---
title: Thread circuits and a broadcast channel in programmable logic
abstract: Embodiments of a message processing circuit are disclosed. In one embodiment, a high-level language is used to specify a broadcast channel and first and second thread circuits. The first thread circuit outputs messages to the broadcast channel, each message having units of data, and starts the second thread circuit, indicating position in a message at which the second thread circuit is to commence reading data. The broadcast channel receives messages from the first thread circuit and outputs data of each message along with a position code indicating position in the message of current output data. The second thread reads data from the broadcast channel at a specified position in a message. The high-level language specification is translated into a hardware description language (HDL) specification, and the HDL specification is used to generate configuration data for programmable logic. Programmable logic is configured to implement the thread circuits and broadcast channel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07823162&OS=07823162&RS=07823162
owner: Xilinx, Inc.
number: 07823162
owner_city: San Jose
owner_country: US
publication_date: 20050225
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","COPYRIGHT NOTICE","REFERENCE TO A COMPUTER PROGRAM LISTING APPENDIX","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE DRAWINGS","OVERVIEW"],"p":["This application is a continuation-in-part application of commonly assigned, co-pending U.S. patent application Ser. No. 10\/769,330, entitled \u201cMethod and Apparatus for Multithreading on a Programmable Logic Device,\u201d invented by Philip B. James-Roxby et al. and filed Jan. 30, 2004, which is incorporated herein by reference in its entirety.","A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","This application includes a computer program-listing appendix on a single compact disc, the contents of which are incorporated herein by reference in their entirety. The compact disc contains a first 1 KB file entitled \u201cAppendix_A.txt\u201d, a second 1 KB file entitled \u201cAppendix_B.txt\u201d, a third 3 KB file entitled \u201cAppendix_C.txt\u201d, a fourth 1 KB file entitled \u201cAppendix_D.txt\u201d, a fifth 3 KB file entitled \u201cAppendix_E.txt\u201d, a sixth 1 KB file entitled \u201cAppendix_F.txt\u201d, and a seventh 34 KB file entitled \u201cAppendix_G.txt\u201d, all of which were created on Feb. 24, 2005.","The present invention generally relates implementing a message processing system on a programmable logic device (PLD) using thread circuits and a broadcast channel.","Programmable logic devices (PLDs) exist as a well-known type of integrated circuit (IC) that may be programmed by a user to perform specified logic functions. There are different types of programmable logic devices, such as programmable logic arrays (PLAs) and complex programmable logic devices (CPLDs). One type of programmable logic device, known as a field programmable gate array (FPGA), is very popular because of a superior combination of capacity, flexibility, time-to-market, and cost.","An FPGA typically includes an array of configurable logic blocks (CLBs) surrounded by a ring of programmable input\/output blocks (IOBs). The CLBs and IOBs are interconnected by a programmable interconnect structure. The CLBs, IOBs, and interconnect structure are typically programmed by loading a stream of configuration data (known as a bitstream) into internal configuration memory cells that define how the CLBs, IOBs, and interconnect structure are configured. Additionally, an FPGA may include embedded memory, such as block random access memories (BRAMs), one or more microprocessors, sometimes referred to as embedded cores, multipliers, transceivers, and digital clock managers (DCMs). The combination of components on an FPGA may be used for system-level integration, sometimes referred to as \u201csystem-on-a-chip\u201d (SOC). Examples of FPGAs include the Virtex-II, Virtex-4, and Spartan families of FPGAs available from Xilinx, Inc.","Historically, FGPAs have not been employed in network processing applications. Rather, network devices, such as routers, employ dedicated, special purpose components for processing packets that propagate through the network. Conventionally, network devices employ network processors or application specific integrated circuits (ASICs) to provide the desirable packet processing\/network processing functions. Such processor- or ASIC-based architectures, however, are static in nature, providing a fixed amount of resources for packet processing\/network processing functions. Accordingly, there exists a need in the art for more flexible message processing architectures.","Various embodiments of the invention are directed to message processing circuitry and implementation techniques. In one embodiment, a high-level language is used to specify a broadcast channel, a first thread circuit, and a second thread circuit. The first thread circuit is specified to output to the broadcast channel a plurality of messages, each message having a plurality of units of data, and start the second thread circuit and indicate a position in a message at which the second thread circuit is to commence reading data. The broadcast channel is specified to receive messages from the first thread circuit and output data of each message along with a position code indicating a position in the message of current output data. The second thread is specified to read data from the broadcast channel at a specified position in a message. The high-level language specification is translated into a hardware description language (HDL) specification, and the HDL specification is used to generate configuration data for programmable logic. Programmable logic is then configured to implement the first and second thread circuits along with the broadcast channel.","In another embodiment, an apparatus is provided for creating a message processing circuit. The apparatus includes means for translating high-level language specifications of a broadcast channel, a first thread circuit, and a second thread circuit into a hardware description language specification; means for generating configuration data for a programmable logic device from the hardware description language specification; and means for configuring a PLD with the configuration data.","To facilitate understanding of the invention, the description has been organized as follows:","Overview, introduces aspects of the invention and exemplary embodiments of their relationships to one another;","Soft Platform, describes a programmable architecture and associated design tool for implementing a message processing system using an integrated circuit;","Memory Model, describes an application-specific programmable memory architecture and interconnection network for an integrated circuit;","Multithread Model, describes an inter-process synchronization mechanism for threads implemented within a configurable logic portion of an integrated circuit; and","Programming Interface, describes a programming interface for a design tool embodying a soft architecture for implementing a message processing system using an integrated circuit.","One or more aspects of the invention are related to a configurable and programmable micro-architecture for implementing message-processing (MP) systems (\u201csoft platform architecture\u201d). As used herein, the term \u201cmessage\u201d encompasses packets, cells, frames, data units, and like type blocks of information known in the art that is passed over a communication channel. A \u201cmessage-processing\u201d system is a system or subsystem for processing messages (e.g., a packet processing system or a network processing system). The soft platform architecture is \u201cmessage-centric\u201d to match the nature of MP systems. That is, the processing components of the MP system go to the messages, as opposed to the messages coming to the processing components.","In one embodiment of the invention, an MP system may be implemented using a plurality of threads and a broadcast channel. Each of the threads processes a respective portion of a multi-word message, and the broadcast channel is used to transmit the message to the threads. One of the threads receives an input message and writes data from the message to the broadcast channel. This thread may be referred to as the broadcaster thread. The broadcast channel receives as input one word at a time and outputs two words at a time. The broadcast channel indicates which words of the message are present on the channel by outputting a message-relative offset of the first-transmitted word of the two-word pair. A receiver thread may read data from the broadcast channel when desired words of the message are present on the channel as indicated by the offset provided by the channel.","Briefly stated, a designer specifies attributes for an MP system, such as structural and behavioral attributes for processing components and memory components. For example, the designer may employ a set of descriptions or \u201cprimitives\u201d that parametrically define the MP system attributes. The primitives provide an abstract mechanism for defining the MP system. A design tool embodying the soft platform architecture may include a programming interface for generating a logical description or \u201clogical view\u201d of an MP system based on the designer-specified attributes.","Notably, the logical view includes logical components of the soft platform architecture configured in accordance with the designer-specified MP system. In particular, the soft platform architecture includes a memory model component and a multithreading component. A physical view of the MP system may then be generated based on the logical view. The physical view includes physical components of an integrated circuit architecture that implement the logical components of the soft platform architecture. The physical view may then be processed to generate configuration data for the integrated circuit to realize the designer-specified MP system (e.g., a configuration bitstream for a PLD or mask data for an ASIC). Thus, the soft platform architecture provides a mechanism by which a designer may design an MP system in an abstract fashion, without knowledge of the particular physical configuration of the integrated circuit.","One or more aspects of the invention are described with respect to a programmable architecture for implementing a message processing system using an FPGA. While the invention is described with specific reference to an FPGA, those skilled in the art will appreciate that other types of programmable logic devices may be used, such as complex programmable logic devices (CPLDs). In addition, other types of mask-programmable devices may be used, such as application specific integrated circuits (ASICs). Those skilled in the art will appreciate that, if an ASIC is employed rather than an PLD, then mask data is generated in place of a configuration bitstream.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 1","b":["102","150","120","150","150","150","102","150","102"]},"The FPGA  illustratively comprises programmable logic circuits or \u201cblocks\u201d, illustratively shown as CLBs , IOBs , and programmable interconnect  (also referred to as \u201cprogrammable logic\u201d), as well as configuration memory  for determining the functionality of the FPGA . The FPGA  may also include an embedded processor block , as well as various dedicated internal logic circuits, illustratively shown as blocks of random access memory (\u201cBRAM \u201d), configuration logic , digital clock management (DCM) blocks , and input\/output (I\/O) transceiver circuitry . Those skilled in the art will appreciate that the FPGA  may include other types of logic blocks and circuits in addition to those described herein.","As is well known in the art, the IOBs , the CLBs , and the programmable interconnect  may be configured to perform a variety of functions. Notably, the CLBs  are programmably connectable to each other, and to the IOBs , via the programmable interconnect . Each of the CLBs  may include one or more \u201cslices\u201d and programmable interconnect circuitry (not shown). Each CLB slice in turn includes various circuits, such as flip-flops, function generators (e.g., a look-up tables (LUTs)), logic gates, memory, and like type well-known circuits. The IOBs  are configured to provide input to, and receive output from, the CLBs .","Configuration information for the CLBs , the IOBs , and the programmable interconnect  is stored in the configuration memory . The configuration memory  may include static random access memory (SRAM) cells. The configuration logic  provides an interface to, and controls configuration of, the configuration memory . A configuration bitstream produced from the program memory  may be coupled to the configuration logic  through a configuration port . The configuration process of FPGA  is also well known in the art.","The I\/O transceiver circuitry  may be configured for communication over any of a variety of media, such as wired, wireless, and photonic, whether analog or digital. The I\/O transceiver circuitry  may comprise gigabit or multi-gigabit transceivers (MGTs). The DCM blocks  provide well-known clock management circuits for managing clock signals within the FPGA , such as delay lock loop (DLL) circuits and multiply\/divide\/de-skew clock circuits.","The processor block  comprises a microprocessor core, as well as associated control logic. Notably, such a microprocessor core may include embedded hardware or embedded firmware or a combination thereof for a \u201chard\u201d or \u201csoft\u201d microprocessor. A soft microprocessor may be implemented using the programmable logic of the FPGA  (e.g., CLBs , IOBs ). For example, a Microblaze\u2122 soft microprocessor, available from Xilinx\u00ae of San Jose, Calif., may be employed. A hard microprocessor may be implemented using an IBM Power PC, Intel Pentium, AMD Athlon, or like type processor core known in the art.","The processor block  is coupled to the programmable logic of the FPGA  in a well known manner. For purposes of clarity by example, the FPGA  is illustrated with 12 CLBs, 16 IOBs, 4 BRAMs, 4 DCMs, and one processor block. Those skilled in the art will appreciate that actual FPGAs may include one or more of such components in any number of different ratios. For example, the FPGA  may be selected from the Virtex\u2122-II Pro family of products, commercially available from Xilinx\u00ae of San Jose, Calif.","One or more aspects of the invention include design tools for designing MP systems, memory systems, and multithreading systems. Such design tools may be implemented using a computer. Notably,  is a block diagram depicting an exemplary embodiment of a computer  suitable for implementing processes, methods, and design tool sections described herein. The computer  includes a central processing unit (CPU) , a memory , various support circuits , and an I\/O interface . The CPU  may be any type of microprocessor known in the art. The support circuits  for the CPU  include conventional cache, power supplies, clock circuits, data registers, I\/O interfaces, and the like. The I\/O interface  may be directly coupled to the memory  or coupled through the CPU . The I\/O interface  may be coupled to various input devices  and output devices , such as a conventional keyboard, mouse, printer, display, and the like.","The memory  may store all or portions of one or more programs and\/or data to implement the processes, methods, and design tool sections described herein. Although one or more aspects of the invention are disclosed as being implemented as a computer executing a software program, those skilled in the art will appreciate that the invention may be implemented in hardware, software, or a combination of hardware and software. Such implementations may include a number of processors independently executing various programs and dedicated hardware, such as ASICs.","The computer  may be programmed with an operating system, which may be OS\/2, Java Virtual Machine, Linux, Solaris, Unix, Windows, Windows95, Windows98, Windows NT, and Windows2000, WindowsME, and WindowsXP, among other known platforms. At least a portion of an operating system may be disposed in the memory . The memory  may include one or more of the following random access memory, read only memory, magneto-resistive read\/write memory, optical read\/write memory, cache memory, magnetic read\/write memory, and the like, as well as signal-bearing media as described below.","An aspect of the invention is implemented as a program product for use with a computer system. Program(s) of the program product defines functions of embodiments and can be contained on a variety of signal-bearing media, which include, but are not limited to: (i) information permanently stored on non-writable storage media (e.g., read-only memory devices within a computer such as CD-ROM or DVD-ROM disks readable by a CD-ROM drive or a DVD drive); (ii) alterable information stored on writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive or read\/writable CD or read\/writable DVD); or (iii) information conveyed to a computer by a communications medium, such as through a computer or telephone network, including wireless communications. The latter embodiment specifically includes information downloaded from the Internet and other networks. Such signal-bearing media, when carrying computer-readable instructions that direct functions of the invention, represent embodiments of the invention.","Soft Platform",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 2","b":["200","200","202","204","206","204","208","208"]},"Notably, the FPGA circuit design may be \u201cinterface-centric\u201d in that the circuit design is driven by the behavior at the system interfaces, as opposed to the \u201cprocessor-centric\u201d model, where the circuit design is driven by the behavior of an embedded processor. The interface-centric circuit design model matches well with the message-centric style of the soft platform architecture. Placement and usage of interfaces, memories, and their interconnections dominate the allocation of FPGA architecture features, and then allocation of functional elements (e.g., programmable logic, embedded processors) for the process components follow as a derivative.","More specifically, the input section  is coupled to one or more input devices  and a database storing an application programming interface (API) (\u201cAPI database \u201d). The API database  includes a set of primitives associated with structural and behavioral attributes of the soft platform architecture. Thus, the API provides a \u201cprogramming interface\u201d for the soft platform architecture. An exemplary embodiment of a programming interface for a soft platform architecture is described below in the section entitled \u201cPROGRAMMING INTERFACE.\u201d Using the input devices , a designer may interact with the input section  to produce specification data for an MP system or subsystem if the MP circuit is part of a larger system (hereinafter referred to as an \u201cMP system\u201d).","Notably, in one embodiment, a designer may use the primitives in the API database  directly to produce the MP system specification data for the soft platform architecture. In another embodiment, a designer may design the MP system using alternate constructions provided by the input section . That is, the input section  may comprise a design entry tool specific to the MP domain. Examples of such MP-specific design-entry tools include Click (available from The Massachusetts Institute of Technology), Rave (available from Cloudshield\u2122 of Sunnyvale, Calif.), and SDL (a telecom standard from ITU-T). The input section  may then map the MP system specified using the alternate constructions onto the primitives in the API database  for the soft platform architecture. Thus, the input section  may provide a different level of abstraction than that provided by the soft platform architecture.","In one embodiment of the invention, the MP system specification data may comprise program code for programmatically interacting with the soft platform section . The program code may be callable by an external design tool of the input section . In another embodiment, the MP system specification data may comprise interpretive descriptions (e.g., descriptions in a textual or binary format) that the soft platform section  may interpret (e.g., an XML format). In either embodiment, the MP system specification is used to configure the soft platform architecture.","The soft platform section  is coupled to the input section  for receiving the MP system specification data. The soft platform section  is also coupled to a database storing the features or attributes of the soft platform architecture (\u201csoft platform database \u201d), and a database storing features or attributes of the architecture of the FPGA  (\u201cFPGA database \u201d).","The soft platform section  includes a first portion  for generating a logical description or \u201clogical view\u201d of an MP system in accordance with the MP system specification. The logical view is defined in terms of the logical components of the soft platform architecture stored in the soft platform database . The soft platform section  includes a second portion  for generating a physical view of the MP system. Notably, using information in the FPGA database , the soft platform section  maps the logical view of the MP system defined in terms of the soft platform architecture onto the architecture of the FPGA . The soft platform section  provides FPGA design data as output, which represents a \u201cphysical view\u201d of the MP system in terms of the architecture of the FPGA . Details of the soft platform architecture are described below with respect to .","The FPGA design tools section  is coupled to the soft platform section  for receiving the FPGA design data. The FPGA design data may comprise a physical description of the MP system specified by the designer in terms of the components and features of the FPGA . For example, in one embodiment, the FPGA design data may comprise a hardware description language (HDL) representation of the MP system design (e.g., Very high-speed integrated circuit description language (VHDL) or Verilog). The FPGA design tools section  processes the FPGA design data to produce configuration bitstream data. For example, the FPGA design tools section  may comprise various well-known FPGA design tools, such as a synthesis tool, a map\/place\/route tool, like-type tools known in the art. The FPGA design tools section  provides configuration bitstream data as output, which may be loaded into the FGPA .",{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 3","FIG. 2"],"b":["300","300","200","300","302","304"]},"At step , a logical view of the MP system is generated in accordance with the MP system specification. As described above, the logical view of the MP system is defined in terms of a soft platform architecture. The logical components of the soft platform architecture are configured in accordance with the MP system specification to generate the logical view of the MP system. The term \u201clogical components\u201d refers to both the structural and behavioral attributes of the soft platform architecture, described in more detail below.","At step , the logical view of the MP system is mapped onto an FPGA architecture to produce FPGA design data. That is, the logical components comprising the logical view are linked to physical components of an FPGA and, optionally, other devices connected to the FPGA (e.g., external memories). In one embodiment of the invention, the FPGA design data comprises an HDL representation of the MP system design. As described above, the FPGA design data provides a physical view of the specified MP system in terms of the architecture of the FPGA. That is, FPGA design data corresponds to the physical implementation of the logical view of the MP system on an FPGA device.","At step , the FPGA system design is processed to produce configuration bitstream data. For example, if the FPGA system design comprises an HDL representation of the MP system design, the FPGA system design may be synthesized, mapped, placed, and routed in a well-known manner to produce bitstream data for configuring an FPGA. At step , the configuration bitstream data is loaded into an FPGA to realize the MP system specified at step . The process  ends at step .",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 4","b":["400","400","402","403","410","402","403","410","402","403","410","402","403","410"]},"Notably, the soft platform architecture  includes a programming\/control interface  and a debug\/test\/monitor interface . The programming\/control interface  conveys the data for configuring the programmable portions of the soft platform architecture . The programming\/control information conveyed via the programming\/control interface  comprises the structural and behavioral information related to the MIS component , the process component , and the SSS component . An exemplary embodiment of a programming interface to the soft platform architecture  is described below in the section entitled \u201cPROGRAMMING INTERFACE.\u201d The debug\/test\/monitor interface  may be used during the design and implementation of an MP system defined in terms of the soft platform architecture . The interfaces  and  are illustrative, as there may be a single shared interface, or more than two interfaces.","The MIS component  is the logical storage point for all messages currently within the system implemented using the soft platform architecture . The MIS component  includes an interface  to the enclosing environment  allowing for the input and output of messages. For example, the soft platform architecture  may be configured to produce an internet protocol (IP) packet router. The MIS component  may be configured to store all IP packets currently in flight through the router. The interface  may be one or more ports by which the router is connected to a physical network.","The MIS component  may be physically implemented using a centralized memory device, a plurality of distributed memory devices, or a combination thereof. In addition, the types, sizes, and interconnections of the physical memory elements, as well as the interface to such physical memory elements, are programmable through configuration of the MIS component . An exemplary embodiment of a logical memory configuration that may be used as the MIS component  is described below in the section entitled \u201cMEMORY MODEL.\u201d","The process component  comprises one or more processes that may be classified as fine grain operations processes (FOPs) , coarse grain operations processes (COPs) , or perimeter interface processes (PIPs) . In addition, the process component  includes an inter-process synchronization component . The FOPs , COPs , and PIPs  operate on messages stored within the MIS component . The term \u201cprocess,\u201d as used herein, denotes a concurrent agent for operating on information stored within the MIS component . The term \u201cthread\u201d is used to denote an instance of a process.","Notably, each single execution of a process within the process component  is associated with a message stored in the MIS component  through a message context . A process in the process component  may be physically implemented directly in programmable logic of an FPGA, or in a soft or hard embedded processor of an FPGA. In one embodiment of the invention, the message context  may be implemented using a data counter (DC) component . The DC component  points to the current position in the current message being operated on by a particular process in the process component . As the process executes, the DC component  may be updated, either automatically to advance to the next position in a message, or by execution of programmed \u201cdata jumps.\u201d In essence, the process moves over the message. The DC component  may be physically implemented using a memory element within the FPGA capable of storing an address associated with the location of a message in the memory of the MIS component . Depending on the memory organization of the MIS component , the DC component  may be a register, a BRAM, or an external RAM.","The processes of the process component  include a common interface. The inter-process communication component  may utilize the common interface to allow interaction between processes of the process component . Such interactions may include, for example, creating or destroying a process or passing data to another process. The inter-process communication component  provides for a control flow in the processing of a message. At a microscopic level, the inter-process communication component  is capable of providing a control flow within a single process's execution. At a macroscopic level, the inter-process communication component  is capable of providing a control flow from one process's execution to another process's execution. An exemplary embodiment of a multithread model that may be used as the inter-process communication component  is described below in the section entitled \u201cMULTITHREAD MODEL.\u201d","A FOP  is the basic programmable unit for message processing. A FOP  performs a sequence of steps on a message stored within the MIS component . At each step, a set of concurrent operations are performed. A FOP  may be associated with a DC component . After each step, the DC component  may be incremented, or a data jump operation performed, such that the FOP  accesses a new portion of the message. The steps, as well as the operations performed during each step, may be programmable, static, or partially programmable and partially static in their definition. Examples of operations include, inspecting a field (e.g., a 16-bit header field) of a message, or performing simple arithmetic (e.g., adding one to a 16-bit header field) on a message.","A FOP  may be implemented within an FPGA using programmable logic. For example, a FOP may be implemented as a finite state machine (FSM) configured within the programmable logic of the FPGA. Alternatively, a FOP may be implemented on an embedded processor within an FPGA. For example, a FOP may be implemented as an operating system thread executed by the embedded processor. The physical implementation of a FOP  may be programmable, static, or partially programmable and partially static in its definition.","A COP  is used to incorporate a function block to perform a message processing operation. A function block may comprise a circuit or subsystem defined outside the context of the soft platform architecture . For example, the function block may comprise a reusable intellectual property (IP) core for an FPGA. A COP  provides a programmable adapter between the interface of the function block and the common interface of the process component . A COP  may be started, stopped, or interrupted by another process of the process component .","A COP  may be defined statically and be in existence permanently. Alternatively, a COP  may be created and destroyed dynamically to allow dynamic reconfiguration of the function blocks associated therewith. For example, a COP  may be used to incorporate a function block for compression or encryption of all or part of a message stored in the MIS component . A COP  may be associated with a DC component , which points to the beginning of the message in the MIS component  to be processed by the COP .","A PIP  is concerned with enabling the movement of a message to and from soft platform architecture . In one embodiment of the invention, a PIP  may be used to incorporate a function block, similar to a COP . The function block associated with a PIP  may comprise a circuit or subsystem defined outside the context of the soft platform architecture  that is specifically geared to perform I\/O functions. In another embodiment of the invention, a PIP  may be implemented as a FSM in programmable logic of the FPGA.","For example, a PIP may be used to receive or transmit successive words of a message over an interface using a protocol defined for the interface. For example, a PIP may act as a smart adapter for the Xilinx\u00ae LocalLink interface to a networking core or the interface to a Gigabit MAC core. A PIP may also communicate with other system components implemented within the FPGA.","The SSS component  may be used to store state information associated with the processes of the process component . For example, the SSS component  may be used to store a message context  for a FOP . The SSS component  may be physically implemented using a centralized memory device, a plurality of distributed memory devices, or a combination thereof.","Memory Model",{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 5","b":["500","500","502","504","504"]},"In particular, the input section  is coupled to a database that stores an API associated with the memory model, referred to herein as the memory interconnection description language (MIDL) library . The MIDL library  comprises a set of primitives for defining structural and behavioral attributes of the memory model. Thus, the MIDL library  provides a programming interface for the memory model. A designer may interact with the input section  to produce specification data for a memory subsystem. The designer may work directly with the MIDL library , or may work indirectly with the MIDL library  through an alternative design tool defined within the input section . The memory subsystem specification data may be programmatic or may be interpretive (e.g., XML). An example of an MIDL specification for a 32-bit wide memory constructed from two 16-bit wide memories, which are in turn mapped to physical BRAM in an FPGA, is shown in the appendix file \u201cAppendix_A.txt\u201d.","The memory model section  is coupled to the input section  for receiving the memory model specification. The memory model section  is also coupled to a database that stores the features or attributes of the memory model (\u201cmemory model database \u201d), and a database that stores the memory attributes of an FPGA and external memories associated therewith (\u201cFPGA memory database \u201d). The memory model section  includes a first portion  for generating a logical view of a memory subsystem in accordance with the memory subsystem specification. The logical view is defined in terms of the logical components of the memory model stored in the memory model database .","The memory model section  may include an analysis\/optimization portion  for analyzing and optimizing the logical view of the memory subsystem in accordance with constraint data provided by a designer. The memory model section  further includes a second portion  for generating a physical view of the memory system based on the logical view. Notably, using information in the FPGA memory database , the memory model section maps the logical view of the memory subsystem onto the physical memory components associated with an FPGA. The memory model section  provides FPGA design data as output.",{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 6","b":["600","600","602","604","606","602","602","604","602","608","602","604","606","602","610","610","602","606"]},"The memory model  is characterized by a \u201cmemory architecture\u201d and a \u201cmemory-interconnection architecture.\u201d The memory architecture pertains to the size, type, and topology of one or more memory circuits comprising the memory element . The memory-interconnection architecture pertains to the type, bus width (e.g., number of wires), and topology of interconnection (e.g., crossbar) of the one or more memory circuits comprising the memory element . In general, with respect to the memory model , the term \u201cinterface\u201d imparts knowledge related to the protocols that must be adhered to for the particular interaction, whereas the term \u201carchitecture\u201d imparts knowledge related to the critical path that particular data follows within the memory model .","The memory and interconnection architectures of the memory model  may be defined by the physical location of the memory circuits used to implement the model, as well as the logical configuration of the interface to such memory circuits. For example, the memory may be physically centralized (i.e., a single physical memory circuit), or several memory circuits may be physically distributed. The memory circuit(s) used to implement the memory model  may be disposed within the FPGA (e.g., any combination of on-chip BRAMs, LUT-based RAMs, and shift registers), disposed external to the FPGA (e.g., external SDRAMs, DDR SDRAMs, and RDRAMs), or a combination thereof. In addition, the interface to such memory circuit(s) may be logically centralized (e.g., a unified programming interface) or logically distributed (e.g., multiple logical interfaces).","In light of the various physical and logical configurations for the memory and interconnection architectures, various logical schemes for storing messages may be implemented using the memory model . In one embodiment, all messages may be stored within a single memory (e.g., a queue of messages in a memory) (\u201cuniform message storage\u201d). Alternatively, different messages may be allocated over different memories (\u201cinterleaved message storage\u201d). In yet another alternative, each message may be physically allocated over different memories (\u201cstriped message storage\u201d). In another embodiment, each message may be logically allocated over different memories (\u201cseparated message storage\u201d).  depict examples of memory subsystems illustrating exemplary configurations for the memory and interconnection architectures with respect to the storage of messages in a system. Those skilled in the art will appreciate that many other configurations for the memory and interconnection architectures may be employed in accordance with the above attributes, of which  are examples.","In particular,  is a block diagram depicting an exemplary embodiment of a memory subsystem  that may be implemented using the memory model . The memory subsystem  illustratively comprises a set of BRAMs through , where N is an integer greater than one (collectively referred to as BRAMs ). The BRAMs  may be disposed within an FPGA. Each of the BRAMs  includes a memory interface . The memory interface  of each of the BRAMs  is configured for communication with a computational element . For example, each of the computational elements  may comprise an instance of a process (e.g., a thread) within the soft platform architecture described above. Each of the BRAMs  includes a second interface for receiving incoming message data.","Notably, an incoming message may be \u201cstriped\u201d across the BRAMs  such that each of the BRAMs  stores only a portion of the incoming message. Each of the computational elements  may then access respective ones of the BRAMs  through the respective memory interface  to access a portion of the incoming message. The memory subsystem  is an example of striped message storage using physically distributed memories within an FPGA.",{"@attributes":{"id":"p-0093","num":"0092"},"figref":"FIG. 10","b":["1000","600","1000","1002","1002","1002","1002","1002","1004","1004","1006","1004"],"sub":["1 ","N"]},"The BRAMs  are logically part of one centralized memory with a dedicated memory interface  that manages access to the messages stored in the BRAMs . Each of the computational elements  may access a message or portion thereof through the memory interface . The memory subsystem  is an example of a logically centralized, physically distributed memory organization.","Returning to , the memory and interconnection interfaces in the memory model  may be defined in accordance with various configurable attributes, such as the number of ports to a memory and the width of each port. In addition, the memory model  may be configured to provide a reactive memory subsystem, such as a cooperative memory subsystem.","Notably,  is a block diagram depicting an exemplary embodiment of a cooperative memory interface  that may be implemented using the memory model . Cooperative memories are memories that do not just stall or block when data is not available, but rather respond back with a message, such as \u201cdata will be available in three cycles.\u201d As shown, the memory element  comprises a memory , control logic , and interface logic . The interface logic  is coupled to the computational element  via a data bus , a control bus , and a status bus . The data bus  has a width of n, the control bus  has a width of m, and the status bus  has a width of k. In general, the width of the control bus  and the width of the status bus  will be much less than the width of the data base . For purposes of clarity by example, the data bus , the control bus , and the status bus  are shown as separate buses. It is to be understood, however, that the data bus , the control bus , or the status bus , or any combination thereof, may be multiplexed within the interface logic  over the same physical bus.","The computational element  requests data using the control bus . The control logic  determines whether the data is available within the memory . If so, the data is communicated to the computational element  over the data bus . Otherwise, the control logic  generates a status signal for communication to the computational element  over the status bus . The status signal may indicate the unavailability of the requested data and an estimated duration after which the data will be available.",{"@attributes":{"id":"p-0098","num":"0097"},"figref":["FIG. 7","FIG. 6"],"b":["700","700","600","700","702","704","600"]},"At step , a logical view of the memory subsystem is generated in accordance with the memory subsystem specification. The logical view is defined in terms of the memory model . That is, the logical components of the memory model  are configured in accordance with the memory subsystem specification to generate a logical view of the memory subsystem.","At step , the memory subsystem may be analyzed and optimized in accordance with predefined constraint and test data. The constraint data may include constraints on memory access, time, and interconnect resources. The test data may include one or more test memory access patterns. In one embodiment of the invention, an analysis model based on memory access, time, and interconnect resources is employed.","Notably,  is a graph  illustrating an exemplary embodiment of a memory analysis model. The graph  includes an axis  representing abstract memory addresses, an axis  representing abstract time, and an axis  representing interconnect resources. The graph  depicts an exemplary access pattern comprising a plurality of points . Each point  signifies a memory access corresponding to a particular memory location (address) at a particular time that utilizes a particular interconnect resource. For example, the exemplary access pattern may result from a burst of packets entering the memory subsystem, followed by some header manipulation, and a burst of packets exiting the memory subsystem. The predefined constraint data is shown superimposed over the graph  as a cuboid . If all points  are within the cuboid , the access pattern is valid. Otherwise, an optimization is required to satisfy the constraints.","Returning to , at step , the logical view of the memory subsystem is mapped onto an FPGA architecture to produce FPGA design data. That is, the logical components comprising the logical view are linked to physical memory components of an FPGA and, optionally, other memory devices connected to the FPGA. The FPGA design data provides a physical view of the specified memory subsystem in terms of the memory architecture of the FPGA. That is, FPGA design data corresponds to the physical implementation of the logical view of the memory subsystem defined using the MIDL. In one embodiment of the invention, the FPGA design data comprises an HDL representation of the MP system design.","At step , the FPGA design data may be combined with other FPGA design data to define a system. For example, the memory subsystem may be incorporated into an MP system designed as described above in the section entitled \u201cSOFT PLATFORM.\u201d That is, the memory subsystem may be the implementation of the MIS component of the soft platform architecture used to implement an MP system.","At step , the combined FPGA design data is processed to produce configuration bitstream data. For example, if the combined FPGA design data comprises an HDL representation, the FPGA design data may be synthesized, mapped, placed, and routed in a well-known manner to produce bitstream data for configuring an FPGA. At step , the configuration bitstream data is loaded into an FPGA. The process  ends at step .","Multithread Model",{"@attributes":{"id":"p-0105","num":"0104"},"figref":"FIG. 12","b":["1200","1200","1202","1204","1204"]},"In particular, the input section  is coupled to a database that stores a library of multithreading primitives (\u201cmultithread primitive database \u201d). The multithread primitive database  stores a set of primitives for defining structural and behavioral attributes of the multithread model. Thus, the multithread primitive database  provides a programming interface for the multithread model. Notably, the multithread primitive database  includes primitives for starting a thread, stopping a thread, suspending a thread, as well as synchronization of such starting, stopping, and suspending among threads. In addition, primitives are provided for indicating status information for individual threads, such as completion or suspension, among other threads. Furthermore, primitives may be provided for allowing data communication among threads.","A designer may interact with the input section  to produce specification data for a multithreading system. The designer may work directly with the multithread primitive database , or may work indirectly with the multithread primitive database  through an alternative design tool defined within the input section . The multithreading system specification data may be programmatic or may be interpretive (e.g., XML).","The multithread model section  is coupled to the input section  for receiving the multithreading system specification data. The multithread model section  is also coupled to a database that stores the features or attributes of the multithread model (\u201cmultithread model database \u201d), and a database that stores the physical attributes of an FPGA (\u201cFPGA database \u201d). The multithread model section  includes a first section  for generating a logical view of the multithreading system in accordance with the multithreading system specification. The logical view is defined in terms of the logical components of the multithread model stored in the multithread database . The multithread model section  includes a second portion  for generating a physical view of the multithreading system based on the logical view. Notably, using information in the FPGA database , the multithread model section  maps the logical view of the multithreading system onto the physical components associated with an FPGA. The multithread model section  provides FPGA design data as output.",{"@attributes":{"id":"p-0109","num":"0108"},"figref":"FIG. 13","b":["1300","1300","1302","1304","1306","1308","1310","1312","1314","1304","1306","1308","1302","1312","1314","1302","1302","1302","1300"]},"Notably, the thread model  may be physically implemented in programmable logic of an FPGA as a synchronous FSM. That is, a clock drives the state machine's transitions and, within each state of the state machine, operations are performed on operands producing outputs. In another embodiment, the thread model  may be implemented using a microcontroller embedded within an FPGA. In yet another embodiment, the thread model  may be implemented using a hard or soft microprocessor embedded within an FPGA.","The thread  includes control logic  for processing data and producing control state data  and operation state data . The control state data  captures the state of the thread  in terms of inter-thread communication (e.g., the thread is finished or suspended). The operation state data  captures the internal state of the thread , which is defined in accordance with the operation of the control logic .","In one embodiment of the invention, the thread  includes an IDLE control state that corresponds to the thread  not currently carrying out any operation. During the IDLE control state, the is Finished terminal  is asserted to indicate that the thread  is not doing any work. If the start terminal  is asserted, the thread  moves out of the IDLE control state and performs the various operations that the thread  is configured to perform. The is Finished terminal  is no longer asserted to indicate that the thread  is in operation. Asserting the stop terminal  returns the thread  to the IDLE control state, terminating all operations. Asserting the suspend terminal  causes the thread  to remain in its current operation state, regardless of how many clock cycles occur on the clock terminal . The suspend terminal  may be used during debugging or testing through an external agent. The is Suspended terminal  is asserted while the thread  is suspended.","The operation state data  depends on the operational configuration of the control logic  of the thread  in accordance with specification data provided by a designer. That is, the control logic  of the thread  is configured to execute a series of steps, where one or more operations are performed at each step. In one embodiment, the thread  may be designed to have one or more designated terminal operation states that cause the thread  to enter the IDLE control state and assert the is Finished terminal . Alternatively, there may be no such designated terminal control states, in which case the thread is control externally by asserting the stop signal.","For example, a VHDL code fragment for implementing the thread  may be:",{"@attributes":{"id":"p-0115","num":"0114"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"a. update : process (clk, stopThread)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"i.","begin -- process update"]},{"entry":[{},"ii.","if stopThread = \u20181\u2019 then"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"1. state <= idle;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"iii.","elsif clk'event and clk = \u20181\u2019 and suspendThread = \u20180\u2019 then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"1. state <= nextState;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"iv.","end if;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"b. end process update;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"where the thread  is implemented as a state machine. In this example, the IDLE control state is implemented as an extra state added to the internal operation state set of the thread. While there is no explicit suspend control state, the suspend mechanism may be implemented by driving the suspend terminal  to prevent the calculated nextState from being latched into the state machine's register. Thus, the thread will remain in the current operation state, with no forward progress. For purposes of clarity by example, the implications for the values of outputs from the state are not shown explicitly in the above exemplary VHDL code fragment.","The thread  has thus far been described with respect to an external agent that asserts the start, stop, and suspend terminals. The \u201cexternal agent\u201d may be another thread, thus allowing threads to control other threads. In order to enable one thread to write or read the signals of another thread, the multithread model employs an interconnection topology and an addressing mechanism. That is, a plurality of threads are interconnected for communication amongst themselves, and a thread may associate the address of another thread with its collection of input and output signals.","Notably,  is a block diagram depicting an exemplary embodiment of a multithread model  in accordance with one or more aspects of the invention. The multithread model  comprises a set of thread models through , where N is an integer greater than one (collectively referred to as thread models ). The multithread model  also includes an interconnection component . Each of the thread models  includes an input bus  and an output bus . The input bus  and the output bus  of each of the thread models  are in communication with the interconnection component . In one embodiment, the interconnection component  facilitates complete point-to-point communication of control, status, and\/or data among the thread models .","In one embodiment of the invention, the output bus  of a thread model  comprises a start control bus , a stop control bus , a suspend control bus , and a status bus . The width of each of the start control bus  and the stop control bus  is N (i.e., the number of thread models  in the multithread model ). The width of the suspend control bus  may be N\u22121 if self-suspension of a thread is not defined. The status bus  may comprise M status signals (e.g., is Finished and is Suspended signals) and thus the width of the status bus  is M. The input bus  of a thread model  comprises a start terminal , a stop terminal , and a suspend terminal .","In one embodiment of the invention, each of the thread models  produces a control signal for each of the other thread models  (e.g., thread model produces control signals for thread models through ) through operation of control logic . Thus, if there are eight thread models  in the multithread model , then each thread model  will produce eight start signals, eight stop signals, and seven suspend signals in accordance with the control logic . For each of the thread models , start signal and one stop signal is connected in a self-loop, which allows a thread model  to start and stop itself. The interconnection component  facilitates the connection between the output bus  of a given thread model and the input buses of each of the other thread models.",{"@attributes":{"id":"p-0121","num":"0120"},"figref":"FIG. 14B","b":["1431","1432","1434","1436","1438","1440","1431","1432","1440","1434","1436","1438"]},"The broadcaster thread  writes a multi-word message to the broadcast channel  one word at a time. Because certain applications may have a set of bytes that are not word aligned within a message, the broadcast channel is implemented to output two words at a time in one embodiment. This allows a reader thread (e.g., , , or ) to read a set of bytes that is not word aligned within the message.","Along with each two-word portion of the message output by the broadcast channel , the broadcast channel indicates the words of the message that are available for reading, for example, with a message-relative offset value. A reader thread, once started, waits for the message-relative offset value to match a desired value and reads the data from the channel in response to a match. In one embodiment, when one thread starts another thread it may also specify an offset address to indicate a message-relative position of the data that that started thread is to read.",{"@attributes":{"id":"p-0124","num":"0123"},"figref":"FIG. 14C","b":["1440","1432","1434"]},"The data-in port may be configured to accept one word of data in an example embodiment. The examples described herein have one word being 4 bytes. To accommodate multi-word messages, the start-data port receives a signal whose state indicates the presence of the first word of a message at the data-in port. The valid-in port is used to indicate when valid data is present at the data-in port for registration by the broadcast channel.","The CHAN_data port drives two words of message data, and the CHAN_addr port indicates which words of the message are at the CHAN_data port. The CHAN_valid port drives a two-bit signal to indicate validity of the words at the CHAN-_data port. The operation of the broadcast channel is illustrated in the example of , which is explained below.","The broadcaster thread may also be configured to provide a start-thread signal (line ) to reader thread . The start-thread signal causes the reader thread to begin monitoring the broadcast channel  for desired data within a message.","The broadcaster thread may also provide an offset value (line ) to the reader thread. The offset value may be used by the reader thread in combination with the CHAN_addr value from the broadcast channel to select the appropriate bytes of data on data-out.",{"@attributes":{"id":"p-0129","num":"0128"},"figref":"FIG. 14D","b":["1452","1454","1456","1458","1460","1462","1464"]},"The values in the data-in and CHAN_data rows , , and  are in hexadecimal format. A logic value \u201c1\u201d is driven at the start-data port during cycle  to indicate that the data \u201caabbccdd\u201d begins a new message. Because the CHAN_data port drives two-words of data while the data-in port receives only one word of input data, the initial value in word  (row ) of CHAN_data is \u201c00000000\u201d. The first input value \u201caabbccdd\u201d is driven as word  on data-out (row ).","The CHAN_addr port value is decimal  in cycle . This indicates that byte  of the message is the start of the current word of the message, which is present in word  of CHAN_data. The two-bit CHAN_valid port drives \u201c01\u201d in cycle , which indicates that on the CHAN_data port, word  is invalid and word  is valid.","At cycle , \u201ceeff000d\u201d is received at the data-in port, and the start-data signal goes to logic \u201c0.\u201d The first word of the message is driven on word  of CHAN_data, and the second word \u201ceeff000d\u201d is driven on word  of CHAN_data. The CHAN_addr value is set to 4, which indicates that byte  of the message is the start of the current word in word  of CHAN_data. The valid-out port drives \u201c11\u201d indicating that both words  and  of CHAN_data are valid.","The start-data signal remains logic \u201c0\u201d in remaining cycles until the first word of a new message is provided at data-in.","Appendix file \u201cAppendix_C.txt\u201d illustrates VHDL for implementing an example broadcast channel in accordance with various embodiments of the invention.",{"@attributes":{"id":"p-0135","num":"0134"},"figref":"FIG. 15","b":["1500","1400","1500","1502","1502","1502","1504","1502","1506","1502","1504","1506","1502","1508","1504","1508","1502","1502","1510","1508"],"sub":["1 ","4 ","1 ","1"]},"Notably, if it is not intended that a particular one of the threads  control the starting of the thread , then the start control terminal  is not asserted. If one of the threads  intends to start the thread , the start control terminal  of that thread is asserted. For example, if the thread intends to start the thread , then the thread asserts its start control terminal . The start control terminals  are logically OR-ed together by the OR component  such that if one or more is asserted, the thread will be started. For purposes of clarity by example, a synchronization mechanism for starting the thread is shown. It is to be understood, however, that the multithread system  may be extended to start, stop, and suspend any number of threads.","Returning to , the output bus  of a thread model  may include a data bus . Data may be communicated amongst the thread models  through the interconnection component . In one embodiment of the invention, the data bus  may comprise a bus for each of the thread models  in the multithread model . For example, if the thread model intends to send data to the thread model , then the thread model communicates the data over the bus associated with the thread model . The validity of the data may be assured by timing, with each of the thread models  designed such that the consumer of the data does not access the data until it has been written. Alternatively, a validity flag  may be employed to indicate valid data.","In yet another embodiment, each of the thread models  may include an identifier  (e.g., a memory address). A pull mechanism may be employed to retrieve data from one thread model using another thread model. A thread model  requiring data provides the identifier to the thread model  in possession of the data, together with a read request, and the data item is provided after some latency. In yet another embodiment, a push mechanism may be employed, whereby once a thread model  has data, it pushes the data to all threads that are known to require the data, together with its identifier .","Programming Interface",{"@attributes":{"id":"p-0139","num":"0138"},"figref":"FIG. 16A","b":["1600","1600","1602","1602","1604","1602","1602","1602"]},"In one embodiment of the invention, the set of primitives  comprises FOP primitives , COP primitives , PIP primitives , signal grouping primitives , inter-process communication primitives , memory element primitives , run-time primitives , implementation metric primitives , and debugging primitives . Each of the aforementioned primitives is discussed in detail below.","The FOP primitives  provide a coding environment targeting multiple threads that operate in parallel. The FOP primitives  include instruction set primitives  and physical implementation primitives . The instruction set primitives  are used to program the threads. That is, the instruction set primitives  provide a mechanism for establishing an instruction set of a thread, where the instruction set itself is programmable. Thus, a designer may modify an instruction set for a thread as desired (e.g., providing a domain-specific set of instructions). The physical implementation primitives  are used to define the physical implementation of a given thread. For example, a thread may be implemented in programmable logic of an FPGA or in a hard or soft microprocessor or using a microcontroller.","In one embodiment, each thread is implemented as a custom FSM in programmable logic of an FPGA. An instruction set is defined for the FSM thread, where each instruction has a dedicated implementation. There is no additional support required for unused operations in the instruction set and multiple instructions may be executed simultaneously.","The COP primitives  are used to include a function block into the design. In one embodiment, the COP primitives  comprise \u201cinclude\u201d type primitives for specifying a particular function block to include within the design.","The PIP primitives  may comprise instruction set primitives  and physical implementation primitives . The instruction set primitives  are used to define an instruction set for a thread in a similar manner to the FOP primitives  described above. Unlike the FOP primitives , however, the instruction set primitives  may be used to define certain system instructions. The system instructions are used to communicate with input\/output interface logic blocks that communication with another system (within the FPGA or external thereto). For example, an interface logic block may be a gigabit Ethernet MAC core. The instruction set primitives  provide support for different communication protocols to read\/write data over various interfaces. For example, one type of interface may be completely streaming, with data arriving at every clock cycle. Another type of interface may have flow control, where there may be a pause in the data stream.","The physical implementation primitives  define the physical implementation of the PIP (e.g., FSM, microprocessor). The PIP primitives  may also comprise include type primitives for specifying the inclusion of the interface function block. Each interface block may have multiple ports, or groups of signals, associated therewith. One group of signals contains the connectivity to the external environment. The others connect to one or more PIP threads. For example, an interface block may have a set of signals that form a receive port and another set of signals that form a transmit port. In this case, the signals may be grouped together such that each port is assigned to a different PIP thread.","The signal grouping primitives  are used to define signal groups. Grouping of signals may occur in various contexts, such as when connecting an interface block to a PIP thread, as described above, or when connecting to a memory element. In such cases, the programming information for an element such as a FOP thread states that the FOP thread is connected to another element.","The inter-process communication primitives  provide support for synchronization and data communication between threads. Some basic aspects of the mechanism, such as support for starting, stopping, and suspending processes, may be built into the soft platform architecture. Thread synchronization and data communication, however, may be completely specified by a designer. In one embodiment, connections are explicitly specified between processes. Alternatively, required connections may be inferred from the operations defined for a particular group of processes. For example, an operation to start another process may have the form of \u201cSTART (process)\u201d or an operation to pass a data value to another process may have the form of \u201cPASS (data, destination process).\u201d With such an operation, a connection may be inferred without a designer explicitly defining the connection.","The memory element primitives  are used to define the various types, sizes, and interconnections of memory elements. The memory element primitives  may include the MIDL primitives discussed above in the section entitled \u201cMEMORY MODEL,\u201d for specifying the logical view of a memory subsystem.","The run-time primitives  may be used to apply run-time reconfiguration. Run-time reconfiguration involves the modification of a circuit implemented within an FPGA at run-time. Dynamic reconfiguration for an FPGA is well-known in the art. For example, the run-time primitives  may be used to migrate functionality between programmable logic and an embedded processor. Initially, some functionality is implemented in programmable logic with other functionality implemented using an embedded microprocessor. Implicitly, the programmable logic implementation exhibits higher performance than the processor implementation. Functionality may be offloaded to the processor to save area within the programmable logic. During execution, statistics may be taken to give feedback on the chosen partition. A reconfiguration controller determines a new partition and reconfigures the FPGA. An exemplary decision condition would be based on the frequency of events. More frequency events may thus be handled in programmable logic, with less frequency events handled by the embedded processor.","The implementation metric primitives  may be used to define the requirements of the system. For example, the implementation metric primitives  may be used to establish performance requirements that must be met. The implementation metric primitives  may be used to create constraints files (e.g., timing constraint files) that can be used by FPGA design tools (e.g., map\/place\/route tools). The implementation metric primitives may also provide low-level optimizations (e.g., clock frequency requirements, throughput latency requirements), as well as high-level optimizations (e.g., optimize for area, throughput, latency, power, and the like).","The debugging primitives  may be used to provide debugging capabilities. The debugging primitives  may be used to capture simulated data associated with the soft platform architecture. For example, instead of presenting signal waveforms to the designer, the debugging primitives  allow for data presentation in a more abstracted form. The debugging primitives  also provide lower-level functions through the use of tags or commands that cause the circuitry to be modified and operate in a debug mode.","Appendix file \u201cAppendix_D.txt\u201d shows exemplary XML code that defines interface logic for a logic block or \u201ccore,\u201d referred to as \u201cAurora,\u201d which may be used to drive the soft platform architecture described herein. The Aurora interface, available from Xilinx\u00ae of San Jose, Calif., is implemented as external intellectual property for point-to-point communication over multi-gigabit transceivers. The first set of signals (clk, reset, RXN, RXP, TXN, and TXP) represent the signals that connect to the external environment. In this example, the data lines would be tied to serial transceivers. The port labeled \u201crx\u201d is the receive port and has several signals associated therewith. Similarly, the port labeled \u201ctx\u201d is the transmit port and also has several signals associated therewith.","Within each port is a clock associated therewith. The clock determines the clock domain. In the present example, both \u201crx\u201d and \u201ctx\u201d ports have an output clock. Thus, the IP function block has circuitry to generate a clock signal. This clock would drive all threads in the determined clock domain. Alternatively, a \u201cuseclk\u201d tag may be used if the IP block does not generate a clock signal. The clock that drives the port is also used to drive other threads in the clock domain.","Appendix file \u201cAppendix_E.txt\u201d illustrates an exemplary XML code of a PIP thread that handles the receive-side connection to the Aurora interface defined in appendix file \u201cAppendix_D.txt\u201d. The PIP thread reads data from the receive port of the Aurora interface and stores the data in a buffer. The protocol for the interface includes flags marking the state of a frame, end of frame, and whether data is valid. The data valid (RXSourceReadyBar) signal allows the stream to pause. The PIP thread waits until the entire frame has been received before committing the frame to memory. Committing the frame to memory is an indicating mechanism informing the buffer that an entire frame is in memory. This ensures that other blocks of logic that read from the memory do not process a partial frame.","Line  of appendix file \u201cAppendix_E.txt\u201d illustrates that the PIP thread connects to the A port of a memory named \u201ca2e_buf.\u201d Line  of appendix file \u201cAppendix_E.txt\u201d shows that the PIP thread also connects to the rx port of the interface block named Aurora (as shown in appendix file \u201cAppendix_D.txt\u201d). Lines - of Appendix file \u201cAppendix_E.txt\u201d define the variables of the PIP thread. In the present example, only internal variables are shown, but variables may also be defined to connect to other threads.","Appendix file \u201cAppendix_F.txt\u201d illustrates exemplary XML code for effecting an explicit connection. A thread named \u201csender\u201d having an output named \u201cmyout\u201d is defined. Threads named \u201creceiver_\u201d and \u201creceiver_\u201d, each with an input named \u201cmyin,\u201d are also defined. The defined connection will connect the output of the sender thread with the two input ports of the receiver threads.",{"@attributes":{"id":"p-0157","num":"0156"},"figref":"FIG. 16B"},"A PLD is configured with a plurality of thread circuits (step ). The thread circuits may be implemented using the tools and approaches described in this application. At least one of the threads is a broadcaster thread as described above, and one or more others of the threads are configured to read data broadcasted by the broadcaster thread. Along with the thread circuits, the PLD is configured with a broadcast channel (step ). The broadcast channel operates as described above.","The broadcaster thread circuit receives input data for broadcasting on the broadcast channel (step ). Depending on application requirements, the broadcaster thread may be configured to start another one of the threads (step ). This may occur either before data is received or in response to having received input data by the broadcaster thread.","The broadcaster circuit writes the message to the broadcast channel (step ), and the broadcast channel outputs message data along with the message-relative position of data present at the output port (step ). Based on the position information provided by the broadcast channel and a word of the message expected by a thread, a thread reads the data at the data-out port of the broadcast channel (step ).","In one embodiment, the reader thread may select data from the data-out port with or without using an offset value. In an application in which no offset is provided by the broadcaster thread to the reader thread, example VHDL pseudo-code is:",{"@attributes":{"id":"p-0162","num":"0161"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CHAN_valid_i <= CHAN_valid(0) when \u201c00\u201d,"]},{"entry":[{},"CHAN_valid(0) and"]},{"entry":[{},"CHAN_valid(1) when others;"]},{"entry":[{},"case state is"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"when stateA =>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if (CHAN_addr = 32) and (CHAN_valid_i = \u20181\u2019)"]},{"entry":[{},"then"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"--process CHAN_data"]},{"entry":[{},"nextState <= stateB"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"--next state is the current state"]},{"entry":[{},"nextState <= stateA"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"endif;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"..."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end case;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In an application in which an offset is provided by the broadcaster thread to the reader thread, example VHDL pseudo-code is:",{"@attributes":{"id":"p-0164","num":"0163"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case state is"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"when stateA =>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (CHAN_addr = (offset + 32)) and"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(CHAN_valid_i = \u20181\u2019)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"--process CHAN_data"]},{"entry":[{},"nextState <= stateB"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"--next state is the current state"]},{"entry":[{},"nextState <= stateA"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"endif;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"..."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end case;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The value \u201coffset\u201d is provided by the broadcaster thread, and the reader thread uses the offset value in combination with the constant value 32 to select data. When the CHAN_addr value is equal to the offset value plus , the reader thread reads from CHAN_data. The reader thread blocks in state A until the byte at (offset +32) becomes available.",{"@attributes":{"id":"p-0166","num":"0165"},"figref":"FIG. 16C","b":["1646","0","7","1440","1648"]},"As an example, an IP packet may follow an Ethernet frame in a message. The Ethernet frame spans 14 bytes (referenced as message bytes - in this description), and the header of the IP packet follows the Ethernet frame in the message and spans 20 bytes. Thus, the IP packet header occupies message bytes -). The offset value 14 may be provided to an IP thread when the IP thread is started, and the IP thread may use the offset value to read unaligned data from CHAN_data.","In one embodiment, for activation of reading from the broadcast channel the offset value is rounded up to the next word boundary. For the example offset , the offset value is rounded to byte . This causes the reader thread to read from the channel when byte  is word  of CHAN_data.","The two least significant bits (LSBs) of the offset value (not rounded) are used to select the bytes from CHAN_data. For the offset value 14 (binary 00001110), the 2 LSBs are \u201c10,\u201d and bytes , , , and  are selected from CHAN_data. For the example message of , the offset value 14 causes the reader thread to read during cycle , bytes , , , and  (45000054).",{"@attributes":{"id":"p-0170","num":"0169"},"figref":"FIG. 16D"},"System  includes a receive thread  for receiving an input message, memory block  for communicating the message to the broadcaster thread , threads , , , and  for processing the message, and broadcast channel  for communicating the message from the broadcaster thread  to the other threads. The system also includes respective memory blocks  for output from threads , , , and , and a transmit thread for outputting data from the memory blocks . The adder and multiplier blocks  and  are used by the RPC thread .","Appendix file \u201cAppendix_G.txt\u201d contains example XML code for implementing system . Each thread is defined beginning with the tag <FSM name=\u201cthreadname\u201d> and ends with the tag <\/FSM>. Within a thread, the blocks to which the thread connects are specified, along with variables. The states of the thread are also defined, with the beginning of a state tagged with <state name=\u201cstatename\u201d> and ending with <\/state>. Within a state, each of the instructions gets executed in parallel.","The \u201cbroadcaster\u201d thread in the XML code connects to the channel with the \u201cusechan\u201d tag. In the \u201cgetFirst\u201d state the broadcaster thread uses the instruction, <operation op=\u201cSTART\u201d params=\u201cETH_THREAD\u201d, 0\u2033\/>, to start ETH_THREAD. The parameter value 0 specifies the offset. The ETH_THREAD in turn starts the IP_THREAD with an offset of 14.","The IP_THREAD uses the CHAN_GET instruction to read data from the specified channel. The instruction allows specification of the message-relative address of data on the broadcast channel and the variable to which the data is to be written. Note that offsets in the CHAN_GET instructions are relative to the offset of 14 issued by the ETH_THREAD in starting the IP_THREAD. The translation of XML, or other high-level language, to HDL accounts for both offset values. Comments interspersed in the code further explain the specified operations for message-relative offset addressing.","While the foregoing describes exemplary embodiment(s) in accordance with one or more aspects of the present invention, other and further embodiment(s) in accordance with the one or more aspects of the present invention may be devised without departing from the scope thereof, which is determined by the claim(s) that follow and equivalents thereof. Claim(s) listing steps do not imply any order of the steps. Trademarks are the property of their respective owners."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Accompanying drawing(s) show exemplary embodiment(s) in accordance with one or more aspects of the invention; however, the accompanying drawing(s) should not be taken to limit the invention to the embodiment(s) shown, but are for explanation and understanding only.",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 9","FIG. 6"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 10","FIG. 6"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 11","FIG. 6"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 14A"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 14B"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 14C","b":"1440"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 14D"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 15","FIG. 14"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 16A"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 16B"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 16C"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 16D"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 17"}]},"DETDESC":[{},{}]}
