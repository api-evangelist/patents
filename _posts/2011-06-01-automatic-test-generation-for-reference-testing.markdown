---
title: Automatic test generation for reference testing
abstract: A system for application reference testing (SMART) solves the technical problem of generating test data and test cases from graphical user interface applications (GAPs) to test web services, effectively and non-invasively. SMART allows organizations to easily and promptly identify and resolve software bugs, ensure higher quality software and development productivity, complete software projects faster, deliver software products to market quicker, and improve the return on investment for software development projects. SMART provides a user friendly visualization mechanism that interacts with an accessibility layer to enable organizations to economically and easily define user interactions with GAPs, by performing point-and-click, drag-and-drop operations on the GAPs, and generate reusable test data and test cases for web services.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08370814&OS=08370814&RS=08370814
owner: Accenture Global Services Limited
number: 08370814
owner_city: Dublin
owner_country: IE
publication_date: 20110601
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION"],"p":["This is a continuation application of U.S. patent application Ser. No. 11\/784,121, filed Apr. 5, 2007, which is incorporated herein by reference in its entirety.","1. Technical Field","This disclosure concerns generating test cases from graphical user interface applications (GAPs) to perform reference testing on web services. In particular, this disclosure relates to an efficient and non-invasive approach to generating reference tests cases and production data from GAPs for web services.","2. Background Information","Organizations spend a substantial portion of their software development project budgets to create test cases. A strong demand exists for systems that generate accurate test cases, efficiently and economically. However, many software development projects employ laborious and inefficient methods and systems, only to produce inaccurate and incomplete test cases that, as a consequence, fail to meet some or all of the testing requirements. A test case may include test data (e.g., valid input data) and a test oracle (e.g., an expected or valid output). Organizations face many of the same technical issues generating both test data and production data from reference applications, and develop elaborate data conversion programs to create production data for new applications. Software developers and system integrators (\u201cdevelopers\u201d) commonly consider test data disposable and only used in testing. Accordingly, test data content may in fact be production data, though distinguished by name due to its role in the testing process.","Developers test new applications to validate that the software complies with system requirements. The testing process includes developing test logic based on detailed specifications, and alternatively, performing reference testing (i.e., a form of regression testing). Developers retest (i.e., regression test) modified software to ensure that a modification to the modified software operates properly, and that the modification has not caused other previously working functions of the modified software to fail. Reference testing includes comparing outputs from new applications against previously recorded (i.e., expected) outputs from the same application or another application. Test oracles may require developers to provide detailed and comprehensive descriptions of the desired behaviour for the new application. Consequently, the quality of a test oracle depends on the quality of the specification. Reference testing includes testing new applications (\u201ctarget applications\u201d) using information from legacy applications (\u201creference applications\u201d). When developers migrate or model functionality from a reference application to a target application, developers attempt to reuse test data and test cases from the reference application. The purpose of migrating functionality includes replacing the reference application with the target application. In contrast, the purpose of modelling functionality of a reference application may include merely replicating the functionality of the reference application in the target application, and not for the purpose of replacing the reference application.","It is very commonly the case that after a software project team deploys a reference application into production for an organization, neither the organization nor the team preserves test data or testing documentation. Even though organizations may store data accumulated by reference applications over many years of use in production, organizations find it difficult to extract and develop test data and test cases from the reference applications to test target applications. Organizations that desire to use data from reference applications spend significant time and money in attempts to understand the source code and the data structures of the reference applications.","Modern systems often incorporate Graphical User Interface (GUI) Applications (GAPs) implemented in a closed and monolithic manner. Developers building target applications find extracting test cases from existing GAPs (reference applications) a difficult technical challenge, especially for closed and monolithic GAPs. Thus, a fundamental technical problem of interoperability for developers is how to extract test cases from existing GAPs, efficiently and non-invasively.","Developers and organizations purchasing system integration and software development services recognize the difficulty and enormous expense of developing new software applications. Beyond developing new applications, developers must define and generate accurate test data and test cases. Organizations tend to use legacy GAPs as long as possible in business operations, primarily to realize the return on investment for the legacy GAPs. However, developers find extracting data from GAPs difficult, because the vast majority of GAPs are closed and monolithic. In other words, most GAPs do not expose programming interfaces or data in known formats. Thus, while developers find the use of GAPs to extract test data and test cases desirable, often the original implementation of a GAP makes the extraction impossible.","In contrast to GAPs, developers design web services as software components that flexibly exchange information over networks, including the Internet. Consequently, business industry demand for applications that easily and inexpensively exchange information has partly caused widespread acceptance of web services. Employing web services, unlike GAPs, enables organizations to quickly build integrated systems by composing (i.e., configuring) the web services for information exchange. Organizations easily migrate and\/or model functionality from existing web services to other web services. However, migrating or modelling functionality in GAPs to generate test data and test cases for web services provide a considerable technical challenge for organizations and developers.","Organizations have invested heavily in legacy GAPs and developers find it difficult and time consuming to analyze the source code of GAPs to extract data and test cases, because of brittle legacy architectures, poor documentation, significant programming effort, and subsequently, the large cost of such projects. Organizations often do not have access to the source code necessary to analyze and develop data extraction and test cases from GAPs, in particular regarding third-party provided GAPs. Given the complexity of GAPs and the cost to migrate and model GAPs to create new web services, a fundamental problem exists of how to extract test data and test cases from GAPs to test web services, and generate production data from GAPs, efficiently and non-invasively.","A need has long existed for a system and method to economically and efficiently extract test cases and production data from GAPs for web services.","A system for application reference testing (SMART) considers GAPs as state machines, in which a structural representation of GUIs of a GAP and GUI elements of the GAP define a GAP state (i.e., GAP state definition) useable to test applications. SMART provides a general, reusable, and reliable mechanism for generating test data and test cases from legacy applications without the need to understand, manipulate, or modify the legacy application source code or data storages. When developers write target applications, the reference applications serve as references to test the target applications. Reference applications may include legacy applications that the target application will replace (i.e., migrate functionality), or non-legacy applications (i.e., applications that the target application will not replace) that possess functionality the target application intends to model. Developers may also use SMART to generate test cases and production data from the reference applications to test and operate the target applications. Organizations face many of the same technical issues generating both test data and production data from reference applications, and often spend significant time, money, and other resources to develop elaborate data conversion programs to create production data, as well as test data, for new applications. One distinction between test data and production data is that test data is generally considered disposable. Accordingly, SMART also solves the technical problem of creating production data for target applications from reference applications.","In one implementation, SMART considers GAPs as state machines, in which a structural representation of GUIs of a GAP and GUI elements of the GAP define a GAP state or GAP state definition. The GAP state definition may include: UI screen sequences, GUI elements of the GAP, the function types of the GUI elements; the properties of the GUI elements, and the values of the GUI elements. SMART may establish test cases based on GUI elements that can substitute for target application data, and GAP state definitions. SMART may establish the test cases to include test logic incorporated with GAP state definitions. SMART allows developers to test target applications (e.g., web services based applications), using GAPs as reference applications. In addition, SMART may calculate or analyze the number of GUI elements that SMART may substitute for target application data and the number of data elements employed by the GAP, including non-GUI elements, to determine the suitability of a GAP as a reference application for testing a target application. SMART may indicate the percentage of target application data parameters that SMART may substitute using GAP GUI elements as test data.","SMART may work in conjunction with a Composer of Integrated Systems (Coins) to produce test cases and production data. Coins provides an approach for creating integrated systems composing GAPs and web services. SMART may work with Coins to control a first GAP (e.g., invoice application) to produce an input to a second GAP (e.g., an expense application) to produce a test case. Coins combines a non-standard use of accessibility technologies used to access and control GAPs in a uniform way with a visualization mechanism that enable nonprogrammers to compose GAPs with each other and web services. Coins uses accessibility technologies to control GAPs and their user interface (UI) elements as programming objects, set and retrieve UI elements, and associates methods with actions that users perform on the UI elements. For example, when a user selects a combo box item the combo box invokes a method that performs some computation. A web service would invoke methods, and set or retrieve field values of a programming object representing the combo box to control the combo box programmatically. Coins controls GAPs as programming objects, and UI elements as fields of the programming objects, and invokes methods on the objects to perform actions and manipulate the GAPs and UI elements. Unfortunately, web services cannot access and manipulate UI elements as pure programming objects, because UI elements only support user-level interactions. However, accessibility technologies expose a special interface that allows the Coins to invoke methods, and set and retrieve UI element values, and thereby control UI elements and GAPs.","Organizations may extend the value of legacy GAPs by using the legacy GAPs to test web services. SMART allows users to associate GUI elements, GAP state definitions, and test logic with test cases that establish test frameworks. SMART establishes test frameworks by capturing user interactions with GAP GUI element (e.g., clicking a button on a GAP screen). SMART allows users to define the GUI elements to use as test data elements, and the GAP state definitions and test logic to define test oracles. In addition, SMART allows users to specify how to use test oracle return values to validate test results.","Other systems, methods, and features of the invention will be, or will become, apparent to one with skill in the art upon examination of the following figures and detailed description. It is intended that all such additional systems, methods, features and advantages be included within this description, be within the scope of the invention, and be protected by the following claims.","A system for application reference testing (SMART) considers GAPs as state machines, in which a structural representation of GUIs of a GAP and GUI elements of the GAP define a GAP state (i.e., GAP state definition) useable to test applications. SMART solves the technical problem of generating test data and test cases from GAPs to test applications. SMART interacts with an accessibility layer to define user interactions with GAPs, by performing point-and-click, drag-and-drop operations on the GAPs, and generate reusable test data and test cases for target applications. SMART considers GAPs as state machines, in which a structural representation of GUIs of a GAP and GUI elements of the GAP define a GAP state or GAP state definition. The GAP state definition may include: UI screen sequences; GUI elements of the GAP; the function types of the GUI elements; the properties of the GUI elements; and the values of the GUI elements. SMART extends certain aspects of Coins, briefly discussed below.","Accessibility technologies provide different aids to disabled computer users, including, as examples: screen readers for the visually impaired; visual indicators or captions for users with hearing loss; and software to compensate for motion disabilities. Under 36 CFR part 1194, the Architectural and Transportation Barriers Compliance Board's Electronic and Information accessibility Standards requires that when Federal agencies develop, procure, maintain, or use electronic and information technology, the electronic and information technology allows Federal employees with disabilities access and use of information and data comparable to Federal employees without disabilities. Accordingly, because the Federal Government's large appetite for technology, and the desire of the technology industry to sell technology to the Federal Government, most computing platforms include accessibility technologies. For example, Microsoft designed Microsoft's Active Accessibility (MSAA) technology to improve the way accessibility aids work with applications running on Windows, and Sun Microsystems accessibility technology assists disabled users who run software on top of Java Virtual Machine (JVM). Many computing platforms, as well as libraries and applications incorporate accessibility technologies in order to expose information about user interface elements. Accessibility technologies provide a wealth of sophisticated services useable to retrieve UI elements attributes, set and retrieve UI element values, and generate and intercept different events. SMART uses accessibility technology to access an accessibility interface that UI elements expose. The accessibility interface exports method for accessing and manipulating the properties and behaviour of the UI elements. For example, a Windows UI element employs the IAccessible interface to allow access and control of the UI element using the MSAA API calls. Accessibility API calls may include: get into object; perform action on object; get value from object; set value on object; navigate to object; and set property on object.","SMART generates a test framework for a target application (TAP) from a GAP that serves as the reference application. SMART interacts with the GAP through an accessibility layer to capture a structural representation of a GAP graphical user interface (GUI) screen including a GUI element. SMART also establishes a GAP state definition. The GAP state definition includes a function type for the GUI element, an element property for the GUI element, and an element value for the GUI element. SMART generates the test framework, including a test case specifying an interaction with the GAP through the accessibility layer based on the structural representation. The test framework also includes a test data element that provides an input parameter for the interaction of the test case with the GAP.","Coins addresses the technical challenge of enabling GAPs to exchange information (i.e., interoperate) with each other and web services over the Internet, and solves the technical problem of composing integrated systems using GAPs and web services, efficiently and non-invasively. Coins allows users to create composite web services from multiple GAPs and web services. Coins identifies and registers multiple GAPs, as a result of the Coins capturing, through the accessibility layer (i.e., accessibility API), information regarding GAPs and user interface (UI) elements of the GAPs. Coins registers GAPs and web services using a design tool user interface to capture user interface interaction specifications that create user interface element correspondence between a UI element of one GAP and a different UI element in a different GAP. Coins defines a web service parameter relationship between a web service parameter and one or more UI elements of a GAP, and defines a composite web service definition for a composite web service from one or more web service parameters. Coins generates and deploys composite web services based on composite web service definitions, one or more user interface interaction specifications, and one or more web service parameter relationships. Coins may also generate and deploy web services based on web service definitions that include one or more user interface interaction specifications between UI elements of different GAPs, and one or more web service parameter relationships.","Coins uses proxies to command and control GAPs and UI elements of GAPs to fulfil web service requests. When a proxy receives a response from a GAP, the proxy extracts data from the GAP, and forwards the extracted data to one or more web services. Proxies use hooks to perform various actions on UI elements and GAPs programmatically through accessibility API calls. Accessibility technologies allow hooks to register for different events produced by UI elements and GAPs monitored by accessibility APIs. One or more GAPs may run with a proxy and corresponding hooks on a single designated GAP host computer along with a accessibility API.","Coins uses a dispatcher as a central point for coordinating proxies in a distributed environment. A proxy registers with the dispatcher under a unique name, collects GAP identification data and information about GAPs running with the proxy on a GAP host computer, and sends the collected GAP identification and information about GAPs to the dispatcher. The dispatcher uses the information collected from the proxies to route web service requests to proxies. The dispatcher routes web service request components of composite web services to one or more GAP host computers, where corresponding proxies ultimately command and control GAPs and UI elements. The dispatcher acts as an intermediary that enables web services and GAPs to run on separate computers while presenting a common view to client programs. Because organizations may move web services and GAPs around the enterprise computing environment for various reasons (e.g., to improve business processes efficiencies or the performance of applications) the dispatcher provides web services and GAPs migration and location transparency to client programs.","The elements illustrated in the Figures interoperate as explained in more detail below. Before setting forth the detailed explanation, however, it is noted that all of the discussion below, regardless of the particular implementation being described, is exemplary in nature, rather than limiting. For example, although selected aspects, features, or components of the implementations may be depicted as being stored in memories, all or part of systems and methods consistent with Coins may be stored on, distributed across, or read from other machine-readable media, for example, secondary storage devices such as hard disks, floppy disks, and CD-ROMs; a signal received from a network; or other forms of ROM or RAM either currently known or later developed.","Furthermore, although this document describes specific components of Coins and SMART, methods, systems, and articles of manufacture consistent with SMART and Coins may include additional or different components. For example, a processor may be implemented as a microprocessor, microcontroller, application specific integrated circuit (ASIC), discrete logic, or a combination of other type of circuits or logic. Similarly, memories may be DRAM, SRAM, Flash or any other type of memory. Logic that implements the processing and programs described below may be stored (e.g., as computer executable instructions) on a computer readable medium such as an optical or magnetic disk or other memory. Alternatively or additionally, the logic may be realized in an electromagnetic or optical signal that may be transmitted between entities. Flags, data, databases, tables, and other data structures may be separately stored and managed, may be incorporated into a single memory or database, may be distributed, or may be logically and physically organized in many different ways. Programs may be parts of a single program, separate programs, or distributed across several memories and processors, and may be implemented or distributed as shared libraries, application programming interfaces (APIs), or in other forms. Furthermore, the programs, or any portion of the programs, may instead be implemented in hardware.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","102","104","106","108","110","112","114","116","120","122","124","126","100","130","100","102","104","120","126","106","110","102","112","114","116","118","112","114","116","118","102","102","120","126","106","110","104","100","104"]},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 2","b":["102","102","104","102","104","104","202","202","102","102","1","206","2","220","3","230","102","1","112","2","114","3","116","102"]},"In one implementation, when proxy-  receives a web service request component the proxy-  interacts with one or more UI elements of the GAP- with UI elements  through the hook- , in response to the web service request component. The accessibility layer-  may support hook-  to perform various actions on GAP- with UI elements  programmatically. Proxy-  in communication with GAP- host computer  for GAP- with UI elements  and hook-  may register the GAP- with UI elements  with the dispatcher , resulting in a second composite web service request component of the composite web service to route through the dispatcher  to the GAP- host computer . In one implementation, when proxy-  receives the second web service request component the proxy-  interacts with one or more of the UI elements of the GAP- with UI elements  through the hook- , in response to the second web service request component. The accessibility layer-  may support hook-  to perform various actions on GAP- with UI elements  programmatically. The dispatcher  may use a load balancer  to route web service requests to multiple GAP host computers.","In one implementation of the Integrated System  multiple instances of a GAP (e.g., Acme Expense GAP (AEG)) run concurrently on separate GAP host computers (e.g., GAP- host computer , GAP- host computer , and GAP- host computer ). The dispatcher  assigns each instance of AEG a unique GAP identifier, enabling the dispatcher  to coordinate parallel execution of multiple instances of AEG, so that when the composite web service  sends a composite web service request component to the dispatcher  in response to a request from a client program  the dispatcher  routes the composite web service request component to the correct instance of AEG.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 3","b":["302","304","100","306","308","310","308","1","312","2","314","1","2","1","312","2","314","1","320","2","321","322","323","324","1","312","2","314"]},"In one implementation, the accessibility layer  supports hook-  and hook- to perform various actions programmatically on GAP- , GAP- UI elements , and GAP-  and GAP- UI elements , respectively. The accessibility layer  may also assist with capturing a structural representation of GUIs of a GAP and UI elements of the GAP , as a result of interactions with the GAP. The structural representation of GUIs of a GAP and UI elements of the GAP  may provide the proxy , hook-  and hook-  comprehensive information to locate, control, and manipulate GAP- , GAP- , GAP- UI elements , and GAP- UI elements . The structural representation of GUIs of a GAP and UI elements of the GAP  may be implemented with a data structure (e.g., an XML file) that captures a depth first traversal of the GUI, breadth first traversal of the GUI, or that otherwise stores the interface elements and screen sequences of the GUI. The proxy  may analyze the structural representation of GUIs of a GAP and UI elements of the GAP  to locate a GAP UI element in the GAP GUI.","The proxy  may include registration logic , an accessibility layer command coordinator , and a GAPs identification table . The proxy  may use the registration logic  to register GAP-  and GAP-  with the dispatcher. The accessibility layer command coordinator  may control GAP-  and GAP- UI elements  through hook- , in response to a web service request component. To that end, the accessibility layer command coordinator  may receive web service request components, extract the graphical user interface element identifiers, a structural representation of a GAP, and the requested action on the identified graphical user interface element. The accessibility layer command coordinator  may then traverse the structural representation  to determine where the identified graphical user interface element resides in the GAP user interface, and make calls to the hook to navigate the GAP to the interface that includes the identified graphical user interface element. Once at the appropriate interface, the accessibility layer command coordinator  may then exercise the graphical user interface element through the hook to perform the requested action.","In another implementation, proxy-  uses an accessibility layer command coordinator running on and dedicated to GAP- host computer  to control GAP- with UI elements  through hook- , in response to a web service request component. The proxy  may collect GAP identification data and information about GAPs (e.g., GAP- , and GAP- ) hosted with proxy  on the multiple GAPs host computer , and stores the collected GAP identification data and information about the GAPs in the GAPs identification table . In one implementation, the proxy  may store GAP Identifiers for multiple locally hosted GAPs (e.g., GAP- , and GAP- ) in the GAP identification table . The proxy  may periodically send the collected GAP identification data and information about the GAPs to the dispatcher . The multiple GAPs host computer  may use the external storage  to store the GAP- exe  and GAP- exe  programs.","In an alternative implementation, the dispatcher  receives a web service request message from the web service  that includes a GAP UI element Identifier and an action request identifier for a specific GAP UI element (e.g., GAP- UI elements ). The GAP UI element may correspond to a GAP (e.g., GAP- ) executing in memory . The dispatcher  may send the web service request message to proxy , which extracts the GAP UI element identifier and action request identifier from the web service request message. The proxy  may perform an action against the GAP- UI elements  specified in the action request identifier through hook- . The action request identifier may include a GUI element data setting action, or a GUI element data retrieval action that the proxy performs through hook-  against the GAP- UI elements  specified in the action request identifier.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 4","FIG. 3"],"b":["102","102","402","404","406","102","406","1","410","2","412","414","424","428","430","432","102","1","206","2","220","1","206","2","220","102","1","112","2","114","102","102","1","410","2","412","324","102","330","1","312","2","314"]},"In one implementation, when a client program  invokes a method of a web service  or composite web service , the web service  or composite web service  to which the method belongs sends a web services registration request  to the dispatcher . The dispatcher  may identify the GAPs required to fulfil a method of a web service , or a composite web service . The dispatcher  may use registration logic  to receive GAP registration requests  from GAPs and web services registration requests  from web services , and composite web services . The dispatcher  may also use the registration logic  to control GAPs to web services assignments logic  to analyze the proxy GAPs identification tables to assign GAPs and UI elements to methods of web services , and methods of composite web services . In one implementation, the registration logic  instantiates the proxy GAPs identification table (e.g., proxy- GAPs identification table , and proxy- GAPs identification table ) in response to a GAP registration request  from a GAP. The dispatcher  may include a GAPs request queue  to store web service requests and web service request components when a web service requests an unavailable GAP, which will be explained in further detail below.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 5","b":["500","500","502","504","506","500","506","508","510","512","513","514","516","518","520","522","524"]},"The interaction logic  captures one or more GAP- UI elements , and one or more GAP- UI elements  using the accessibility layer . In other words, the Interaction logic  may capture a structural representation of GUIs of a GAP and UI elements of the GAP  through the accessibility layer  using the hook logic  to communicate with the GAPs (e.g., GAP- , GAP- , and corresponding GAP- UI elements  and GAP- UI elements ). Proxy logic  may control the GAPs through the hook logic , and the proxy logic  may use the registration logic  to send GAP registration requests  to the dispatcher . The structural representation of GUIs of a GAP and UI elements of the GAP  may include a GAP UI element label, a UI element Identifier, and location information in the GAP GUI for the GAP UI elements (e.g., GAP- UI elements  and GAP- UI elements ), and may also include a GAP GUI screen sequence representation for each GAP GUI screen sequence.",{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIG. 6","FIG. 6"],"b":["518","518","534","602","620","518","518","1","526","2","528","602","604","1","608","2","610","3","612","534","1","526","2","528","604","602","620","622","624","1","526","1","1","626","1","2","628","1","3","630","2","528","2","1","634","2","2","636","2","3","638","642","2","1","634","1","2","628","624","534","650","650"]},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 7","b":["534","520","702","520","702","202","604","1","608","2","610","3","612","534","202","202","534","520","704","706","514","510","534","522","622","522","624","1","526","1","1","626","1","2","628","1","3","630","2","528","2","1","634","2","2","636","2","3","638","622","624","2","1","634","1","2","628","2","1","634","1","2","628","522","622","1","526","1","1","626","1","2","628","1","3","630","2","528","2","1","634","2","2","636","2","3","638"]},{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 8","FIG. 8"],"b":["524","802","604","1","608","2","610","3","612","2","528","2","1","556","2","2","558","2","3","560","804","3","612","2","3","638","802","802","514","802","604","1","608","2","610","3","612","1","526","1","1","626","1","2","628","1","3","630","2","528","2","1","634","2","2","636","2","3","638","702","202","1","526","2","528","604","1","608","2","610","3","612","804","500","706","704","802","706"]},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 9","b":["326","902","904","906","908","910","912","913","914","916","918","916","920"]},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 10","b":["1002","204","202","102","428","1004","102","428","1006","1008","1010","1012","102","204","202","1016","1018","1020","102","1022","1024"]},{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 11","b":["1102","1104","1106","1108","1110","1112","1114","1116"]},{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 12","b":["1204","1206","1208","1210","1212","1214","1216","1218"]},{"@attributes":{"id":"p-0074","num":"0073"},"figref":["FIG. 13","FIG. 13","FIG. 13"],"b":["1300","1300","1302","1304","1306","1","1308","1310","1300","1312","1302","1306","1","1314","1302","1304","1300","1304","1306","1306","1302","1302","1","1314","1","1314","1","1308","1316","1318","1","1314","1","1320","1","1322","1316","1318","1","1314","1302","1","1322","1","1314","1","1308","102","1","1322","1","1322","1","1322","1","1320","1318","1","1320","1","1322","1","1322"]},{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 14","b":["1402","1","1","1404","1","1","1406","1","1","1408","1","2","1410","1","3","1412","1416","1402","1","1","1","1416","1","2","1418","1","3","1420","1","1322","1","1","1432"]},{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 15","FIG. 15"],"b":["1502","1504","1506","1502","1","1508","1402","1504","1506","1502","1","1508","1402","1504","1506","1510","1502","1","1","1","1510","1","1504","1","1402","1300","1511","1512","1","1514","2","1516","3","1518","1306","1502","1520","1512","1","1508","1306","1510","1520","1521","3","1518","2","3","1519","1520","1502","1512","1306","1","1508","1","1508","1504","1502","1318","1","1320","1","1322","1","1508","1402"]},{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 16","b":["1300","1602","1604","1606","1608","1602","1318","1402","1602","1","1","1508","1402","1","1602","1","1508","1402"]},"The design tool user interface logic  may generate the design tool user interface  that includes the input parameter area  and a screen sequence area , monitor and determine an operator's selection of at least one of the GAP- UI elements  in the GAP GUI represented in the structural representation of GUIs of a GAP and UI elements of the GAP , and add the selected GAP- UI elements  to the input parameter area . The definition logic  may establish the web service definition with at least one of the web service parameters  (e.g., WS parameter- , WS parameter- , and WS parameter- ) that will interact with the at least one of the GAP- UI elements . The relation logic  may establish a web service parameter relationship  between at least one of the web service parameters  (e.g., WS parameter- , WS parameter- , and WS parameter- ) and at least one of the GAP- UI elements . The relations logic  may establish multiple web service parameter relationships  with multiple web service parameters  (e.g., WS parameter- , WS parameter- , and WS parameter- ) and each of the GAP- UI elements .",{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 17","b":["1702","204","102","428","1704","102","428","1710","102","1712","102","204","1716","1718","1720","102","1722","1724","1726","1728","1730"]},{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 18","b":["1800","1800","1802","1804","1804","1800","1806","1808","1806"]},"The user interface tool  may include: an input parameter area ; UI screen sequence area ; and input logic area . In one implementation, SMART  may divide the user interface tool  input parameter area  into a reference application (RAP) view (RAV) , and target application (TAP) view (TAV) . The RAV  interacts with the RAP  through a proxy  that controls the RAP  through an accessibility layer  in communication with a hook . The RAV  captures structural representations of a GAP and UI elements of the GAP , and GAP state definitions  through interactions with the RAP . The GAP state definition  may include: a GAP UI screen sequence , a GAP Screen , and a GUI element  associated with the GUI screen . The GAP state definition  may also include various attributes of the GUI element , including: GUI element functions , GUI element property , and GUI element value . The RAV  may establish a test framework  based on the GUI element , GAP state definition , and test logic  defined in the input logic area . The test framework  may define a test case  that includes a test data element  associated with the GUI element , and a test oracle . The test case may associate the test oracle  with the GAP state definition , and test logic  that determine a return value response for the test oracle . The test framework  may include multiple test cases , and the each test case  may include a test case description  that indicates the scope and purpose of a test case.","The user interface tool  input parameter area  target application (TAP) view (TAV)  may capture a TAP interface definition , including: a TAP data parameter , and TAP return value parameter . Once SMART  captures a TAP interface definition  and establishes a test framework , SMART  may establish a test harness  associating the TAP  to the test framework . SMART  may define the test harness  to include a test framework description , a test harness data parameter , and a test harness return value parameter . Test harness may establish a relationship between the test framework  and TAP interface  using the test framework description  to identify the test framework , and corresponding test case  that the test harness  will use to test the TAP . The test harness  may use the test harness data parameter  to establish a relationship between the TAP data parameter  and test data element . The test harness  may also use the test harness return value parameter  to establish a relationship between the TAP return value parameter  and the test oracle . Once SMART  establishes the test harness , which associates the TAP  and test framework , the test harness may send test data corresponding to the test data element  representing TAP data  to the TAP  through the test harness data parameter . The TAP interface  may send the test framework  a TAP return value  through the test harness return value parameter . In response to the TAP return value , the test oracle  may apply test logic  to the TAP return value , and return a test oracle return value to the test harness . SMART  may store the test framework  and test harness in external storage  for reuse and further testing.",{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 19","b":["1816","1800","1802","1816","1902","1904","1906","1804","1842","1906","1902","1908","1910","1912","1940","1826","1844","1820","1822","1824","1816","1908","1802","1810","1814","1812","1816","1920","1828","1836","1838","1840","1828","1830","1922","1924","1816","1922","1924","1850"]},"In one implementation, the RAV  may capture a GUI element  that includes multiple GUI element functions , including: an action producer , input data acceptor , an output data retriever , and a state checkpoint . The GUI element  may include any combination of the GUI element functions . For example, the \u201cSearch\u201d pull-down box  GUI element  has a GUI element value  equal to \u201cDown\u201d and the GUI element property the functions of the GUI element  may operate to cause the action producer  function to set a GUI Screen  to scroll in the downward direction, and cause the GAP state to change (e.g., from editing a document to searching a document). In the \u201cSearch\u201d pull-down box  example, the output data retriever  function retrieves a list of search options from a container (e.g., listviews and edit boxes) to display in the \u201cSearch\u201d pull-down box  (e.g., Up, Down, and All), while the input data acceptor  function receives the selected \u201cDown\u201d value as input data. Following the example above, the state checkpoint  function may indicate an \u201cintermediate\u201d GAP GUI screen state corresponding to the execution of the \u201cSearch\u201d function. Alternatively, the state checkpoint  function may indicate a final state or exception state, where the action producer  causes an application to complete an action (e.g., close an application) or result in an error (e.g., invalid input to the input data acceptor ).","In one implementation, SMART  may calculate or analyze a SMART ratio . The SMART ratios  may include a GAP utilization ratio  and TAP testing coverage ratio . The GAP utilization ratio  represents a ratio of the number of GUI elements  that SMART  may associate with test data elements  (to substitute as TAP data ) to the number of GAP data elements, optionally including non-GUI elements used to run the GAP. For example, if a GAP employs 6,543 data elements (e.g., the total number of both non-GUI elements and GUI elements), and 2,768 of the data elements (GUI elements) may be used as test data, then the GAP utilization ratio is 42.30%. In an alternative implementation, SMART  may establish the TAP testing coverage provided by a GAP. In other words, SMART may determine the TAP testing coverage ratio  that indicates the percentage of TAP functionality that any particular GAP may test. Thus, if the TAP testing coverage ratio is 100%, SMART may extract test cases from a GAP to test 100% of the functionality of a TAP.","A GAP utilization ratio  or TAP testing coverage ratio  that exceeds a pre-selected ratio threshold may indicate the suitability of the GAP as a RAP  for a TAP . SMART  may compare the SMART ratios  against the ratio threshold to determine a suitability result. SMART  may report the suitability result to the operator, who may determine whether to proceed with test extraction based on the suitability results. Alternatively or additionally, SMART  may automatically analyze one or more SMART ratios  from multiple GAPs against the ratio threshold to determine one or more GAPs from which to extract tests. Accordingly, SMART  may use any number of GAPs to build a composite test framework  (see ), and may select a set of GAPs based on their GAP utilization ratio  or TAP testing coverage ratio . As examples, an operator may pre-select a ratio threshold of 50%, 75%, or 90%, which may depend on whether the operator desires to extract tests from one or more GAPs or the number of GAPs available to build a comprehensive (i.e., 100% coverage) test framework. An operator may select different two GAPs that individually provide 100% coverage to build a composite test framework  to enhance the quality of the testing.",{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 25","b":["2502","2502","2504","2506","1","2508","2","2510","1","2512","2","2514","2516","2518","1","2512","2520","2","2514","2502","2516","1940"]},{"@attributes":{"id":"p-0088","num":"0087"},"figref":["FIG. 20","FIG. 20","FIG. 20"],"b":["1800","1802","1800","1852","1842","1800","1808","1806","1842","2002","2004","2002","1842","1850","2006","1862","1848","1860","2004","1852","1856","2006","1862","1854","1860","2004","1872","1844","1800","1808","2006","1870"]},{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 21","b":["1818","1800","1802","1818","1908","1910","1852"]},{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 22","b":["2200","1800","1816","1804","1800","1842","2202","1816","1804","1820","1822","1824","2204","1804","1816","1826","1922","1924","1834","2206","1800","1848","1834","2208","1864","1800","1828","1830","1834","1836","1838","1840","2210","1816","1850","1828","1844","1814","2212","1844","1866","1850","1816","1846","1848","1850","2214","1842","1858","1846","1874","2216","1800","1842","2218","1870","1808"]},{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 23","b":["1800","1808","1842","1806","1818","1842","1846","2302","1818","1852","1854","1856","2304","1800","1860","1854","1848","1846","2306","1800","1862","1856","1850","2308","1818","1808","1858","2310","1842","1818","1872","2312","1842","1806","1806","1800","1800","1808","2314","1808","1870","1842"]},{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 24","b":["1800","1806","1808","1842","1800","1806","1808","2402","1806","1842","2404","1808","1846","1842","2406","1808","1848","1846","1848","1806","2408","1864","1806","1848","1866","1850","1808","2410","1808","1872","2412","1808","2414","1806","1848","1806","1808","1872","1872","1808","1850","1850","1844","1828","1866","1806","1808","1862","1806","1808","2416","1808","1846","2418","1848","1846","1808","1848","1846","2408"]},{"@attributes":{"id":"p-0093","num":"0092"},"figref":["FIG. 26","FIG. 26","FIG. 26"],"b":["1800","2602","2604","2606","2608","2606","2610","2612","2606","2614"]},"A number of implementations have been described. Nevertheless, it will be understood that various modifications may be made without departing from the spirit and scope of the invention. Accordingly, other implementations are within the scope of the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The disclosure can be better understood with reference to the following drawings and description. The components in the figures are not necessarily to scale, emphasis instead being placed upon illustrating the principles of the invention. Moreover, in the figures, like referenced numerals designate corresponding parts or elements throughout the different views.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 26"}]},"DETDESC":[{},{}]}
