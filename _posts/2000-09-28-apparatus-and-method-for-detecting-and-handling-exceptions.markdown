---
title: Apparatus and method for detecting and handling exceptions
abstract: An apparatus and method are provided for detecting and handling exceptions. Instructions that are executed only when there is an exception pending are qualified by a first predicate register in a predicate register pair. Instructions that are executed only when there is no exception pending are qualified based on a second predicate register in the predicate register pair. When an exception is thrown, a determination is made as to whether or not the instruction that threw the exception is in a try block, or range, of the method that threw the exception. If not, the first predicate register predicated instruction to branch to a return stub for the method is generated. If the instruction that threw the exception is in a try block of the method, the first predicate register predicated instruction to branch to a snippet associated with the method is generated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06886094&OS=06886094&RS=06886094
owner: International Business Machines Corporation
number: 06886094
owner_city: Armonk
owner_country: US
publication_date: 20000928
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["The present invention is related to commonly assigned and co-pending U.S. patent application Ser. No. 09\/671,876 entitled \u201cAPPARATUS AND METHODS FOR IMPROVED DEVIRTUALIZATION OF METHOD CALLS\u201d, Ser. No. 09\/671,973 entitled \u201cAPPARATUS AND METHOD FOR IMPLEMENTING SWITCH INSTRUCTIONS IN AN IA64 ARCHITECTURE\u201d, Ser. No. 09\/671,770 entitled \u201cAPPARATUS AND METHOD FOR AVOIDING DEADLOCKS IN A MULTITHREADED ENVIRONMENT\u201d, Ser. No. 09\/671,771 entitled \u201cAPPARATUS AND METHOD FOR VIRTUAL REGISTER MANAGEMENT USING PARTIAL DATA FLOW ANALYSIS FOR JUST-IN-TIME COMPILATION\u201d, Ser. No. 09\/671,873 entitled \u201cAPPARATUS AND METHOD FOR AN ENHANCED INTEGER DIVIDE IN AN IA64 ARCHITECTURE\u201d, Ser. No. 09\/671,874 entitled \u201cAPPARATUS AND METHOD FOR CREATING INSTRUCTION GROUPS FOR EXPLICITLY PARALLEL ARCHITECTURES\u201d, and Ser. No. 09\/671,875 entitled \u201cAPPARATUS AND METHOD FOR CREATING INSTRUCTION BUNDLES IN AN EXPLICITLY PARALLEL ARCHITECTURE\u201d, filed on even date herewith and hereby incorporated by reference.","1. Technical Field","The present invention is directed to an apparatus and method for detecting and handling software exceptions such as those thrown in Java and C++. More particularly, the present invention is directed to an apparatus and method for detecting and handling software exceptions in a machine having predication and explicit parallelism.","2. Description of Related Art","When a software exception is thrown, normal program flow is altered and an exception handler is invoked. Exceptions are typically thrown when an error or other exceptional condition is encountered. This tends to be a rare occurrence for most applications. However, to ensure that thrown exceptions are properly caught it may be necessary to check for their presence frequently. For example, a typical implementation of the Java Virtual Machines will include a check for a pending exception after each method invocation. Furthermore, some applications may use exception throwing as a common flow control device. For these applications, the efficient handling of exceptions is critical to their performance. Therefore, it would be beneficial to have an apparatus and method of efficiently detecting and handling exceptions. It would further be beneficial to have an apparatus and method for efficiently detecting and handling exceptions in a machine having predication and explicit parallelism.","An apparatus and method are provided for detecting and handling exceptions. The apparatus and method make use of predicate registers to identify whether or not an exception is pending. Instructions that are executed only when there is an exception pending are qualified by a first predicate register in the predicate register pair. Instructions that are executed only when there is no exception pending are qualified based on a second predicate register in the predicate register pair.","When an application or system is initialized, the predicate pair is set to indicate that no exception is pending, i.e. the first predicate is set to zero and the second is set to one. When an exception is thrown, the settings of the predicate pair is reversed thereby indicating the presence of a pending exception.","Whenever an exception must be detected, a branch instruction qualified by the first of the predicate pair is inserted into the instruction group at the site where detection is required. All instructions in the instruction group that precede the inserted branch are qualified by the second predicate. In this way, the standard instructions of the group will be executed when no exception is pending but only the inserted branch instruction will be executed when an exception is pending.","The target of the inserted branch depends on whether an exception handler is provided to handle exceptions at the detection site. If not the branch will target code that terminates the current method and returns to the method's caller. Otherwise the branch will target code that will invoke a lookup handler routine passing it parameters that identify the detection site. The lookup handler routine will determine if any of the exception handler(s) associated with the detection site handles the current pending exception. If so control will be passed to the handler. If not the current method will be terminated and a return will be made to its caller. Other features and advantages of the present invention will be described in, or will become apparent to those of ordinary skill in the art in view of, the following detailed description of the preferred embodiment.","With reference now to the figures, and in particular with reference to , a pictorial representation of a distributed data processing system in which the present invention may be implemented is depicted. Distributed data processing system  is a network of computers in which the present invention may be implemented. Distributed data processing system  contains a network , which is the medium used to provide communications links between various devices and computers connected together within distributed data processing system . Network  may include permanent connections, such as wire or fiber optic cables, or temporary connections made through telephone connections.","In the depicted example, a server  is connected to network  along with storage unit . In addition, clients , , and  also are connected to a network . These clients , , and  may be, for example, personal computers or network computers. For purposes of this application, a network computer is any computer, coupled to a network, which receives a program or other application from another computer coupled to the network. In the depicted example, server  provides data, such as boot files, operating system images, and applications to clients -. Clients , , and  are clients to server . Distributed data processing system  may include additional servers, clients, and other devices not shown. In the depicted example, distributed data processing system  is the Internet with network  representing a worldwide collection of networks and gateways that use the TCP\/IP suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high-speed data communication lines between major nodes or host computers, consisting of thousands of commercial, government, educational, and other computer systems, that route data and messages. Of course, distributed data processing system  also may be implemented as a number of different types of networks, such as, for example, an Intranet or a local area network.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1"},"With reference now to , a block diagram of a data processing system which may be implemented as a server, such as server  in , is depicted in accordance to the present invention. Data processing system  may be a symmetric multiprocessor (SMP) system including a plurality of processors  and  connected to system bus . Alternatively, a single processor system may be employed. Also connected to system bus  is memory controller\/cache , which provides an interface to local memory . I\/O Bus Bridge  is connected to system bus  and provides an interface to I\/O bus . Memory controller\/cache  and I\/O Bus Bridge  may be integrated as depicted.","Peripheral component interconnect (PCI) bus bridge  connected to I\/O bus  provides an interface to PCI local bus . A modem  may be connected to PCI local bus . Typical PCI bus implementations will support four PCI expansion slots or add-in connectors. Communications links to network computers - in  may be provided through modem  and network adapter  connected to PCI local bus  through add-in boards.","Additional PCI bus bridges  and  provide interfaces for additional PCI buses  and , from which additional modems or network adapters may be supported. In this manner, server  allows connections to multiple network computers. A memory mapped graphics adapter  and hard disk  may also be connected to I\/O bus  as depicted, either directly or indirectly.","Those of ordinary skill in the art will appreciate that the hardware depicted in  may vary. For example, other peripheral devices, such as optical disk drive and the like also may be used in addition or in place of the hardware depicted. The depicted example is not meant to imply architectural limitations with respect to the present invention.","The data processing system depicted in  may be, for example, an IBM RISC\/System 6000 system, a product of International Business Machines Corporation in Armonk, N.Y., running the Advanced Interactive Executive (AIX) operating system.","With reference now to , a block diagram of a data processing system in which the present invention may be implemented is illustrated. Data processing system  is an example of a client computer. Data processing system  employs a peripheral component interconnect (PCI) local bus architecture. Although the depicted example employs a PCI bus, other bus architectures such as Micro Channel and ISA may be used. Processor  and main memory  are connected to PCI local bus  through PCI Bridge . PCI Bridge  also may include an integrated memory controller and cache memory for processor . Additional connections to PCI local bus  may be made through direct component interconnection or through add-in boards. In the depicted example, local area network (LAN) adapter , SCSI host bus adapter , and expansion bus interface  are connected to PCI local bus  by direct component connection. In contrast, audio adapter , graphics adapter , and audio\/video adapter (A\/V)  are connected to PCI local bus  by add-in boards inserted into expansion slots. Expansion bus interface  provides a connection for a keyboard and mouse adapter , modem , and additional memory . SCSI host bus adapter  provides a connection for hard disk drive , tape drive , and CD-ROM  in the depicted example. Typical PCI local bus implementations will support three or four PCI expansion slots or add-in connectors.","An operating system runs on processor  and is used to coordinate and provide control of various components within data processing system  in FIG. B. The operating system may be a commercially available operating system such as OS\/2, which is available from International Business Machines Corporation.","An object oriented programming system such as Java may run in conjunction with the operating system and may provide calls to the operating system from Java programs or applications executing on data processing system . Instructions for the operating system, the object oriented operating system, and applications or programs are located on storage devices, such as hard disk drive  and may be loaded into main memory  for execution by processor . Hard disk drives are often absent and memory is constrained when data processing system  is used as a network client.","Those of ordinary skill in the art will appreciate that the hardware in  may vary depending on the implementation. For example, other peripheral devices, such as optical disk drives and the like may be used in addition to or in place of the hardware depicted in FIG. B. The depicted example is not meant to imply architectural limitations with respect to the present invention. For example, the processes of the present invention may be applied to a multiprocessor data processing system.","The present invention provides an apparatus and method for detecting and handling exceptions in a machine having predication and explicit parallelism. Although the present invention may operate on a variety of computer platforms and operating systems, it may also operate within a Java runtime environment. Hence, the present invention may operate in conjunction with a Java virtual machine (JVM) yet within the boundaries of a JVM as defined by Java standard specifications. In order to provide a context for the present invention, portions of the operation of a JVM according to Java specifications are herein described.","With reference now to , a block diagram illustrates the relationship of software components operating within a computer system that may implement the present invention. Java-based system  contains platform specific operating system  that provides hardware and system support to software executing on a specific hardware platform. JVM  is one software application that may execute in conjunction with the operating system. JVM  provides a Java run-time environment with the ability to execute Java application or applet , which is a program, servlet, or software component written in the Java programming language. The computer system in which JVM  operates may be similar to data processing system  or computer  described above. However, JVM  may be implemented in dedicated hardware on a so-called Java chip, Java-on-silicon, or Java processor with an embedded picoJava core. At the center of a Java run-time environment is the JVM, which supports all aspects of Java's environment, including its architecture, security features, mobility across networks, and platform independence.","The JVM is a virtual computer, i.e. a computer that is specified abstractly. The specification defines certain features that every JVM must implement, with some range of design choices that may depend upon the platform on which the JVM is designed to execute. For example, all JVMs must execute Java bytecodes and may use a range of techniques to execute the instructions represented by the bytecodes. A JVM may be implemented completely in software or somewhat in hardware. This flexibility allows different JVMs to be designed for mainframe computers and PDAs.","The JVM is the name of a virtual computer component that actually executes Java programs. Java programs are not run directly by the central processor but instead by the JVM, which is itself a piece of software running on the processor. The JVM allows Java programs to be executed on a different platform as opposed to only the one platform for which the code was compiled. Java programs are compiled for the JVM. In this manner, Java is able to support applications for many types of data processing systems, which may contain a variety of central processing units and operating systems architectures. To enable a Java application to execute on different types of data processing systems, a compiler typically generates an architecture-neutral file format\u2014the compiled code is executable on many processors, given the presence of the Java run-time system.","The Java compiler generates bytecode instructions that are nonspecific to a particular computer architecture. A bytecode is a machine independent code generated by the Java compiler and executed by a Java interpreter. A Java interpreter is part of the JVM that alternately decodes and interprets a bytecode or bytecodes. These bytecode instructions are designed to be easy to interpret on any computer and easily translated on the fly into native machine code.","A JVM must load class files and execute the bytecodes within them. The JVM contains a class loader, which loads class files from an application and the class files from the Java application programming interfaces (APIs) which are needed by the application. The execution engine that executes the bytecodes may vary across platforms and implementations.","One type of software-based execution engine is a Just-In-Time (JIT) compiler. With this type of execution, the bytecodes of a method are compiled to native machine code upon successful fulfillment of some type of criteria for \u201cjitting\u201d a method. The native machine code for the method is then cached and reused upon the next invocation of the method. The execution engine may also be implemented in hardware and embedded on a chip so that the Java bytecodes are executed natively. JVMs may interpret bytecodes or use other techniques, such as Just-In-Time compiling, to execute bytecodes. It is not uncommon for a JVM to interpret some methods and Just-In-Time compile others.","When an application is executed on a JVM that is implemented in software on a platform-specific operating system, a Java application may interact with the host operating system by invoking native methods. A Java method is written in the Java language, compiled to bytecodes, and stored in class files. A native method is written in some other language and compiled to the native machine code of a particular processor. Native methods are stored in a dynamically liked library whose exact form is platform specific.","With reference now to , a block diagram of a JVM is depicted in accordance with a preferred embodiment of the present invention. JVM  includes a class loader subsystem , which is a mechanism for loading types, such as classes and interfaces, given fully qualified names. JVM  also contains runtime data areas , execution engine , native method interface , and memory management . Execution engine  is a mechanism for executing instructions contained in the methods of classes loaded by class loader subsystem . Execution engine  may be, for example, Java interpreter  or just-in-time compiler . Native method interface  allows access to resources in the underlying operating system. Native method interface  may be, for example, a Java native interface.","Runtime data areas  contain native method stacks , Java frames , PC registers , method area , and heap . These different data areas represent the organization of memory needed by JVM  to execute a program.","Java frames  are used to store the state of Java method invocations. When a new thread is launched, the JVM creates a new Java stack from which the thread will allocate Java Frames. A thread is a part of a program, i.e. a transaction or message, that can execute independently of other parts. In a multithreaded environment, multiple streams of execution may take place concurrently within the same program, each stream processing a different transaction or message.","A Java frame contains all the information pertaining to a single method invocation and is commonly partitioned into three regions. The first region holds all local variables including the input parameters. The second region is typically fixed in size and contains various pointers used by the interpreter including a pointer to the previous frame. The third region is the Java operand stack which is a FIFO stack that holds operands and results of bytecode operations. The operand stack is also used to pass parameters during invocation. The JVM performs only two operations directly on Java operand stacks: it pushes and pops stack items. These items may be object references or primitives such as integers or floating point values.","When the interpreter  invokes a Java method, the interpreter  saves the return PC, i.e. a bytecode pointer, in the current frame and makes an indirect call via a JVM invoker field in a method block of the Java method, as described in greater detail hereafter. Upon return from the JVM invoker, the interpreter fetches the current frame and resumes execution starting with the bytecode specified in the returnPC field. When an interpreted method completes, the current frame is discarded and the previous frame is made current.","PC registers  are used to indicate the next instruction to be executed. Each instantiated thread gets its own pc register (program counter) and Java stack. If the thread is executing a JVM method, the value of the pc register indicates the next instruction to execute. If the thread is executing a native method, then the contents of the pc register are undefined.","Native method stacks  store the state of invocations of native methods. The state of native method invocations is stored in an implementation-dependent way in native method stacks, registers, or other implementation-dependent memory areas. In some JVM implementations, native method stacks  and Java frames  are combined.","Method area  contains class data while heap  contains all instantiated objects. The JVM specification strictly defines data types and operations. Most JVMs choose to have one method area and one heap, each of which are shared by all threads running inside the JVM. When the JVM loads a class file, it parses information about a type from the binary data contained in the class file. It places this type information into the method area. Each time a class instance or array is created, the memory for the new object is allocated from heap . JVM  includes an instruction that allocates memory space within the memory for heap  but includes no instruction for freeing that space within the memory.","Memory management  in the depicted example manages memory space within the memory allocated to heap . Memory management  may include a garbage collector which automatically reclaims memory used by objects that are no longer referenced. Additionally, a garbage collector also may move objects to reduce heap fragmentation.","The present invention is equally applicable to either a platform specific environment, i.e. a traditional computer application environment loading modules or native methods, or a platform independent environment, such as an interpretive environment, e.g., a Java environment loading classes, methods and the like. For purposes of explanation of the features and advantages of the present invention, examples of the operation of the present invention will assume a Java environment.","The present invention provides a mechanism by which exceptions in a machine having predication and explicit parallelism are detected and handled. In particular, the present invention may operate in a non-Mixed-Mode-Interpretation (non-MMI) Just-In-Time (JIT) compiler running in a Java Virtual Machine (JVM) on an IA64 platform. MMI describes an environment where methods are initially interpreted until they pass some threshold, such as a frequency of invocation or time consumed, at which time they are compiled. In a non-MMI environment, all methods are compiled. It should be appreciated, however, that the present invention is not limited to a non-MMI environment and may be implemented in MMI environments without departing from the spirit and scope of the present invention.","The IA64 platform is described in the Intel IA-64 Architecture Software Developer's Manual, available for download at http:\/\/developer.intel.com\/design\/ia-64\/downloads\/24531702s.htm, which is hereby incorporated by reference in its entirety. Briefly, IA64 allows a compiler or programmer to explicitly group instructions to be executed concurrently. IA64 also provides a set of 64 single bit predicate registers which can be used to control instruction execution. A predicated register can be associated with an instruction as a \u201cqualifying predicate.\u201d When the qualifying predicate is true, the instruction executes normally. When the qualifying predicate is false, the instruction will not modify architectural state thereby acting essentially as a no-operation (a NOP).","With the present invention, a pair of predicate registers P and P is utilized to determine if an exception is pending or not. In the case of the present invention, P is true when an exception is pending and is false otherwise. P is true when no exception is pending and false otherwise. The values of predicate registers are set by the results of instructions, such as compare (cmp) and test bit (tbit).","The present invention provides methods for using these predicate registers to detect and handle exceptions. In particular, the present invention provides a method for initializing the predicate register pair when crossing a boundary from non-JITted code to JITted code, a method for setting the predicate pair to indicate the presence of a pending exception, a method for running exception detecting instructions concurrently with instructions that are only allowed to complete if no exception is present, and a method to pass control to the appropriate exception handler when an exception occurs.","As mentioned above, the present invention includes a method for initializing a predicate register pair for use in exception detecting and handling when crossing a boundary from non-JITted code to JITted code. With the method of the present invention, when invoking a JITted method from non-JITted code, e.g., a native method or the JVM itself, a \u201cglue\u201d routine is used to set up the required environment, such as setting up input registers and various flags. A \u201cglue\u201d routine is a routine that is used to perform some conversion, translation or other process that makes one system work with another. In this case, the glue routine operates to allow a Java Virtual Machine and a Just-In-Time compiler to work together.","The glue routine of the present invention also sets the predicate register pair by examining an exception flag maintained by the JVM. If the exception flag in the JVM indicates that an exception occurred, the predicate registers are set to indicate an exception. In other words, P is set to true and P is set to false.","In addition, when returning to JITted code from non-JITted code, e.g., returning from a call into the JVM, small \u201cglue\u201d routines are executed to restore the state required by the JITted environment. If the call could have caused an exception to be thrown, the predicate register pair is set again, via examination of the exception flag, before returning to JITted code. When JITted code throws an exception, a routine is called which sets up storage locations to indicate the pending exception and additionally sets the predicate register pair to indicate the presence of the exception, i.e. P is set to true and P is set to false.","When the JIT compiler generates instructions following a method invocation, it is free to combine, in a single instruction group, instructions that must only execute in the presence of an exception with those which must only execute in the absence of an exception. Those instructions that must execute only when no exception is pending are qualified by predicate register P while the instructions that must execute when an exception is pending are qualified by predicate register P. By \u201cqualified\u201d what is meant is that the predicate register is a qualifying predicate, i.e. the predicate register is one whose value determines whether the processor commits the results computed by the instruction.","In a preferred embodiment, only a single branch instruction is used to handle the exception so that the code might appear as:",{"@attributes":{"id":"p-0060","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(P2)","ld \u2003r14=[r35]"]},{"entry":[{},"(P2)","mov \u2003r37=r8"]},{"entry":[{},"(P2)","adds \u2003r9=8, r8"]},{"entry":[{},"(P1)","br.cond.spnt \u2003handleException"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":"StartPC EndPC HandlerPC ExceptionType wordForJit"}}}},"If an invoke is not in a try range, the JIT compiler will generate the predicate register P qualified branch to go to an appropriate return stub. The collection of return stubs is placed so that they can be reached by a relative branch from any JITted method and are replicated if required.",{"@attributes":{"id":"p-0062","num":"0062"},"figref":"FIG. 4","b":["400","400","410"]},{"@attributes":{"id":"p-0063","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"mov \u2003ar.pfs = r35"]},{"entry":[{},"mov \u2003rp = r36"]},{"entry":[{},"br.ret \u2003rp"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0064","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"mov \u2003ar.pts = r35"]},{"entry":[{},"mov \u2003rp = r36"]},{"entry":[{},"br.cond \u2003MonitorExit"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"When a method is JITted, the results of the JIT compiler are stored in a JIT code buffer for use.  is an exemplary block diagram illustrating a JIT code buffer in accordance with the present invention. As shown in , the JIT code buffer  stores the return stubs for the methods, the lookup handler and compiled methods. The JIT code buffer  may be of various sizes but is typically 16 MB in size. Of these 16 MB, less than 4 k is used to store the returns stubs and lookup handler. The remainder of the JIT code buffer  is used to store the compiled methods.","The compiled JITted methods may make use of the return stubs stored in the JIT code buffer  during exception handling. Exception handling is performed using the lookup handler which either invokes the compiled method exception handler or passes control to the return stubs in the JIT code buffer .","The stubs perform whatever return function is required of the method, including monitor release for synchronized methods. The return stubs perform a \u201cpure\u201d return as is required for exception handling. This provides complete freedom to the JIT compiler when creating standard return sequences that will be used for non-exception returns. For example, a standard return could contain conditional storage modifications that would not be allowed when an exception was present.","With the present invention, if an exception is encountered, and the exception is within a try block of the method, the JIT compiler creates a branch to a \u201csnippet,\u201d which is code generated specifically for that method. The snippet identifies a known register with the bytecode offset of an invoke that branches to a lookup handler. An example snippet is:",{"@attributes":{"id":"p-0069","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"mov \u2003r8 = pc"]},{"entry":[{},"mov1 \u2003r9 = currentMethodBlock"]},{"entry":[{},"br.cond \u2003LookupHandler"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The lookup handler searches the method's exception table to see if the bytecode offset is within the range of a try block which handles the current instructions. If it is, the predicates are reset to indicate no pending exception and control is passed to the compiled exception handler for the method. Otherwise, a branch is made to the return stub appropriate for this method with the predicate registers indicating a pending exception.","In this way, methods that do not handle the current exception return to the calling routine with P=true and P=false. The post invoke code for that call is executed and the appropriate return stub or snippet is invoked until the exception is handled. If the exception is not handled by any method in the call chain, the JVM terminates the thread and prints a stack trace identifying the exception.",{"@attributes":{"id":"p-0072","num":"0072"},"figref":["FIG. 6","FIG. 6"],"b":["610","620"]},"If there are instructions before the exception branch, the predicate register P predicated instructions are generated (step ). Thereafter, or if there are no instructions before the exception branch, a determination is made as to whether or not the instruction is in a try block, or range, of the method (step ). If not, the predicate register P predicated instructions to branch to a return stub for the method is generated (step ). If the instruction is in a try block, the predicate register P predicated instruction to branch to a snippet associated with the method is generated (step ). The snippet is then generated (step ).",{"@attributes":{"id":"p-0074","num":"0074"},"figref":["FIG. 7","FIG. 7"],"b":["710","720","730"]},"Thus, the present invention provides methods for using predicate registers to detect and handle exceptions. In particular, the present invention provides a method for initializing the predicate register pair when crossing a boundary from non-JITted code to JITted code, a method for setting the predicate pair to indicate the presence of a pending exception, a method for running exception detecting instructions concurrently with instructions that are only allowed to complete if no exception is present, and a method to pass control to the appropriate exception handler when an exception occurs.","It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable-type media such a floppy disc, a hard disk drive, a RAM, and CD-ROMs and transmission-type media such as digital and analog communications links.","The description of the present invention has been presented for purposes of illustration and description, but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention, the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objectives and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
