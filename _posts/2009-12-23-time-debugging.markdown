---
title: Time debugging
abstract: A design time debugging tool provides debugging information available from the compiler during design time, as if a user were debugging code that provided the debugging information, by exposing information available from the compiler without initiation of a debugging session and without executing the program being debugged.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08621435&OS=08621435&RS=08621435
owner: Microsoft Corporation
number: 08621435
owner_city: Redmond
owner_country: US
publication_date: 20091223
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Debugging refers to the process of inspecting and observing a computer program behavior and state during execution of the program. Traditional debugging tools allow program execution to be stopped at a specific line of code or when a specific condition occurs, at which time the developer can inspect program state. For example, for variables that are in scope, the developer can see the values of the variables at the time that the program execution broke. The developer can also run new code in the context of the debugged program and observe the new state of the application and its data structures. This practice is commonly used for the purpose of finding and correcting bugs (defects) in a computer program so that it executes as expected and in the process of writing new applications or functionality where observing the behavior of an existing application is helpful. Debugging in general is a time-consuming, tedious task. Often debugging tools are provided to make the job a little less onerous.","Run time debugging tools are software tools that enable a developer or tester to monitor the execution of a program. The user can stop or pause the execution of the program, re-start it, set breakpoints, inspect values in memory, change values in memory and so on. Run time debugging tools provide information about a running instance of the program and are not able to provide information during design time.","When creating plug-ins, add-ons, automation components or extensions (hereafter called \u201cextensions\u201d herein) for applications that have an extensibility model, debugging becomes a useful technique to inspect and explore the application's state when the extension is running in the context of the application. It is helpful to have knowledge of the data structures and object models that are created based on the different states of the extension. Today, information about the data structures and object models of the application associated with a particular state of the extension is typically provided by run time debugging of the extension as it executes within the context of a particular instance of the application but is not available when the extension is not executing. As described herein, information based on the data structures and objects of an instance of the application is exposed during regular interaction with the application, without having to execute and debug the extension. Examples of such applications include but are not limited to Visual Studio\u00ae and Microsoft\u00ae Office. Examples for such extensions include but are not limited to coloring in Visual Studio\u00ae or macros in Microsoft\u00ae Office.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","Overview","Some integrated development environments (IDEs) such as Eclipse, Visual Studio\u00ae and others include an array of debugging tools. For example, some IDEs include an interactive, run time debugger that can be used for debugging applications written in any language supported by the IDE. The debugger may be able to attach to a running process inside or outside of the IDE to monitor and debug that process. If source code for the running process is available, the debugger may be able to display the source code as the program is being run. If source code is not available, the debugger may be able to show the disassembly.","The debugger may allow a developer or other user to set breakpoints that allow execution to be stopped temporarily at a certain point in the code, values of objects created during execution of the program being debugged to be inspected and changed and execution to resume. The debugger also may support user interfaces such as watch windows in which the values of variables are monitored and displayed as execution of the program continues. Breakpoints may be able to be conditional, meaning that a breakpoint can be triggered when a specified condition is met. A user may be able to execute one line of source code at a time, step into functions to debug inside the function, or step over a function, hiding what happens during execution of the function body. In some debuggers, during a debug session, if a user hovers a mouse pointer over a variable, the current value of the variable may be displayed in a data tooltip where the value can also be modified if desired. The debugger may include an expression evaluator feature that can evaluate an expression in the context and state of the debugged application.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"i":["a ","c","f"],"b":["104","102","142","144","104","106","112","108","110","114","118","116","126","128","132","102","134","130","134","136"]},"Suppose, however, that a developer wants to write some code that executes within the context of another program. An example of code that executes in the context of another program is code that is an extension to an application such as an IDE. Suppose, for example, the extension code provides a refactoring functionality and that the extension code manipulates user code by reordering parameters a and b of a function A. Today, to determine if the extension code operates correctly on function A, the developer writes the extension code and incorporates the extension into the IDE of a user project that includes some code where function A is used. The developer then gets the compiler's view or representation of the user code by starting the compiler within the user project. He attaches a debugger to the parameter reordering code in another instance of the IDE. He inserts breakpoints in the extension code and when a breakpoint is encountered, the developer steps through the data structures created by the compiler from the user code to see if the extension code has had the desired effect on the user code.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1","i":"d ","b":["102","148","152","158","150","158","152","154","158","156"]},"In accordance with aspects of the subject matter disclosed herein, as illustrated in , in contrast to the above, a single instance of an IDE  is instantiated on a computer . A design time editor  displays source code  under interactive development by a user. The source code  displayed in the design time editor  may comprise extension code, that is, code that acts upon or extends the functionality of another application. The extension code may act upon a particular user instance of a type of application. For example, the extension code may extend the functionality of a user's Excel\u00ae spreadsheet. Alternatively, the extension may extend the functionality of a source code editor for a particular language in an IDE in which a particular user project has been loaded and so on. The design time editor  raises events representing developer changes to the extension code during interactive development of the extension code. The events raised by the design time editor  are monitored by the design time debug engine .","The design time debug engine  in response to the events raised by the design time editor  can request information from the design time compiler . The information requested can include information about objects created by the compiler associated with the code on which the extension acts, information associated with user files including code files, designer artifacts, resource files, and so on, objects associated with the compiler, objects associated with the IDE responsive to user interactions with the IDE. This information can be formatted and displayed in the design time debug user interface , as described more fully below, even though the extension code is not being executed. The design time debug engine  also monitors user interactions in the design time debug user interface  and in response thereto, may change the display of source code  in the design time editor  or may change the information displayed in the design time debug user interface . For example, a section of code in the source code editor may be highlighted in response to a user interaction in the design time debug user interface , and so on.","It will be appreciated that in the above illustrative, non-limiting examples, the user code being manipulated by the extension code can be a hosting application and the extension code can be a hosted application. Aspects of the subject matter disclosed herein can be similarly applied in other hosting scenarios such as but not limited to any extensible application including but not limited to Microsoft\u00ae Excel\u00ae. For example, most browsers are extensible, having plug-ins to support Flash applications, Java applets and so on. Such a plug-in may display the browser object model as a user interacts with the webpage. In accordance with aspects of the subject matter disclosed herein, similar information concerning a particular state of the hosting application is available during design time of the hosted application and is displayed in the design time debug user interface.","Design Time Debugging","A software extension, as the phrase is used herein, is a computer program that is designed to be incorporated into another piece of software to enhance or extend the functionalities of the software into which it is incorporated. That is, the software extension is supposed to be run within the context of or to be hosted by another (hosting) application. Other terms used to denote software extensions are add-ons, add-ins or plug-ins. On its own, a software extension is typically not useful or functional. Examples of software applications that support extensions include Visual Studio\u00ae and Eclipse, browsers such as the Mozilla Firefox Web browser, and applications such as Adobe Systems Photoshop, Microsoft\u00ae Excel\u00ae and Microsoft\u00ae Windows Explorer, all of which provide for extensions. Commonly, applications whose scope is potentially unbounded will feature an extensions application programming interface (API). Descriptions of the APIs are often published so that third-party developers can produce extensions.","One of challenges of writing software extensions is understanding the APIs and the data structures of the hosting application in any given state of the end user (hosting) program. For example, in a development environment, understanding the language compilers and the data structures created by the language compilers is a non-trivial endeavor. Today, to be able to see the data structures of the hosting program, a debugger has to be attached to the software extension (hosted) code that uses the data structures. To be able to attach a debugger to the software extension code, the developer has to write code inside the extension that has the development environment and compiler objects in scope. He has to set the correct high level context for these objects (e.g., load in the correct files or project that the extension is loaded in). After that, often, more specific information has to be found to be able to display the relevant part of a data structure. For example, it may be insufficient to get a full parse tree for a particular open file in the development environment. Instead displaying a particular parse node may be much more helpful. A more particular context may be provided so that the particular parse node can be displayed, by, for example, using a current location of a cursor in an editor.","After the code is syntactically correct, the developer compiles and deploys the code in the IDE so that the next time the development environment is started, the extension will be included in the running code. Finally, the development environment is started, a project encapsulating the desired scenario is opened, a debugger is attached to the running application (extension code) and debugging tools are used to investigate the applicable data structures.","Suppose, for example, a developer is writing a software extension comprising an extension to a compiler and wants to debug the compiler as it is running on a user instance of an order processing program. If the developer wants to determine how the compiler looks at the order processing code, he starts the compiler within the user project, attaches a debugger to the compiler process and inserts breaks to determine the compiler view of the order processing program. That is, the compiler API is investigated as it has a specific state where the input is the executing order processing program. Two instances of the development environment are running: one in which the order processing program is running and one in which the compiler that manipulates the order processing program is running.","In contrast, in accordance with aspects of the subject matter disclosed herein, debug information for the software extension for the active document or project is provided as if the user were debugging code that provided this data. This information is provided by exposing known information about the environment using tools such as the compiler watch window and other traditionally run time debug user interfaces such as data tooltips and expression evaluators without creating a run time debugging session. The design time debugging information is provided automatically as the user changes application state without user intervention.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 1","FIG. 3","FIG. 4","FIG. 4"],"i":"b ","b":["101","103","101","101","101","105","101"]},"System  may include one or more of: a processor (such as processor ), a memory , and a design time debugging module . Other components well known in the art may also be included but are not here shown. It will be appreciated that design time debugging module  can be loaded into memory  to cause one or more processors such as processor  to perform the actions attributed to the design time debugging module . Design time debugging module , in accordance with aspects of the subject matter disclosed herein, may receive one or more of: user input  and one or more data sources (not shown) and display substantially simultaneously: source code of an extension (first program) under interactive development and run time debugging information based on data structures and\/or objects associated with an instance of an extensible IDE in a design time debug user interface without executing the extension. The information displayed in the design time debug user interface can be displayed automatically (e.g., without human intervention to request the display of the information). Moreover, the information displayed in the design time debug user interfaces can change automatically responsive to user interaction manipulating the application. For example, information displayed in the design time debug user interfaces can change automatically responsive to user interaction manipulating source code of an IDE, or by user interaction manipulating the information presented in the design time debug user interfaces. The information presented in the design time debug user interfaces may include run time debug information based on execution of the application (second program).","The design time debugging module may include one or more of: an application that is associated with a user interface and with an extensibility API that allows a user to observe and manipulate the application's data structures. For example, the design time debugging module may include an application such as Excel\u00ae having a user interface that enables a user to set up a spreadsheet and program tasks using macros and an extensibility API that allows a user to observe and manipulate the data structures generated by Excel\u00ae.","The design time debugging module  may include one or more of: an editor , a compiler  and a design time debug engine . Editor  may comprise a source code editor. Editor  may generate design time editing events based on user input manipulating the source code of the first program, changes to cursor position or focus in the source code editor, edits to or manipulation of source files, or by receiving an event caused by a user clicking on relevant menu items. Editor  may send the design time editor events to the design time debug engine .","The design time debug engine  may request an updated view of data structures, objects and so on from the compiler  based on the received editor events. Compiler  may represent a background compiler, dynamic parser or parallel compiler. As code is being written, such a compiler may compile the code in the background to provide feedback about syntax and compilation errors, which may be flagged with an indicator such as a red wavy underline or the like. Warnings may also be marked, such as with a green underline or the like. The compiler  may generate or refresh a language model, and send a refreshed view of the current language model, compiler-generated objects, compiler-generated data structures, IDE objects, IDE data structures and so on to the design time debug engine  in response to requests received from the design time debug engine .","Design time debug engine  can generate run time debugging information based on the information received from the compiler  or application and display the run time debugging information in design time debug user interfaces such as debugger windows available at design time when the end user is interactively writing code. Information that populates the design time debug user interfaces can be responsive to user events such as changes to cursor position in the source code editor, edits to source files, by receiving a user interaction such as an event caused by the user clicking on relevant menu items, or by user interaction with the design time debug user interfaces.","When such an event is detected or received by the design time debug engine , the design time debug engine  may ask the compiler  to refresh the compiler's representations of data structures or objects associated with an instance of the second program, or representations of data structures or objects associated with the compiler or IDE. The information returned to the design time debug engine  by the compiler may be presented to a user through design time debug user interfaces that resemble traditional run time debugging user interfaces displayed during a traditional run time debug session. The design time debug user interfaces include but are not limed to a watch window , an expression evaluator  and data tooltips . The information displayed in the design time debugging user interfaces presents information that is based on the compiler view of the state of the hosting (second) program. The information may include information about files, compiler objects and references. It will be appreciated that this run time debug information is displayed without execution of the first program, during development of the first program during design time.","The design time debug engine  may also monitor user interactions with the design time debug user interface(s). In response to detecting a user interaction within the editor  or within the design time debug user interface, the content of the information displayed in the design time debug user interface may be automatically refreshed or modified. In response to detecting a user interaction within the design time debug user interface, the appearance of information displayed in the design time editor may be automatically modified, for example a section of source code may be highlighted, and so on.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 1","i":"f ","b":["172","172","17","174","17","174","177","176","17","17","1","178","1","178","180","182","17","174"]},"In contrast, is an example of a display  for a design time debug user interface  as might be displayed during interactive design time development of software extension code Module   in and editor As a developer types in the code of Module  in a design time editor, a design time debug user interface such as design time debug user interface  is automatically displayed. No debug session is initiated. Module  is not executing. As the developer navigates within the code (using the cursor, for example), the design time debug user interface, displays information about the compiler object that is associated with the point at which the cursor is located. The information that is displayed in the design time debug user interface  can include information concerning types inherent to the compiler  and objects created by the compiler  to represent types of members that are associated with the description of the source code, data structures and objects created by the compiler  and data structures and objects associated with the IDE in which the compiler is executing.","For example, design time debug user interface  displays the call statement node CallStatementNode , that is the compiler's representation of the console writeline method call (Console.WriteLine(\u201cfff') line . CallStatementNode  represents an object that describes the line (Console.WriteLine(\u201dfff') line  in the source code . By looking at design time debug user interface , the value of CallStatementNode : (Console-WriteLine(System.Collections.Object))  can be ascertained, as can the type of CallStatmentNode : (Microsoft\u00ae.VisualBasic.Syntax.CallStatement) . The design time debug user interface  displays information concerning the children of CallStatementNode . One of the children of CallStatementNode  is the method to be called. The method to be called is represented by the property QualifiedNode  which points to an object that represents the method. The value of the object pointed to by QualifiedNode  is Console-.WriteLine . The type of QualifiedNode  is one of the types inside the compiler : Microsoft\u00ae.VisualBasic.Syntax.QualifiedNode. Thus the design time debug user interface  displays a tree structure that represents the syntax tree of the code displayed in the source code editor, e.g., source code . The root node of the tree is the call statement node that represents the whole line of code. The tree itself includes subtrees representing the method being called, the arguments for the method and so on. Each of the items displayed in design time debug user interface  can itself be inspected by selecting the item to be expanded.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 2","FIGS. 1"],"b":["200","1","1","109"],"i":["b","e ","g "]},"When an editing event is detected by the design time debug engine , the design time debug engine requests an application or compiler such as compiler  described above to refresh its view of data structures and objects associated with the second program . In response to receiving the updated information from the compiler , the design time debug engine displays design time debugging information  as described above with respect to . When a user interaction with the design time debug user interface is detected by the design time debug engine , the design time debug engine requests a compiler such as compiler  described above may request a different view of data structures and objects associated with the second program. In response to receiving the updated information from the compiler , the design time debug engine displays design time debugging information  as described above with respect to . In a manner similar to the behavior of the runtime debug user interfaces, the design time debug engine may also monitor user interaction with the design time debug user interfaces and responsive thereto, modify the display of the source code in the editor. For example, in response to receiving user input selecting a node in the design time debugging user interface, a section of the source code displayed in the editor corresponding to that node may be highlighted in the editor. When a user types an expression in the design time watch window the result of this expression can be reflected in the application itself, e.g., in the source editor.","Example of a Suitable Computing Environment","In order to provide context for various aspects of the subject matter disclosed herein,  and the following discussion are intended to provide a brief general description of a suitable computing environment  in which various embodiments may be implemented. While the subject matter disclosed herein is described in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other computing devices, those skilled in the art will recognize that portions of the subject matter disclosed herein can also be implemented in combination with other program modules and\/or a combination of hardware and software. Generally, program modules include routines, programs, objects, physical artifacts, data structures, etc. that perform particular tasks or implement particular data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. The computing environment  is only one example of a suitable operating environment and is not intended to limit the scope of use or functionality of the subject matter disclosed herein.","With reference to , a computing device for software development in the form of a computer  is described. Computer  may include a processing unit , a system memory , and a system bus . The processing unit  can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit . The system memory  may include volatile memory  and nonvolatile memory . Nonvolatile memory  can include read only memory (ROM), programmable ROM (PROM), electrically programmable ROM (EPROM) or flash memory. Volatile memory  may include random access memory (RAM) which may act as external cache memory. The system bus  couples system physical artifacts including the system memory  to the processing unit . The system bus  can be any of several types including a memory bus, memory controller, peripheral bus, external bus, or local bus and may use any variety of available bus architectures.","Computer  typically includes a variety of computer readable media such as volatile and nonvolatile media, removable and non-removable media. Computer storage media may be implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer-readable storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CDROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer .","It will be appreciated that  describes software that can act as an intermediary between users and computer resources. This software may include an operating system  which can be stored on disk storage , and which can control and allocate resources of the computer system . Disk storage  may be a hard disk drive connected to the system bus  through a non-removable memory interface such as interface . System applications  take advantage of the management of resources by operating system  through program modules  and program data  stored either in system memory  or on disk storage . It will be appreciated that computers can be implemented with various operating systems or combinations of operating systems.","A user can enter commands or information into the computer  through an input device(s) . Input devices  include but are not limited to a pointing device such as a mouse, trackball, stylus, touch pad, keyboard, microphone, and the like. These and other input devices connect to the processing unit  through the system bus  via interface port(s) . An interface port(s)  may represent a serial port, parallel port, universal serial bus (USB) and the like. Output devices(s)  may use the same type of ports as do the input devices. Output adapter  is provided to illustrate that there are some output devices  like monitors, speakers and printers that require particular adapters. Output adapters  include but are not limited to video and sound cards that provide a connection between the output device  and the system bus . Other devices and\/or systems or devices such as remote computer(s)  may provide both input and output capabilities.","Computer  can operate in a networked environment using logical connections to one or more remote computers, such as a remote computer(s) . The remote computer  can be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . Remote computer(s)  can be logically connected via communication connection . Network interface  encompasses communication networks such as local area networks (LANs) and wide area networks (WANs) but may also include other networks. Communication connection(s)  refers to the hardware\/software employed to connect the network interface  to the bus . Connection  may be internal to or external to computer  and include internal and external technologies such as modems (telephone, cable, DSL and wireless) and ISDN adapters, Ethernet cards and so on.","It will be appreciated that the network connections shown are examples only and other means of establishing a communications link between the computers may be used. One of ordinary skill in the art can appreciate that a computer  or other client device can be deployed as part of a computer network. In this regard, the subject matter disclosed herein man pertain to any computer system having any number of memory or storage units, and any number of applications and processes occurring across any number of storage units or volumes. Aspects of the subject matter disclosed herein may apply to an environment with server computers and client computers deployed in a network environment, having remote or local storage. Aspects of the subject matter disclosed herein may also apply to a standalone computing device, having programming language functionality, interpretation and execution capabilities.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 4","b":["600","602","600","610","600","600","650","610","611","620","611","650","660"]},"A user can create and\/or edit the source code component according to known software programming techniques and the specific logical and syntactical rules associated with a particular source language via a user interface  and a source code editor  in the IDE . Thereafter, the source code component  can be compiled via a source compiler , whereby an intermediate language representation of the program may be created, such as assembly . The assembly  may comprise the intermediate language component  and metadata . Application designs may be able to be validated before deployment.","The various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus described herein, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing aspects of the subject matter disclosed herein. In the case of program code execution on programmable computers, the computing device will generally include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may utilize the creation and\/or implementation of domain-specific programming models aspects, e.g., through the use of a data processing API or the like, may be implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","While the subject matter disclosed herein has been described in connection with the figures, it is to be understood that modifications may be made to perform the same functions in different ways."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In the drawings:",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1","i":"a "},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1","i":"b "},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1","i":"c "},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1","i":"d "},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1","i":"e "},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1","i":"f "},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1","i":"g "},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
