---
title: System and method for designing and implementing packet processing products
abstract: A system and method for allowing a user to create instructions for building a packet processing integrated circuit. The system includes a user interface for allowing a user to define a desired packet processing algorithm () using a plurality of discrete packet processing blocks (), each of the blocks corresponding to a portion of the desired packet processing algorithm (). The system allows the user to define connections () between the plurality of packet processing blocks (). The system processes a plurality of packet processing blocks () and the connections to provide a list of instructions in a hardware description language for producing an integrated circuit capable of executing the desired packet processing algorithm (). The list of instructions can be delivered to a customer (), or the customer can receive an integrated circuit constructed using the list of instructions (), or the customer can receive a NETLIST generated using said list of instructions (). The plurality of packet processing blocks () can include a Packet Processing Unit (PPU, PPUX) , a Packet Modification Unit (PMU) , and a Decision and Forwarding Unit (DFU) 
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07724684&OS=07724684&RS=07724684
owner: Modelware, Inc.
number: 07724684
owner_city: Red Bank
owner_country: US
publication_date: 20070524
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["1. Field of the Invention","The present invention relates to digital component design and implementation systems and, more particularly, to a system and method for designing and implementing packet processing products.","2. Related Art","Computer-based communications are dominated by the transmission of packets of data. Typically, a packet contains a payload, i.e., a portion of an overall data message, surrounded by a number of header bits or bytes, that are used to insure that the payload is transmitted and received without error. The header bits or bytes can be divided into a number of fields designating commands, responses, packet characteristics, etc. The fields can take on one or more values depending on the particular protocol used. Some protocols are custom-designed, while others, such as asynchronous transfer mode (ATM) or Transmission Control Protocol\/Internet Protocol (TCP\/IP), are standardized. For any type of protocol, there is a need to extract and examine the header bits or bytes to make decisions as to how to classify a type of packet, where to route the packet, and whether to drop or temporarily store (queue) the packet for future processing. The header must be parsed, bits or bytes examined or processed, and then routing decisions must be made.","Various hardware and software products have, in the past, been developed for designing and implementing products for processing and classifying data packets. In one approach, parsing, decision, and routing functions are implemented in software modules executed by the host processor and memory of the receiving computer. Processing large amounts of data in real time is often slow, since doing so puts a strain on processor resources. A second approach is to use a specialized microprocessor and associated hardware, called a network processing unit (NPU). The NPU provides a programmable interface for programming nearly any type of protocol functionality. However, the ability to program nearly every aspect of a transmission packet protocol burdens an NPU with a large amount of functionality, rendering an NPU both expensive and slow (low data rates). Also, the time needed for a developer to program an NPU may take several hours to days, which can be cost prohibitive. Another approach is to design a customized application specific integrated circuit (ASIC). This approach often wastes large numbers of gates to achieve only limited functionality, and is thus not cost effective. As such, there is a lack of an adequate system or methodology for designing and implementing packet parsing and classification products, wherein such products can be designed and implemented.","Accordingly, what would be desirable, but has not yet been provided, is a system and method for designing and implementing packet processing products which addresses the foregoing limitations.","The present invention relates to a system and method for designing and implementing packet processing products, wherein a user can create instructions for building a packet processing integrated circuit. The system includes a user interface for allowing a user to define a desired packet processing algorithm by defining a plurality of discrete, packet processing blocks, each of the blocks corresponding to a portion of the desired packet processing algorithm, as well as connections between the plurality of packet processing blocks. The system processes the plurality of packet processing blocks and the connections to provide a list of instructions in a hardware description language for producing an integrated circuit capable of executing the desired packet processing algorithm. The list of instructions can be delivered to a customer, or the customer can be provided with an integrated circuit constructed using the list of instructions. The customer can also be provided with a NETLIST generated using said list of instructions.","The packet processing blocks of the present invention include a Packet Processing Unit (PPU), a Packet Modification Unit (PMU), and a Decision and Forwarding Unit (DFU). The PPU includes functionality for extracting a header of a packet; for pointing to a portion of the header of a predetermined width using a predetermined index of a bit location in the header; for comparing the data represented by the portion of the header with at least one predetermined value; and for declaring a match when the result of the comparison is true. A variation of a PPU, called a PPUX, includes functionality for accessing an external Content-Addressable Memory (CAM) or Random-Access Memory (RAM). The PMU includes functionality for extracting a packet; pointing to a portion of the packet of a predetermined width using a predetermined index of a bit location in the packet; and modifying the portion of the packet. A packet can be modified in one of three ways: deletion, insertion, or overwriting a portion of the packet. The DFU can perform one of drop, queue, and forwarding operations on packets coming from at least one PPU, PPUX, or PMU. The PPU, PPUX, PMU, and DFU can be programmed by an external microprocessor.","Further features and advantages of the invention will appear more clearly on a reading of the detailed description of an exemplary embodiment of the invention, which is given below by way of example only with reference to the accompanying drawings.","Referring to , a process according to the present invention for designing packet processing products is shown. The present invention allows a user to design packet processing products using a high-level programming language which generates a NETLIST for generating a hardware design specification of a digital circuit. A NETLIST describes the connectivity of an electronic design. The design process begins at step , wherein a set of user requirements and specifications are received, which may be in the form of a packet parsing architecture or a packet parsing and classification algorithm. Typically, these requirements are in the form of a text description of the system to be generated. At step , the description is translated by the user or provider into a textual or graphical design using packet processing blocks which include Packet Parsing Units (PPU), Packet Parsing Units with an external interface to a CAM\/RAM (PPUX), Packet Modification Units (PMU), and Decision and Forwarding Units (DFU), which will be described hereinbelow with reference to .","As an example of step , if the customer needs a firewall that accepts TCP packets and rejects UDP packets, then three PPUs and one DFU are required. One of the PPUs is devoted to determining a source IP address; a second PPU is devoted to extracting a destination IP address; and a third PPU is devoted to distinguishing between TCP and UDP packets. The three PPUs are connected in parallel (since the information can be extracted simultaneously from the same packet), and the \u201cmatch\u201d outputs of the PPUs (to be described with reference to ) and a source packet is forwarded to a DFU. Once the source and destination addresses are extracted from the packet and the type of packet is extracted, the DFU takes each match input and the packet and makes a decision: If the packet is a TCP packet and the source and destination addresses are allowed, then the packet is passed on, otherwise the packet is to be dropped. Thus, in step , the user can select the required number and combination of packet processing blocks to be used in the design.","At step , the packet processing block requirements, including their required inputs and outputs, are entered into a connection document, which can be a text based EXCEL\u2122 spreadsheet or a VISIO\u2122 block diagram. Typical inputs to the connection document include entries for each PPU and DFU block, which may include an index representing the point of entry into a packet to be processed, and whether a lookup in an internal table of data in a PPU is required.","Once the connection document has been completed, then, at step , packet processing blocks, e.g., each PPU and DFU, can be configured. Configuring a packet processing block involves taking a \u201cdefault\u201d packet processing block file, such as a generic PPU or DFU file, and modifying portions of it and setting variables within each file. Code for the packet processing blocks to be described in  (written in pseudo-code) can be found in Appendices A-E and G-L attached hereto. In particular, the pseudo-code for the PPU calls code found in the following appendices: a file for describing a generic header extraction block called a Hardware Lookup Unit (HLU) (see Appendices D and K), and a file for describing a generic Match\/Lookup Unit (MLU) (see Appendices E and L). Both the HLU and MLU will be described hereinbelow as part of the description of the PPU. The packet processing blocks are implemented in a hardware design language (HDL) which models digital circuits, with gates, flip flops, counters, and other logic in a C-like software language. In some implementations, the \u201cpruning\u201d process can be performed by manually copying and editing a maximally configured processing block file, or by applying a preprocessor in the form of shell scripts to cull code from and substitute variables within a maximally configured processing block files. Preprocessing shell scripts, as is known in the art, can include textual or graphically-based user prompts for answering questions about specific parameters desired by the user for a particular block.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIGS. 2A-2D","FIG. 2A","FIG. 2B","FIG. 2C","FIG. 2D"],"b":["13","13","15","15","16","17","18","19"]},"The GUI code can pass the input parameters to a preprocessor, such as a preprocessor called \u201cveriloop2.\u201d The pseudo-code for veriloop can be found in Appendix F. Veriloop first performs substitutions into appropriate variables using the parameters passed from the GUI. Veriloop then searches for constructs such as name-value pairs, conditional constructs, and loops having a particular syntax, and then culls the maximally configured packet processing block file to produce a preprocessed header-like library files, each containing a function or class representing a particular PPU, DFU, etc. Pseudo code for types of preprocessor constructs can be found in Appendix G. Pseudo code for sample pre-processed files of  can be found in Appendices H-L. Note that there is only one PPU\/MLU\/HLU file for all three PPUs, which share the same number of inputs\/outputs and share the same general structure. The number of PPUs that need to be generated depends upon the degree of parallelism needed for a particular design. If all the operations for a number of PPUs can be performed in series, then one PPU is needed, since all that changes between instances of PPUs is the input parameters (e.g. opcode, mask, etc.). There is one generated PPU for each parallel operation. There are separate DFU Appendices (i.e., Appendices B, H, and I because each DFU can have a different number of inputs\/outputs).","The present invention distils the implementation of maximally configured processing blocks into common sub-blocks which have unique names (e.g., PPU_, DFU_) or modules which have inputs and outputs that can be interconnected in such a way as to perform all of the functions necessary for implementing a desired packet processing product. The common blocks described herein are preferably instantiations of packet processing blocks written in VHDL, Verilog, or System C, but other suitable hardware description languages can be used. The software implementation of packet processing blocks is platform independent, and can be written in a platform independent language such as JAVA. As such, packet parser\/classifier functionality of the present invention can run both in Windows and in different versions of the Unix operating system, as well as others. In a GUI, the programmer\/designer can invoke instances of these common modules using a C-like application programming interface (API) surrounded by other C-like code for interconnecting the sub-blocks.","At step , integration is performed. Integration involves declaring instantiations of each processing block by name, and making connections between instantiated packet parsing blocks in a top-level main program file (the top-level main program file is similar to the file containing the main( ) function call in C language). These connections are called \u201cwires\u201d or \u201csignals\u201d which are declared like variables, and associations are made between two processing block instances which have a common wire. For example, signal \u201cx\u201d in PPU ties to signal \u201cy\u201d in the top level file. Signal \u201cz\u201d of DFU also ties to signal \u201cy\u201d in the top level file. In this way, signal \u201cx\u201d of PPU is tied to Signal \u201cz\u201d of DFU which may also be tied to one or more other signals. Certain input parameters can also be \u201chard-coded\u201d within the top-level file.","At this point, all source HDL code has been generated which together can constitute a fully designed product. At step , if the customer desires only the design, then at step , the generated packet processing block files and the top level file can be delivered to the customer. If the customer desires to have a NETLIST, then at step , the generated files are run through a commercially-available synthesis tool, as is known in the art. Sample synthesis tools include Design Compiler from Synopsis, Precision Synthesis from Mentor Graphics, Sinplify from Synplicity, or XST from Xilinx. The synthesis tool behaves like an optimizing compiler which produces a NETLIST for producing an electrical schematic for a custom integrated circuit which is implemented with a minimum number of logic gates, flip-flops, counters, etc. The type of NETLIST generated depends on whether the customer desires to have a foundry-specific device, e.g. a Xilinx FPGA or a generic (\u201cvirtual\u201d) NETLIST which is not specific to a particular vendor's product. Customers which are EDA (electronic design automation) vendors desire a non-specific NETLIST. The NETLIST could be a foundry-specific or \u201cvirtual\u201d bitstream or binary file that is delivered to customer.","At step , if the customer does not desire to have a digital integrated circuit delivered to them, then at step , the NETLIST is delivered to the customer, otherwise, at step , the NETLIST is run through a place and route program, which physically constructs the gates defined in the NETLIST on a silicon die and interconnects them. The choice of a place and route tool depends on whether the packet parser\/classifier is to be implemented as an ASIC (fixed logic) or an FPGA (programmable logic). Sample place and route programs include Quartus II from Altera and ISE from Xilinx. At step , the integrated circuit is delivered to the customer.","With reference to , a block diagram of a graphical design environment using packet processing blocks according to the present invention for designing a packet processing product, indicated generally at , is depicted. The blocks  can be implemented in a text-based or graphical design environment. The environment  includes combinations of any number of Packet Parsing Units (PPUs) , PPUXs  (which are PPUs that can access CAM\/RAM memory ), Packet Modification Units (PMUs) , and Decision and Forwarding Units (DFUs) . The PPUs , PPUXs , PMUs , and DFUs  can be connected by a designer in a variety of ways to create parsing\/classification logic for any desired packet processing algorithm. The PPUs  operate on packet headers . The packet itself can be passed through the environment  intact. Alternatively, only the packet header  is passed through the environment, which requires the creation and passing of a pointer to the packet data to be output after the DFUs . The packets are stored in memory upon arrival and retrieved from memory upon departure. A copy of the header  and a pointer to the packet location is passed to the development environment . The length of the copied header  is variable. It starts at a programmable position in the header  and ends at the last field that must be processed. A PPU takes a header  and can seek, i.e., locate, any field of constant or variable length. Once the field is found in the header , the PPU  can perform a check on that field, such as whether the field is equal to or greater than a given value, or matches a particular value, and then output that value depending on the operation performed.","PPUXs  are PPUs that can perform lookups or searches using external random-access memories (RAMs) or CAMs (a CAM is defined as a RAM-like memory which can determine whether an input value is present in the memory device). A PMU  is a PPU which allows fields in the header of a packet or the packet itself to be modified by means of insertions, deletions, or substitution of bytes. In contrast, the PPUs  and PPUXs  only allow the fields of a packet header to be examined. Any number of PPUs , PPUXs , and PMUs  can be chained together in series or in parallel to implement complex expressions. The DFUs  combine the output of one or more PPUs  and\/or PPUXs  and\/or PMUs  using a programmable condition, and then forward the header to one of a plurality of outputs. The outputs can represent Boolean True and False values, and decisions as to whether to drop, forward, or queue the packet. The DFUs  make decisions to forward, drop, or enqueue packets based on the results from the PPUs . For example, the output of the last DFU in the chain, such as the DFU labeled \u201cA\u201d, can be a queue ID, i.e. of the queue implemented in an external traffic manager .","The traffic manager  is a device which performs a set of actions and operations for a network to guarantee the operability of the network. Traffic Management (TM) is exercised in the form of traffic control and flow control. In the context of the present invention, the traffic manager  operates on a packet stream once the classification & processing is done on a packet (i.e. once it passes from PPU\/DFU blocks). For example, PPU\/DFU blocks are used to figure out the priority number of a packet. The traffic manager is given that priority number and the packet to do a traffic control operation to guarantee that high priority packets pass before low priority packets.","With reference to , a block diagram of the PPU  is depicted. The PPU  performs basic parsing of the packet header  and may perform mathematical\/logical operations on the parsed fields of packet header . The PPU  includes a plurality of inputs and outputs -. The function of each input and output -, as well as the values that each input or output handle, are described with reference to Table 1 hereinbelow.",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},"Ref. #","Type",{}]},{"entry":[{},"In","(In = Input;"]},{"entry":["Signal","FIG. 4","Out = Output)","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Clk","32","In","Clock input"]},{"entry":["Rst","34","In","Asynchronous reset (Active high)"]},{"entry":["DataIn","36","In","Packet header data input"]},{"entry":["SOHIn","38","In","Start of header input (Active High)"]},{"entry":["EOHIn","40","In","End of header input (Active High)"]},{"entry":["InVal","42","In","Data In valid indication (Active High)"]},{"entry":["DataOut","44","Out","Packet header output"]},{"entry":["SOHOut","46","Out","Start of header output (Active High)"]},{"entry":["EOHOut","48","Out","End of header output (Active High)"]},{"entry":["OutVal","50","Out","Data Out valid output (Active High)"]},{"entry":["Qual\/Enb","52","In","Qualifier\/Enable input that is checked using the"]},{"entry":[{},{},{},"Qualifier Condition 54 below to enable the PPU"]},{"entry":[{},{},{},"22 on a packet by packet basis. The Qual\/Enb"]},{"entry":[{},{},{},"52 can be the Result 70 from a previous PPU."]},{"entry":["QualCond","54","In","Qualifier Condition: The PPU operation is"]},{"entry":[{},{},{},"enabled if the result of the check of the"]},{"entry":[{},{},{},"Qual\/Enb input 52 using the Qualifier condition"]},{"entry":[{},{},{},"54 is true. The Qualifier Condition 54 can be:"]},{"entry":[{},{},{},"Always True, Equal, Less Than, Less Than or"]},{"entry":[{},{},{},"Equal, Greater Than, Greater Than or Equal,"]},{"entry":[{},{},{},"etc.)"]},{"entry":["Index","56","In","Index that points to a byte position in the header"]},{"entry":[{},{},{},"relative to the start of packet. The first byte in"]},{"entry":[{},{},{},"the header has an Index of 0."]},{"entry":["Width","58","In","Width of the field to be operated on"]},{"entry":["Mask","60","In","The Mask value is ANDed with the data to be"]},{"entry":[{},{},{},"operated on. This allows checking of only"]},{"entry":[{},{},{},"certain bits in a data field"]},{"entry":["Opcode","62","In","The Opcode specified the operation to be"]},{"entry":[{},{},{},"performed. The opcodes are:"]},{"entry":[{},{},{},"EQ: Equal to Param1 64"]},{"entry":[{},{},{},"LT: Less Than Param1 64"]},{"entry":[{},{},{},"LE: Less Than or Equal to Param1 64"]},{"entry":[{},{},{},"GT: Greater Than Param1 64"]},{"entry":[{},{},{},"GE: Greater Than or Equal to Param1 64"]},{"entry":[{},{},{},"RNG: Check if within range <Param1 64,"]},{"entry":[{},{},{},"Param2 66>"]},{"entry":[{},{},{},"LUP: Look up"]},{"entry":[{},{},{},"SPCL: Special programmable expression"]},{"entry":[{},{},{},"which can use PARAM1 64, PARAM2"]},{"entry":[{},{},{},"66, four special purpose registers"]},{"entry":[{},{},{},"provisioned in PPU 12, Index 56, Width"]},{"entry":[{},{},{},"58, and Qualifier\/Condition 54."]},{"entry":["Param1","64","In","Most opcodes use the parameter Param1"]},{"entry":["Param2","66","In","The RNG opcode uses Param2 to indicate the"]},{"entry":[{},{},{},"end of the range"]},{"entry":["Match","68","Out","Match is asserted (high) if the result of the"]},{"entry":[{},{},{},"operation is true"]},{"entry":["Result","70","Out","The Result output is controlled by a logical or"]},{"entry":[{},{},{},"arithmetic expression on any of the inputs. For"]},{"entry":[{},{},{},"example, to output a Result that drives the"]},{"entry":[{},{},{},"Index input 56 of the next PPU so that it points"]},{"entry":[{},{},{},"to a data field that is 2 bytes ahead:"]},{"entry":[{},{},{},"Result = Index + 2"]},{"entry":["ResVal","72","Out","Indication that Result 70 is valid"]},{"entry":["SeqOut","74","Out","Sequence number used for synchronization"]},{"entry":[{},{},{},"between PPUs and a DFU. This value"]},{"entry":[{},{},{},"increments every packet"]},{"entry":["MapWrRd_n","76","In","Map write enable is used to program internal"]},{"entry":[{},{},{},"registers. Active high is writing, active low for"]},{"entry":[{},{},{},"reading"]},{"entry":["MapAddr","78","In","16 Address locations are provisioned for"]},{"entry":[{},{},{},"following usage"]},{"entry":[{},{},{},"0x0 = PPU ID"]},{"entry":[{},{},{},"0x1 = Qualifier enable condition value"]},{"entry":[{},{},{},"0x2 = Address to program internal Lookup table"]},{"entry":[{},{},{},"0x3 = Data to program internal Lookup table"]},{"entry":[{},{},{},"(Note: The address needs to be written first"]},{"entry":[{},{},{},"followed by data)"]},{"entry":[{},{},{},"0x4-0x7: Used for special purpose registers"]},{"entry":[{},{},{},"which can be used in any equation for the"]},{"entry":[{},{},{},"special Operation code"]},{"entry":[{},{},{},"0x8-0xF: For future use"]},{"entry":["MapWrData","80","In","Write data for the PPU map"]},{"entry":["MapRdData","81","Out","Read back data from the PPU map"]},{"entry":["SeqIn","82","In","An optional externally defined sequence"]},{"entry":[{},{},{},"number. This may be used in place of an"]},{"entry":[{},{},{},"internally generated sequence number for a"]},{"entry":[{},{},{},"PPU."]},{"entry":["TAG","83","In","An optional user defined label to be associated"]},{"entry":[{},{},{},"with the packet header"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"The terms in brackets in  accompanying a specific input or output represents the bit width of the input or output, in standard HDL syntax. For example, if the input DataIn  is to be 32 bits wide, then the variable DW is set to 32 such that DataIn  is expressed in an HDL file as \u201cDataIn[DW-1:0]=DataIn[32-1:0]=DataIn[31:0]\u201d, where \u201c31\u201d represents the last bit and \u201c0\u201d represents the first bit.","The input Clk  is supplied from external hardware, such as the clock of a microprocessor. The Input Rst  is used to cause the PPU to go into a pre-defined state where most internal variables and outputs are set to an initial value. This condition is usually needed at power-up of the hardware in logic systems to stabilize the system before execution of a packet processing algorithm. The system is initially Reset. A predetermined amount of time later, when it is known that all circuits have stabilized, then the circuit is put into operation by toggling Rst .","The PPU  includes a Hardware Lookup Unit (HLU) , a Delay\/FIFO module  containing an optional Delay Line  or a FIFO , a Match and Lookup Unit (MLU) , Result Generation (process) , Sequence Generation (process) , an Output Alignment (process) , interconnected as shown. The sub-blocks - are implemented as modules or processes. A module is similar to a class or subclass in an object-oriented language like C++, while a process is similar to a function. The PPU also contains (not shown) a predetermined but limited number of internal general-purpose registers for storing and retrieving values for comparisons, lookups, etc.","A stream of data is continuously presented to the input DataIn  of the HLU . No data of the input stream is stored in a memory. In such circumstances, it is the job of the HLU  to extract information from a packet and present that information to the other blocks of the PPU . The HLU  takes a snapshot of the data stream according to the location in the data stream specified by the inputs Index  and Width . The inputs SOHIn , EOHIn , and InVal  allow for fine tuning of locating data from the output of other PPUs, PPUXs, PMUs, or external hardware. SOHIn , EOHIn , and InVal  tell the PPU  how to delimit data a packet header. SOHIn  tells the hardware where packet starts and EOHIn  tells the hardware when a packet header ends. Once the packet starts, then at every clock cycle, the data presented at DataIn  is either valid or invalid, as indicated by the input InVal . The extracted header bits are present as an output CompDat  and as an input to the MLU . CompDat  stands for the data that needs to be compared in the MLU .","The Delay\/FIFO module  is used to synchronize the outputs of the PPU  to be presented to a subsequent block, such as a DFU. The Delay\/FIFO module  is needed because the inputs to the PPU, such as DataIn , along with the control input signals SOHIn , EOHIn , and InVal , need to be aligned in time in the Output Alignment process  with intermediate outputs of other sub-blocks of the PPU , such as the Match output  of the MLU , which may be delayed relative to the inputs due to delays in processing within the MLU . The MLU  performs its decision making (e.g., a comparison of a bit within DataIn  with a user specified parameter (Param)) without full packet storage. Therefore, DataIn  along with the control input signals SOHIn , EOHIn , and InVal  are pipelined to the Result Generation process  and the Output Alignment process  by way of intermediate I\/O Val_i , SOH_i , EOH_i , and Data_i . There are fixed delays (measured in clock cycles) associated with processing in the in Result Generation process  and the MLU . There is a variable delay associated with the HLU  depending upon value of Index . The inputs described above must be delayed in the Output Alignment process  by the sum of the aforementioned individual delays. For example, if Index  is , then CompDat  is received at the MLU  eight clock cycles after DataIn  arrives at the PPU . If the MLU  processes CompDat  in three clock cycles, then the PPU  inputs need to be delayed by 8+3 clock cycles in the Output Alignment process . The choice of the optional Delay Line  or the FIFO  depends on the size of the delay needed. A FIFO always works but requires using scarce memory in the PPU . Thus, if only a few clock cycles worth of delay up to about  clock cycles are needed, then the Delay Line  is used, otherwise the FIFO  is used.","The MLU  performs the bulk of the packet parsing and classification operation to be performed on one unit of a packet processing algorithm. The MLU  is programmable, i.e., it can compare the data\/fields extracted in the HLU  with values stored in internal registers by means of the inputs Opcode , Param , Param , and Mask  and declares a match or no match which appears on the internal output Match , which, in turn, appears as an output of the Result Generation process . The inputs QualEnb  and QualCond  enable or disable the MLU  depending on certain conditions. The operation to be performed in the MLU  are enabled if the result of the check of the QualEnb  using the QualCond  is true. QualEnb  is a value stored in a qualEnb register (not shown) which is user programmable through an address map. The Qualifier Condition  can be: Always True, Equal, Less Than, Less Than or Equal, Greater Than, Greater Than or Equal, etc.","For example, if the user desires only to allow IPV6 packets, then QualEnb  can be programmed through the qualEnb register (not shown) to be the value 6. QualCond  is set to Equal To (EQ). The packet type is retrieved from a mode register from an external CPU. If the packet type is 6 (IPV6), then the MLU  is enabled; if the packet type is 4 (IPV4), then the MLU  is disabled, and no comparison takes place. If it is desired to have all types of IP packets, then QualCond  is set to Less Than or Equal (LE) or Always True.","The match\/no-match functionality of the MLU  is performed on the portion of the DataIn  packet header pointed to by Index  and Width . Additional inputs Mask , Opcode input , Param , and optionally Param  are needed to perform the comparison\/match\/no-match operation. The MLU  performs a seek and operation function.","The seek function finds a data field in a packet header (not shown) based on an offset from the start of the packet header indicated by the input Index . If Index  is 0, then the first byte of the packet header is indicated. An Index  of six indicates the seventh byte from the beginning of the packet header. The interconnections that can be made to the Index input  include a fixed value (e.g. 4), a value stored in an internal user defined control register, or the result output  of another PPU, PMU, or DFU. If the Index input  is driven from another PPU, PMU, or DFU, the value placed on the Index input  is variable, depending on the condition(s) evaluated in the previous PPU, PMU, or DFU.","The operation function performs a check, an extraction, or a lookup on \u201cData_Field\u201d, which is the contents of the packet header pointed to by the Index input  of width equal to the value in bits placed on the Width input . The general expression of the operation is\n\nOp(Data_Field AND Mask, Param1, Param2)\n\nThe Data_Field may be filtered (AND'ed) with the Mask input . \u201cOp\u201d is one of the opcodes placed on the Opcode input  given the Param input , and optionally the Param input . The types of operations are shown in Table 2 below:\n",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Mnemonic","Parameters","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["EQ","Param1","Equal: Check if the Data field is equal to"]},{"entry":[{},{},"Param1."]},{"entry":["LT","Param1","Less Than"]},{"entry":["LE","Param1","Less Than or Equal"]},{"entry":["GT","Param1","Greater Than"]},{"entry":["GE","Param1","Greater Than or Equal"]},{"entry":["RNG","Param1,","In Range between Param1 and Param2"]},{"entry":[{},"Param2"]},{"entry":["LUP","\u2014","Look Up"]},{"entry":["SP","\u2014","Search: or special operation for a PPU using"]},{"entry":[{},{},"PARAM1, PARAM2, four Special purpose"]},{"entry":[{},{},"registers provisioned in PPU, Index, Width &"]},{"entry":[{},{},"Qualifier."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"For example, a single MLU can be programmed to check if an IP address less than 224.XX.XX.XX, by specifying the following values:\n\n","As another example, to point to the beginning of an Ethernet frame payload for both untagged and VLAN tagged frames:\n\n","The inputs MapWrRd_n , MapAddr , and MapWrData , and the output MapRdData  are used as the interface between an external microprocessor and the internal registers of the PPU  to allow for reading of and writing to the registers. The PPU , PPUX , PMU , and DFU  can contain a user defined number of internal registers for packet header manipulation either internally or via an external microprocessor. The opcodes LUP and SPCL can be used to directly manipulate data in internal registers.","The output Match  of the MLU  is fed to the input of the Result Generation process  to be described hereinbelow. The Match output  is True if the operation performed in the MLU  is True, or False otherwise. The Result Generation process  takes the Match output , the outputs of the Delay\/FIFO module , and optionally a tag value present on TAG  and produces the result output iResult , which is fed as an input to the Output Alignment process  and ultimately is the output Result  of the PPU . The Result Generation process  also outputs iResVal , which indicates when iResult  is valid. This is needed as a handshaking device, since result generation can take more than a single clock cycle. iMatch  is the value of Match  passed along from the MLU . Assuming the MLU  was enabled, iResult  can take on two values corresponding to the True or False evaluation of the operation performed in the MLU . The True\/False result values can be fixed or an arithmetic or logical function of any of the PPU  inputs. The iResult output  is later passed through the Output Alignment process  to be described hereinbelow as Result , which can be used to drive a DFU input or any input of another PPU or a PMU. Result  can also be a complex expression that the user may want to program. This allows the Index , QualEnb , Opcode , or Param<,> ,  inputs of a PPU to be driven with different values depending on the Result  output of other PPUs.","The PPU  generates or forwards a sequence number using the Sequence Generation process . The sequence number can optionally come from an external process\/hardware via the input SeqIn  and passed along to a DFU; otherwise sequence numbers are internally generated within a PPU  using the Sequence Generation process . The sequence number, which appears as an internal output iSeq , is passed through the Output Alignment process  to a DFU through the PPU output SeqOut . Sequence numbers are incremented sequentially for each use of a PPU and are used for internal synchronization of all the inputs of a DFU. Sequence numbers are needed because different PPUs can present their output packet header data, match data, and results at different times. For example, one PPU may index at bit  of an incoming packet, in which case match output may appear at an input to a DFU after three clock cycles. If another PPU indexes on a VLAN type field, then index is set to block  or , which gives its results to the same DFU after 6+3 clock cycles. The DFU takes the matches packet headers, and sequence number from each of the PPUs and arranges them in correct sequence to be described hereinafter.","The Output Alignment process  aligns all outputs to the start of packet (SOP) or the end of packet (EOP). This is done in order to provide proper delineation of the output signals of one PPU to the next PPU\/PPUX\/PMU\/DFU. For example, if PPU is connected to PPU, and PPU operates either on an 802.3 Ethernet frame or an Ethernet type 2 frame, then PPU examines a byte field which is either 20 bytes or 40 bytes from the beginning of a packet header. Therefore, all outputs of PPU need to be aligned on SOP as a requirement for input to PPU. As another example, some protocols use trailer insertion, e.g., inserting a checksum at the end of a packet. Therefore, outputs are aligned at EOP.","With reference to , a block diagram of a PPUX  is depicted. A PPUX  has the same I\/O signals and sub-blocks as the PPU  except for additional I\/O needed to access an external CAM\/RAM . Elements illustrated in  which correspond to the elements described above in connection with the PPU  of  have been identified by corresponding reference numbers increased by one hundred. Unless otherwise indicated, both the PPU  and the PPUX  have the same construction and operation.","In a PPU, as mentioned earlier, there is a predetermined number of internal registers\/memory which can be programmed by a user. A typical need for programmed memory is for performing a lookup of values by MLU . For example, if there is a need to compare Param  to one hundred IP addresses, then internal memory is used. However, if the number of lookups and hence values to be stored in memory is on the order of thousands of bytes or more, then it may be necessary to store and retrieve these values to\/from an external CAM\/RAM .",{"@attributes":{"id":"p-0057","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},{},"Type",{}]},{"entry":[{},"Ref. #","(In = Input;"]},{"entry":["Signal","in FIG. 5","Out = Output)","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["XRdAddr","222","Out","Memory address output"]},{"entry":["XRdEnb","224","Out","Read signal (Active High)"]},{"entry":["XRdData","226","In","Read data from memory"]},{"entry":["XRdVal","228","In","Read data valid input"]},{"entry":[{},{},{},"(Active High)"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"With reference to , a block diagram of a Packet Modification Units (PMU)  is depicted. A PMU allows for modification, i.e., insertion, deletion, or replacement, of bytes in a packet, including both the header and payload data. The PMU  includes a Delay\/FIFO module  containing an optional Delay Line  or a FIFO , a Modification Unit (MU) , a Result Generation process , a Sequence Generation process , and an Output Alignment process , interconnected as shown. These sub-blocks - are implemented as software modules or processes.","The inputs InVal , SOHIn , EOHIn , DataIn , TagIn , Rst , and Clk  have the same functionality as is found in the PPU  and the PPUX . The delay\/FIFO module  can be used to synchronize the inputs InVal , SOHIn , EOHIn , DataIn , and TagIn  with the outputs of the Result Generation Process  and the outputs of the Modification Unit (MU)  as is done in the PPU , but it also provides a second function: to delay incoming packet data by an amount equal to the number of bytes that may be inserted into a packet in the Modification Unit . This delay is not needed for removing or overwriting data in a packet. As with the PPU , the choice of the optional Delay Line  or the FIFO  depends on the size of the delay needed. If only a few clock cycles worth of delay (a few words to be inserted) are needed, then the Delay Line  is used, otherwise the FIFO  is used. As with the PPU , InVal , SOHIn , EOHIn , and DataIn  are pipelined to the a Modification Unit (MU)  as the intermediate outputs Val_i , SOH_i , EOH_i , and Data_i .","Val_i  is also directed to the Result Generation Process . The Result Generation Process  has a different purpose from the one found in a PPU . The intermediate outputs iResVal (result valid)  and iResult (the result)  are not based on a field value, but reflect the number of bytes inserted. Like a PPU , iResult  becomes the output Result  which can be used as an input to another PPU\/PPUX\/PMU\/DFU. It can also be a complex expression that the user may want to program. The Sequence Generation Process  with the optional SeqIn input  has the same functionality as in the PPU .","The Modification Unit (MU)  inserts\/modifies\/removes data as specified by a user. The MU  is specified at preprocessing time as one of an inserting type, modifying type, or removing type PMU. The type of operations performed by the input signals ByteOffset , ByteValid , and ByteData  are shown in Table 4 below:",{"@attributes":{"id":"p-0062","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},"Ref. #","Type",{}]},{"entry":[{},"in","(In = Input;"]},{"entry":["Signal","FIG. 6","Out = Output)","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ByteOffset","336","In","Byte Offset for insertion\/deletion\/"]},{"entry":[{},{},{},"modification starting at zero bytes"]},{"entry":[{},{},{},"from the beginning of the packet"]},{"entry":["ByteValid","338","In","Valid (Active High) for the number"]},{"entry":[{},{},{},"of clock cycles needed to insert"]},{"entry":[{},{},{},"N bytes"]},{"entry":["ByteData","340","In","The N bytes of data to be inserted"]},{"entry":[{},{},{},"or overwritten (not used for"]},{"entry":[{},{},{},"deletion)"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"The inputs MapWrRd_n , MapAddr , and MapWrData , and the output MapRdData  provide a future programming interface for an external microprocessor to allow for the reading and writing from\/to internal registers of the PMU  to, for example, dynamically program an MU to either insert, delete, or modify a packet at run time. Val_i , SOH_i , and EOH_i  are passed after a delay intact from their corresponding inputs to the MU  to the Output Alignment process . The modified packet, represented as the intermediate input\/output Data_i  is also presented to the Output Alignment process . The Output Alignment process  has the same purpose and functionality as found in the PPU or PPUX, i.e., aligning all intermediate outputs iSeq , iResVal , iResult , Vali_i , SOH_i , EOH_i  and Data_i  on either the start of packet (SOP) or the end of packet (EOP) to become the aligned outputs SeqOut , OutVal , SOHOut , EOHOut , DataOut , ResVal , Result , and TagOut .","With reference to , a block diagram of a Decision and Forwarding Unit (DFU)  is depicted. The DFU  performs drop, queue, or forward operations based on input from 1 to N PPUs, PPUXs, PMUs, or other DFUs. The DFU  includes a plurality of inputs and outputs -. The function of each input and output -, as well as the values each input or output can take on, are described with reference to Table 5 hereinbelow.",{"@attributes":{"id":"p-0065","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},"Ref. #","Type",{}]},{"entry":[{},"in","(In = Input;"]},{"entry":["Signal","FIG. 7","Out = Output)","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["RIn","400a-400n","In","Result from PPUs 0 to N \u2212 1"]},{"entry":["MIn","402a-402n","In","Match from PPUs 0 to N \u2212 1"]},{"entry":["RInSeq","404a-404n","In","Sequence Number from PPUs 0 to N \u2212 1. The"]},{"entry":[{},{},{},"DFU matches the sequence number among"]},{"entry":[{},{},{},"all its input ports to ensure that it is operating"]},{"entry":[{},{},{},"on results for the same packet"]},{"entry":["RInVal","406a-406n","In","Result valid from PPUs 0 to N \u2212 1 (Active High)"]},{"entry":["ROutAVal","408","Out","Result output port A valid (Active High)"]},{"entry":["ROutBVal","410","Out","Result output port B valid (Active High)"]},{"entry":["ROutDVal","412","Out","Result output port D valid (Active High)"]},{"entry":["ROut","414","Out","Result output. The result is based on the"]},{"entry":[{},{},{},"evaluation of a logical expression of the match"]},{"entry":[{},{},{},"and result inputs"]},{"entry":["SeqOut","416","Out","Sequence number output. This sequence"]},{"entry":[{},{},{},"number is output with the results"]},{"entry":[{},{},{},"corresponding to the input sequence number"]},{"entry":["DValIn","418a-418n","In","Data valid from PPUs 0 to N \u2212 1"]},{"entry":["SOHIn","420a-420n","In","SOH from PPUs 0 to N \u2212 1"]},{"entry":["EOHIn","422a-422n","In","EOH from PPUs 0 to N \u2212 1"]},{"entry":["DataIn","424a-424n","In","Data from PPUs 0 to N \u2212 1"]},{"entry":["DValOut","426","Out","Data valid output"]},{"entry":["SOHOut","428","Out","SOH output"]},{"entry":["EOHOut","430","Out","EOH output"]},{"entry":["DOut","432","Out","data output"]},{"entry":["MapWrRd_n","434","In","Map read\/write enable is used to program"]},{"entry":[{},{},{},"internal registers. Active high is writing, active"]},{"entry":[{},{},{},"low for reading."]},{"entry":["MapAddr","436","In","16 Address locations are provisioned for"]},{"entry":[{},{},{},"following usage"]},{"entry":[{},{},{},"0X0 = DFU ID"]},{"entry":[{},{},{},"0x1-0xF: For future use"]},{"entry":["MapWrData","438","In","Write data for the DFU map"]},{"entry":["MapRdData","440","Out","Read back data from the DFU map"]},{"entry":["Clk","442","In","Clock input"]},{"entry":["Rst","444","In","Asynchronous reset (Active high)"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"Referring again to , the DFU  includes sub-blocks Latch -, Data Selection MUX , Result Generation process , and Output Alignment process . The triangles within  are for blocking together intermediate outputs and do not themselves have inherent functionality. All sub-blocks are processes. Latch -latches the incoming results, data, and other output signals coming from 0 to N-1 PPUs\/PPUXs\/PMUs to be processed at a later time inside the DFU . The Latch -are necessary since each PPU\/PPUX\/PMU may present packet data at different times. Four signals from each Latch -, namely iDValIn -, iSOH -, iEOH -, and iData -, corresponding to the latched inputs DValIn -, SOH -, EOH -, and Data -, respectively, and representing together data signals from each PPU\/PPUX\/PMU, belong to groups, which are fed together to the Data Selection MUX . Likewise, four signals from each Latch -, namely iRInVal -, iMln -, iRIn -, and iRInSeq -corresponding to the latched inputs RInVal -, MIn -, RIn -, and RInSeq -, respectively, and representing together control\/result signals from each PPU\/PPUX\/PMU, belong to groups, which are fed together to the Result Generation process MUX . The Data Selection MUX  selects one of the sets of N-1 data groups and forwards the data group to the output group which includes iDValOut , iSOHOut , iEOHOut , and iDOut  as inputs to the Output Alignment Process . The Result Generation Process  has a similar purpose to that found in the PPU\/PPUX, namely, generating a result iRout  which depends on the evaluation of a programmable logical expression which may depend on the value of the inputs RIn[0\u2212(N-1)] -and\/or Min [0\u2212(N-1)] -. In addition, the evaluation of this complex logical expression can determine an output port to which the packet is to be routed, i.e., the pass along\/queue outputs A and B, or the drop port D, represented as active high enabling intermediate outputs iROutAVal , iROutBVal , and iROutDVal . These outputs are passed along to the Output Alignment Process , which has the same purpose and function as the PPU , PPUX , and PMU . The intermediate outputs - become the DFU outputs DValOut , SOHOut , EOHOut , DOut , SeqOut , ROutAVal , ROutBVal , and ROutDVal , and Rout , respectively.","With the addition of a group of external AND gates and control outputs ROutAVal , ROutBVal , and ROutDVal , the output DOut  is routed to one of three output ports: DOutA , DOutB , or DOutD . Typically, DOutA  and DOutB  can be used for normal output and DOutD  can be used for dropping a packet (not shown). Alternatively, DOutD  can be used as a third routing output port. For the normal ports DOutA  and DOutB , the packet is either forwarded to a destination, or another chain of PPUs\/PPUXs\/PMUs, or sent to a queue of a traffic manager.","As an example of the operation of the Data Selection MUX  and Result Generation process , if the DFU  has two PPU inputs DIn[] and DIn[], and two match inputs Min[] and Min[], then the following conditions exist:\n\n","The design environment of the present invention can be connected to a set of internal PPU\/PPUX\/PMU\/DFU registers and programmed through a microprocessor interface. The operations that the microprocessor would perform are reads and writes to\/from the registers. Table 6 below shows a sample interface for a microprocessor manufactured by Freescale, Inc. (formerly Motorola):",{"@attributes":{"id":"p-0070","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Signal","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["UP_CLK","In","Clock: This is the clock for the \u03bcP interface."]},{"entry":["UP_CS","In","Chip Select: This active low signal enables the"]},{"entry":[{},{},"core to respond to microprocessor cycles."]},{"entry":["UP_RWn","In","Read\/Write: Read (high)\/Write (low) signal"]},{"entry":["UP_READY","Out","Ready: Active low signal asserted by the core"]},{"entry":[{},{},"to indicate the successful transfer of read or"]},{"entry":[{},{},"write data."]},{"entry":["UP_A[15:0]","In","Address Bus: 16-bit address driven by the"]},{"entry":[{},{},"microprocessor to address the core registers."]},{"entry":["UP_D[15:0]","In\/Out","Data Bus: Bi-directional 16-bit data"]},{"entry":["UP_IRQ","Out","Interrupt Request: Active low signal asserted"]},{"entry":[{},{},"by the core to indicate that an event was"]},{"entry":[{},{},"detected."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The possible types of interconnections between DFUs and PPUs are numerous. Depending on the application, the control inputs of the PPUs or DFUs can be driven with fixed values (hardwired), from programmable registers, or from the outputs of other PPUs or DFUs. Table 7 shows the options for control signal connections, with some typical examples of standard packet processing:",{"@attributes":{"id":"p-0072","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["PPU Control",{},{}]},{"entry":["Input","Connected To","Description\/Functionality"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Qualifier","Fixed Value","PPU always enabled"]},{"entry":[{},"Register","Enable\/disable under software control"]},{"entry":[{},"Other","Enable\/disable conditionally depending on result from"]},{"entry":[{},"PPU\/DFU","other PPU\/DFU"]},{"entry":["Index","Fixed Value","Index is fixed. Example: MAC Destination or"]},{"entry":[{},{},"Source Address"]},{"entry":[{},"Register","Index is software programmable"]},{"entry":[{},"Other","Index depends on result from other PPU\/DFU."]},{"entry":[{},"PPU\/DFU","Example: IP Destination Address for untagged or VLAN"]},{"entry":[{},{},"frames"]},{"entry":["Width","Fixed Value","Width is fixed. Example: MAC Destination or"]},{"entry":[{},{},"Source Address"]},{"entry":[{},"Register","Width is software programmable"]},{"entry":[{},"Other","Width depends on result from other PPU\/DFU."]},{"entry":[{},"PPU\/DFU","Example: IPv4 or IPv6 Address"]},{"entry":["Mask","Fixed Value","Mask value fixed or not used"]},{"entry":[{},"Register","Mask value is software programmable"]},{"entry":[{},"Other","Mask value depends on result from other"]},{"entry":[{},"PPU\/DFU","PPU\/DFU"]},{"entry":["Opcode","Fixed Value","Opcode is fixed. Example: Equal"]},{"entry":[{},"Register","Opcode is software programmable"]},{"entry":[{},"Other","Opcode changes depending on result from other"]},{"entry":[{},"PPU\/DFU","PPU\/DFU"]},{"entry":["Param<1,2>","Fixed Value","Parameter(s) value is fixed. Example: Check for fixed"]},{"entry":[{},{},"MAC Address"]},{"entry":[{},"Register","Parameter(s) value is software programmable."]},{"entry":[{},{},"Example: Check for programmable MAC Address."]},{"entry":[{},"Other","Parameter(s) value depends on result from other"]},{"entry":[{},"PPU\/DFU","PPU\/DFU. Example: Check TTL field in IP packet"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Each PPU\/PPUX\/PMU\/DFU is configurable at synthesis time using the parameters shown in Table 8:",{"@attributes":{"id":"p-0074","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Parameter","Range","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Data Width","8, 16,","Data bus width"]},{"entry":[{},"32, 64"]},{"entry":[{},"Bits"]},{"entry":["Qualifier Input","0-64","Qualifier input width See PPU"]},{"entry":["Width","Bits","interface description"]},{"entry":["Result Output","0-64","Result output width"]},{"entry":["Width","Bits"]},{"entry":["Max Header Size","1-1023","Maximum packet header size to be"]},{"entry":[{},"Bytes","processed"]},{"entry":["Max Internal","1-16K","Maximum length of internal lookup"]},{"entry":["Lookup Depth",{},"table (Note that very deep and wide"]},{"entry":[{},{},"can consume a very large amount of"]},{"entry":[{},{},"memory and may not be practical or"]},{"entry":[{},{},"feasible)"]},{"entry":["Max Field Width","1-256","Maximum width field to be operated on"]},{"entry":["Max Internal","1-64","Sets the maximum lookup latency."]},{"entry":["Lookup Latency",{},"The configuration tool uses this"]},{"entry":[{},{},"parameter to determine the amount of"]},{"entry":[{},{},"parallelism in the lookup. If a very"]},{"entry":[{},{},"short latency is required, the search is"]},{"entry":[{},{},"done more in parallel and consumes"]},{"entry":[{},{},"more registers\/flip-flops as opposed to"]},{"entry":[{},{},"memory."]},{"entry":["PPUX Address","1-32","PPUX external memory address width"]},{"entry":"Width"},{"entry":["PPUX Data Width","1-64","PPUX external memory data width"]},{"entry":["Number of DFU","1-16","Each DFU can be fed by up to 16"]},{"entry":["Input Ports",{},"PPUs\/PPUXs"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"With reference to , a block diagram is depicted showing a sample packet processing algorithm design using the present invention. In this example, the packet processing algorithm relates to extracting the precedence field of an IP packet for a VLAN\/Non-VLAN frame from a packet header  belonging to a packet . Pseudo code which implements the two DFUs and the three PMUs of  can be found in Appendix H-L. A top-level file for the example of , expressed in pseudo code, can be found in Appendix M. The precedence field is used as the QID of the queue into which the packet is to be stored in a traffic manager. The packet header  is fed to a DataIn input  of a PPU . The PPU  determines first whether the inputted packet header  belongs to a virtual LAN (VLAN) frame or a non-VLAN frame by pointing to byte  of the header (Index=12) with a field width of 2 bytes. The operation to be performed is:\n\n(Data_Field(byte 12, width 2) AND Mask=0, Param1=08100, Param2=0)\n\nIf packet header  points to a VLAN frame, then the Result output  of the PPU  is set to point to the location or offset in the packet header  of the IP address in a VLAN type frame, otherwise it points to the location in the packet header  of the IP address in a non-VLAN frame. This IP address is fed to the Index input , along with the header  to a second PPU . In the PPU , the most significant byte is checked and must be less than , signifying that the input IP address is valid. The operation to be performed is:\n\n(Data_Field(byte=of address, width=1) AND Mask=0, Param1=224, Param2=0)\n","The packet header  is then passed to the Din[] input  of a DFU . If the DA field of the IP address is >=224.0.0.0, then the packet is to be dropped by placing the header on the DOutD output  of an AND gate  connected to the DFU . Otherwise, the packet  is forwarded to a third PPU  with the Index input  of the PPU  pointing to the \u201ctype of service\u201d field (ToS) in the header  based on whether the packet  belongs to a VLAN or non-VLAN frame. The ToS tells the application how a datagram should be used, e.g. delay, precedence, reliability, minimum cost, throughput etc. Depending on the value of the ToS field, one can change a priority assigned to a packet which is then sent to a traffic manager which processes the packet based on the set priority.","In the PPU , the IP precedence field is extracted from the header  with the following operation:\n\n(Data_Field(byte=field location, width=1) AND Mask=0, Param1=2 (start), Param2=3 (len))\n","The IP precedence field is fed to the Din[] input  of a second DFU . The DFU  places the packet header on the DOutA output  of an AND gate  for queueing, and the precedence field is placed on the DOutB output  of an AND gate . The precedence field functions as the Queue Identifier (QID) for the packet to be queued and both inputs ,  are fed to a traffic manager . The traffic manager  outputs the classified packet on output  and the QID on output .","The present invention is subject to numerous variations and modifications. For example, the packet processing blocks having other types of functionality can be provided, such as:\n\n","As an alternative to a textual programming interface for implementing a given packet parser\/classifier, the programmer\/designer can use a graphical design program such as OrCAD or Microsoft Visio to draw and interconnect sub-blocks with input windows for entering interconnecting expressions and entering program inputs.","The present invention has several advantages over prior art packet processing products. The present invention can be used to produce an inexpensive piece of digital hardware, while the prior art products are limited to programs running on a microprocessor. The present invention is scalable to handle simple to complex classification tasks, and software modules can be connected and configured in a variety of ways.","It will be understood that the embodiment described herein is merely exemplary and that a person skilled in the art may make many variations and modifications without departing from the spirit and scope of the invention. All such variations and modifications are intended to be included within the scope of the present invention as defined in the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a more complete understanding of the present invention, reference is made to the following detailed description of an exemplary embodiment considered in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2C"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2D"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
