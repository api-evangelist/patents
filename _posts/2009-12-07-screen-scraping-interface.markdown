---
title: Screen scraping interface
abstract: An interface can serve as a client-mainframe interface, enabling clients to develop applications without a need to understand mainframe processes and screen flows. Extended Tool Command Language (Tcl) can define services that can include a series of interactions with a mainframe system and service definitions can be added or updated on the interface during operation of the interface without disrupting processing. The service definitions can enable the interface to receive XML requests from a client, parse the XML requests, execute the service scripts to interact with the mainframe systems, generate the result in a XML format and send the XML file back to the client. Fundamental Mainframe Interactions (FMI) commands can interact with the mainframe systems and enable the specification of the XML structure of the request and response. The interface can provide efficient connection pooling management and connection life cycle control to improve the performance of the mainframe system interactions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08291047&OS=08291047&RS=08291047
owner: Verizon Data Services LLC
number: 08291047
owner_city: Temple Terrace
owner_country: US
publication_date: 20091207
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This application is a continuation of U.S. patent application Ser. No. 10\/693,706, filed Oct. 24, 2003, the entire disclosure of which is incorporated herein by reference.","The systems and methods relate to mainframe interfaces, and more particularly to an interface for providing transparent communication with a mainframe system.","In the current business environment, it can be advantageous for a company to have a web presence. However, a gap can exist between e-commerce infrastructures and legacy mainframe systems that can present numerous challenges. Due to this gap, online business transactions cannot flow through, or be executed in the mainframe system in real time. For example, common and convenient e-commerce transactions can include paying bills online. Unfortunately, only a small portion of online payments can flow through mainframe systems, even in today's \u201chigh-tech\u201d era. It can take three to seven days for the payment to be effective as the online transactions can be queued in a database for manual entry into a legacy or mainframe billing system.","Enterprises, such as telecommunication industries, can have many critical mainframe systems that can run operations for ordering, provisioning, repair, dispatch, and billing activities. In many instances, the users interfacing with the mainframe system can be production workers of the enterprises, e.g., call center representatives, help desk support personnel, dispatch technicians, and the like. In such instances, prolonged user-system interaction can harm productivity. To remain competitive, enterprises can require means to integrate their e-commerce infrastructure with legacy or mainframe systems so as to provide customers\/users with a substantial real-time experience and improved usability. In addition, integrating the legacy systems with the e-commerce infrastructure can provide a consolidated tool that can improve productivity and efficiency for production workers and result in cost reductions and increased customer satisfaction.","However, replacing legacy systems to satisfy the needs of the customers and the production workers can be unrealistic. These legacy applications can be very secure, highly reliable and can handle large volumes of data, making them the preferred choice of large enterprises. Enterprises can be reluctant to change their stable applications because they risk significant revenue loss if the replacement applications fail. Interfaces to mainframe systems can be built using stored procedures or other mainframe development tools. While this may not involve change to existing mainframe applications, it can require fully understanding and programming the complicated business logic in mainframe applications in different ways, which can take an extended period of time. However, there remains a need for businesses to integrate web applications with mainframe systems.","Screen scrapers and Web terminal emulators that can enable consolidation of the legacy systems as well as provide a Web interface to these systems can be a suitable solution. Screen scraping, also known as screen-based navigation or screen-based data capture, can read the data stream intended for a mainframe terminal, either via a client based terminal emulator or a server based program, and can turn the data stream into a graphical presentation compatible with what users expect from modern desktop applications. In so doing, screen scraping can avoid making changes to the mainframe application while making it easier to use. Screen scraping can also enable fairly extensive modifications to the sequence of information presented to the user by combining several screens into a single graphical presentation, giving the effect of modifying the application without affecting the business logic.","Recent developments have resulted in major changes in the field of uniting Web and legacy technologies. Web interface to legacy systems can provide users with a substantial real-time experience as well as extend the scope of the mainframe application to a larger user base. Commercially available products can render the terminal-oriented presentation of an application on a Web browser without modifying the application. These tools can be easy to use and implement, but can have several drawbacks. They can be limited in terms of scalability, flexibility, functionality, and security. They can be suitable only for simple transactions and activities and the user interface may not be friendly.","Known screen scraper tools can provide underlying Application Programming Interfaces (APIs) for screen scraping. However, e-commerce programmers can still be required to understand the business logic of the mainframe applications to build the interface to the mainframe system. Therefore, there can be a need to develop middleware that can provide a transparent interface to mainframe systems for clients and that can address the drawbacks of existing screen scrapers and Web terminal emulators. Additionally, there can be a need for middleware that can be used to interface with a variety of mainframe systems and can allow users to add or change the interface to a mainframe system without disrupting processing.","An interface can serve as the middleware, or communication link between a client and a mainframe system. The interface can accept XML requests from the clients, can communicate with mainframe systems, and can return XML results to the clients. By providing a transparent interface, the client programmers can develop the client applications without a need to understand the mainframe processes and screen flows. A service can include a series of interactions with a mainframe system, e.g., a service for paying a bill online can include several mainframe screen interactions. Tool Command Language (Tcl) can be extended to define a service and service definitions can be added or updated to the interface during operation of the interface without disrupting processing. The basic commands for interacting with the mainframe systems can include Fundamental Mainframe Interactions (FMI) commands. FMI commands can enable the specification of the XML structure of the request and response. FMI commands can be invoked from a service directly. At runtime, upon receiving a request from a client, the interface can parse the XML request, can execute the service scripts to interact with the mainframe systems, can generate the result in a XML format, and can send the XML file back to the client. The interface can provide efficient connection pooling management and connection life cycle control to improve the performance of the mainframe interactions.","In one embodiment, a interface for interfacing a client with a mainframe system can include a session manager receiving requests for services from the client, a message processor to parse the requests to obtain parsed requests, a service processor to obtain service definitions based on the parsed requests and a host connector interacting with the mainframe system and executing commands based on the service definitions, the commands corresponding with applications recognized by the mainframe system for providing results to the requests for services from the client. The interface can include a database for storing a plurality of service definitions and a storage manager that can communicate with the service processor and retrieve the service definitions based on the parsed requests from the database.","In one aspect, the interface can include an interface engine to listen for a connection request from the client and instantiate the session manager to receive the requests for services related to the connection request. The interface engine can assign one of a plurality of pre-established connections from a connection pool to the client in response to the connection request. The interface engine can instantiate the session manager from pre-established session managers in a thread pool. The interface can include a cache memory and a service cache to store in the cache memory, the service definitions for the requests for services related to the connection.","In one aspect, the interface can include an administrative tool for creating new service definitions and\/or modifying existing service definitions. The administrative tool can include a socket connection to communicate administrative requests to the interface. The interface can include a command processor that can execute administrative commands based on the requests for services being requests for a single command. The interface can further include an authenticator containing access privilege information for the client that can be used in determining if the client is authorized to have the service processor obtain the service definitions. The interface can also include a logging service to log activities of the interface.","In one embodiment, a method of interfacing a client with a mainframe system can include receiving requests for services from the client, parsing the requests to obtain parsed requests, obtaining service definitions based on the parsed requests, interacting with the mainframe system, executing commands based on the service definitions, the commands corresponding with applications recognized by the mainframe system for providing results to the requests for services from the client, and providing the results to the client. The method can receive a connection request from the client and instantiate a session manager to receive the requests for services.","In one aspect, the method can pre-establish a plurality of session managers and instantiate one of the session managers. The method can retrieve entitlement information related to the client and obtain service definitions when the entitlement information indicates the parsed requests can be processed for the client. The method can return an error message to the client when the entitlement information indicates the parsed requests cannot be processed for the client. In one aspect the method can determine if the requests for services are single commands and execute the single commands at an interface interfacing the client with the mainframe system.","In one aspect, the method can create a plurality of connections with the mainframe system to form a connection pool and connections can be assigned from the connection pool when a service request is received. The method can return the connection to the connection pool when the client chooses to end a session with the mainframe system. When creating the connections, the method can perform commands corresponding to startup sections of the service definitions. The method can perform commands corresponding to execution sections of the service definitions when executing the commands.","In one aspect, the method can perform commands corresponding to a closeup section of the service definition so as to release the plurality of connections when the requests for services include a logout request. In one aspect, the method can include specifying identifiers for mainframe screens and specifying actions to be taken with respect to the mainframe screens to generate the service definitions, the actions including receiving the requests for services and providing the results.","In one aspect, the method can include opening a socket connection to an interface to facilitate interfacing with the mainframe system and managing the interface over the socket connection. Managing can include controlling access of the clients to the interface, generating the service definitions, and\/or modifying the service definitions. Managing can also include logging activities of the interface to obtain logs and debugging the execution of the commands based on the logs.","In one embodiment, computer-readable medium can contain instructions for controlling a computer to perform screen-based navigation for interfacing a client with a mainframe system. The instructions can include controlling a computer to define at least one service in a string based command language, including at least one mainframe screen interaction, to receive eXtensible Markup Language (XML) requests from the client, to parse the requests into string based command language requests, to determine the service corresponding to the string based command language requests and obtain service script corresponding to the service, to establish a connection to the mainframe system, to execute the service script on the mainframe system so as to perform the mainframe screen interaction corresponding with the service, to generate results for the mainframe screen interaction in XML format, and to present the results to the client.","The instructions can control the computer to create a plurality of connections to form a connection pool when defining the service, and to assign one of the connections from the connection pool so as to establish the connection to the mainframe system. The instructions can control the computer to separate the service into a startup section, an execution section, and a closeup section when defining the service. The instructions can control the computer to execute the startup section when creating the plurality of connections, to execute the execution section when executing the service script on the mainframe system, to return the connection to the connection pool when receiving an XML request to end a session, and to execute the closeup section to release the plurality of connections when receiving an XML request to logout from the mainframe system.","Referring to , there is shown an exemplary backend integration interface  that can serve as middleware to provide an interface between a client  and a mainframe system . In one embodiment, interface  can accept XML requests from client , communicate such requests to the mainframe system , and communicate results of such requests to the client  using XML. By providing such a transparent interface, the client , and\/or users of the client  do not need knowledge of the mainframe system  processes and screen flows to develop the client applications that can input and receive data to\/from the mainframe system .","A series of interactions with a mainframe system can be referred to herein as a service. For example, paying a bill online can include several mainframe screen interactions. A service for online bill payment can encapsulate these interactions. As commonly known by those of skill in the art, Tool Command Language (Tcl) can be implemented as a string based command language and can be easily extended to support new commands. Thus, for example, Tcl can be extended to support new commands in the scripts used to define services, referred to as Service Definitions. In one embodiment, commands to interact with the mainframe system  can be referred to herein as Fundamental Mainframe Interactions (FMI) commands. A Tcl extension can be implemented to support FMI commands. Consequently, FMI commands can be used in Tcl scripts directly in the known manner of using commands in Tcl. Definitions for the services can be added or updated on interface  during operation of interface  without disrupting processing. FMI commands can also enable the specification of an XML structure of the request and response. FMI commands can be invoked from a service.","Upon receiving a request from client , interface  can parse the XML request, execute the service scripts to interact with mainframe system  using known Java command language (JACL), generate the result in XML format, and send the XML file to client . (Java is a trademark of Sun Microsystems, Inc.) Interface  can provide connection pooling management and connection life cycle control to improve the performance of mainframe interactions. Client  can input and receive data via interface , which can include a Graphical User Interface (GUI) for communicating with interface , which in turn interfaces with mainframe system . The interface for client  can include web browsers, Visual Basic applications users, cellular and landline phone users, and users of other means for communicating with a processing system.","FMI commands can be classified into three categories. A retrieval category can include commands for retrieving information from a particular position on a screen of mainframe system , and determining whether a specific pattern is available on the mainframe screen. An update category can include commands for entering data into fields on the mainframe screen, and invoking function keys to navigate through different mainframe screens. A control category can include commands for identifying the current cursor position on the mainframe screen, moving the cursor to a specified position, reading input XML, creating XML output hierarchy structure, and making and closing connections. Table 1 can include exemplary FMI commands for the above categories. It can be understood that FMI commands in addition to those of Table 1 can be provided for interactions with mainframe system .",{"@attributes":{"id":"p-0030","num":"0029"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Fundamental Mainframe Interactions (FMI)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"Command",{}]},{"entry":["Category","Command Name","Description","Parameters"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Retrieval","wait_for_msg","Wait for a particular","Pattern: the message to"]},{"entry":[{},{},"message pattern on","search"]},{"entry":[{},{},"the screen. If the","Position: the position on"]},{"entry":[{},{},"pattern is found for","the screen to begin the"]},{"entry":[{},{},"the given time period,","search"]},{"entry":[{},{},"return true, false","Exact: a flag to indicate if"]},{"entry":[{},{},"otherwise.","the position is the exact"]},{"entry":[{},{},{},"position to begin the search"]},{"entry":[{},{},{},"or any position beyond"]},{"entry":[{},{},{},"Time interval: the time"]},{"entry":[{},{},{},"interval to perform a check"]},{"entry":[{},"retrieve_screen","Retrieve content from","Position: the position to"]},{"entry":[{},{},"the screen starting","begin the retrieval"]},{"entry":[{},{},"from a given position","Length: the total length of"]},{"entry":[{},{},"with a given length","the content"]},{"entry":[{},{},"and create an","Tag: the tag name in the"]},{"entry":[{},{},"appropriate XML tag","output XML string. If tag"]},{"entry":[{},{},"in the result XML","name is not specified, the"]},{"entry":[{},{},"string. The retrieved","retrieved content is not"]},{"entry":[{},{},"content is returned by","added to the result XML"]},{"entry":[{},{},"this command.","string"]},{"entry":[{},"Output","Appends content to","Text: the content to be"]},{"entry":[{},{},"the result XML string","output"]},{"entry":[{},{},{},"Tag: the tag name in the"]},{"entry":[{},{},{},"output XML file"]},{"entry":["Update","send_key","Send keystrokes to","Keys: the keys to be sent"]},{"entry":[{},{},"the mainframe"]},{"entry":[{},{},"system. This may"]},{"entry":[{},{},"result in placing text"]},{"entry":[{},{},"at the current position"]},{"entry":[{},{},"on the screen or"]},{"entry":[{},{},"invoking function"]},{"entry":[{},{},"keys."]},{"entry":["Control","get_cursor","Get the current cursor","None"]},{"entry":[{},{},"position on the"]},{"entry":[{},{},"screen."]},{"entry":[{},"set_cursor","Set the cursor to the","Position: position to be set"]},{"entry":[{},{},"given position on the","on the screen"]},{"entry":[{},{},"screen."]},{"entry":[{},"open_output_item","Create a new tag in","Tag: the tag name in the"]},{"entry":[{},{},"the result XML","result XML string"]},{"entry":[{},{},"string. The new tag"]},{"entry":[{},{},"will be a child of the"]},{"entry":[{},{},"current tag."]},{"entry":[{},"close_output_item","Close the closest","Tag: the tag name to be"]},{"entry":[{},{},"open tag.","closed"]},{"entry":[{},"open_input_item","Make the element","Tag: the element name in"]},{"entry":[{},{},"with the given name","the input XML string"]},{"entry":[{},{},"(which is a child of"]},{"entry":[{},{},"the current working"]},{"entry":[{},{},"element) as the"]},{"entry":[{},{},"working element."]},{"entry":[{},"close_input_item","Close the closest","Tag: the element name to"]},{"entry":[{},{},"open element of the","be closed"]},{"entry":[{},{},"input XML string."]},{"entry":[{},"get_parameter","Get a parameter from","Tag: the parameter name"]},{"entry":[{},{},"the current element in"]},{"entry":[{},{},"the input XML"]},{"entry":[{},"get_service_parameter","Get the value of the","Name: the parameter name"]},{"entry":[{},{},"service parameter"]},{"entry":[{},{},"from the database."]},{"entry":[{},"Connect","Connect to a","Server: the mainframe"]},{"entry":[{},{},"mainframe system","system name"]},{"entry":[{},"Close","Close the connection","None"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The position parameter for such commands wait_for_msg, retrieve_screen, and set_cursor, as described in Table 1 can be an absolute position or can be represented using X and Y coordinates. Generally, mainframe system screens can include 80 columns and 24 rows. The absolute position for a co-ordinate denoted by (x, y) can be calculated using the formula 80*(x\u22121)+(y\u22121). For example, a position at column 6, line 10 (6, 10) can have an absolute portion of 80 (6-1)+(10-1)=409.","A scenario can be described that can exemplify the writing of a service definition to capture the screen flow and business logic for a service. The scenario can include a service to retrieve time reporting information of a company employee from mainframe system . While interface  and its implementation can be described herein by use of this scenario, it can be understood that interface  and its implementation can support various scenarios for interfacing with mainframe system .","In one embodiment, an employee can use terminal emulation to connect to the time reporting system from a PC to view the time reported for a specified week, e.g., by providing the beginning date of the week.  provides a flow diagram for a service definition  to accomplish this task, including FMI commands from Table 1. In general, once logged in, the employee can be prompted to input the application name, as there can be a number of applications hosted by the server. The employee can enter the application name and can then be prompted to enter an employee ID and password. After entering the ID and password, the system can display a menu of options, e.g., add, edit and view, prompting the employee to select an option. The employee can select the option by entering the option number from the main menu. For the exemplary scenario, a view option can be selected and the beginning date of the week can be provided. The system can then display the time reported for the selected week.","Referring more particularly to , service definition  can begin when the employee logs in or connects to the server at .  can also indicate the FMI commands (in italics) that can be used to support the process flow for service definition , e.g., the connect IP Address command can be used to connect to the server at . Service definition  can then wait () for the mainframe system  to be ready to enter () the application name. The wait_for_msg command can continue to check, e.g., at 200 ms intervals, if, for the example of , \u201cApplication Name\u201d is found, starting from position . The \u201c@E\u201d can signify the ENTER key to designate the end of the string. The command can return true when the designated string is found. This can ensure that the screen can be completely loaded before the next step can be executed. For the example of , the expected string variable can be \u201cApplication Name\u201d and the value obtained can be \u201ctimereporting\u201d. The command can be configured to \u201ctime out\u201d after a specified period, e.g., 10 seconds. Service definition  can send () the application name to mainframe system .","Upon obtaining the application name, service definition  can navigate () to a second screen. Service definition  can then wait () for the next screen to be fully loaded before entering () identification information. The associated FMI commands can operate similar to those for  and , with the employee inputting a name, and password, e.g., testuserid and testpassword. The \u201c@T\u201d can signify the TAB key for inputting multiple lines. Service definition  can navigate to a third screen if authentication is successful ().","The third screen can be the main menu screen, and service definition  can wait () for the screen to be loaded and enter () a menu option, e.g., the employee can choose option 3 to view time reports for the designated week beginning with the date Jan. 1, 2002. The option choice can be sent to mainframe system  for execution at  and service definition  can wait () for mainframe system  to be loaded and to retrieve () the requested time reports. The retrieved results can be enclosed in a tag called, e.g., \u201ctimereported\u201d. Service definition  can terminate () the connection with the mainframe system  when the employee inputs a BREAK, e.g., \u201c@C\u201d.","The service definition  of  can illustrate how the FMI commands can work together to interact with a mainframe system . It can be understood that, since Tcl is a script language, it can readily support branch, loop, and other browser flow controls in a service definition. For example, branching can be used to trap an error when the user enters invalid login parameters. In another example of a flow control, a loop can be used to separately retrieve time reported for each project in a listing of projects.","As noted, the exemplary service definition  of  can illustrate communication with mainframe system  so as to complete a service. To use interface  for Web communication, the client or user  can submit an extended mark-up language XML request. As known in the art, XML can have a hierarchical structure. The elements of the XML structure can be defined in the service definition. The root element of the request XML can be called \u201crequest.\u201d Attributes of the root can include the request name, user ID and password. The parameters element can be structured under the root and the parameters in the request can be referred to as the children of the parameter element.","The FMI commands can be used to read input XML. From Table 1, open_input_item, and close_input_item can be used to control the hierarchy of the XML string. By calling open_input_item with a tag name parameter element, the subsequent parameters can be the children of the tag name until the corresponding close_input_item for the tag name is executed. The get_parameter command can be used to get the value of a parameter from an element with the given tag name under the current element of the input XML. For example, in the sample scenario using known XML commands and conventions, the XML request may look like:",{"@attributes":{"id":"p-0040","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<request name=\u201dget_time_report\u201d userid=\u201dtest\u201d password=\u201dtest\u201d>"]},{"entry":[{},"\u2003<parameters>"]},{"entry":[{},"\u2003\u2002\u2009<login_info>"]},{"entry":[{},"\u2003\u2003\u2003<SSN>999-99-9999<\/SSN>"]},{"entry":[{},"\u2003\u2003\u2003<PWD>test_pwd<\/PWD>"]},{"entry":[{},"\u2003\u2003<\/login_info>"]},{"entry":[{},"\u2003\u2003<beginning_date>01012002<\/beginning_date>"]},{"entry":[{},"\u2003<\/parameters>"]},{"entry":[{},"<\/request>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The previously described example of  hardcoded the values of ssn and pwd. The above XML commands can be used to retrieve ssn and pwd from the request XML. While the flow for service definition  can remain the same for Web communication, the associated FMI commands can be modified. For example, the send_key \u201ctestuserid\u201d and send_key \u201ctestpassword\u201d commands at  and the send_key \u201c01012002\u201d command at  of  can be replaced as follows:",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"send_key \u201ctestuserid\u201d","\u2192","open_input_item \u201clogin_info\u201d"]},{"entry":[{},{},{},"send_key get_parameter \u201cssn\u201d"]},{"entry":[{},"send_key \u201ctestpassword\u201d","\u2192","send_key get_parameter \u201cpwd\u201d"]},{"entry":[{},{},{},"close_input_item \u201clogin_info\u201d"]},{"entry":["and","send_key \u201c01012002\u201d","\u2192","send_key get_parameter"]},{"entry":[{},{},{},"\u201cbeginning_date\u201d."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The XML requests can have corresponding XML responses in return. A set of FMI commands can be defined to manipulate the output or response XML in a similar way as the input XML. FMI commands listed in Table 1 can be used for this purpose, including open_output_item, close_output_item, output, and retrieve_screen. Open_output_item and close_output_item can be counterparts of open_input_item and close_input_item discussed above. The output command can be used to write some contents into the response XML string. The retrieve_screen command can be used to retrieve information from the screen and add it to the response XML string. For example, in the sample scenario, the service request can generate the following response XML string:",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<result>"]},{"entry":[{},"\u2003<timereported>"]},{"entry":[{},"\u2003\u2003<project_name>Interface<\/project_name>"]},{"entry":[{},"\u2003\u2003<total_hour>40<\/total_hour>"]},{"entry":[{},"\u2003<\/timereported>"]},{"entry":[{},"<\/result>,"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"To generate this output, the following FMI commands can replace the retrieve_screen command at .",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"open_output_item \u201ctimereported\u201d"]},{"entry":[{},"retrieve_screen 320 60 \u201cproject_name\u201d"]},{"entry":[{},"retrieve_screen 380 20 \u201ctotal_hour\u201d"]},{"entry":[{},"close_output_item \u201ctimereported\u201d"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The above example can illustrate how to retrieve values from input XML. In some scenarios, the user ID and password can be fixed for all XML requests and thus need not be provided by each individual input XML. Such information can be saved with the service definition as service parameters. When a service is defined, service parameters can be defined and stored in a database in an encrypted form, e.g., database  of interface  in . The FMI command get_service_parameter can be used to retrieve the value of a service parameter. In the exemplary scenario of , the user ID and password can be stored as service parameters, and the following two commands can retrieve the information from database  at  and send the information to the mainframe system  at .",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"send_key get_service_parameter \u201cuserid\u201d"]},{"entry":[{},"send_key get_service_parameter \u201cpassword\u201d"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As shown in , interface  can include a communication module , an administrative module  and a tool module . The communication module  can provide connections to the client  and mainframe system  and can include interface engine , session manager , service processor , command processor , and host connector . The administrative module  can manage interface  and can include authenticator , admin tool , storage manager  and database . The tool module  can provide specialized tools to improve performance of interface , including logging service , message processor , connection pool , thread pool  and service cache .","Interface engine  can be configured as a lightweight connection listener. Upon receiving a connection request from client , interface engine  can create session manager  to handle subsequent requests associated with that connection. Once connected and authenticated, session manager  can act as a request listener and can expect requests from client . The requests can be administrative commands or service requests. An administrative command request can be used to manage interface , such as adding a user and\/or updating a service definition. A service request can be used to execute a service and can contain the parameters to be used in executing the service. When a request message is received, session manager  can call the message processor  to parse the request. Message processor  can parse and validate incoming XML requests and can create an object used by session manager  to serve the request. Session manager  can then call service processor  or command processor  to execute service requests and administrative command requests, respectively.","Service processor  can process service requests, which can contain unique service IDs. Based on the service ID contained in a service request, the corresponding Tcl scripts associated with the service ID can be obtained from the service definitions in database , via storage manager , and can be executed by service processor . The host connector  can interact with the mainframe system  to execute the FMI commands in the Tcl script. The FMI commands can have corresponding APIs defined in host connector . Authenticator  can be used for authentication and entitlement of client . Authenticator  can check if client  is authorized to access interface . For service requests, Authenticator  can determine if client  is entitled to perform such a request based on the entitlement profile for client  that can be included in database . Only authorized clients can send administration command requests.","In the tools module , logging service  can log the major activities, warnings, and errors that occur on interface . Depending on the client system being used, fatal and error messages can also be sent to the client system's event logger. Logging service  can include tools to view and analyze the logs. Thread pool  can pre-create threads for processing service and command requests, so that the overhead of creating threads at runtime can be reduced. Rather than creating host connections at runtime, connection pool  can create some host connections when interface  is started. Service cache  can store the accessed service definitions in an in-memory cache to avoid frequent runtime database access.","The admin or administration tool  can maintain user access control and entitlement, create and modify service definitions, and conduct other administrative work. Once a service is defined using admin tool , storage manager  can divide the service definition into several Tcl scripts as discussed below. Storage manager  can also store and manage the data required by interface . In one embodiment, storage manager  can be designed to operate without a database management system (DBMS). Files can be used to store data as well. This embodiment can be beneficial when interface  has limited services and users. The data can be saved as files in the file system to minimize costs and overhead associated with DBMS operations.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 3","FIG. 1","FIG. 1"],"b":["200","14","202","14","10","52","14","26","204","206","28","208","14","14","28","28","14","28","54","56"]},"Session manager  first contacts () authenticator  to retrieve () the access privileges and\/or entitlement information for client . Session manager  can call () message processor  to parse () the incoming request. Communications between communication module  and administrative module  and tool module  can be illustrated by data flow arrows  and  in , respectively. The entitlement information can be used to determine whether a request can be served (). For example, the entitlement information for an employee can indicate that the employee can retrieve only time reports related to the employee's work. Based on this exemplary entitlement information, a request by the employee to retrieve another employee's time reports may not be served or processed.","An error message can be returned to client  when the entitlement information indicates the request cannot be served, as at , and procedure  can return to  to await further requests, as indicated at \u201cA\u201d. If the request is to be served and the request is a service, as determined at , session manager  can call service processor  () to handle the service, as shown by data flow arrow  in .","Service processor  can interact () with host connector , as indicated by data flow arrow  in . Host connector  in turn can interface () with mainframe system  to execute () the requested commands. Data flow arrow  of  can illustrate the connection between host connector  and mainframe system . If the request is a request for a single command, session manager  can call () command processor  to execute () the administrative commands, as illustrated by data flow arrow  of . Once execution of the service request at  or the command  is completed, including returning results to client , procedure  can return to await more requests, as indicated by \u201cA\u201d in . When the request is a logout request, as determined at , procedure  can end. Logging service  can be invoked during any stage of the process to log the key activities of interface .","It can be understood that in accepting a connection at  of , interface  can create a connection to mainframe system  for host connector  to interface with mainframe system . Such connections can be expensive to create. Interface  can provide a connection pool  to improve performance. When registering a service with interface , the number of connections in the pool  to be created can be specified. When interface  begins, the connections can be created and kept in connection pool . When a client  requests a connection, one of the pre-created connections can be assigned to client  (an instance of session manager , as at  of ). If client  relinquishes control of the connection, e.g., at logout  of , the server can return the connection to the pool of available connections. During the lifetime of the connection while session manager  can be listening for requests, as at  of , the client can invoke any number of services using the reference to the connection. For example, an employee can request a benefits report after completing a time report request. Session manager  can obtain the reference to the connection from connection pool  when instantiated and can use this reference throughout its life span.","A screen navigation life cycle on mainframe system  can have at least three phases during screen scraping, including initialization, execution, and termination. For example, in the exemplary scenario of , the initialization phase can include login () through waiting for input at . The execution phase can include obtaining the input from the screen () through retrieving the time reported at . The termination phase can be illustrated at . It can be seen that the service definition  can be repeated from login  to termination  for each employee requesting time reports. It can also be observed that some navigation can remain the same for every request.","By pre-navigating these screens for each connection in connection pool , overall response time for obtaining reports can be improved. Thus, interface  can divide a service definition into several sections, including a STARTUP section corresponding with the initialization phase described above, an EXECUTION system corresponding with the execution phase and a CLOSEUP section corresponding with the previously described termination phase.  illustrates a flow chart  for the screen navigation life cycle described above. The method  can start when a user at client , e.g., a system administrator or programmer, can register () a service with interface  and can specify, as part of the registration, the number of connections in the pool  to be created, as previously described. When interface  begins (), the connections can be created and kept in connection pool , as at . The number of connections in the connection pool can be changed dynamically by changing the connection pool number associated with a service, e.g., through administrative tool , or web-based administrative tool .","In creating the connections at , the STARTUP section can execute to pre-navigate the screens, using the login information provided by the client\/administrator\/programmer registering the service definition. In terms of a service definition, those commands before the first variable in the service definition can be put in the STARTUP section. This can ensure that the STARTUP section can be independent of the service requests, which can provide values for variables. When a connection request is received at runtime, as determined at , the method  can determine at  if a connection is available from connection pool . If a connection is available, the service definition can directly execute the EXECUTION section () as the STARTUP section can have been executed when the connection was created at . If a connection is not available, a new connection can be created () and the STARTUP section can be processed ().","The EXECUTION section can be executed regardless of whether the connection is obtained from connection pool . The EXECUTION section can begin at the end of the STARTUP section, and can begin with the first request or command containing a variable. For example, in , the variables \u201ctestuserid\u201d and \u201ctestpassword\u201d can be entered at  and the EXECUTION section for service definition  would begin at . The separation of STARTUP from EXECUTION can significantly improve performance when connections are available in connection pool .","The CLOSEUP section can release the connection resources. It can specify the process to quit from mainframe system  and release the connection resources. At runtime, after completing the servicing of a request, as by executing the EXECUTION section, interface  can determine at  whether to release the connection resources in the CLOSEUP section (). The determination can be based on whether the logout associated with the service definition is input, e.g., the termination sequence \u201csend_key \u2018@c\u2019\u2014close\u201d at  of . Release of the connection resources, as by execution of the CLOSEUP section at , can end screen navigation life cycle .","When a client completes execution at  and the resources are not released, the client can choose at  to execute additional requests, or end the session. If the client chooses to end the session, the connection can be returned to the connection pool  (). It can be understood that the service definition can include a RESET section that can bring the connection to the last page that STARTUP navigates to. The RESET section can be added to the service definition when registering the definition. In returning a connection to connection pool , the RESET section can be executed () and the screen navigation life cycle  can await further connection requests.","As previously described, when a connection to interface  is established, interface engine  can create a new thread, or session manager  to process requests for that connection. The session manager  can wait for incoming requests and when received, can parse the request by invoking message processor . After parsing, the incoming parameters can be stored in a hash table. The key and content for the hash table can be the variable name and value respectively. Session manager  can invoke command processor  and service processor  to process administrative commands and service requests, respectively, using the hash table as a parameter.","One purpose of service processor  can include managing the life cycle of a service. Interface  can include scripts corresponding to each section of a service definition, as described previously. Service processor  can obtain a connection for the service either from connection pool  or by creating a new connection. Each connection can include an instance of host connector . For a connection from connection pool , the EXECUTION section can be executed. For a newly created connection, the STARTUP section can be first executed using the host connector  instance and the parameter hash table, then the EXECUTION section can be executed. After EXECUTION, service processor  can create a new thread to return the final result to the requestor. Meanwhile, the main thread can invoke the RESET or CLOSEUP section depending on how the connection is to be released.","Host connector  can interface with mainframe system  through FMI commands. Implementation of the FMI commands can utilize a screen scraping software development kit (SDK). In one embodiment, the SDK can implement a high level language API for screen scraping. A connection can be allocated to serve each connection request and can include a reference to host connector , which can use the underlying screen scraping tool to maintain the state of screen navigation. When a Tcl script is executed by JACL, the reference to host connector  can be passed to JACL as a parameter, and FMI commands in the script can use the same connection to interface with mainframe system .","Host connector  can remember responses or error messages for the connection. In the life cycle of a connection, there can be multiple steps that retrieve information from mainframe system . The retrieved information can be stored in a buffer associated with the connection and error messages can be stored in a separate buffer. The contents of the buffers can be retrieved and returned to the clients.","In one embodiment, an administrator  can utilize a Web-based administrative tool  to manage interface . Using tool , administrator  can manage services and the mainframe servers with which interface  can communicate, including controlling access to clients, viewing logs, and configuring properties. As shown in , tool  can be bundled separately from interface  and can talk to interface  using XML requests\/responses over a socket connection.","Administrative tool  can also include a Service Definition Development (SDD) toolkit  that developers can utilize to generate a skeleton of a service definition by specifying the identifiers of each screen and the actions to be taken in that screen. Developers can then modify the generated script to add other logic for further screen scraping manipulation. Developers can also trace and debug the execution of a service definition using the SDD toolkit  and the logs created by logging service .","As described herein, interface  can provide a generic framework to interface with mainframe systems and to automate interactions therewith using a client-interface-mainframe three-tier architecture. The interface  can provide major benefits over existing solutions in the industry including separation of the navigation flow from the front-end e-commerce applications. The client programs need only submit an XML service request to interface , without being concerned with how interface  and the mainframe system  work. Interface  also supports adding and\/or updating services during operation of interface  to satisfy changing demands. As an example, changes to the screen flow of the time reporting system described previously can be accomplished by updating the service definition using the Admin Tool  without interrupting the functioning of interface . Interface  can also provide a quick mainframe interface development tool, with limited development effort needed to add or update an interface. Using connection pooling and connection life cycle control, interface  can provide good response time to client requests. These techniques and multi-threading implementation can help interface  to provide high scalability as well. Additionally, a Web-based administration tool can provide for ease in managing the interface  framework.","The systems and implementations thereof described herein may not be limited to particular components or configurations. For example, interface  can include multiple databases for separate storage of service definitions, access privileges, service parameters and other interface  information and\/or data. The command processor and service processor can be combined into a single processing unit that can include processing for other components of interface . Interface  can include processors, volatile memory and non-volatile memory for storing request data, client data and other data corresponding to input and output values and other intermediate computations for the methods  and . The memory can include instructions for implementing interface , including implementation of procedure  and execution of service definitions such as service definition . Such instructions can be transferred, in the course of operation, from the non-volatile memory to the volatile memory and to the processor for execution.","Additionally, the flow chart in  can illustrate an exemplary service definition  for interface  and the flow chart of  can illustrate an exemplary implementation of interface . Other configurations can be contemplated and\/or other actions, decisions, menus and the like can be included. For example, the branching and looping described with relation to  can provide additional functionality for service definitions.","In one embodiment, the core components of interface  can be developed using Java. The Java programming language developed by Sun Microsystems, Inc. has gained wide acceptance for writing software for the Internet and World Wide Web. While compilers for most programming languages generate code for a particular operating environment, Java enables writing programs using a \u201cwrite once, run anywhere\u201d paradigm. (\u201cWrite Once, Run Anywhere\u201d is a trademark of Sun Microsystems, Inc.) The terminology used herein to describe aspects of interface  can include terminology associated with Java and JACL. In addition, the interface  can be implemented in .NET, a set of connection software technologies by Microsoft Corporation.","The systems and methods described herein may not be limited to a particular hardware or software configuration; they may find applicability in many computing or processing environments. They can be implemented in hardware or software, or a combination thereof. Preferably, the interface , service definitions such as service definition  and procedure  can be implemented in computer programs running in one or more processors. Implementation languages for the computer programs can include high level procedural languages, object oriented programming languages, assembly and\/or machine language for communication with a computer system.","The computer programs can be stored on a storage media and\/or one or more devices (e.g., CD-ROM, hard disk, or magnetic disk) that are readable by a general or special purpose programmable computer for configuring and operating the computer when the storage medium or device is read by the computer to perform the procedures described herein. The system and methods can also be considered to be implemented as a computer-readable storage medium, configured with a computer program, where the storage medium so configured can cause a computer to operate in a specific and predefined manner.","While the methods and systems have been disclosed in connection with the preferred embodiments shown and described in detail, various modifications and improvements thereon will become readily apparent to those skilled in the art. Those with ordinary skill in the art will recognize that the arrangement and connectivity of the components shown in the figures are merely for illustrative purposes, and can be varied accordingly and components may be combined or otherwise reconfigured without departing from the scope of the disclosed systems and methods.","Accordingly, many additional changes in the details and arrangement of parts, herein described and illustrated, can be made by those skilled in the art. It will thus be understood that the following claims are not to be limited to the embodiments disclosed herein, can include practices otherwise than specifically described, and are to be interpreted as broadly as allowed under the law."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The following figures depict certain illustrative embodiments in which like reference numerals refer to like elements. These depicted embodiments are to be understood as illustrative and not as limiting in any way.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
