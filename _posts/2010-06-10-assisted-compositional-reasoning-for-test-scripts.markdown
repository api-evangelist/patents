---
title: Assisted compositional reasoning for test scripts
abstract: Assisted compositional reasoning for test scripts is implemented by a Type Inference of GUI Object References (TIGOR). TIGOR makes types of GUI objects explicit in the source code by using the properties of GUI objects as referred to in test script statements to access a GUI object repository for GUI objects that have matching GUI objects properties. TIGOR analyzes the GUI object types of the matching GUI objects in view of a sequence of operations performed on the GUI objects in the test script statements. TIGOR infers a GUI object type for a GUI object when that GUI object type is determined to be valid and/or compatible with a sequence of operations, such as API calls, executed in test script statements that perform actions on the GUI object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08572570&OS=08572570&RS=08572570
owner: Accenture Global Services Limited
number: 08572570
owner_city: Dublin
owner_country: IE
publication_date: 20100610
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["1. Technical Field","This disclosure relates to analysis and generation of accurate GUI object type inferences for testing applications that contain these GUI objects. The inferences may be used to create composed test scripts for testing applications composed of multiple applications, including graphical user interface applications, and in particular relates to transforming multiple individual test scripts that are designed to individually test standalone GUI applications into fewer test scripts or a single composed test script for testing a composed application composed of multiple applications.","2. Related Art","The relentless pace of advancing technology has given rise to complex computer software applications to help automate almost every aspect of day-to-day existence. Today applications exist to assist with writing novels to filing income tax returns to analyzing historical trends in baby names. One nearly ubiquitous feature of these applications is that they employ graphical user interfaces (GUIs). Another nearly ubiquitous aspect is that applications that incorporate GUIs (Graphical user interface APplications (GAPs)) require thorough testing prior to release.","Integrated systems are composed of components that exchange information. These components include different legacy event-based applications, such as GAPs. To automate testing, engineers create test scripts that are programs that interact with GAPs by performing actions on the GUI objects of the GAPS. When testing integrated systems and composed applications in particular, it is important to reason about how to compose test scripts whose operations reference these GUI objects.","Successfully combining existing individual test scripts that are designed to test individual applications in order to test composed applications is difficult. The significant complexity of combining test scripts, and the permutations and combinations of GUI elements, including data types, gives rise to an enormous field of potential commands and command sequences that could have bugs of any severity, from insignificant to critical failure. As a result, even if test scripts exist for the applications, it is rarely the case that the test scripts can be easily combined without significant effort to adequately test the composed application. The complexity is further complicated, because unlike conventional languages that require programmers to declare types of variables explicitly, test script statements reference GUI objects using the properties (e.g., location, color, and size) of the GUI objects. The absence of data type information exacerbates the process of composing test scripts, making it expensive and prohibitive to test composed systems. These fundamental problems are inherent for most existing Open Source and commercial automated testing tools.","Several fundamental problems make it difficult to type operations that reference GUI objects in test scripts. First, specifications for GUI objects are often not available, and these objects are created dynamically in the GAPs' processes and the contexts of the underlying GUI frameworks (e.g., Windows or Java SWT). Black-box testing does not provide the option to obtain information about GUI objects from the source code of GAPs. Therefore, test engineers use capture\/replay tools to extract values of properties of GUI objects, so that these objects can be later identified on GUI screens by matching these prerecorded values with the properties of GUI objects that are created at runtime. Because complete specifications of GUI objects are not available, it is difficult to analyze statically how GUI objects are accessed and manipulated by test script statements.","Manually testing large-scale composed applications with composed test scripts is tedious, error prone, and laborious. Nontrivial GAPs contain hundreds of GUI screens that in turn contain thousands of GUI objects. In order to automate testing of GAPs, test engineers write programs using scripting languages (e.g., JavaScript and VBScript), and these testing scripts drive GAPs through different states by mimicking users who interact with these GAPs by performing actions on their GUI objects. Often test scripts simulate users of GAPs, and their statements access and manipulate GUI objects of these GAPs. For example, the statement:","VbWindow(\u201cUserId\u201d).VbEdit(\u201ctxtAgentsName\u201d).Set \u201cShawn\u201d","locates a window whose caption is Userid and that is created by a Visual Basic-based control, then a text box is located whose name is txtAgentsName that is a GUI object whose parent is the Userid window. By calling the method Set with the parameter \u201cShawn\u201d, the value of the text box is set to \u201cShawn\u201d.","Commercial tools such as Quick Test Pro (QTP), Rational Robot, and Compuware Test Partner help generate test scripts by tracking pointing of a cursor at GUI objects and performing desired actions. These tools generate scripting code that can replay captured user actions for an individual application. The generated code serves as a skeleton for creating scripts to automate script testing for individual applications. When test scripts are combined to create a composed test script, test engineers add code manually to the composed test script so that the composed test script performs actions on the GUI objects as previously exercised by the individual test scripts.","Using manually written code to combine individual test scripts in order to test composed applications makes the composed test scripts more complex, time consuming to create, and difficult to accurately implement, maintain, and evolve. Although it is known in advance that the test scripts access and manipulate GUI elements, it is not clear how to detect GUI object data types, without significant manual analysis and reasoning, until compile time which lead to runtime errors.","Using API calls exported by testing platforms remains a primary mode of accessing and manipulating GUI objects of GAPs. Operation statements in the test scripts include API calls that perform actions on GUI objects referenced in the test scripts incorporated in the applications tested by the scripts. When the operation statements fail to properly manage the GUI object data types of the GUI objects referenced in the test scripts, these API calls lead to various run-time errors.","Checking test scripts for potential flaws caused by API calls that lead to incorrect tests and runtime errors in the test scripts is a difficult technical challenge. Furthermore, there are fundamental problems with using API calls to access and manipulate GUI objects. First, the API calls take names and property values of GUI objects as string input parameter variables. The values of these input parameters are often known only at runtime, making it impossible to apply sound checking algorithms. Second, testing platforms export dozens of different API calls, and high complexity of these API calls makes it difficult for programmers to understand which API calls to use and how to combine them to access and manipulate GUI objects. These problems lead to a wide range of bugs in the test scripts, many of which are difficult to detect during the inspection of the test script source code.","Therefore, a need exists to address the problems noted above and other previously encountered.","Assisted compositional reasoning for test scripts is implemented by the Type Inference of GUI Object References (TIGOR) system and method. TIGOR facilitates making types of GUI objects explicit in the source code, allowing test engineers to reason more effectively about the interactions between statements in complex test scripts and GUI objects that these statements reference. In one implementation, TIGOR includes logic that automatically infers GUI object types referenced in the operational statements of the test scripts. TIGOR provides a tool for developing and testing applications composed with multiple applications that include GUI objects. TIGOR is practical and efficient, and yields appropriate GUI objects types that provide error free control of GUI objects referenced in composed test scripts to test composed applications.","Crafting test scripts from scratch for testing new integrated systems is a significant investment. Test engineers implement sophisticated testing logic. Specifically test engineers write code that processes input data, uses this data to set values of GUI objects, acts on the objects to cause GAPs to perform computations, retrieves the results of these computations from GUI objects, and compares these results with predetermined answers to determine if GAPs behave as desired. Since multiple test scripts are already created for testing individual GAPs, it is highly desirable that these scripts be reused for testing the corresponding integrated systems. Reusing testing logic repeatedly is the ultimate goal of test automation.","However, it is difficult to compose test scripts into mega-scripts that test newly integrated systems, because many of these scripts are difficult to reason about, and the test scripts are often out-of-date, and should be fixed before being composed with other scripts. In addition, operations in test scripts should be synchronized, so that composed scripts can facilitate GAPs to exchange data when GUI objects are exposed to these exchanges. Specifically, test engineers should know what types of GUI objects are referenced by expressions in test scripts in order to determine how to move data between test scripts. Scripting languages do not allow programmers to specify types of variables. Unlike conventional languages that require programmers to declare types of variables explicitly, test script statements reference GUI objects using their properties (e.g., name, location, color, and size).","Test scripts are highly sensitive to the types of GUI objects that the test scripts reference, for example, changing the type of a GUI object from a list box to a text box will lead to runtime errors in test scripts. Test script statements that access and manipulate GUI objects as failures if these statements are broken because of mismatches between types of GUI objects that methods are invoked on the references of the GUI objects in test scripts statements. Test engineers put a lot of effort into detecting and understanding failures, so that the test engineers can fix test scripts to work on modified versions of GAPs.","TIGOR assists compositional reasoning about test scripts by inferring the data types of GUI objects on which a test script performs actions. TIGOR, in one implementation, operates in combination with a testing tool, such as that manufactured by Hewlett-Packard Corp. referred to as the Quick Test Pro (QTP\u2122 tool).","Other systems, methods, features and advantages will be, or will become, apparent to one with skill in the art upon examination of the following figures and detailed description. All such additional systems, methods, features and advantages are included within this description, are within the scope of the claimed subject matter, and are protected by the following claims.","The Type Inference of GUI Object References (TIGOR) assists compositional reasoning about test scripts by inferring the data types of GUI objects on which a composed test script performs actions.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 1","b":["100","100","102","104","106","104","106","108","110","108","112","114","110","108","110","116","106","104","104","118","110","120","118","122","118","124","116","114","118","116","126","112","126","112","122"]},"The TIGOR system architecture  includes a GUI object repository or GUI object repositories  that stores validated action results  for actions performed by the API calls  on GUI object types . For example, the statement:","VbWindow(\u201cUserId\u201d).VbEdit(\u201ctxtAgentsName\u201d).Set \u201cShawn\u201d","locates (action result ) a window whose caption is Userid and that is created by a Visual Basic-based control, then a text box (GUI object type ) is located whose name is txtAgentsName and is a GUI object  whose parent is the Userid window. By calling the method \u2018Set\u2019 with the parameter \u201cShawn\u201d, the value of the text box is set to \u201cShawn\u201d (action result , in this example, sets a value).","The type inferencer logic  determines the GUI object types  by obtaining, from the GUI object repositories , mappings of GUI object types , where each of the mappings  may comprise properties of a GUI object type . Example properties include location, color, and size of the GUI objects. The type inferencer logic  may assign GUI object types  to each GUI object  according to the API call types  in sequence determined to be compatible with the GUI object types in sequence .","In one implementation, the TIGOR system architecture  includes one or more external GUI object repositories . The object repositories  may be provided by an external service provider or providers  and may be accessed through the network . The multiple external GUI object repositories  store mappings  for the GUI objects  in applications that do not compose the composed application . These applications may reference the GUI objects  referenced in the test script statements . In one implementation, the larger the inventory of mappings  for GUI objects  available in the GUI object repositories , including external GUI object repositories , the more accurate the inference result . For example, an external service provider  may offer access to any number of GUI object repositories , both GUI object repositories  related and unrelated to the applications  used to compose the composed application , through a network , in order to increase the inventory of mappings  for GUI objects  used by TIGOR  to obtain the type inference results . The GUI object repositories  store the mapping  of names of GUI objects  and the physical properties  of the GUI objects that describe how those GUI objects  are represented.","The type inferencer logic  may find multiple GUI object interaction paths  that identify API calls  that perform actions  on the sequential GUI objects. For example, the GUI object interaction paths  may include the sequence of GUI objects referenced in a sequence of test script statements and composed test script statements (, ). Recall, the statement:","VbWindow(\u201cUserId\u201d).VbEdit(\u201ctxtAgentsName\u201d).Set \u201cShawn\u201d","locates a window whose caption is Userid and that is created by a Visual Basic-based control, then a text box is located whose name is txtAgentsName and is a GUI object whose parent is the Userid window. By calling the method Set with the parameter \u201cShawn\u201d, the value of the text box is set to \u201cShawn\u201d. The sequence of GUI objects  referenced in this example may include in one path a window GUI object and a text box GUI object. The text box GUI object is the destination GUI object in this example and \u2018set\u2019 is the action results  performed on the GUI object .","The GUI object interaction paths  may validate useable GUI object interaction paths  from the multiple GUI object interaction paths  that control the actions  performed on the sequential GUI objects, and determines a GUI object interactions count  in each of the useable GUI object interaction paths . For example, the \u2018set\u2019 action result  is valid for a text box GUI object type and the \u2018set\u2019 operation counts as a GUI object interactions count  in a useable GUI object interaction path .","In one implementation, the type inferencer logic  may select, from the useable GUI object interaction paths , a first path having the least number of GUI object interactions  of the useable GUI object interaction paths . In another implementation, the type inferencer logic  selects from the useable GUI object interaction paths , a first path having the greatest number of GUI object interactions  of the useable GUI object interaction paths . In still another implementation, the type inferencer logic  selects from the useable GUI object interaction paths , a first path having a number of GUI object interactions  between the least and the greatest number of GUI object interactions  of the useable GUI object interaction paths . The type inferencer logic  determines the type of the exposed method  in the useable GUI object interaction paths , where the useable GUI object interaction paths  each extend from a root node (e.g., see  GUI object ) to the destination GUI object  (e.g., see  GUI object ) that exposes the exposed method .","For example, the test script statement  may include VbWindow (\u201cState).Select 3. The API call  VbWindow is exported by a GUI testing framework . Executing the API call  identifies a list box GUI object  whose property \u201cname\u201d (e.g., GUI objects properties ) has the value \u201cState\u201d (e.g., action results ). By calling the method  \u2018Select\u2019 with the value 3, the third item in its value list is selected. However, if the referenced GUI object  is not of the GUI object type \u2018list box\u2019 (e.g., a special form of a \u2018text box\u2019 type), the API call  will result in a runtime exception. The absence of typing information in the source code (e.g., in the test script statement ) exacerbate the process of detecting and understanding failures in test scripts , making maintenance and evolution of these scripts  expensive and prohibitive, thus obliterating benefits of test automation . Test engineers often lack time and necessary skills to understand old scripts, especially if these scripts were created by other engineers. To be able to compose and synchronize test scripts , it is critical for test engineers to understand what types  of GUI objects are referenced in the expressions of these scripts . Existing approaches provide lithe help to address this pervasive and big problem.","TIGOR  makes types of GUI objects  explicit, enabling test engineers to reason more effectively about the interactions  between statements in complex test scripts  and GUI objects  that these statements  reference. TIGOR  provides a way to synchronize test scripts (, ) and create composed test script statements  in order to test composed applications .","For example, a composed application  may include E-procurement systems (EPS) that businesses employ that often include different GAPs assisting different steps of the purchasing process. In EPSes, the rule of separation of duty requires that operations be separated into different steps that must be done by independent persons (agents) in order to maintain integrity. With the separation of duty rule in place, no person can cause a problem that will go unnoticed, since a person who creates or certifies a transaction may not execute the transaction. Implementing this rule results in agents using different GAPs  that provide different services for different steps of the purchasing process.","Employees order items using an electronic shopping cart service of the web-based application buystuff (BS). Department managers review selected items in the shopping cart, approve and order them, and enter the ordered items into expense tracker (ET), a third-party closed and monolithicWindows GAP that the company uses internally to keep track of purchases. The BS service sends a notification to a company accountant, who uses a closed and monolithic GAP called Invoice tracker (IT) to create invoices for ordered goods. When the ordered goods are received from BS, a receiving agent compares them with the entries in ET. The accountant can view but cannot modify records in ET, and likewise, no other agent but the accountant can insert and modify data in IT. If the received goods correspond to the records in ET, the receiving agent marks the entries for the received goods in ET and notifies the accountant. After comparing the invoices in IT with the marked entries in ET and determining that they match, the accountant authorizes payments.","Each procurement agent uses different GAPs  to accomplish different goals. Sometimes, several GAPs  should be used to accomplish a single goal, and agents have to transfer data between these GAPs  and perform other operations manually. Clearly, automating these activities  is important in order to improve the quality and the efficiency of business services.","Consolidating disparate components into integrated EPSes facilitates enterprises to achieve a high degree of automation of their purchasing processes. One supporting function of an integrated system (composed application ) is to extract information about ordered items from the service BS and create and enter invoices into IT using this information. Once the payments are processed, the user marks invoices in IT as paid, and the information about these invoices should be extracted from IT and entered as expenses into ET. There are many other functions of the integrated EPS that involve interoperating GAPs  with each other.","An important function of testing an integrated EPS is to use individual test scripts  that are designed for components GAPs  to perform integrated tasks . These scripts may continue to work with legacy GAPs , and operations synchronized in order to facilitate GAPs  to exchange data. The test scripts  and composed test script statements  may be synchronized in order to facilitate GAPs  to exchange data. In a way, composing test scripts  mimic how users interact with integrated systems . Composing test scripts  this way requires test engineers to reason about types  of GUI objects that these scripts  reference.","In another implementation, TIGOR  includes a test automation model  that illustrates interactions between test scripts  and GAPs . Statements of test scripts  are processed by the scripting language interpreter . In one implementation, the scripting language interpreter (and\/or script parser logic)  is supplied with a testing platform. When the interpreter  encounters statements  that access and manipulate GUI objects , the interpreter  passes the control to the testing platform  that translates these statements  into a series of instructions that are executed by the underlying GUI framework  and the operating system.","The layers between test scripts  and GAPs  may be viewed as a reflective connector. A connector is a channel that transmits and executes operations (e.g., API calls ) between test scripts (, ) and GAPs . Reflection exposes the type  of a given GUI object , and facilitates test scripts (, ) to invoke methods  of objects  whose types  and classes are not statically known before the GAP  is run. A connector between scripts (, ) and GAPs  is combined with reflection so that test scripts (, ) can access and manipulate GUI objects  at run-time.","Each statement  in test scripts (, ), which accesses and manipulates GUI objects  may include the following operations: (1) navigate to some destination GUI object , using GUI object properties , and (2) invoke methods  to perform actions  on the GUI objects , including getting and setting values . Using implementations of the concepts of reflection and connector, statements  in test scripts  can navigate GUI objects  in GAPs  and perform operations  on these GUI objects .",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 2","b":["200","118","108","202","204","206","130","118","208","210","108","202","204","206","118","108","202","204","112","146","112","128","214","118","118","118","108","202","204","200","136","210","212"]},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 2","b":["200","200","118","208","210","214","108","202","204","208","210","212","118","208","210","120","224","218","118","120","220","118","140","120"]},"In one implementation, a TIGOR composer , discussed in detail under  below, models the GAPs (, , and ). The trees (, , ) that model GUIs are input to the type inferencer , which infers types of references to GUI objects  in test scripts (, , and ). The script  for the GAP (, , and ) is parsed using the script parser  and the parse tree  is generated. The parse tree  contains an intermediate tree representation of the test script (, , and ) where references to GUI objects  are represented as nodes. Recall that GUI objects  are described using unique names with which property  values of these objects  are indexed in object repositories . The names for the GUI objects  are resolved into the values of properties  of GUI objects  using an OR Lookup  into the object repositories . The type inferencer  takes the parse tree , the GUI tree (, ), and values of properties  of GUI objects  as inputs and produces a dictionary  that maps  references to GUI objects  in test scripts (, , and ) to their GUI objects types  in GAPs (, , and ). For example, this dictionary  can be implemented as comments in test scripts (, , and ) that accompany references to GUI objects and\/or messages in an inference message repository .","The TIGOR architecture  includes script navigate logic  (see Table 1) that is executed on the script side to obtain the object v which is contained in the GUI object  that is referenced in the test script (, , and ) using the object o. The properties of the returned object v are defined in the object repositories  under the name p. The script navigate  breaks an operation into multiple operations, locating and navigating to the GUI object  in the corresponding applications, determine the state of the application when the GUI object is active, locates the GUI object by identifying by matching the recorded properties in the test script in a object repository. Next the GUI object type is matched to the operation to be performed as identified by a composed test script.","The test scripts (, , and ) are combined into a composed test script by implementing statements that exchange data for a composed GUI object that corresponds to GUI objects in the first and the second applications. Composed test script statements in the composed test script pass data from the statements of one test script to the statements of a second test script for the first and second applications. The statements of the first and second scripts process data of the different types of the GUI object as referenced in the multiple applications. The statements pass information from one script to the other script, while managing the differences in the types of the GUI objects as referenced in the multiple applications.","For example, a first GUI object referred to as user ID represented as a string (\u201crobert\u201d) in the first application, a second GUI object referred to as user ID represented as an integer (\u201c01234567\u201d) in the second application, and user ID represented in the combined application as a different type of GUI object (e.g., an alpha numeric value \u201crobert01\u201d). The first GUI object referred to as user ID represented as a string (\u201crobert\u201d) in the first application\u2014operations performed on the first GUI object may include reading the name from the GUI object and then performing the operation to reverse the string or some other operation. The second GUI object referred to as user ID represented as an integer\u2014operations performed on the second GUI object as an integer may be clearly distinct from the operations performed on the first GUI object.",{"@attributes":{"id":"p-0067","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Example Script Navigate logic"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":{"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mstyle":{"mtext":"SCRIPTNAVIGATE"}}},{"mtd":{"mfrac":{"mrow":[{"mi":"v","mo":"=","mrow":{"mrow":[{"msub":{"mi":["S","T"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["o","T"]}}},{"mi":"navigate","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"p"}}],"mo":"\u00b7"}},{"mrow":{"mrow":[{"mo":["\u2329","\u232a"],"mrow":{"mi":"T","mo":",","msub":{"mi":["S","T"]}}},{"mi":"identify","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["o","T"]},"mo":",","mrow":{"mi":"OR","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"p"}}}}}],"mo":"\u22a2"},"mo":"=","mi":"v"}]}}}]}}}}},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The TIGOR architecture  includes Get Object logic  (see Table 2) that is executed on the GAP side to obtain the collection of objects v, which are contained in the GUI object  that is referenced in the GAP using the object oG.",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Example Get Object logic"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":{"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mstyle":{"mtext":"GETOBJECT"}}},{"mtd":{"mfrac":{"mrow":[{"mi":"v","mo":"=","mrow":{"mo":["{","}"],"mrow":{"mi":"o","mo":"|","mrow":{"mrow":[{"msub":{"mi":["S","G"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["o","G"]}}},{"mi":"child","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mo":["{","}"],"mrow":{"msub":[{"mi":["p","i"]},{"mi":["v","i"]}],"mo":"\u21a6"}}}}],"mo":"\u00b7"}}}},{"mrow":{"mrow":[{"mo":["\u2329","\u232a"],"mrow":{"mi":"G","mo":",","msub":{"mi":["S","G"]}}},{"mi":"getObject","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["o","G"]},{"mi":"v","mn":"1"},{"mi":["v","i"]}],"mo":[",",",","\u2062",","],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}}],"mo":"\u22a2"},"mo":"=","mi":"v"}]}}}]}}}}},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The TIGOR architecture  includes MCALL logic (see Table 3) may evaluate a test script expression (test script statement ) that references a GAP object to wait for the result of the action  performed on the GAP .",{"@attributes":{"id":"p-0071","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example MCALL logic"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(T,E[o\u00b7m(v,...,v)],S), G,a,S ,TS (E[wait(r)],S),(G,[remote r = o\u00b7m(v\u2032,...,v\u2032)],S),TS"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The TIGOR architecture  includes CALLRETURN logic (see Table 4) that returns the result  of method execution  from the GAP  to the test script , and EXECGAP logic (see Table 5) that evaluates the action  at the GAP . E stands for the context in which a given rule is applied.",{"@attributes":{"id":"p-0073","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example CALLRETURN logic"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00004","he":"2.79mm","wi":"1.02mm","file":"US08572570-20131029-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00005","he":"2.79mm","wi":"1.02mm","file":"US08572570-20131029-P00005.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00006","he":"1.78mm","wi":"3.56mm","file":"US08572570-20131029-P00006.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}],"sub":["T","1","n","T","G","T","G","1","n","G"]}},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example EXECGAP logic"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"E::= a;remote r = E"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The testing system TS  including the GAP G  and the test script T , which collectively referred to as programs, P . These programs  may include a set of locations and a set of values (, ). The state, S, of the testing system , TS, is the union of the states of the GAP  and the test script (, ). The state of a program , P, is obtained via the mapping function ProgramState. SP in the reduction rules is shorthand for the application of the ProgramState function to obtain the state S of some program P, which either the test script (, ), T, or the GAP , G. The evaluation relation is defined by the reduction logic shown in Tables 1 through 5.","The object repository (OR) lookup  computes the set of properties  and their values of a GUI object  whose entry in the object repository  is labeled p. The OR lookup  returns a child object whose properties  values match given values of the GUI objects  referenced in the test script statements . The function type returns the type  of a GUI object as it is defined in the GUI framework, the function Member checks if a given method is a member of the set of the methods of a given GUI type  , and the function childOf returns true  if the GUI object of the type  is a child object of the parent object of the type t, otherwise it returns false . The test script (, ), T, and the GAP , G are members of the testing system , TS. Executing the expression e with the initial state ST leads to executing the action , a with the initial state SG, and the system TS transitions to a new system TS. In these rules T and G are programs  and S is a state.","Test scripts (, , ) are run on testing platforms externally to GAPs (, , ), and therefore cannot access GUI objects  as programming objects that exist within the same programs. Using Application Programming Interface (API) calls  exported by testing platforms is a primary mode of accessing and manipulating GUI objects , and these API calls  lead to various run-time errors in test scripts (, , ) especially when their corresponding GAPs (, , ) are modified.","For example, a test script statement (, , ) may include API calls  VbWindow(\u201cLogin\u201d).VbButton(\u201cDolt\u201d).Click. The API calls  VbWindow and VbButton are exported by the QTP\u2122 testing framework. Executing these API calls  identifies a window whose property  values match those stored in some OR (, ) under the name \u201cLogin,\u201d and this window contains a button whose property  values match those stored in some OR (, ) under the name \u201cDolt\u201d. By calling the method Click, this button is pressed. Since API calls  take names of the property  values of GUI objects  as string variables, and if GUI objects are identified only at runtime, it is impossible to apply effective sound checking algorithms. To make matters worse, the names of API calls  depend upon the types  of GUI objects that the parameters of these calls reference (e.g., the parameter for the API call  VbButton should reference a GUI object  of the type  button), otherwise a runtime exception is thrown. In addition, API calls  take names of the property  values of GUI objects  (as defined in Ors , ) as string input parameter variables, and the values of these input parameters are often known only at runtime, making it impossible to apply sound checking algorithms. These problems are rooted in the absence of type information, and exacerbate the process of detecting and understanding failures in test scripts (, , ), making maintenance and evolution of these test scripts (, , ) expensive and prohibitive.","TIGOR  includes a type system  that includes a tractable syntactic method for proving the absence of certain program behavior, specifically run-time type errors by classifying phrases according to the kinds of values they compute. The type system  facilitates programmers to maintain and evolve software effectively by, among other things, detecting errors, providing documentation, and ensuring language safety. In one implementation, the type system  of the programming language cannot be used in which the source code of GAPs  is written to declare types  of references to GUI objects  in test scripts (, , , ). Even if the source code was available, the source code may not contain explicit types  whose instances are GUI objects  for the test scripts (, , ) on which to perform actions . These objects  may be created dynamically in GAPs  using API calls  that are exported by the underlying GUI frameworks . The parameters to these API calls  are variables that contain values of types  of GUI objects  as defined by the type system  of the underlying GUI framework. For example, to create GUI objects  in Windows, programmers invoke the API call  CreateWindow passing a string variable that specifies the types  of these objects as a first parameter.","TIGOR  infers types  of references to GUI objects  as part of expressions in test scripts (, , , , ), and facilitate type checking of these expressions. TIGOR  statically detects type errors with a high degree of automation and good precision.","An executed test script expression changes not only the state of the script, but also states of other GAPs , to which the script is connected (i.e., whose GUI objects the script accesses and controls). Each statement in test scripts (, , , , ), which accesses and manipulates GUI objects  include the following operations: (1) navigate to some destination GUI object and () invoke methods to perform actions on the object. In one implementation, navigation rules are standard. The rules GS navigate  and GS get object  show how test scripts (, , , , ) manipulate the GAP  by initiating a user action  \u2018a\u2019 on the GAP . These rules are evaluated to the reference to GUI object  whose type  is \u2018c\u2019 in the test script (, , , , ).","GS navigate  operates on composite test scripts  and composite GUI objects  that represent unique identifiers and have mappings  to the first GUI object in the second GUI object in the individual first and second applications . When GS navigate  navigates to the composite GUI object, synchronizes navigation to the first and second GUI objects by constructing first and second operation statements  that navigate to the first and second GUI object, and thereby synchronizing operations with the composite GUI object, and the first GUI object and the second GUI object, so that subsequent operations can be performed on the first GUI object and the second GUI object. The synchronization ensures that the individual applications when exercised by the composite application do not fail. The state of the composite GUI object in the composite application may represent different states in the respective applications. Synchronization allows the composite test script to set the composite GUI object value, the states and values for the first and second GUI objects in the first and second applications.",{"@attributes":{"id":"p-0083","num":"0082"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"GS Navigate Logic"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":{"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mrow":{"mrow":{"mrow":[{"mo":["\u2329","\u232a"],"mrow":{"mi":["G","a"],"mo":[",",","],"msub":{"mi":["S","G"]}}},{"mo":["\u2329","\u232a"],"mrow":{"mi":"G","mo":",","msub":{"mi":["S","G"]}}}],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":"\u22a2","mi":"root"},"mo":"=","mi":"v"},{"mrow":[{"mo":["(","\u232a"],"mrow":{"mi":"T","mo":[",",","],"mrow":{"mi":"E","mo":["[","]"],"mrow":{"mi":["navigate","p"],"mo":["(",")"]}},"msub":{"mi":["S","T"]}}},{"mi":"TS","mo":"\u21a6","mrow":{"mo":["\u2329","\u232a"],"mrow":{"mi":"T","mo":[",",","],"mrow":[{"mi":"E","mo":["[","]"],"msub":{"mi":["o","T"]}},{"msub":{"mi":["S","T"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"msub":{"mi":["o","T"]},"mo":"\u21a6","mrow":{"mo":["(",")"],"mrow":{"mi":"c","mo":",","mrow":{"mo":["{","}"],"mrow":{"mi":["object","v"],"mo":"\u21a6"}}}}}}}]}}}],"mo":[",",","],"mi":"TS"}]}}}}},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0084","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"GS Get Object Logic"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":{"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mrow":[{"msub":{"mi":["S","T"]},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["o","T"]}}},{"mrow":{"mrow":[{"mrow":[{"mrow":[{"mo":["(",")"],"mrow":{"mi":"c","mo":",","mrow":{"mo":["{","}"],"mrow":{"mi":"object","mo":"\u21a6","msub":{"mi":["o","T"]}}}}},{"mo":["\u2329","\u232a"],"mrow":{"mi":["G","a"],"mo":[",",","],"msub":{"mi":["S","G"]}}}],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mi":"TS","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["\u2329","\u232a"],"mrow":{"mi":"G","mo":",","msub":{"mi":["S","G"]}}}}],"mo":"\u2208"},{"mi":"getObject","mo":["(",")"],"mrow":{"msub":{"mi":["o","G"]},"mo":",","mrow":{"mo":["{","}"],"mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["p","i"]},{"mi":["v","i"]}],"mo":"="}}}}}],"mo":"\u22a2"},"mo":"=","msup":{"mi":["v","\u2032"]}}],"mo":"="},{"mrow":[{"mo":["\u2329","\u232a"],"mrow":{"mi":"T","mo":[",",","],"mrow":{"mi":"E","mo":"\u2061","mrow":{"mo":["[","]"],"msub":{"mi":["o","T"]}}},"msub":{"mi":["S","T"]}}},{"mi":"TS","mo":["\u21a6","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["\u2329","\u232a"],"mrow":{"mi":"T","mo":[",",","],"mrow":[{"mi":"E","mo":"\u2061","mrow":{"mo":["[","]"],"msub":{"mi":["o","T"]}}},{"msub":{"mi":["S","T"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"msub":{"mi":["o","T"]},"mo":["\u21a6","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mrow":{"mi":"c","mo":",","mrow":{"mo":["{","}"],"mrow":{"mi":"object","mo":"\u21a6","msup":{"mi":["v","\u2032"]}}}}}}}}]}}}],"mo":[",",","],"mi":"TS"}]}}}}},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"When the names of entries in the object repositories  are string constants, sound type checking of expressions that reference GUI objects  in test scripts (, ) may be applied. The type soundness of TIGOR  may be shown through two standard theorems, preservation and progress. Type soundness implies that the language's type system is well behaved. In TIGOR, well-typed inferences to GUI objects do not get stuck, that is they pass the type checking algorithm successfully or halt with errors (progress). If a well-typed expression is evaluated, then the resulting expression is also well typed (preservation). The progress and preservation theorems and proofs are presented below.",{"@attributes":{"id":"p-0086","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Theorem 1 (Preservation)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Theorem 1 (Preservation) If \u00d8 \u251c e:T, and e e\u2032, then \u00d8 \u251c e\u2032 :T."},{"entry":"Proof. Preservation is proved by induction on the rules defining the transition system for step-by-step"},{"entry":"evaluation of TIGOR expressions."},{"entry":"T-NAV By induction let us assume that if e:\u03c4, then e\u2032 :\u03c4. Assume that e.navigate (p) :\u03b4. From"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"the typing rule we have e:\u03c4. By induction e\u2032 :\u03c4 and \u0393 \u251c childOf(\u03b4,\u03c4) : true, so by typing"]},{"entry":[{},"rule T-NAV e\u2032navigate(p):\u03b4."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"T-CALL By induction let us assume that if e:\u03c4, then e\u2032 :\u03c4. Assume that e.m((v,...,v) : \u03b4."}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From the typing rule we have e:\u03c4. By induction e\u2032 :\u03c4 and, so by typing rule T-CALL"]},{"entry":[{},"e\u2032 .m((v,...,v) : \u03b4."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0087","num":"0086"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Theorem 2 (Progress)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Theorem 2 (Progress) If \u0393 \u251c e:T, then either e is an irreducible value, contains an error"},{"entry":"subexpression, or else \u2203 e\u2032 such that e e\u2032."},{"entry":"Proof. The proof is by induction on the rules of the type checking. We consider the following cases."},{"entry":"T-NAV Let e\u2032=e.navigate (p) and assume that e\u2032 :\u03c4. Since e\u2032 is not a value, we must show that"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2203e\u2032\u2032 such that e\u2032  e\u2032\u2032. By induction we have that either e is a value or \u2203\u03b5 such that e \u03b5."]},{"entry":[{},"In the latter case it follows that e.navigate (p)  \u03b5navigate (p). In the former we have"]},{"entry":[{},"v.navigate (p)  v."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"T-CALL Let e\u2032=e.m((v,...,v): \u03b4 and assume that e\u2032 :\u03b4. Since e\u2032 is not a value, we must show"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"that \u2203e\u2032\u2032 such that e\u2032  e\u2032\u2032. By induction we have that either e is a value or \u2203\u03b5 such that"]},{"entry":[{},"e \u03b5. In the latter case it follows that e.m((v,...,v)  \u03b5.m((v,...,v). In the former we"]},{"entry":[{},"have v.m((v,...,v)  v.m((v,...,v)."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0088","num":"0087"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Example TIGOR type rules"},{"entry":"Typing judgments are of the form \u0393\u251ce:T, read \u201cIn the type environment \u0393,"},{"entry":"expression e has type T\u201d. The rule T-NAV obtains the type \u03c4 of the "},{"entry":"expression e in \u039e, which is the test script environment."},{"entry":"In the GUI framework typing environment \u0393 the GUI object"},{"entry":"of the type \u03b4 is the child of the object of the type \u03c4."},{"entry":"Evaluating the expression navigate (p) replaces it with its value "},{"entry":"of the type \u03b4. The rule T-CALL "},{"entry":"evaluates the method call m on the GUI object to the type \u03b4."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":{"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":"\u2003","mtable":{"mtr":[{"mtd":{"mstyle":{"mtext":"T-NAV"}}},{"mtd":{"mfrac":{"mrow":[{"mrow":{"mi":"\u039e","mo":"\u22a2","mrow":{"mi":"e","mo":":","mrow":{"mrow":[{"mrow":[{"mi":["\u03c4","\u0393"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mi":"childOf","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["\u03b4","\u03c4"],"mo":","}}}],"mo":"\u22a2"},{"mi":"true","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mi":"Type","mo":["(",")"],"mrow":{"mi":["OR","p"],"mo":["(",")"]}}}],"mo":":"}}},"mo":"=","mi":"\u03b4"},{"mrow":{"mi":"\u039e","mo":"\u22a2","mrow":{"mi":"e","mo":"\u00b7","mrow":{"mi":"navigate","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"p"}}}},"mo":":","mi":"\u03b4"}]}}}]}}}}}},{"entry":{}},{"entry":{"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mstyle":{"mtext":"T-CALL"}}},{"mtd":{"mfrac":{"mrow":[{"mrow":[{"mi":"\u039e","mo":"\u22a2","mrow":{"mi":"e","mo":":","mrow":{"mrow":[{"mi":["\u03c4","\u0393"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mi":"m","mo":":","mrow":{"msub":[{"mi":"v","mn":"1"},{"mi":["v","n"]}],"mo":["\u00d7","\u00d7"],"mi":"\u2026"}}],"mo":"\u22a2"}}},{"mrow":[{"mi":["\u03b4","m"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mi":"Member","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03c4"}}],"mo":"\u2208"}],"mo":"->"},{"mrow":{"mi":"\u039e","mo":"\u22a2","mrow":{"mi":"e","mo":"\u00b7","mrow":{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":"v","mn":"1"},{"mi":["v","n"]}],"mo":[",",","],"mi":"\u2026"}}}}},"mo":":","mi":"\u03b4"}]}}}]}}}}},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 3","b":["300","100","300","154","322","324","300","234","216","302","202","204","118","304","306","308","310","312","314","316","318","320","208","210","322","324","300","236","326","208","210","322","324","118","304","306","308","310","312","314","328","330","118","304","306","308","310","312","314","324","324","322","300","202","204","322","324","330","322","324","328","300","322","324","300","328","400","500","600","700","800","322","324","302","300","300","328","400","500","600","700","800","118","304","306","308","310","312","314","316","318","320","118","304","306","308","310","312","314","338","330","314","324","304","322"]},"To create mappings  between these properties  and GUI objects , the user moves the cursor over some GUI object  of a GAP (, ), and TIGOR Composer  uses the accessibility API calls  to obtain information about the GUI objects. To confirm the selection, a frame (, ) is drawn around the object with the tooltip window displaying the information about the selected object. Then, the user clicks the mouse button and drags this object (or rather its image) onto the TIGOR Composer dataflow palette . After releasing the mouse button, the dragged object is dropped onto the TIGOR Composer dataflow palette  under the label of the corresponding component. Once the user has dragged-and-dropped all desired GUI objects (, , , , , , ), these objects are connected with arrows (, , ) that specify the directions of data exchanges. For example, by drawing an arrow between the object Description  of the GAP  IT and the object (optional)  of ET, the user specifies that the data from the corresponding GUI object  of GAP  IT will be transferred to the GUI object  of GAP  ET. In one implementation, TIGOR  produces type inferencer message guides (, ) that explain how to transform the data during data exchange (, , ) between the GAPS (, ). Once dataflow mappings (, , , ) between GUI objects (, , , , , , ) are specified, TIGOR  uses the information captured for each screen  and input objects to locate and type expression in test scripts statements (, ) that reference these GUI objects. The information about GUI objects (, , , , , , ) that participate in data exchange (, , ) is used to locate references to these objects in test scripts statements (, ), thereby enabling test engineers to reason effectively about using the test scripts statements (, ) to compose composed test scripts .","TIGOR  infers GUI objects types. Once the test script is loaded (and parsed) and the model of the GUI of a GAP is extracted using the accessibility layer, the type inference logic  resolves types for references to GUI objects in the running GAP. The user can select a reference in the test script to view its corresponding GUI object on the GAPs (, , , , ). When a reference is selected, a frame (, ) is drawn around the GUI object  with the tooltip window displaying the type information about the selected object, and subsequently about its reference. In addition, the user may cursor over any GUI object. TIGOR composer  displays a context menu that allows the user to check to see what references in the test script to which a selected object is mapped.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":["FIG. 4","FIG. 5","FIG. 6","FIG. 7","FIG. 8"],"b":["400","402","404","406","408","410","118","804","806","324","400","300","502","604","602","604","702","802","118","804","806","702","602","604","702","802","118","804","806","802","602","604","702","802","118","804","806"]},{"@attributes":{"id":"p-0093","num":"0092"},"figref":["FIG. 9","FIG. 9"],"b":["900","902","904","906","908","910","912","914","916","118","128","124","910","904","902"]},"In the expression VbWindow(\u201ca\u201d).ActiveX(e).VbEdit(e).Set, navigation is started from the GUI object whose object repository  reference is named \u2018a\u2019 . Expressions \u2018e\u2019  and \u2018e\u2019  compute values of the intermediate nodes in the traversal path at runtime. These expressions are parameters to the API calls  ActiveX  and VbEdit , respectively, and these calls handle GUI objects  of the types  Control and Edit. If e  and e  are evaluated to the names \u201cc\u201d  and \u201cg\u201d , then this statement will execute correctly, otherwise a runtime exception will be thrown. The type inferencer logic  decides which GUI objects should be visited from the node \u2018a\u2019  in the tree  in order to reach a destination object  that exposes the method Set . When visiting GUI objects  in a path expression, the types of these objects should match the API calls  that reference these objects . By finding all paths leading to destination objects while satisfying type constraints, TIGOR  determines whether the navigation expression is correct. If no path exists, then the expression is incorrect. If one or more paths exists, the type inferencer logic  outputs the values to which the expressions e  and e  may be evaluated.",{"@attributes":{"id":"p-0095","num":"0094"},"figref":"FIG. 10","b":["1000","216","118","340","1002","306","308","1004","1006","1008","1000","124","306","308","340","1002","1004","1004","306","308","322","324","100","1000","304","306","308","310","312","314","340","322","324"]},{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 11","b":["1100","322","1102","118","340","1002","306","308","1004"]},{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 12","b":["1200","324","1202","118","340","1002","306","308","1004"]},{"@attributes":{"id":"p-0098","num":"0097"},"figref":"FIG. 13","b":["1300","212","1302","216","118","340","1002","306","308","1004","1302","208","210","212","322","324","118"]},{"@attributes":{"id":"p-0099","num":"0098"},"figref":"FIG. 14","b":["1400","116","1400","202","204","1402","110","1404","108","208","210","112","114","1406","110","1400","1408","110","1410","120","1412","1414","116","114","140","112","124","128","114","1416","112","140","112","124","142","116","124","128","130","124","1418","130","124","124","1420","118","114","142","114","142","114"]},"In another example, referring briefly to , the type inferencer logic  may determine an exposed method  () \u2018Set\u2019  expressed in the test script statement (, , ) VbWindow (\u201ca\u201d).ActiveX(e).VbEdit(e).Set. The type inferencer logic  may determine a destination GUI object () \u2018e\u2019 (, , ) that exposes the exposed method  \u2018Set\u2019 (, ). The element path () between sequential GUI objects in a GUI tree , (e.g., VbWindow , \u201ca\u201d , ActiveX , e , and VbEdit ) leads to the destination GUI object \u2018e\u2019 . In one implementation, the sequential GUI objects (e.g., \u201ca\u201d , \u201ce\u201d , \u201ce\u201d ), (e.g., \u201ca\u201d , \u201cb\u201d , \u201cc\u201d , \u201ce\u201d ), (e.g., \u201ca\u201d , \u201cb\u201d , \u201ce\u201d ), (e.g., \u201ca\u201d , \u201cc\u201d , \u201cg\u201d ) are characterized by GUI object types (e.g., static, control, button, combo, edit, calendar) ().","The API call types (e.g., static, control, button, combo, edit, calendar) in sequence are analyzed for compatibility with the GUI object types (e.g., static, control, button, combo, edit, calendar) in sequence (). For example, ActiveX  includes static and control as API call types, and VbEdit  includes button, combo, edit, calendar as API call types. API call types in sequence may include a static-button sequence, a control-combo sequence, a control-edit sequence and a control-calendar sequence. The logic  to determine the API call types  obtains validated action results for actions  performed by the API calls  on GUI object types  stored in the GUI object repositories .","In one implementation, the logic  finds multiple GUI object interaction paths validated as useable GUI object interaction paths from the multiple GUI object interaction paths that control the actions performed on the sequential GUI objects; and determine a number of GUI object interactions in each of the useable GUI object interaction paths. The logic  further causes the processor to: select from the useable GUI object interaction paths, a first path selected having the least number of GUI object interactions of the useable GUI object interaction paths; or some combination of GUI object interactions of the useable GUI object interaction paths. The logic  further causes the processor to: select from the useable GUI object interaction paths, a first path selected having the greatest number of GUI object interactions of the useable GUI object interaction paths; or some combination of GUI object interactions of the useable GUI object interaction paths. The logic  further causes the processor to: determine the type of the exposed method in the useable GUI object interaction paths, where the useable GUI object interaction paths each extend from a root node representing the destination GUI object that exposes the exposed method. The test script statement references GUI objects using the GUI objects properties of the GUI objects, the properties comprising: name; location; color; size, or any combination thereof.",{"@attributes":{"id":"p-0103","num":"0102"},"figref":"FIG. 15","b":["164","234","1500","332","334"]},"In one implementation, the GUI object repositories  are directed to open source subject GAPs based on the following criteria: easy-to-understand domain, limited size of GUI (less than 200 GUI objects), and two successive releases of GAPs with modified GUI objects. Example GAPs useable with TIGOR  include: Twister (version 2.0) is a real-time stock quote downloading programming environment that allows users to write programs that download stock quotes; mRemote (version 1.0) facilitates users to manage remote connections in a single place by supporting various protocols (e.g., SSH, Telnet, and HTTP\/S); University Directory (version 1.0) allows users to obtain data on different universities; and Budget Tracker (version 1.06) is a program for tracking budget categories, budget planning for each month and keeping track of expenses.","In one implementation, the type inferencer  includes a machine-readable medium  and get object logic (, ), stored on the machine-readable medium, that when executed by a processor, cause the processor to: identify a first GUI object  referenced by a first test script  and implemented in a first application and a identify a second GUI object  referenced by a second test script  and implemented in a second application. The type inferencer  may further include script navigator logic (, ), stored on the machine-readable medium, that when executed by the processor, causes the processor to: obtain the first test script for the first application and the second test script for the second application, and a first result  and a second result  of a first and a second action  performed on the first GUI object and the second GUI object  implemented in the first application and the second application . The type inferencer  may identify a first and a second sequence  of operation statements comprising a first and a second operation statement of the first and the second test scripts (, ). The type inferencer  may establish a composed GUI object reference that maps the first and the second GUI objects to a composed GUI object (, ) in a composed application . The type inferencer logic  further causes the processor to: retrieve mappings  of first and second GUI object types  and type constraints for the first and the second GUI objects  from a first GUI object and a second GUI object repositories . The type inferencer logic  further causes the processor to: create a composed GUI object type mapping  of the first and the second GUI object types  and type constraints to a composed GUI object type and type constraints for the composed GUI object. The type inferencer logic  further causes the processor to: create a composed test script  comprising the first and second sequence of operation statements and a composite sequence of operation statements that, when executed by the processor, cause the processor to synchronize states of the first, the second, and the composed GUI objects.","The first result and the second result are obtained by the type inferencer, and the first and the second sequence of operation statements are identified, by evaluating the sequence of operation statements of the first and the second test scripts to identify those sequence of operation statements that, when executed by the processor, cause the processor to synchronize the states of the first GUI object and the second GUI object. The first GUI object and the second GUI object are referred to in GAPs that compose a composed application.","The composed application comprises composed operation statements that when executed by the processor cause the processor to: perform actions on the first GUI object and the second GUI object of the first and the second applications. The type inferencer logic further causes the processor to: store the composed GUI object type mapping in a composed GUI object repository. The first and the second GUI object type and type constraints of the first and the second GUI objects are mapped, by identifying the sequence of operation statements, comprising the first and second sequence of operation statements, that navigate to the first and the second GUI objects and satisfy the type constraints of the first and the second GUI objects, in order to validate a navigation expression implemented by the first and second sequence of operation statements when executed by the processor. The first and second test scripts comprise operation statements, that when executed by the processor, perform actions on the first and the second GUI objects of the first and the second applications.","The type inferencer resolves the GUI type differences between the multiple applications referred to in the composed test script, and provides automatic reasoning so that the amount of work that would otherwise be done by manual inspection is significantly decreased. For example, where there are two applications and in one application you have a GUI object that holds values of salary as an integer type GUI object and you have a second application that has a text box or combo box that also holds the values of salary but the GUI object type is string. The operations that are performed on these objects and how you treat the values of the objects will be different depending on the GUI object type, integer or a string. The type inferencer infers the values of the GUI objects in the multiple applications for the composed test script so that the operations performed on the GUI objects of the multiple applications correspond to and\/or match the inferred GUI object types (data types). The GUI objects transfer data between corresponding applications. When the inferred GUI object type is incorrect for one of the applications as referenced in the composed test script, the type inferencer issues a warning and identifies the location in the composed test script where the type of the GUI object must be revised.","Accessibility tools are used to identify and extract information about types of the GUI objects in the multiple individual applications. Analyze the test scripts for the individual applications, to obtain information about links objects referred in the test scripts to the GUI objects in the corresponding application. For example, a first application in the second application, where in the first application the GUI object is a text box and in the second application the GUI object is a combo box for each application there is a corresponding test script, that have statements that reference GUI objects in each of the first and the second application. The composed test script includes statements that reference the GUI object as a text box in the first application and that reference the GUI object as a combo box in the second application. Combining the first and the second application, into a mega-application that implements a uniform GUI that controls and manipulates the two GUIs of the first and second applications. The composed GUI object implements a uniform GUI object that represents the GUI objects in the first and second applications. The composed test script executes the composed GUI object. When the value of the composed GUI object is entered in the composed GUI the value is translated to the proper data type and type constraints are satisfied in the corresponding first and second applications that compose the composed application. The inferencer generates a sequence of composed operations statements that perform actions on the GUI objects in order to properly update the value of the GUI objects in the corresponding applications.","The systems may be implemented in many different ways. For example, although some features are shown stored in computer-readable memories (e.g., as logic implemented as computer-executable instructions or as data structures in memory), all or part of the systems, logic, and data structures may be stored on, distributed across, or read from other machine-readable media. The media may include hard disks, floppy disks, CD-ROMs, ROM and RAM. The systems may be implemented in software, hardware, or a combination of software and hardware.","Furthermore, the systems may be implemented with additional, different, or fewer components. As one example, a processor or any other logic may be implemented with a microprocessor, a microcontroller, a DSP, an application specific integrated circuit (ASIC), program instructions, discrete analog or digital logic, or a combination of other types of circuits or logic. As another example, memories may be DRAM, SRAM, Flash or any other type of memory. The systems may be distributed among multiple components, such as among multiple processors and memories, optionally including multiple distributed processing systems. Logic, such as programs or circuitry, may be combined or split among multiple programs, distributed across several memories and processors, and may be implemented in or as a function library, such as a dynamic link library (DLL) or other shared library.","Choosing manual testing of GAPs versus writing test scripts is a matter of trade-offs between the development effort to create test scripts and their projected level of reuse. The GUIs of most GAPs are changed significantly in the first several releases making the effort of writing test scripts worthless. Only when GAPs stabilize, the effort that test engineers put in writing test scripts will be amortized over the future use of the test scripts. TIGOR can foster test automation simply because TIGOR gives a certain degree of assurance that test scripts can be reused in later regression testing. Using TIGOR allows test personnel to reduce costs significantly while keeping test development overhead within acceptable limits. Specifically, clients may be given an option that they pay additional cost for creating test scripts, and this cost may be amortized over the lifetime of the GAPs by using TIGOR that facilitates test scripts to run on consecutive releases of these GAPs.","Accessibility technologies provide different aids to disabled computer users (e.g., screen readers for the visually impaired). Most computing platforms include accessibility technologies since it is mandated by the law. Accessibility technologies provide a wealth of sophisticated services required to retrieve attributes of GUI objects, set and retrieve their values, and generate and intercept different events. The MSAA for Windows, however, using a different accessibility technology will yield similar results. Even though there is no standard for accessibility API calls, different technologies offer similar API calls, suggesting slow convergence towards a common programming standard for accessibility technologies.","The main idea of most implementations of accessibility technologies is that GUI objects expose a well-known interface that exports methods for accessing and manipulating these objects. For example, a Windows GUI object should implement the (Accessible interface in order to be accessed and controlled using the Microsoft Active Accessibility (MSAA) API calls. In TIGOR, accessibility serves as a uniform reflective connector that facilitates test scripts to access and control GUI objects of GAPs.","Using accessibility technologies, programmers can also register callback functions for different events produced by GUI objects thereby obtaining timely information about states of the GUI objects. For example, if a GUI object receives an incorrect input and the GAP shows an error message dialog informing the user about the mistake, then a previously registered callback can intercept this event signaling that the message dialog is being created, dismiss it, and send an \u201cillegal input\u201d message to the tool that controls the GAP.","When a target GAP is started, the accessibility layer loads predefined hook libraries in the process space of this applications and registers addresses of callbacks that should be invoked in response to specified events. Since hooks \u201clive\u201d in the process spaces of GAPs, their callbacks can affect every aspect of execution of these GAPs.","Hooks are user-defined libraries that contain callback functions (or simply callbacks), which are written in accordance with certain rules dictated by accessibility technologies. Hooks are important because they facilitate users to extend the functionality of GAPs, specifically to integrate them with GAPs without changing their source code. Writing hooks does not require any knowledge about the source code of GAPs. In our approach, a hook library is generic for all GAPs, and its goal is to listen to events generated by the GAP into which this hook is injected as well as to execute instructions received from integrated systems. An example of an instruction is to disable a button until certain event occurs. The power of hook libraries is in changing the functionalities of existing GAPs without modifying their source code. Main functions of the generic hook are to receive commands to perform actions on GUI objects, to report events that occur within GAPs, and to invoke predefined functions in response to certain commands and events. Since accessibility layers are supported by their respective vendors and hooks are technical instruments which are parts of accessibility layers, using hooks is legitimate and accepted to control and manipulate GAPs. In addition, writing and using hooks is easy since programmers use high-level accessibility API calls, and may avoid the complexity of low-level binary rewriting techniques.","While various embodiments of the type inferencer have been described, it will be apparent to those of ordinary skill in the art that many more embodiments and implementations are possible within the scope of the invention. Accordingly, the invention is not to be restricted except in light of the attached claims and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The Type Inference of GUI Object References (TIGOR) may be better understood with reference to the following drawings and description. The elements in the figures are not necessarily to scale, emphasis instead being placed upon illustrating the principles of the system. In the figures, like-referenced numerals designate corresponding parts throughout the different views.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 15"}]},"DETDESC":[{},{}]}
