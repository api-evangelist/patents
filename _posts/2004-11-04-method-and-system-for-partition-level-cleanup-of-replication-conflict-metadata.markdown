---
title: Method and system for partition level cleanup of replication conflict metadata
abstract: A method of removing metadata from a database in a multimode replication system includes establishing a metadata retention period for nodes in the system as well as associating changes with nodes on the system. The system responds to an expiration of the retention period for any one node by analyzing the associated changes and nodes and determining if the change affects data shared with other nodes. If the data is shared with other nodes then the expired retention period node metadata is removed from the system. If the expired metadata retention period node does not share the changes with other nodes, the metadata is not removed. This allows any unique changes to still be entered into the database without adversely affecting other nodes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07933868&OS=07933868&RS=07933868
owner: Microsoft Corporation
number: 07933868
owner_city: Redmond
owner_country: US
publication_date: 20041104
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED PATENT APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS","Exemplary Embodiments of the Invention"],"p":["The following references have subject matter in common with the current application:","Co-Pending patent application Ser. No. 10\/434,647 filed May 9, 2003 entitled \u201cArchitecture for Partitioned Computers and Propagation of Changes in Data Replication\u201d commonly assigned with the present application.","Co-Pending patent application Ser. No. 10\/977,652 filed Oct. 29, 2004 entitled \u201cMethod and System for Performing Subset Computation for Replication Topologies\u201d commonly assigned with the present application.","This invention relates in general to the field of database management. More particularly, this invention relates to the management of metadata in database replication systems.","A distributed database is a relational database whose information may be replicated out to multiple user databases. Although dispersed, a distributed database system manages and controls the entire database as a single collection of data. Distributed databases often get updates from multiple users while in operation. In normal operation, a distributed database is accessed by a user and a portion of the information is changed. The changes can be saved back to the database and then distributed out to some or all of multiple other users for their reference. This is done because changes made by one user can affect another user if the data that one user is manipulating is the same data that another user is relying on. Often, the multiple users access the same data at different times and can manipulate that data in different ways before returning it to the database to be saved. Conflicts can arise in a distributed database system as a result of moving a data set or image to and from a users database. For example, a conflict can arise due to multiple updates on the same data set image from multiple users. The distributed database management system must resolve the multiple user changes in order to keep a properly updated and consistent database core. Conflicts arising from multiple users changing the same data can be resolved in the central database of the replication system. Conflict resolution rules can be established based on many factors including but not limited to the type of database, its application, and the hierarchical status of the one user over another.","Data changes and the statistics of the changes, such as who made the changes and when, are stored in metadata with the data of record in the database. In large databases with a large number of users, the conflict metadata can become so large that system stability, scalability, and performance are adversely affected. Large amounts of saved metadata also require large amounts of storage which can be difficult to accommodate if metadata continues to grow. One prior art method of dealing with the growth and convergence difficulties of accumulating a vast quantity of metadata is to set time deadlines for change updates. For example, in a large system with hundreds of users, metadata may be stored for a week so that, among other tasks, conflict resolution may occur. In this instance, it may be necessary to save metadata change history for a week so that a full conflict resolution concerning all changes can be accommodated.","In the current example, at the end of the one week period, the metadata has grown to a point where the storage capacity or the performance of the database may be at a constraint to system performance. Change metadata needed for conflict resolution is then removed. By removing the change metadata, the database system may avoid problems associated with excess metadata such as lack of convergence, stability, storage or performance. However, changes not submitted before the change metadata removal are unable to be accommodated. The user submitting the changes must download a new set of data from the database and start from that point without his earlier changes being entered.","This metadata management technique, although commonly used, can force many users who did not get their changes in before the cutoff time to loose their changes and start over by downloading new information. Also, this may be inequitable to the user who is manipulating a piece of data that no other user is accessing. In a scheme where multiple users can access overlapping portions of data, changes submitted to and resolved by the database are transmitted to other users who have requested the same data so that all users may utilize the most current version of the data they are viewing. Users who have not actively requested the same portion of data do not get updates on data that they are not using. This scenario, coupled with the cutoff deadline for changes discussed above, sets up the inequitable requirement that a sole user of a specific portion of data who does not submit his changes before the cutoff deadline loses his ability to incorporate those changes even though no other user is viewing or manipulating his specific portion of the database. However, this is a heretofore necessary, but adverse, consequence of the use of a cutoff deadline rule for the management of change metadata.","Thus, there is a need for a distributed database management method and system which manages change metadata such that data changes not submitted by a change deadline are not universally lost by all users incorporating a change deadline management scheme. The present invention addresses the aforementioned needs and solves them with additional advantages as expressed herein.","Aspects of the invention includes a method to clean up metadata at a sub database or partition level. By grouping database changes into partitions, a replication system is able to determine which rows go to which subscribers and cleanup metadata at a workgroup level. Subscribers may also be known as users or nodes at a workgroup level that are members of the replication topology in which data is sent to subscribers where it is updated and sent back to the originating database. In one embodiment, the working group level is a node which gets a replica of a portion of database data. A metadata retention timer is set for each node and the metadata is purged if the node associated with the expired timer would have had its data shared with other nodes. Alternately, the metadata is not purged if the node operated on a portion of database data that only the expired node operates upon. Thus, any changes locally stored in the node but not synchronized with the database can be saved and not lost after the retention timer expires. This ability to submit changes after the retention period for node-isolated sets of data changes is enabled by the use of an association of changes to nodes and allows a more flexible method for metadata accumulation management.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1","b":["100","50","60","70","80","90","50","10","20","30","40","100","1","60","10","40","2","70","20","10","80","30","100","90","10","30"]},"Table 1 indicates a mapping of data partitions to nodes and indicates that nodes N, N, and N are using data partition A. Any change to an element of data partition A that is made by node A would be of interest to nodes N and N because those nodes are also subscribing to the information in data partition A. Consequently, any change made to partition A is properly propagated to the other nodes such that nodes N, N, and N receive the updated information.",{"@attributes":{"id":"p-0020","num":"0019"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Node to Dataset Mapping"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Node","Data Partition"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Node 1","Partition A, Partition Z"]},{"entry":[{},"Node 2","Partition B"]},{"entry":[{},"Node 10","Partition A, Partition C"]},{"entry":[{},"Node 100","Partition A, Partition C"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"The action of an editing node submitting a change to partition data so that other nodes may benefit from the change may be termed synchronization. During a synchronization, a node that has a partition data change submits the change back to the database  where conflicts may be resolved between the database and other nodes. Once the conflicts are resolved and a change to a partition element is made, the change is propagated to other interested nodes. The resolution of conflicts involves the use of metadata concerning the partition data and the change which includes such information as which node made the change, the time of the change, the type of change and the other nodes that may be affected by the change. This metadata may also contain version vectors which store replica and version information or simply before and after values of the data. Metadata such as this can become large and prior art systems have developed a scheme for keeping the size of metadata to within manageable and reasonable limits.","One such scheme to regulate the accumulation of metadata is to delete change metadata in a node after a specific period of time. This restriction avoids the buildup of metadata but is also a technique that forces nodes to submit their changes before the metadata retention period expires. If a node does not submit its changes before the metadata retention period expires, then the node looses any changes it made and locally stored, but has not submitted to the database. The loss of the locally stored change is forced because the expired time change cannot be properly checked for conflicts due to the removal of change metadata after the retention period. Changes submitted after the retention period by a node are lost. Additionally, any node that fails to synchronize runs the risk of having stale data. Therefore an expired node generally has to re-download fresh data of interest from the database after the retention period expires.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 2","FIG. 1","FIG. 2","FIG. 1"],"b":["200","200"]},"At the beginning of the first day, at T=0, all nodes, are synchronized such that their retention period are reset and each node has fresh data. It is also assumed that at T=0, node N changed one of its partition A data elements resulting in change C. This change was propagated to nodes N and N who also subscribe to partition A data. At time T=1, node N synchronizes with the database and acquires fresh data. As a consequence, the node N retention period is reset while the retention periods of the non-resynchronized nodes, N, N and N continue to accumulate time.","At time T=2, node N changes the new value of the element in data partition A and forms C\u2032 from the previous C. However, node N only stores the value locally and does not synchronize the change. The other nodes are unaware of the change to C\u2032. A similar event occurs at time T=3 where node N makes a change to data partition B. The node N change makes a change referred to as C in data partition B. However, node N stores the data locally and does not synchronize the change with the database.","At time T=4, the retention period for nodes N, N and N expires. As a consequence, the change metadata for these nodes is purged and is not available for purposes such as change conflict resolution. Node N has made no changes to any data and is therefore unaffected by the expiration of its retention period. Node N looses change C in data partition B as a result of the expiration of its retention period. This is true even though no other node in the system is also using data partition B. Node N is now unable to submit its change C. To make a change, Node N must download fresh information and re-perform the change C and then submit that change to the database even though no other node is using the data. This result is common in prior art metadata management operations.","Also at time T=4, node N looses its change C\u2032. Here, it is clear that other nodes, notably nodes N and N, use the same data partition A data wherein change C\u2032 resides. Consequently, at the end of the retention period at time T=4, node N looses its change metadata and is unable to successfully make its C\u2032 change. If node N wants to insert change C\u2032 into the database after T=4, it must download fresh data and re-perform the change that resulted in change C\u2032.","As a consequence of the prior art rule of a fixed metadata retention period for all nodes, all nodes loose changes that they make and save locally of they do not submit their changes before the retention period expires. This rule can have undesirable consequences for nodes that have important changes but are unable to submit those changes before the retention expiration deadline.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 3","FIG. 2"],"b":["300","300","200","1","2","10","100","300"]},"At time T=0 in , all nodes in the system are synchronized wherein all nodes have received a change C made by node N. At T=0, the change C was propagated to the other interested nodes N and N. Node N was also synchronized at this time, but not because it needed to receive the change C. Node N is synchronized at time T=0 in  for reasons other than a propagation of change C. In this example, the synchronization of node N is assumed to be an event independent of the synchronization of the other nodes, but coincidentally simultaneous in time.","As in , at time T=1 in , node N synchronizes with the database and acquires fresh data. As a consequence, the node N retention period is reset while the retention periods of the non-resynchronized nodes, N, N and N continue to accumulate time.","At time T=2, node N changes the new value of the element in data partition A and forms C\u2032 from the previous C. However, node N only stores the value locally and does not synchronize the change. The other nodes are unaware of the change to C\u2032. A similar event occurs at time T=3 where node N makes a change to data partition B. The node N change makes a change referred to as C in data partition B. However, node N stores the data locally and does not synchronize the change with the database. These events are similar to the events that occurred at similar times in the timeline  of .","Returning to , at time T=4, the retention period for nodes N, N and N expires. According to an aspect of the invention, the node N is unaffected by the expiration of the metadata because node N had no pending changes. According to an aspect of the invention, node N does not loose its change data as before in  even though its retention period has expired. This result is a consequence of the recognition that the node N change C affects no other nodes. That is, there is no other external node in the system that would be entitled to see the C change if it were submitted to the database for conflict resolution and subsequent distribution to interested nodes. There are no other interested nodes. Therefore, the metadata persistent in the database that would allow the change C from node N is retained. Node N is not forced to download fresh data and re-perform the change C. Node C can perform the change after the its data retention period has expired as long as no other node requires that same information. This is one advantage of the present invention.","Returning to  at time T=4, node N looses its change C\u2032. Here, it is clear that other nodes, notably nodes N and N use the same data partition A data wherein change C\u2032 resides. Consequently, at the end of the retention period at time T=4, node N looses its change metadata and is unable to successfully make its C\u2032 change. This result is similar to the result of . As before, if node N wants to insert change C\u2032 into the database after T=4, it must download fresh data and re-perform the change that resulted in change C\u2032.","In one aspect of the invention, changes to data elements of a database downloaded to nodes are mapped in a change-to-node association. This change-to-node association allows a database to determine which nodes can retain the metadata and which nodes have metadata that can be purged. Generally, metadata concerning a node is expired and may be purged if that node is one that would have received changes generated by other nodes and the node has a retention period that has expired. When such a node has changes that are submitted after the retention period, the changes are discarded because there is no conflict metadata to resolve the change against other nodes and the database information. Conversely, if there is a node that has made local changes to one or more elements of data that are not shared by any other node, then the conflict metadata for that local changed data node is not automatically purged upon expiration of the retention period for the node. This advantageous result is enabled by the use of the node-to-change association of the present invention.","A node-to-change association list is a list indicating which nodes changes need to be distributed out based on the partitions of the nodes. For instance, if change C pertains to data for state=\u2018WA\u2019 and nodes N and N have partition of state=\u2018WA\u2019, then the change-to-node mapping list would contain the following exemplary entries:",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"C1, N1"]},{"entry":[{},"C1, N2"]},{"entry":[{},". . ."]},{"entry":[{},"C2, N3 (some other change C2 for another node N3)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["C, Metadata, Nov. 1, 2004","C, Metadata, Oct. 5, 2004\n\nA third list is maintained to record the last timestamp of change received by all other nodes from the current node. For example,\n","N, Nov. 2, 2004","N, Nov. 2, 2004","N, Oct. 1, 2004","N, Sep. 1, 2004\n\nWhen the procedure to clean up change metadata is executed, change C can be cleaned up because all nodes that needed the change have already received it. This can be assumed to be the case because change C was made on Nov. 1, 2004 and nodes N and N have received changes up to Nov. 2, 2004, and they are the only nodes that need change C. Hence, the metadata for C can be cleaned up. Change C has not yet been received by node N because N has received changes up to Oct. 1, 2004 and C was made later on Oct. 5, 2004. Yet metadata for change C needs to be cleaned up because it is older than the retention period from the current time, and is considered too old and hence expired. Since N has not received this change yet, it will now never be able to receive it. The only alternative is to expire N and reinitialize N, i.e. refresh it with fresh data from the current node. Node N has received changes only up to Sep. 1, 2004. Changes C and C got cleaned up because of reasons mentioned above, but node N is not expired because the change-to-node mapping list indicates it should not have received either of those changes anyway. One of skill in the art will recognize that the above mapping list entries are exemplary only to demonstrate the principles of the current invention.\n"]}}}},{"@attributes":{"id":"p-0038","num":"0043"},"figref":"FIG. 4","b":["400","410"]},"The general method  may also time tag any change made by a node (step ) so that the time of the local change is known with respect to the synchronization time or the retention timer value. The general method  also resets the retention period timer if nodes synchronize upon submitting changes (step ). Synchronization involves, at minimum, the entry of data from a node and the conflict resolution of the changed data between all nodes and the database. At node synchronization time, an individual node's metadata retention timer is reset to begin a new retention period count.","As part or as a result of synchronization, changes made by one node concerning specific elements of the database information are propagated to other interested nodes that use the same information (step ). This step ensures that any change that is made to data that is used by multiple nodes is shared by the other nodes that need the updated information. In one embodiment, the retention expiration period termination for a node is tested (step ).","If the retention expiration period termination event is not detected (step , no path), then the process  continues to time tag any data changes made by nodes if they occur (step ), accommodate synchronizations (step ), and keep the system updated (step ). Once a retention period for a node is expired, that is, once the retention timer runs out, this event is detected (step , yes path) and a second inquiry is made. The second inquiry involves identifying whether the expired node is a node for which data must be propagated to multiple nodes (step ).","This inquiry may be answered by scanning the change-to-node association and determining whether the expired node has data that is preferably propagated to other nodes if changes to the data were made. If the answer to step  is that the change-to-node association does not indicate that there are other interested nodes, then the conflict resolution metadata for the expired node may be retained and need not be purged (step ). This has the advantageous result of allowing the expired node to transmit its changes to the database and having the database accept the changes.","However, if the expired node is one where, if changes were made, the changes are preferably propagated to other nodes, then conflict resolution metadata for the expired node is purged (step ). This result prohibits multiple nodes sharing the same data elements of a database from entering changes to a database beyond the retention period and keeps the accumulation of metadata within reasonable limits.","Exemplary Computing Device",{"@attributes":{"id":"p-0044","num":"0049"},"figref":"FIG. 5"},"Although not required, embodiments of the invention can also be implemented via an operating system, for use by a developer of services for a device or object, and\/or included within application software. Software may be described in the general context of computer-executable instructions, such as program modules, being executed by one or more computers, such as client workstations, servers or other devices. Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover, those skilled in the art will appreciate that various embodiments of the invention may be practiced with other computer configurations. Other well known computing systems, environments, and\/or configurations that may be suitable for use include, but are not limited to, personal computers (PCs), automated teller machines, server computers, hand-held or laptop devices, multi-processor systems, microprocessor-based systems, programmable consumer electronics, network PCs, appliances, lights, environmental control elements, minicomputers, mainframe computers and the like. Embodiments of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network\/bus or other data transmission medium. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices and client nodes may in turn behave as server nodes.",{"@attributes":{"id":"p-0046","num":"0051"},"figref":"FIG. 5","b":["500","500","500","500"]},"With reference to , an exemplary system for implementing an embodiment of the invention includes a general purpose computing device in the form of a computer system . Components of computer system  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus).","Computer system  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer system  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, Random Access Memory (RAM), Read Only Memory (ROM), Electrically Erasable Programmable Read Only Memory (EEPROM), flash memory or other memory technology, Compact Disk Read Only Memory (CDROM), compact disc-rewritable (CDRW), digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computer system . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer system , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer system  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD ROM, CDRW, DVD, or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer readable instructions, data structures, program modules and other data for the computer system . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer system  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface , which may in turn communicate with video memory (not shown). In addition to monitor , computer systems may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer system  may operate in a networked or distributed environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer system , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks\/buses. Such networking environments are commonplace in homes, offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer system  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer system  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer system , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Various distributed computing frameworks have been and are being developed in light of the convergence of personal computing and the Internet. Individuals and business users alike are provided with a seamlessly interoperable and Web-enabled interface for applications and computing devices, making computing activities increasingly Web browser or network-oriented.","For example, MICROSOFT\u00ae's .NET\u2122 platform, available from Microsoft Corporation, includes servers, building-block services, such as Web-based data storage, and downloadable device software. While exemplary embodiments herein are described in connection with software residing on a computing device, one or more portions of an embodiment of the invention may also be implemented via an operating system, application programming interface (API) or a \u201cmiddle man\u201d object between any of a coprocessor, a display device and a requesting object, such that operation may be performed by, supported in or accessed via all of .NET\u2122's languages and services, and in other distributed computing frameworks as well.","As mentioned above, while exemplary embodiments of the invention have been described in connection with various computing devices and network architectures, the underlying concepts may be applied to any computing device or system in which it is desirable to implement a metadata cleanup mechanism. Thus, the methods and systems described in connection with embodiments of the present invention may be applied to a variety of applications and devices. While exemplary programming languages, names and examples are chosen herein as representative of various choices, these languages, names and examples are not intended to be limiting. One of ordinary skill in the art will appreciate that there are numerous ways of providing object code that achieves the same, similar or equivalent systems and methods achieved by embodiments of the invention.","The various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers, the computing device will generally include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may utilize the signal processing services of an embodiment of the present invention, e.g., through the use of a data processing API or the like, are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","While aspects of the present invention has been described in connection with the preferred embodiments of the various figures, it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. Furthermore, it should be emphasized that a variety of computer platforms, including handheld device operating systems and other application specific operating systems are contemplated, especially as the number of wireless networked devices continues to proliferate. Therefore, the claimed invention should not be limited to any single embodiment, but rather should be construed in breadth and scope in accordance with the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of exemplary embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating embodiments of the invention, there is shown in the drawings exemplary constructions of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
