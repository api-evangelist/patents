---
title: Method for automatically generating code to define a system of hardware elements
abstract: A method is provided for automatically generating code to define and control a system of connected hardware elements. The method comprises: accepting a system configuration macro with sub-macros for system elements, subsystem elements, and connections there between; accepting a plurality of tables with a plurality of system element behaviors, a plurality of subsystem element behaviors, and a plurality of connection options; defining the system of connected elements in response to selecting sub-macros; defining the physical links between the system elements and the behavior of the system and subsystem elements in response to populating the selected sub-macro parameters; expanding the selected sub-macros; generating executable code; and, accessing the tables in response to parameters in the executable code. Advantageously, the form and function of the system can be defined with programming, or writing application specific code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08418129&OS=08418129&RS=08418129
owner: QUALCOMM Incorporated
number: 08418129
owner_city: San Diego
owner_country: US
publication_date: 20030326
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS","Functional Description","GLOSSARY"],"p":["This application is a continuation-in-part of application entitled, SYSTEM AND METHOD FOR SWITCHING VARIABLY SIZED INFORMATION GROUPS, invented by Yun et al., Ser. No. 10\/023,266, filed Dec. 14, 2001 now abandoned.","This application is a continuation-in-part of application entitled, SYSTEM AND METHOD FOR SIMULTANEOUS DEFICIT ROUND ROBIN PRIORITIZATION, invented by Yun et al., Ser. No. 10\/022,673, filed Dec. 17, 2001 now U.S. Pat. No. 7,079,545.","This application is a continuation-in-part of application entitled, SYSTEM AND METHOD FOR GRANTING ARBITRATED BIDS IN THE SWITCHING OF INFORMATION, invented by Yun et al., Ser. No. 10\/029,581, filed Dec. 20, 2001 now U.S. Pat. No. 7,424,013.","This application is a continuation-in-part of application entitled, SYSTEM AND METHOD FOR HIERARCHIAL SWITCHING, invented by Yun et al., Ser. No. 10\/035,835, filed Dec. 24, 2001 now U.S. Pat. No. 7,020,131.","This application is a continuation-in-part of a pending application entitled, SYSTEM AND METHOD FOR TOLERATING DATA LINK FAULTS IN A PACKET COMMUNICATIONS SWITCH FABRIC, invented by Clovis et al., Ser. No. 10\/373,139, filed Feb. 24, 2003, which is incorporated herein by reference.","1. Field of the Invention","This invention generally relates to software programming and, more particularly, to a method for automating generating code that defines and controls a system of network-connected hardware elements.","2. Description of the Related Art","Conventionally, software can be generating by using macros to construct calls to a particular interface in the effort of promoting hardware independent software. However, the interfaces so constructed are not configuration independent. If the system hardware connections are modified, the macros must also be modified. This can be very difficult to for a chip vendor to manage as new customers decide to use a chipset of complex programmable devices, especially if the original design team has been redirected to other projects.","There is industry demand for integrated circuits (ICs) switching systems that can be easily scaled for Network Access, the Network Edge, or a Core Switch Router, at the high end. SCSA (Signal Computing System Architecture) defines a switch fabric to be the facility for connecting any two (or more) transmitting or receiving Service Providers.",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 10"},"Packets are converted into frames by ingress traffic managers (iTMs). A frame is a logical unit of data, which is often a small piece of a much larger data set such as a file or image. The iTMs feed the ingress side of the fabric. The switch fabric might convert the frame format to a \u201cnative\u201d format, and then on egress, convert the data back into the TM frame format before sending the data to the egress traffic managers (eTMs). If the frames are fixed size (for example: 53 bytes, 64 bytes, or 80 bytes), the frames are often called cells.","Protocol Specific vs. Protocol Agnostic","A switch fabric can be protocol specific or protocol agnostic. An example of a protocol specific switch fabric would be a system designed and optimized specifically for asynchronous transfer mode (ATM) traffic. Another example would be a switch that handles only TCP\/IP traffic. The obvious disadvantage of a switch fabric hardwired to handle a specific protocol is lack of flexibility. Service providers want to sell services to a variety of customers in various industries. Protocols vary from industry to industry.","Even within one protocol type, there can be protocol upgrades. For example, TCP\/IP, the machine language of Internet routers, now runs primarily \u201cIPv4.\u201d This protocol, successful as it has been, has a lack of available addresses, poor security features, and no \u201cquality of service\u201d (QoS) provisions. The next generation Internet protocol is \u201cIPv6.\u201d It provides solutions to these limitations.","A protocol agnostic switch fabric works equally well with all protocol types, however, the traffic manager must be responsible for recognizing specific protocol types. The disadvantage of a protocol agnostic switch fabric is that it may be more complicated, and perhaps slower than a switch fabric dedicated to a particular protocol.","Packet Striping vs. Single Link per Packet","The simplest way for a traffic manager to transmit a packet into a switch fabric is to transmit the packet serially along one line. Striping is a way of achieving higher bandwidth by transmitting a single packet across multiple ingress\/egress lines. For example, a TM can transmit a packet into a switch fabric eight times as fast if the packet is sliced into eight pieces (stripes) by the TM, and conveyed into the fabric along 8 parallel lines simultaneously. The fabric captures the packet in memory, routes it to the required egress destination, and slices the packet into 8 parallel lines before transmitting the packet to the egress TM.","The upside to packet striping is the potential for lower latency. There are several negative aspects of packet striping:","if one of the links is damaged (1 of 8 in the example above), the entire channel is out of service, degrading fault tolerance; and,","the interface between the TM and switch fabric is more complicated. Circuitry must be used to slice the packet into stripes and reassemble it into packets.","Single-Cell Packet vs. Multi-Cell Packets","Many switch fabrics now deployed and passing revenue traffic, especially in wide area networks (WANs), use asynchronous transfer mode (ATM) packets. ATM packets are single-cell packets, with a fixed cell size of 53 bytes, 48 bytes of which is the information payload. The ATM specification evolved in the 1980s and early 1990s. It was then believed that variable length (multi-cell) packets would be too difficult to implement at rates needed for wire-speed traffic. The single-cell solution was a compromise that would work for voice data, video data, multimedia data, email data, file data, etc. With a fixed frame size, switch designs are simplified and ultimately faster.","However, files are better sent in large frames. Voice switching performs better with small bursts of data, corresponding to analog-to-digital converter time slots. Large frames and concomitant switching latencies can render a switch useless for most 2-way voice applications. Voice communications require low latency (time delay). Since ATM had to work for all network data, the small payload (voice) requirements prevailed at the expense of the large frame applications.","For large frames or packets it is much more efficient to establish a path from an ingress port card to the required egress destination, and then leave this path undisturbed until the packet is completed. With single cell packets, the ingress port card must bid for, accept grants, and then schedule each cell of a multi-cell packet.","There are also Frame Relay switch fabrics. Frame Relay is a single-cell protocol, albeit with frame size ranging from 6 to 4096 bytes. Such switch fabrics have been deployed and passing revenue traffic since the early 1990s. These switch fabrics have generally not been used for voice data because of the large latency. Only highly compressed voice traffic works well over frame relay. Voice-over-frame relay was added as an afterthought by network engineers. Frame relay excels at data communications such as local area network internetworking (LAN-to-LAN). Such communications are very high speed and bursty, with non-critical latency constraints.","Cut-Through vs. Store-and-Forward","The conventional method of switch fabric packet routing is called Store-and-Forward. In this method, the switch fabric accepts an input packet and buffers the packet on the ingress side of the fabric, making sure the packet was received intact, knowing the exact number of cells in the packet. The problem with the store-and-forward method is the added latency of buffering the packet. In Cut-through Packet Routing (CPR), a switch fabric is able to send the incoming packet cells to the correct egress port as soon as the destination address is known.","Memory-Based vs. Arbitrated Crossbar","A switch fabric can use memory-based crossbars or arbitrated crossbars. A memory-based crossbar is sometimes called a \u201cshared memory switch.\u201d Ingress packets flow from the port cards into a huge memory bank, which serve as the switch. From the memory bank, the destination address is determined from egress port destination information in the cell headers. The problem with these switch fabrics is that they become prohibitively expensive and large from all the required high-speed memory. Such fabrics cannot be used to reach terabit total switching speeds with technology available today.","It would be advantageous if new firmware executable code could be easily created for new customers by field application engineers (FAEs). Preferably, such code genertion could occur without the need for delving into the finer details of the firmware, knowing the chipset register definitions, or modifying the source code. If the firmware generation process could be highly automated, customers could even learn how to deploy a wide variety of system configurations themselves, with little FAE support, after receiving training for the chipset and its firmware environment.","It would be advantageous to deploy a new system by running a graphical user interface (GUI) on a workstation, with the GUI prompting the user(s) through a process that automatically defines the form and function of the system, without the usual arduous (and expensive) programming. Using \u201cdrag and drop\u201d mouse commands, pull down menus, and icons, the customer or FAE could create a completely new firmware build customized for a completely new hardware configuration.","It would be advantageous if the maintenance of the system firmware could be focused on the code generation system as well as the algorithmic code, without the drudgery of \u201cstarting from scratch\u201d for each new system or customer.","A good example of a candidate chipset for employing the method described above is the Cyclone Switch Fabric. This set of four chips has thousands of registers and 100's of millions of logic gates. A huge and steep learning curve must be overcome for even the most seasoned firmware engineer to master the multiplicity of register settings, system configuration options, and complex algorithms used in the firmware. It would be advantageous of the Cyclone chipset firmware can developed for new systems with the help of automated tools.","It would be advantageous if the automatic system definition process could also be applied to a broader range communications chipsets. Other examples chipsets might include framers, media access controllers (MACs), PHY devices (used in the OSI Physical layer), Physical Medium Dependent (PMD) devices, framers, network processors, and traffic managers. All such devices have registers, which must be loaded to configure the devices and registers, which must be read to monitor the health and status of the devices. All such devices also must be connected together in a specific manner in a newly proposed system (the form of the system). And all such devices have a multiplicity of parameter selections (the function of the system). The system engineer, solutions architect, or FAE could use the automated firmware tools on customer visits to propose new solutions to customer needs.","A method is provided for automatically generating code to define and control a system of connected hardware elements. The method comprises: accepting a system configuration macro with sub-macros for system elements, subsystem elements, and connections there between; accepting a plurality of tables with a plurality of system element behaviors, a plurality of subsystem element behaviors, and a plurality of connection options; defining the system of connected elements in response to selecting sub-macros; defining the physical links between the system elements and the behavior of the system and subsystem elements in response to populating the selected sub-macro parameters; expanding the selected sub-macros; generating executable code; and, accessing the tables in response to parameters in the executable code. Alternately stated, the expansion of the sub-macros defines the form and the function of the network hardware, with programming.","Additional details of the present inventions methods are provided below.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 1","FIGS. 2 and 3"],"i":"a ","b":"100"},"Step  generates a system configuration macro. Step  generates tables defining a plurality of system element behaviors, a plurality of subsystem element behaviors, and a plurality of connection options.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 1","FIG. 1"],"i":["b ","a"],"b":["102","104","102","104"]},"Step  accepts the system configuration macro with sub-macros for defining system elements, subsystem elements, and connections there between. Step  selects sub-macros. Step  populates parameters in the selected sub-macros. Step  accepts the plurality of tables defining a plurality of system element behaviors, a plurality of subsystem element behaviors, and a plurality of connection options. Step  expands a plurality of sub-macros with populated parameters. In some aspects, Step  expands the parameters of the selected sub-macros. Step  generates executable table indexing code. For example, the code can be generated by means of a complier specific to the target processor. Step  elaborates the executable code. Step  accesses the tables in response to parameters in the executable code. The above-mentioned steps describe the steps that a user would perform to define, compile, and run the code.","In some aspects of the method, elaborating the executable code in Step  includes differentiating the executable code into code sections corresponding to system and subsystem elements. Then, accessing the tables in response to the parameters in the executable code in Step  includes loading accessed tables into corresponding subsystem element memories.","In other aspects, accepting the system configuration macro with sub-macros for defining system elements, subsystem elements, and the connections there between, in Step , includes accepting a hierarchical set of fields, with subsystem elements being indentured to system elements. Then, accessing the tables in response to the parameters in the executable code in Step  includes substeps. Step accesses a sub-table in response to indexing a table. Step loads values from the sub-table in chip registers.","In some aspects, expanding the plurality of sub-macros with populated parameters in Step  includes generating C++ language code. Then, generating executable code in Step  includes generating machine code.","To better illustrate the invention, the above-mentioned steps can be understood as a process of configuring a switch fabric of cards including firmware-enabled chips. Then, accepting the system configuration macro with sub-macros for defining system elements, subsystem elements, and the connections there between, in Step  includes accepting a switch fabric configuration macro for defining switch fabric cards, firmware processing integrated circuits (chips) on the cards, and the connections between the cards. Further, Step  may include accepting sub-macros to hierarchically define the system level (slot number), the slot level (card type), card level (chip type), and chip level (link types and endpoint).","In some aspects, accepting sub-macros to hierarchically define the system level, the slot level, card level, and chip level, (Step ) includes differentiating at the slot level between port cards to manage traffic flow in and out of the switch fabric, and switch cards to manage backplane traffic flow between the port cards. In other aspects, Step  includes differentiating at the port card level between memory subsystems (MSs) and queuing\/scheduling (QS) devices. In yet other aspects, Step  includes differentiating at the switch card level between arbiter and crossbars. Further, Step  may include defining MS chip level data link connections.","Defining MS chip level data link connections may further include defining input port card ingress data links, backplane data links, and output port card egress data links. In other aspects, accepting sub-macros to hierarchically define the system level, the slot level, card level, and chip level, in Step  includes defining PQ chip level control link connections. That is, defining grant\/bid control links between input port card ingress QS devices and switch card arbiters and defining grant\/bid control links between output port card ingress QS devices and switch card arbiters.","In other aspects, accepting sub-macros in Step  includes defining the chip level. Then, accessing the tables in response to parameters in the executable code in Step  includes accessing tables to define chip default register settings and chip modes.","Some aspects of the method include further steps. Step , following the elaboration of the executable code, monitors system performance. Step  compares the system performance to a standard. The standard may be that the data and\/or control links merely interface. Alternately, the standard may be a bit error rate, for example, or an information bandwidth. Step , in response to sub-standard system performance: automatically repopulates selected parameters in the selected sub-macros; accesses tables in response to the repopulated parameters; and, instantiates new executable code. Note, Step  through  may be preformed iteratively until a minimum level (the standard) of system performance is obtained. In other aspects, the method may shut to system down if a minimum level of performance is not (eventually) achieved.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 2","b":["200","202","204","206","208","210","212","214","216","214"]},"In some aspects, elaborating the executable code in Step  includes differentiating the executable code into code sections corresponding to cards and chips. Then, indexing the tables in response to calling the parameters (Step ) includes loading accessed tables into corresponding card chip memories.","In other aspects, Step , following the elaboration of the switch fabric with the executable code, monitors switch fabric performance. Step  compares the switch fabric performance to a standard. Step , in response to sub-standard switch fabric performance: automatically repopulates selected parameters in the selected sub-macros; indexes tables in response to the repopulated parameters; and, instantiates new executable code.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 3","b":["300","302","304","306","308","310","312","314"]},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 9","b":["400","402","404","406","408"]},"The present invention methods use C++ macros to define the physical configuration of a multi processing packet switch fabric system in a hierarchical manner that includes automatic code generation and chip register programming.","The System Configuration File is a human-readable configuration file and a C++ source file containing C++ macros combine to expand into executable code that forms the run-time implementation of the a packet switch fabric system, for example. The system configuration file is a human-readable text file that defines the hardware layout in its entirety, and performs initial programming of the chips for a discovered hardware configuration.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 4"},"The present invention method is different from conventional system configuration macros in that the form and function of an entire physical subsystem is described and defined in a text file consisting of C++ language macros and hierarchical data tables. Typically, a conventional Element Management System (EMS) maintains a provisioning database that describes cross-connect configurations, equipment and facility states. Various layers of system code use this database to program the hardware. The physical configuration of the system is opaque to this software. The physical layout, connectivity is manifest only when viewed by an operator through the use of a graphical user interface (GUI) that creates a diagram, or as a result of a report output.","The present invention system configuration file and tables makes the firmware agnostic of the complete subsystem, enabling it to autonomously reconfigure itself based on its own discovery. A complex system is modeled as a hierarchy of autonomous subsystems managed by a high-level communication protocol. The approach is also flexible; practically every physical parameter of the system is captured in the configuration tables. For ease of use, human-readable macro text is pre-processed, not interpreted. Therefore, any ANSII C++ preprocessor can process it. A special program is not required for interpretation, as an interpreter need not be created to process the file. The invention is useful in that the tables that drive the configuration file can be used as input to a GUI that can graphically diagram how the system is configured both physically and functionally. That is, the combination of system configuration file and the tables completely describe both the physical and functional aspects of the switch subsystem.","The AMCC Cyclone Firmware System Configuration Mechanism","The present invention method is enabled, in one specific embodiment, as the Cyclone Firmware Subsystem (CFS) System Configuration mechanism, that encapsulates the form and function of an entire physical Cyclone Switch Suosystem (CSS) in a text file consisting of C++ language macros and hierarchical data tables.","The configuration system is key to ease of use and flexibility, capturing every physical parameter of the CSS in human-readable tables and macros that can be processed by any ANSII C++ preprocessor to generate the code required to run on any variant of a Cyclone switch system. No special interpreters or proprietary pre-processors are required. The CFS configuration mechanism is not hardware independent, but configuration independent, meaning the CFS can re-program the Cyclone chips to accommodate all possible system configurations.","The configuration table approach to system programming is more useful than modifying source code because the tables can alternatively serve as input to a Graphical User Interface (GUI) tool that generate a picture of the system, graphically diagramming how the system is configured, both physically and functionally.",{"@attributes":{"id":"p-0070","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["API Cyclone Firmware Subsystem Application Programming Interface\u2014The API is provided as a means for software on the system controller, or \u201cHost\u201d, to communicate with the Cyclone Firmware Subsystem.","CFS Cyclone Firmware Subsystem\u2014CFS refers to the entire collection of firmware that represents the a standalone subsystem that controls the operation of the Cyclone switch hardware. A major sub-component of the CRF is the Token Bus Driver, which is a layer of software that handles the low-level, OS and hardware-dependent read and write operations on the token bus.","CSS Cyclone Switch Subsystem\u2014CSS refers to all of the hardware and firmware that makes up a complete Cyclone packet switch fabric. The CSS consists of the Cyclone chips on various port cards and switch cards that comprise the hardware and the firmware that operates on those chips. The CSS is the only context that includes the concept of hardware, all other terms that remain refer to firmware entities.","Configuration table module: a programming abstraction of the compile-time configuration class and run-time configuration table object that is encapsulated as a manageable entity, dependent only upon its interface and not implementation. The configuration table module is addressed through the configuration table module API.","Configuration table class: compile-time definition of the structure, form, properties and methods (functions) of a configuration table object.","Configuration table object: run-time instantiation of a configuration table class, or variable of type \u201cConfigTable\u201d. The configuration table object includes the configuration table and the methods that operate upon the table.","Configuration file: a build-time entity, the configuration file contains the macro definitions that, when elaborated (run, or executed) create the methods that execute upon the data in the configuration table. In Release 1.0 of the firmware, the configuration file name is \u201cSystemConfiguration.cfg\u201d.","Configuration table: a run-time entity, the configuration table is the RAM-resident aggregation of data tables that define the Cyclone fabric subsystem configuration, and the values contained in every chip register contained in the system.\n\nConfiguration Table Module\n"]}}}},"This section describes the purpose, structure and function of the configuration table module. The Configuration Table Module consists of the system configuration files and associated methods. This architectural feature of the CFS abstracts the entire Cyclone switch fabric into one central configuration file. The configuration table allows a complete Cyclone fabric subsystem to be defined and modified without the need to re-program, greatly simplifying the system management overhead required to provision, monitor and upgrade the packet fabric subsystem.","The System Configuration.cfg file contains macros that describe the hardware configuration to the Cyclone firmware. The macros expand into object code that executes on the switch card CPU. For example the SWITCH_CARD macro will be replaced by code that, upon execution (elaboration), will instantiate a switch_card object. The System Configuration File is a human-readable configuration file and a C++ source file containing C++ macros combine to expand into executable code that forms the run-time implementation of the Cyclone packet switch fabric system. It defines the hardware layout in its entirety, and performs initial programming of the cyclone chips for a discovered hardware configuration. The format of the configuration file is itself hierarchical, indentured to reflect higher and higher specificity of the system.",{"@attributes":{"id":"p-0073","num":"0079"},"figref":"FIG. 5"},"Data for the Configuration Table is accumulated from the header files listed below:","SystemConfiguration.cfg: as described above, provides the initial overall slot layout that defines which card type occupies what slot and what chips are configured on each card. The macros in this file are expanded into code by the compiler to make up methods in the ConfigTable object. At startup, these methods verify the hardware configuration, and read values from the tables described below, to program the Cyclone chips on the cards that are found.","The System Configuration file \u201cSystemConfiguration.cfg\u201d is modified by the system designer at build time to reflect the hardware layout of the Cyclone fabric. The contents are used at compile time to generate methods that make up the Configuration Table object, which is instantiated at run time to verify the hardware configuration and to pro-gram default values into the chips. The configuration information and the class methods that operate upon this information are included in the boot image that is present in the persistent store of the primary switch card (either hard disk, or some type of EPROM). A configuration table can also be downloaded to the primary card from the host during startup.","For each chip, in addition to the chip ID, there are three \u201cmodes\u201d which are numbers that point to a section in the register tables. For each chip type there is a set of four register tables. The first table is simply a base table that contains an initial value for each register. The other three tables contain the mode specific values, and these tables are used to modify the base tables at runtime (i.e. the relevant entries in the mode tables are merged with the base tables). At runtime, the firmware starts with a copy of the base tables and successively merges in the appropriate entries from the other tables. The final result is programmed in the chips. The following header files contain tables that are hierarchical, with the first configuration file having the broadest scope for a particular chip type, and successive files having more resolution into the settings of individual chips.\n\n",{"@attributes":{"id":"p-0078","num":"0088"},"figref":"FIG. 6"},"Self-Healing and Load Balancing","Self healing is a process by which the firmware dynamically changes system configurations to overcome system failures. Once corrected, the system brings itself back to a new \u201cstandard\u201d of performance. In performing self healing, the firmware monitors the health of control and data links between switch chips and dynamically re-routes data and control information when links fail, in order to maintain optimum performance levels. Data and control traffic loading is also re-balanced when cards are inserted or removed from the system. Multiple levels of control performance is supported if the number of control links limits credit bandwidth, automatically switching to dual-credit mode to preserve credit bandwidth. The mode changes are the result of selecting different mode tables and re-programming the chip registers with values from those tables.","One aspect of Self Healing is Load Balancing. In the example system of the Cyclone Switch Fabric, Load Balancing would equally balance the \u201cload\u201d of port cards being configured and monitored by a processor on a switch card. Each such processor, through its dedicated Arbiter, can supervise up to 32 port cards. But if there are four working switch cards in the system, each processor would supervise 8 port cards in a load-balanced system. If one switch card were then to fail, the self healing firmware would detect this failure, and a load balancing routine might reallocate ports to switch cards such that 11 port cards are each supervised by switch cards 1 and 2, and the remaining 10 port cards are supervised by switch card 3.","Overview of the Cyclone Firmware Relating to Load Balancing","The Cyclone firmware is a collection of task objects that execute on the switch card CPUs. Communicating through a TCP\/IP connection, the Cyclone firmware can be controlled by any host processor through a supplied Application Programming Interface (API). Configurable entirely through the use of configuration files, the Cyclone firmware is a distributed system providing fault-tolerant control of up to 16 switch cards and 32 port cards to program, monitor and control the Cyclone chips in a Cyclone switch fabric system. Typically, a switching subsystem contains multiple, intelligent switch cards that are connected through an internal network in a loosely coupled fashion.","A Cyclone Switch Subsystem (CSS) is generally distributed among the port cards and the switch cards. The port cards contain input and output queue chips ( iPQ and oPQ,  EDFQ) and memory subsystem chips ( iMS and eMS). The switch cards contain an Arbiter () and up to five Crossbar chips (Arbiters and Crossbars are both  parts but are configured by a jumper to operate in either Arbiter or Crossbar mode). Included in the CSS is a controlling CPU that is resident on every switch card.","Overview of the Cyclone Firmware Relating to Self Healing","The firmware provides the capability to resynchronize individual credit counters in the PQ chips on a periodic basis, or on-demand in case errors are detected by the firmware. The firmware will re-synchronize the appropriate flow control counters of those particular ports for which an error was detected. Typically, credit resync is the result of detecting a status flag set by the S Arbiter chip, indicating either a soft or permanent link error, or by the system detecting that a switch card has failed. If a credit-carrying control link goes down, the link will be re-assigned and the credit counters resynchronized.","The failure of a control link between an Arbiter and PQ indicates to the firmware that backplane tokens cannot be reliably communicated over the failed link The port card may need to be managed by a different switch card in order to re-establish connectivity to the chips on the port card. Once the self healing is complete, the BP_CBFC configuration of the switch may need to be updated. To update the BP_CBFC configuration, the register settings of the appropriate Arbiter chips must be updated, followed by those on the MS chips, and ultimately those on the PQ chips. Reconfiguration of the control links is performed by selecting an appropriate map from the PQ chip configuration file.","Example of Self-Healing Configuration Table Entry",{"@attributes":{"id":"p-0085","num":"0095"},"figref":"FIG. 7"},"The \u201cChip Configuration Mode\u201d is used as an index into the configuration tables to select the appropriate tables containing the chip register values for a given Chip Configuration Mode. The \u201cFamily Mask\u201d defines alternate configurations to support load balancing and self healing. Family Mask is combined with Chip Configuration Mode to find compatible modes for alternate credit transmission\/reception. The search is done in the order that the various configurations occur in the configuration file, with the most optimal configurations occurring first, followed by less optimal configurations. At some point the number of links becomes small enough to change the credit mode to \u201cdual\u201d mode, so that each credit returned to an iPQ is counted as two credits, to halve the number of credits that are needed to keep the switch running.",{"@attributes":{"id":"p-0087","num":"0097"},"figref":"FIG. 8"},"Link Failures","When the firmware detects a control or data link error during polling, it sends an internal system error message to the system error handler on the primary switch card. At the same time, an error message is sent to the user. The system error handler reconfigures the switch when it receives a control link failure error and, synchronizes the credit counters of all PQ's when it receives a data link failure error.","Control Link Failures","The failure of a control link between an Arbiter and PQ indicates to the firmware that tokens cannot be reliably communicated over the failed link. The port card may need to be managed by a different switch card in order to re-establish connectivity to the chips on the port card (this is referred to as self healing from the Firmware perspective, as opposed to load balancing from the switch's perspective, which balances cell traffic load among the available links). Once the load balancing is complete, the Credit Based Flow Control (CBFC) configuration of the switch may need to be updated. To update the CBFC configuration, the register settings of the appropriate Arbiter chips updated, followed by those on the MS chips, and ultimately those on the PQ chips.","The self healing Process does the following:\n\n","Data link failures are detected on the receive side of the ingress MS during register polling. The Host is notified of these failures. A data link failure detected on the receive side of the ingress MS indicates that there's an error on the data link between the traffic manager and the iMS. The firmware has a map of how the TM links map between the ingress MS and egress MS chips. Using this map, the system error handler will disable the data link in the eMS \u201cOutput Link Enable\u201d bit mask that corresponds to the failed data link detected by the ingress MS.","Data Link Failures from Ingress MS to Crossbar","Data link failures are detected on the receive side of the Crossbar during register polling. The Host is notified of these failures. Each link is monitored for 8B\/10B violations, frame misalignment, byte misalignment, loss of CDR lock, and FIFO overflow\/underflow. When the link error threshold is exceeded for a link, the Crossbar will initiate a report to the Arbiter over the token bus. The result is that the Arbiter will no longer grant transmissions over that link. An idle cell is automatically generated by the Crossbar for those outputs that have no corresponding valid input. The errored link is detected during register polling and the Host is notified. Disabling a link reduces switch performance and should be cause for removal of the offending card(s).","Data Link Failure from Crossbar to Egress MS","Data link failures are detected on the receive side of the egress MS (from backplane or another MS) during register polling. The Host is notified of these failures. Failed backplane links between the Crossbar and receiving eMS are communicated to the iPQ on the same port card by the MS2PQ_LINK_FC signal, which communicates all receive link status in round robin order. Once the iPQ gets a failed link notification, it passes the information to the Arbiter during bids (byte-7, bit-1) so that the Arbiter will stop using that link to grant connections to the respective egress port and channel (and subchannel).","System Error Counter Timeout","The iPQ indicates a credit counter timeout \u201cerror\u201d in bit 2 of its High Priority Message register (register ). The error is detected by a polling task, which reports it to its local XbarCard task. This task does not report the error to the user nor to the system error handler task. Instead, the XBarCard task intercepts the error and sends the NOT_SYNCH_TIMED_OUT_COUNTERS message to the local CreditResync task. The local CreditResync task detects which specific counter or counters have timed out by reading the timed out counters bit mask from the iPQ. The CreditResync task resets each timed out counter to the maximum number of credits depending on the current CBFC mode.","A method has been provided for automatically generating code to define and control a system of hardware elements. A switch fabric embodiment of the invention has been presented for illustration. However, the invention is not limited to merely this example. Other variations and embodiments of the invention will occur to those skilled in the art."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 1","i":"a "},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 1","FIG. 1"],"i":["b ","a. "],"b":["102","104"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
