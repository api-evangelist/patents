---
title: Caching data
abstract: A method of caching data is provided, which includes a plurality of processes to , a cache manager and a data type register including at least one data type and a corresponding data type bit . Said data type bit is set () within the register on being accessed by each of said processes and subsequently reset () within the register. The cache manager restores () each of said set data type bit and identifies its corresponding data type . The cache manager writes the output data of each of said processes within a memory cache and said cache manager resets () said memory cache when the data type bit set by the last of said processes is reset.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06910103&OS=06910103&RS=06910103
owner: Autodesk Canada Inc.
number: 06910103
owner_city: Montreal
owner_country: CA
publication_date: 20020829
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","INTRODUCTION","BRIEF SUMMARY OF THE INVENTION","BEST MODE FOR CARRYING OUT THE INVENTION"],"p":["This application claims the benefit under 35 U.S.C. \u00a7119 of the following co-pending and commonly assigned foreign patent application, which application is incorporated by reference herein:","United Kingdom Patent Application No. 01 21 115.0, entitled \u201cCACHING DATA\u201d, filed on Aug. 31, 2001.","This application is related to the following co-pending and commonly-assigned patent applications, which applications are incorporated by reference herein:","U.S. patent application Ser. No. 10\/196,671, entitled \u201cCONTINUATION MANAGER\u201d, by Itai Danan, filed on Jul. 15, 2002; and","U.S. patent application Ser. No. 10\/196,652, entitled \u201cPROCESSING DATA\u201d, by Itai Danan, filed on Jul. 15, 2002.","The present invention relates to optimising data caching by initialising and maintaining a structure referencing data during execution of an application running on a computer.","The speed and capacity of processing and data storage devices has gradually shifted the limits of application functionality from hardware to application instructions themselves.","The increasing complexity of many applications is such that it is no longer possible to consider a set of application instructions as ever being finished. Instead, the source code for these instructions evolves over time, and improves according to changing user requirements over a product lifetime spanning many years. Even in the shorter term, application instructions may change from day to day. In order to manage this constant evolution and minimise the problems arising from its inherent complexity, it is established good engineering practice for applications to comprise a large number of small sets of instructions or modules.","Individual teams of engineers can work on modules separately, and this enables parallel evolution of several aspects of an application's functionality. Theoretically, any complex application can be broken down into sufficiently small individual modules so that complexity, at the module level, never becomes a limiting factor. However, as the number of said modules increases, the problem of combining them to work together becomes more difficult. In the art, it is this problem which places an upper limit on the complexity of reliable application evolution.","When combining modules in an application, a fundamental difficulty stems from the initialisation of the data, which modules provide a specific functionality for the processing thereof. A main application may comprise tens or even hundreds of said modules. Thus should any of said modules fail to initialise data and\/or fail to further process the cached data generated by another of said modules, this may generate a corruption of the output data or even a main application crash.","The initialisation has to occur before the main application processing begins and, in the case of dynamically loaded modules known in the art as \u2018plug-ins\u2019, said initialisation often has to occur during said main application processing. In order to avoid this problem, engineers traditionally have to keep application complexity as low as possible, while still fulfilling the application requirements, and thus there exists a limit to the creativity with which engineers may devise new or improved modules for a main application.","A further problem encountered by individual teams of engineers is that they traditionally have to implement their expertise in an application by using the application's specific Application Programming Interface (API). The equipping of numerous different applications with the same specialist functionality can prove expensive and time-consuming, as said specialist functionality must be modified for implementation according to every different API.","In certain environments, such as video editing, application size and complexity cannot be avoided. Thus, when attempting to process input data by means of said modules to generate an output, such as a video sequence or composite image, very significant and costly data processing corruption may occur, especially if a large quantity of various types of data is cached during said processing.","A need therefore exists for allowing an application to benefit from a combination of modules developed under differing APIs without however compromising the overall functionality of said application due to the corruption of any of said modules' output.","It is an object of the present invention to provide an improved method of caching data with maintaining a register of data definitions in an application comprising a large number of application modules.","According to an aspect of the invention, there is provided a method of caching data, which includes a plurality of processes, a cache manager and a data type register including at least one data type and a corresponding data type bit. A data type bit is set within the register on being accessed by each of said processes and subsequently reset within the register. The cache manager restores each of said set data type bit and identifies its corresponding data type. The cache manager writes the output data of each of said processes within a memory cache and said cache manager resets said memory cache when the data type bit set by the last of said processes is reset.","According to another aspect of the invention, there is provided an apparatus configured to cache data, comprising display means, storage means and processing means, wherein said display means is configured to display a plurality of processes; said storage means is configured to store said plurality of processes, a cache manager and a data type register including at least one data type and a corresponding data type bit; and said processing means is configured by said cache manager to perform the processing steps of setting a data type bit within said register on being accessed by each of said processes and subsequently resetting said data type bit within said register; restoring each of said set data type bit and identifying its corresponding data type; storing the output data of each of said processes within a memory cache; and resetting said memory cache when the data type bit set by the last of said processes is reset.","According to yet another aspect of the invention, there is provided a computer system programmed to cache data, including a plurality of processes, a cache manager and a data type register including at least one data type and a corresponding data type bit, programmed to perform the processing steps of setting a data type bit within said register on being accessed by each of said processes and subsequently resetting said data type bit within said register; restoring each of said set data type bit and identifying its corresponding data type; storing the output data of each of said processes within a memory cache; and resetting said memory cache when the data type bit set by the last of said processes is reset.","According to still another aspect of the invention, there is provided a computer readable medium having computer readable instructions executable by a computer, such that said computer performs the steps of setting a data type bit within a data type register, which includes at least one data type and a corresponding data type bit, on being accessed by each of a plurality of processes and subsequently resetting said data type bit within said register; restoring each of said set data type bit and identifying its corresponding data type; storing the output data of each of said processes within a memory cache; and resetting said memory cache when the data type bit set by the last of said processes is reset.","The invention will now be described by way of example only with reference to the previously identified drawings.",{"@attributes":{"id":"h-0007","num":"0000"},"figref":"FIG. 1"},"Most modern data-processing applications, whether generic such as word processors and spreadsheet applications or very specific such as digital video editing applications, undergo daily evolution, through modification and\/or improvement of their numerous function-specific modules, also known to those skilled in the art as \u2018plug-ins\u2019.","It is well known in the art for individual teams of engineers, who are totally removed from the company producing a specific application, to create new- or modify existing function-specific modules in order to improve said application's functionality, thus enhancing any of such generic or specific applications with said engineers' own particular expertise. An example would be an engineer specialising in three-dimensional motion tracking technology, who prefers to confer its technological expertise to most applications requiring said motion tracking functionality, such as image compositing, virtual worlds modelling or avatar animating, rather than any specific compositing application in particular.","Most engineers distribute plug-ins over networks such as the Internet, as numerous iterations of said plug-ins are traditionally circulated for testing and debugging prior to commercial release amongst multiple users using a network of connected computers. An environment for connecting multiple users to whom plug-ins will be distributed is illustrated in FIG. .","Computer terminals ,  and  are image processing systems located at an image compositing company  and are connected to the Internet  via an Internet Service Provider (ISP) .","Computer terminals ,  and  are image processing systems located at a different image compositing company  and are also connected to the Internet  via an Internet Service Provider (ISP)","Computer terminal  is connected to the Internet  via an Internet service provider (ISP)  and is operated by a third-party engineer as described above.","The ISPs ,  and  in combination with user terminals  to , provide each individual user with a unique IP address, e-mail account and other optional Internet facilities such as are commonly provided to a user with an ISP account. Provided that appropriate data transfer applications, protocols and permissions have been set up, there is provided the scope for terminals ,  and  and terminals ,  and  to access data stored on terminal .",{"@attributes":{"id":"h-0008","num":"0000"},"figref":"FIG. 2"},"An image processing system such as terminal  is illustrated in  processing system , such as an Octane\u2122 produced by Silicon Graphics Inc., supplies image signals to a video display unit . Moving image data is stored on a redundant array of inexpensive discs (RAID) . The RAID is configured in such a way as to store a large volume of data, and to supply this data at a high bandwidth, when required, to the processing system . The operator controls the processing environment formed by the processing system , the video monitor  and the RAID , by means of a keyboard , and a stylus-operated graphics tablet . The processing system shown in  is optimal for the purpose of processing image and other high bandwidth data. In such a system, the instructions for controlling the processing system are complex. The invention relates to any computer system where processing instructions are of significant complexity.","Instructions controlling the processing system  may be installed from a physical medium such as a CDROM or DVD disk , or over a network, including the Internet. These instructions enable the processing system  to interpret user commands from the keyboard  and the graphics tablet , such that image data, and other data, may be viewed, edited and processed.",{"@attributes":{"id":"h-0009","num":"0000"},"figref":"FIG. 3"},"User operations of the system shown in  are summarised in FIG. . At step  the user switches on the computer system. At step  application instructions for controlling the processing system  are installed if necessary. These instructions may be installed from a CDROM or DVD , or via a network, possibly the Internet . At step  the user interacts with the processing system  in such a way as to start the application instructions. At step  the user interacts with the application now running on the processing system . Said interaction may include the loading and saving of files, for instance the downloading of plug-in modules from the Internet , in order to provide additional functionality so as to enhance said interaction.","Files of various formats may be loaded and saved. Each file format has a specific set of instructions for loading and saving. Where a large number of formats are to be loaded and saved, instructions for all formats are not loaded simultaneously. Instead, instructions for format loading and\/or saving are only loaded when the user initiates an action that explicitly requires them. Instructions of this kind are sometimes referred to as plug-ins, reflecting the fact that a user can obtain such instructions and make them available to the main application according to his or her specific needs.","Plug-ins may provide a broad variety of functionality. In image processing, various types of image filtering, enhancement and modification can be performed by algorithms available as plug-ins. Furthermore, the main application instructions and additional plug-ins need not be written by the same engineer who wrote the main application. According to the prior art, they merely need to conform to the application's standard application programming interface.","At step  the user closes the application, and at step  the processing system  is switched off.",{"@attributes":{"id":"h-0010","num":"0000"},"figref":"FIG. 4"},"The processing system  shown in  is detailed in FIG. . The processing system comprises two central processing units  and  operating in parallel. Each of these processors is a MIPS R12000 manufactured by MIPS Technologies Incorporated, of Mountain View, Calif. Each of these processors  and  has a dedicated secondary cache memory  and  that facilitate per-CPU storage of frequently used instructions and data. Each CPU  and  further includes separate primary instruction and data cache memory circuits on the same chip, thereby facilitating a further level of processing improvement. A memory controller  provides a common connection between the processors  and  and a main memory . The main memory  comprises two gigabytes of dynamic RAM.","The memory controller  further facilitates connectivity between the aforementioned components of the processing system  and a high bandwidth non-blocking crossbar switch . The switch makes it possible to provide a direct high capacity connection between any of several attached circuits. These include a graphics card . The graphics card  generally receives instructions from the processors  and  to perform various types of graphical image rendering processes, resulting in images, clips and scenes being rendered in real time on the monitor . A high bandwidth SCSI bridge  provides an interface to the RAID , and also, optionally, to a digital tape device, for use as backup.","A second SCSI bridge  facilitates connection between the crossbar switch  and a DVD\/CDROM drive . The DVD drive provides a convenient way of receiving large quantities of instructions and data, and is typically used to install instructions for the processing system  onto a hard disk drive . Once installed, instructions located on the hard disk drive  may be fetched into main memory  and then executed by the processors  and . An input output (I\/O) bridge  provides an interface for the graphics tablet  and the keyboard , through which the user is able to provide instructions to the processing system .","Application instructions running on the processing system  are complex. Whether the application is a word processor, image editor or a digital film editor, the instructions that define the application's functionality typically run into hundreds of thousands, if not several millions, of individual binary instructions for the processors  and . Definition of these instructions is achieved by the use of a high level language such as C++, which is compiled into binary machine code compatible with the intended target processor. However, the use of a high level language, while reducing the effort required to define instructions, still does not solve the complexity problem entirely. As high level languages have become more sophisticated, this has allowed engineers to create more complex applications. The requirement of organisation still imposes a limit upon the complexity that application instructions can achieve. This complexity is minimised by splitting up an application into a large number of modules.",{"@attributes":{"id":"h-0011","num":"0000"},"figref":"FIG. 5"},"A particular difficulty encountered when combining modules in a single application is that of module compatibility. In , an illustration is shown of the relationships between modules that lead to this difficulty. An application  comprises an executable module  and several other modules  to . The modules  to  are dynamically loaded shared objects. Under Unix-type operating systems, such as Irix\u2122 and Linux\u2122, dynamically shared objects are usually abbreviated as dso's. They are also known simply as shared objects. Under Windows\u2122 operating systems, dso's are known as dynamically loaded libraries, or dll's. The executable module  defines the starting point of the application instructions , while the other modules  to  provide additional functionality that is invoked via the executable .","Each module  to  includes instructions , in the form of several functions , and data structures . There are two types of data that it is necessary to consider. The first type of data is user data, supplied usually from files on the hard disk , and which is to be created, manipulated and stored by the application. User data includes word processing files, text files, image files and so on. However, from an engineer's perspective a second type of data exists, which has an effect on the behaviour of the application, and the functions  within each module. These types of data are indicated at .","An example of this type of data is a mathematical function which is required to calculate a sine function at high speed. A look up table includes a number of pre-calculated results, thus reducing significantly the time required for the function to execute. Thus a data structure affects a function in a module. In some implementations the data structure is created when the application starts, by invoking an initialisation function prior to the start of the main application. In order for the application to function correctly, it is essential for the sine function to be initialised before the application begins. This is an example where data structures  within modules must be initialised.","A second requirement for initialisation is when hardware components of the processing system  are to be initialised. For example, the graphics card  has the potential to operate in a variety of display modes. The application may require a particular mode to operate. In order to do this, a graphics interface module  can be used to interrogate the graphics card  and determine which of its available modes is suitable for the application. The graphics card is then instructed to operate in the selected mode. Thereafter, many other modules will require information about the selected graphics mode in order to function correctly within the overall context of the application. This is an example of a requirement for hardware initialisation, which also results in data structures being initialised, that represent the behaviour and characteristics of the graphics card so that other modules may function in an appropriate way.","Various types of modules require initialisation, although it is possible that some modules will require none.",{"@attributes":{"id":"h-0012","num":"0000"},"figref":"FIG. 6"},"An edited example of the source code for a module  which requires initialisation at the start of an application is shown in  according to the invention. The source code is written in C++, but defines the actions of events that occur during the loading of the module which may be implemented in binary process instructions or any other appropriate instruction medium, and which may be stored on a hard disk drive , optical disk , or transferred as a stream over a network  to facilitate an initialisation process. Moreover, the example in  is heavily edited to convey the essence of the invention. Proper engineering practice known to those skilled in the art will result in these features being placed in several files, including header files, and a source code file dedicated to initialisation functionality alone, as will be appreciated by those skilled in the art.","In the source code listing, a registration object is declared at . Because this is declared outside any function or other type of structure, it is static, i.e. it exists from the time the module is loaded to the time the module is unloaded. At , a constructor for the template class invoked at  is defined. The constructor for a static object is called automatically by the loading process within step . Thus, even before the main application starts, the constructor for each module is called. Any instructions may be placed here in order to define the functionality of the registration object declared at .","An addDependency( ) function is called at , the arguments of which are contained in brackets and define an additional dependency for the present module. The constructor shown in this example has four lines of code, each defining a dependency. Thus, as a result of executing these four lines of code, an entry will have been processed with the meaning that the present module is dependent upon modules initialise, process, cache and continuation.","In order to implement the invention, a second function addContext( ) is called at . Its argument, contained in brackets, defines an additional slot  including one or a plurality of default values  in a context  administered by the process module and further defines a comparison function to define the equality of values  within the slot . The constructor shown in this example has one line of code declaring the context  within which the functionality of the present module will be called, the slot  within the context  within which the definition of the present modules data is declared and finally, the values  within said slot  which represents a set of default values of the output type when the functionality of the present module is invoked.","The operational functions of the example module  are subsequently declared at , which define the purpose of said present module upon completing the application start process of step . In the particular case of the executable module , a context object , cache object  and continuation object  are declared amongst said other dynamic functions and each defines a thread concurrently processed by processors  and  whilst a user interacts with the application at step .","For completeness in this example, code is also shown for the performInitialise( )  and performFinalize( ) . According to the present invention, only the executable module  needs to declare dynamic functions ,  and , whereas all other modules need to register a static register object  equipped with a register , slot  and values  and declare a context object .",{"@attributes":{"id":"h-0013","num":"0000"},"figref":"FIG. 7"},"The application start process of step  is further detailed in , wherein the data definition register of the present invention is generated. At step , an operating system running on the processing system  performs loading of all application modules. As a result of this process, each module is registered in a list, along with its dependencies which are processed and validated. According to the teachings of co-pending United Kingdom patent application No. 01 08 953.1 in the name of the present Assignee, which are incorporated herein for reference, an initialisation schedule is generated by sorting the modules in order of the number of their dependencies, according to which said modules are subsequently sequentially initialised. Thus, at step , the first module in the initialisation schedule is selected. When step  is first encountered, the application module  is loaded and, at step , the initialisation function  is called for the selected module. This has the result that the data  in the module, upon which correct module functionality depends, is initialised before other modules attempt to use the operational functions , . As a result of the initialisation function , every module's static objects are declared; their dependencies registered () and the module's register , slot  and values  thereof declared () and registered ().","At step , a question is asked as to whether the data definition the present module seeks to register already exists in the data definition register. When the first executable module  is initialised, there obviously exist no data definition register as yet and thus, the question asked a step  is answered negatively, whereby the data definition register is first generated, its data definition slot is incremented by a unit at step  and the slot  and default values  thereof are declared within the data definition register at step .","As more modules are initialised after the executable module , some of said subsequently initialised modules may perform various distinct functions on identically structured data. For example, a module engineered to provide a particularly fast method of previewing a three dimensional model composed of polygons will process the same data as another module specifically engineered to provide a particularly realistic method of equipping the polygons of said three-dimensional model with a texture, i.e. polygons. Thus, question  may also be answered positively, at which point control is directed to the next step .","At said step , a question is asked as to whether all the modules listed in the initialisation schedule have been initialised. Until all of said modules have been initialised, the question  is answered negatively, wherein control is returned to step  and the next application module in the initialisation schedule is initialised. Question  is eventually answered positively and, at step  a task processing sequence is loaded in main memory . Said task processing sequence is a data structure which details which specific modules loaded at step  and initialised at step  through to step  should be invoked and in which particular order so that the application loaded at step  and started at step  can provide the user's intended output.","For example, if the application is a database, the task processing sequence loaded at step  may comprise a report comprising data-mining and data-compiling queries consisting mainly of SQL statements. Accordingly, modules of the database application such as a boolean search module and a mathematical functions module would be invoked in order to firstly identify the relevant alpha-numerical data contained within the tables of said database, and subsequently process values of said alpha-numerical data with mathematical functions.","Alternatively, in the specialist field of digital video editing, the task processing sequence loaded at step  may be an edit decision list, also known to those skilled in the art as a process tree, which represents image or audio data processing tasks to be performed in a logical order in order to generate a composited frame or even a complete video sequence.","Upon performing the task processing sequence loading of step , the application processing starts at step .",{"@attributes":{"id":"h-0014","num":"0000"},"figref":"FIG. 8"},"As a result of the processing performed by the steps in , the contents of main memory  are as shown in FIG. . The operating system that performs the loading resides in main memory as indicated at . The application is also resident in main memory as indicated at . System data  includes data used by the operating system . In the example, the operating system is Irix\u2122, available from Silicon Graphics Inc., but the functionality of the present invention is equally extensible to alternative operating systems, such as Windows 2000\u2122 or Windows NT\u2122, available from the Microsoft Corporation of Redmond, or Linux\u2122, freely available under the terms of the GNU General Public License or, alternatively, from a variety of commercial distributors.","Application data  includes data loaded by default at step  for the application, including a data definition register , a task processing sequence  and possibly image data , audio data , API specific data  and eventually an error log .","The application  comprises a plurality of application modules, wherein said plurality of application modules is dynamic. That is, the application  comprises a finite number of application modules upon completing the processing performed by the steps in , but additional application modules, also known to those skilled in the art as plug-ins, may be dynamically loaded subsequently to the modules already loaded at the start of the application as the user interacts with the application  according to step .","The application  includes an executable module  which itself includes a process thread , a cache thread  hereinafter referred to as a cache manager, and a continuation thread , respective details about which will be provided further in the present embodiment. In addition to the executable module , application  includes a plurality of application modules , ,  and .",{"@attributes":{"id":"h-0015","num":"0000"},"figref":"FIG. 9"},"According to the invention, although the data definition register  is instantiated as a static object within main memory , its structure is dynamic and graphically illustrated in FIG. . As was previously explained, the first application module to be initialised according to steps  through to  is the executable module . Accordingly, as the question  is answered negatively, the initialisation of the executable module  effectively instantiates the data definition register  itself as its first slot  is instantiated as a result of the processing step .","Thereafter, the next application module is selected at step  which, in the example, is module . As module  provides a first specific functionality for input data, the structure of which defers substantially from the input data to be processed by the executable module , the initialisation process of module  detects that the corresponding data definition does not exist within data definition register  at step  and thus increments the data definition register slots by one unit , within which the slot  and default values  thereof are subsequently declared at step . Further data definition register slots ,  and eventually  are respectively instantiated by the intialisationed processing steps  to  applied to modules ,  and eventually module .",{"@attributes":{"id":"h-0016","num":"0000"},"figref":"FIG. 10"},"A simplified example of an edit decision list, or process tree, is shown in  as the task processing sequence  loaded into memory  at step .","Process trees generally consist of sequentially-linked processing nodes, each of which specifies a particular processing task required in order to eventually achieve an output scene , under the form of a composited frame or a video sequence. Traditionally, an output scene  will comprise both image data and audio data. Accordingly, the composited scene will thus require the output from an image-keying node  and the output of a sound mixing node . The image-keying node  calls on a plurality of further processing nodes to obtain all of the input data it requires to generate the desired image data, or sequence of composited frames. In the example, the desired output image data includes a plurality of frames within which a three-dimensional computer generated object is composited, as well as a background also consisting of a plurality of three-dimensional objects superimposed over a background texture.","The image-keying node  thus initially requires a sequence of frames , each frame of which is subsequently processed by a colour-correction processing node  and a motion tracking processing node  such that the composited three-dimensional object generated by three-dimensional modelling node , to which is applied a texture by the texturing node  and appropriate lighting by artificial light processing node  and finally appropriate scaling by scaling node , is seamlessly composited within the colour corrected sequence of frames .","In so far as the background is concerned, the image keying processing node  also requires a uniform texture from a texturing node , the functionality of which is similar to the texturing node , to which is applied the colour-correction functionality of a colour-correction processing node , the functionality of which is similar to the colour-correction processing node . The image-keying processing node  finally requires to overlay the plurality of simple three-dimensional objects generated from the three-dimensional modelling node , which are appropriately lighted by the artificial light processing node  and motion-tracked by means of the motion-tracking processing node  over the colour corrected-texture  before overlaying the composited frame sequence of frame  on top of the composited background.",{"@attributes":{"id":"h-0017","num":"0000"},"figref":"FIG. 11"},"Upon completing the loading of the process tree shown in  at step , the application processing starts at step  and the process thread  executes the first process tree traversal. The traversal of a process tree designates a processing cycle which takes place approximately every one thirtieth of a second and is shown in further detail in FIG. .","As was previously explained, a process tree is a task processing sequence, wherein input data is pulled by a parent node from its children nodes, i.e. processing nodes from which a processing node depends. In , the direction of processing is represented by a dotted line , which shows that sequential node processing traditionally starts from the leftmost branch of a process tree to its rightmost branch. For any given branch comprising processing nodes, the traversal moves from the topmost parent processing node  to the last child processing node  of a branch. The traversal then reverses direction and moves back () to the last parent node  of the branch, at which point the input data processed by the traversed children nodes is pulled by said parent node .","The traversal then considers whether there exists another branch  from said parent node , at which point the traversal again moves down the branch  until such time as it reaches the last child processing node and moves back () to parent node . The above processing method is applicable to every combination of parent and children nodes within a process tree and thus a processing cycle only finishes when the traversal eventually returns () to the topmost parent node , which is traditionally the output node of the process tree, at which point a second traversal begins and so on and so forth.",{"@attributes":{"id":"h-0018","num":"0000"},"figref":"FIG. 12"},"The traversal is an integral part of the application  at runtime in so far that it takes place from the moment the application processing is started at step  until such time as the application is closed at step , whether the user of system  actively interacts with the application by means of specifying new processing tasks or modifying existing processing tasks by means of keyboard  or touch tablet , or whether the user of system  does not provide any input for an unspecified duration. The various steps performed by application  at runtime are further detailed in FIG. .","It was previously explained that, upon starting the application processing of step  the process thread  of the executable module  executes the first traversal of the process tree . Consequently, at step , the process thread, or traversal, is shown as running and is also shown as including both the continuation thread  and the cache thread , which are concurrent sub-processes of said process thread.","At step , a question is asked as to whether the user interacting with application  requires a new application module . If the question  is answered positively, then the new module  is loaded at step , the processing details thereof will be further detailed in the present embodiment. Control is subsequently directed to step . Alternatively, if the question asked a step  is answered negatively, control is also directed to step , wherein another question is asked as to whether the user has interacted in such a way as to signify his intent to close the application . If the question asked at step  is answered positively, then control is directed to step , wherein the application is closed and system  is eventually switched off at step . Alternatively, if the question asked at step  is answered negatively, control is subsequently returned to the concurrently running process thread , continuation thread  and cache thread  of step .",{"@attributes":{"id":"h-0019","num":"0000"},"figref":"FIG. 13"},"The processing steps according to which the process thread  at step  traverses the task-processing sequence  illustrated in , are further detailed in FIG. .","At step , the process thread, or traversal, selects the next processing node within the process tree according to the processing direction . At step , a question is asked as to whether the selected node has new input data; if the question is answered negatively, then control is directed to step , which will be detailed further below in the present embodiment. Alternatively, the question asked at step  is answered positively and the context object  of the selected node accesses the data definition slot ,  in the context\/data definition register ,  at step .","At step , the process thread writes a data definition access signature bit in the data definition register in order to temporarily record which specific slot is accessed by the processing node within the data definition register at step . At step , a question is asked as to whether there already exists input data registered to the slot accessed in the data definition register which is different from the default slot data. If the question asked at step  is answered negatively, control is directed to step . Alternatively, if the question asked at step  is answered positively, the process thread pushes the portion of main memory  specifically affected to the slot accessed at step  and known to those skilled in the art as the memory stack at step , such that the new input data identified at step  can be registered within the data definition register as specific values to replace the last or current default values  at step . At step , the slot access signature bit which was written at step  is OR-ed such that the next slot access within the cycle can be accurately identified with the least possible resource usage.","Accordingly, at step  a question is asked as to whether there exists another processing node dependent upon the last node selected at step . If the question of step  is answered positively, then control is directed back to said step . Alternatively, the process thread  selects the last parent node accessed at step , thus representing the traversals change of direction . In accordance with the traversal description of , input data is pulled and processed at step , whereafter a question is asked at step  in order to determine if all the dependent nodes from the parent node selected at step  are processed. If the question asked at step  is answered negatively, i.e. if another branch  is identified, then control is directed back to step , wherein the next dependent node is selected. Alternatively, the memory stack which was pushed at step  is eventually popped, or unloaded, at step  and control is subsequently directed to step  and so on.",{"@attributes":{"id":"h-0020","num":"0000"},"figref":"FIG. 14"},"The continuation thread  operating at concurrently with the process thread  is further detailed in FIG. . The continuation thread is in effect a sub-process of the process thread , and its function is to ensure that for each processing node selected by the process thread, the operational functions within said processing node are processed in an accurately sequential order as specified by the module's main function .","As a traversal is generally accomplished within a thirtieth of a second, but the various processing nodes composing a process tree may require varying lengths of time in order to generate the output required by their parent node, often as not exceeding one thirtieth of a second, there exists a need to process every operational function of each processing node one at a time, i.e. process a fraction of the workload of each processing node at every traversal, instead of processing the totality of the main function  called by every processing node in turn.","Accordingly, as the process thread selects the next node in the traversal at step , the continuation thread  selects the next operational function within the application module represented by said selected node at step . At step , a question is asked as to whether the next selected function requires input data. If the question at step  is answered negatively, control is forwarded directly to step . Alternatively, the question at  is answered positively and the selected operational function accesses the cached data at step , whereafter the operational function of the selected node processes the data at step .","At step , the question is asked as to whether a processing error has occurred, i.e. the function selected at step  is unable to process the data registered within the data definition register at step  and instead processes the default input data values . If the question asked at step  is answered negatively, control is subsequently forwarded directly to step . If the question asked at step  is answered positively, however, the continuation manager logs the error detected at step  at step  within the error log . According to a preferred embodiment of the present invention, the continuation thread is configured to log which operational function of which module has experienced a control error, as well as the data definition register slot , input data registered at step  and default data .","Upon completing the error logging process of step , a question is asked at step  which considers whether there exists another operational function in the selected node left to be processed. If the question at step  is answered negatively, control is then returned to step  of the process thread, whereby the next node is selected, which enables the continuation manager to select the next function to be processed in said subsequently selected node. Alternatively, the question of step  is answered positively, whereby another question is asked as to whether there exists another dependent node for the process thread to select. If the question of step  is answered positively, control is subsequently returned to step  of the process thread. Alternatively, the continuation manager selects the next available function in the current node at step  in order to prune the remaining workload within the current traversal.",{"@attributes":{"id":"h-0021","num":"0000"},"figref":"FIG. 15"},"The cache thread  operating concurrently with the process thread and the continuation thread at step  is also a sub-process of the process thread . The function of the cache thread  is essentially to maximise the efficiency of the caching of input data required for the data processing a parent node. In order to achieve this functionality, the cache manager precisely determines which input data needs to be cached by a parent node from its children, utilising the least possible processing resources, to the exclusion of any other data which does not require caching.","As the process thread  OR-s the access signature bit for the currently selected node at step , the cache manager restores said O-Red access signature bit at step  in order to accurately identify which data definition register slot ,  was accessed by the currently selected node and thus at step  match the data definition contained therein with the corresponding input data identified at step . Upon successfully carrying out said matching operation at step , the new input data is returned from the cache at step .","At step  a question is asked as to whether the process thread has assessed that all dependent nodes have been processed at question . If the question at step  is answered negatively, the cache manager restores the next access signature bit OR-ed by the process thread at step  at step . Alternatively, the question of step  is answered positively, meaning that all the dependent nodes of the last parent node selected have been processed and the cache manager subsequently OR-s the input data currently held in the cache at step . The cache manager then again restores the next access signature bit OR-ed by the process thread at step  at step , and so on and so forth.",{"@attributes":{"id":"h-0022","num":"0000"},"figref":"FIG. 16"},"The process thread detailed in , continuation thread detailed in FIG.  and cache manager detailed in  of the present invention are concurrent processes which, when processed by processors  and  at runtime, instantiate a single processing pipeline, the benefit of which will be better appreciated by reference to a processing cycle according to the prior art shown in FIG. .","For the purpose of clarity, a simplified processing cycle  is shown, which includes a parent node  and three children nodes ,  and . It will be understood and apparent to those skilled in the art that the following detailed description of processing cycle  could equally apply to much more extended processing cycles, such as the traversal  shown at , which potentially includes hundreds of even thousands of combinations of parent and children nodes.","According to the prior art, in order to generate the output data  of the parent processing node , two operational functions  and  are sequentially called. The first function  called requires the output data  of a first child processing node  and the output data  of a second child processing node  as its input data. The second function  called requires the output data  of the third child processing node  as its input.","As the output data  and  are sequentially pulled by the function , after which the second function  pulls the output data , it can be appreciated that the parent node  has no knowledge of the data definition or, in essence, structure of the output data  prior to function  first attempting to process said output data  when pulled. Similarly, the parent node  has no knowledge of the data definition of output data  and the data definition of output data .","With reference to the sequential manner in which functions  and  pull data from the children nodes ,  and , there exists the potential for the output data  of the parent node  to be corrupted or even for either of function  or  to cease processing input data and thus potentially crash the application if any of the pulled data ,  and  does not conform to the data structure, or definition, required by said functions , . Said lack of conformity may arise from an engineers' mistake when implementing functionality to the application modules ,  or  or, alternatively, because an engineer has implemented said functionality and thus its output data outside the applications' standard API rules.",{"@attributes":{"id":"h-0023","num":"0000"},"figref":"FIG. 17"},"According to the present invention, however, a slot  and data default values  are declared within a context\/data definition register  by every single application module  to  of application  initialised according to the invention at step . Upon starting the application processing at step , the process thread  of the present invention enables parent and child processing modules to register (the input data ,  and  actual values of) within the data definition register , i.e. the scope of a parent node functionality, e.g. the processing cycle  of parent node .","The present invention maintains the scope of the parent's node functionality by means of the context object , which will be better understood by those skilled in the art with reference to a context function implemented according to the prior art. An edited example of the source code for a context function according to the prior art is shown in FIG. . The source code is written in C++ and is heavily edited to convey the essence of its functionality, as will be appreciated by those skilled in the art.","In the source code listing, a function is declared, such as for instance function . At , the line of code which will be compiled into machine-readable instructions that can be processed by processors ,  pushes the data definition register slot  according to step , thereby defining the duration of the scope  of function . Operational sub-functions  and  are subsequently called and processed within scope  until such time as the processing is completed at  and the memory stack is unloaded at  according to step , thereby terminating the scope .","As said memory stack is unloaded by the line of code , the data definition and actual values are unloaded within the data definition register such that the next function  cannot benefit from the data definition and values registered within scope .",{"@attributes":{"id":"h-0024","num":"0000"},"figref":"FIG. 18"},"The above limitation is overcome by the present invention with the implementation of the context object , which is further detailed in FIG. . An edited example of the source code is shown as written in C++ and is heavily edited to convey the essence of the invention. Proper engineering practice known to those skilled in the art will result in these features being placed in several files, including header files, as will be appreciated by those skilled in the art.","In the source code listing, a context object  is initially declared, within which a scope function  is first declared in order to define the duration of the scope  according to the invention. Conditional parameters  are subsequently implemented, which define instances according to which the slot  and values  should be pushed within the data definition register ,  according to step  by means of instructions .","As the duration of the scope  is initiated before any operational functions are called, such as functions , , the scope  remains active and maintains all of the changes of the data definition register ,  accessible to said subsequently called operational functions , . As the context object  is invoked at every parent processing module within a task processing sequence , each of said parent processing module eventually generates output data, at which point its operational functions ,  cease being invoked and the context object  terminates at , thereby unloading the memory stack according to step .",{"@attributes":{"id":"h-0025","num":"0000"},"figref":"FIG. 19"},"Changes within the data definition register ,  during a processing cycle such as processing cycle  are shown according to the invention in FIG. . The data definition register  is shown equipped with data definition register slots , each of which represents the data definition  and default values  thereof for every processing module  to  initialised for an application. Data definition register  also includes an access signature bit slice , wherein each data definition slot  within the data definition register is assigned an OR-ed signature bit .","As the processing cycle  is initiated, the next node  is selected according to step , the process thread determines that there exists new input data , the corresponding data definition  is accessed in the data definition register  and the corresponding access signature bit  is written according to step . There already exists a default values  registered within register  so the stack is shown as pushed according to step  and input data  is shown as registered within the register .","The next operational function of child node  is selected by the continuation manager according to step  and, as no input data is required, said first operational function processes its data at step . In the example, no processing error occurs and there exists no other function to be carried out by child node , thus the continuation thread will select the next node selected by the process thread at step , i.e. child module .","The access signature bit  is subsequently OR-ed according to step  at , whereby it is restored by the cache manager according to step , which matches the access signature bit  to the data definition  and input data , and thus writes said data  to the cache (not shown) of the parent node . At step , there exists another dependent node  and the process thread subsequently selects the next child module , whereby the cache manager awaits the next signature bit OR-ing.","In accordance with the method described thereabove, the data  of the child module  is registered within the data definition register  after the corresponding access signature bit  is written. Said access signature bit  is subsequently OR-ed at , whereby data  is also cached within the cache of parent node . Upon selecting the next child module , the process thread writes the access signature bit , data  is registered within the data definition register  and cached within the parent node cache. Said access signature bit  is eventually OR-ed at . Throughout processing cycle , the parent node  has full knowledge of the data definitions , default values  thereof and actual values  to  such that, should the processing of said data  to  result in a processing error at step  and subsequent error logging at step , functions  and  process the default data values  rather than the actual data  to , thus nullifying any corruption of the output data  of the parent node , or even fatal processing error by functions , .",{"@attributes":{"id":"h-0026","num":"0000"},"figref":"FIG. 20"},"The efficiency of the memory cache management implemented by the cache thread  of the present invention is further detailed in , whereby the contents of a memory cache  implemented either in secondary cache ,  or main memory  or a combination thereof are shown over a period of time equivalent to one processing cycle such as processing cycle .","It was previously explained that as the first access signature bit  is OR-ed at , it is restored by the cache manager according to step , whereby it enables the cache manager to match the corresponding data definition  with actual data, such as data . Upon completing said matching operation, the cache manager is configured to write said input data  within cache  and, commensurate with the sequential method of module traversal by the process thread , the cache manager sequentially writes input data  and  within cache  and it can be assessed that only the data required by the parent processing module  is cached, to the exclusion of any other irrelevant data. This enables said parent module  to accurately pull () the input data ,  and  from the cache  for processing, whereby the absence of irrelevant data improves processing time since the parent node  does not need to sieve said extraneous, irrelevant data.","In the example, all dependent modules ,  and  have been processed by the process thread  at  and said process thread unloads the memory stack at step , thereby invoking the cache manager to clear the cache at step , whereby the cache  is O-Red according to step  for the next processing cycle .",{"@attributes":{"id":"h-0027","num":"0000"},"figref":"FIG. 21"},"In the example field of digital video compositing, wherein task processing sequence  mostly takes the form of the process tree detailed in , the processing cycle  of which is detailed as traversal  to  in , the benefits of the present invention will be clearly appreciated by those skilled in the art. Indeed it is common for process trees to incorporate hundreds and potentially even thousands of logically-linked process nodes configured as parent processing nodes and children processing nodes, each of which symbolises the call on operational functions of application modules  to . In a preferred embodiment of the present invention, there results the ability for the user of a video editing terminal  to reliably obtain an output composited frame or sequence even if an operational function invoked malfunctions during a traversal. Moreover, there also results the ability for the user of the video editing terminal  to implement new tasks within the task processing sequence , thus potentially declaring new parent and children nodes, the operational functions of which need not be declared within the same API as the application  so long as each of said new modules initialises a data definition register slot  and default values  thereof within the data definition register .","The respective output data of each parent and children nodes  to  of the process tree detailed in  are graphically shown in  in order to illustrate the input data pulled and processed at step  within the context of the process thread, continuation thread and cache manager according to the present invention.","The traversal , i.e. process thread , initially traverses the process tree in accordance with the detailed explanation of , thus initially proceeds to the leftmost last child node , whereby an operational function of the child node  is invoked in order to fetch a frame  which depicts a real plane photographed in front of a blue background in order to facilitate subsequent keying processes. Node  is a parent node of node  and thus subsequently able to pull the frame  from the cache, and its colour correction operational function modifies the colour  of said frame by applying a processing rule to every pixel of said frame. According to the invention, it is known to parent node  that frame  comprises a finite number of pixels corresponding to the resolution of frame  as the definition  of the frame is an array of pixels and its default value  is for instance the default number of pixels in a NTSC frame.","The traversal ,  subsequently identifies the next branch depending from the parent node  and thus proceeds to node , whereby a three dimensional computer generated model  of a plane is generated by operational functions of said node . Its parent node  is subsequently able to pull said three-dimensional computer-generated model in order to apply a \u201csteel\u201d bitmap texture to each polygon of said three-dimensional model, which is a plane. It is known to node  that the three-dimensional model is composed of polygons defined by tessellating the smallest component of the model, which are vertices. The definition  of the three dimensional model is an array of polygons, and the default value is, say, a cube model. The actual value registered within the data definition register  by processing node  includes all of the three-dimensional co-ordinates of said vertices. Parent processing node  is therefore able to correctly apply the \u201csteel\u201d bitmap texture to the array of polygons  generated by node . According to the invention, if an operational function of node  was faulty and did not output an array of polygons defined in three-dimensional space which the operational function of node  could thus process so as to equip the three dimensional model  with a texture, then the parent node  would equip a cube with said steel bitmap texture, since it is the default value.","Processing node  subsequently applies an artificial lighting step  of the proces thread, whereby the next node is selected, which algorithm at  to the textured three-dimensional model and processing node  can subsequently scale the lighted (), textured () three-dimensional model  at . The parent node  of nodes  and  subsequently pulls the data of said nodes according to step  and calls an operational function designed to animate the real plane in the frame  and the composited plane  in relation to one another within a same three dimensional volume , known to the those skilled in the art as motion-tracking.","With respect to the topmost graphical parent node  within the process tree, two further branches respectively defined by nodes ,  and  to  have to be processed before it pulls the input data and processes said data itself. A \u201csky\u201d bitmap texture  is thus generated by node  which is subsequently colour-corrected at parent node  using the same operational function as was invoked by colour-correction processing node  to process the frame .","Similarly, a computer-generated three-dimensional \u201cclouds\u201d model  is generated by node  utilising potentially the same operational function as was invoked by node  to generate the \u201cplane\u201d three-dimensional model. The three-dimensional model  is subsequently lit () at parent node  using potentially the same lighting algorithm of the operational function called at node . The lit () three-dimensional model  is subsequently motion-tracked () at processing node  utilising the same operational functions invoked by the processing node  in order to eventually match the motion of the real and composited planes with the composited clouds.","Upon completing the processing  at node , the parent node  is thus able to pull all of the input data  to  and process it in order to generate a composite frame , within which two planes appear superimposed over a sky and clouds.",{"@attributes":{"id":"h-0028","num":"0000"},"figref":"FIG. 22"},"The evolution of the data definition register  of the parent node  maintained by the process thread  during the traversal  further detailed in  is graphically illustrated in FIG. .","For the purpose of clarity, the data definition register slots  to  are arranged in the same order as the sequential order in which parent and children nodes  to  are traversed. Thus, data definition register slot  contains data definition and values relevant to the chroma-keying functionality of parent node ; data definition register slot  contains data definition and default values relevant to motion tracking node ; data definition register slot  contains data definition and default values relevant to colour-keying processing node ; slot  contains data definition and default values pertaining to the frame-acquisition processing node ; slot  contains data definition and values pertaining to the scaling processing node ; slot  contains data definition and values pertaining to the artificial light processing node ; slot  contains data definition and default values pertaining to the texture processing node ; slot  contains data definition and default values relevant to the three dimensional modelling processing node  and slot  contains data definition and default values particularly relevant to the sound processing node .","In accordance with the processing steps shown in , the traversal  initially references the input data of the chroma-keying node  at , thereby pushing the default values  up within the memory stack. The process thread next accesses the motion tracking node , whereby motion tracking data  is referenced within the data definition register , and the corresponding default values  are also pushed within the memory stack, as previously. In accordance with the traversal previously detailed, colour correction actual data , frame data , scaling data , computer generated artificial lighting , bitmap texture data  and three-dimensional model data  are similarly sequentially referenced within the data definition register, whereby their respective default values are similarly pushed in their respective stacks.","When the process thread selects the colour correction processing node , the question asked at step  is answered positively and, in a manner similar to the previous registrations of actual data  to , colour control actual data  is similarly pushed up in the colour control stack of the data definition register in order to register the new colour control data  particularly relevant to colour correction processing node . Thereafter, actual texture data , actual motion tracking data , actual artificial lighting data  and actual three dimensional model data  are respectively pushed by new texture data , new motion tracking data , new artificial lighting data  and new three dimensional model data .","Upon image keying processing node  pulling all of the input data  to  in order to generate output composite frame , the data definition register  is OR-ed, whereby actual input data  to  are unregistered and data definition register  is returned to its original configuration ().",{"@attributes":{"id":"h-0029","num":"0000"},"figref":"FIG. 23"},"It was previously explained that the data definition register  is a dynamic structure, as it must extend its functionality to occasions wherein the user of processing terminal  requires a new application module to be loaded at step  when interacting with the application at step . Said step  is further detailed in FIG. .","According to a preferred embodiment of the present invention, within the course of the interaction with application , the user eventually performs an action at step  which requires the loading of one or a plurality of processing modules which were not initialised at step . Upon performing this specific action, the operating system  loads the new processing modules in accordance with step  at step , whereby the static objects of said new modules are declared and the dependencies and context thereof registered in accordance with processing steps  to . If the operational functions of the new modules are configured to process data, the definition of which is already registered within the data definition register , there is no need to re-register an identical data definition and default values thereof within the register. If, however, the operational functions of the new modules are configured to process data, the definition of which does not yet exist within the register, then in accordance with steps  to , the data definition register slots  to  are incremented by a unit, eventually resulting in the data definition register being updated at step .","The processing of the new module eventually starts at step  when the initialisation process is complete.",{"@attributes":{"id":"h-0030","num":"0000"},"figref":"FIG. 24"},"The process tree detailed in  is shown in , including a new processing node , the operational function of which is to apply a deformation matrix to the artificially lit and textured three dimensional model  to simulate a heat haze effect.","As the first traversal  of the process tree shown in  is completed according to the invention, the user can ascertain from the output composite frame  that the three-dimensional model-based plane within the frame  appears behind the real plane from frame  and thus, in order to improve the realism of the shot, should appear at least partially deformed by the heat haze of the exhaust of the real plane. In the example, application  does not include any application module, the operational function of which allows the user to implement this effect within the composited frame . The user of terminal  thus connects to the internet  by means of a modem connection (not shown) to the ISP  in order to identify then download an application module which features this particular functionality from the engineer's terminal .","Upon completing said download operation and initialising a processing module hence referred to as a deform module  according to step , the user of terminal  can implement a deform node  as a child of the scaling node  and the new parent of nodes ,  and .","In effect, the scaling operational function invoked by the scaling node  must now process a deformed (), lit () and textured () three-dimensional model . As a result of the concurrent processing accomplished by the process thread , continuation thread  and cache manager , the input data of the deform node  is registered within the data definition register  and the default data value is zero, resulting in a non-deformation of the data submitted to said deform node . Therefore, even if the deformation operational function, which is the specific functionality of the application module  downloaded by the user, is not properly implemented or malfunctions, the scaling node  is still able to process a non-deformed, lit and textured three dimensional model.",{"@attributes":{"id":"h-0031","num":"0000"},"figref":"FIG. 25"},"The evolution of the data definition register  during the traversal  shown in  is graphically represented in , including a new data definition register slot  including a default value of zero instantiated when the deform processing module  is initialised.","At the onset of the next traversal of the process tree, the data definition register  is shown which includes an additional slot  implemented as a result of the incrementation of step . Said slot  defines the \u201cdeform\u201d data and a default value of zero, as previously explained. As the traversal progresses according to the detailed description provided at , the process thread eventually selects the deform node  at step , whereby the node's actual data  is registered to the data definition register, thus pushing the data definition and value up in this stack irrespective of the fact that the deform slot  is not contiguous with the respective data definition register slots of the previous node or the subsequent node.","The traversal subsequently progresses, whereby the process thread selects the lighting node  and its actual data  is registered within the data definition register and so on and so forth until such time as the data definition register is OR-ed at ."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 4","FIG. 2"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 7","FIGS. 5 and 6"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 8","FIG. 4","FIG. 7"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 9","FIG. 8"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 10","FIG. 8"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 11","FIG. 10"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 12","FIG. 8"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 13","FIG. 12"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 14","FIG. 12"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 15","FIG. 12"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 17","FIG. 16"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 18","FIG. 17"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 19","FIG. 16","FIG. 13","FIG. 15"],"b":"14"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 20","FIG. 15","FIG. 19"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 21","FIG. 10"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 22","FIG. 21"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 23","FIG. 8"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 24","FIG. 10","FIG. 23"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 25","FIG. 22"],"b":"24"}]},"DETDESC":[{},{}]}
