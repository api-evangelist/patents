---
title: System and method for updating installation components using an installation component delta patch in a networked environment
abstract: A system and method for managing the installation of files on a computing device are provided. A client computing device obtains installation information identifying a version of a baseline installation component stored on the client computing device. The installation information also includes an installation component delta patch that is merged with the baseline installation component to generate an updated installation component. The updated installation component is utilized to install one or more files on the client computing device. Upon completion of the installation, the updated installation component can be deleted.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07546594&OS=07546594&RS=07546594
owner: Microsoft Corporation
number: 07546594
owner_city: Redmond
owner_country: US
publication_date: 20031215
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["The present invention relates to software and computer networks and, in particular, the present invention relates to a system and method for managing and communicating software updates.","Most commercially available software products undergo a continual revision process to repair or upgrade features and\/or functions. Each revision of a software product or component may require the addition of new files and\/or the replacement of existing files with files of newer versions. Once a vendor has isolated a software product problem and created a solution for the problem, it would want to put that fix into an update and make the update widely available to the customers. Software vendors have a business incentive to distribute software updates to customers as quickly and trouble-free as possible.","The Internet provides an important channel for customers to obtain the latest updates for software products. The explosive growth of Internet usage has created a common expectation by customers that software products and updates be provided online for downloading. It is also in the interest of software vendors to promote the use of the Internet to distribute updates, because it reduces their costs and allows customers to obtain the fix for an identified problem as soon as the fix is made available for downloading. The vendor sites on the Internet can be designed to make it very simple to discover and locate update files for an application. The technical aspects of file download have mostly disappeared from the user's view, and are now typically handled by the operating system.","In a conventional approach, a software vendor constructs a software update as a \u201cpackage\u201d for download. This package is typically a self-extracting executable file with the setup program and each of the product's updated files embedded and compressed to make the package smaller. The size of the package is generally the sum of the compressed sizes of each changed file, plus the size of the extraction code itself. Upon execution, the package extracts each of the contained files to a temporary location, then starts the setup program to install each file to a proper location in the system's directory. Files that are shipped in a compressed form are decompressed as they are installed. Any existing file of the same name in the same location would simply be overwritten by the replacement file.","Even though the Internet makes wide and quick distribution of software updates possible, the limited bandwidth of network transmission has caused problems. The sheer sizes of common software applications have caused the download sizes of updates to become unreasonably large. Usually a multitude of fixes for a variety of problems of a product will be grouped into an update. If a vendor updates a software product on a regular basis, the download size of the update package will continue to grow, because the vendor cannot omit files under the assumption that the user already has those files from earlier updates. Because the update package combines a number of whole files, it may be quite large, even when the files are compressed. Sometimes, even on the fastest modem connections, the bandwidth efficiency of the download is decreased.","The time-consuming aspect of the conventional downloading process is, of course, undesirable. In some cases, customers pay long-distance or connection time charges during these file downloads. Any reductions in connection time will reduce the direct monetary cost for these customers. The vendors typically also have some distinguishable costs relating to the sizes of downloads they provide, so reducing the sizes may give them direct monetary benefits as well. Reducing the sizes of downloads will increase their available network bandwidth, allowing them to serve more customers with existing network server equipment.","The long time it takes to download a large update also makes the downloading process more vulnerable to various network connection problems. There are a number of reasons why an Internet session might be disconnected prematurely, including telephone line noise, call-waiting signals, and unintentional commands. Some Internet service providers enforce a connection time limit, limiting the amount of time the user can be on-line in a single session. If the user is downloading a large file when the network connection is cut off, he or she may have to start over. Most common operating systems and file transfer protocols do not allow the file transfer to be resumed, so any interim progress would be lost, and the transfer would have to be restarted. The opportunities for failure are so numerous that many users find it nearly impossible to obtain the update online. If the size of an update package is too large, users may never be able to completely download it.","One attempt to reduce the size of software updates and increase bandwidth efficiency relates to the use of delta patches, or binary patches. One skilled in the relevant art will appreciate that a delta patch corresponds to specialized software code that modifies an existing file when executed by a computing device. Because the delta patch includes specialized software code, a unique delta patch is required for each unique version of a file. As applied to software updates, a software update service can transmit a smaller sized update delta patch instead of transmitting a complete, updated file. The updated delta patch is then utilized to modify the existing file into the updated file.","Although the update delta patches can potentially reduce the amount of data required to update files, current approaches to delta patching are deficient in managing the selection of applicable delta files in situations where a large number of versions of a file exist. Because a unique delta patch is required for each version of a file, typical software update systems can often require hundreds, if not thousands, of unique delta patches to correspond to each unique version of a file. In one approach, some update services supporting delta patching transmit all possible delta patches to a client computing device. However, this approach typically increases the amount of data required to implement the software update as the number of possible update delta patches increase. Accordingly, the number of potentially applicable delta patches can quickly grow to the same size as the complete updated file. In another approach, a networked update software service scans a client machine to select which delta patch may be applicable for each client machine. Although this reduces the amount of delta patch information that is transmitted, it requires additional logic on the software update service to scan the client machines and select an applicable delta patch. The use of the additional logic increases the system resources that must be provided by the service. Further, this approach typically prevents the utilization of network caching, such as is typically achieved by traditional Web servers.","In addition to the above described shortcomings, existing systems are unable to deliver certain types of software updates, such as hardware drivers. As known in the art, specialized software updates, such as those that apply to hardware drivers, are difficult to provide to users on a large-scale distribution because most specialized software updates will only work on client computers with specific hardware. In most cases, for example, if a client computer obtains an incompatible hardware driver upgrade, the installation of the driver upgrade may cause a fatal error, or even prevent the computer from operating.","As will be readily understood from the foregoing, there is a need for a system and method having improved communication of software updates between a server and a number of clients. In addition, there exists a need for a software update system and method having improved mechanisms for allowing update services to target specific types of clients when delivering specialized updates.","A system and method for managing the installation of files on a computing device are provided. A client computing device obtains installation information identifying a version of a baseline installation component stored on the client computing device. The installation information also includes an installation component delta patch that is merged with the baseline installation component to generate an updated installation component. The updated installation component is utilized to install one or more files on the client computing device. Upon completion of the installation, the updated installation component can be deleted.","In accordance with an aspect of the present invention, a method for managing the installation of files on the client computing device is provided. In accordance with the method, a computing device obtains installation information identifying a required baseline installation component for installing one or more files on the client computing device. The computing device selects a baseline installation component stored on the client computing device. The computing device obtains an installation component delta patch from the installation information and merges the installation component delta patch from the installation information and the selected baseline installation component. The computing device installs one or more files on the client computing device utilizing the merged installation component.","In accordance with a further aspect of the present invention, a method for managing the installation of files on the client computing device is provided. In accordance with the method, a computing device obtains a package including information identifying a required baseline installation component for installing one or more files on the client computing device. The computing device identifies a baseline installation component stored on the client computing device and obtains an installation component delta patch from the package. The computing devices merges the installation component delta patch from the package and the identified baseline installation component and installs one or more files on the client computing device utilizing the merged installation component. The computing device also deletes the merged installation component upon installing the one or more files on the client computing device.","Generally described, the present invention is directed to a system and method for managing software updates. More specifically, the present invention is directed to a system and method for facilitating the selection and implementation of software updates while minimizing the bandwidth and processing resources required to select and implement the software updates. In accordance with the present invention software updates can correspond to updates for specific software applications or operating systems. Further, software updates can include software drivers or updates to firmware, such as system BIOS. In accordance with an aspect of the present invention, a system and component architecture for processing the software updates is provided. In accordance with another aspect of the present invention, an update protocol and interface to facilitate the authorization and synchronization of client machines with an update service is provided. In accordance with a further aspect of the present invention, a method for updating an installation component and various installed files utilizing delta patches is provided. One skilled in the relevant art will appreciate, however, that additional aspects of the present invention may also be provided in the present application. Further, one skilled in the relevant art will appreciate that each identified aspect may be considered individually or as part of common inventive aspect.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1","b":["100","100","100","110","120","130","120","110","120","130"]},"The client computing device , the update service , and the external update provider  electronically communicate via a network . The network may be a local area network (LAN) or a larger network, such as a wide area network (WAN) or the Internet. By the use of generally known software, the software update system  may be configured to exchange documents, commands, and other known types of information between the client computing device  and the servers , ,  and  of the update service . As will be appreciated by those skilled in the art and others, the software update system  shown in  is a simplified example of one suitable system for implementing the present invention and that the present invention is not limited to this example.","As will be described in more detail below, one embodiment the update service  comprises a number of servers. As shown in , the update service  includes an update server  for managing the overall processes of the update service  and coordinating processes of the servers , ,  and  of the update service . The authorization server  generates authorization cookies as requested by the client and, in turn, the authorization cookies are used to generate server cookies, that allow client computers to access updates provided by the update service . The metadata server  provides general information regarding the updates provided by the update service . The metadata server  allows the system of the present invention to identify specific updates for a specific type of client computer or a specific group of client computers. The download server  provides one or more software components for delivering data files associated with software updates provided by the update service .","The external update provider  may include one or more servers that distribute software updates. The external update provider  may be associated with an entity that provides software, software updates, or other data that is to be distributed to groups of client computers. For example, the external update provider  may be associated with a third party software developer desiring to use the update service  to distribute updates for one or more software applications. In another example, the external update provider  may be associated with software update system .","The client computing device  may be any computing device that stores and executes software applications . The client computing device  may be formed from any one of a number of different computer products including, but not limited to, personal computers (PCs), personal digital assistants (PDAs), mobile telephones, two-way pagers, etc. As will be appreciated by those of ordinary skill in the art or others, the architecture of the client computing device  may take on any suitable form. For example, the client computing device  may include a network interface for providing communication with the network . The network interface may be configured for use with any wired or wireless network connection, and may be used with any suitable communication protocol, such as the TCP\/IP protocol. In addition, the client computing device  may include a processing unit, a display, and a memory unit. The memory unit may store the program code necessary for operating the client computing device , such as an operating system . In addition, the memory unit stores an update management component  for controlling and executing processes of the present invention.","The software update system  stores software programs that, when executed, implement the present invention. When executed, the software update system  stores, manages, and selectively communicates software updates. As described more fully below, among many other benefits, the present invention provides a mechanism for defining and selecting target groups of client computing devices that are eligible to receive software updates. The present invention also provides an improved mechanism for downloading data files associated with software updates.","For purposes of illustrating the present invention, a detailed description of a working example of the present invention is provided. In describing the working example, reference is made to software updates that may refer to a specific upgrade of a software application, e.g., an upgrade of a media player version 6.0 to media player version 7.0. As will be appreciated by those of ordinary skill in the art, such a software update may include the communication and installation of a number of data files associated with the software update. Thus, for purposes of illustrating the present invention, a distinction is made between a software update and an individual data file containing a software update.","With reference now to , an illustrative interaction between the components of the software update system  to update one or more files on the client computing device  will be described. With reference to , the software update service is initiated by the transmission of software update information by one or more external update providers . As described above, the external update providers  may be associated with software update system . Alternatively, the software update information may be transmitted by third-party external update providers . In an illustrative embodiment of the present invention, the software update information can include software code utilized to update a file, software code utilized to replace a file, various rules for determining the applicability of the software updates, and\/or display information describing the software update. The transmission of the software update information may be completed at any time and does not have to be contemporaneous with the initiation of the other illustrated software update component interactions.","Upon receipt of the software update information from the external update provider , the update service  generates one or more pieces of data to facilitate the transmission of update information. The data can include a patch storage file that corresponds to a set of software delta patches for updating different versions of a file. The data can also include a patch storage manifest that corresponds to an index mapping particular file versions to a corresponding delta found in the patch storage file. The data can further include a self-extracting file that corresponds to information the update agent will utilize to request and install specific software update data, as will be described in greater detail below. One skilled in the relevant art will appreciate that the generation of the patch storage file, patch storage manifest, and the self-extracting files may be completed at any time and does not have to be contemporaneously with the other illustrated component interactions.","To initiate the transmission of software update information to clients, a client computing device  initiates an authentication request to the update service . In an illustrative embodiment of the present invention, the authentication request corresponds to an update protocol interaction between the client computing device  and the update service , which will be described in greater detail below. Upon completion of the authentication, the update service  transmits an authentication cookie to the client computing device . With reference now to , the authenticated client computing device  then initiates the synchronization of the available updates with the update server . In an illustrative embodiment of the present invention, the synchronization request also corresponds to the update protocol interaction between the client computing device  and the update service , which will be described in greater detail below. Upon the completion of the synchronization, the client computing device  receives the information of all applicable software updates and information describing the updates. However, in an illustrative embodiment of the present invention, no software code to instantiate the update has been downloaded.","With continued reference to , at sometime during the update process, a selection of the updates to be installed is received. In an illustrative embodiment of the present invention, a user may be presented with software update information received during synchronization and asked to select an appropriate update. Alternatively, the client computing device  may be configured in a manner to automatically select all applicable software updates. Further, the client computing device  may also have some rules that allow it to automatically select a subset of the available software updates. Still further, a user may initiate a selection of an update by communicating with the update service , such as via an internet Web page.","With reference now to , the update management component  instantiates an update agent  on the client computing device , if an update agent is not already present. The update agent  then requests the transmission of a software update information package, such as self-extracting file. The update agent  receives the self-extracting file and performs any updates to the installer, as will be described below. Further, the update agent  can request any missing or corrupted information from the update service .","With reference now to , once the update agent  receives the software update information package, the update agent  performs an inventory of the files that are installed on the client computing device . Based on a comparison of the inventory and the software update information package, the update agent  determines which delta patch, or other update information, will be required to complete the selected updates. The update agent  then transmits a request for specific delta updates. In one embodiment of the present invention, the request for software updates may correspond to a direct request transmitted via a direct network connection, which will be referred to as a manual update. In another embodiment of the present invention, the request for software updates may be a background request that is transmitted without requiring overt user action. This embodiment will be referred to as an automatic update.","In an illustrative embodiment of the present invention, if the software update corresponds to a delta patch, the update agent  transmits a request to the update service  that identifies the particular delta patch identified by the patch storage manifest. Alternatively, in the event that a delta patch is unavailable or if several delta patches have failed, the update agent  can initiate a fallback procedure. The fallback procedure can include a request for the transmission of a complete copy of the entire updated file from the patch storage file. The fallback procedure can also include a request for the transmission of a complete copy of the entire updated file from in self-contained package.","In an illustrative embodiment of the present invention, the download server  of the update service  can directly process the software update request from the update agent . Alternatively, the request can also be processed by any number of additional external download servers such as traditional Web servers that have either received the requested update delta patches from the update service . For example, a corporation may utilize an internal server to update client machines. Additionally, the request can be processed by external download servers in which some, or all, of the update delta patches are cached in processing previous requests. Accordingly, in this embodiment, the download can be distributed to a number of additional download servers capable of servicing hyper text transfer protocol (\u201cHTTP\u201d) data requests.","With reference to , once the software update information is received, the update agent  merges the delta patch with the installed file to generate an updated file. Additionally, the update agent  can validate whether the merger successfully updated the appropriate file. As described above, if a delta patch cannot be validated, the update agent  may request the delta patch again or request an entire updated file after a number of failures. Once the update agent  obtains the validated and update file, the file is installed on the client computing device .",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 7","FIG. 8"],"b":["700","110","120","702","120","110"]},"At block , the client computer  and the software update service  synchronize update information. In an illustrative embodiment of the present invention, the software update service  transmits metadata describing specific software updates to the client computing device . The metadata contains information describing the available software updates to allow a user to select one or more updates for installation. A more detailed description of the synchronization process will be described below with regard to . At block , the client computing device  obtains a selection of applicable updates to download. In an illustrative embodiment of the present invention, the selection of applicable updates can correspond to the utilization of a number of unique user interfaces to facilitate user selections. The selection of user interfaces will be described in greater detail with regard to .","At block , the client computing device  processes the user selection of applicable software updates and interfaces with the software update service  to request specific update information. In an illustrative embodiment of the present invention, the client computing device  selects and requests one or more applicable update delta patches. The update agent  on the client computing device  can then process the requested data to implement the selected software update. At block , the routine  terminates.","With reference to , a protocol diagram  for authorizing access to client computing devices  and corresponding to block  () will now be described. In an illustrative embodiment of the present invention, the software update service  utilizes an extensible targeting mechanism to control client computing device  access to updates and other software. The software update service  incorporates a mechanism that associates specific software updates with one or more target groups of client computing devices . For example, the software update service  may limit access of a specific hardware driver update to a particular brand of client computing devices  having a specific hardware device. In such an example, the software update service  may define a target group of client computing devices  having a particular brand name and a specific hardware device and limit the transmission of the particular software download to the target group.","In an illustrative embodiment of the present invention, the extensible targeting mechanism is facilitated by the use of software components (\u201cauthorization plug-ins\u201d) that define a client computing device's membership to one or more target groups. The presence of an authorization plug-in on a client computing device  defines whether the client computing device belongs to the specific target group of the authorization plug-in. A target group, for example, may include all computers having a valid product identification (\u201cPID\u201d) number for a particular software application. In such an example, as described in more detail below with respect to , an authorization plug-in  may be installed in the client to read a PID from a memory module of the client computing device and pass the obtained PID to a corresponding PID server plug-in . The corresponding PID plug-in, also referred to herein as PID validator , utilizes one or more methods to determine if the received PID is valid. Once it is determined that the PID stored on the client computing device  is valid, the server generates a server cookie which indicates that the client computing device  is a member of a target group having a valid PID. In another example, a target group may include client computing devices that are designated as beta test computers.","In an illustrative embodiment of the present invention, the authorization server  of the software update service  contains a number of server authorization plug-ins that define a set of target groups of client computing devices that the authorization server will recognize. Each server authorization plug-in contains components for communicating data with a corresponding client authorization plug-in stored on a client computing device . In a similar manner, each client computing device  includes one or more client authorization plug-ins that identifies the target groups to which the client belongs. In an illustrative embodiment of the present invention, the client authorization plug-ins can be installed in each client computing device during the installation or upgrade of a software application, such as the installation or upgrade of an operating system. Additionally, the server authorization plug-ins may be dynamically installed or removed by an administrator desiring to control the access to software updates. The authorization plug-ins stored on the client computing device  and the authorization server  can be an actual software plug-in, or the authorization plug-ins can be hard coded into dynamically linked libraries.","As shown in , the authorization server  contains three example server authorization plug-ins: (1) a first server authorization plug-in  defining a target group that includes all computers (hereinafter the \u201cAll Computers target group\u201d); (2) a second server authorization plug-in  defining a target group that includes computers having a valid PID (hereinafter the \u201cPID target group\u201d); and (3) a third server authorization plug-in  defining a target group that includes beta test computers (hereinafter the \u201cbeta target group\u201d). Also shown in , the client computing device  contains two client authorization plug-ins: (1) a first client authorization plug-in  indicating that the client computing device  is a member of the All Computers target group; and (2) a second client authorization plug-in  indicating that the client computing device  is a member of the PID target group. In this example, the client computing device  does not contain an authorization plug-in indicating that it is a member of the beta target group. As will be appreciated by those of ordinary skill in the art, each client authorization plug-in  and  may be configured to execute one or more functions on the client computing device  to assist the validation process. For instance, the second client authorization plug-in  may be configured to examine the memory of the client computing device  to verify or obtain a PID for an installed software application.","As shown in , the authorization sub-routine  begins when the client computing device  communicates a configuration request  to the authorization server . In an illustrative embodiment of the present invention, the configuration request  is formed from any suitable software component configured to obtain information describing the authorization plug-ins stored on the authorization server . As will be appreciated by those skilled in the art, the configuration request  may utilize a known method referred to as \u201cGetConfig.\u201d In response to receiving the configuration request , the authorization server  communicates a configuration response , which includes information identifying all of the authorization plug-ins stored on the authorization server . In one embodiment, the configuration response  includes an array of strings that identifies and describes all authorization plug-ins stored on the authorization server . In the present example, the configuration response  includes information that identifies the first server authorization plug-in , the second server authorization plug-in , and the third server authorization plug-in .","At block , the client computing device  generates one or more authorization cookies in response to receiving the configuration response . In the process of block , the client computing device  generates an authorization cookie for each pair of matching client and server authorization plug-ins. Thus, in the present example, the first client authorization plug-in  generates a first authorization cookie associated with the All Computers target group because the first client authorization plug-in  and the first server authorization plug-in  are both associated with the All Computers target group. In addition, the second client authorization plug-in  generates a second authorization cookie associated with the PID target group because the second client authorization plug-in  and the second server authorization plug-in  are both associated with the PID target group. A third authorization cookie is not generated since the client computing device  does not have an authorization plug-in indicating that it is a member of the beta target group.","As will also be appreciated by those skilled in the art, one implementation of the process of block  may include the use of a generally known software method referred to in the art as \u201cGetAuthCookie.\u201d It will also be appreciated that the generation of each authorization cookie may involve additional processing. For instance, the second client authorization plug in  may be configured to examine information stored in the client's system registry to retrieve a PID and include the PID in the authorization cookie. In other examples, the process of block  may include processes for communicating with other computers or devices. For instance, a client authorization plug-in may communicate with a device, such as a sound card, scanner, video card, etc., to obtain the make and model of the device. In other non-limiting examples, a client authorization plug-in may communicate with a security device, such as a fingerprint reader, to obtain information describing a user.","In general, a client authorization plug-in may read configuration information from any component of the client computing device  or any other computing device communicatively connected to the client computing device . In other examples, a client authorization plug-in may be configured to utilize one or more public or private application programming interfaces (APIs) to gather and encrypt information from the client that will be validated by the corresponding server plug-in. In such examples, PID validator plug-in  uses a private API to encrypt the client's PID to pass the encrypted PID to the server for decryption and validation. In other embodiments, other client authorization plug-ins may utilize biometric measurements, such as fingerprint readers or voice prints, to construct an authorization cookie to be passed to the server for validation. In yet another example, a client authorization plug-in may call a Web service or any other service to communicate authorization credentials or any other type of data to the authorization server .","In an illustrative embodiment of the present invention, each authorization cookie includes a string that identifies an associated target group. For example, a string may indicate that a particular authorization cookie is associated with the PID target group. Each authorization cookie also includes a data section for communicating data between a client and a server. For example, an authorization cookie associated with the PID target group may have a data section that contains an actual PID. As will be appreciated by those of ordinary skill in the art, the data section can contain any type of data that is stored in any format, such as a byte array. For example, if plug-ins on the client and the server require the communication of public and private keys, such data can be encrypted in the data section of one or more authorization cookies.","Once the client computing device  generates an authorization cookie for each pair of corresponding client and server authorization plug-ins, the client computing device communicates the generated authorization cookies to the authorization server . As shown in , the client computing device  communicates the authorization cookies in a cookie request . The cookie request  includes any suitable format for communicating an array of the authorization cookies generated in the process of block . One implementation of this part of the authorization method  may include the use of a generally known software method referred to in the art as \u201cGetCookie.\u201d","In one embodiment, the cookie request  also includes other authorization server cookies stored in the memory of the client computing device . As will become more readily understood from the following description, the memory of the client computing device  may store old authorization server cookies that were created in previous executions of the authorization routine . By providing the stored authorization server cookies in the cookie request , the client computing device  will be able to maintain its access privileges that were granted in the previous executions of the authorization sub-routine . In the present example, since there are no authorization server cookies stored in the client, the cookie request  includes the first authorization cookie associated with the All Computers target group and the second authorization cookie associated with the PID target group.","Next, as shown in block , in response to receiving the cookie request , the authorization server  generates a server cookie. In one embodiment, for each of the received authorization cookies, a call is made to an appropriate server authorization plug-in to generate server cookie data. The server cookie data generated by each server authorization plug-in includes an identifier for each target group identified in the received authorization cookies. In the present example, since the cookie request  includes the first authorization cookie associated with the All Computers target group and the second authorization cookie associated with the PID target group, the authorization server  generates server cookie data containing an identifier for these respective target groups. On the authorization server , the server cookie data is then combined with data of old server cookies, if an old server cookie is received in the cookie request , to generate a new server cookie. In one embodiment, the new server cookie is encrypted by the use of a publically available encryption method, such as Triple DES.","In an illustrative embodiment of the present invention, the server cookie can include encrypted information that identifies one or more associated target groups. In addition, the server cookie can include expiration data, which is stored in both a clear text format and an encrypted format. The expiration data stored in the clear text format is used by the client computing device  for monitoring for the expiration of the server cookie. The expiration data stored in the encrypted format is used by software update service  to determine if the client computing device  is authorized to receive updates associated with a particular target group. In one embodiment, the expiration data of the server cookie applies to all target groups identified in the server cookie. Alternatively, or in addition to the expiration time that applies to the entire server cookie, the server cookie may include a plurality of expiration data, each of which may apply to individual target groups. As will be appreciated by those of ordinary skill in the art, each server cookie can include additional data. For instance, a server cookie may be configured to store client state information, such as a time stamp of the last execution of the authorization sub-routine .","Once generated, the authorization server cookie  is communicated from the authorization server  to the client computing device . Next, as shown in block , the server cookie is then stored in the memory of the client computing device . When the client computing device  determines that at least one component of the server cookie has expired, the client computing device can re-execute the authorization method  to obtain a new server cookie. As mentioned above, in each subsequent execution of the authorization method , the client computing device  may communicate its stored server cookies to the authorization server  in the cookie request . In one embodiment, the client does not have to send the request  unless the server informs the client that the server configuration has changed, i.e., a new authorization plug-in has been added.","In accordance with another aspect of the present invention, the software update service  may provide a synchronization sub-routine for synchronizing update information between the metadata server  and the client computing device . By the use of a unique software update hierarchy, the synchronization sub-routine can efficiently identify specific updates that apply to a particular client computing device. In addition, by the use of the server cookie generated in the authorization sub-routine , the synchronization sub-routine can selectively grant access to updates associated with specific target groups.","In accordance with an illustrative embodiment of the present invention, each software update includes three components: (1) an instruction component; (2) a localized data component; and (3) a data component. As will be appreciated by one of ordinary skill in the art, each update may have one or more of the above-described components. For example, an update may contain an instruction component, a localized data component, and a data stream component. In another example, an update may only contain an instruction component for testing one or more conditions of a client computing device. The various components of the software updates are described in more detail below.","Generally described, the instruction component contains two sub-components: (1) an applicability rule that defines one or more conditions to be tested by a client computing device ; and (2) a set of prerequisites that identifies one or more updates that are required for proper installation of an individual update. As described below, the applicability rule can define a number of conditions related a computer, and each of the conditions can be associated with other conditions by the use of any logical operators. For example, the instruction component may include an applicability rule to determine if a computer has a particular version of Windows\u00ae installed. As also described below, the set of prerequisites can identify one or more updates that are required to have been previously installed. For example, as described in more detail below with reference to , an individual update may contain a prerequisite that lists other updates required for the proper installation of the individual update. In other examples, as is also shown in , the set of prerequisites can include the use of logical operators to define more complex prerequisites rules.","The instruction component also contains code, such as a Boolean flag, that indicates if there are other updates that depend from a particular update. For illustrative purposes, an update is considered to be a LEAF update if there are no other updates that depend from a particular update. The Boolean flag that is used to indicate if an update is a LEAF is dynamically updated by the metadata server  as related updates are added or removed.","The localized data component of each update includes general information describing the update. For instance, the localized data component may include information describing the features and benefits of the update. The localized data component may also include a text description of the installation procedures of the update. In addition, the localized data component may include any other data or information related to the update. For instance, the localized data may indicate that an update is a high priority update. In another example, the localized data may provide special installation messages, such as a message that indicates that an update cannot be installed with other software updates. The localized information may be in a format that allows for the display of its contained information to a user.","The data component of each update includes one or more binary data streams of the update. In one embodiment, the data component of each update may be associated with one or more data files, such as an executable file, a document, a linked library, etc. As described in more detail below, each update may be associated with a combination of data files, each of which facilitates the actual upgrade, installation, or modification of software used by the client. For instance, the installation of an update may be facilitated by the use of a single CAB file including all the information required to complete a selected update. Alternatively, the installation of the update may be facilitated by use of a number of individual updates used to update one or more files stored on a client computing device.","In an illustrative embodiment of the present invention, software updates can be arranged in a hierarchy that allows for controlled distribution of the software updates. Generally described, the hierarchy of updates defines relationships between the updates and specifically indicates which updates are dependent on other updates. For illustrative purposes, an example set of updates is provided and shown in . As shown, a hierarchy of sample updates  includes a base set of updates , a second set of updates , and a third set of updates . In general, each update in the base set of updates  does not have a prerequisite that requires the installation of other updates. However, the sixth update  contains a prerequisite that requires the installation of the first update , the second update , and the third update . The seventh update  contains a prerequisite that requires the installation of the fourth update . The eighth update  contains a prerequisite that requires the installation of the sixth update  and the fifth update . Hence, the eighth update  also requires the installation of the first update , the second update , and the third update . For purposes of illustrating the present invention, it is given that all of the updates of the sample set of updates  are all associated with the All Computers target group and the PID target group.","Also shown in , and as described in more detail below, each update contains an applicability rule that specifies conditions for the installation of the update. For example, the first update  requires the installation of an English version of an operating system. The second update  requires the installation of Windows\u00ae XP version SP1. In another example, the sixth update  requires the installation of a software patch referred to as the XP PATCH. Accordingly, the client computing device  will not install the updates if the applicability rules have not been satisfied.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":["FIG. 9","FIG. 9"],"b":["922","931"]},{"@attributes":{"id":"p-0073","num":"0072"},"figref":["FIG. 10","FIG. 7","FIG. 10"],"b":["704","704","110","123","110","110","1051","123","1051","123","110","110","1051"]},"The client computing device  processes the instruction components of each received update to determine if the condition defined in the applicability rules can be met. If the condition defined in an individual update is met, for purposes of illustrating the synchronization sub-routine , the individual update is \u201cinstalled,\u201d and the installed update is saved in a first component of the client's update cache. On the other hand, if the condition defined in an individual update is not met, individual update is considered to be \u201cfailed,\u201d and the failed update is saved in a second component of the client's update cache. In this description of the synchronization sub-routine , if an update is installed it can be assumed that the prerequisites and the conditions of the applicability rules have been met. Installation of an update for purposes of describing this sub-routine does not necessarily mean that the data files associated with the update are actually installed in the client computing device .","In one embodiment, the two components of the client's update cache can be used to categorize the received updates. The first component is used for storing installed, non-LEAF updates; and a second component is used for storing all other updates received by the client, i.e., the updates that were not installed. The second component of the update cache also includes the storage of all LEAF updates. As described in more detail below, updates stored in the update cache can be communicated to and processed by the metadata server  to identify other related updates that are available for installation on the client computing device .","Returning now to , details of the synchronization request, which are illustrated as items , , and , will now be described. As will be appreciated by those of ordinary skill in the art, the synchronization request may be initiated by one of a number of different devices, processes, applications, user-initiated commands, requesting an update. The synchronization request may be initiated by a user requesting a list of updates, an automatic update initiated by the client agent, or any other software component requesting information from the metadata server  or the update service . In one embodiment, the synchronization request includes an authorization server cookie, such as the authorization server cookie generated from the authorization routine . The use of the server cookie allows the server to determine if the client is a member of one or more target groups.","Each synchronization request may also include identifiers for each update stored in the client's update cache. More specifically, if one or more updates are stored in the update cache, the synchronization request includes a first component having identifiers for installed, non-LEAF updates; and a second component having identifiers for all other updates, such as LEAF updates, failed updates, and other updates that are not installed. The update identifiers may be in any format including, but not limited to, an array of integers. Alternatively, if there are no updates stored in the client's update cache, the synchronization request is not configured with an update identifier. When a synchronization request is not configured with an update identifier, the synchronization request provides an indication that the client computing device  does not have any cached updates.","As shown in , a first synchronization request  is communicated from the client computing device  to the metadata server . In the present example, the client's update cache will not contain any updates, given that this is the first execution of the method. Thus, the first synchronization request  does not contain an identifier for a cached update. In response to receiving a synchronization request, as shown in block , the metadata server  determines if the synchronization request contains at least one update identifier. If it is determined that the synchronization request does not include an update identifier, the metadata server  responds by selecting first level updates for communication to the client computing device . As described above, first level updates may include any updates that do not have a prerequisite identifying other updates.","Alternatively, if it is determined that a synchronization request contains at least one update identifier, the metadata server  examines the prerequisites of the server's stored updates to select additional updates for delivery to the client. In one embodiment, the metadata server  selects updates having fulfilled prerequisites. In the examination of the prerequisites, the server uses the updates of the first component of the synchronization request, which includes identifiers of the non-LEAF updates that are installed on the client.","In addition to selecting updates having fulfilled prerequisites, the server also uses the updates identified in the second component of the synchronization request to filter the selected updates. More specifically, uninstalled updates, LEAF updates and failed updates identified in the second component of the synchronization request are used to filter one or more selected updates. This feature of the present invention allows the system and method of the present invention to avoid multiple transmissions of updates stored on the metadata server .","Returning to the present example, since the first synchronization request  does not include an update identifier, the metadata server  selects the base level of updates  for communication to the client computing device . With reference to the sample set of updates shown in , the base level of updates  includes the updates referenced as , , , , and .","In the processing of block , the metadata server  also examines the authorization server cookie contained in the synchronization request  to identify the target groups that are associated with the client computing device . The metadata server  also examines the target groups of the updates selected in the process of block . The process of block  then filters out all selected updates that are not associated with a target group identified in the received authorization server cookie. In the present example, since all of the selected updates , , , , and  are associated with the PID and All Computer target groups, all of the selected updates are sent to the client computing device .","The metadata server  then communicates the selected updates in a synchronization response  to the client computing device . In general, each synchronization response includes the instruction component of each update sent by the server . Thus, in the present example, the first synchronization response  includes the instruction components for the updates referenced as , , , , and . In one embodiment, each synchronization response does not include the localized data component or the data component of each update.","Next, as shown in block , the client computing device  processes the instruction components of each received update to determine if the condition defined in the applicability rules can be met. With reference again to , the client computing device  processes the instruction components of the received updates -. For purposes of illustrating the present invention, it is given in this example that the operating system of the client computing device  is an English installation of Windows\u00ae version XP SP1. It is also given that the client computing device  is a Dell PC and is running a 32-bit, X86 processor. Thus, in the processing of the instruction components of the sample set of updates, the client computing device  would determine that the condition defined in the first update  would be met because the computer contains an English OS. The condition defined in the second update  would be met because the operating system is Windows\u00ae version XP SP1. The condition defined in the third update  would be met because the client computing device  is running an X86 processor. The condition defined in the fifth update  would be met because the client computing device  is a Dell PC. As a result, the first update , second update , third update , and fifth update  are all saved in the first component of the client's update cache. The condition defined in the fourth update  would not be met because the client computing device  is not running a 64-bit X86 processor. Thus, the fourth update  is considered to be a failed update and saved in the second component of the client's update cache.","Returning to , in the processing of block , the client computing device  also determines if a subsequent synchronization request is required. In one embodiment, it is determined that a subsequent synchronization request is required if at least one of the received updates indicates that it is not a LEAF update. In the present example, it is determined that a subsequent synchronization request is required because all of the received updates are not LEAF updates. Thus, the client computing device  communicates a subsequent synchronization request  to the metadata server .","As summarized above, a synchronization request includes identifiers for each update stored in the client's update cache. Thus, in the present example, the subsequent synchronization request  includes a first data component indicating that the first update , second update , third update , and fifth update  are installed on the client. In addition, the subsequent synchronization request  includes a second data component indicating that the fourth update  is not successfully installed on the client.","In response to receiving the subsequent synchronization request , as summarized above, the metadata server  determines if the subsequent synchronization request  contains at least one update identifier. If it is determined that subsequent synchronization request contains at least one update identifier, the metadata server  examines the prerequisites of all stored updates to select additional updates for delivery to the client.","With reference again to the present example, in the processing of block , the metadata server  would select the sixth update  because its prerequisites are met. More specifically, as shown in , the sixth update  is selected for communication to the client computing device  because its prerequisite, which requires installation of the first update , second update , and third update , is fulfilled. The seventh update  and eighth update  would not be selected for communication to the client because their prerequisites are not fulfilled. More specifically, the synchronization request  did not contain an identifier for the fourth update , which is a prerequisite for the seventh update . In addition, the synchronization request  did not contain an identifier for the sixth update , which is a prerequisite for the eighth update .","Returning to , the synchronization sub-routine  continues by communicating the selected updates in a subsequent response  from the metadata server  to the client computing device . With reference again to the present example, the subsequent response  would include information related to the sixth update , is communicated to the client  in a subsequent response .","Upon receiving the subsequent response , the client computing device  processes the instruction components of the subsequent response . Similar to the process of block , the client computing device  processes the instruction components of each received update to determine if the condition defined in the applicability rules is met. In the present example, if it is given that the XP PATCH is installed in the client computing device, the sixth update  is considered to be installed and the update is written to the update cache of the client computing device . Since the sixth update  is not a LEAF update, the client computing device  sends another synchronization request  that includes all of the updates stored in the first and second component of the client's update cache. The synchronization request  also includes the authorization server cookie.","In the present example, by use of the above-described processing of the metadata server , the synchronization request  is processed at block  where the server selects the eighth  update. The eighth  update is selected because the synchronization request  indicates that the fifth and the sixth updates  and  are installed in the client computing device . Given that the eighth update  is associated with the same target groups identified in the authorization server cookie, the instruction component of the eighth update  is communicated to the client computing device  in another response . The eighth update  is then processed in block  in a manner similar to the process of blocks  and . Since all of the received updates of the response  are LEAF updates, a subsequent synchronization request is not sent back to the metadata server .","At the client computing device , after it is determined that all of the received updates are LEAF updates, or if no updates are received in the response , the synchronization sub-routine  communicates a driver synchronization request  from the client computing device  to the metadata server . As will be appreciated by one of ordinary skill in the art, the driver synchronization request  may include information describing all of the hardware installed in the client computing device  and information describing the installed software. Similar to the prior software synchronization requests (,  and ), the driver synchronization request  may communicate the installed updates to the server. In addition, all of the driver updates currently cached on the client, if any, are communicated to the server.","In response to receiving the driver synchronization request , the metadata server  responds by sending all of the driver updates that apply to the client computing device  that are not already cached on the client. A driver update is sent to the client computing device  in a response  if its prerequisites and conditions are met. The response  communicating the driver updates preferably communicates the instruction component of each update. The driver updates are then written to the update cache of the client computing device.","After the receiving the response  containing the driver updates, the synchronization sub-routine  sends a request  for the localized data of each of the received software and hardware updates. As summarized above, the localized data component of each update includes general information describing the update. For instance, the localized data component may include information describing the features and benefits of the update. The localized data component may also include a text description of the installation procedures of the update. In addition, the localized data component may include any other data or information related to the update.","Thus, upon receiving request  for the localized data of each of the received software updates and hardware updates, the metadata server  responds by sending all of the localized data for all of the received software updates and hardware updates saved in the update cache of the client. Once received, the localized data can be processed by a software application to determine which of the updates needs to be installed. Alternatively, the received localized data can be displayed to a user to inform the user of all updates that are available to the client computing device . In one embodiment, the received localized data can be displayed on a Web page. In the present example, localized data may be received by the client for the sixth and eighth updates  and . If localized data is stored in the base updates , ,  and , the localized data for those update would also be received by the client.",{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 11","b":["1100","1100","1105","1106","1103","1104","1100","1101","123","124"]},"In one aspect of the present invention, the client performs a number of processes to enhance the display of the Web page . For instance, the client computing device  examines the localized data of each update to determine if a particular update is of high priority. Such a feature can be facilitated by locating text in the localized data, or in other component of a particular update, that indicates that the particular update is a high priority or emergency update. If the client computing device  detects a high priority update or emergency update, the client displays the high priority update in a visible section of the Web page , such as the top section of the page. In addition, the client may generate a visual indicator, such as a specialized text message , indicating that the update is a high priority update.","The client computing device  may also examine the localized data of each update to determine if a particular update requires an exclusive installation, i.e., an update having an installation file that cannot be simultaneously installed with an installation file of another update. Such a feature can be facilitated by locating text in the localized data, or in other component of a particular update, that indicates that the particular update requires an exclusive installation. If the client computing device  detects such an update, the client displays a visual indicator, such as the text message  shown in , with the description of the updates that require an exclusive installation.","Returning to , the software update routine  continues at block  where the client computing device  receives a selection of the updates. As noted above, in response to actuation of the control button , the selection of the one or more updates can be obtained by the metadata server  or the download server . Once the selection of one or more updates is received the software update routine  continues at block  where the selected software updates are processed.","In accordance with still another aspect of the present invention, the software update service  may provide a method for selecting and transmitting information between the software update service and the client computing device .  are illustrative of a software update processing sub-routine  implemented by the client computing device  to retrieve and install requested software in accordance with the present invention. As described above, the software update processing sub-routine  may be implemented once a selection of software updates has been generated or received. With reference to , at block , the update management component  instantiates an update agent . In an illustrative embodiment of the present invention, the update agent  is a specialized software component for determining what software update information is required to completed a requested software update, to generate a required version of an installation component of the update agent, to generate updated files by merging existing files with delta patches, and\/or to initiate the installation of updated files. In the event that an update agent  is already instantiated, block  may be omitted.","At block , the update agent  obtains software update information from the update service . In an illustrative embodiment of the present invention, the software update information transmitted by the update service  is in the form of a package, such as a self-extracting file, that includes a variety of data that may be utilized by the update agent. In one aspect, the package can include a list of all the files that correspond to a particular software update. Additionally, the package can include copy of at least a portion of the patch storage manifest that maps specific versions of files to be updated to a corresponding software update delta patch stored in the patch storage file on the update service . The package can also include installation information for each file to be updated that can include an identification of a version of an installation component required to complete the installation. Further, the package can also include an installation component for the update agent  or a delta patch to update a version of an installation component already stored on the client computing device . Still further, the package can include verification information to allow the update agent to determine whether a software update was successful. For example, the verification information can include reference hash values for updated files for comparison. The update agent  may also verify the contents of package.","At decision block , a test is conducted to determine whether the update agent  needs to update a version of the installation component to implement the update. One skilled in the relevant art will appreciate that the transmission of a complete copy of an installation component in the self-extracting file can increase the amount of data transmitted by the update service  for each software update. Accordingly, in an illustrative embodiment of the present invention, a baseline version of an installation component may be stored in the client computing device and updated specifically for the requirements of the current software update by way of an installation component delta patch. Accordingly, the installation information in the self-extracting file instructs the update agent  whether or not any included installation component updates need to be merged with the baseline version of the installation component on the client computing device . If an update is required, at block , the update agent  updates the baseline installation component, as will be explained in greater detail below with regard to .","Once the update agent updates the installation component or if the installation component does not require an update, at block , the update agent  performs an inventory of files installed on the client computing device  and the specific version of the file. In an illustrative embodiment of the present invention, the update agent  may query the client computing device  file system for all files identified in the package as corresponding to the selected update. Alternatively, if the update agent  has recently conducted an inventory, a cached version of the inventory may be utilized. At block , the update agent  identifies what software update information is required to complete the requested update. In an illustrative embodiment of the present invention, the patch storage manifest includes a mapping of versions of an installed file to a required delta patch. Accordingly, if delta patching is available, the update agent  will utilize the mapping to identify a particular delta patch and its offset location within the patch storage file. Alternatively, if delta patch is not available or cannot implemented, the update agent  may identify an entire file for download.","With reference now to , at block , the update date agent transmits a request for the identified software update information. In an illustrative embodiment of the present invention, the update agent  can transmit a request for specific delta patches by indicating a specific range of patches required from the patch storage file to the download server  of the update service . As described above, the patch storage file includes a large of number of applicable delta patches, in which each delta patch is identified by its location with the patch storage file. Because the patch storage file may be rather large in some implementations, the update agent  can utilize a request that only requests for data from specific locations in the patch storage file as indicated from the patch storage manifest. In an alternate embodiment of the present invention, the update agent  may request an entire copy of an update file and\/or a complete copy of the patch storage file.","In an alternate embodiment of the present invention, another download server that may not be exclusively associated with the update service  can process the update agent  request. In this embodiment, the request patch storage file may be transmitted, in whole or in part, to any number of additional download servers on a network. The additional download servers may be part of a private network utilized to update clients on the private network. Further, the additional download server may be part of public network. In a private network environment, the download servers may obtain a complete copy of the patch storage file for processing client requests. Alternatively, the download servers may also cache portions of the patch storage file in processing previous data requests from other clients and utilize the cache data to satisfy the download. Accordingly, the additional download servers can reduce the communications strain on the download server  of the update service .","At block , the update agent  receives the requested update information. In an illustrative embodiment of the present invention, the requested update information may be transmitted in two approaches. In a first approach, referred to as manual update, the update request is sent to the update service  with a request for a direct HTTP data delivery response. In this approach, the update service  may utilize all of the entire bandwidth available to transmit the requested data to the update agent . In a second approach, referred to as an automatic update, the update request is sent to the update service  with a request for an indirect HTTP data delivery response. In this response, the update service  transmits the requested data as a background process. The background process may be implemented in a manner to utilize a minimal amount of available bandwidth. Further, the background process may be interrupted during the download process and restarted at the next available time. A description of a system and method for transmitting requested data via a background process is described in commonly assigned and copending U.S. patent application Ser. No. 09\/505,735, entitled System and Method for Transferring Data Over a Network, and filed on Feb. 16, 2000, which is hereby incorporated by reference. One skilled in the relevant art will appreciate that foreground or background data delivery is not necessarily reflective of a priority of the selected software update, but rather how bandwidth is allocated to obtain the update information.","Once the requested in formation is received from the update service, at block , the update agent  merges the delta patch with the corresponding installed files. In an illustrative embodiment of the present invention, the update agent  may cache the original version of the installed file to ensure that the selected file does not change during the download and merging process. Further, the cached original version of the installed file may be used to uninstall the selected update.","At decision block , a test is conducted to determine whether the updated file is valid. In an illustrative embodiment of the present invention, the update agent  may utilize a hashing algorithm to compare a reference hash value obtained from the update information package and corresponding to a valid file update with a hash from the current modified file. If the hashes do not match, the current modified file is not valid. One skilled in the relevant art will appreciate that any one of a number of alternative validation algorithms may also be utilized. If the updated file is not valid, the sub-routine  returns to block , where the update agent may request the update information again. Alternatively, if the update agent  has unsuccessfully attempted to generate the update file several times, the update agent may implement one of several fallback procedures. In one embodiment of the present invention, the update agent  may request a completed copy of the updated file stored in the patch storage file and identified from the patch storage manifest from the update service . In another embodiment of the present invention, the update agent  may request a copy of the updated file in a self-contained file from the update service . In still another embodiment of the present invention, the sub-routine  may otherwise fail.","Once the selected file is valid, at decision block , a test is conducted to determine whether any additional downloads are required. In an illustrative embodiment of the present invention, the sub-routine  enters into an iterative loop that continuously checks for additional downloads after the completion of a previously selected download. If the state of a file changes during the download, the update agent  would continue to request additional downloads for the new change of state. If additional downloads are required, at block , the update agent  performs another inventory and identifies all applicable delta patches. The sub-routine  then returns to block .","Once all the requested update downloads are complete, at decision block , a test is conducted to determine whether the state of the client machine has changed. In an illustrative embodiment of the present invention, time may elapse between the downloading and merging of update information and the actual installation of the updated file. Accordingly, prior to installing the updated file, the update agent determines whether the client computing device state has changed. If the state has changed, the file update may not be valid and the update fails at block . Alternatively, if no state change has occurred, the update agent  installs the updated file at block  and the sub-routine  returns at block .","With reference now to , a sub-routine  implemented by the client computing device  for updating a baseline installation component corresponding to block  () will be described. At decision block , a test is conducted to determine whether a new baseline installation component is included in the self-extracting file transmitted to the update agent  from the update service . In an illustrative embodiment of the present invention, if the delta patches required to update the baseline installer are comparable in size to the transmission of an updated installation component, a new baseline installation component will be transmitted. If an updated installation component is included, at block , the update agent installs the updated baseline installation component as the new installation component. Additionally, the new updated installation component may be saved in the client computing device  memory to serve as a baseline installer for additional updates. At block , the sub-routine returns.","If an updated baseline installation component is not included in the self-extracting file, at block , the update agent  obtains a baseline installation component delta patch from the self-extracting file. In an illustrative embodiment of the present invention, the baseline installation component delta patch corresponds to software code that can be merged with the baseline installation component to generate an updated baseline installation component. Accordingly, at block , the updated agent merges the baseline installation component delta patch with the baseline installation component. At block , the update agent  then designates the updated baseline installation component as the current installation component. In an illustrative embodiment of the present invention, the updated installation component will not be saved after the installation is complete. In accordance with this embodiment, the update agent  only maintains a limited number of baseline installation components in the client computing device  memory. Accordingly, the update agent generates a temporary, updated installation component at each installation. Because each client computing device  can only correspond to a limited number of baseline installation components, the update service  is only required to transmit a single baseline installation component delta patch for each client computing device. At block , the sub-routine  returns.","While the preferred embodiment of the invention has been illustrated and described, it will be appreciated that various changes can be made therein without departing from the spirit and scope of the invention. For instance, although the illustrative examples described herein apply to software updates, the scope of the present invention includes other uses beyond the distribution and communication of information related to software updates. Accordingly, unless specific subject matter is expressly excluded in this disclosure, it is to be appreciated that the scope of the present invention applies to distribution and communication of any type of data, other than, or in addition to software updates."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing aspects and many of the attendant advantages of this invention will become more readily appreciated as the same become better understood by reference to the following detailed description, when taken in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 5","FIG. 1"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 6","FIG. 1"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 12A and 12B","b":["1200","110"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
