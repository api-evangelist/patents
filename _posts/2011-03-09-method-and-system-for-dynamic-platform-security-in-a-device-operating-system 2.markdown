---
title: Method and system for dynamic platform security in a device operating system
abstract: A system and method is provided for implementing platform security on a consumer electronic device having an open development platform. The device is of the type which includes an abstraction layer operable between device hardware and application software. A secure software agent is provided for embedding within the abstraction layer forming the operating system. A secure store is provided for storing security information unique to one or more instances of the application software. The secure software agent uses the security information for continuous runtime assurance of ongoing operational integrity of the operating system and application software and thus operational integrity of the device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09635048&OS=09635048&RS=09635048
owner: Irdeto B.V.
number: 09635048
owner_city: Hoofddorp
owner_country: NL
publication_date: 20110309
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The present invention relates generally to mitigating security threats and recovering from security breaches on electronic devices. More particularly, the present invention relates to: (a) preventing unauthorized use and access of an electronic device and digital assets such as games, applications, e-books, video files, text files and other digital data considered of value on that electronic device using a secure software agent embedded in the device; (b) providing a means to mitigate the damage that may be caused by automated attacks that may occur by installing secure software agents that are diverse from on agent to the next; and (c) providing a means to recover from attacks that may occur by updating the secure software agent with one that is diverse from the original agent in functionality (for example, introducing additional security checks) and structure (for example, by re-ordering the location of binary code in the agent).","Devices such as mobile phones, tablets, games consoles, set top boxes, televisions, personal navigation devices, and other consumer electronics devices (or simply \u201cdevices\u201d) are typically purchased by consumers from retail distribution channels (e.g., consumer electronics stores) or may be sold to or leased to consumers by service providers (or simply \u201coperators\u201d)\u2014e.g., mobile network operators, broadcast television network providers, or Internet video providers. Traditionally, such devices were closed devices or embedded devices that were based on proprietary hardware and operating systems and that did not support third party software applications. However, such devices have increasingly become open devices. It should be understood that \u201copen\u201d in the context of this background discussion can include varying degrees including, but not limited to, standard hardware (such as a system on a chip based on an Intel or ARM processor), open source operating systems and software, open or published APIs to enable third party applications development, and\/or freely modifiable programming.","Such devices may include open source operating systems, including those such as Linux (an open source Unix-type operating system originally created by Linus Torvalds with the assistance of developers around the world) or Android (an open source mobile operating system based on a modified version of the Linux kernel and marketed by Google, Inc. of Mountain View, Calif.).","Attacks on closed or embedded devices, in the form of unauthorized use and access, have taken place for many years. However, such hacking of embedded devices has been a specialized and highly technical process that required a specialized combination of hardware and software skills. In contrast, open devices have hardware and operating systems that are well understood by many developers and hackers. Accordingly, this trend to open devices greatly increases the potential number of hackers with knowledge and expertise that renders such open devices much more susceptible to attack. Such open devices also support the capability for third party application developers to develop applications for those device (e.g., open API's) and hence such devices also increasingly support the capability for consumers to download, install, and execute third-party software applications (or simply \u201capplications\u201d) on such devices. Such applications are not developed by the operator or the original equipment manufacturer (or simply \u201cOEM\u201d which could include companies such as Apple Inc., of Cupertino, Calif.) of the device. In terms of software design, such applications may be developed using a script language (e.g., JavaScript) or native code (e.g., a C or C++ program).","The capability for consumers to purchase or lease and to download and install third-party software applications on devices may be provided by the OEM (e.g. Apple Inc.), an operator, or a company that is unaffiliated with the OEM or operator typically via an Internet-based retail interface\u2014e.g., the iTunes Store or the Android Market (software-based online digital media stores operated by Apple Inc. and Google Inc., respectively). Internet-based retail interface provides a system by which the third-party application developer (or simply \u201cdeveloper\u201d) shares part of the revenue from sales of an application with the Internet-based retail interface provider. The trend to enable consumers to download and install such third-party applications (or simply \u201capps\u201d) on devices also increases the potential security concerns for consumers, operators, developers and OEM's beyond those that would normally be associated with an embedded device.","One such security concern is malware whereby the third-party software sold to the consumer may contain malicious software known as malware (e.g., worms, viruses, Trojans, rootkits, and backdoors). Such malware may cause a breach of consumer privacy\u2014e.g., malware on a mobile phone might monitor a user's position via the GPS capabilities of the mobile phone and transmit such positional data to a remote server. Malware may also cause identity theft or fraudulent use of the device or related services\u2014e.g., malware on a mobile phone could automatically dial services which add charges to a user's mobile phone subscription. Malware may also cause network stability problems for operators\u2014e.g., malware on mobile phones could inappropriately use network capabilities such as SMS or mobile voice calling to create a denial of service attack against a mobile network operator's network impacting the network service quality or availability.","Another significant security concern is application piracy. Here, applications are subject to piracy whereby a consumer may obtain a copy of the application for free and install it on their device or on a similar device that is not authorized or supported by the provider of the Internet-based retail interface. Application piracy causes the provider of the Internet-based retail interface and the developer to generate less revenue than they would in the absence of application piracy.","Additional security concerns include unauthorized applications. Providers of Internet-based retail interfaces may \u201ccertify\u201d applications to ensure that malware is not present in the applications sold through their Internet-based retail interfaces. This serves to provide some level of protection against the malware concerns noted above and to prevent applications from otherwise compromising the security of the device and\/or device network (i.e., mobile network). If this certification process can be circumvented or is not exhaustive, then consumers may unknowingly download malware onto their devices from an unauthorized Internet-based retail interface or other Internet web site. If this certification process can be circumvented or is not adequate to detect potential malware then consumers may unknowingly download malware onto their devices from an Internet-based retail interface.","Another important security concern involves content piracy. It is known that media applications (e.g., a video player, music player or e-book reader) may be used on devices by consumers to access high value digital content, such as digital video, music or electronic publications, that is licensed from media content providers (e.g., a movie studio, music producer, or book publisher) by the providers of Internet-based retail interfaces for sale to consumers. A hostile user (e.g., a content pirate) may install software on a device owned by the hostile user to enable the hostile user to access cryptographic keys used by a media application to decrypt content, siphon digital content (i.e., capture decrypted, compressed digital content at some point in the media rendering path) or \u201cscreen scrape\u201d digital content (i.e., capture decrypted, decompressed digital content at some point in the media rendering path). Such captured media content could therefore be used and reproduced without further control or approval by the media content providers.","Existing approaches to platform security (i.e., security intended to address one or more of the security problems noted above) typically involve one or more of the following methods further grouped and described herein below.","\u201cOperating system security\u201d is a security method whereby one or more functions or capabilities including process isolation, access control, private application programming interfaces (APIs), and application certification\/signing, and application licensing services may be provided by an operating system. Such functions and capabilities are further described as follows.","\u201cProcess isolation\u201d may be supported by the operating system (or a hypervisor installed beneath the operating system) to ensure that each application and parts of the system runs in its own process and dedicated memory space such that, by default, no application has the capability to perform any operation that could adversely affect another application, the operating system (OS), or the consumer. Each application process can be considered to be running in its own operating environment often referred to as its own \u201csandbox.\u201d However, to develop applications that are useful to users, most applications must be able to access operating system services (e.g., on a mobile phone OS, send short message service (SMS) text messages, get user location, record phone calls, take pictures, or the like) that are not supported within the basic sandbox. This limits the effectiveness of process isolation or the \u201csandbox\u201d as the application must access operating system services outside the sandbox which increases the probability that the application may perform operations that negatively affect other applications, the OS, or the consumer.","\u201cAccess control\u201d involves the ability to address the requirement for applications to use OS services or resources outside the sandbox or for native applications, OS services or resources that could enable a native application to adversely affect other applications, the consumer or a network. Here, the OS includes access control functionality that makes decisions about whether to grant such access to a requesting application. This access control functionality may be combined with the concept of permissions. For example in the Android OS from Google Inc., application developers must declare the permissions required by their applications in an associated manifest file to enable the application to perform any operation that might adversely affect other applications, the OS, or the consumer. Access control decisions may also be based on the privileges inherently granted to an application (e.g., user application or root access in the Linux OS). One of the problems associated with permissions is related to the question of who or what grants permissions to an application and whether the grantor understands the implications of such approval (e.g., in the Android OS case it is the consumer that grants such permissions). Another problem is that such permissions may be modified by malware or an attacker following such grant of permissions by the consumer or the certifying authority. Some operating systems have access control frameworks that enable different access control models to be implemented (e.g., Linux Security Module (LSM)). LSM enables different access control models and functions to be implemented as loadable kernel modules.","\u201cPrivate APIs\u201d are another mechanism to limit the ability of applications to access operating system services or resources that may adversely affect platform security. Here, although many system API's may be open or public, the OEM may limit access to certain operating system services by maintaining the secrecy of API's required to access such services from applications developers. This is normally coupled with an application certification process to ensure that applications submitted for certification do not attempt to call such private API's.","\u201cApplication certification\/signing\u201d involves various existing application certification processes in current use that ensure applications do not perform malicious operations and\/or access private API's. These processes generally include static verification (e.g., scanning the object code prior to execution) of the application (e.g., to verify that private API's are not called by the application) and dynamic verification (e.g. to verify the \u201cstability\u201d of the application during execution). If the Application passes the certification process it is then digitally signed by the certifying authority (which may also be the Internet-based retail interface provider) in a form that can later be verified. One of the problems with current application certification schemes is that a comprehensive verification is not readily automated and, hence, is not exhaustive. Because of this, a malicious operation could be embedded in the application in such a manner that it will only execute at a pre-specified time following the application certification\/signing process. Accordingly, such malicious operation can avoid detection during the verification process. Another problem with application certification is the sheer number of applications that may have to be certified by an Internet-based retail interface provider. For example, it is estimated that the App Store (an Internet-based retail interface offered by Apple Inc. for providing mobile software applications for their iPhone\u2122 brand smartphone) has over 300,000 applications and that there are 10,000 new applications submitted to Apple Inc. each week. This makes it cost-prohibitive to perform exhaustive verification of applications before certification. Another problem is that a hacker could modify or replace the root of trust in the OS (i.e., a digital certificate and software) used to verify the integrity of the application against the signature generated by the Internet-based retail interface provider such that the application can be modified following application certification\/signing, such that the permissions associated with the application can be modified, such that a hostile third party could load an unauthorized application onto the device or such that a pirated application can be loaded onto the device by a consumer.","\u201cApplication licensing services\u201d involves protection against application piracy whereby the system provides a license service. For example, the Android OS provides a licensing service that lets an application developer enforce licensing policies for paid applications. However, these types of application licensing services can be readily circumvented by hackers by modifying the application to extract such license verification checks.","In addition to the problems noted in each of the above functions and capabilities found within platform security, there is a problem that is common to process isolation, access control, and application licensing services whereby the portions of the OS that support such security functions can be subverted or bypassed by modifying portions of the operating system that perform such functions. To prevent such changes to the OS security functions or other OS functions, a further method of utilizing a \u201csecure boot loader\u201d is often implemented in devices.","A \u201csecure boot loader\u201d (or \u201csecure boot\u201d for short) is used to ensure that only the intended boot software and OS kernel are loaded onto the device. Here, the authentication compares the applicable software against a signature generated by the device OEM. The authentication or integrity verification of the boot software and the OS kernel occur only during device start-up such that this mechanism can be circumvented by dynamic attacks occurring during the boot process. Once the secure boot loader has been bypassed, the OS can be modified to bypass other security functions that may be present in the OS. These dynamic attacks can be highly automated so that they are accessible by consumers that do not otherwise have the technical skills to independently implement such attacks (i.e., jailbreaking techniques). Moreover, there is no way to restore device security for devices already deployed in the field once the secure boot process has been compromised.","In addition to the problems noted above relating to platform security, there is a problem that is common to process isolation, access control, application licensing services, virtual machines, and secure boot loaders that relates to the ability to recover from an attack. Generally, once an attack has occurred there is no mechanism in place to recover platform security for devices that have been sold or licensed or otherwise distributed to consumers. We refer to this as \u201cstatic security\u201d because the assumption inherent in the design of such platform security is that the platform security mechanisms put in place will resist any and all attacks during the useful lifespan of the device. Static security is often attacked and such attacks are then \u201cpackaged\u201d into automated attacks that can be implemented by the average consumer (e.g., the known jailbreak attack on the iPhone\u2122 developed by Apple\u2122).","\u201cVirus detection and intrusion prevention software\u201d is another security method used to detect malware and mitigate any damage that such malware may cause. To date, nearly every solution to detect malware on devices, such as mobile phones, has relied upon the same \u201csignature\u201d-based mechanisms that personal computer (PC) anti-virus solutions have used for years. The term \u201csignature\u201d here does not involve a digital signature, but rather a set of attributes by which a specific piece of malware can be identified\u2014e.g., an attribute such as being of a specific length and having a specific sequence of bytes at a certain location within it. However, these signatures are only understood once the malware has been deployed, meaning the malware may have already caused damage. Additionally, these signature-based types of solutions must be constantly updated and must be able to detect 10's of thousands of malware signatures. These alone cannot be relied upon as the only means of detecting and preventing damage from malware on devices. Additionally, anti-virus software itself can be modified or disabled by malware to prevent such detection.","\u201cVirtual machines\u201d is yet another security method used to apply platform security. Virtual machines, such as the Java\u2122 virtual machine (JVM), are designed to allow the safe execution of applications obtained from potentially untrusted sources. The JVM accepts a form of computer intermediate language commonly referred to as Java\u2122 bytecode which is a programming language conceptually representing the instruction set of a stack-oriented, capability architecture from Oracle Corporation of Redwood Shores, Calif. Java\u2122 applications run in a restricted sandbox which is designed to protect the user from misbehaving code or malware. This comes with performance limitations and limitations in terms of the functionality\u2014e.g., applications are prevented from accessing operating system functions and resources that are deemed to be \u201chazardous\u201d.","Each of the aforementioned security methods form part of a static platform security functionality  as shown in prior art . Additionally, secure bootstrap loading  as shown in  is well known, for example within U.S. Pat. No. 6,185,678 issued to Arbaugh et al. on Feb. 6, 2001, and not further described herein.","\u201cMedia application obfuscation\u201d, is a security method which can be used in conjunction with platform security, or in cases where platform security does not exist, whereby software obfuscation techniques may be applied to media applications to prevent cryptographic keys that are used to decrypt the content from being discovered by a hostile user and to prevent media siphoning or screen scraping attacks on the media playback path. There are four problems that arise in protecting the media playback path. First, the media playback path may be implemented by the OEM or another third party that gives the provider of the media application limited ability to implement obfuscation techniques within the media playback path. Second, obfuscating the media playback path can introduce additional central processing unit (CPU) overhead which could increase the power consumption of a device, and introduce delays in the functioning of the application or other applications on the device. Third, the high data rates of certain media types (e.g., high definition video) associated with decompressed high definition video may limit the ability to obfuscate the media playback path. Finally, the hardware used to render the media (i.e., a graphics processing unit (GPU)) may not be secure or may have secure API's that are not commercially accessible to the media application provider, in order to prevent screen scraping type attacks.","It is, therefore, desirable to provide a security mechanism that overcomes the problems associated with previous methods of preventing unauthorized use of a device and digital assets on that device and the limitations of static platform security.","It is an object of the present invention to obviate or mitigate at least one disadvantage of previous platform security methods and mechanisms. More specifically, the present invention addresses the deficiencies of previous platform security methods and mechanisms in terms of improving security against at least application piracy, malware, unauthorized applications, and content piracy.","In a first embodiment, the present invention provides a system for improving security of a device, the system including: an abstraction layer operable between device hardware and application software; a secure software agent embedded within the abstraction layer; and a secure store for storing security information unique to the application software for continuous runtime use by the secure software agent to assure ongoing integrity of the system.","In a further embodiment, there is provided a method of improving security of a device where the device includes an abstraction layer operable between device hardware and application software, the method including: embedding a secure software agent within the abstraction layer; and providing a secure store for storing security information unique to the application software for continuous runtime use by the secure software agent to assure ongoing operational integrity of the device.","Other aspects and features of the present invention will become apparent to those ordinarily skilled in the art upon review of the following description of specific embodiments of the invention in conjunction with the accompanying figures.","Generally, the present invention provides a method and system for renewable or \u201cdynamic\u201d platform security. Though applicable to any mobile phones, games consoles, tablets, set top boxes, televisions or other consumer electronic devices, the present invention will be described in terms of such devices that use an open OS such as, but not limited to, the Linux or Android\u2122 OS. In particular, the preferred embodiment will be shown and described relative to the Android\u2122 OS for purposes of illustration only and should not be construed as limiting the intended scope of the present invention. Indeed, advantages of the present invention in terms of countering malware, application piracy or modification, improving platform access control, and securing media playback on devices are universally applicable to any device OS with particular usefulness to any open device as a result of the inherently greater security risks associated with such open devices. Moreover, the present invention is intended as a new method and system of application control and which is usable with, and in addition to, existing platform security.","With reference to , an overall layer schematic  is shown to indicate the present invention as implemented in an Android\u2122 OS embodiment. Here, the basic architecture of the present invention is seen to include a layered execution stack. The base layer  involves typical system on a chip (SOC) components including a central processing unit (CPU), graphics processing unit (GPU), and memory (read only memory (ROM)) within which the basic input\/output system (BIOS) resides. The highest layer in  is the device application shown here as one or more Android\u2122 applications , . Intervening layers include the various known software and hardware elements including a hard disk drive (HDD) storage device or flash memory , the OS kernel  and OS kernel application interface layer  which manages system calls between the OS native applications  and the Android\u2122 OS . In accordance with the present invention, the layered execution stack further includes a Java\u2122 access control (JAC) layer  between the Android\u2122 OS  and the virtual machine (VM) layer  (i.e., Dalvik, which is the Android\u2122 VM that forms an integral part of the Android\u2122 OS). The VM layer serves to convert the given application into a compact executable form (i.e., the \u201c.dex\u201d format in terms of Android\u2122 applications) suitable for execution in a known manner on the given device. The JAC layer  serves to provide secure access control by authenticating communication between the machine executable code of the VM layer  and a security agent (or simply \u201cagent\u201d) . Such access control functionality may include any suitable known mechanism that provides a bridge between scripted apps and the native agent to allow the agent to verify the integrity of the scripted application thereby extending the range of \u201capplications\u201d to scripted applications. It should further be understood that if all applications are assumed to be native applications , then the JAC layer  would not be required.","It should be understood that the present invention may be implemented in conjunction with known static platform security functionality  as shown in . More specifically, the present invention incorporates existing OS system security functions, such as process isolation, by ensuring that the portions of the operating system that perform such functions are not modified during the boot process or during run time. As well, the present invention complements existing secure boot loader functions (Stage 1 Bootloader  and Stage 2 Bootloader  as shown in ) by verifying that the correct secure boot loader path was followed and by dynamically verifying the integrity of the OS and boot loader. It should be understood that such secure boot loader only functions as such during start-up.","In accordance with the present invention, the agent  is embedded in the OS kernel . The agent  is Linux Security Module interface (LSM I\/F) compliant. LSM is not further discussed herein as it is a known framework (which is applicable to Android\u2122 as well as Linux distributions) that allows the Linux kernel to support a variety of computer security models without favoring any single security implementation. In order to render the agent  resistant to tampering, modification, and reverse engineering attacks, the agent  is itself protected using known software protection techniques such as, but not limited to, those described in more detail in U.S. Pat. Nos. 6,594,761, 6,779,114, 6,842,862, and 7,506,177 each issued to Chow et al. which illustrate examples of such tamper resistance that may be usable in conjunction with the present invention.","It should be understood that the agent  forms an integral and un-detachable part of the OS kernel  without which the device OS  and\/or the applications , ,  will cease to function correctly. One example of the functions of the agent  is to monitor the integrity of both the OS  and the applications , ,  loaded onto the device, and to detect any breaches of the OS  or secure boot , . The agent  maintains and has sole access to a secured data store  within which the agent  keeps information relevant for the agent's performance of kernel resource access control, integrity verification, application licensing and application resource access control. While the secure store  is shown in  as being a separate component of the inventive system, it should be understood that the secure store  may exist within the hard drive or flash  as seen in alternative embodiment  if . Still further, the secure store  may exist as a secure memory within the system on a chip base layer  as seen in further alternative embodiment  in .","In terms of kernel resource access control, the agent is configured to control application access to OS kernel resources and data. The access control decisions made by the agent are based on, but not limited to, factors such as: OS kernel integrity, application integrity, application context, and the privileges granted by any given trusted root authority. An access control decision based on OS kernel integrity determines whether the kernel has been modified, been replaced, been added to, or had portions removed in an unauthorized manner. The access control decision will also determine whether the secure boot process even occurred. If the OS kernel has been modified, replaced, added to or portions removed or the secure boot process cannot be positively verified, this determination would serve to invalidate many of the assumptions that the agent or an application or a secure application such as a media player would normally operate under. An access control decision based upon application integrity determines whether the application that is attempting to access OS kernel resources has been modified in any way (e.g., to insert malware into the application or by other malware) or whether the privileges associated with that application been modified (e.g., to give it privileges to access system resources that were not authorized by the certifying authority).","An access control decision based upon application context determines whether a given application is functioning in some manner outside the context of that application. Thus, the agent can make context sensitive access control decisions. For example, if a media application playing high definition video is running, then other applications should not be able to access the frame buffer as this would enable a screen scraping attack. An access control decision based upon any given trusted root authority determines application permissions relative to the authority. In other words, the present invention may support multiple application signing authorities such that the agent may grant an application signed by a highly trusted authority a greater degree of latitude in terms of access to system resources than may be granted to an application signed by a less trusted authority or an application that was not certified at all.","In terms of the agent's performance of integrity verification, the agent is configured to dynamically monitor (e.g., in memory while the software is running) the integrity of the kernel, the secure boot components, the agent itself, and all protected applications and unprotected applications to determine if any of these items have been modified in any way at any time during the execution of the given application(s) (e.g., dynamic tampering which might be implemented using a debugger).","In terms of the agent's performance of application resource control, the agent is configured to control access to application resources which may include, for example, a portion of the application that has been encrypted by the agent, or data files that are required by the application to execute (e.g., game resource files), or data to control execution of applications. Such access control decisions are based on factors such as, but not limited to, the presence of valid license data or the confirmation of the identity of the device or consumer, either of which are designed to protect applications from piracy.","The agent itself may be embodied in software and generated by diverse code portion combinations with a fixed interface. Creation of such variations in code portions can be accomplished according to known methods, or combinations of such methods, including those described in U.S. Pat. Nos. 6,594,761, 6,779,114, 6,842,862, or 7,506,177 each issued to Chow et al. or any other suitable known method. Such variations can be termed \u201cdiverse agents\u201d or \u201cupdated agents.\u201d Diverse agents are those which have the same functionality, F, but that are structurally and semantically diverse. The objective of generating and deploying diverse agents is to prevent an automated attack\u2014i.e., an attack developed by a sophisticated attacker that can be sufficiently automated that it is simple to use by an average consumer and that would be applicable to each and every agent deployed in some installed base of devices. Such diverse agents may be deployed across different instantiations of a device, different types of devices, devices sold in different geographic regions or by different operators, etc.","Updated agents are those whereby if an agent, A1, with functionality set F1, is deployed in the field and is compromised or attacked in some way, it is desirable to fix such vulnerability. This may be accomplished by generating an agent, A2, that incorporates the functionality F1 but which also incorporates a new functionality designed to prevent the attack on A1. This incremental functionality, F2, is such that the functionality of A2 is now F1+F2. By applying diversity capabilities to A2, it is more difficult for an attacker to isolate the software functions in A2 (e.g., through differential analysis) which implement the new functionality F2. Updated agents provide a mechanism to address attacks on devices or agents that are already deployed in the field. Such updated agents could be downloaded by consumers, pushed to the device via a software update mechanism or pulled to the device by the existing agent. Where such updates occur, it should be understood that they are accomplished by configuring the agent software for updates upon identification and analysis of any attempted or actual successful attack by a security threat. Therefore, the present invention could issue updates to the agent for attacks that are \u201cin development\u201d as hackers will often post information of attacks that are in development but which have not yet succeeded in reaching the attackers objectives.","With regard to , a more detailed schematic  of the dynamic platform security functionality is shown in accordance with the generalized stack architecture of the present invention as in . Here, it can be seen clearly, when compared with prior art , how the present invention compliments and can be implemented in conjunction with the known static platform security functionality. As in the previous , the base layer includes typical SOC  components including a CPU  and ROM  within which BIOS  resides.","In terms of the operations shown in , there is a typical secure boot loader sequence  provided as shown. It should be understood that the embodiment of the present invention could leverage existing secure boot technology. It should equally be understood that the boot sequence may equally apply to 1 stage or the many stages there-after. Typically there are 2 boot loading stages ,  in a system as shown in . Generally speaking, bottom up validation of secure boot components occurs as the first component validates the second component before transferring execution control to the next component. This boot time integrity verification is shown by way of dotted lines. Here, the first stage occurs upon device reset, where ROM code is hard wired to the device reset address. The ROM (or boot ROM)  loads the next boot stage  after verifying that the next boot stage is the intended boot stage. This verification or authentication is performed by computing a digital signature from the HDD or flash memory . If the digital signature matches the pre-computed value (as encapsulated in the digital certificate  as shown), then the OS boot loader  will be loaded into main memory and executed. If the signature does not match the pre-computed value at any stage, execution control will not transfer to the next stage and the device will fail to boot. When the OS boot loader  has execution control, the OS boot loader performs  a similar operation of validating the OS image from the HDD or flash memory . Again, if the computed signature matches the expected pre-computed signature, it will load into memory the OS image and transfer control to the OS image (i.e., the Linux kernel  operating in the Android\u2122 OS  as shown). The OS image will then initialize, and during this process the agent  will also be initialized. While the agent  is included in the OS image which is digitally signed, it should be understood that the agent  may be updated. This is because signatures are broken down into logical module separation and each module has its own signatures that are checked during the secure boot process. Therefore, any module may be replaced though the signature must be valid and trusted cryptographically with a digital signing private key.","With continued reference to , the OS kernel  is shown as the Linux kernel modified for the Android\u2122 OS . Here, this specific implementation of the invention uses the Linux Security Module (\u201cLSM\u201d). As mentioned above, LSM is a framework that allows the Linux kernel  to support a variety of computer security models while avoiding favoring any single security implementation. LSM provides hooks at every point in the Linux kernel  where a user-level system call is about to result in access to an important internal kernel object. LSM can be used to implement a wide range of security functions (e.g., Mandatory Access Control (MAC), On Access Virus Checking).","The agent  in accordance with the present invention is also configured to include integrity verification (or simply \u201cIV\u201d). The IV function that is embedded in the agent  enables the agent  to perform static integrity verification (e.g., on HDD or on flash memory) and dynamic integrity verification (e.g., in random access memory (RAM)). IV is implemented by computing a hash value for an application or system component and then comparing that to a known good value for the hash function. If the calculated value is the same as the stored known good value, then the agent assumes that the component has not been modified by an attacker. However, if the calculated value is different than the stored known good value, then the agent assumes that the component has been modified and can no longer be trusted to perform the functionality that it was intended to perform or that it should no longer have the same privileges that were originally assigned to it.","As shown in , the agent  performs IV checks on a number of device software components on an ongoing basis. This \u201cintegrity monitoring\u201d is done to detect any unauthorized modification (e.g., tampering) such as the modification, replacement, removal, or additions of components or sub-components that are critical to supporting the security objectives for the system.","Such components monitored via IV by the agent  in accordance with the present invention include: ROM BIOS ; HDD or device flash memory ; stage 1 bootloader ; stage 2 bootloader ; Linux kernel  or portions of the Linux kernel; system call interface (I\/F) ; agent  including the secure store  (during both boot time and run time as indicated, respectfully, by dotted and solid arrows in ); native application ; Android\u2122 OS ; native Android\u2122 application ; JAC ; Android\u2122 (Dalvik) virtual machine ; Android\u2122 application ; and application & system provisioning sequence (as further described with regard to  below).","Such integrity monitoring (shown by solid arrows) of native application 1  is illustrated in . Here, the agent  continuously monitors native application 1  such that integrity is verified when the native application 1  attempts to access system resources through the system call I\/F . This occurs through signature verification  whereby the agent  implements IV by comparing signature 1  to a known good value corresponding to application 1 resources. In particular, application 1 resources include IV information and the application signing certificate stored in a secure store . If the signature 1 value is the same as the stored application signing certificate (i.e., known good value), then the agent  assumes that the native application 1  has not been modified by an attacker and that its permissions or privileges  have not been modified. However, if the signature 1 value is different than the known good value, then the agent  assumes that the native application 1  has been modified and can no longer be trusted to perform the functionality that it was intended to perform. This process occurs for all native applications that may be present up to native application n .","The process isolation block  shown in  will be further explained with regard to  where there is illustrated a runtime boot loading sequence  in accordance with the present invention. In particular, upon device reset a top down validation (at steps 1, 2, and 3) of secure boot components can be seen. This validation serves to ensure that the OS that is loaded onto the device is the one intended by the OEM or operator and that the OS has the intended functionality. Once the agent gains execution control during initialization (at step 4), the agent will perform IV upon itself along with the previously executed components of the secure boot loader including the boot ROM image, the OS boot loader, and the OS image. If the integrity (from steps 1 through 4) of all of these components is confirmed by the agent by using comparisons to data resident in the agent secure store (at steps 5 though 8), then the agent assumes that the OS that is installed on the device is the intended OS and that certain security functionality that may be performed by the OS has not been modified. However, if the agent determines that one or more of the components cannot be authenticated, the agent may take corrective action.","One possible corrective action taken by the agent is to replace the boot components with a backup image of the intended boot components, then reset the device and start the boot up process again. If the agent detects that the system is invalid after a number of attempts to correct invalid components, then the agent may deny all further access to critical system resources or application resources. It should be readily apparent that the number of attempts is a matter of design choice and therefore a predetermined variable within the intended scope of the present invention. Likewise, the determination of which system resources may be considered critical may be predetermined based upon the given device usage. As well, other corrective actions are possible without straying from the intended scope of the present invention.","It should be understood the preceding detailed description presumes that an application already exists and is therefore known to the OEM, operator, Internet-based retail interface provider, and, in turn, known to the agent in accordance with the present invention. However, it is readily apparent that new applications may come into being by a developer. As such,  illustrates the processing that is applied to an application (unprotected) submitted by a developer during the application certification process . The agent in accordance with the present invention includes an asset protection tool  which is a software tool configured to create and update the encrypted application secure store . Here, the asset protection tool  stores information to protect the unprotected application. It should be understood that a variety of tamper resistant techniques can be applied to the stored information such as, but not limited to, secure loader and IV, and the use of whitebox cryptography to protect cryptographic secrets at rest (e.g., on disk) and in use (e.g., in-memory).","With further regard to , there is provided an unprotected asset  (i.e., new application from a developer) at step 1. Created by the application developer or development system is an unsigned enhanced permission container manifest  at step 2. This lists the permissions (A, B, . . . etc.) granted to the application by the certifying authority. Moreover, the permissions are mapped to specific set of kernel system calls. After the unsigned manifest  is created, the asset protection tool  is configured to generate or use a provided private root of trust key  at step 3. The root of trust may be automatically and randomly generated by the asset protection tool. The asset protection tool  then signs the unsigned application  via the asset protection tool  at step 4 and places the result in a signed enhanced permission container manifest that exists within the application secure store . Moreover, the signed version of the enhanced permission container manifest is stored at step 5 in the application secure store  where information specific to the given asset (e.g., code signature, enhanced permission container manifest, root of trust keys) are placed. The resultant outcome at step 6 is a signed and protected asset  in the form of a fully provisioned application. Optionally, the unprotected new application may have a secure loader wrapped around it so as to provide a resulting protected asset with static tampering resistance and be IV enabled.","It should further be understood that not all application types may be provisioned for any particular embodiment of the asset protection tool discussed above. For example, in the present embodiment which is related specifically to the Android\u2122 OS, a typical list of application types that can be provisioned, installed, and subsequently run on the system implementing the present embodiment of the invention may be limited to a native OS application, a native Android\u2122 application, and an Android\u2122 application. Other open OS implementations may of course be possible beyond the specific Android\u2122 OS implementation illustrated herein without straying from the intended scope of the present invention.","The permission information created in the provisioning sequence of  is further used by the agent during installation and runtime of the given application being placed onto the device. Moreover, when the given application code selected from the types of available applications is provisioned the resulting signed enhanced permission container manifest in the application secure store thereby contains all the permissions that the application code requires during runtime. The enhanced permission container manifest specifies the application code signature and the signature of the container itself so as to prevent tampering of the container or application after the application code has been signed.","With regard to , initial installation  of application permissions is illustrated. Here, the signed enhanced permission container manifest  shown is found within the application secure store  that was created during provisioning time in . As previously mentioned, the enhanced permission container manifest  is encrypted by the asset protection tool. Accordingly, this facilitates transfer of the enhanced permission container manifest  from the application secure store  to the agent secure store . Both the application secure store  and the agent secure store  comprise the secure store as generally shown in .","Within the enhanced permission container manifest  there exists a permission list (i.e., Permission A, Permission B, . . . etc.). The permission list determines what OS kernel resources can be accessed by the given application code that forms the application being installed and run. The application code signature is used by the agent  to IV the application to ensure it has not been modified at the time it makes the OS request for particular kernel permissions, such as \u201cinstall\u201d requests. The container signature is a reference value for the container itself, and is used by the agent  to ensure the contents of the container have not changed. Once the integrity of the OS and the application have been verified, the installed application's enhanced permission container manifest will be stored in the agent secure store  for future reference of other permission requests for that application.","With further regard to , the installation sequence includes first sending at step 1 a request to the OS kernel  to install an application pursuant to an installer directive from the application code . Subsequently, the OS kernel  passes along the request to the agent  at step 2. The agent  validates (via IV as already described above) the OS kernel  at step 3. It should be understood as previously noted above, that the agent  also validates the OS kernel  in an ongoing manner (i.e., as a background process). At step 4, the agent  accesses the application secure store  to retrieve the signed enhanced permission container manifest  therefrom. The agent  validates at step 5 the application's signed enhanced permission container manifest through IV using the signed enhanced permission container manifest . The agent  at step 6 stores the validated application's enhanced permission container manifest into the agent secure store  for future reference. Based upon the step 5 validation operation, the agent  allows or denies the install to the OS kernel  at step 7. In turn, the OS Kernel  at step 8 passes the permission (allow or deny) to the installer directive that is installing the application to be installed to ultimately allow or deny installation of the application code .","As mentioned above, the agent validates the OS kernel in an ongoing manner as kernel operations are required. This kernel access control  is shown in  in terms of continuous runtime system integrity. Here, the sequence of how the entire system integrity is maintained is shown whenever any application makes an OS request for kernel services. In , an installed and running application (i.e., user application)  is shown making a request for OS services or resources . This request is passed to the OS kernel  and which request is, in turn, passed along to the agent  via the LSM functionality that will ultimately allow or deny the request. In accordance with the present invention, the criteria used by the agent  to allow or deny the application request may include: system\/application integrity, application permissions, application behavior, security context for other applications that may be running, and remote commands (element , shown previously in regard to ).","The agent decision criteria related to system\/application integrity includes whether tampering has been detected to either system or application components.","The agent decision criteria related to application permissions includes whether the application has the necessary permissions to make such a request. In the Android\u2122 OS, such permissions are declared in a manifest file that is associated with the application. Application developers must declare these permissions and it is up to the consumer to grant or not grant these permissions which may be problematic as consumers are not typically aware of security implications of their actions.","The agent decision criteria related to application's behavior disregards whether an application may have permissions to access certain kernel services and instead relies upon the application's behavior. For example, an application that requests consumer GPS coordinates every 15 seconds and then attempts to send such coordinates to a third party via some messaging protocol such as SMS, could potentially be \u201cspyware.\u201d Such behavior therefore may result in request denial even though the application may have permissions associated with the kernel service related to GPS coordinates (i.e., the agent would block access if the application had rights granted to location data, but not rights granted to SMS data).","The agent decision criteria related to the security context of any other applications that may be running also disregards whether an application may have permission to access certain kernel services and instead looks to whether allowing a request when another trusted application is running could negatively affect one or more of these trusted applications. In other words, the agent properly enforces permissions at run time. For example, the requesting application may try to access certain memory or drivers to capture high definition video after a trusted high definition video player application that implements digital rights management has decrypted the video thereby calling into question the appropriateness of the high definition video data usage by the requesting application (i.e., the agent may block access to the screen buffer memory, though allow the playing of the video itself).","The agent decision criteria related to remote commands involve providing the agent the ability to support commands from a remote entity (e.g., a service provider) that could override the applications permissions or privileges. For example, a mobile operator may wish to disable a mobile device that has been stolen. In this case, the agent would also base decisions to provide system access on remote commands that would prevent the device from being used by an unauthorized user of the device. For example, a mobile operator may wish to disable or limit the access an application or applications have to network services or other kernel resources in the event that such an application is causing problems with network reliability or stability (e.g., by generating a high volume of traffic or connections that cannot be sustained by the network). In this case, the agent could override the privileges that the application has or prevent the application from executing at all.","Further, such commands from the remote command controller may be used to limit permissions (e.g., reduce privileges, change privileges, or revoke privileges). Further, such commands from the remote command controller may be used to remove applications from the device, including terminating the application if currently executing, removing the application from memory, or un-installing the application completely. Overall, it is important to note that the present invention may not only serve to \u201ckill\u201d applications, but may also serve to limit access to system resources beyond the access that is implied in the privileges associated with the given application\u2014e.g., even if an application has the privilege to send SMS messages, this is not quantified in the privileges such that when the application sends, for example, 10,000 SMS messages an hour, the agent could \u201cthrottle this back\u201d based on some \u201cnormal behavior\u201d template stored in the agent secure store or based on remote commands. Still further, the agent may be used to report anomalous behavior back to the remote entity so that, for example, a mobile operator or designated third party could make decisions about what to do (e.g., an application has made X requests for a system resource over some period of time).","Using the aforementioned criteria for ongoing runtime system integrity, the kernel access control  shown in  includes an initial OS request by the user application  at step 1. In turn, the application at step 2 creates a software interrupt or otherwise creates an event for the OS. In the OS kernel , the LSM receives the request  (i.e., interrupt\/event) and passes the request  to the agent  at step 3. The agent  integrity verifies the application  and the permissions at step 4 using the criteria described above. At step 5, the agent  validates the user request memory stack. Thereafter, the agent  integrity verifies the OS kernel image in memory at step 6. As previously mentioned, IV checks are run on an ongoing basis by the agent . This check verifies that the IV process is still running and has not detected any evidence of tampering. Based upon the system validation process (steps 4, 5, and 6), the agent  therefore allows or denies the request, and, at step 7, the allowance or denial of the request is passed along to the OS kernel . In turn, the OS kernel  passes along the allowance or denial of the request at step 8. At such point, the application event returns control back to the application  at step 9 with the decision to allow or deny the request.","As in the continuous runtime system integrity of , it should be understood that the application must also be validated in an ongoing manner. Accordingly, there is shown runtime validation of an application request in . In general, an application must not be tampered with in any way or validation here will fail. The stack diagram  in  illustrates how the present invention efficiently provides application integrity monitoring while maintaining system integrity at the same time. Here, the address spaces for the agent , OS kernel , and application  are shown. As the agent is embedded in the OS kernel, it should be understood that the agent address space  is therefore shared with the OS kernel address space . Return addresses in the calling stack are data points into integrity verification information that is contained in the agent. The start of runtime validation (at step 1) of the application involves the agent walking the stack of the request for OS service while validating all return addresses (at steps 2 through 4) and performing integrity verification on the address range utilizing the call stack signature as described below. When an application makes a request for any OS kernel service, the OS kernel passes along this request of a kernel service to the agent. This OS kernel is LSM enabled such that the agent is required to allow or deny the request.","In accordance with the present invention, runtime call stack signature calculation is accomplished using the distance (in bytes) between each return address on the stack to the top of the stack. Table A represents exemplary call stacks for the agent , the OS kernel , and the application .",{"@attributes":{"id":"p-0079","num":"0078"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE A"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},{},"Stack Frame",{}]},{"entry":[{},{},"Element"]},{"entry":["Call Stack",{},"Filter \u201cReturn"]},{"entry":["Signature","Owner","Address\u201d","Comments"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Agent","Return Address","Current Stack Position (must be"]},{"entry":[{},{},{},"Agent Address Space)"]},{"entry":["12 bytes","Agent",". . .","Variable length stack frame"]},{"entry":[{},"Agent","Return Address","Calculate the bytes inbetween"]},{"entry":["23 bytes","OS Kernel",". . .","Variable length stack frame"]},{"entry":[{},"OS Kernel","Return Address","Calculate the bytes inbetween"]},{"entry":["44 bytes","OS Kernel",". . .","Variable length stack frame"]},{"entry":[{},"OS Kernel","Return Address","Calculate the bytes inbetween"]},{"entry":["10 Bytes","User App",". . .","Variable length stack frame"]},{"entry":[{},"User App","Return Address","Calculates the bytes inbetween"]},{"entry":[{},"User App",{},"Top of Stack"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"The signature from the above example includes an application unique user ID randomly assigned during installation and a collection of call stack signature bytes as seen in Table B.",{"@attributes":{"id":"p-0081","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE B"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Application Identifier (2-8 bytes)","Call Stack Signature (2-128 bytes)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In terms of the example of TABLE B, the signature of call stack of \u201cApplication ID 12032\u201d would be \u201c12032:12:23:44:10\u201d and used in the integrity verification check by the agent.","The depth of the stack is a variable length but not to exceed 128 samples. Also, the depth of the stack between the OS kernel and the agent is known and calculated prior to the application calling the OS kernel services. From this calculation, the agent may determine that all the return addresses on the call stack are included in the integrity verification signature range when the application and system components were provisioned. It should be understood that all the return addresses must be found in the list of signatures of the signed application and system components, which are stored in the agent secure store, in order for the agent to allow the OS to service the application.","As shown in , there is detailed a runtime call stack signature validation sequence. Here, the validation sequence begins at step 1. Thereafter, at step 2, the agent examines the stack and determines the return address which identifies the location of the calling code in the OS Kernel address space . Based on the calling code, the agent at step 3 verifies that the caller is legitimate and has recently and successfully had its integrity verified. There may be several layers of this checking in the OS Kernel address space , as indicated in . Thereafter, at step 4, a similar return address determination and validation process is performed as calling code in the stack appears from the application address space . Again, there may be several layers of this checking in the application address space , as shown in .","During runtime, it should be understood that application permissions should be enforced on an ongoing basis as applications are subject to dynamic attacks (e.g. portions of an application or its associated permissions could be modified during execution using a debugger). Such application permission enforcement  is shown in . Here, any request that an application  makes to the OS kernel  after installation of the application  will be validated using the signed enhanced permission container manifest  that is stored in the agent secure store . The agent  will allow or deny the request based on the integrity of the system and the permission provided in the enhanced permission container . The enforcement sequence includes an application  making an OS request at step 1 and, at step 2, the OS kernel  validates the request with the agent . At step 3, the agent  validates the OS integrity as already described above.","Step 4 provides that the agent  validates the type of OS Kernel request from the signed enhanced permission container manifest . It is important here to note that, at run-time, the requesting application is only granted access to OS Kernel services that are contained within the signed enhanced permission container manifest  which contains the requested permissions as identified by the application developer prior to submission of the application to certification. Moreover, this mechanism maintains the security and integrity of the system, even if the application developer does not correctly identify all kernel services that their application attempts to access at run time.","Once the agent  validates the type of OS Kernel request from the signed enhanced permission container manifest , the agent  then passes the allow or deny decision based on the validation in the steps 3 and 4 to the OS kernel  at step 5. Subsequently, the OS kernel  passes such allow or deny decision to the application  at step 6 based on the agent decision passed to it.","The above-described embodiments of the present invention are intended to be examples only. Alterations, modifications and variations may be effected to the particular embodiments by those of skill in the art without departing from the scope of the invention, which is defined solely by the claims appended hereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the present invention will now be described, by way of example only, with reference to the attached Figures.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 2C"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 3","FIG. 2A"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 5","FIG. 3"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 6","FIG. 3"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 7","FIG. 3"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 8","FIG. 3"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 9","FIG. 3"]}]},"DETDESC":[{},{}]}
