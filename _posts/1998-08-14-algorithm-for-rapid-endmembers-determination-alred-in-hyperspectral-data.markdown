---
title: Algorithm for rapid endmembers determination (ALRED) in hyperspectral data
abstract: A method for rapid processing of large sets of hyperspectral data. A hyperspectral image, with hundreds of thousands to millions of pixels measured at hundreds of wavelengths, can contain over a gigabyte of data. Even modern computers can be quite slow when performing involved calculations on data sets of this size. An algorithm requiring a minimal amount of floating point calculations that still yielded useful results is disclosed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08041121&OS=08041121&RS=08041121
owner: The United States of America as represented by the Secretary of the Air Force
number: 08041121
owner_city: Washington
owner_country: US
publication_date: 19980814
---

{"@attributes":{"id":"description"},"GOVINT":[{},{}],"heading":["STATEMENT OF GOVERNMENT INTEREST","REFERENCE TO SOURCE CODE APPENDIX","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["The invention described herein may be manufactured and used by or for the Government for governmental purposes without the payment of any royalty thereon.","Reference is made to the source code appendix which is the most advanced version of the source code of the present invention at the time of filing.","The present invention relates generally to spectroscopy, and more specifically the invention pertains to an algorithm for rapidly estimating basis spectra (\u2018endmembers\u2019) for use in analysis of hyperspectral data.","Hyperspectral data consists of hundreds of digital images, each spatially coincident image measured at a different wavelength. Each pixel in the image, then, has measured value at hundreds of wavelengths, and a spectrum of measured values vs. wavelength can be plotted for each pixel. This spectrum can also be thought of as a vector with magnitude and direction in come multi-dimensional space, with the perpendicular coordinate axes spanning this space being the wavelengths at which measurements were made. The measured spectra are then lists of coordinates for a point in this space.","When one makes a scatterplot in multiple dimensions with every pixel in the image plotted as such a point, the entire data set can be viewed as a \u2018data cloud\u2019\u2014the scatterplot with thousands of points plotted from the data resembles a cloud. Points inside the data cloud can often be usefully modeled as a linear combination of points near the \u2018hull\u2019 of the data cloud. The physical interpretation of this model is that points on the hull of the data cloud may correspond to pixels that have uniform and unique spectral composition (uniform surface properties), and points inside the data cloud correspond to pixels with inhomogeneous composition describable as mixtures of the supposedly pure pixels of the hull.","An example of a system that acquires hyperspectral data is in U.S. Pat. No. 5,379,065, Jan. 3, 1995, Programmable hyperspectral image mapper with on-array processing, the disclosure of which is incorporated herein by reference.","An ideal case for hyperspectral data analysis is using the \u2018convex hull\u2019 approach would be data that, when scatterplotted, fell within (and even outlined) an obvious simplex. For two wavelength measurements, a two-dimensional simplex is a triangle. For three wavelength measurements, the corresponding simplex is a tetrahedron. Imagine, for the moment, the two-dimensional case. If the data cloud is of a triangle shape, then one may imagine trying to find a \u2018best fit\u2019 triangle to the data cloud. If this is done, the vertices of the data cloud could then be taken as points (representing spectra) that describe the rest of the data. That is, every point inside the triangle can be described as a linear combination of the triangle vertices, where the multipliers on the vertice vectors sum to one and are all greater or equal to zero. Imagine that the three vertices represent the spectra of a tree, a road, and soil. One would interpret the triangle shape of the data cloud, then, to mean that the measured scene was composed uniquely of there three things. The points near the triangle vertice can be taken to be purely tree, purely road, or purely grass. Points inside the triangle vertice are assumed to be a mixture of these three \u2018endmembers\u2019. Based on the position of data points inside the triangle one can calculate the exact nature of this mixture for each data point.","This calculation of multipliers for the endmembers is called \u2018spectral unmixing\u2019. For example, a point dead center in the triangle would be described as 1.3 tree, \u2153 road, and \u2153 grass (note the sum of the multipliers is one). A point along the \u2018hull\u2019 (the edge of the triangle) between the road and grass endmember could be \u00bd A grass, \u00bd A road, and 0 tree. The results of this unmixing are useful for an analyst trying to assign physical characteristics to each pixel in a hyperspectral image. Fir higher dimensions (often there are hundreds of wavelengths in a hyperspectral data set), one must imagine a data cloud inside a multi-dimensional simplex.","Often, the measured data may intrinsically be of lower dimensionality that the number of wavelengths. Imagine data being measured in the dimensions that falls along a plane when scatterplotted in three dimensions. The physical interpretation of this is that the measured scene contained only three unique spectral signatures and mixtures of these endmembers. It would then be possible to transform the data into a two-dimensional space and so the endmember identification and spectral unmixing in two dimensions (a simpler problem). In this manner, data measured in 200 wavelengths often is only intrinsically 10-15 dimensional","Data sets may exist where, physically, no pixels in the image were of a uniform composition. In this case, one may try to fit a simplex around the data cloud and use the extrapolated vertices guarantees a neat mathematical solution to the unmixing problem, but leaves room for error in having found physically relevant endmembers.","Fitting a simplex around a multi-dimensional data cloud in a physically meaningful way is a very difficult mathematical and computational problem. I am unaware of any existing software tools for doing this. Instead, a classic approach to finding endmembers is as follows. Firstly, one performs a principal component transformation on the data set to reduce the data to its intrinsic dimensionality. One then scatterplots the data along various axes, looking for obvious outliers that might be useful as endmembers. Having located several endmembers, one then does the linear spectral unmixing. This process is far from automated and can require hours to complete.","One attempt at automating part of the interactive hunt for endmembers is called \u201cPixel Purity Index\u2019. This is included in the commercial software package called \u2018ENVI\u2019. This method iteratively creates random direction vectors, projects the data cloud onto these vectors, and flags pixels that lie at the extremes of the resulting distribution. After doing this thousands of time, it then selects the pixels that were most often flagged in this manner as possible endmembers. One then can interactively select pixels from this reduced number of pixels. This method is quite effective, but can require hours or even days of computing.","The present invention includes a system and a process that uses an algorithm for rapidly estimating basis spectra (\u2018endmembers\u2019) for use in analysis of hyperspectral data. The algorithm aims to locate all unique spectral shapes present in the data. First, all spectra in the data are normalized by area or by vector length. The goal in doing this is to prepare spectra with different total energies for comparison by spectral shape. The algorithm then scans through the hyperspectral data to find maxima and minima at each measured wavelength. The spatial pixels at which maxima and minima were found are then flagged as possible endmembers. The spectra of all flagged pixels are then compared for similarity by calculating correlation coefficients. Spectra with a correlation coefficient above a certain threshold are eliminated as being too similar in shape to other spectra which are kept as endmembers. The remaining spectra can then be used (in their pre-normalization form) as endmembers to do \u2018spectral unmixing\u2019 of the hyperspectral data set. This selection process is extremely rapid compared to iterative or statistical methods for locating likely endmembers, and yields useful results.","It is an object of the invention to estimate basis spectra for analysis of hyperspectral data.","This and many other objects and advantages of the present invention will be readily apparent to one skilled in the pertinent art from the following detailed description of a preferred embodiment of the invention.","The present invention is a system and process that uses an algorithm for rapidly estimating basis spectra (\u2018endmembers\u2019) for use in analysis of hyperspectral data. The algorithm aims to locate all unique spectral shapes present in the data.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1"},"Having been told that automatic fitting of a simplex to a data cloud is a difficult problem (and were it to be solved, might require more computational time than would be useful), one will wonder how useful endmembers might be located in the data in a rapid automatic fashion. One could find certain points on the hull of the data cloud by simply locating the maximum\/minimum values in the data at each measured wavelength. One can then use the points in the cloud (corresponding to spectra) having these maximum\/minimum values at one or more wavelengths as endmembers. These points will not necessarily be near the vertices of some ideally-fit simplex, but will certainly be on the hull of the data cloud, and therefore more useful as endmembers that a randomly selected data point.","This idea requires refinement, however. One wants to identify as endmembers all uniquely shaped spectra in the data. Some pixels in the image will be brighter than most others at all wavelengths. As one is looking for shapes in the spectra that are unique, one will need to normalize the spectra somehow before running min\/max tests as a search criteria. One can normalize by area under the spectral curve, which corresponds to an energy normalization, or one can normalize by vector length (the distance from the point in multi-dimensional space to the origin).","Pixels having low overall intensity are thrown out, as their spectral shapes will be heavily influenced by noise. After normalization, one calculates the min\/max values. Flagged pixels are endmember candidates, and one potentially has twice as many candidates as measured wavelengths (if every min\/max occurred at different pixels). One can then eliminate many of the candidates based on their similarity to other candidates. This step can be done using correlation coefficient calculation between all candidates. For spectra that are highly correlated (a threshold is set), all but one are thrown away (or the average of these spectra is kept as an endmember). After eliminating essentially redundant spectra (ones that are too similar), one has a set of spectra that work quite well as endmembers.","Table 1 is the algorithm used in the present invention.",{"@attributes":{"id":"p-0032","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Here is some sample code that performs an endmember selection on "},{"entry":"a hyperspectral image:"},{"entry":";===============READ CUBE==="},{"entry":"a=fltarr(320,640,210)"},{"entry":"openr,lun, \u2018c:\\hydicedata\\atcr007.cub\u2019,\/get_lun"},{"entry":"readu,lun, a"},{"entry":"a=a(7:314,*,*)"},{"entry":"orig = a"},{"entry":"free_lun,lun"},{"entry":";==========NORMALIZE Spectra BY AREA====="},{"entry":"atot = total(a,3)."},{"entry":"mu = total(total(atot,1))\/(308.*640.)"},{"entry":"stdev = sqrt(total(total((atot-mu){circumflex over (\u2009)}2,1))\/308.*640.))"},{"entry":"for i=0,209 do a(*,*,i)=a(*,*,i)\/atot"},{"entry":";==========CLEAN OUT THE DIM ONES====="},{"entry":"avspec = total(total(a,1),1)\/(308.*640.))"},{"entry":"thresh = mu-stdev"},{"entry":"dim = where(atot lt thresh,count)"},{"entry":"ythr = fix(dim\/308.) & xthr = round(((dim\/308.)-ythr)*308.)"},{"entry":"if count ge 1 then begin"},{"entry":"\u2003for I=0,count-1 do a(xthr(i),ythr(i),*)=avspec(*)"},{"entry":"endif"},{"entry":";==========SET UP VARIABLES====="},{"entry":"bands = [findgen(91)+10, findgen(27)+111,findgen(53)+152]"},{"entry":"nban = n_elements(bands)"},{"entry":"temp = fltarr(308,640)"},{"entry":"minm = fltarr(nban) & maxm = fltarr(nban)"},{"entry":";=======FIND WHICH PIXELS HAVE MIN OR MAX VALUES"},{"entry":";=======IN ONE BAND (MIN\/MAX FOR ENTIRE CUBE)"},{"entry":"for i=0,nban-1 do begin"},{"entry":"\u2003temp(*,*) = a(*,*,bands(i))"},{"entry":"\u2003duma=min(temp,minin) & dumb=max(temp,maxin)"},{"entry":"\u2003minm(i)-minin & maxm(i)=maxin"},{"entry":"endfor"},{"entry":"minm = minm(sort(minm)) & maxm = maxm(sort(maxm))"},{"entry":";==========ELIMINATE REDUNDANT PIXELS====="},{"entry":"minf = [minm(0)] & maxf = [maxm(0)]"},{"entry":"for i=1,nban-1 do begin"},{"entry":"\u2003if minm(i) ne minm(i-1) then minf=[minf,minm(i)]"},{"entry":"\u2003if maxm(i) ne maxm(i-1) then maxf=[maxf,maxm(i)]"},{"entry":"endfor"},{"entry":"nmin n_elements(minf) & nmax = n_elements(maxf)"},{"entry":";-----------------------list of min\/max aggregation--"},{"entry":"biglist = [minf,maxf] & biglist = biglist(sort(biglist))"},{"entry":"coord = [biglist(0)]"},{"entry":"for i=1,n_elements(biglist)-1 do begin"},{"entry":"\u2003if biglist(i) ne biglist(i-1) then coord=[coord,biglist(i)]"},{"entry":"endfor"},{"entry":";----------------------------------------------------"},{"entry":";==========CONVERT TO X,Y COORD====="},{"entry":"minx = fltarr(nmin) & miny = minx"},{"entry":"maxx = fltarr(nmax) & maxy = maxx"},{"entry":"for i = 0,nmin-1 do begin"},{"entry":"\u2003dumin = minf(i)\/308."},{"entry":"\u2003miny(i) = fix(dumin)"},{"entry":"\u2003minx(i) = round((dumin \u2212 fix(dumin))*308.)"},{"entry":"endfor"},{"entry":"for i = 0,nmax-1 do begin"},{"entry":"\u2003dumax = maxf(i)\/308."},{"entry":"\u2003maxy(i) - fix(dumax)"},{"entry":"\u2003maxx(i) = round((dumax - fix(dumax))*308.)"},{"entry":"endfor"},{"entry":";-----------------------LIST OF MIN\/MAX AGGREGATION---"},{"entry":"ybig = fix(coord\/308.) & xbig=round(((coord\/308.)-ybig)*308.)"},{"entry":"device,decomposed=0"},{"entry":"plot, orig(xbig(0),ybig(0),*),yrange=[0.,1.],ysty=1"},{"entry":"for i=1,n_elements(coord)-1 do $"},{"entry":"\u2003oplot, orig(xbig(i),ybig(i),*),color=18*i"},{"entry":";=======SORT OUT THE ENDMEMBER CANDIDATES====="},{"entry":"nem = n_elements(coord)"},{"entry":"endmem = fltarr(nem,nban)"},{"entry":"for i=0,nem-1 do endmem(i,*) = orig(xbig(i),ybig(i),bands)"},{"entry":"means = total(endmem,2)\/float(nban)"},{"entry":"meansub \u2212 endmem"},{"entry":"for i=0,nban-1 do meansub(*,i)=endmem(*,i)-means(*)"},{"entry":"stdv = sqrt(total(meansub{circumflex over (\u2009)}2,2)\/float(nban))"},{"entry":"covar = (transpose(meansub)##meansub)\/float(nban)"},{"entry":"corr = covar"},{"entry":"for i=0,nem-1 do begin & for j=0,nem-1 do begin"},{"entry":"\u2003corr(i,j) = covar(i,j,)\/(stdv(i)*stdv(j))"},{"entry":"endfor & endfor"},{"entry":";-------GOT THE CORR COEFF, NOW AVERAGE SIMILAR ONES---"},{"entry":"endmemf = fltarr(nem,210)"},{"entry":"for i=0,nem-1 do endmemf(i,*) = orig(xbig(i),ybig(i),*)"},{"entry":"count = fltarr(nem) & count(*)=1."},{"entry":"wcorr = corr"},{"entry":"for i=0,nem-1 do wcorr(i:nem-1,i)=0."},{"entry":"wcorr(where(wcorr lt.985))=0."},{"entry":"while total(wcorr) ne 0. do begin"},{"entry":"\u2003top = max(wcorr,ind)"},{"entry":"\u2003yind = fix(ind\/float(nem))"},{"entry":"\u2003xind = round(((ind\/float(nem))-yind)*nem)"},{"entry":"\u2003endmemf(xind,*) = endmemf(xind,*)+endmemf(yind,*)"},{"entry":"\u2003endmemf(yind,*) = 0."},{"entry":"\u2003count(xind) = count(xind)+count(yind)"},{"entry":"\u2003wcorr(*,yind)=0. & wcorr(yind,*)=0."},{"entry":"endwhile"},{"entry":"for i=0,nem-1 do endmemf(i,*)=endmemf(i,*)\/count(i)"},{"entry":"endmem = fltarr(1,210)"},{"entry":"cou = 1."},{"entry":"for i=0,nem-1 do begin"},{"entry":"\u2003if total(endmemf(i,*)) ne 0. then begin"},{"entry":"\u2003\u2003endmemb = [[endmemf(i,*)],endmemb]"},{"entry":"\u2003\u2003cou = cou+1."},{"entry":"\u2003endif"},{"entry":"endfor"},{"entry":"endmemb = endmemb(0:cou-2,*)"},{"entry":"nemb = size(endmemb)"},{"entry":"nemb = nemb(1)"},{"entry":";==========NOW, OUTPUT THE ENDMEMBERS====="},{"entry":"gowav = fltarr(3,210) & lam = fltarr(210)"},{"entry":"openr,lun,\u2018d:\\forrad1\\gainoff\\95082400\\run07\\cr07m82.wav\u2019,\/get_lun"},{"entry":"readf,lun,gowar"},{"entry":"free_lun,lun"},{"entry":"lam(*) = 1000.*(gowav(1,*))"},{"entry":"openw,lun,\u2018d:\\endmems1.ascii\u2019,\/get_lun"},{"entry":"for i=0,209 do printf,lun,lam(i),endmemb(*,i),format=\u2018(17(g13.6,1x))\u2019"},{"entry":"free_lun,lun"},{"entry":"end"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"This algorithm's chief advantage is its speed. My IDL implementation of this algorithm run on a Pentium Pro 200 MHz computer takes about 2 minutes to generate endmembers for a 320\u00d7640 pixel by 210 wavelength data cube. The results compare very favorable to the slower methods mentioned above.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 1"},"The second advantage of this new method is that it is entirely automatic\u2014no user interaction is needed to select endmembers (this is part of what contributes to the algorithm's speed).","As mentioned above, there are various ways of doing the normalization of spectra. In addition, there are different ways of eliminating redundant pixels. Instead of throwing out highly correlated spectra, one could average them together. One could also see if one pixel had been flagged at multiple wavelengths and throw out similar ones flagged only once. Instead of calculating a correlation between spectra, one might also calculate the angle between vectors (the points in the data cloud) to check for similarity.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 9"},"While the invention has been described in its presently preferred embodiment it is understood that the words which have been used are words of description rather than words of limitation and that the claims may be made without departing from the scope and spirit of the invention in its broader aspects."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
