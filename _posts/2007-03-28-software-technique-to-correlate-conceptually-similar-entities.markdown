---
title: Software technique to correlate conceptually similar entities
abstract: Various technologies and techniques are disclosed for providing a framework with a common set of domain-specific entity identifier types that object models representing conceptually similar entities from a domain can use to correlate to model-specific object instances. A particular model-specific object instance of a particular one of the object models can be retrieved using a common set of domain-specific entity identifier types. An instance of a particular domain-specific entity identifier type can be retrieved from a corresponding one of the model-specific object instances. One or more extensibility mechanisms allow third parties to extend the set of domain-specific entity identifier types.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08813101&OS=08813101&RS=08813101
owner: Microsoft Corporation
number: 08813101
owner_city: Redmond
owner_country: US
publication_date: 20070328
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["In the world of computer programming, object models are application programming interfaces (APIs) and\/or classes that are used to represent specific types of information relating to some problem domain. Multiple object models frequently refer to the same domain of conceptual entity using their own internal representation. Individual object models are typically designed to facilitate some particular style of data access or algorithmic processing. Take, for example, a method object called \u201cMethod A\u201d that represents a specific function in some computer program. There might be a performance analysis tool that stores performance data over a period of time for a certain method object called \u201cMethod A\u201d. There might be a debugger that also stores debugging information for a method object called \u201cMethod A\u201d. There might also be source code written using a software development program that contains the actual implementation for \u201cMethod A\u201d. Each program uses its own model-specific object instances for referring to the same conceptual entity called \u201cMethod A\u201d.","A problem arises when a process wants to correlate the different objects corresponding to \u201cMethod A\u201d in a meaningful fashion. One approach that is sometimes taken is to independently recognize that they are referring to the same conceptual entity by invoking model-dependent application programming interfaces to retrieve the entities using model-dependent data extracted from the other model. For example, suppose that a debugger wants to use performance analysis data for a comparison. The debugger could ask the performance analysis tool for the data. The performance analysis tool would then analyze the performance record from the performance model, extract a method signature, recompose the method signature into a format that is acceptable to the debugger, and pass that information to the debugger. This solution is tedious and also only works if the object models make the data public and provide mechanisms for the entity data to actually be requested. When the data is actually private, or the object model does not expose a way of accessing that data, a client may not be able to correlate these models at all.","Various technologies and techniques are disclosed for providing a framework with a common set of domain-specific entity identifier types that object models representing conceptually similar entities from a domain can use to correlate to model-specific object instances. A particular model-specific object instance of a particular one of the object models can be retrieved using a common set of domain-specific entity identifier types. An instance of a particular domain-specific entity identifier type can be retrieved from a corresponding one of the model-specific object instances. One or more extensibility mechanisms allow third parties to extend the set of domain-specific entity identifier types.","In one implementation, an application programming interface is provided with an abstract entity identifier class, with domain-specific entity identifier types being required to derive from the abstract entity identifier class, thereby allowing object models representing a conceptually similar entity to use the domain-specific entity identifier types to correlate model-specific object instances.","This Summary was provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter.","For the purposes of promoting an understanding of the principles of the invention, reference will now be made to the embodiments illustrated in the drawings and specific language will be used to describe the same. It will nevertheless be understood that no limitation of the scope is thereby intended. Any alterations and further modifications in the described embodiments, and any further applications of the principles as described herein are contemplated as would normally occur to one skilled in the art.","The system may be described in the general context as a framework application that allows conceptually similar entities to be correlated, but the system also serves other purposes in addition to these. In one implementation, one or more of the techniques described herein can be implemented as features within a framework program such as MICROSOFT\u00ae.NET Framework, or from any other type of program or service that provides platforms for building applications. In another implementation, one or more of the techniques described herein are implemented as features with other applications that deal with object models each having their own manner of referencing the same conceptual entity.","In one implementation, a framework is provided that has application programming interfaces (APIs) for allowing conceptually similar entities to be correlated. The framework has a common set of domain-specific entity identifier types that object models representing conceptually similar entities from a domain can use to correlate to model-specific object instances. The term \u201cdomain-specific entity identifier types\u201d as used herein is meant to include identifiers implemented in an abstract class for the purpose of describing some conceptual entity in a particular domain. The term \u201cmodel-specific object instance\u201d is meant to include an object instance obtained from some specific model instance. Take, for example, the scenario that was previously described in the background. Suppose there is a performance analysis tool that stores performance data over a period of time for a certain method object called \u201cMethod A\u201d. Suppose also that there is a debugger that also stores debugging information for a certain method object called \u201cMethod A\u201d. Suppose also that there is source code written using a software development program that contains the actual implementation for \u201cMethod A\u201d. Each program uses its own model-specific object instances for referring to the same conceptual entity called \u201cMethod A\u201d. If some process wants to see the performance and debugger data for \u201cMethod A\u201d, the common set of domain-specific entity identifier types can be used in order to correlate these object instances together in a meaningful fashion.","As shown in , an exemplary computer system to use for implementing one or more parts of the system includes a computing device, such as computing device . In its most basic configuration, computing device  typically includes at least one processing unit  and memory . Depending on the exact configuration and type of computing device, memory  may be volatile (such as RAM), non-volatile (such as ROM, flash memory, etc.) or some combination of the two. This most basic configuration is illustrated in  by dashed line .","Additionally, device  may also have additional features\/functionality. For example, device  may also include additional storage (removable and\/or non-removable) including, but not limited to, magnetic or optical disks or tape. Such additional storage is illustrated in  by removable storage  and non-removable storage . Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Memory , removable storage  and non-removable storage  are all examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by device . Any such computer storage media may be part of device .","Computing device  includes one or more communication connections  that allow computing device  to communicate with other computers\/applications . Device  may also have input device(s)  such as keyboard, mouse, pen, voice input device, touch input device, etc. Output device(s)  such as a display, speakers, printer, etc. may also be included. These devices are well known in the art and need not be discussed at length here. In one implementation, computing device  includes framework application . Framework application  will be described in further detail in .","Turning now to  with continued reference to , a framework application  operating on computing device  is illustrated. Framework application  is one of the application programs that reside on computing device . However, it will be understood that framework application  can alternatively or additionally be embodied as computer-executable instructions on one or more computers and\/or in different variations than shown on . Alternatively or additionally, one or more parts of framework application  can be part of system memory , on other computers and\/or applications , or other such variations as would occur to one in the computer software art.","Framework application  includes program logic , which is responsible for carrying out some or all of the techniques described herein. Program logic  includes logic for providing a framework with a common set of domain-specific entity identifier types that a plurality of object models representing a conceptually similar entity can use to correlate model-specific object instances ; logic for providing one or more extensibility mechanisms to allow third parties to extend the set of domain-specific entity identifiers types ; logic for enabling the domain-specific entity identifier types to be extended by allowing one or more model-specific object instances to be provided for one or more domain-specific entity identifier types that a particular one or more of the object models did not originally support ; logic for enabling the domain-specific entity identifier types to be extended by allowing one or more domain-specific entity identifier types to be provided for model-specific object instances that a particular one or more of the object models did not originally support ; and other logic for operating the application . In one implementation, program logic  is operable to be called programmatically from another program, such as using a single call to a procedure in program logic .","Turning now to  with continued reference to , the stages for implementing one or more implementations of framework application  are described in further detail.  is a high level process flow diagram for framework application . In one form, the process of  is at least partially implemented in the operating logic of computing device . The process begins at start point  with providing a framework with a common set of domain-specific entity identifier types (unique or non-unique) that object models representing conceptually similar entities from a domain can use to correlate to model-specific object instances (stage ). The framework allows a particular model-specific object instance of a particular one of the object models to be retrieved using a common set of domain-specific entity identifier types (stage ). In one implementation, the correlation using the identifier types is independent of the model-specific object instance types (stage ). An instance of a particular domain-specific entity identifier type can be retrieved from a corresponding one of the model-specific object instances (stage ). The process ends at end point .",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 4","FIG. 4","FIG. 4","FIG. 4"],"b":["100","200","270","272","274","276","278","280"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 5","FIG. 5"],"b":["100","290","292","294","296","298"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 6","FIG. 5","FIG. 6"],"b":["100","310","312","314","316","318","320"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 7","FIG. 5","FIG. 7"],"b":["100","340","342","344","346"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIGS. 8-13","FIG. 1-7","FIG. 8"],"b":"400","ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["They are simple immutable value objects containing only simple data types","They provide \u201cvalue equality\u201d semantics so that two instances are equal if their values are equal","They contain no model-dependent information","They can be serialized and de-serialized","They define a data contract so they are not tightly coupled to a particular runtime type"]}}}},"In one implementation, all entity identifier classes derive from this common ModelIdentifier abstract base class. They typically offer additional data that a client can specify at instantiation time. Object models typically access these data through public properties exposed by those subclasses.",{"@attributes":{"id":"p-0035","num":"0039"},"figref":"FIG. 9","b":"500","ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":["An IModel can be either a root model (which has no parent model) or a sub-model (it is the child of another IModel)","It implements a method (e.g. IHandle GetModelHandle) to retrieve those sub-models using entity identifiers (the method returning a model handle to the sub-model).","It implements a method (e.g. ModelIdentifier GetModelIdentifier) to obtain one or more entity identifiers of the requested type."]}}}},{"@attributes":{"id":"p-0036","num":"0043"},"figref":"FIG. 10","b":"600","ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":{"@attributes":{"id":"ul0005-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":["It implements a de-referencing method (IModelDereference) that returns the actual IModel instance to which it logically refers","Model handles are simple immutable value objects","Model handles have \u201cvalue equality\u201d semantics","Model handles may be serialized and de-serialized","Model handles define a data contract so they do not depend on a specific runtime type"]}}}},"An entity identifier is a domain-specific symbolic reference that can be applied to multiple models sharing a set of related entity identifier types, sometimes called an ontology. On the other hand, a model handle is a soft reference to a single model-specific object instance. The model handle abstraction permits tools to refer to entities in other object models in a uniform way. It can also avoid holding any model-specific data objects. When the tool wants to interact with a model object, it obtains it by de-referencing the handle.",{"@attributes":{"id":"p-0038","num":"0050"},"figref":"FIG. 11","b":["700","700"]},"One implementation of IHandleModelService  aggregates all instances of ModelHandleFactory ( on ) and ModelIdentifierFactory ( on ), and delegates client requests to the appropriate one. Implementations of IModel that do not understand a particular entity identifier are expected to invoke IHandleModelService, thereby allowing third parties to extend them.",{"@attributes":{"id":"p-0040","num":"0052"},"figref":"FIG. 12","b":["800","800"],"ul":{"@attributes":{"id":"ul0007","list-style":"none"},"li":{"@attributes":{"id":"ul0007-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0008","list-style":"none"},"li":["The type of IModel it can produce","The type of ModelIdentifier it will accept","The type of IModel it requires for context","A model \u201ctag\u201d that uniquely identifies a particular implementation of the context IModel"]}}}},"The IHandleModelService implementation aggregates all ModelHandleFactory instances. When it receives a request for a model handle, it chooses the appropriate one based on the metadata listed above. It then delegates control to this factory to produce the requested model handle.",{"@attributes":{"id":"p-0042","num":"0058"},"figref":"FIG. 13","b":["900","900"],"ul":{"@attributes":{"id":"ul0009","list-style":"none"},"li":{"@attributes":{"id":"ul0009-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0010","list-style":"none"},"li":["The type of ModelIdentifier it can produce","The type of IModel for which it can produce this ModelIdentifier","The type of IModel it requires for context","A model \u201ctag\u201d that uniquely identifies a particular implementation of the context IModel"]}}}},"The IHandleModelService implementation aggregates all ModelIdentifierFactory instances. When it receives a request for an entity identifier, it chooses the appropriate one based on the metadata listed above. It then delegates control to this factory to produce the requested entity identifier.","Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather, the specific features and acts described above are disclosed as example forms of implementing the claims. All equivalents, changes, and modifications that come within the spirit of the implementations as described herein and\/or by the following claims are desired to be protected.","For example, a person of ordinary skill in the computer software art will recognize that the client and\/or server arrangements, user interface screen content, and\/or data layouts as described in the examples discussed herein could be organized differently on one or more computers to include fewer or additional options or features than as portrayed in the examples."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 5","FIG. 1"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 6","FIG. 1","FIG. 5"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 7","FIG. 1","FIG. 5"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
