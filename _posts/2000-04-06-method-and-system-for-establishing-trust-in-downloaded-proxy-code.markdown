---
title: Method and system for establishing trust in downloaded proxy code
abstract: A system consistent with the present invention enables a program in a distributed system to determine whether downloaded code is trustworthy before using the downloaded code to communicate with other programs or services in the distributed system. A client that downloads proxy code from a service can verify that both the service and the downloaded code are trustworthy before using the code to communicate with the service. “Trustworthy” code is code the client knows will enforce the client's security constraints in communicating with the service, e.g., mutual authentication, confidentiality, and integrity.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06901518&OS=06901518&RS=06901518
owner: Sun Microsystems, Inc.
number: 06901518
owner_city: Santa Clara
owner_country: US
publication_date: 20000406
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present application is related to and claims the benefit of U.S. Provisional Patent Application No. 60\/128,406, entitled \u201cRMI Security,\u201d filed Apr. 8, 1999, which is relied upon and is incorporated herein by reference.","The present invention relates generally to data processing systems and, more particularly, to using downloaded code to provide secure communication between a client and a remote service in a distributed system.","Today's distributed systems can be made up of various components, including both hardware and software. Nodes in distributed systems typically communicate via a network such as the Internet. One means of communication between programs in a distributed system is downloading code from one program to another. For example, a client (e.g., a program running on a node in a distributed system) can access a service running on a remote node by downloading code from the remote service.","A \u201cservice\u201d refers to a resource, data, or functionality that can be accessed by a user, program, device, or another service and that can be computational, storage related, communication related, or related to providing access to another user. Examples of services include devices, such as printers, displays, and disks; software, such as applications or utilities; information, such as databases and files; and users of the system.","In a distributed system implemented using the Java\u2122 programming language, services appear programmatically as objects, with interfaces that define the operations available from the service. In the Java\u2122 programming language, a \u201cclass\u201d provides a template for the creation of \u201cobjects\u201d (which represent items or instances manipulated by the system) having characteristics of that class. Thus, a class defines the type of an object. Methods associated with a class are generally invoked on the objects of the same class or subclass. The Java\u2122 programming language is described in by James Gosling, Bill Joy, and Guy Steele, Addison-Wesley, 1996, which is incorporated herein by reference.","In a distributed system that depends on downloaded code, there is the danger that the downloaded code may be untrustworthy. For example, the code could carry a virus or disguise its true source, causing the user of the downloaded code to disclose confidential information to an unknown party. Therefore, it is desirable to enable users in a distributed system to confirm that downloaded code is trustworthy.","A system consistent with the present invention enables a user in a distributed system to determine whether downloaded code is trustworthy before using the downloaded code to communicate with others in the distributed system. For example, if a client downloads code from a service, the client can verify that both the service and the downloaded code are trustworthy before using the code to communicate with the service. \u201cTrustworthy\u201d code is code that the client knows will enforce the client's security constraints (e.g., mutual authentication, confidentiality, and integrity) when communicating with the service.","In accordance with one implementation of the present invention, code is downloaded from a server, and a set of constraints to implement secure communication with the server is determined. Secure code is then used to verify that the downloaded code will enforce the set of constraints when the downloaded code is used to communicate with the server.","In accordance with another implementation of the present invention, a first proxy containing code for communication purposes is downloaded, and a second proxy containing code for communication purposes is obtained from the first proxy. A trustworthiness verification routine is used to determine whether the second proxy is trustworthy, and when it has been determined that the second proxy is trustworthy, the second proxy is used to determine whether a server is trustworthy. When it has been determined that the server is trustworthy, a trustworthiness verification routine is requested from the server by using the second proxy and this verification routine is then used to identify the trustworthiness of the first proxy. When it has been determined that the second proxy is trustworthy, that the server is trustworthy, and that the first proxy is trustworthy, the first proxy is used to invoke a method on the server.","A distributed system suitable for practicing methods and systems consistent with the present invention can be implemented using the Jini\u2122 architecture. A Jini\u2122 system is built around one or more lookup services that list the services available in the distributed system. When a service joins the network, it uses a process called discovery to locate the lookup service or services for the network. The service registers by passing a proxy object to each lookup service. The proxy object is a Java\u2122 object implementing the interfaces of the corresponding service. When a client (e.g., a program) wishes to use a service, the client interacts with the lookup service and downloads the proxy to facilitate use of the service. The Jini\u2122 architecture is described in more detail in Arnold, , Addison-Wesley (1999).","A system consistent with the present invention enables a program in a distributed system to determine whether downloaded code is trustworthy before using the downloaded code to communicate with other programs or services in the distributed system. For example, if a client downloads code from a service, the client can verify that both the service and the downloaded code are trustworthy before using the code to communicate with the service. \u201cTrustworthy\u201d code is code the client knows will enforce the client's security constraints in communicating with the service.","These constraints can include, for example, integrity, anonymity, mutual authentication, delegation, and confidentiality. The \u201cintegrity\u201d constraint ensures that messages will not be tampered with in transit, the \u201canonymity\u201d constraint permits the identity of the client to stay unknown to the service, and \u201cmutual authentication\u201d refers to the client and service verifying their identities to one another. The \u201cdelegation\u201d constraint allows the service to make calls to other computers using the client's identity, and the \u201cconfidentiality\u201d constraint ensures that messages are private, e.g., by using encryption.","The constraints attached to a proxy are included in the serialized version of the proxy. As part of RMI system , an object, such as a proxy, is converted into a serialized version of itself before being passed. The serialized object contains enough information to enable the recipient to identify and verify the Java\u2122 class from which the contents of the object were saved and to restore the contents to a new instance. Object serialization is explained in the Java\u2122 Object Serialization Specification, available at http:\/\/web2.java.sun.com\/products\/\/jdk\/1.3\/docs\/guide\/serialization\/spec\/serialTO C.doc.html, which is incorporated herein by reference. When a client trusts the downloaded code to enforce the client's security constraints and trusts the service, the client can trust communicating through the proxy to the service and can trust the service to do what the client asks, and not something harmful.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["100","100","102","104","106","108","108","102","110","112","114","116","118","110","142","120","122"]},"Computers  and  may be similarly configured, with computer  including memory , secondary storage device , and CPU , and computer  including memory , secondary storage device , and CPU . Memory  of computer  includes a service , and memory  of computer  includes a lookup service  that defines the services available in one part of distributed system . Lookup service  contains one proxy object for each service within that part of distributed system . Each \u201cproxy object\u201d corresponds to a service in the distributed system and implements interfaces corresponding to methods available from a service.","For example, if service  were a database service, the corresponding proxy object  would implement database interfaces such as \u201cfind\u201d or \u201csort.\u201d for a proxy to the database service. In response, lookup service  returns proxy object  corresponding to database service  to the client. Lookup services are explained in greater detail in U.S. patent application Ser. No. 09\/044,931, entitled \u201cDynamic Lookup Service in a Distributed System,\u201d which is incorporated herein by reference.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2","b":["142","136","140","140","202","204","136","142","140","140","136","142","140","136"]},"In this way, the Jini\u2122 architecture relies on downloaded code to provide services in a dynamic and flexible way. Once a client downloads a proxy object, the client invokes methods on the proxy to communicate with the remote service. However, the proxy may be implemented using code that the client does not trust. Before sharing any critical data with the service, the client needs to establish trust in the proxy, the service, or both.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3"},"With reference to , the exemplary method begins when the client downloads the proxy, P, from a lookup service (step ). The client then asks P for a second proxy to the service, P, by invoking a method on P corresponding to a method on the service (step ). The client examines the code in P to verify that P uses only trusted code (step ). If the client verifies P (step ), then the client uses P to authenticate the service by invoking a method on P (step ). If the service is authenticated (step ), the client then uses P to ask the service if the service trusts P's code, by invoking a method on P to obtain a proxy verifier from the service, and then passing P to the proxy verifier (step ). If the service trusts P (step ), then the client can trust P (step ). In this manner, the client uses local, trusted code to establish trust in a downloaded proxy.","The VerifyProxyTrust Method","The exemplary method described above will now be explained using the Java\u2122 RMI Security Subsystem, part of RMI system . The Security Subsystem defines classes and interfaces that ensure secure communication between remote objects. One class provided by the RMI Security Subsystem is the Security class, which includes the verifyProxyTrust method. The verifyProxyTrust method establishes trust in downloaded code and is defined as follows:",{"@attributes":{"id":"p-0028","num":"0027"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public static void verifyProxyTrust ("]},{"entry":[{},"\u2003Object proxy,"]},{"entry":[{},"\u2003SecurityConstraints constraints)"]},{"entry":[{},"throws RemoteException;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":["122","142","140"]},"When a remote service instantiates its proxy, the service can include the RemoteSecurity interface, which provides methods enabling a client to attach security constraints to the proxy or to query the service to determine the service's security constraints. The RemoteSecurity interface is defined as follows:",{"@attributes":{"id":"p-0030","num":"0029"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public interface RemoteSecurity {"]},{"entry":[{},"\u2003RemoteSecurity setClientConstraints ("]},{"entry":[{},"\u2003\u2003SecurityConstraints constraints);"]},{"entry":[{},"\u2003SecurityConstraints getClientConstraints( );"]},{"entry":[{},"\u2003SecurityConstraints getServerConstraints (String name,"]},{"entry":[{},"\u2003\u2003\u2003Class[ ] parameterTypes);"]},{"entry":[{},"\u2003\u2003throws NoSuchMethodException, RemoteException;"]},{"entry":[{},"\u2003boolean equalsIgnoreConstraints(Object obj);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"As explained above, the constraints can include, for example, integrity, anonymity, mutual authentication, delegation, and confidentiality. When the verifyProxyTrust method determines that the proxy will enforce the client's constraints by correctly implementing the RemoteSecurity interface, the proxy is \u201ctrusted.\u201d",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIGS. 4A and 4B"},"As shown in steps  to  of , the verifyProxyTrust method first determines whether the downloaded proxy is a secure RMI stub. A stub is one example of a proxy, created by the RMI System, that uses the RMI protocol to communicate with a service. A secure RMI stub is an instance of a class generated by the java.lang.reflect.Proxy class provided by the Java\u2122 programming language. The methods of the Proxy Class include Proxy.isProxyClass, which returns true if it is passed a proxy class that was generated by the Proxy Class, Proxy.getInvocationHandler, which returns the invocation handler associated with the proxy instance passed as its argument, and Proxy.getProxyClass, which generates a java.lang.Class object for a proxy given a class loader and an array of interfaces. These methods and the java.lang.reflect.Proxy class are explained in further detail in the \u201cJava\u2122 2 Platform, Standard Edition, v 1.3 API Specification,\u201d available at http:\/\/java.sun.com\/products\/jdk\/1.3\/docs\/api\/java\/lang\/reflect\/Proxy.html, and incorporated herein by reference.","The verifyProxyTrust method calls the Proxy.isProxyClass method, passing the class of the proxy as a parameter, to determine whether the proxy is an instance of a trusted generated Proxy class (step ). As described above, the Proxy.isProxyClass method will return true if and only if the specified class was dynamically generated to be a trusted proxy class.","If the Proxy.isProxyClass method returns true, the proxy is an instance of a trusted class, and the verifyProxyTrust method tests the invocation handler of the proxy to determine if it is an instance of a trusted class (step ). Each secure RMI stub has an invocation handler used to invoke methods on the proxy. The verifyProxyTrust method calls the local Proxy.getInvocationHandler method, passing the proxy as a parameter. The getInvocationHandler method returns the invocation handler of the proxy, and the verifyProxyTrust method then calls the local instanceof operator to determine whether the proxy's invocation handler is an instance of a local trusted class,","SecureInvocationHandler. The local trusted class SecureInvocationHandler is specified in the Security class in RMI . The corresponding local calls made by verifyProxyTrust are:",{"@attributes":{"id":"p-0036","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["Proxy.isProxyClass(proxy.getClass( ))","handler=Proxy.getInvocationHandler(proxy)","handler instanceof SecureInvocationHandler\n\nAs explained above, these methods are provided by the java.lang.reflect.Proxy class of the Java\u2122 programming language.\n"]}}}},"If the proxy is an instance of a trusted class and the invocation handler is secure, then each socket factory instance contained in the invocation handler is checked (step ). A socket is an end-point to a communication path between two processes in a network. A socket factory is an object that implements a method to create a new socket. Socket factories are described in more detail at http:\/\/java.sun.com\/products\/jdk\/1.3\/docs\/api\/java\/net\/SocketImplFactory.html. The class of each socket factory instance in the proxy is compared to a local list of trusted socket factory classes.","To obtain the list of trusted socket factory classes, the verifyProxyTrust method uses a local configuration database to obtain TrustVerifier. TrusterVerifiers are provided as part of the Java\u2122 RMI Security Subsystem in RMI system , and are defined as follows:",{"@attributes":{"id":"p-0039","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public interface TrustVerifier {"]},{"entry":[{},"\u2003boolean trustedConstraintClass(Class c);"]},{"entry":[{},"\u2003boolean trustedPrincipalClass(Class c);"]},{"entry":[{},"\u2003boolean trustedClientSocketFactoryClass(Class c);"]},{"entry":[{},"\u2003boolean trusted Proxy(Object proxy,"]},{"entry":[{},"\u2003\u2003\u2003SecurityConstraints constraints)"]},{"entry":[{},"\u2003\u2003throws RemoteException;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":["122","408","410"]},"Before continuing with the description of , it is important to understand the difference between a unicast and an activatable stub. An RMI stub can be either unicast or activatable, depending on how it was exported by the service it represents. A unicast stub works until its service goes down. By contrast, an activatable stub will still work after its service goes down because an activatable stub is capable of restarting the service, if necessary. Each activatable stub contains an Activation ID consisting of information needed for activating the stub's corresponding object, e.g., a remote reference to the object's activator and a unique identifier for the object. Activatable objects are explained in more detail in the Java\u2122  Platform, Standard Edition, v.1.2.2 API Specification, available at http:\/\/www.java.sun.com\/products\/jdk\/1.2\/docs\/api\/java\/rmi\/activation\/package-su mmary.html, incorporated herein by reference.","If the proxy is activatable, i.e., the proxy contains an Activation ID, (step ) then the verifyProxyTrust method takes additional steps to determine whether the proxy is a secure RMI activatable stub. The verifyProxyTrust method obtains an activator verifier by making a remote call, using the proxy's invocation handler, to the remote service's getActivatorVerifier method, passing the client constraints as parameters (step ). The getActivatorVerifier method is provided in the RMI system of an activatable service to enable a client to verify a proxy's Activation ID. The call to getActivatorVerifier returns an activator verifier plus optional codebase and signer information. The activator verifier is an object received from the service containing code that implements the verifyActivatorTrust method, explained below. The codebase information is the location from which the code, i.e., the activator verifier, should have been downloaded, e.g. a uniform resource locator (URL). The signer information identifies the creator or creators of the code, i.e., the activator verifier.","Because the verifier could have been downloaded, the verifyProxyTrust method checks that the activator verifier can be trusted using the codebase and signer information (step ). If the service returned codebase information, the verifyProxyTrust method calls a local RMIClassLoader.getClassAnnotation method, which returns the location where the activator verifier code was obtained. The verifyProxyTrust method compares that location to the codebase information from the service. If they are different, the activator verifier is not used because its code is not trusted. If one or more signers is specified by the service, the verifyProxyTrust method obtains the signers of the verifier by calling the local Class.getSigners method and compares them to the signers specified by the service. If they are different, the activator verifier is not used because its code is not trusted.","In this way, the verifyProxyTrust method uses local methods to confirm the activator verifier code, which may have been downloaded and therefore could be corrupted. If the service did not specify either codebase or signer information, the verifyProxyTrust method confirms that the activator verifier was not downloaded, i.e., that the activator verifier is local, and therefore trusted. To do this, the verifyProxyTrust method compares the classloader of the verifier's class to the context classloader of the current thread or an ancestor of the context classloader. If they are the same, then the activator verifier was not downloaded, and can be trusted.","Once the verityProxyTrust method ensures that the activator verifier can be trusted, as described above, it extracts the Activation ID from the stub and calls the verifyActivatorTrust method of the verifier, passing the Activation ID as a parameter (step ). The verifyActivatorTrust method will return normally if the service trusts the activation ID passed to it (step ). If any of these calls do not return normally, i.e., throws an exception, then the proxy is not a secure RMI activatable stub (step ), otherwise trust is established (step ).","Trusting a Proxy Other than a Secure RMI Stub","If the proxy is not a secure RMI stub, the client can still establish trust in the proxy. If the proxy's class has a method with the signature\n\n","In response, the remote service returns a proxy verifier plus optional codebase and signer information. The verifyProxyTrust method checks the proxy verifier code using the codebase and\/or signer information in the same way as described above with respect to the activator verifier. Once the verifyProxyTrust method ensures that the proxy verifier can be trusted, it makes a local call to the verifyProxyTrust method of the verifier, passing the proxy as a parameter. If any of these calls do not return normally, i.e., throws an exception, then the proxy is not trusted.","If the proxy is not a secure RMI stub and does not have the getSecureProxy method, then an ordered list of TrustVerifier instances is obtained from the local configuration database, as described above. The verifyProxyTrust method calls the trustedProxy method of each TrustVerifier instance, with the proxy and client constraints as parameters. The trustedProxy method returns true if the given proxy is known to be trusted to correctly implement the RemoteSecurity interface, and false otherwise. If any method returns true, then trust is established. If none returns true, trust is not established.","Although systems and methods consistent with the present invention are described as operating in a Jini\u2122 system using the Java\u2122 programming language, one skilled in the art will appreciate that the present invention can be practiced in other systems and other programming environments. Additionally, although aspects of the present invention are described as being stored in memory, one skilled in the art will appreciate that these aspects can also be stored on or read from other types of computer-readable media, such as secondary storage devices, like hard disks, floppy disks, or CD-ROM; a carrier wave from the Internet; or other forms of RAM or ROM. Sun, Sun Microsystems, the Sun Logo, Java\u2122, and Jini\u2122 trademarks are trademarks or registered trademarks of Sun Microsystems Inc. in the United States and other countries.","Other embodiments of the invention will be apparent to those skilled in the art from consideration of the specification and practice of the invention disclosed herein. It is intended that the specification and examples be considered as exemplary only, with a true scope and spirit of the invention being indicated by the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["This invention is pointed out with particularity in the appended claims. The above and further advantages of this invention may be better understood by referring to the following description taken in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 4A and 4B"}]},"DETDESC":[{},{}]}
