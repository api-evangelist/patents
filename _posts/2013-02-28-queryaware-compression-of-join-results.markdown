---
title: Query-aware compression of join results
abstract: A method is provided for compressing results of a join query. A join order of a result set is determined from the join query, where the result set includes a plurality of tuples. A plurality of dictionary entries for the result set is received. A nested hierarchy of dictionaries is created based on the join order and the dictionary entries. A plurality of encoded tuples is received. The nested hierarchy of dictionaries is used by a processor to decode the plurality of encoded tuples so as to produce the plurality of tuples of the result set.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09218354&OS=09218354&RS=09218354
owner: International Business Machines Corporation
number: 09218354
owner_city: Armonk
owner_country: US
publication_date: 20130228
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This patent application is a divisional of U.S. patent application Ser. No. 12\/984,324, entitled \u201cQuery-Aware Compression Of Join Results\u201d, filed on Jan. 4, 2011, the entire teachings of which being hereby incorporated by reference.","The present invention generally relates to database management systems, and more particularly relates to join queries.","Application programs often need to retrieve data from remote database servers using a data access API (application programming interface) such as JDBC (Java Database Connectivity). In the case of join queries, the result set (from the join) can be quite large. Therefore, transmitting the results from the server to the client can significantly increase latency delays and also affects the query response time.","In one embodiment a method for decompressing results of a join query is disclosed. According to the method, a join order of a result set comprising multiple tuples is determined from the join query. Dictionary entries for the result set are received, and a nested hierarchy of dictionaries is created based on the join order and the dictionary entries. Encoded tuples are received, and the nested hierarchy of dictionaries is used to decode the encoded tuples so as to produce the tuples of the result set.","In another embodiment, a computer program product for compressing results of a join query is disclosed. The computer program product comprises a computer readable storage medium having program code embodied therewith, the program code readable\/executable by a processor to perform a method. According to the method, a join order of a result set comprising multiple tuples is determined from the join query. Dictionary entries for the result set are received, and a nested hierarchy of dictionaries is created based on the join order and the dictionary entries. Encoded tuples are received, and the nested hierarchy of dictionaries is used to decode the encoded tuples so as to produce the tuples of the result set.","In yet another embodiment, an information processing system for compressing results of a join query is disclosed. The information processing system comprises a memory and a processor that is communicatively coupled to the memory. A result encoder is communicatively coupled to the memory and the processor. The result encoder is configured to perform a method. According to the method, a join order of a result set comprising multiple tuples is determined from the join query. Dictionary entries for the result set are received, and a nested hierarchy of dictionaries is created based on the join order and the dictionary entries. Encoded tuples are received, and the nested hierarchy of dictionaries is used to decode the encoded tuples so as to produce the tuples of the result set.","Other objects, features, and advantages of the present invention will become apparent from the following detailed description. It should be understood, however, that the detailed description and specific examples, while indicating various embodiments of the present invention, are given by way of illustration only and various modifications may naturally be performed without deviating from the present invention.","Various embodiments of the present invention will be discussed in detail hereinbelow with reference to the attached drawings.","Embodiments of the present invention compress the result sets of join queries for more efficient transmission. The join query is exploited in order to partition the join result set. The redundancy in the joined data is also exploited. For example, consider the simple case in which the query is a join between two tables, Table A and Table B. The join results comprise tuples with some subset of columns from Table A and another subset of columns from Table B. Without loss of generality, assume the tuples are of the form <columns(A), columns(B)>. As the results are scanned, a dictionary is maintained for each table; the same dictionary is maintained in synchronization. As the results are scanned, if a value for columns(A) is not in dictionary(A), the value is inserted into the dictionary and the value is transmitted in plaintext along with a flag. Otherwise the code for the value is transmitted. The process applies to the values of columns(B). As the stream of code is read, it is checked for a plaintext flag. If the flag exists, the code is treated as plaintext and inserted into the dictionary. Otherwise, a lookup is performed in the dictionary to decode the code. If the joins involve multiple tables, a join ordering can be exploited to perform cascading or nested encoding.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1","b":["100","102","104","106","108","110","104","112","114","114","112","114","108","102"]},"While some traditional compression methods use dictionaries to indicate how various data tokens are compressed, this embodiment of the present invention provides a novel \u201cnested dictionary\u201d  and  that is particularly suited for compressing join results of varying nesting complexity. In this embodiment, a result encoder  receives the join result  (which can be incremental) from the query server  and consults\/updates a local nested dictionary  to generate the compressed query result  as output. This compressed query result  is then transmitted over the network  and received by a result decoder  at the client side. The result decoder  decompresses the results using its own local nested dictionary . These decompressed results  (which can be incremental) are then passed to the query client .","While  shows the query  passing through the result decoder  and the query packet  passing through the result encoder , in some embodiments the decoder  and encoder  are situated in the transmission paths of the query client  and query server . However, this configuration is not required and the query  and packets  are not required to pass through these components during their transmission from the client  to the server .",{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIGS. 2-4","FIG. 2"],"b":["202","112","204","112","214","202","204","104","110","102","120","214"]},"As shown, the first table  comprises two columns, Col  and Col . The second table  comprises three columns, Col , Col , and Col . In this example, the issued query is a join of the two tables  and  with an equality condition between Col  and Col . The result set  is shown as a table with four columns, Col , Col\/ , Col , and Col .","If this result data table  were to be transmitted as shown in , the data would be about 400 bytes long (assuming 20 bytes per field). In particular, the result data table  comprises four columns of data and the following data would be transmitted.","(A,X,L,E)","(A,X,M,F)","(A,Y,L,F)","(B,X,L,E)","(B,X,M,F)","So with each field being 20 bytes, this results in approximately 400 bytes of data.","Instead, in this embodiment, the size of the transmitted result data table  is reduced\/compressed by maintaining a dictionary  and  that assigns a short identifier to each field value, as shown in Table 1 below. The result encoder  analyzes the result data table  and translates each tuple into a compressed format that comprises short identifiers and also generates dictionary entry information that is transmitted therewith. Table 1 shows one example of a dictionary  and  that is generated for the result data table  of . This example of a compressed format is (Dict_Entry_No\/Col, Dict_Entry_No\/Col, Dict_Entry_No\/Col, . . . Dict_Entry_No\/ColN). This format comprises a number of elements equal to the number of elements in the tuples, with each identifier\/value of this format identifying a dictionary entry (Dict_Entry_No) and where each position in the format corresponds to a given column of the result data table .","For example, the first tuple of the result data table  in  is (A,X,L,E). The result encoder  compresses this first tuple into a compressed format that comprises short identifiers such as (1,1,1,1). Note that because the original tuple (A,X,L,E) comprises four values the compressed format also comprises four values. The compressed tuple format (1,1,1,1) identifies to the result decoder  the dictionary entries to retrieve for decoding this compressed data, with each position in this format corresponding to a column in the result data table  and identifying which entry (e.g., the first or second entry) in the dictionary to use for the particular column. The compressed tuple format of \u201c(1,1,1,1)\u201d indicates that this tuple comprises the first entry in the dictionary for Col , followed by the first entry in the dictionary for Col , followed by the first entry in the dictionary for Col , followed by the first entry in the dictionary for Col .","Stated differently, each position within the compressed format corresponds to a column in the result data table . Starting from the leftmost element in the compressed format and moving to the right, the first position corresponds to Col , the second position corresponds to Col , the third position corresponds to Col , and the fourth position corresponds to Col. The identifier\/value at each position corresponds to the entry within the dictionary (e.g., the first entry) for the given column where the corresponding value of the original (uncompressed) tuple can be located. For example, a \u201c1\u201d in the first position of the compressed format indicates to the result decoder  to look in its dictionary for the value under the first entry for Col. As can be seen from Table 1, the result decoder  decodes (1,1,1,1) into the first tuple (A,X,L,E).","The result encoder  also generates dictionary entry information that is used to store information in a dictionary. Table 1 below shows one example of a dictionary maintained by both the encoder  and decoder  based on the dictionary entry information generated by the encoder . In this embodiment, each row of the table is in itself a separate dictionary. The set of rows within the table is a nested hierarchy of dictionaries based on the join order.",{"@attributes":{"id":"p-0032","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Tuple Dictionary"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Result Data Column","Entry 1","Entry 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Col1","A","B"]},{"entry":[{},"Col2\/3","X","Y"]},{"entry":[{},"Col4","L","M"]},{"entry":[{},"Col5","E","F"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"In this embodiment, the dictionary entries are generated in the formation of (Value, Row), where \u201cValue\u201d is a value within the tuple and \u201cRow\u201d identifies the row within the dictionary  where the value corresponding to \u201cValue\u201d is to be added. In this embodiment, each row of the dictionary  corresponds to a column in the result data table . For the first tuple of (A,X,L,E), the result encoder  generates dictionary entries (A,1), (X,2), (L,3), and (E,4), and adds these entries into its dictionary . The \u201cA\u201d in \u201c(A,1)\u201d indicates that value \u201cA\u201d is to be added to the dictionary  in the first row (corresponding to Col of the result data table ), as indicated by the \u201c1\u201d. The \u201cX\u201d in \u201c(X,2)\u201d indicates that value \u201cX\u201d is to be added to the dictionary  in the second row (corresponding to Col\/ of the result data table ), as indicated by the \u201c2\u201d. The \u201cL\u201d in \u201c(L,3)\u201d indicates that value \u201cL\u201d is to be added to the dictionary  in the third row (corresponding to Col of the result data table ), as indicated by the \u201c3\u201d. The \u201cE\u201d in \u201c(E,4)\u201d indicates that value \u201cE\u201d is to be added to the dictionary  in the fourth row (corresponding to Col of the result data table ), as indicated by the \u201c4\u201d. As can be seen from Table 1 above, the dictionary  only comprises one unique entry for each value in the result data table . Because these dictionary entries are associated with the first tuple (A,X,L,E), they are entered into the first entry location of the dictionary  (because no other entries have been added for the columns at this point).","In this embodiment, the dictionary entries (A,1), (X,2), (L,3), and (E,4) are transmitted before the compressed tuple (1,1,1,1) and, therefore, are received by the result decoder  prior to the compressed tuple. However, this is not required. When the decoder  receives these dictionary entries, it adds the corresponding information into its dictionary . Therefore, the dictionaries  and  of the encoder  and decoder  remain synchronized.","In this embodiment, as the encoder  scans the results, if a value is not in its corresponding dictionary the encoder  inserts the value into the dictionary, and transmits the value in plaintext along with a flag. Otherwise the encoder  transmits the code for the value. When the decoder  receives this data, it analyzes the received data to determine if there is a plaintext flag. If the flag exists, the decoder  treats this code as plaintext and inserts it into the corresponding dictionary. Otherwise, the decoder  performs a look up in the corresponding dictionary to decode the code.","For the second tuple (A,X,M,F) in the result data table  of , the result encoder  only needs to add \u201cM\u201d and \u201cF\u201d to the dictionary because \u201cA\u201d and \u201cX\u201d are already in the dictionary. Therefore, the result encoder  creates dictionary data items (M,3) and (F,4), which are transmitted in addition to the compressed tuple (1,1,2,2). The transmitted dictionary entry data indicates that \u201cM\u201d is added to the dictionary  as a second entry (since \u201cL\u201d has already been added in the first entry) in the third row of the result data table ; \u201cF\u201d is added to the dictionary  as a second entry (since \u201cE\u201d has already been added in the first entry) in the fourth row of the result data table .","The transmitted compressed tuple (1,1,2,2) indicates to the decoder  that the first element of the uncompressed tuple is the value, \u201cA\u201d, in the first dictionary entry in the first row corresponding to Col; the second element is the value, \u201cX\u201d, in first dictionary entry in the second row corresponding to Col\/; the third element is the value, \u201cM\u201d in the second dictionary entry in the third row corresponding to Col; and the fourth element is the value \u201cF\u201d in the dictionary second entry for the fourth row corresponding to Col. Therefore, when the result decoder  receives this compressed tuple (1,1,2,2), the decoder  uses its dictionary  to translate (1,1,2,2,) into (A,X,M,F), which is the second tuple of the result data table  of .","The encoder  performs similar operations for the remaining tuples (A,Y,L,F), (B,X,L,E), and (B,X,M,F) of the result data table . In particular, the dictionary entries and compressed tuple for (A,Y,L,F) are (Y,2) and (1,2,1,2); the dictionary entries and compressed tuple for (B,X,L,E) are (B,1) and (2,1,1,1); and the compressed tuple for (B,X,M,F) is (2,1,2,2). The last tuple (B,X,M,F) does not require any additional dictionary information because all field values of (B,X,M,F) are already stored in the dictionaries  and . Table 1 shows the data maintained by the dictionaries  and  after the encoder  has generated all of the necessary dictionary entries for the result data table  of . The format of the dictionary ensures that every unique value per column is transmitted only once, so as to reduce redundancy.","For the example shown in , the encoder  transmits the following as the compressed results  for the result data table  of .","4 col","(A,1), (X,2), (L,3), (E,4), (1,1,1,1)","(M,3), (F,4), (1,1,2,2)","(Y,2), (1,2,1,2)","(B,1), (2,1,1,1)","(2,1,2,2)","When the decoder  receives this compressed data it builds its dictionary  to comprise the same data as dictionary , and decodes the compressed data to obtain the tuples (A,X,L,E), (A,X,M,F), (A,Y,L,F), (B,X,L,E), and (B,X,M,F). Overall, due to this encoding, only 280 bytes (assuming each field is 20 bytes) of data need to be transmitted (including the dictionary data), which is a significant savings.","If a result table is a wide table with many columns, the encoder  of one embodiment also applies a second compression technique. This additional compression process significantly reduces the size of the transmitted data when the result set is very wide (many columns) and\/or the join is deeply nested. Considering again the example shown in , instead of encoding each column value separately, the encoder  of this embodiment encodes each tuple of each side of a join separately. In the example of , there are three tuples on the left side (Table ) of the join: AX, AY, and BX. There are also three tuples on the right side (Table ) of the join: XLE, XMF, and YLF. When the encoder  is going to transmit the first tuple (A,X,L,E), the encoder  first generates a dictionary entry for the left component \u201cAX\u201d in the first table  and a dictionary entry for the right component \u201cXLE\u201d in the second table .","Thus, in this embodiment the format of the dictionary entries is (Value, Row), where \u201cValue\u201d is a value within the tuple and \u201cRow\u201d identifies the row within the dictionary  and  where the value corresponding to \u201cValue\u201d is to be added. Further, in this embodiment, each row of the dictionary  and  corresponds to each side (e.g., left side or right side) of the join operation. Stated differently, each row corresponds to each table (Table 1  and Table 2 ) used in the join operation. These dictionary entries are \u201c(AX,1)\u201d and \u201c(XLE,2)\u201d, respectively.","These dictionary entries are then transmitted by the encoder  followed by the compressed tuple, which is now only \u201c(1,1)\u201d. The compressed tuple \u201c(1,1)\u201d indicates to the decoder  to select the value \u201cA,X\u201d in the first entry of the dictionary for the first table  (the left side of the join) and also select the value \u201cXLE\u201d in the first entry of dictionary for the second table  (the right side of the join). In other words, the compressed tuple, in this embodiment, has a format of \u201c(Entry_NO_Row_, Entry_No_Row_)\u201d. The first position of the compressed tuple corresponds to the first row of the dictionary  and  and comprises a value identifying which entry of the first row to select, and the second position of the compressed tuple corresponds to the second row of the dictionary  and  and comprises a value identifying which entry of the second row to select. The second tuple (A,X,M,F) simply becomes a dictionary entry (XMF,2) followed by the compressed tuple (1,2), and so on. The resulting dictionaries created by the encoder  and decoder  based on these dictionary entries is shown below in Table 2. Similar to Table 1 above, the set of rows within the table is a nested hierarchy of dictionaries based on the join order.",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Tuple Dictionary"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Result Data Column","Entry 1","Entry 2","Entry 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"Table 1 (left side)","AX","AY","BX"]},{"entry":[{},"Table 2(right side)","XLE","XMF","YLF"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"The encoder  transmits the following compressed results  for the result data table  of .","2 col","(AX,1), (XLE,2), (1,1)","(XMF,2), (1,2)","(AY,1), (YLF,2), (2,3)","(BX,1), (3,1)","(3,2)","When the decoder  receives this compressed data it builds its dictionary  to comprise the same data as dictionary , and decodes the compressed data to obtain the tuples (A,X,L,E), (A,X,M,F), (A,Y,L,F), (B,X,L,E), and (B,X,M,F). Because the example of  has a narrow result table as compared to a wide result table, the compression is slightly lower (e.g., 380 bytes assuming each field is 20 bytes) using this process. However, the compression is significantly greater when the result table is very wide and\/or the join is nested and\/or the columns are highly correlated, which lead to many identical tuples on either side.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 3","b":["120","202","204","214","302","314"]},"The example of  uses the first two tables  and  and the results table  of . The third table  in  comprises two columns Col  and Col . The new join condition is an equality between Col  of the results table  and Col  of the third table . The overall join result is shown as a new results table . One example of a set of nested dictionaries for the compression process discussed below is shown in Tables 3 and 4. In this embodiment, each row of the dictionaries in Tables 3 and 4 corresponds to each table used in the respective join operation associated therewith",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Tuple Dictionary 1 For Second Join"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Result Data Column","Entry 1","Entry 2","Entry 3","Entry 4","Entry 5"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":["Table 1 (left side)","ax","ay","bz","cx","cy"]},{"entry":["Table 2 (right side)","ER","ES","FR"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0062","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Tuple Dictionary 2 For First Join"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Result Data Column","Entry 1","Entry 2","Entry 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"Table 1 (left side)","AX(=a)","AY(=b)","BX(=c)"]},{"entry":[{},"Table 2 (right side)","XLE(=x)","XMF(=y)","YLF(=z)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"The first tuple in the results table  is (A,X,L,E,R). In order to compress this first tuple, the encoder  utilizes the second compression technique discussed above and creates dictionary entries (ax,1) and (ER,2) based on the uppermost join between table  and table . Here, \u201c(ax,1)\u201d represents the tuple (A,X,L,E) from the left side of the join (i.e., Table ) and \u201c(ER,2)\u201d represents the tuple (E,R) from the right side of the join (i.e., table ). In this example, (A,X,L,E) is itself the result of a join from tables  and . Therefore, the encoder  recursively encodes the tuple (A,X,L,E) by considering the left side (table ) and right side (table ) of that join operation. In other words, the \u201cax\u201d in (ax,1) represents \u201c(AX)(XLE)\u201d. Therefore, the encoder  creates the dictionary entries (AX,1.1) and (XLE,1.2) and updates its dictionaries for the left side (table ) and right side (table ) of the first join operation accordingly, as shown in Table 4.","Therefore, the overall encoding of the first tuple is (AX,1.1), (XLE,1.2), (ax,1), (ER,2), and (1,1). This indicates that \u201cAX\u201d and \u201cXLE\u201d are added to first join's dictionary (Table 4) in the first entry of the first row (corresponding to Table 1 ) and the first entry of the second row (corresponding to Table 2 ), respectively. The elements \u201c1.1\u201d and \u201c1.2\u201d of (AX,1.1), (XLE,1.2) are exemplary identifiers that indicate that the preceding element (such as \u201cAX\u201d and \u201cXLE\u201d, respectively) is to be placed in the dictionary (see Table 4) associated with the first join operation for the left row and the right row, respectively. In other words, the \u201c1.1\u201d and \u201c1.2\u201d value identify the table from which \u201cAX\u201d and \u201cXLE\u201d came.","The element \u201cax\u201d in the first position of \u201c(ax,1)\u201d comprises two positions, a first position comprising \u201ca\u201d and a second position comprising \u201cx\u201d. The first position corresponds to the first element \u201cAX\u201d in the first dictionary entry (AX,1.1) and the second position corresponds to the first element \u201cXLE\u201d in the second dictionary entry (XLE,1.2) of the transmitted compressed tuple. The element \u201cax\u201d represents the concatenation of the first entry (AX) of left the lower join side (table ) and the first entry (XLE) of the right lower join side (table ). The \u201c1\u201d in the second position of \u201c(ax,1)\u201d indicates that element \u201cax\u201d is to be added to an entry in the first row in the upper join dictionary (See Table 3). Therefore, based on this format, when the decoder  receives this transmitted dictionary entry information along with the compressed tuple and detects (ax,1), it knows to associate \u201ca\u201d with \u201cAX\u201d and \u201cx\u201d with \u201cXLE\u201d in its dictionaries.","The element \u201cER, 2\u201d indicates that \u201cER\u201d is to be added to an entry in the second row of the upper join's dictionaries, as shown in Table 3. The compressed tuple (1,1) represents a concatenation of the first entry (ax) of the left upper join side (table ) and the first entry (ER) of right upper join side (table ). Therefore, the first position in the compressed tuple (1,1) corresponds to the dictionary associated with the upper join dictionary (Table 3) and the value at the first position corresponds to the entry number associated with the first row for obtaining a value. Because a \u201c1\u201d exists at the first position of the compressed tuple (1,1), this indicates to the decoder  that the first entry is to be selected from the first row of the upper join dictionary (Table 3), which comprises \u201cax\u201d. In this embodiment, the entries for the first row of the upper join dictionary can comprise a pointer or any other type of mapping to the entries of the first and second rows of the lower join dictionary. Thus, the dictionaries are nested and comprise a set of leaf level dictionaries and a set of intermediate level dictionaries. The set of leaf level dictionaries map data tuple fragments to a first set of code and the set of intermediate level dictionaries map a tuple created from the first set of code to a second set of code that is smaller than the first set of code.","The second position in the compressed tuple (1,1) corresponds to the dictionary associated with the lower join dictionary and the value at the second position corresponds to the entry number associated with the second row for obtaining a value. Because a \u201c1\u201d exists at the second position of the compressed tuple (1,1), this indicates to the decoder  that the first entry is to be selected from the second row of the lower join dictionary, which comprises \u201cXLE\u201d.","Returning now to second result table , the encoder  encodes the second tuple (A,X,L,E,S) as (ES,2) and (1,2). As the encoder  generates the dictionary entries it adds this dictionary information into its dictionaries . The encoder  only generates a dictionary entry of (ES, 2) because dictionary entries have already been generated for \u201cAX\u201d and \u201cXLE\u201d. Because \u201cES\u201d comes from the right side (table ) of the upper join, the dictionary entry comprises a \u201c2\u201d in the second position. This indicates that \u201cES\u201d is to be added to the dictionary for the upper join in the second entry for Col. The compressed tuple (1,2) indicates to the decoder  that the first entry value, \u201cax\u201d, for Col of the lower join dictionary and the second entry value, \u201cES\u201d, for Col of the upper join dictionary are to be used to decode this compressed tuple. Therefore, when the decoder  receives (ES,2) and (1,2), it enters appropriate dictionary information based on the dictionary entry (ES,2) and decodes the compressed tuple of (1,2) into (A,X,L,E,S). Even though \u201cax\u201d is equal to (AX)(XLE) and the other decoded element is equal to (ES), the decoded result is not (A,X,X,L,E,E,S) because a join operation has be performed. Therefore, the decoded result is (A,X,L,E,S).","The above processes are performed on the remaining tuples and the encoder  transmits the following information to the decoder .","2 col","(AX,1.1), (XLE,1.2), (ax,1), (ER,2), (1,1)","(ES,2), (1,2)","(XMF,1.2), (ay,1), (FR,2), (2,3)","(AY,1.1), (YLF,1.2), (bz,1), (3,3)","(BX,1.1), (cx,1), (4,1)","(4,2)","(cy,1), (5,3)","When the decoder  receives this set of information comprising dictionary entries and compressed tuples, it builds its dictionaries  to decode the compressed tuples. For example, the decoder  translates (1,1) into (A,X,L,E,R), (1, 2) into (A,X,L,E,S), (2,3) into (A,X,M,F,R), (3,3) into (A,Y,L,F,R), (4,1) into (B,X,L,E,R), (4,2) into (B,X,L,E,S), and (5,3) into (B,X,M,F,R).",{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 4","FIG. 3"],"b":["402","404"]},"At line  a result tuple T is obtained by joining tables T and T. For example, a first result tuple of T=(A,X,L,E,R) is obtained by joining (A,X,L,E) and (E,R), where (A,X,L,E)=T and (E,R)=T. A recursive encoding function is then called beginning at line . This recursive encoding function spans from line  to line . At line  a determination is made as to whether T is in a base table (e.g., a table used in the join operation). If so, an identifier n for T in dictionary join_id is obtained, where dictionary join_id identifies the table from which T came from. If this Tuple T is not in the dictionary, then a dictionary entry such as (AX, 1.1) in the format of ((T, join_id), n) is returned at line . Otherwise a dictionary entry is not returned at line .","If T is not in the base table, then the process goes to the else branch , where T=Jx(T,T) where x=join_id. For example, the tuple (A,X,L,E,R) is not in a base table. Therefore, for tuple (A,X,L,E,R) the else branch  is performed so that recursive encoding functions (line ) are called for each of the join components T and T of tuple (A,X,L,E,R) at lines  and , respectively. The output of these recursive encoding operations occurs at lines  and  based on whether identifiers are already in the dictionary (lines  and ). For example, recursive encoding functions are called for (A,X,L,E) and (E,R), with the recursive encoding function being performed on the \u201c(A,X)\u201d and \u201c(X,L,E)\u201d components of (A,X,L,E). The result of this recursive encoding process for the tuple (A,X,L,E,R) comprises the dictionary entries of (AX,1.1), (XLE,1.2), (ax,1) and (ER,2) with a compressed tuple (1,1).","Thus, the compression technique for nested joins takes advantage of the join nesting information to provide a more efficient compression result than conventional techniques. Assuming that each field is 20 bytes, an uncompressed transmission would be around 700 bytes (35 fields\u00d720 bytes). However, with the compression technique explained above with respect to , the transmission size is 460 bytes. This technique can be extended to arbitrarily nested joins. Also, as the amount of nesting increases, the compression provided by the above compression technique also increases.","The various compression techniques discussed above are fully incremental in that one tuple can be transmitted after the other (together with some dictionary entries). Thus, the client can receive and decode these tuples incrementally via the decoder . This allows for overlap between decoding, tuple processing, and transmission, so as to reduce the overall response time. Traditional compression has less information about the result set table to be compressed and, therefore, is much less beneficial as compared to embodiments of the present invention. Specifically, conventional compression techniques do not comprise or utilize information regarding the join nesting that led to the result set. The various compression techniques of explained above can be combined or can be mixed in further embodiments to generate the compressed result.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":["FIG. 5","FIG. 5"],"b":["502","504","120","110","104","504","120","506","120","508","120","102","512"]},{"@attributes":{"id":"p-0085","num":"0084"},"figref":["FIG. 6","FIG. 6"],"b":["602","604","124","102","104","604","124","606","124","608","124","120","110","610","124","612","514"]},{"@attributes":{"id":"p-0086","num":"0085"},"figref":["FIG. 7","FIG. 1"],"b":["700","700"]},"The information processing system  includes a computer . The computer  has a processor(s)  that is connected to a main memory , mass storage interface , and network adapter hardware . A system bus  interconnects these system components. The main memory , in this embodiment, comprises the encoder (or the decoder), their components, and the nested dictionaries.","Although illustrated as concurrently resident in the main memory , it is clear that respective components of the main memory  are not required to be completely resident in the main memory  at all times or even at the same time. In this embodiment, the information processing system  utilizes conventional virtual addressing mechanisms to allow programs to behave as if they have access to a large, single storage entity, referred to herein as a computer system memory, instead of access to multiple, smaller storage entities such as the main memory  and data storage device . The term \u201ccomputer system memory\u201d is used herein to generically refer to the entire virtual memory of the information processing system .","The mass storage interface  is used to connect mass storage devices, such as mass storage device , to the information processing system . One specific type of data storage device is an optical drive such as a CD\/DVD drive, which may be used to store data to and read data from a computer readable medium or storage product such as (but not limited to) a CD\/DVD . Another type of data storage device is a data storage device configured to support, for example, NTFS type file system operations.","Although only one CPU  is illustrated for computer , computer systems with multiple CPUs can be used equally effectively. Embodiments of the present invention further incorporate interfaces that each includes separate, fully programmed microprocessors that are used to off-load processing from the CPU . An operating system included in the main memory is a suitable multitasking operating system such as any of the Linux, UNIX, Windows, and Windows Server based operating systems. Embodiments of the present invention are able to use any other suitable operating system. Some embodiments of the present invention utilize architectures, such as an object oriented framework mechanism, that allows instructions of the components of operating system to be executed on any processor located within the information processing system . The network adapter hardware  is used to provide an interface to a network . Embodiments of the present invention are able to be adapted to work with any data communications connections including present day analog and\/or digital techniques and any future networking mechanism.","Although the exemplary embodiments of the present invention are described in the context of a fully functional computer system, those of ordinary skill in the art will appreciate that various embodiments are capable of being distributed as a program product via CD or DVD, CD-ROM, or other form of recordable media, or via any type of electronic transmission mechanism.","The flowcharts and block diagrams in the figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods, and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical function(s). In some alternative implementations, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. Also, each block of the block diagrams and\/or flowchart illustration, and combinations of blocks in the block diagrams and\/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions.","Aspects of the present invention may be embodied as a system, method, or computer program product. Accordingly, aspects of the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.), or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201ccircuit,\u201d \u201cmodule\u201d, or \u201csystem.\u201d Furthermore, aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.","Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. A computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device.","A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electro-magnetic, optical, or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate, propagate, or transport a program for use by or in connection with an instruction execution system, apparatus, or device.","Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.","Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the \u201cC\u201d programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).","Aspects of the present invention have been discussed above with reference to flowchart illustrations and\/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and\/or block diagrams, and combinations of blocks in the flowchart illustrations and\/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","These computer program instructions may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function\/act specified in the flowchart and\/or block diagram block or blocks.","The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein, the singular forms \u201ca\u201d, \u201can\u201d and \u201cthe\u201d are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms \u201ccomprises\u201d and\/or \u201ccomprising,\u201d when used in this specification, specify the presence of stated features, integers, steps, operations, elements, and\/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and\/or groups thereof.","The description of the present invention has been presented for purposes of illustration and description, but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiments above were chosen and described in order to best explain the principles of the invention and the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIGS. 2 and 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 7","FIG. 1"]}]},"DETDESC":[{},{}]}
