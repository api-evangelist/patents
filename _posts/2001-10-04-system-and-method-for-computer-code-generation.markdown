---
title: System and method for computer code generation
abstract: The invention provides a system and method for computer code generation that can be used to generate code and configuration files from any data source. In accordance with one embodiment of the invention a Generator Framework provides a common set of standards and APIs through which designs may be input. The purpose of the Generator Framework is to unify the code generation techniques implemented in products such as the Builder products from BEA Systems, Inc., by introducing sufficient abstraction levels. Built-in rules are introduced in the Generator Framework, and a data navigation layer isolates the Generator Framework from the data sources used. Filters can be added to the framework to transform data. Notifiers are used by the Generator Framework to notify external components about the generation process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06973640&OS=06973640&RS=06973640
owner: BEA Systems, Inc.
number: 06973640
owner_city: San Jose
owner_country: US
publication_date: 20011004
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CLAIM OF PRIORITY","COPYRIGHT NOTICE","FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Introduction","EXAMPLE","EXAMPLE","EXAMPLE","EXAMPLE","EXAMPLE","EXAMPLE"],"p":["This application claims priority from provisional application \u201cSYSTEM AND METHOD FOR COMPUTER CODE GENERATION\u201d, Application No. 60\/238,559, filed Oct. 4, 2000, and \u201cSYSTEM FOR SOFTWARE APPLICATION DEVELOPMENT AND MODELING,\u201d Application No. 60\/238,561, filed Oct. 4, 2000, and is related to \u201cSYSTEM FOR SOFTWARE APPLICATION DEVELOPMENT AND MODELING,\u201d application No. 09\/970,917, Inventors Todd Little and Loren Konkus, filed Oct. 4, 2001, all of which are incorporated herein by reference.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","The invention relates generally to computer software development and specifically to a system and a method for generating computer code for software applications.","The increasingly important field of software development brings with it the ever more common question\u2014who can we get to actually do the software coding? Software developers or coders are in high demand, and their skills demand premium salaries. As such the software generation or development process is a major factor to consider for any company that relies on or uses software for it's day-to-day business needs. This issue is even more relevant to those companies who support the software development process-companies such as BEA Systems, Inc, IBM Corporation, and Microsoft Corporation who develop software development products, suites and tools. In order to maximize the benefits of their products to their end customers, these companies must develop tools that allow a software developer to minimize the amount of time necessary to finish a particular software project, while at the same time maximizing the options available to the developer to create a quality product. Some tools are also particularly geared to helping junior or beginning developers, who may not be as experienced, to successfully compete against more established and skilled software architects.","Given the importance of software development to the global industry, and the demands that it should be relatively painless, easy to work with, and that it make optimal use of time and resources, it seems natural to want to develop a software generation tool or system, that automatically generates software code in accordance with some preset or preordained wishes of a developer. This allows the software architect or developer to concentrate on the \u201cbig picture\u201d, and to envisage the functioning of the software application as a whole, without undue regard to the intricacies of code development.","To this end, many tools allow the architect to develop a model or plan of the desired software application and to use this plan as a blueprint for subsequent software development. Similar to the way in which an architect designs blueprints for a building, software designers also design blueprints for their complex software applications. And just as a building architect likes to be able to test those blueprints for structural soundness, using for example a modeling or analysis system to test each aspect of the design, software architects also like to test their software blueprints for reliability, scalability, optimal use of resources, and good software design. As the complexity of a particular project increases, so too does the need for a reliable, accurate model. The software industry has developed several modeling techniques to address this need, one of which is the Unified Modeling Language (UML), a nonproprietary language defined in the Object Management Group Unified Modeling Language Specification, hereby incorporated by reference. UML provides software architects with a standardized language for specifying, constructing, visualizing and documenting the artifacts of a complex software system. The UML specification is a successor to three earlier object-oriented methods, Booch, Object Modeling Technique (OMT), and Object Oriented Software Engineering (OOSE), and includes additional expressiveness to handle more complex modeling problems, not readily handled by prior techniques.","Some of the features inherent in UML are: Formal definition of a common object analysis and design (OA&D) metamodel to represent the semantic of OA&D models, including static, behavioral, usage and architectural models, Interface Definition Language (IDL) Specifications for mechanisms for model interchange between OA&D tools, which includes a set of IDL interfaces that support dynamic construction and traversal of a user model; and, easily readable notation for representing OA&D models, most commonly a graphic syntax for consistently expressing UML semantics. As such the UML is more correctly considered a visual modeling language rather than a visual programming language. Because of its open standard and widespread industry use it serves to lower the cost of training and retooling when changing between projects and organizations, and provides opportunity for new integration between tools, processes and domains.","Some tools have attempted to combine the design aspects of a UML-based design system, with code generation functionality, to better assist the software developer in code design and generation. An example of this type of tool is the Builder range of products from BEA Systems, Inc, San Jose, Calif., that can be used to build applications, primarily in C or C++, and primarily for the Tuxedo server product, although other types of application can be built, and in other languages. A problem with most of these types of product can that they tend to proprietary in nature, or geared specifically toward code generation for a particular species of code type or server. If the developer or architect must work across platforms on a particular project they often need to learn the specific code generation techniques for those platforms. This in turn consumes development time, and adds to both the learning and maintenance time required to manage the various platform tools. The overall situation ends up being not much more useful than if no tools were used.","It would be more useful if there existed a uniform code development or generation system, that was generic enough to be used with a wide variety of platforms and technologies, yet could be made specific enough in those cases in which a detailed integration with the product was needed.","The invention tackles the demand for a software development and code generation environment that combines the ability to act generically across a wide variety of platforms, yet can be customized for each individual product as required. Roughly described, the invention provides a framework, that supports a system and a method for computer code generation, which can in turn be used to generate code and configuration files from any data source. In accordance with one embodiment of the invention a Builder Generator Framework (or simply a Generator Framework) provides a common set of standards and application programming interfaces (APIs) through which designs may be input. The purpose of the Generator Framework is to unify the code generation techniques implemented in products such as the Builder products from BEA Systems, Inc., by introducing sufficient abstraction levels. Built-in rules are introduced or plugged-in into the generator framework, and a data navigation layer or interface isolates the generator framework from the data sources (and the underlying software products, applications, development suites or servers) used. Filters can be added to the framework to transform data, while notifiers are used by the generator framework to notify external components about the generation process.","Roughly described, the invention provides a system and method for computer code generation that can be used to generate code and configuration files from any data source. As referred to herein, a Generator Framework is used to unify the code generation techniques implemented in products such as the Builder products from BEA Systems, Inc., by introducing sufficient abstraction levels. When used in the context of the Builder products, the framework may be referred to as the Builder Generator Framework, although it will be evident to one skilled in the art that the systems and techniques described herein have application beyond the products described, which are listed for illustrative purposes and to show the operation of the invention in an everyday setting.","The following terms are used herein, and have the appropriate meanings and equivalents known to one skilled in the art:","Design Pattern\u2014A Design Pattern names and identifies a common object oriented design structure.","IDL\u2014Interface Definition Language, as defined by the Common Object Request Broker Architecture and Specification.","Interface Repository\u2014An interface repository (or simple repository) contains the definitions of the interfaces that determine client\/server contracts.","The Generator Framework provides a common set of standards and application programming interfaces (APIs) to generate code and configuration files from any data source. A primary goal in developing the Generator Framework is to unify the code generation techniques implemented in the Builder family of products, by introducing sufficient abstraction levels. Built-in (or generic) rules are introduced in the generator framework. A data navigation layer isolates the generator framework from the data sources used. Filters can be added to the framework to transform data. Notifiers are used by the generator framework to notify external components about the generation process.","The Generator Framework is intended to be used in development products such as those produced by BEA Systems, Inc. which includes their Builder family of products. BEA Builder is designed to enable companies to leverage the development skills of their existing programming staff, while substantially reducing the time and costs associated with implementing new applications, such applications being then used primarily for the BEA Tuxedo platform. BEA Builder is a suite of five products which address the key aspects of client-side and server-side application development. These include:","BEA Active Expert\u2014A tool that allows the use of popular Windows development tools to create BEA TUXEDO client applications.","BEA C++ Expert\u2014A tool that assists the programmer in writing BEA TUXEDO servers and clients using C++.","BEA Contract Repository\u2014A central repository for the storage of interface information for server-side BEA TUXEDO application components.","BEA Rose Expert 2.0\u2014A plug-in to the Rational Rose development tool that allows the application designer to leverage the Rose object design environment to build BEA TUXEDO servers and clients using C++.","BEA Configuration Expert 2.0\u2014A tool to quickly and simply generate BEA TUXEDO configuration files without having to know the specific configuration file formats.","This robust suite of products helps enable rapid development of BEA TUXEDO applications and encompasses the full set of development tasks, allowing the developer to continue to use their tool of choice, while filling in the gaps, augmenting standard development tools to provide the essential capabilities needed to do both client and server side business application development. The Generation Framework architecture is also intended to be flexible enough to be reused in other BEA products, such as BEA Repository, but it will be evident to one skilled in the art that the architecture has applications beyond theses examples. Although the Generator Framework architecture does not decide upon or define the implementation language used, code examples given herein are in JAVA. These examples can easily be transposed to C or C++.","Within this document, the following conventions are used within this document when displaying UML diagrams:","Interfaces are in Italic","Abstract classes are in Bold Italic","Concrete classes are in Bold.","Generator Architecture","The Generator Framework architecture may be used and customized in several Builder products, such as the Active Expert, C++ Expert, Rose Expert, Configuration Expert and Ice Crystal products. This document describes the architecture of a common Generator Framework, in which the abstraction levels are raised to integrate different tools and types of generation (C++, UBBconfig files, etc.); and different data sources (Contract Repository, Configuration Repository, etc.)",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 1","FIG. 5","FIG. 1"]},"The Data Source  is the place where the data used for the generation comes from. It is usually considered as a repository (e.g. Builder Contract Repository, CORBA Interface Repository, etc . . . ). The data source may be stored on any temporary, permanent or semipermanent storage device, hereinafter referred to simply as a storage device. Such storage devices may include memory devices, magnetic devices, hard (fixed) disks, and equivalent storage mechanisms. When the data source is taken directly from a software product or application it may be read directly or in real-time from that application and not e stored as any discrete file or record.","The Output Files  are the result of the generation. The output files may be output, written to, or stored on any temporary, permanent or semipermanent storage device, hereinafter referred to simply as a storage device, such as described above. When the output files are intended to be sent directly to another software application they may be sent directly or in real-time to that application and not e stored as any discrete file or record.","Templates  are text files containing both instructions to drive the generation process and pieces of static code that need to be generated.","Rules can be internal () or external () to the framework, and are pieces of logic that implement template instructions. Rules are used to generate output dynamically when static template code is not appropriate.","Filters can be internal () or external () pieces of logic invoked from rules and used to transform data.","Conditions  are external pieces of logic invoked from rules used to evaluate conditions. Conditions are used to generate code depending on some specific conditions.","Notifiers  are external pieces of logic used when a rule is invoked. This allows external components to be notified of the progress of the generation process.","The Generator Framework is composed of a set of classes providing generation abstractions, using a data source as input, template files and external specific rules to drive the generation process against the data sources, and producing one or many output files. The Generator Framework itself is composed of the following elements:","A Parser  parses template files and invokes appropriate rules (built-in or specific). The Parser is also the place where all the plug-ins are registered: Rules, Filters, Conditions and Notifiers.","A Data Navigation Layer  acts as an abstraction to the data source, by providing navigational capabilities inside the data source. This layer implements the Facade design pattern, and exposes only the navigation primitives, not the details of the data source. This and other design patterns are described in Design Patterns, Gamma et al. Addison Wesley, hereby incorporated by reference.","Built-in Rules  provide basic functions to query symbol values from the data source, navigate through the data source, and open and close files.","Built-in Filters  provide generic transformation capabilities, such as lowercase\/uppercase conversion.","Data Navigation Layer ",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 2","b":["140","142","144","146"]},"The Parser  provides functions to manipulate the scope stack, such as pushing a new scope on the stack, popping the scope stack, and getting the current scope. The model for the data navigation layer is based on an object-oriented model for data. Scope represents objects from the data source, which have string attributes, accessed through attribute related functions; and references (relationships or pointers to other objects), accessed through reference related functions.","Symbol Naming","A symbol name is a name for an attribute (simple data) or a reference (related scope), and can be absolute or relative. An absolute symbol name is composed of the scope name and the relative symbol name, for example Interface::name. A relative symbol name can be simple or composed. A simple symbol name is just an identifier, such as \u201csrvList\u201d. A composed symbol name contains several reference names separated by dots and a simple symbol name used to access a related scope symbols. For instance, getting the module name from the operation scope in the Contract Repository would be done using the following symbol:","interface.module.name","If a module and an interface scopes have been pushed on the scope stack when parsing, the same name can be written:","Module::name","The General form of a symbol name is:","[<ScopeName>::][<ReferenceName>.]*<Name>","Element Cardinality","Attributes and references can be single or multi-valued. This impacts the usage of the Scope API, because it is not semantically possible to query individually an attribute or a reference which is multi-valued. The Scope API defines functions to both query single and multi-valued attributes and references. Single valued attributes and references are queried by functions that return directly the requested value (character string or scope). Multi-valued attributes and references are queried by functions that return an iterator of character strings or scopes. The Scope API provides an isMultiple( ) function that checks if a symbol name corresponds to a single or multi-valued attribute or reference.","Accessing Data Elements","The Scope interface implements a getValue( ) method to get the value of a single-valued attribute. This method accepts a relative symbol name only. If the attribute is multi-valued, this function throws an exception. In the following example, the scope method getValue( ) is used to return the type of a parameter (for example \u201cin\u201d, \u201cout\u201d or \u201cinout\u201d) in IDL generation:",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"String parameterType ="]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{}," currentScope.getValue(\u201cparamType\u201d);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Iterator i=currentScope.values(\u201cportNumbers\u201d);","Because the scopes are stacked by the parser, the value of a symbol can also be queried to the parser itself, asking the value of the symbol to the top scope on the stack, then to the previous scope, and so on. When querying symbol values from the parser, both absolute and relative symbol names can be used. The parser itself implements a getValue( ) and a values( ) methods, which retrieve directly the corresponding attribute value(s) if the symbol name is absolute; and retrieve the value(s) of the attribute of the current scope (i.e. the scope at the top of the scope stack) if the symbol name is relative.\n\nScope Navigation\n","Scope Navigation is performed by means of pointers or pointer-like references. A reference provides access to a list of (sub-)scopes related to the current scope. Similarly to the attribute names, reference names are either relative or absolute. For instance, in IDL generation, a Module scope gives access to an \u201cinterface list\u201d reference, which provides access to the interfaces of the module. The relation between the scope navigation and the data source navigation is shown in FIG. . The scope method getScope( ) takes a reference name as input and returns the related scope. If the reference is multi-valued, this functions throws an exception. The following shows an example:",{"@attributes":{"id":"p-0060","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Scope moduleScope ="]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"interfaceScope.getScope(\u201cmodule\u201d);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Iterator i=moduleScope.scopes(\u201cinterfaces\u201d);","Similarly, the parser allows access to references through the scope stack by providing a getScope( ) and scopes( ) methods, accepting both absolute and relative reference names. For instance, this allows access to the module interface list at the operation scope level, by calling:","parser.scopes(\u201cModule::interfaceList\u201d);","Rules","In the template files, a rule is represented by a string delimited by separators, containing a rule name and zero or more arguments. A rule name is an identifier containing uppercase characters. A rule argument contains text (which may also contain nested rules). In terms of regular expressions, a rule has the following syntax:","$[ruleName[:ruleArgument]*]","The rule delimiter symbols \u201c$[\u201c,\u201d]\u201d and \u201c:\u201d may be changed if appropriate. They may even be changeable programmatically. Examples of these are shown below:",{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$ [OPEN:$ [APPNAME] .cpp]"]},{"entry":[{},"$ [VAL:date:U]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"For each rule, there is a piece of code implementing the rule logic. This piece of code is implemented by an execute( ) method which is invoked by the parser. The parser's built-in rules are implemented in the Generator Framework itself. Specific rules are implemented out of the Generator Framework. The Rule interface defines the following abstract method:",{"@attributes":{"id":"p-0068","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{}," public abstract String execute(String[] args,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Parser p) throws GenException;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"String parse(String str) throws GenException;","Built-in Rules","Built-in rules provide a generic set of rule implementation for data access, data navigation and boolean conditions. These rules are part of the Generator Framework. The (non-exhaustive) list and syntax of these rules is described below in the section titled Built-in Rules Syntax.","Templates",{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 3","b":["150","154"]},{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"TemplateFile: TemplateLines ;"]},{"entry":[{},"TemplateLines:| TemplateLines TemplateLine ;"]},{"entry":[{},"TemplateLine: BlockDelimiter RET | TemplateElements"]},{"entry":[{},"RET ;"]},{"entry":[{},"TemplateElements:| TemplateElements TemplateElement;"]},{"entry":[{},"TemplateElement: Rule | Text;"]},{"entry":[{},"Rule: \u2018$[\u2019 RuleName RuleArgs \u2018]\u2019 ;"]},{"entry":[{},"RuleName: RULE_IDENT;"]},{"entry":[{},"RuleArgs: | \u2018:\u2019 TemplateElements;"]},{"entry":[{},"Text: TEXT\u2003\u2003;"]},{"entry":[{},"BlockDelimiter: \u2018@{\u2019| \u2018@}\u2019 ;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Filters are used to transform data during the generation. A filter is a piece of logic that takes a string and a scope as input, and outputs the transformed string. Transformation include:\n\n","Filters are initially registered with the Parser in the framework. Each filter has a name, and may allow several transformations to take place. For example, the \u201cCase\u201d filter (built-in filter) has the two \u201cU\u201d and \u201cL\u201d transformations, for uppercase and lowercase conversion respectively. The Parser provides functions to add and remove filters, and to get a filter by its name.","TextFilter Interface","Text Filters are used to transform any kind of data during the generation process. Text Filters are used by the FILTER rule (see also the FILTER Rule below), and can be used by external rules. The TextFilter interface defines the following abstract method:",{"@attributes":{"id":"p-0076","num":"0078"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{}," abstract public String transform(Scope scope,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{}," String input,"]},{"entry":[{},"String transformationName);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"$[FILTER:$[VAL:moduleName]:Case:U]","SymbolFilter Interface","The SymbolFilter interface is used to transform the value of a symbol. The difference with TextFilters is that a symbol bears more information than simple text from the scope point of view. For instance, the type of the symbol that can be used to transform data includes adding double quotes if the symbol is a string, or generating Y or N if the symbol is boolean. Symbol Filters are used by the VAL rule (see also the VAL Rule below), and can be used by external rules. The SymbolFilter interface defines the following abstract method:",{"@attributes":{"id":"p-0079","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{}," abstract public String transform(Scope scope,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{}," String symbolName,"]},{"entry":[{},"String input,"]},{"entry":[{},"String transformationName);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"When implementing Filters, there is the alternative between using:","$[FILTER:$[VAL:symbolName]:filterName:transformationName]","or","$[VAL:symbolName:filterName:transformationName]","These two forms are equivalent, unless the symbol name is meaningful to perform the transformation, like the formatting depending on the symbol type above.","Conditions","Conditions are used to generate code conditionally. Conditions are pieces of code that are plugged into the Generator Framework. The Parser provides functions to add and remove conditions, and to get a condition by its name.","Condition Interface","The Condition interface implements the following abstract method:","abstract public boolean isApplicable(Scope scope);","Conditions are used by the COND rule (see COND Rule below), and can be used by external rules.","Generic Conditions","Generic Conditions are implemented by the COND rule. This rule accepts complex conditions as input, expressed by symbol values, constants and logical operators. The condition text is parsed by the COND rule code. The syntax of generic conditions is still an open issue. Below is an example of a generic condition:",{"@attributes":{"id":"p-0087","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003 $[COND:domain.machines.$# > 1]"},{"entry":"\u2003@{"},{"entry":"\u2003*NETWORK"},{"entry":"\u2003 $[ITERATE:domain.machines]"},{"entry":"\u2003 @{"},{"entry":"\u2003 $[VAL:lmid] NADDR=$[VAL:naddr] NLSADDR=$[VAL:nlsaddr]"},{"entry":"\u2003 @}"},{"entry":"\u2003@}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In this example, domain.machines is a composed symbol name representing a reference. The $# notation is the number of elements of this reference. Below is a possible syntax for generic conditions, the notation and syntax are borrowed from \u201cThe JAVA Language Specification\u201d by the JAVA Team, Addison Wesley, 1996, hereby incorporated by reference.",{"@attributes":{"id":"p-0089","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{}," ConditionalExpression:"]},{"entry":[{},"ConditionalAndExpression"]},{"entry":[{},"ConditionalExpression || ConditionalAndExpression"]},{"entry":[{},"ConditionalAndExpression:"]},{"entry":[{},"EqualityExpression"]},{"entry":[{},"ConditionalAndExpression && EqualityExpression"]},{"entry":[{},"EqualityExpression:"]},{"entry":[{},"UnaryExpression"]},{"entry":[{},"EqualityExpression RelationalOperator UnaryExpression"]},{"entry":[{},"RelationalOperator: one of"]},{"entry":[{},"== != > < >= <="]},{"entry":[{},"UnaryExpression:"]},{"entry":[{},"Expression"]},{"entry":[{},"! UnaryExpression"]},{"entry":[{},"Expression:"]},{"entry":[{},"Identifier"]},{"entry":[{},"Constant"]},{"entry":[{},"( ConditionalExpression )"]},{"entry":[{},"Identifier:"]},{"entry":[{},"Literal"]},{"entry":[{},"Identifier . Literal"]},{"entry":[{},"Identifier . $#"]},{"entry":[{},"Constant:"]},{"entry":[{},"NumberConstant"]},{"entry":[{},"StringConstant"]},{"entry":[{},"NumberConstant:"]},{"entry":[{},"[\u2212]?[0-9]+"]},{"entry":[{},"StringConstant:"]},{"entry":[{},"\u201c StringChars \u201d"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"When navigating the data source with the scopes, it is often desirable to select related data elements depending on some condition. For instance, when generating code from IDL, the list of input parameters may be needed: if the model only provides a list of parameters (in, out, and inout), a conditional list may be useful to do this. This is the purpose of the CONDLIST and CONDITERATE rules, which apply a condition (named or generic) to each scope element of the list or the iteration, and then process their block of template code.","Notifications","Notifiers are used to send messages to external components that use the Generator Framework. Notifiers are typically used to inform external components (such as progress bars, output text widgets) about the status of the generation. A component wanting to be notified about the generation progress must simply implement the Notifier interface (see below). Notifications are sent in rules using the parser notify( ) method. Notifiers are registered in the parser for a specific rule (e.g. OPEN, CLOSE). Two conditions must be met for receiving notification messages from a rule:\n\n","The Notifier interface defines the following abstract method:",{"@attributes":{"id":"p-0093","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"abstract public void ruleInvoked(String ruleName,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{}," Parser p,"]},{"entry":[{},"String message);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Protected code sections allow users of the Generator Framework to define parts of the output file (or files) being untouched by the generation process. This is a powerful mechanism used to preserve user code while still being able to apply the generator to produce updated versions of the output files. For instance, defining a protected code section in a function implementation allows to keep the user code in the output file. Protected code sections are identified by a particular rule in the templates (see also the PCS Rule below). Unicity of a protected code section depends on a tag\u2014which is defined by the person writing the template. The tag generated in the output file is parsed by the PCS rule to ensure uniqueness.","3. Generator Framework","The UML diagram in  shows the class architecture of the framework. The meaning of the UML representation  in  will be evident to one skill in the art. As shown therein, the parser is the central point of the Generator Framework. It's functions include invoking the parsing of a template file, and executing rules which in turn change the scope of the parser. Scopes are organized in a stack inside the parser. The following class and interface specifications are given as examples, although it will be evident to one skilled in the art that the specific classes given are","Scope Class","The Scope class is an abstract class providing access to a data source (Contract Repository, Configuration Repository, UREP, . . . ).",{"@attributes":{"id":"p-0097","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"package com.beasys.generator;"]},{"entry":[{},"public abstract class Scope {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ General purpose functions"]},{"entry":[{},"\/\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{}," public String getName( );"]},{"entry":[{},"public String getType(String symbolName);"]},{"entry":[{},"public boolean isMultiple(String symbolName);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Attribute-related functions"]},{"entry":[{},"\/\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public abstract boolean hasAttribute(String symbolName);"]},{"entry":[{},"public abstract int getAttributeCount(String symbolName);"]},{"entry":[{},"public abstract String getValue(String symbolName)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"throws CardinalityException;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public abstract Enumeration values(String symbolName);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Reference related functions"]},{"entry":[{},"\/\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public abstract boolean hasReference(String symbolName);"]},{"entry":[{},"public abstract int getReferenceCount(String symbolName);"]},{"entry":[{},"public abstract Scope getScope(String symbolName)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"throws CardinalityException;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public abstract Enumeration values(String symbol Name);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"The Rule class defines the function that implements a rule. A rule is invoked by the parser when a rule invocation is recognized in the templates.",{"@attributes":{"id":"p-0099","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"package com.beasys.generator;"]},{"entry":[{},"public abstract class Rule {"]},{"entry":[{},"public String execute(String[] args, Parser p) throws"]},{"entry":[{},"GenException;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The Parser class contains the core of the Generator Framework, parsing template files and invoking rules.",{"@attributes":{"id":"p-0101","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"package com.beasys.generator;"]},{"entry":[{},"public class Parser {"]},{"entry":[{},"public Parser( );"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Scope Management"]},{"entry":[{},"\/\/"]},{"entry":[{},"public Scope getCurrentScope( );"]},{"entry":[{},"public String getValue(String symbolName)"]},{"entry":[{},"throws CardinalityException;"]},{"entry":[{},"public Enumeration values(String symbolName);"]},{"entry":[{},"public\u2003\u2002Scope\u2003\u2002getScope(String\u2003\u2002symbolName)\u2003\u2002throws"]},{"entry":[{},"CardinalityException;"]},{"entry":[{},"public Enumeration scopes(String symbolName);"]},{"entry":[{},"public void popScope( );"]},{"entry":[{},"public void pushScope(Scope s);"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Rule Management"]},{"entry":[{},"\/\/"]},{"entry":[{},"public void addRule(Rule r);"]},{"entry":[{},"public void removeRule(String ruleName);"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Condition Management"]},{"entry":[{},"\/\/"]},{"entry":[{},"public void addCondition(String name, Condition c);"]},{"entry":[{},"public void removeCondition(String name);"]},{"entry":[{},"public Condition getCondition(String name);"]},{"entry":[{},"public boolean hasCondition(String name);"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Filter Management"]},{"entry":[{},"\/\/"]},{"entry":[{},"public void addFilter(Filter f);"]},{"entry":[{},"public void removeFilter(String);"]},{"entry":[{},"public Filter getFilter(String name);"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Notifier Management"]},{"entry":[{},"\/\/"]},{"entry":[{},"public void addNotifier(String ruleName, Notifier n);"]},{"entry":[{},"public void removeNotifier(String ruleName, Notifier);"]},{"entry":[{},"public void notify(Rule r, String message);"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Template Management"]},{"entry":[{},"\/\/"]},{"entry":[{},"public void loadTemplates(String)"]},{"entry":[{},"throws ParserException;"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Parsing Functions"]},{"entry":[{},"\/\/"]},{"entry":[{},"public String parse(String s)"]},{"entry":[{},"throws GenException;"]},{"entry":[{},"public void parseTemplate(String templateName)"]},{"entry":[{},"throws GenException;"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Parser Properties"]},{"entry":[{},"\/\/"]},{"entry":[{},"public String getOutputDir( );"]},{"entry":[{},"public void setOutputDir(String dirName);"]},{"entry":[{},"public String getRootDir( );"]},{"entry":[{},"public void setRootDir(String dirName);"]},{"entry":[{},"public void setTemplateDir(String dirName);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The Filter class is the common superclass of the SymbolFilter and TextFilter classes:",{"@attributes":{"id":"p-0103","num":"0107"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"abstract public class Filter"]},{"entry":[{},"{"]},{"entry":[{},"protected Filter(String name);"]},{"entry":[{},"public String getName( );"]},{"entry":[{},"public abstract boolean hasTransformation(String name);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The SymbolFilter class is used by the VAL rule to transform a symbol value.",{"@attributes":{"id":"p-0105","num":"0109"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"abstract public class SymbolFilter"]},{"entry":[{},"extends Filter"]},{"entry":[{},"{"]},{"entry":[{},"protected SymbolFilter(String);"]},{"entry":[{},"abstract public String transform(Scope s,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"String symbolValue,"]},{"entry":[{},"String input,"]},{"entry":[{},"String transfName);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"The TextFilter class is used by the FILTER and VAL rules to transform a text value.",{"@attributes":{"id":"p-0107","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"abstract public class TextFilter"]},{"entry":[{},"extends Filter"]},{"entry":[{},"{"]},{"entry":[{},"protected TextFilter(String);"]},{"entry":[{},"abstract public String transform(Scope s,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"String input,"]},{"entry":[{},"String transfName);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"The Condition interface defines a isApplicable( ) method used to conditionally generate code. Conditions are used by the COND rule.",{"@attributes":{"id":"p-0109","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public interface Condition"]},{"entry":[{},"{"]},{"entry":[{},"public abstract boolean isApplicable(Scope scope);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The Notifier interface defines a method used to notify external components about the status of the generation. External components are notified from rules when the rule invokes the notify( ) method of the Parser class.",{"@attributes":{"id":"p-0111","num":"0115"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public interface Notifier"]},{"entry":[{},"{"]},{"entry":[{},"public abstract void ruleInvoked(String ruleName,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Parser p,"]},{"entry":[{},"String message);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"The following rules are given as examples of the type of rules that can be used with the invention. It will be evident to one skilled in the art that other rules can be used.","OPEN Rule","Synopsis","$[OPEN:<fileName>]","Description","The OPEN rule opens the file <fileName> for output. The generation output is written to the file <fileName>. The name of <fileName> can contain static values such as \u201ctest.idl\u201d, or symbols for substitution, such as \u201c$[VAL:moduleName].idl\u201d.","$[OPEN:$[VAL:moduleName].idl]","CLOSE Rule","Synopsis","$[CLOSE]","Description","The CLOSE rule closes the current output file. The generator output is restored to the previous opened output file, if any. If there is no more output file, any rule other than $[OPEN] causes the generator to fail.","SCOPE Rule","Synopsis","$[SCOPE:<scopeName>]","Description","The SCOPE rule ensures that the current scope name is the same as the scope name passed in the rule. The generator fails if the current scope name is not <scopeName>. This rule has no other effect.","VAL Rule","Synopsis",{"@attributes":{"id":"p-0120","num":"0124"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$ [VAL:<symbolName>]"]},{"entry":[{},"$ [VAL:<symbolName>:<filterName>:<transformationName>]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The VAL rule is used to return the value of symbols. A symbol value pertains to the current scope stack. Symbol values are retrieved against scopes from the scope stack, using the getValue( ) method of the Scope class. Usually, the VAL rule can only be used on single-valued attributes. An exception is thrown if this rule is used on a multiple-valued attribute. However, the VAL rule can be used with a symbol representing a multi-valued attribute only if it is invoked from an iterated code block in the LIST, ITERATE, CONDLIST and CONDITERATE rules. The second form allows the framework to apply a symbol or a text filter to the symbol value. The <filterName> parameter is the name of the filter to be used. The <transformationName> parameter is the name of a valid transformation in this filter.","$[VAL:passingMode]$[VAL:type]$[VAL:parameterName:Case:U]","FILTER Rule","Synopsis","$[FILTER:<text>:<filterName>:<transformationName>]","Description","The FILTER rule is used to apply a text filter to some text block. The <text> argument is parsed by the parser (it may contain rules). The <filterName> parameter is the name of the text filter to be used. The <transformationName> parameter is the name of a valid transformation in this text filter.","$[FILTER:$[VAL:parameterType]:FML:outDecl]","COND Rule","Synopsis",{"@attributes":{"id":"p-0126","num":"0130"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$ [COND:<condition>:<codeBlock>]"]},{"entry":[{},"$ [COND:<condition>]"]},{"entry":[{},"@{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<conditionalCodeBlock>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"@}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"The COND rule has two forms: the first forms allows to conditionally generate a (one line) piece of code depending on a named or generic condition. The second form allows to generate a block of code (on multiple lines) depending on a named or generic condition. The code block is delimited by the \u2018@{\u2018 and \u2019@}\u2019 markers.","ITERATE Rule","Synopsis",{"@attributes":{"id":"p-0128","num":"0132"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$ [ITERATE:<symbolName>]"]},{"entry":[{},"@ {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<iteratedCodeBlock>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"@ }"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"The ITERATE rule repeats the same block of code for a given symbol name. The iteration symbol name is a static name corresponding to a multi-valued reference related to the current scope. The iterated code block (between the \u2018@{\u2018 and \u2019@}\u2019 markers) is a piece of template code that is iterated for all the objects returned by the iteration at the scope level. Rules may be invoked inside this block, with a scope corresponding to the iterated objects. The iteration symbol name can also be a multi-valued attribute. In that case, the iterated code block is invoked with the same scope, and the VAL rule can be used to retrieve the sequenced values of the multi-valued attribute.","LIST Rule","Synopsis",{"@attributes":{"id":"p-0130","num":"0134"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$ [LIST:<listName>:<codeBlock>]"]},{"entry":[{},"$ [LIST:<listName>:<codeBlock>:<Separator>]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The LIST rule is similar to the ITERATE rule. Instead of iterating several lines of code, it outputs a list of <codeBlock> elements, separated by a separator string (the default separator is \u201c,\u201d).",{"@attributes":{"id":"p-0132","num":"0136"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"$ [VAL:operationName] ($ [LIST:parameterList:$ [VAL:parameterNa"},{"entry":"me]])"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},{"@attributes":{"id":"p-0133","num":"0137"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$ [CONDITERATE: <symbolName>]"]},{"entry":[{},"@ {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<iteratedCodeBlock>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"@ }"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"The CONDITERATE rule repeats the same block of code for a given symbol name, depending on a named or generic condition. The iteration symbol name is a static corresponding to a multi-valued reference related to the current scope. The iterated code block (between the \u2018@{\u2018 and \u2019@}\u2019 markers) is a piece of template code that is iterated for all the objects returned by the iteration at the scope level which satisfy the named or generic condition. Rules may be invoked inside the block, with a scope corresponding to the iterated objects.","CONDLIST Rule","Synopsis",{"@attributes":{"id":"p-0135","num":"0139"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"$ [CONDLIST:<listName>:<condition>:<CodeBlock>]"},{"entry":"$ [CONDLIST:<listName>:<condition>:<codeBlock>:<separator>]"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The CONDLIST rule is the result of the composition of a LIST rule and a COND rule. Each element generated in the list and used as the current scope in the code block must satisfy the named or generic condition.",{"@attributes":{"id":"p-0137","num":"0141"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$ [CONDLIST:parameterList:passingMode =="]},{"entry":[{},"\u2033in\u2033 :$ [VAL:parameterName]]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}]},"$[INCLUDE:<templateName>]","Description","The INCLUDE rule is used to include a template inside the current template.","$[INCLUDE:t_funcDecl]","PCS Rule","Synopsis","$[PCS:<pcs_tag>]","Description","The PCS rule defines the location of a protected code section in a template. The argument to the PCS rule is a tag which is parsed by the parser. In the output file, the protected code section will be delimited by the two lines shown below. Any comments put in the template on the $[PCS: . . . ] line will be preserved in the output file for both begin and end markers.","$[BEGIN_PCS:<parsed_tag>]","$[END_PCS]","5. Template Example","The following example was developed as a prototype for validating the Generator Framework architecture. This particular template example is used to generate IDL files:",{"@attributes":{"id":"p-0146","num":"0150"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"$ [SCOPE:Module]"},{"entry":"$ [OPEN:$ [VAL:name] .idl]"},{"entry":"#"},{"entry":"# File: $ [VAL:name] .idl"},{"entry":"#"},{"entry":"module $ [VAL:name] {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$ [ITERATE: interfaceList]"]},{"entry":[{},"@{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"interface $[VAL:name] {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$ [ITERATE:operationList]"]},{"entry":[{},"@{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"$ [VAL:retType]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"$ [VAL:name] ($ [LIST:paramList:$ [VAL:passMode]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"$ [VAL:type] $[VAL:name]]);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"@}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"@}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"$ [CLOSE]"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In this example, the \u201cname\u201d symbol is used several times to get the names of modules, interfaces, operations, and parameters, respectively. The ITERATE and LIST rules manage the data navigation so that the \u201cname\u201d symbol is each time the name of the element in the corresponding scope.","The foregoing description has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Obviously, many modifications and variations will be apparent to the practitioner skilled in the art. The embodiments were chosen and described in order to best explain the principles of the invention and its practical application, thereby enabling others skilled in the art to understand the invention for various embodiments and with various modifications that are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
