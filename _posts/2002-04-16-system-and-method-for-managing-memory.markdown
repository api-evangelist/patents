---
title: System and method for managing memory
abstract: A method and system for accessing data by an application program is disclosed. The application program issues a data request to a data storage system. In response, the data storage system loads into memory a data node corresponding to the data request. The data node is stored as part of a data structure. The data storage system returns a reference to the application program, which is then used to access the node. The application program may further instruct the data storage system to de-allocate a node when available memory is low or when it is no longer using the node.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07430586&OS=07430586&RS=07430586
owner: Zoran Corporation
number: 07430586
owner_city: Sunnyvale
owner_country: US
publication_date: 20020416
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","BRIEF SUMMARY","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","The invention relates to managing memory, and in particular to providing a data storage system for an application to use in accessing data.","2. Background Information","Document data is increasingly being stored and\/or processed in a structured format using a data structure standard. In particular, data structure standards are used to provide a set of definitions that can be used to separate data content from a particular presentation. In this manner, the content can be quickly accessed and re-rendered in a different context. It has previously been recognized that by separating content from presentation it would be possible to share data on a platform-independent basis. One such early effort was the Electronic Data Interchange (\u201cEDI\u201d). Similarly, the Hypertext Markup Language (\u201cHTML\u201d), which has enjoyed widespread acceptance over the World Wide Web, represents another effort to normalize document data structures for facilitating the sharing of data between different computer systems.","While many data structure standards have been developed, one exemplary standard which has gained widespread recognition is the Extensible Markup Language (\u201cXML\u201d). XML, like HTML, evolved from the Standard Generalized Markup Language (\u201cSGML\u201d). XML is a document-based organizational standard that provides a set of rules for defining descriptions of structure and content in a document. XML uses tags that are similar to HTML tags, except that HTML tags provide a way of formatting information, while XML tags only organize and describe the data itself. That being the case, it is typically the case that XML documents must be parsed using a processing algorithm, as must XHTML and SGML documents.","Regardless of the data structure standard in use, there are two dominant approaches to navigating document data. The first type of navigation method, or parser, reads the document and transforms the data into its tree-structured equivalent. The most common example of this is the Document Object Model (\u201cDOM\u201d), which is based on the notion of using nodes to navigate a document. DOM, and other tree-based parsers, enable application programs to navigate and manipulate document data by loading and storing the entire document in this tree structure. However, this approach suffers from the fact that it is a strong consumer of memory resources. A DOM version of a document can easily consume two to three times as much memory as the original document would have. This can have a significant impact on applications which run in memory-poor environments, such as would be the case with embedded system applications.","The second approach to parsing document data is to analyze the document as a stream of text, rather than as a tree. In particular, as the various components of a document are encountered, the parser raises events (such as start and end elements), and reports such events back to the application program. A common example of an event-based parser is the Simple API for XML (\u201cSAX\u201d), which reports events to the application program using callbacks, which cause the application program to implement event handlers for the different types of events. While the event-based parser of a document requires much less memory than its DOM version would, event-based parsers can only process the current node and those nodes that are younger siblings or children of the current node. Moreover, the application program will have no control over the navigation through the document data.","Accordingly there is a need in the art for a system and method of managing memory which does not suffer from the aforementioned drawbacks.","A system and method for accessing data by an application program is disclosed. In one embodiment, the method comprises issuing a request, by an application program, for a reference, and storing a node in a memory as part of a data structure in response to said request, said data structure to include at least a portion of a data set and to be organized as a plurality of nodes. The method further includes returning the reference to the application program, and accessing the node, by the application program, using the reference.","Other embodiments are disclosed and claimed herein.","One aspect of the invention relates to providing a system for parsing document data which is to be provided to an application program in response to a request from the application program. In one embodiment, this functionality is provided by a data storage system which receives and parses data, such as document data, from a data source. The data storage system parses a data set to determine node boundaries and relationships, and creates a data structure in memory comprised of nodes. In one embodiment, the scope of the data structure created by the data storage system corresponds to application program requests and represents some fraction of the total data set. In one embodiment, the requests are navigation function calls which cause the data storage system to load a desired node into the data structure in memory. The data structure may be stored in shared system memory that is accessible by both the application program and the data storage system, according to one embodiment. The data structure may be updated by the data storage system based on subsequent application program requests.","Another aspect of the invention relates to providing a system for an application program to navigate through document data and access specific nodes of the data structure. This is done by returning references to the application program corresponding to the desired nodes. A reference may be a physical memory address where the node is stored, or may be a virtual memory address. It should be appreciated that the reference may also be a table index, an associative memory address, or any other means of identifying a storage location for the node sought. In one embodiment, when an application program issues a navigation function call to the data storage system, the data storage systems updates the data structure in system memory as needed, and returns one or more references to the application program corresponding to the requested node(s). The application program may then access the nodes in the data structure using the corresponding references returned to it.","Yet another aspect of the invention relates to releasing nodes from the data structure, when no longer being used by the application program. In one embodiment, nodes are de-allocated (i.e., have no effective reference assigned), but are yet retained in memory. In another embodiment, nodes that are de-allocated are also discarded from system memory. In another embodiment, de-allocated nodes are discarded from memory automatically, while in another embodiment, de-allocated nodes are discarded from system memory as a function of system memory limitations.","Referring now to the figures, one embodiment of a processor system  that implements at least one aspect of the invention is depicted in . Processor system  comprises a processor or a central processing unit (CPU) . The illustrated CPU  may include an Arithmetic Logic Unit (ALU) for performing computations, a collection of registers for temporary storage of data and instructions, and a control unit for controlling operation for the processor system . In one embodiment, the CPU  includes any one of the x86, Pentium\u2122, Pentium II\u2122, and Pentium Pro\u2122 microprocessors as marketed by Intel\u2122 Corporation, the K-6 microprocessor as marketed by AMD\u2122, or the 6\u00d786MX microprocessor as marketed by Cyrix\u2122 Corp. Further examples include the Alpha\u2122 processor as marketed by Digital Equipment Corporation\u2122, the 680X0 processor as marketed by Motorola\u2122; or the Power PC\u2122 processor as marketed by IBM\u2122. In addition, any of a variety of other processors, including those from Sun Microsystems, MIPS, IBM, Motorola, NEC, Cyrix, AMD, Nexgen and others may be used for implementing CPU . Moreover, the CPU  is not limited to a microprocessor, but may take on other forms such as microcontrollers, digital signal processors, reduced instruction set computers (RISC), application specific integrated circuits, and the like. Although shown with one CPU , processor system  may alternatively include multiple processing units.","The CPU  may be coupled to a bus controller  by way of a CPU bus . The bus controller  includes a memory controller  integrated therein, though the memory controller  may be external to the bus controller . The memory controller  provides an interface for access by the CPU  or other devices to system memory  via memory bus . In one embodiment, the system memory  includes synchronous dynamic random access memory (SDRAM). System memory  may optionally include any additional or alternative high speed memory device or memory circuitry. The bus controller  is coupled to a system bus  that may be a peripheral component interconnect (PCI) bus, Industry Standard Architecture (ISA) bus, etc. Coupled to the system bus  are a graphics engine or a video controller , a mass storage device , a communication interface device , and one or more input\/output (I\/O) devices . The video memory  is used to contain display data for displaying information on the display screen . In another embodiment, the video controller  is coupled to the CPU  through an Advanced Graphics Port (AGP) bus.","The mass storage device  includes (but is not limited to) a hard disk, floppy disk, CD-ROM, DVD-ROM, tape, high density floppy, high capacity removable media, low capacity removable media, solid state memory device, etc., and combinations thereof. The mass storage device  may include any other mass storage medium. The communication interface device  may include a network card, a modem interface, etc. for accessing network  via communications link . The I\/O devices  may include a keyboard, mouse, audio\/sound card, printer, and the like. The I\/O devices  may also include the specialized display circuits and input circuits of an embedded system.","As is familiar to those skilled in the art, the processor system  may further include an operating system (OS) and at least one application program, which in one embodiment, are loaded into system memory  from mass storage device  and launched after POST. The OS may be any type of OS including, but not limited or restricted to, DOS, Windows\u2122 (e.g., Windows 95\u2122, Windows \u2122, Windows 2000\u2122, Windows XP\u2122, Windows NT\u2122, Windows NT Embedded\u2122), Unix, Linux, OS\/2, OS\/9, Xenix, VxWorks, etc. The operating system is a set of one or more programs which control the processor system's operation and the allocation of resources. The application program is a set of one or more software programs that performs a task desired by the user.","In one embodiment, processor system  is an embedded system, such as an application card, network appliance or other consumer product.  illustrates one embodiment of processor system  when implemented as an embedded system. In this embodiment, CPU , system memory , non-volatile memory , communication interface , and I\/O circuits  are connected via system bus . The non-volatile memory  may be programmable read-only memory (PROM) and may contain the Basic Input\/Output System (\u201cBIOS\u201d) for the processor system . Where processor system  is an embedded system, I\/O circuits  will correspond to the particular specialized circuits used by the embedded system. By way of providing non-limiting examples, the I\/O circuits  may correspond to the input-output circuitry for a cellular phone, personal digital assistant (\u201cPDA\u201d), or other consumer electronic device using embedded system technology. In addition, communication interface  and\/or one or more of the I\/O circuits  may be used to provide data to the system memory . Such data may be loaded from a fixed-medium storage device, such as a floppy or hard disk, or may be received over a communications link connected to network . It should be appreciated that the network can be a local area network (\u201cLAN\u201d), a wide area network (\u201cWAN\u201d), the Internet, or any other data network.","In accordance with the practices of persons skilled in the art of computer programming, the invention is described below with reference to symbolic representations of operations that are performed by processor system , unless indicated otherwise. Such operations are sometimes referred to as being computer-executed. It will be appreciated that operations that are symbolically represented include the manipulation by CPU  of electrical signals representing data bits and the maintenance of data bits at memory locations in system memory , as well as other processing of signals. The memory locations where data bits are maintained are physical locations that have particular electrical, magnetic, optical, or organic properties corresponding to the data bits.","When implemented in software, the elements of the invention are essentially the code segments to perform the necessary tasks. The program or code segments can be stored in a processor readable medium or transmitted by a computer data signal embodied in a carrier wave over a transmission medium or communication link. The \u201cprocessor readable medium\u201d may include any medium that can store or transfer information. Examples of the processor readable medium include an electronic circuit, a semiconductor memory device, a ROM, a flash memory or other non-volatile memory, a floppy diskette, a CD-ROM, an optical disk, a hard disk, a fiber optic medium, a radio frequency (RF) link, etc. The computer data signal may include any signal that can propagate over a transmission medium such as electronic network channels, optical fibers, air, electromagnetic, RF links, etc. The code segments may be downloaded via computer networks such as the Internet, Intranet, etc.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 3A","b":["304","302","304","150","304","110","302","110","150","126","304","302","126","110","104","302","304","304","130"]},"Where processor system  is an embedded system, application program  is comprised of specialized code for carrying out the specific function of the embedded system. For example, in one embodiment application program  may be an embedded Internet browser or embedded XML processor. Moreover, in the case of an embedded system, application program  and data storage system  may be stored on non-volatile memory, while data source  provides data to system memory  to be operated on by data storage system  and\/or application program .","System memory  and\/or non-volatile memory  may further be used to store operating system  and optional API programs , where optional APIs  are used to perform further processing of data received from data source . It should be appreciated that, in one embodiment, data source  is a serial source, such as a file stored on mass storage  or a data stream received over network . Similarly, the data provided by the data source  may be any data set capable of being represented in discreet segments and modeled as a series of nodes.","Moreover, in one embodiment, data storage system  is an Application Programming Interface (\u201cAPI\u201d) which serves as a processing intermediary between an application program and a data set from data source . It should further be appreciated that data storage system  may be a portion of another API, or contained within another processing program. In addition, optional APIs  may be used to carry out additional rendering functions, such as those processing operations carried out by Cascading Style Sheets (\u201cCSS\u201d), Extensible Stylesheet Language (\u201cXSL\u201d), and Document Style Semantics and Specification Language (\u201cDSSSL\u201d).",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 3B","b":["310","308","306","100","302","304","308","302","304","130","308","304","302"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 4","b":["400","402","304","404","302","402","404"]},"In response to this request, at block , the data storage system  may initialize internal data, such as any local variables or similar operating parameters. Where a data set is being sent via a communications stream, the data storage system  may also process the data input stream and allocate node storage as needed. Finally, a reference is returned to the application program  by the data storage system , according to one embodiment.","After receipt of a reference for the root node, the application program  may then request additional nodes at block . Data storage system , at decision block , makes a determination as to whether the additional node requested by the application program  at block  is a request for a child, sibling or parent node. In one embodiment, this request is in the form of a navigation function call. As is described in more detail below with reference to , the application program  may access specific data in a data set by issuing a series of navigation function calls which result in the data storage system  returning one or more references to one or more particular nodes.","Upon receiving a navigation function call, such as a request for a reference to a child, sibling or parent node, the data storage system  at block  processes the data from the data source  as needed to respond to the request. In one embodiment, the data storage system  also allocates node storage in system memory  and releases any previously de-allocated nodes to free any additional needed memory. Thereafter, the data storage system  returns one or more references to the node(s) requested, according to one embodiment. Thereafter, application program  has access to the nodes for which it has received references.","If, however, the request from the application program  was not a request for a node, process  moves to decision block  where a determination is made as to whether the request was to de-allocate a previously requested node. If so, this request is processed at block  and the node in question is de-allocated.","Where the request is determined to not be a node de-allocation request, process  moved to decision block  where a determination is made as to whether or not the request was a request to de-allocate a subtree. In one embodiment, a request to de-allocate a subtree would be a request to de-allocate a particular node and all of its descendants.","Finally, the request from the application program  may be a request to exit or terminate the data storage system , the determination of which is made at decision block .","As discussed above, the data storage system  allocates system memory for nodes and returns references to the corresponding memory locations in response to application program  node requests. This process creates a system memory usage state. One such memory usage state is depicted in . In the memory usage state of , an application program  has made a root node request, such as was previously discussed in regards to block  of process . In response, system memory was allocated to the root node  and a corresponding reference returned to the application program . Moreover, in this embodiment, a subsequent request was made by the application program  for a child node  of the root node . Again, system memory was allocated and a reference returned. At some point thereafter additional requests were made for nodes  and . The requests, or navigation functions calls, may have been in the form of two child node calls, or may have been in the form of one child node call, follow by a sibling call. In either event, system memory was allocated for nodes  and  and the corresponding references returned to the application program .","Referring now to , in which a memory usage state is depicted where the data storage system  has pre-fetched nodes  and . Pre-fetched nodes are those nodes for which memory has been allocated, but for which no application program  request has been issued and no reference returned. To identify the fact that nodes  and  are not visible to the application program , they are depicted in hatching in . Similarly, for  nodes depicted in non-hatched boxes are visible to the application program , while nodes depicted in hatched boxes are not.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 5C","b":["302","514","516","302","514","516","302"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 5D","FIG. 5D","FIG. 5E"],"b":["302","508","302","302","508","302","304","508","304","508","508","302"]},"Referring now to , the various node processing states and transitions are depicted. In particular, a node may be described as any one of the following: not yet processed, pre-fetched, active, de-allocated, and discarded.","As shown in , node state  corresponds with a node which has yet to be processed by a data storage system. Node state  corresponds with a node which has been read into system memory  by a data storage system , but not yet requested by the application program. Thus, in this state, the node would not be visible to the application program, according to one embodiment. Node state  relates to a node that has been loaded into memory, and for which a reference has been returned to the application program. Node state  relates to a node which the application program has indicated it no longer needs, but which still resides in system memory . Finally, node state  corresponds to a node which has been removed from memory.","Nodes transition through node states - under varying circumstances. In particular, node transition , which takes a node from node state  to node state , may occur when the data storage system determines that sufficient memory is available to pre-fetch the node into memory. In one embodiment, nodes are pre-fetched based on memory availability, while in another embodiment nodes are pre-fetched based, at least in part, on an application program's request patterns. It should be appreciated that such pre-fetching may be done to improve system efficiency and\/or system response time.","A node may enter node state  (i.e., active state) by either node transition  or node transition . Node transition  occurs when an application program issues a request for node which has already been pre-fetched. In this case, the data storage system simply has to return a reference to the application program for the pre-fetched node already in memory. Alternatively, node transition  also takes a node to an active state and occurs when an application program requests a node which has yet to be processed. In this latter case, the data storage system allocates memory for the node and, when memory limitations require, releases one or more nodes that have been de-allocated, according to one embodiment. Thereafter, a reference may be returned to the application program for the now-active node.","Node transition , which takes a node from an active state (node state ) to a de-allocated state (node state ), occurs when the data storage system receives a de-allocation request from the application program. However, the data storage system continues to hold the node in memory.","Node state  may be achieved through node transition  or node transition . In the case of node transition , the data storage system receives a de-allocation request by the application program and decides to immediately discard the node, thereby freeing up previously occupied memory. Unlike node state , in which the node remains in memory, the data storage system may determine that the node should be immediately discarded due, for example, to a lack of available memory.","Another route to node state  is through node transition . In this case, the data storage system chooses to remove from memory a node which had been previously de-allocated. Node transition  may occur as memory limitations require.","Two other ways a node may achieve node state  is through node transition  and . In the case of node transition , an application program issues a request for a node which it had previously ordered de-allocated. In this case, the node is already in memory and the data storage system has only to return a reference to that location. Alternatively, node transition  occurs when an application requests access to a node which had been both de-allocated and discarded. In this case, memory must be re-allocated for the node and a corresponding reference returned to the application program.","Referring now to , in which navigation function calls - are depicted. Navigation function calls are invoked in response to a request from an application program, such as application program . Navigation function calls return a reference to a desired node and may be invoked through any programming method that supports subroutine, function or method calls. By way of non-limiting examples, navigation function calls - may be invoked using programming code in C, Basic, C++, Java, or scripting languages, such as Bourne Shell or perl. Similarly, function calls - may be remotely invoked using such methods as CORBA IDL or Java Remote Method Invocation.","Referring still to , function call  is a parent node request. Function call  corresponds to a next-sibling-node request, while function call  is a previous-sibling-node request. Function call  is a request to find the first child, and function call  is a parent request, as was function call . Function call  is a request for the last child of a node. As with function calls  and , function calls  and  correspond to a next-sibling and previous-sibling request, respectively.","It should be appreciated that other navigation function calls are possible, such as grandparent- and grandchild-node requests. Similarly, cousin node requests are possible, as is any other node relationship describable in familial terms or otherwise. In another embodiment, functions call may be based on application-specific relationships. By way of non-limiting examples, such relationships may include \u201cis an example of,\u201d \u201chas the property of,\u201d or \u201cdepends on.\u201d In a relational database, each row of a table may represent a node, where values of columns in rows are used as links to rows in other tables, according to one embodiment.","In another embodiment, nodes may be represented by unique tags, in which an application program issues requests for nodes having particular tags and the data storage system returns a reference to that tag.","While certain exemplary embodiments have been described and shown in the accompanying drawings, it is to be understood that such embodiments are merely illustrative of and not restrictive on the broad invention, and that this invention not be limited to the specific constructions and arrangements shown and described, since various other modifications may occur to those ordinarily skilled in the art."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1","b":"100"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2","b":"100"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 5A-5E"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
