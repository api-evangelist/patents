---
title: Depth write disable for rendering
abstract: A depth write disable apparatus and method for controlling evictions, such as depth values, from a depth cache to a corresponding depth buffer in a zone rendering system. When the depth write disable circuitry is enabled, evictions from the depth cache (as which typically occur during the rendering of the next zone) to the depth buffer are prevented. In particular, once the depth buffer is initialized (i.e. cleared) to a constant value at the beginning of a scene, the depth buffer does not need to be read. The depth cache handles intermediate depth reads and writes within each zone. Since the memory resident depth buffer is not required after a scene is rendered, it never needs to be written. The final depth values for a zone can thus be discarded (i.e., rather than written to the depth buffer) after each zone is rendering.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06954208&OS=06954208&RS=06954208
owner: Intel Corporation
number: 06954208
owner_city: Santa Clara
owner_country: US
publication_date: 20040511
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application is a continuation of Ser. No. 10\/038,814, filed on Dec. 31, 2001, now U.S. Pat. No. 6,747,657 entitled \u201cDepth Write Disable for Zone Rendering.\u201d","1. Field","The present invention relates generally to graphics systems and more particularly to methods and apparatus for controlling the transfer of data from a depth cache to depth buffer.","2. Background Information","Computer graphics systems are commonly used for displaying graphical representations of objects on a two-dimensional video display screen. Current computer graphics systems provide highly detailed representations and are used in a variety of applications. In typical computer graphics systems, an object to be represented on the display screen is broken down into graphics primitives. Primitives are basic components of a graphics display and may include points, lines, vectors and polygons, such as triangles and quadrilaterals. Typically, a hardware\/software scheme is implemented to render or draw the graphics primitives that represent a view of one or more objects being represented on the display screen.","The primitives of the three-dimensional objects to be rendered are defined by a host computer in terms of primitive data. For example, when the primitive is a triangle, the host computer may define the primitive in terms of X, Y and Z coordinates of its vertices, as well as the red, green and blue (R, G and B) color values of each vertex. Additional primitive data may be used in specific applications.","Image rendering is the conversion of a high-level object-based description into a graphical image for display on some display device. For example, an act of image rendering occurs during the conversion of a mathematical model of a three-dimensional object or scene into a bitmap image. Another example of image rendering is converting an HTML document into an image for display on a computer monitor. Typically, a hardware device referred to as a graphics-rendering engine performs these graphics processing tasks. Graphics-rendering engines typically render scenes into a memory buffer that is subsequently output to the graphical output device, but it is possible for some rendering-engines to write their two-dimensional output directly to the output device. The graphics-rendering engine interpolates the primitive data to compute the display screen pixels that represent the each primitive, and the R, G and B color values of each pixel.","A graphics-rendering system (or subsystem), as used herein, refers to all of the levels of processing between an application program and a graphical output device. A graphics engine can provide for one or more modes of rendering, including zone rendering. Zone rendering attempts to increase overall 3D rendering performance by employing a zone-sized color and depth cache, also called a render cache. By gaining optimal render cache utilization, pixel color and depth memory read\/write bottlenecks are thereby reduced.","In zone rendering, a screen is subdivided into an array of zones. Per-zone instruction bins, used to hold the primitive and state setting instructions required to render each zone sub-image, are generated in a first pass. Whenever it is determined that a primitive intersects (or possibly intersects) a zone, a corresponding primitive instruction is placed in the bin for that zone. Some primitives will intersect more than one zone, in which case the primitive instruction is replicated in the corresponding bins. This process is continued until the entire scene is sorted into the bins. Following the first pass of generating the bins for each zone of the image, a second zone-by-zone rendering pass is performed. In particular, the bins for all the zones are rendered to generate the final image. Each scene is typically rendered one zone at a time.","The size of the zone typically corresponds to the size and organization of the render cache. A render cache stores pixel data that have been recently used by the rendering processor so that this information is more rapidly available to the rendering processor than it is from external memory devices. In particular, the render cache handles intermediate depth reads and writes within each zone. The data is typically written from the render cache into the depth buffer in main memory. For example, depth values are evicted from the render cache to the depth buffer as a result of a context switch or the partial rendering and\/or resumption of a scene. Evictions from the render cache to the depth buffer typically occur during rendering of the next zone. However, since the render cache handles intermediate reads and writes, the values evicted from the render cache to the depth buffer do not typically need to be read. Writing values to the depth buffer unnecessarily places substantial load on the memory bus as well as other parts of the system and may slow the operation of the system.","What is needed therefore is a method, apparatus and system for enabling and\/or disabling evictions from a depth cache to a corresponding depth buffer.","The present invention provides a depth write disable apparatus and method for controlling evictions, such as depth values, from a depth cache to a corresponding memory-resident depth buffer in a zone rendering system. The depth write disable configuration includes a memory controller  implementing eviction detection logic  to enable\/disable write evictions from the internal render cache  to the corresponding depth buffer  in response to a control signal in the form of a enable\/disable bit . When the depth write enable\/disable bit indicates that depth buffer writes are disabled, evictions  from the render cache  (as typically occur during the rendering of the next zone ) cause the evicted data to be discarded instead of being written to the depth buffer . In particular, as the depth cache is initialized (i.e. cleared) to a constant value at the beginning of the rendering of a zone, the depth buffer does not need to be read. The depth cache handles intermediate depth reads and writes within each zone.","Since the memory resident depth buffer is typically not required after a scene is rendered, depth values typically do not need to be written to the depth buffer. After a scene is rendered, the final depth values for a zone can thus be discarded, rather than written to the depth buffer. The elimination of the final depth value writes to the depth buffer reduces overall bandwidth requirements, thus improving performance particularly in bandwidth-constrained systems. Embodiments of the present invention also provide for automatic override of the depth write disable configuration when evictions from the depth cache to the depth buffer are necessary.","One skilled in the art will recognize that the present invention is not limited to 3D rendering, primitives or so forth. Rather, the actual implementation may be utilized on 3D, 2_D, 2D primitives and so forth. The present invention can be utilized to prevent writes of any temporary data from a cache to a buffer where the data in at least some instances is not required after the zone is rendered. Moreover, the rendering modes may include but are not limited to solely \u201czone rendering.\u201d Embodiments of the present invention can also be adopted for use in non-zone rendering implementations where primitives are typically rendered all over the screen. In such an implementation, the size of the cache would be sized according to the size of the image.","In the detailed description, numerous specific details are set forth in order to provide a thorough understanding of the present invention. However, it will be understood by those skilled in the art that the present invention may be practiced without these specific details. In other instances, well-known methods, procedures, components and circuits have been described in detail so as not to obscure the present invention.","Some portions of the detailed description that follow are presented in terms of algorithms and symbolic representations of operations on data bits or binary signals within a computer. These algorithmic descriptions and representations are the means used-by those skilled in the data processing arts to convey the substance of their work to others skilled in the art. An algorithm is here, and generally, considered to be a self-consistent sequence of steps leading to a desired result. The steps include physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers or the like. It should be understood, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussions, it is appreciated that throughout the specification, discussions utilizing such terms as \u201cprocessing\u201d or \u201ccomputing\u201d or \u201ccalculating\u201d or \u201cdetermining\u201d or the like, refer to the action and processes of a computer or computing system, or similar electronic computing device, that manipulate and transform data represented as physical (electronic) quantities within the computing system's registers and\/or memories into other data similarly represented as physical quantities within the computing system's memories, registers or other such information storage, transmission or display devices.","Embodiments of the present invention may be implemented in hardware or software, or a combination of both. However, embodiments of the invention may be implemented as computer programs executing on programmable systems comprising at least one processor, a data storage system (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. Program code may be applied to input data to perform the functions described herein and generate output information. The output information may be applied to one or more output devices, in known fashion. For purposes of this application, a processing system includes any system that has a processor, such as, for example, a digital signal processor (DSP), a micro-controller, an application specific integrated circuit (ASIC), or a microprocessor.","The programs may be implemented in a high level procedural or object oriented programming language to communicate with a processing system. The programs may also be implemented in assembly or machine language, if desired. In fact, the invention is not limited in scope to any particular programming language. In any case, the language may be a compiled or interpreted language.","The programs may be stored on a storage media or device (e.g., hard disk drive, floppy disk drive, read only memory (ROM), CD-ROM device, flash memory device, digital versatile disk (DVD), or other storage device) readable by a general or special purpose programmable processing system, for configuring and operating the processing system when the storage media or device is read by the processing system to perform the procedures described herein. Embodiments of the invention may also be considered to be implemented as a machine-readable storage medium, configured for use with a processing system, where the storage medium so configured causes the processing system to operate in a specific and predefined manner to perform the functions described herein.","An example of one such type of processing system is shown in FIG. . Sample system  may be used, for example, to execute the processing for methods in accordance with the present invention, such as the embodiment described herein. Sample system  is representative of processing systems based on the microprocessors available from Intel Corporation, although other systems (including personal computers (PCs) having other microprocessors, engineering workstations, set-top boxes and the like) may also be used. In one embodiment, sample system  may be executing a version of the WINDOWS.\u2122. operating system available from Microsoft Corporation, although other operating systems and graphical user interfaces, for example, may also be used.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","102","104","106","108","114","102","102","112","102","100"]},"Processor  issues signals over common bus  for communicating with memory  or graphics and memory controller  in order to manipulate data as described herein. Processor  issues such signals in response to software instructions that it obtains from memory . Memory  may be a dynamic random access memory (DRAM) device, a static random access memory (SRAM) device, or other memory device. Memory  may store instructions and\/or data represented by data signals that may be executed by processor , graphics device  or some other device. The instructions and\/or data may comprise code for performing any and\/or all of the techniques of the present invention. Memory  may also contain software and\/or data. In some embodiments, graphics device  can offload from processor  many of the memory-intensive tasks required for rendering an image. Graphics device  processes data signals and may be a complex instruction set computer (CISC) microprocessor, a reduced instruction set computing (RISC) microprocessor, a very long instruction word (VLIW) microprocessor, a process implementing a combination of instruction sets, or other processor device, such as a digital signal processor, for example. Graphics device  may be coupled to common bus  that transmits data signals between graphics device  and other components in the system , including render cache  and display device . As discussed in detail below, render cache  handles intermediate reads and writes for zone rendering. Graphics device  includes rendering hardware that among other things writes specific attributes (e.g. colors) to specific pixels of display  and draw complicated primitives on display device . Graphics and memory controller  communicates with display device  for displaying images rendered or otherwise processed by a graphics controller . Display device  may comprise a computer monitor, television set, flat panel display or other suitable display device.","Memory  stores a host operating system that may include one or more rendering programs to build the images of graphics primitives for display. System  includes graphics device , such as a graphics accelerator that uses customized hardware logic device or a co-processor to improve the performance of rendering at least some portion of the graphics primitives otherwise handled by host rendering programs. The host operating system program and its host graphics application program interface (API) control the graphics device  through a driver program.","Referring to , an embodiment  of various graphics objects, for example geometric primitives (i.e. triangles, lines) , implemented on a zone rendering system  is illustrated. In zone rendering, a screen is subdivided into an array of zones  commonly screen-space rectangles although other geometric variants may be used as well. Each zone  is associated with a bin. Each bin  includes a chained series of command buffers  stored within non-contiguous physical memory pages. The bins  are thus preferably implemented as a chain of independent physical pages.","The process of assigning primitives (and their attributes)  to zones  is referred to as binning. \u201cBin\u201d refers to the abstract buffer used for each zone\u2014where a bin  will typically be realized as a series of instruction batch buffers . Binning performs the necessary computations to determine what primitives  lie in what zones  and can be performed by dedicated hardware and\/or software implementations.","When a primitive  intersects a zone , the corresponding primitive instruction is placed in the bin  associated with the zone  intersected. Per-zone instruction bins  are thus used to hold primitive instructions and state-setting instructions required to render each sub-image and are generated by comparing the screen-space extent of each primitive  to the array of zones . Thus, as the primitives  are received, the present invention determines which zone(s)  each primitive  intersects, and replicates the primitive instructions into a bin  associated with each of these zones .","In one typical implementation, a driver  writes out a set of primitive instructions to be parsed by the graphics-binning engine . For each zone  intersected by a primitive , the graphics-binning engine writes corresponding primitive instructions into buffers  associated with the zones  intersected. Some primitives  will intersect more than one zone , in which case the primitive instruction is replicated in bins  corresponding to the intersected zones . For example, the lightning bolt depicted in  intersects nine zones . This process is continued until the entire scene is sorted into bins .","Referring to , in a typical implementation, a graphics primitive and state-setting instruction stream, referred to as a scene input list , is initially applied to graphics-binning engine ring buffer  associated with graphics-binning engine . The scene input list  may be a single, temporally-ordered scene description as received by the application programming interface (API). Graphics-binning engine  is typically implemented as a hardware binning engine (HWB) . One skilled in the art will recognize that a software or software plus hardware binner could be used as well. The graphics-binning engine  parses scene input list  and determines which zone(s)  each primitive  intersects.","As previously noted, the zones  are associated with bins . Graphics-binning engine  compares the screen-space extent of each primitive  to the array of zones , and replicates the associated primitive commands into corresponding bins . Bins  are comprised of chained series of command buffers  typically stored within non-contiguous physical memory pages. A bin list is a list of buffers  which comprise each bin . Pages are initially allocated to the bin memory pool (BMP) . The bin pointer list  is initialized with the page numbers of the pages and stores write pointers into each bin list .","The graphics-binning engine  also maintains the current graphics state by parsing associated state-setting instructions contained with the scene input list . Prior to placing a primitive command in any given bin , the graphics-binning engine  typically precedes the primitive command in the bin  with any required state-setting instructions.","After the scene input list  has been completely parsed, the associated bins (i.e. bin 0, bin 1 . . . bin n\u22121) are ready to be used by the graphics-rendering engine  to render the scene. As discussed in detail below, instructions are included at the end of the scene input list  to cause the graphics-binning engine  to increment the register in pending scene counter  by one and initiate rendering of the binned scene. For example, graphics-binning engine  sends a render instruction to graphics-rendering engine ring buffer  associated with graphics-rendering engine  via path .","Rendering","Once all the primitives  are sorted and the command structures completed, a second pass is made to render the scene one zone  at a time. Following the first pass of building a bin for each zone  intersected by a primitive , a second zone-by-zone rendering pass is performed. In particular, the bins  for all the zones  are rendered to generate the final image, with each scene rendered one zone  at a time. The order with which the zones  are rendered is typically not significant. All bins  associated with primitives  that touch pixels within a particular zone  are rendered before the next zone  is rendered. A single primitive  may intersect many zones , thus requiring multiple replications. As a result, primitives  that intersect multiple zones  are rendered multiple times (i.e. once for each zone  intersected).","Referring to , rendering performance improves as a result of the primitives  being sorted by their intersections with zones  that are aligned to the render cache . The information is stored in the depth cache  with its memory address where it is available for later use by the rendering engine . Since graphics device  only works on a small portion of the screen at a time (i.e. a zone ), it is able to hold the frame buffer contents for the entire zone  in render cache . A render cache  handles intermediate depth reads and writes within each zone . The dimensions of the zone  are typically a constant tuned to the size and organization of the render cache . It is by this mechanism that the render cache  provides optimal benefits\u2014reuse of cached data is maximized by exploiting the spatial coherence of a zone . With zone rendering, only the minimum number of color memory writes need be performed to generate the final image one zone  at a time, and color memory reads and depth memory reads and writes can be minimized or avoided altogether. Use of the render cache  thus significantly reduces the memory traffic and improves performance relative to a conventional renderer that draws each primitive  completely before continuing to the next primitive . Consequently, whenever the memory resident depth buffer  is not required after a scene is rendered, the final depth values for a zone  stored in the render cache  can be discarded, rather than written to the depth buffer .",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 4","b":["170","182","176","172","174","178","180","172","164","174"]},"When the depth write enable\/disable bit indicates that depth buffer writes are enabled, the memory controller  performs a write back cycle. When the memory controller  releases the bus, the rendering processor writes the cache data on the memory bus. This data reaches the depth buffer .",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 5","b":["172","174","106","126","136","182","174","126","136","172","174"]},"Referring to , zone control register  includes multiple fields including a depth write disable field  for storing depth write control signals , typically implemented as one or more bit(s). Memory controller  uses depth write control bits  to determine whether evictions from the depth cache  should be written to depth buffer . In an embodiment, the zone control register  implements depth write control bits such as depth write disable bit .","In operation, a graphics application (not shown) supplies instructions , including zone control instructions , into the instruction stream. The instructions  are stored in a memory area  and accessible to graphics-binning engine  and graphics-rendering engine  which decode and execute them. During the zone rendering mode, zone control register  is made to be the active register during the processing of zone control instruction  from the instruction stream.","In a typical implementation, depth write disable control instruction  provides a depth write control value  (local control address+depth write disable bit) that is loaded into zone control register . A depth write disable field  allows graphics application software or operating software to request depth write disable to be enabled so that normal evictions  from depth cache  to depth buffer  are prevented. In particular, in the binning stage, primitives  are decomposed into zones  that are aligned to depth cache . Since graphics device  only works on a small portion of the screen at a time i.e. a zone , it is able to hold the frame buffer contents for the entire zone  in depth cache . Only the minimum number of color memory writes need to be performed to generate the final image one zone at a time, and color memory reads and depth memory reads and writes to depth buffer  can be minimized or avoided altogether. A (constant) clear depth value can be generated and written to depth buffer . Similarly, a (constant) clear stencil value is written to depth buffer . A special primitive can also be used to perform a fast clear of the depth or any other memory areas. When depth write disable bit  of zone control register  is set, the depth eviction detection logic  prevents depth value writes  to depth buffer .","Embodiments of the present invention also provide for automatic override of depth write disable configuration  when evictions from depth cache  to depth buffer  are necessary. Depth write enable control instruction  provides a depth write control value (local control address and depth write enable bit)  that is loaded into zone control register . Depth write enable field  allows graphics application software or operating software to request depth write to be enabled so that evictions  from depth cache  to depth buffer  are allowed to be written.","Evictions from depth cache  written to depth buffer  may be desirable in various situations and is not limited to any of the configurations discussed herein. For example, depth cache  may need to write data back to depth buffer  in multiple context applications, when rendering partially binned scenes, when the cache is flushed, when a valid cache line is deallocated to provide space for a line of new data in the cache, or when the only valid copy of data is in the cache and the graphics engine  wants to use, or partially overwrite, that data. In each of these cases, the only valid copy of data may be in depth cache  so that a write to memory is required to assure that the data in memory is not stale.","For example, depth write control circuit can be used with a system and method for rendering multiple images on multiple display devices using a graphics-rendering engine . Graphics-rendering engine  may alternate between the processing of instructions associated with a first independent image and instructions associated with a second independent image. In particular, graphics-rendering engine  may switch between processing instructions from different ring buffer memory areas or by processing instruction from two different graphics applications within the same instruction stream. Graphics-rendering engine  need not wait to completely process all of the instructions associated with the first independent image before starting to process instructions associated with the second independent image. To facilitate context switching, depth cache  needs to be used by another graphics context or purpose prior to the completion of rendering. In such case, depth write evictions need to be written to the appropriate graphics context's depth buffer. Previously written depth values can be read back into depth cache  later when necessary. Allowing such evictions permits the cached depth values  to be written to the appropriate graphics context's depth buffer .","Evictions  from depth cache  to depth buffer  may be desirable where a partially binned scene needs to be rendered (in order to free memory resources and\/or permit intermediate access to the partial scene results) and then subsequently resumed. Zones  of a scene are sometimes rendered before the scene is completely binned. This situation may arise from resource (instruction, vertex or texture memory) limitations that may not allow the entire scene to be binned.","In particular, if additional free memory cannot be made, graphics rendering engine  renders a partially-binned scene to free up bin memory and then restarts binning the remainder of the scene. In a typical embodiment, a direct write of zone control register  to set a synchronous end scene bit  is performed. This causes graphics binning engine  to (a) close all valid bins  by terminating them with an instruction to end the batch buffer, (b) flush out any internally cached data (e.g., cached bin pointers ), and (c) modify the state-tracking information associated with bins  such that, upon resumption of binning, all necessary state is inserted into a bin  prior to the first primitive  it receives. A direct write of a bin scene register  causes pending scene counter  to get incremented. The depth write enable bit  is cleared prior to rendering the partial scene as the rendering of the continuation of the scene will require depth values to have been written to memory. Binning of the scene is resumed through a direct write of the zone control register  to set a resume bit .","The present invention also prevents the rendering of a zone  from increasing latency of competing operations (e.g., dual display) and effectively eliminates hard limits on scene resources (bin list memory, texture memory, etc.).","Another typical implementation is the interruption of the rendering of a zone  by another ring. Here the rendering performed in the other ring (indeed, simply the logical context switch to the other ring) will force evictions from the depth cache . In order to resume the rendering of the zone , intermediate color and depth values must have been written to the memory resident buffers, such as depth buffer \u2014where the depth cache  misses will bring the zone's color and depth value back into the depth cache  if subsequently required.","In yet another typical implementation, evictions  from the depth cache  due to logical context switch or flush operations are not gated by depth write disable bit . When zone rendering is resumed, the setting of depth write disable bit  is restored and will subsequently gate depth eviction (e.g. writes).","Furthermore, another embodiment attempts to gain access to the target color and\/or depth buffer  (which have yet to be rendered). This access may come either explicitly via a lock operation or implicitly via a copy operation that reads the yet to be rendered color or depth buffer . In this case, the depth write disable feature is typically only used during the final phase of scene rendering.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 6","b":["190","172","174","172","192","174","174"]},"A particular zone control register is made to be the active register during the processing of a zone control instruction from the instruction stream being stored in a corresponding ring buffer memory area (step ). In a typical implementation, the graphics applications supply instructions into the instruction stream. The graphics-rendering engine decodes specific instructions from the instruction stream to find out what information the instruction contains (for example, zone control or a state variable change to apply or a primitive to be rendered). These instructions may be stored in a ring buffer memory area that is usually associated with a particular display device. The graphics-rendering engine then executes the instruction accordingly.","In a typical implementation, the zone control instruction provides a depth write disable value (local control address+depth write disable bits) to be loaded into the zone control register (step ).","Whether the depth and\/or other values (such as stencil values)  should be evicted from the render cache  to the depth buffer  is determined (step ). For example, the embodiment  detects those render configurations such as zone rendering where a render or alternative cache is used to hold data and normal evictions to the depth buffer  are not needed. The present invention can detect whether a depth write disable value (local control address+depth write disable bits) was loaded into the zone control register.","If no eviction is desired (i.e. the depth write disable bit  of a zone control register is set) (step ), the depth eviction detection logic  prevents depth value writes  to the depth buffer  (step ). In a typical implementation, a depth write disable field allows graphics application software or operating software to request depth write disable to be enabled so that evictions  from the render cache  to the depth buffer  are prevented.","Having now described the invention in accordance with the requirements of the patent statutes, those skilled in the art will understand how to make changes and modifications to the present invention to meet their specific requirements or conditions. Such changes and modifications may be made without departing from the scope and spirit of the invention as set forth in the following claims."],"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
