---
title: Use of minimal propagation delay path to optimize a mesh network
abstract: The present technology relates to protocols relative to utility meters associated with an open operational framework. More particularly, the present subject matter relates to protocol subject matter for advanced metering infrastructure, adaptable to various international standards, while economically supporting a 2-way mesh network solution in a wireless environment, such as for operating in a residential electricity meter field. The present subject matter supports meters within an ANSI standard C12.22/C12.19 system while economically supporting a 2-way mesh network solution in a wireless environment, such as for operating in a residential electricity meter field, all to permit cell-based adaptive insertion of C12.22 meters within an open framework. Particular present features relate to the use of minimal propagation delay path to optimize a mesh network.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08848571&OS=08848571&RS=08848571
owner: Itron, Inc.
number: 08848571
owner_city: Liberty Lake
owner_country: US
publication_date: 20130228
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["PRIORITY CLAIMS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS","Example","Example","TABLE OF DEFINITIONS"],"p":["This application is a continuation of prior U.S. patent application Ser. No. 12\/902,853 filed Oct. 12, 2010, to be issued Mar. 5, 2013 as U.S. Pat. No. 8,391,177 entitled \u201cUSE OF MINIMAL PROPAGATION DELAY PATH TO OPTIMIZE A MESH NETWORK\u201d, which is a continuation of U.S. patent application Ser. No. 11\/900,202 filed Sep. 10, 2007, issued Nov. 30, 2010 as U.S. Pat. No. 7,843,834 and bearing the same title, which claims the benefit of two previously filed U.S. Provisional Patent Applications entitled \u201cMETERING RF LAN PROTOCOL AND CELL\/NODE UTILIZATION AND MANAGEMENT,\u201d respectively assigned U.S. Ser. No. 60\/845,056, as filed Sep. 15, 2006, and assigned U.S. Ser. No. 60\/845,994, as filed Sep. 20, 2006, all of which are hereby incorporated herein by reference in their entireties for all purposes. Any disclaimer that may have occurred during prosecution of the above-referenced application(s) is hereby expressly rescinded.","The present technology relates to protocols relative to utility meters associated with an open operational framework. More particularly, the present subject matter relates to protocol subject matter for advanced metering infrastructure, adaptable to various international standards, while economically supporting a 2-way mesh network solution in a wireless environment, such as for operating in a residential electricity meter field.","The general object of metrology is to monitor one or more selected physical phenomena to permit a record of monitored events. Such basic purpose of metrology can be applied to a variety of metering devices used in a number of contexts. One broad area of measurement relates, for example, to utility meters. Such role may also specifically include, in such context, the monitoring of the consumption or production of a variety of forms of energy or other commodities, for example, including but not limited to, electricity, water, gas, or oil.","More particularly concerning electricity meters, mechanical forms of registers have been historically used for outputting accumulated electricity consumption data. Such an approach provided a relatively dependable field device, especially for the basic or relatively lower level task of simply monitoring accumulated kilowatt-hour consumption.","The foregoing basic mechanical form of register was typically limited in its mode of output, so that only a very basic or lower level metrology function was achieved. Subsequently, electronic forms of metrology devices began to be introduced, to permit relatively higher levels of monitoring, involving different forms and modes of data.","In the context of electricity meters specifically, for a variety of management and billing purposes, it became desirable to obtain usage data beyond the basic kilowatt-hour consumption readings available with many electricity meters. For example, additional desired data included rate of electricity consumption, or date and time of consumption (so-called \u201ctime of use\u201d data). Solid state devices provided on printed circuit boards, for example, utilizing programmable integrated circuit components, have provided effective tools for implementing many of such higher level monitoring functions desired in the electricity meter context.","In addition to the beneficial introduction of electronic forms of metrology, a variety of electronic registers have been introduced with certain advantages. Still further, other forms of data output have been introduced and are beneficial for certain applications, including wired transmissions, data output via radio frequency transmission, pulse output of data, and telephone line connection via such as modems or cellular linkups.","The advent of such variety and alternatives has often required utility companies to make choices about which technologies to utilize. Such choices have from time to time been made based on philosophical points and preferences and\/or based on practical points such as, training and familiarity of field personnel with specific designs.","Another aspect of the progression of technology in such area of metrology is that various retrofit arrangements have been instituted. For example, some attempts have been made to provide basic metering devices with selected more advanced features without having to completely change or replace the basic meter in the field. For example, attempts have been made to outfit a basically mechanical metering device with electronic output of data, such as for facilitating radio telemetry linkages.","Another aspect of the electricity meter industry is that utility companies have large-scale requirements, sometimes involving literally hundreds of thousands of individual meter installations, or data points. Implementing incremental changes in technology, such as retrofitting new features into existing equipment, or attempting to implement changes to basic components which make various components not interchangeable with other configurations already in the field, can generate considerable industry problems.","Electricity meters typically include input circuitry for receiving voltage and current signals at the electrical service. Input circuitry of whatever type or specific design for receiving the electrical service current signals is referred to herein generally as current acquisition circuitry, while input circuitry of whatever type or design for receiving the electrical service voltage signals is referred to herein generally as voltage acquisition circuitry.","Electricity meter input circuitry may be provided with capabilities of monitoring one or more phases, depending on whether monitoring is to be provided in a single or multiphase environment. Moreover, it is desirable that selectively configurable circuitry may be provided so as to enable the provision of new, alternative or upgraded services or processing capabilities within an existing metering device. Such variations in desired monitoring environments or capabilities, however, lead to the requirement that a number of different metrology configurations be devised to accommodate the number of phases required or desired to be monitored or to provide alternative, additional or upgraded processing capability within a utility meter.","More recently a new ANSI protocol, ANSI C12.22, is being developed that may be used to permit open protocol communications among metrology devices from various manufacturers. C12.22 is the designation of the latest subclass of the ANSI C12.xx family of Meter Communication and Data standards presently under development. Presently defined standards include ANSI C12.18 relating to protocol specifications for Type 2 optical ports; ANSI C12.19 relating to Utility industry Meter Data Table definitions; and ANSI C12.21 relating to Plain Old Telephone Service (POTS) transport of C12.19 Data Tables definition. It should be appreciated that while the remainder of the present discussion may describe C12.22 as a standard protocol, that, at least at the time of filing the present application, such protocol is still being developed so that the present disclosure is actually intended to describe an open protocol that may be used as a communications protocol for networked metrology and is referred to for discussion purposes as the C12.22 standard or C12.22 protocol.","C12.22 is an application layer protocol that provides for the transport of C12.19 data tables over any network medium. Current standards for the C12.22 protocol include: authentication and encryption features; addressing methodology providing unique identifiers for corporate, communication, and end device entities; self describing data models; and message routing over heterogeneous networks.","Much as HTTP protocol provides for a common application layer for web browsers, C12.22 provides for a common application layer for metering devices. Benefits of using such a standard include the provision of: a methodology for both session and session-less communications; common data encryption and security; a common addressing mechanism for use over both proprietary and non-proprietary network mediums; interoperability among metering devices within a common communication environment; system integration with third-party devices through common interfaces and gateway abstraction; both 2-way and 1-way communications with end devices; and enhanced security, reliability and speed for transferring meter data over heterogeneous networks.","To understand why utilities are keenly interested in open protocol communications; consider the process and ease of sending e-mails from a laptop computer or a smart phone. Internet providers depend on the use of open protocols to provide e-mail service. E-mails are sent and received as long as e-mail addresses are valid, mailboxes are not full, and communication paths are functional. Most e-mail users have the option of choosing among several Internet providers and several technologies, from dial-up to cellular to broadband, depending mostly on the cost, speed, and mobility. The e-mail addresses are in a common format, and the protocols call for the e-mail to be carried by communication carriers without changing the e-mail. The open protocol laid out in the ANSI C.12.22 standard provides the same opportunity for meter communications over networks.","In addition, the desire for increased mesh network operational capabilities as well as other considerations including, but not limited to, a desire to provide improved capabilities for individual metrology components in an open operational framework, leads to requirements for interfacing such components with mesh network system applications.","As such, it is desired to provide an improved protocol for advanced metering infrastructure applications in an open operational framework.","While various aspects and alternative embodiments may be known in the field of utility metering, no one design has emerged that generally encompasses the above-referenced characteristics and other desirable features associated with utility metering technology as herein presented.","In view of the recognized features encountered in the prior art and addressed by the present subject matter, improved apparatus and corresponding methodology allowing advanced metering infrastructure in an open operational framework have been provided.","In an exemplary arrangement, methodology and corresponding apparatus have been provided to permit transmission of information between a utility meter and an operational application through a frequency hopping network operated in accordance with present protocol subject matter.","In one of its simpler forms, the present technology provides an improved network and meter protocols.","One positive aspect of the present subject matter is that it supports meters within an ANSI standard C12.22\/C12.19 system while economically supporting a 2-way mesh network solution in a wireless environment, such as for operating in a residential electricity meter field, all to permit cell-based adaptive insertion of C12.22 meters within an open framework.","Another positive aspect of the present subject matter is that it provides for cell isolation through quasi-orthogonal sequences in a frequency hopping network. Some additional positive aspects relating to a network operated per the present protocol subject matter relate to real time clock distribution and recovery, uplink routing without requiring a routing table, and the handling of Beacon Requests and Registered State bit resolving to avoid circular routes.","Still additional positive aspects of the present protocol subject matter as relates to cell or node utilization or management in a mesh network, relate to cell size management, to Number-of-sons' management, to crystal drift compensation in a mesh network, to broadcast acknowledgement features, and to Traffic Load Control in a Mesh Network.","Additional aspects of the present subject matter relate to Embedded RF environmental evaluation tool features to gauge the performance need of RF transceivers, Downlink routing mechanisms, Outage notification system features, the use of minimal propagation delay path to optimize a mesh network, and operation at the node level of a Discovery Phase in a frequency hopping network.","An exemplary present methodology relates to a method for optimizing an advanced metering system mesh network. Such an exemplary method may comprise establishing a network including a central facility root node and a plurality of node devices, at least some of which node devices comprise metrology devices; configuring the network for bi-directional communications between the central facility root node and each of the plurality of node devices; computing an average local propagation delay for each one-hop link; computing the total propagation delay along each path to the central facility root node; selecting at each node device the shortest value of total propagation delay to define its own global propagation delay value; and conducting communications using the path corresponding to the selected value. With such an exemplary method, communications among nodes within the network may be optimized.","Still another present exemplary methodology relates to a method for optimizing an advanced metering system mesh network. Such present exemplary methodology may comprise establishing a network including a central facility root node and a plurality of node devices, at least some of which node devices comprise metrology devices; configuring the network for bi-directional communications between the central facility root node and each of the plurality of node devices; computing an average local propagation delay for each one-hop link; propagating global propagation delay information from the central facility root node to each of the node devices on a step by step basis; storing global propagation delay information at each node device; and conducting communications using a path corresponding to the shortest value of total propagation delay based on the stored global propagation delay information and the average local propagation delay. With such methodology, each node device may advantageously select a communications path based only on knowledge of its own average local propagation delay and the global propagation delay information from immediate neighbor node devices.","Still further present exemplary methodologies are provided by alternatively incorporating various present features. One example is the further inclusion of each node making available its own global propagation delay value by updating its message header. In still further alternatives, present exemplary methodologies may include the average local propagation delay being derived by maintaining a record of all communication attempts with each one of the plurality of node devices in the direction of the central facility root node; and computing a statistical communication success rate for each one of the plurality of node devices.","In certain present alternatives, the average local propagation delay for each one-hop link is computed using the relationship:",{"@attributes":{"id":"p-0032","num":"0031"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"D","mo":"=","mrow":{"msub":{"mi":["T","d"]},"mo":"+","mrow":{"msub":{"mi":["T","r"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mrow":{"mn":"1","mo":"-","mi":"P"},"mi":"P"}}}}}}},"br":{},"sub":["d ","r "]},{"@attributes":{"id":"p-0033","num":"0032"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},{"mfrac":{"mrow":{"mi":"PS","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},"msub":{"mi":["N","av"]}},"mo":"+","mrow":{"mfrac":{"mrow":{"msub":{"mi":["N","av"]},"mo":"-","mn":"1"},"msub":{"mi":["N","av"]}},"mo":"\u2062","mrow":{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}}}}],"mo":"="}}},"br":{},"sub":"av "},{"@attributes":{"id":"p-0034","num":"0033"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":["D","r"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},{"mo":"{","mtable":{"mtr":[{"mtd":[{"mfrac":{"mrow":[{"mrow":{"msub":{"mi":["N","av"]},"mo":"\u2062","mrow":{"msub":{"mi":["D","r"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}}},"mo":"+","mn":"1"},{"msub":{"mi":["N","av"]},"mo":"-","mn":"1"}]}},{"mrow":{"mrow":{"mi":"if","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mi":"PS","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}},"mo":"=","mn":"0"}}]},{"mtd":[{"mfrac":{"mrow":[{"mrow":[{"mo":["(",")"],"mrow":{"msub":{"mi":["N","av"]},"mo":"-","mn":"1"}},{"msub":{"mi":["D","r"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}}],"mo":"\u2062"},{"mrow":{"msub":{"mi":["D","r"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}},"mo":"+","msub":{"mi":["N","av"]}}]}},{"mrow":{"mrow":{"mi":"if","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mi":"PS","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}},"mo":"=","mn":"1"}}]}]}}],"mo":"="}}},"br":{}},"It is to be understood that the present subject matter equally pertains to corresponding apparatus subject matter. One exemplary present embodiment relates to an advanced metering system mesh network, comprising a central facility root node; and a plurality of node devices. Preferably, in such exemplary embodiment, each node device is configured for bi-directional communications with the central facility root node, and at least some of which node devices comprise metrology devices. In such exemplary embodiment, each node device preferably is further configured to compute an average propagation delay for each one-hop link to itself in the mesh network and to select the shortest transmission path to the central facility root node based only on its own computed average propagation delay and global propagation delay information stored in its immediate neighbors. With such an arrangement, communications between the central facility root node and the plurality of node devices may advantageously be optimized. Other features as expressed herein may be provided in other combinations, likewise forming exemplary present embodiments.","Additional objects and advantages of the present subject matter are set forth in, or will be apparent to, those of ordinary skill in the art from the detailed description herein. Also, it should be further appreciated that modifications and variations to the specifically illustrated, referred and discussed features, elements, and steps hereof may be practiced in various embodiments and uses of the present subject matter without departing from the spirit and scope of the subject matter. Variations may include, but are not limited to, substitution of equivalent means, features, or steps for those illustrated, referenced, or discussed, and the functional, operational, or positional reversal of various parts, features, steps, or the like.","Still further, it is to be understood that different embodiments, as well as different presently preferred embodiments, of the present subject matter may include various combinations or configurations of presently disclosed features, steps, or elements, or their equivalents including combinations of features, parts, or steps or configurations thereof not expressly shown in the figures or stated in the detailed description of such figures. Additional embodiments of the present subject matter, not necessarily expressed in the summarized section, may include and incorporate various combinations of aspects of features, components, or steps referenced in the summarized objects above, and\/or other features, components, or steps as otherwise discussed in this application. Those of ordinary skill in the art will better appreciate the features and aspects of such embodiments, and others, upon review of the remainder of the specification.","Repeat use of reference characters throughout the present specification and appended drawings is intended to represent same or analogous features, elements, or steps of the present subject matter.","Various discussion herein makes us of and\/or relies on abbreviations and acronyms, having the intended meanings as set forth in the appended Table of Definitions, which forms part of the present disclosure.","A reference model for interconnection of open systems (referred to as OSI\u2014Open Systems Interconnection) has been described by ISO (the International Standards Organization). Such model, represented by present , is a functional decomposition of a communication system. In other words, the different layers perform different functions. A layer N offers services to the layer above N+1, by enhancing the services offered to this layer N by the underlying layer N\u22121. Such architecture allows further modifications on one layer without changing the others. Moreover, it allows compatibility between different protocols based on the same principle.","Selected combinations of aspects of the disclosed technology correspond to a plurality of different embodiments of the present subject matter. It should be noted that each of the exemplary embodiments presented and discussed herein should not insinuate limitations of the present subject matter. Features or steps illustrated or described as part of one embodiment may be used in combination with aspects of another embodiment to yield yet further embodiments. Additionally, certain features may be interchanged with similar devices or features not expressly mentioned which perform the same or similar function.","The present subject matter network and protocol architecture may be described as based on a tree with four kinds of elements, spread on cells, represented by present . At the top of such architecture is a Collection Engine, which acts as a central database. It knows all the cells and their contents, that is, the cell where each meter is and its address. It also collects monthly data from every endpoint and it allows access to any meter in the network. The user can request or send data to a single meter or broadcast information. The Collection Engine can communicate with the router of the selected cell by TCP\/IP protocol inside Internet network.","In such tree hierarchy, just below the Collection Engine stand routers of the cells, referred to as the Cell Relays. There is one Cell Relay for each cell and it is the gateway between individual meters in the cell and the Collection Engine. The Cell Relay contains a routing table of all the meters in its cell. It can also forward data in the two directions, that is, between the Collection Engine and the endpoints. It also assumes the role of synchronizing the cell.","At the bottom of such tree are located so-called Endpoints (EPs). They can transmit and receive metering information. In addition, each one of them can act as a relay for distant endpoints with no additional hardware.","The last indicated module of such four kinds of elements is the Walk-By unit, a Zigbee handheld that can communicate with orphans or configure the subject protocol parameters. This module doesn't itself contain the subject protocol. It uses the Zigbee part of the register to communicate with it.","Therefore, the subject network uses 3 media, which are the subject RF link, a Zigbee RF Link, and a TCP\/IP link, all as represented per present .","Present  represents in part the subject protocol, which in part is based on the 3 first layers of the subject layer model, respectively labeled as: Physical, Data Link and Network Layer. Such Data Link Layer is further divided into 2 sub-layers, MAC (Medium-Access Control) and LLC (Logical-Link Control). As represented, each layer can communicate by way of the SAP (Service Access Point) with layers just below and just above.  represents the layer model of an EP (endpoint) incorporating a cell relay module option. On the top of the stack, the API layer is communicating with the meter itself to exchange metering data or with the Cell Relay application. The left stack represents the Cell Master while the right one is the Cell Relay WAN section (or Cell Relay board).","The following discussion describes each layer of present , including their respective functionalities and services.","The Application Layer Interface (API) is not itself part of the subject protocol, but from a network point of view it is the layer just above. One main goal of the present subject matter is to transport data from the API layer. In one exemplary embodiment, in the AMI network the API layer could follow the C12.22 protocol, as discussed throughout the present disclosure. However, it is to be understood that the present subject matter could also work with another API layer.","The network layer is the highest layer of the present protocol subject matter. It is in charge of routing the packets to their final destination. To be able to do this it manages a table of its 1-hop neighbors obtained through the MAC layer. For an uplink message (towards the cell relay (CR)), this table allows the NET layer to send the message to the best 1-hop neighbor of lower level. The NET layer of the next endpoint repeats this operation until it reaches the cell relay (lowest level in the cell).","The cell relay (or cell master) NET layer is preferably one exception since it is the only one that can send a message to any endpoint (EP) in the cell; it is possible because the CR NET has all the neighbor (or father) tables of the cell and thus is able to send a message with all the addresses (the whole path) in the header. The CR (or CM) NET layer can also send a broadcast message to all EPs in the cell. For this each NET layer sends this message to all its sons.","The Logical Link Control (LLC) layer is mainly in charge of repetition of messages that have not been heard (including in the case of broadcast) and of fragmentation of messages that are too long. It also filters duplicated messages, in both directions, to not overburden the NET layer or the RF link, Finally, it is often used as just a link between the NET and MAC layers.","The Medium Access Control (MAC) layer handles the largest number of tasks or functions. First, the MAC layer is the synchronization manager. When the power is turned on it tries to find a cell and once connected to it, it adjusts its level to stay in contact with the best possible father.","It is to be understood by those of ordinary skill in the art that various terms may be used to describe certain functional relationships. For example, the terms father or parent may be used interchangeably relative to the terms son or child. Choice of such terms herein is not meant to convey particular limitations or meaning beyond the context in which they are presented, as will be understood by those of ordinary skill in the art.","Among the layers of the subject protocol, the MAC layer is the only one to have a notion of time. The subject protocol time is divided into Time Slots (TS) and the MAC layer aligns them with the ones of its fathers, which do the same until operation of the cell relay (which is the time reference in the network). Such synchronization is done through time information included by the MAC layers in the header of all packets. If there is no traffic the MAC layer sends beacons so that its sons can stay synchronized with him.","Another task of the MAC layer is to acknowledge messages received. Positive or negative acknowledgement (ACK or NACK) is possible. These are 1-hop acknowledgements. However, if the API layer needs an end-to-end acknowledgement, it needs to insert the request in the message it sends. The MAC layer also inserts several personal parameters in the header of all messages it sends. When receiving packets from its neighbors, it extracts these parameters and manages a table of its neighborhood. Part of this table is communicated to the NET layer.","Finally, the MAC layer computes a CRC (Cyclic Redundancy Check) on the packets and adds it at the end before giving it to the PHY layer for transmission or uses it upon reception of a message for error detection.","The Physical (PHY) layer is in charge of transmitting data on the RF link. It is by default in receiving mode and never decides on its own to transmit. All its instructions, including packets to send, come from the MAC layer. Before transmitting a packet it computes and adds FEC and then adds a preamble and a header to this protected packet. When it receives a packet, it removes these 2 additions before delivering the data to the MAC layer. The physical layer also provides the received packet power (RSSI) and time of reception for the MAC layer. As a last service, it can also measure and give the RSSI value on the current listening channel.","Present  are concerned more particularly with exemplary apparatus and methodology for providing an interface between a meter in an advanced metering system and an application running on such a system, thereby allowing plug-n-play compatibility (i.e., interchangeability) of metrology devices in the subject open operational framework, such as for ANSI standard C12.22 meters, otherwise discussed herein. Also, present  relate to exemplary apparatus and methodologies for downloading firmware through a network as discussed herein to end devices including utility meters and relays, such as for upgrading firmware in previously installed revenue meters in communication and cell\/node relationships per protocol as otherwise described herein. A viral propagation methodology is disclosed as an alternative to at least portions of the broadcast methodology. Various such features may involve downloading firmware in an RF mesh network that is arranged in hierarchical layers, or a \u201ctree\u201d-configured arrangement, as otherwise discussed herein.",{"@attributes":{"id":"p-0152","num":"0151"},"figref":"FIG. 3A","b":["100","100"]},"Major components of AMS  include exemplary respective meters , , , , , , , and ; one or more respective radio-based networks including RF neighborhood area network (RF NAN)  and its accompanying Radio Relay , and power line communications neighborhood area network (PLC NAN)  and its accompanying PLC Relay ; an IP (internet protocol) based Public Backhaul ; and a Collection Engine . Other components within exemplary AMS  may include a utility LAN (local area network)  and firewall  through which communications signals to and from Collection Engine  may be transported from and to respective exemplary meters , , , , , , , and  or other devices including, but not limited to, Radio Relay  and PLC Relay .","AMS  is configured to be transparent in a transportation context, such that exemplary respective meters , , , , , , , and  may be interrogated using Collection Engine  regardless of what network infrastructure exists in-between or among such components. Moreover, due to such transparency, the meters may also respond to Collection Engine  in the same manner.","As represented by the illustration in , Collection Engine  is capable of integrating Radio, PLC, and IP connected meters. To facilitate such transparency, AMS  operates and\/or interfaces with ANSI standard C12.22 meter communication protocol for networks. C12.22 is a network transparent protocol, which allows communications across disparate and asymmetrical network substrates. C12.22 details all aspects of communications, allowing C12.22 compliant meters produced by third parties to be integrated into a single advanced metering interface (AMI) solution. AMS  is configured to provide meter reading as well as load control\/demand response, in home messaging, and outage and restoration capabilities. All data flowing across the system is sent in the form of C12.19 tables. The system provides full two-way messaging to every device; however, many of its functions may be provided through broadcast or multicast messaging and session-less communications.","With present reference to , there is illustrated a block diagram of an exemplary meter  incorporating interface features in accordance with the present subject matter. Meter  preferably incorporates several major components including Metrology , a Register Board , and one or more communications devices. In the presently illustrated exemplary configuration, meter  may include such as an RF LAN Interface  and accompanying antenna , and a Zigbee Interface  and its accompanying antenna . In addition, an Option Slot  may be provided to accommodate a third party network or communications module .","Metrology  may correspond to a solid-state device configured to provide (internal to the meter) C12.18 Blurt communications with Register Board . Communications within meter  are conducted via C12.22 Extended Protocol Specification for Electronic Metering (EPSEM) messages. The meter Register Board  is configured to fully support C12.19 tables and C12.22 extensions. While all meter data will be accessible via standard C12.19 tables, in order to facilitate very low bandwidth communications, manufacturers tables or stored procedures are included which provide access to specific time-bound slices of data, such as the last calendar day's worth of interval data or other customized \u201cgroupings\u201d of data.","Meter  may be variously configured to provide differing communications capabilities. In exemplary configurations, one or more of GPRS, Ethernet, and RF LAN communications modules may be provided. GPRS will allow meters to be IP addressable over a public backhaul and provide more bandwidth than the meter will likely ever require, but may incur ongoing subscription costs. Ethernet connectivity can be used to bridge to third party technologies, including WiFi, WiMax, in-home gateways, and BPL (Broadband over Power Lines), without integrating any of these technologies directly into the metering device, but with the tradeoff of requiring external wiring and a two part solution. Ethernet devices may be used primarily in pilots and other special applications, and they additionally may be ideal for certain high-density RF-intolerant environments, such as meter closets.","Due to the increased complexity of managing a WAN interface, with its more sophisticated link negotiation requirements and TCP\/IP (Transmission Control Protocol\/Internet Protocol) stack, WAN connected meters may include an additional circuit board dedicated to WAN connectivity. Such board if used would preferably interface with meter  using EPSEM messages and Option Slot .","The availability of Option Slot  within meter  provides the advantage that it will make meter  available for integration with third party backhauls, such as PLC (Power Line Communications). In order for such third party devices to be integrated into AMS , on the other hand, third party devices will need to include both a communications board and a C12.22 compliant relay to couple communications signals from any proprietary network of the third party to an IP connection. Alternatively, third parties could integrate meter  into their own end-to-end solution.","The communications protocol between meter  and respective communications modules , , and WAN module or optional third party communications module , follow the C12.22 standards, allowing any third party to design to the standard and be assured of relatively straightforward integration.","Communication with the Collection Engine  is performed over an Internet Protocol connection. The Wide-Area-Network is a fully routable, addressable, IP network that may involve a variety of different technologies including, but not limited to, GPRS, WiFi, WiMax, Fiber, Private Ethernet, BPL, or any other connection with sufficiently high bandwidth and ability to support full two-way IP communication. Several assumptions (that is, criteria of the present subject matter) may be made regarding the IP WAN. Collection Engine  is preferably implemented so as to be able to communicate directly with other respective nodes on the IP WAN. While communications may be conducted through a firewall , it is not necessary that such be proxied, unless the proxy is itself a C12.22 node functioning as a relay between a private IP network and the public IP WAN.","Further in accordance with the present subject matter, the interface between meters and applications manager (IMA Manager) provided by the present technology facilitates communications between upper level devices including, but not limited to, Collection Engine  and the various respective meters and other devices within AMS . More particularly, the IMA Manager uses a C12.22 manager to create an Extended Protocol Specification for Electronic Meters (EPSEM) message object wrapped in an Application Control Service Element (ACSE) object, to send the message to a native network, to receive a response from the native network, and to return an ACSE object with the EPSEM response embedded. The IMA Manager preferably would then utilize the IMA for the device class in order to build an EPSEM message to be sent to the meters.","The IMA Manager will merge the EPSEM message with any necessary ApTitles to form an ACSE message and then will pass the ACSE message to the C12.22 Manager. The C12.22 Manager will then send the ACSE message to the appropriate meters. A response from a meter may be received from the network into the C12.22 Manager, which will parse the ACSE message so as to extract the ApTitle and EPSEM message. Later, the C12.22 Manager receives a response from the previous ACSE message, parses the ACSE response and sends it to the IMA Manager.","The IMA Manager processes an exception response and submits it to an exception manager, which delivers the exception to all systems that have subscribed to that exception type. The IMA Manager utilizes a Metadata store to retrieve any information about the calling ApTitle, such as the device class and EDL configuration file, and then utilizes the IMA for the device class to interpret, for example, that an outage has occurred.","The IMA Manager will inform the Exception Manager which respective meter has experienced an outage. The Exception Manager obtains a list of subscribers for the supplied Exception Type from the Metadata Store API, and then sends the message to every notification system that has subscribed to notifications of the exception's type.","The Advanced Metering System of the present technology provides a series (or plurality) of services (functionalities) to utilities. In its most basic implementation, it provides daily feeds of residential interval or TOU (Time of Use) data. Beyond such functionality, it provides power outage and restoration notifications, on-demand readings, firmware updates, load control\/demand response, gas meter readings, and in-home display messages. All of such functions (services) are communicated via the C12.22 protocol. In order to optimize use of the low-bandwidth RF LAN, selected operations assume use of manufacturer procedures within the meter; however, the general C12.22 communication engine of the system is not specific to any particular tables, devices, or manufacturers. In the future, in accordance with the present subject matter, as alternate network substrates may become available, the RF LAN can very easily be swapped out with other technologies.","With present reference to , it will be seen that an exemplary Advanced Metering System (AMS) generally  deployment has been illustrated.  illustrates for exemplary purposes only a single RF LAN cell, with twelve respective member nodes organized into three levels, as well as four directly connected IP meters , , , and . In such system, all respective meter devices , , , , , , , , , , , , , , , , , and , Cell Relay , and Collection Engine , have C12.22 network addresses. Collection Engine  may in accordance with the present subject matter have multiple C12.22 addresses to allow for separate addressing between different services (functionalities). Meter (or Master) data management system  is not part of the C12.22 network, but preferably it will be implemented so as to communicate over the Utility LAN  to Collection Engine  via Web Services. Communications between Cell Relay  and Utility LAN  variously involve Public Backhaul  and firewall , in a manner analogous to that discussed above in conjunction with Public Backhaul  and firewall  (), as well understood by those of ordinary skill in the art.","The meter data acquisition process begins with the Meter (or Master) Data Management System  initiating a request for data. Such operation is done through a web services call to Collection Engine  and may be performed without knowledge of the configured functionality of the end-device. Collection Engine  analyzes the request for data, and formulates a series of C12.22 multicast (or broadcast) data requests. Such requests are then sent out either directly to the device (in the case of an IP connected meter, such as ), or to Cell Relay  that relays the message out to all appropriate nodes. Broadcast and multicast messages are sent by Cell Relay  to all members of the cell, either via an AMS RF LAN-level broadcast, or by the Cell Relay repeating the message. For efficiency sake, the use of an RF LAN level broadcast may be preferred.","Typically these requests are sent as a call to a manufacturer's stored procedure. In C12.22, stored procedure calls are performed as writes to a predetermined table, e.g. \u201ctable 7.\u201d The stored procedure will send the default upload configured for such device. For example, a given meter may be configured to upload two channels of hourly interval data, plus its event history. Another meter might be programmed to send up its TOU registers. The stored procedure will require four parameters to be fully operative in accordance with the present subject matter: data start time, data end time, response start time, and response end time. The data start and end time are be used to select which data to send. The response start time and end time are used to determine the window within which the upstream system wants to receive the data. The various AMS enabled meters of  are preferably field programmable, via C12.22 tables, as to the type data to be included in a default upload.","When data is sent to Collection Engine , is it sent as C12.19 table self-write with the notification bit set, and the do-not-respond bit set. The result is that per the present subject matter no C12.22 acknowledgement is sent in response to the Collection Engine's broadcast, nor does the Collection Engine  in response to the notify-write send any response; however, the notify-write effectively serves per the present subject matter as an acknowledgement to the receipt of the broadcast.","The response processing section can use the configured data about an end device and the response message from the end device to determine the results from the device. The response processing section begins operation associated with a specific job in a task list, but can be switched between any active job that is awaiting a response. Such operation allows responses that contain logs from the device to be parsed by each job that could be waiting for an action to be completed within the end-device. Such also would allow unsolicited messages to be parsed by the IMA code and then later associated with any possible jobs, as determined by the IMA, all in accordance with the present subject matter.","While most operations will not require this, the AMS meters will support chaining a series of EPSEM messages, such as multiple table reads and writes in a single request. This is functionality that is required in the C12.22 specification, and will assist in improving the efficiency of the system, as it avoids the overhead of sending a separate message for each EPSEM command. AMS enabled devices will process each request sequentially, allowing a series of operations to be handled in a single command, each building on the next, such that a read subsequent to a write would reflect the results of the request write. If a command in an EPSEM chain cannot be completed, remaining commands in the chain are rejected with appropriate error messages, per the present subject matter.","When a respective device receives a request, it evaluates the multi-cast address specified. If the device is a member of the multicast group, it responds to the request; otherwise, it discards it. Membership in different multicast groups is determined via use of C12.22 standard table 122.","On-demand reading per the present subject matter is similar to the Daily Meter Data Acquisition Process; however, rather than sending a broadcast or multicast request, the on-demand reading process in accordance with the present subject matter communicates directly to desired respective meters. Such process begins with a user initiated an on-demand read through an AMS User Interface, or through a web services call from an upstream system. Per the present subject matter, an orchestration layer of the Collection Engine  begins by evaluating the current system load of the communications substrate through which the respective device is connected. Requests for an on-demand read from a saturated cell may be rejected.","Once Collection Engine  determines that the request can be honored, it selects per the present subject matter an appropriate communication server within the Collection Engine, and submits the command to retrieve data from the device and return it. The communications server forms a C12.22 table read request, encrypts it, and sends it to the device directly, if IP connected, or to Cell Relay  for RF LAN connected devices. In cases where traffic flows through the RF LAN, the Cell Relay software retrieves the message from the IP backhaul , and evaluates the message. The destination address (in C12.22 terminology, the called ApTitle) may be stripped off to save bandwidth on the network, relying instead on the underlying RF LAN addressing scheme for delivering the message. The Cell Relay software must also examine whether the destination ApTitle is still valid within the cell. If the destination ApTitle is no longer valid, the Cell Relay rejects the message, returning an error packet to the Collection Engine. Provided that the destination is still valid, the Cell Relay software sends the message to the device across the RF LAN, per the present subject matter.","A protocol stack for the RF LAN advantageously takes the message and constructs a node path for the message to take before actually transmitting the packet. Such pre-constructed node path allows Cell Relay  per the present subject matter to push a message down through the tree of the cell without creating redundant radio messages. If Collection Engine  wants to do an on-demand read to meter , it starts by sending the message to Cell Relay . Cell Relay  in turn sends out a transmission that will be heard by both respective meters  and  (in the exemplary configuration of present ). Meter  could go ahead and retransmit the message, but this wouldn't get the message to meter . Instead, it would simply waste bandwidth. With the node path provided to by the RF LAN protocol stack, meters  and  will hear the message, but per the present subject matter only meter  will retransmit the message. The retransmitted message of meter  will be heard by both meters  and , but only meter  will be in the node path, again meaning other parts of the cell (such as meters  and ) won't receive a message that would be useless to them. Both meters  and  will hear the message, but it is only addressed to meter . As such, meter , per the present subject matter, will simply ignore it.","Once the message is received at the subject (i.e., intended) meter, whether via RF LAN or via IP, such meter must unpack the request and act on it. The communications module within the device will pull the C12.22 message off the network substrate and provide it to the Register Board  (). Register Board  will decrypt the message based on shared keys, and then respond to the request, encrypting it and returning it to the calling ApTitle. In the case of the RF LAN, the message is simply forwarded to the next layer up in the cell. Messages are forwarded from one layer to the next until they finally reach Cell Relay , which relays it across the IP backhaul  to the communications server that initiated the transaction.",{"@attributes":{"id":"p-0179","num":"0178"},"figref":"FIG. 3D"},"When new or upgraded firmware is to be installed within a system , an image  of the firmware to be downloaded will be provided to an Advanced Metering System (AMS) Collection Engine  as a binary image file. Further discussion of Collection Engine  is included herewith but for the present it is noted that Collection Engine  is responsible for breaking up the single binary image into a series  of discrete blocks  that can be distributed across a communications arrangement such as an RF LAN, or other media. In an exemplary embodiment, an ANSI C12.22 compliant media may be used. Such blocks  will contain a hash or checksum for the block itself to verify the block's integrity, as well as a block identifier, which is represented in  by the leading and trailing spaces  and , respectively.","In general, when transferring blocks, each broken down, discrete block  is in its entirety preferably written into a record in a manufacturer's table for firmware images. End devices  are configured to evaluate such blocks  to determine their discrete integrity by using their block level hashes. The end devices can also validate that such blocks  are assembled (that is, reassembled) into the correct order. Finally, each end device is able to evaluate the integrity of the overall image by evaluating the CRC (Cyclic Redundancy Check) or hash for the entire image.","The basic present process for transferring firmware image blocks  involves in part functionality that is similar to that used for reading data from meters. A broadcast containing the image blocks  is sent to meters . Meters  indicate, in a manner described further herein, that they have successfully received the image blocks . Meters that don't respond are retried in a recovery process to make up for any failures. Because of the critical nature of firmware images, and the large number of blocks involved, some additional control and feedback mechanisms may be desired in some instances, to logistically handle the volume of traffic.","Managing the transport of firmware blocks  in an environment which encounters or involves unreliable media becomes critical when transferring firmware images. In an exemplary configuration, a 384 k byte firmware image broken into 64 byte blocks will require 6,144 blocks to be transferred completely successfully before it can be loaded. When transferring blocks across an RF LAN, for example, it is relatively likely that at least one node within a given cell will fail to successfully receive a block. Such circumstances are presently addressed in two key manners. First, it is important that blocks be able to be transmitted and received in any order. Second, depending on the practical reliability of the underlying network, in accordance with present subject matter, it may in some instances be practiced to broadcast a given block several times before resorting to point-to-point transfers of image blocks. In an exemplary configuration, it has been found that upper level systems, that is the Collection Engine  and\/or a cell relay , should preferably transmit the firmware image at least twice, and in some instances three or four times, before resorting to point-to-point transfer of image blocks.","With further reference to , a firmware download process begins with the Collection Engine  sending out a broadcast message to all target nodes, calling a manufacturer's stored procedure or writing to a manufacturer's table in the device. In such context, a target node may correspond to an end device such as meter , cell relay , or meters  including representative meters , , and . Such command indicates to the device the number of firmware blocks it should expect to receive, and that it should now be in firmware download mode.","When in such firmware download mode, the device will report the number of blocks it has successfully received as part of any daily read requests. Additionally, being placed in firmware download mode resets to zero a block counter of such device. Moreover, the command includes instructions to the end devices indicating that no direct acknowledgements on the part of the meters should be made. Rather, devices acknowledge such command by reporting their success count as part of the next interrogation cycle.","Collection Engine  is responsible for evaluating, based on the presence of the firmware block success count, whether all of the targeted nodes have successfully entered firmware download mode. Nodes that have not switched to firmware download mode eventually are then individually contacted by the Collection Engine .","Once the target nodes are in firmware download mode, Collection Engine  will begin broadcasting firmware blocks  to the target nodes . As an alternative to transmission of the firmware blocks  exclusively by Collection Engine , it may be desirable to transfer the firmware image  to the cell relays  and then send a command to instruct them to broadcast the firmware image  within their respective cell. Such alternative method would be one approach to reducing public carrier back-haul costs and to allowing cell relays to better manage bandwidth within their cells.","Completion of the broadcast transfers is a process that may take several days, or even weeks, depending on whether it is being done in conjunction with other operations, In any event, after such completion, Collection Engine  begins evaluating the block success count of each of the target nodes. When a node has a complete set of blocks, it will record a special event in the meter history log indicating such successful completion. Most nodes should have a complete set of blocks once the broadcast transfers are complete. Nodes that are still missing blocks will need to have them transferred point-to-point. Nodes that have excessive missing blocks after the broadcast process is complete may be flagged for possible maintenance or replacement as being potentially defective.","To facilitate point-to-point transfers, Collection Engine  will call a second stored procedure in the device. Such second procedure, a manufacturer's stored procedure, will provide a list of missing blocks, by block number. In an exemplary embodiment, the block list will include a predetermined maximum number of blocks, and a status byte indicating whether there is more than the predetermined number of blocks missing. For example, the predetermined maximum number of blocks may be set to twenty blocks. In using such method, most meters will receive all blocks and will not need to report on individual blocks; however, those meters that are missing blocks can be interrogated for a manifest of what they still require.","Collection Engine  will use such missing block data provided by the respective meter  to perform point-to-point block transfers. Meter nodes that cannot be contacted will be reported to the system operator. Once the point-to-point retries have been completed, the devices can be instructed to enable the new firmware. The command to activate the firmware may correspond to a C12.22 manufacturer's stored procedure. If a date and time is specified, the device will activate the firmware at the specified date and time. If no date and time is provided, the device normally will be set to activate the firmware download on an immediate basis.","Successful firmware activation can involve two additional aspects. First, selected metrology devices, i.e., meters, may employ not just one, but a plurality of images related to different aspects of the device's operation. In an exemplary configuration, at least three separate firmware images may be employed: one for the meter register board, another for a neighborhood local area network (LAN) microprocessor, and a third for a home area network (HAN) processor. In a more specific exemplary configuration, the neighborhood local area network microprocessor may correspond to an RF LAN microprocessor while the home area network processor may correspond to a Zigbee processor. Each of such components will have its own firmware image that may need to be updated. Additionally, over the course of time, new metrology device versions which require different firmware may be incorporated into existing systems. In such case, a given cell may have a mixture of devices with different firmware needs. For example, the Zigbee protocol may be used for communicating with gas meters, in-home displays, load-control relays, and home thermostats.","With reference presently to , there is illustrated and represented an exemplary methodology (and corresponding apparatus) for transmitting differing firmware images to selected end devices. As illustrated in , for the general group of meters  illustrated, a first subset of such meters illustrated with a white background (and generally represented by meters , , , , and ) support one firmware image, while a second subset of generally illustrated meters  illustrated with a grey background (and generally represented by meters , , , , and ) support another firmware image. As a result, while meters ,  are under meters ,  in the cell network hierarchy (or tree) and may be able to exchange firmware images with each other, the only way meters ,  can receive their firmware is through meters , , which in the present example are of another device type.","In order to handle such exemplary circumstances as represented in present , the firmware image distribution system is independent of the actual device for which the firmware is intended. Put another way, when an image is delivered to cell relay  and distributed over the RF LAN, it is distributed to all of the members of the cell that match the broadcast or multicast address used, regardless of whether the image is compatible with their particular hardware. This means that in accordance with the present technology, cell members act as hosts for the firmware. In order to update both types of meters (per the present representative example), two firmware updates will need to be distributed. Firmware will be transferred first to meters of the first subset (generally represented by meters , , , , and ), and then activated. Secondly, firmware will be transferred to meters of the second subset (generally represented by meters , , , , and ), and then activated. Such same mechanism can be used to download separate firmware images for individual microprocessors within the end node, as needed on a case-by-case basis per a specific implementation of the present subject matter.","Advantageously, in accordance with the present subject matter, the firmware activation code not only evaluates the integrity of the individual blocks and the overall firmware image, but it also checks whether the image is applicable to its actual hardware and for which hardware it is targeted. In general, the activation command will be sent only to the appropriate devices by using a multicast group associated with the device class. Nevertheless, checking that the image is compatible with the end device is an appropriate safeguard practiced in some embodiments in accordance with present subject matter.","With reference again to both , it will be observed that the various meters or nodes  are illustrated as being connected to one another by double-headed arrow lines (representatively illustrated at , , , , and  in , and at , , , , and  in ). Such interconnections schematically illustrate a self generated network formed by the meters  themselves per the present subject matter, in concert with each other and cell relay  as the individual meters  are activated. Because each of the respective meters  is self contained with respect to the RF LAN formed, an opportunity exists to distribute upgrade software (firmware) among the various meters on a viral peer-to-peer basis.","In such foregoing viral peer-to-peer model, a firmware image may be delivered to exemplary cell relay . From there, Collection Engine  preferably may send a stored procedure command to cell relay , indicating that it should distribute such firmware image to the RF LAN. Collection Engine  also sends a command to the meter nodes within the cell using a broadcast or multicast message, instructing them that a new firmware image is available. Once such command is received, cell relay  makes the firmware available to its local RF LAN processor. Per the present subject matter, meter nodes  within such cell instruct their RF LAN processors to begin looking for blocks. At such point, the RF LAN processors take over the block transfer process. Again, per previously discussed present methodology, such blocks  may be sent in any order.","Such presently disclosed viral-type distribution mechanism may be very powerful and very efficient in that it may be able to make better use of the available physical bandwidth. Under such present viral peer-to-peer arrangement, individual meter nodes  can grab firmware images or portions of firmware images, from their immediate neighbors or parents, rather than needing to get the data directly from cell relay  or Collection Engine . As a result, one portion of the cell could be exchanging firmware blocks while another portion of the cell could be passing various messages between meter nodes  and cell relay , all without impacting each other.","With reference to , there is illustrated a block diagram representation of exemplary components of Collection Engine  in accordance with an exemplary embodiment of the present subject matter. Collection Engine  is a collection of software-based functionality which provides ANSI C12.22 services to the devices that comprise the C12.22 network, including one or more cell relays  as well as the metrology and end devices . Though such components are preferably software-based, those of ordinary skill in the art will appreciate various equivalent forms of implementation, providing the same functionality. Conceptually, Collection Engine  is comprised of three major components, the Orchestration System or Manager generally , the Master Relay\/Authentication Host , and the communications server or servers (represented by illustrated components , , and ). Collection Engine  is implemented preferably so as to be able to distribute work across multiple servers , , and  in order to facilitate scaling.","Within a C12.22 system, the Master Relay  is the coordinating process for the overall system. In order to send or receive C12.22 messages, respective nodes  must be registered with the Master Relay. However, before a respective node is allowed to register, it must be authenticated. The Authentication Host provides such functionality in the present exemplary embodiment. The Master Relay or station is responsible for the actual meter data acquisition process, communicating with the meter via C12.22 messages.","As will be understood by those of ordinary skill in the art, each of the respective major components of Collection Engine  is in turn made up of a series of smaller components and functionality feature sets. The Orchestration Manager or layer  provides coordination between such components, and presents a unified, single API (Application Layer Interface) to upstream systems. The Orchestration Manager or system  runs as a single master orchestration service (or functionality) and as a series of agents. Each separate physical server will have an orchestration agent to tie it into the larger system. API requests are directed to a master orchestration service (or functionality) which in turn works with the orchestration agents to ensure that requested work or methodology is performed or executed.","The Master Relay\/Authentication Host  will provide standard C12.22 registration services\/functionality as well as integrated C12.22 network authentication functionality\/services. One vision for the C12.22 protocol is that, similar to DNS (Domain Name Servers), a C12.22 master relay may be created which would be shared between multiple utilities, perhaps providing services to an entire region or country. With such approach in mind, implementation of a master relay in accordance with present technology should provide full support for the use of other authentication hosts, and for sending notification messages to registered hosts. Additionally, the Orchestration Manager or layer  is preferably implemented so as to be able to receive notifications from master relays from other manufacturers, meaning that an implementation of the present subject matter could be realized employing a master relay from an outside source.","The representative Communications Servers , , and  provide communication functionality with devices, such as to parse and translate such communications, and post or return data as necessary. Communication Servers , , and  thus preferably may comprise a series of services\/functionality to accomplish such overall functionality per the present subject matter. Within Communications Servers , , and  are a series of major components: a meter communications host, a data spooler, and an exception event manager. The meter communications host is responsible for listening for network communications and sending network communications. It is the component that both \u201cspeaks\u201d C12.22 and \u201cinterprets\u201d C12.19 table data. The data spooler and the exception event manager provide mechanisms for streaming meter data and exception events, respectively, to upstream systems.",{"@attributes":{"id":"p-0203","num":"0202"},"figref":"FIG. 4"},"Per the present subject matter, there are several proposed physical layers. All use Frequency Hopping Spread Spectrum technique. Each one of them is intended to be used for a specific market location (such as either for North America or for Europe) and inside a specific band, and follows the regional or local required regulations.","The physical layer termed PHY-FHSS-NA-915 is intended to be used in the 902-928 MHz ISM band in North America. It complies with pertinent FCC regulations, namely parts 15.35, 15.205, 15.209, and 15.247, and in a preferred embodiment may encompass 52 channels. Other particulars of the transmitter and receiver specifications for such 915 MHz Band, for North America, as well as the channel allocations thereof, are well known to those of ordinary skill in the art from the pertinent regulations, without requiring additional discussion herewith.","The physical layer termed PIY-FHSS-NA-2400 is intended to be used in the 2.4 GHz ISM band in North America. It complies with pertinent FCC regulations, namely parts 15.35, 15.209, 15.247 and 15.249, and in a preferred embodiment may encompass 16 channels. Other particulars of the transmitter and receiver specifications for such 2.4 GHz Band, for North America, as well as the channel allocations thereof, are also well known to those of ordinary skill in the art from the pertinent regulations, without requiring additional discussion herewith.","The physical layer termed PHY-FHSS-EU-868 is intended to be used in the 868 MHz ISM band in the European Union. It complies with pertinent ETSI regulations, namely sections 300 220 and ERC 70-03. Other particulars of the transmitter and receiver specifications for such 868 MHz ISM band in the European Union are also well known to those of ordinary skill in the art from the pertinent regulations, without requiring additional discussion herewith.","The physical layer termed PHY-FHSS-EU-2400 is intended to be used in the 2.4 GHz ISM band in the European Union. It complies with pertinent ETSI regulations, namely sections ETSI 300 228 and ERC 70-03, and in a preferred embodiment may encompass 16 channels. Other particulars of the transmitter and receiver specifications for such 2.4 GHz ISM band in the European Union are also well known to those of ordinary skill in the art from the pertinent regulations, without requiring additional discussion herewith.","With reference to the PHY Layer, this describes the adjustable (that is, \u201ctweakable\u201d) parameters of such PHY layer. For PHY_Synch_Length: The length in bits of the Synch field, the synchronization bit sequence of the PPDU. For PHY_SFD_Value: The value of the SFD field of the PPDU. This value should be chosen with appropriate auto-correlation properties to enable a reliable start of frame detection. The recommended values are given in the following table. The most significant bit of PHY_SFD_Value is sent first on the air interface, just after the preamble. These SFD values have sufficient orthogonality to be used with the purpose of isolating several coexisting networks. For PHY_RSSI_Average_Time: The averaging time to perform the RSSI reading.",{"@attributes":{"id":"p-0210","num":"0209"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Value Number","PHY_SFD_Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1 (default)","0xB127"]},{"entry":["2","0x9363"]},{"entry":["3","0x263D"]},{"entry":["4","0x23E5"]},{"entry":["5","0x0BCD"]},{"entry":["6","0x871B"]},{"entry":["7","0x19A7"]},{"entry":["8","0x94F8"]},{"entry":["9","0x1A67"]},{"entry":["10","0x25E3"]},{"entry":["11","0x8DD2"]},{"entry":["12","0x1CB6"]},{"entry":["13","0x895B"]},{"entry":["14","0x26F1"]},{"entry":["15","0x258F"]},{"entry":["16","0x2C76"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"PHY Parameter Default Values may be preferably regarded as follows. For PHY_Synch_Length: 32 bytes; for PHY_SFD_Value: 0xB127 (with the most significant bit being the first sent on the air interface); and for PHY_RSSI_Average_Time: 1 ms.","As far as medium access parameters, time and frequency divisions are managed with the use of the Slotted Aloha technique (details of which are well known to those of ordinary skill in the art). Time is generally divided into identical Time Slots (TS) and at each change of TS (Time Slot), the frequency hops from one channel to another channel according to a frequency hopping sequence. MAC layer is in charge of synchronization. Since typically traffic at any point in time is low, Slotted Aloha technique is an appropriate selection. Each meter is by default in receiver mode and pushes data on the medium when it wants to speak. Such method generally may be producing a relative number of collisions but, in normal operating conditions, internal collisions are expected to be lower than collisions due to the noisy environment of ISM bands. However, the present protocol intentionally manages repetitions to compensate for such phenomenon.","The physical layer can give to the layers above it a snapshot of the link quality between the endpoint and the sender of the message. The physical layer does this by measuring the Received Signal Strength Indicator (RSSI) during the message reception. Such reading is processed during the reception of the synchronization bits, which are an alternating zero-one sequence. This is an average reading over PHY_RSSI_Average_Time ms. When the physical layer detects the Start Frame Delimiter, it stops the reading of RSSI and saves the value to give it later to the MAC layer together with the received message.","The RSSI is also a measurement of the interference level on a given channel when used outside the reception of a present protocol network message. This is used for instance in the environment analysis processes.","In all cases, the RSSI value sent to the MAC layer by the physical layer is preferably not a mere reading of the RSSI register of a transceiver chipset. The value is preferably processed to reflect the actual power level of the incoming signal, that is, LNA gain and filter insertion losses should be taken into account in the RSSI value forwarded to the MAC layer.","The RSSI is formatted as a single signed byte. The value is given in dBm. Its theoretical range is therefore from \u2212128 dBm to +127 dBm.","Data is preferably transmitted in the little endian format (Least Significant Bit first). Bit ordering is also done with the least significant bit first.","The Forward Error Correction (FEC) used by the physical layer is an interleaved Reed-Solomon (38,28) code with symbols in Galois Field (GF)(256). The steps for encoding are:\n\n",{"@attributes":{"id":"p-0219","num":"0222"},"figref":["FIG. 5","FIG. 5"]},{"@attributes":{"id":"p-0220","num":"0223"},"figref":["FIG. 6","FIG. 7"],"b":["1","2"]},"The steps for decoding are the same as for such encoding but in reverse order:\n\n","The Reed-Solomon coding preferably used in the present protocol is an RS (38,28) code. It is a shortened version of an RS (255,245) code with symbols in GF (256). This means that the symbols of the code are bytes and that for each block of 28 bytes, there are appended 10 additional redundancy bytes. This code has a Hamming distance of 11 and allows the correction of 5 erroneous bytes per block.","More particularly, each byte of the message is considered as an element of GF (256). Reference herein to such elements will be as symbols. All the operations made with such symbols (addition, subtraction, multiplication and division) should be made according to the additive and multiplicative laws of the Galois field GF (256), constructed with the primitive polynomial p(x)=x+x+x+x+1. A symbol of GF (256) has several useful representations: a binary representation {bbbbbbbb}, a polynomial representation b\u03b1+b\u03b1+b\u03b1+b\u03b1+b\u03b1+b\u03b1+b\u03b1+band an exponential representation \u03b1. In the last two representations, \u03b1 is a primitive element such that p(\u03b1)=0. The binary or polynomial representation is useful for addition and the exponential representation is useful for multiplication. All GF(256) elements, except zero, have an exponential representation, the complete field can written as the set GF(256)={0, 1, \u03b1,\u03b1, \u03b1, . . . , \u03b1, \u03b1}. The conversion between the two representations is done with a look-up table. For the implementation of the encoder\/decoder, it is necessary to add and multiply the symbols in GF(256). Addition is readily performed with the binary or polynomial representation of the symbols. The operation is equivalent to a modulo 2 addition of each bit, for instance\n\n0010 1100+1000 1111=1010 0011\n","Multiplication is relatively more difficult because a conversion to the exponential form of the symbol is necessary. A look-up table is preferably used for such purpose. As an example, the following a multiplication of the two symbols of the previous example\n\n0010 1100\u00d71000 1111\n","The first symbol () has the exponential representation \u03b1, the second symbol () has the exponential representation \u03b1. The product is \u03b1\u03b1=\u03b1=\u03b1=\u03b1because \u03b1=1. Such table can be used in the other way to convert the result in binary form and obtain 44*143=226.","With reference to the present Reed-Solomon Encoder as preferably implemented in accordance with present subject matter, conforming to the established convention in coding theory, one would use here the polynomial representation for the messages. That means that the present 28-symbol data block, {u,u,u, . . . u,u}, can be written u(x)=ux+ux+ . . . +ux+ux+ux+u. The symbol uis the first symbol written in the interleave table, which is filled from left to right. The 38-symbol code word (message+redundancy symbols) can be written c(x)=cx+cx+ . . . +cx+cx+cx+c. The Reed-Solomon encoding process is equivalent to a division of the message by a generator polynomial G(x). This can be implemented with a linear feedback shift register as shown in present . This is similar to, but different from a conventional CRC encoder. The difference is that in the present subject matter each multiplication by a coefficient and each addition has to be understood as multiplication and addition in GF (256).","In the shift register implementation represented in present , the gare elements of GF (256). The shift register is first initialized with zeros. The symbols of the message are then shifted into the register, beginning with uand finishing with u. After the whole data block has been pushed into the shift register, the content of the register is the remainder of the division. These symbols are the FEC symbols and they are appended to the initial message in the following way","{u,u,u, . . . u,u,p,p,p,p,p,p,p,p,p,p}","As with conventional CRC computing, the multiplicative factors in the shift register are given by the coefficients of a polynomial:\n\n()=\n","In our case this polynomial is:\n\n()=(\u03b1)()()()()()()()()()\n","Once such polynomial is developed to find the gi coefficients, the result is\n\n()=\u03b1+\u03b1+\u03b1+\u03b1+\u03b1+\u03b1+\u03b1+\u03b1+\u03b1\n","The first step of the Reed-Solomon decoding process is the syndrome computation. For a 38-byte received block, 10 syndromes are preferably computed. If the received message is {r,r, . . . r,r,r}, the following polynomial representation applies:\n\n()=\n","The 10 syndromes {S,S, . . . , S} will be computed with R(x) as shown below:\n\n(\u03b1), for 1\u226610\n","If the 10 syndromes are equal to zero, there is no detectable error in the message and the decoding process stops here. There is of course a possibility for an undetectable error but preferably this will be detected later by the CRC.","The second step of the Reed-Solomon decoding process is the computation of the error locator polynomial. This polynomial has the following form:\n\n()=1+5\n","The degree of such polynomial is not known beforehand because it depends on the number of errors in the received message. To compute the coefficients of ELP(x), an iterative algorithm is used, the Berlekamp-Massey algorithm. A pseudo-code description of such algorithm is as follows:",{"@attributes":{"id":"p-0237","num":"0243"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Input: S, S, . . . , S","(the syndromes)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Initialization:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"224pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Len=0"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ELP(x)=1","(the current error locator polynominal)"]},{"entry":[{},"PELP(x)=1","(the previous error locator polynominal)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"224pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"j=1"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"d=1","(the previous discrepancy)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"for k=1 to 10"},{"entry":{}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"d","mo":"=","mrow":{"msub":{"mi":["S","k"]},"mo":"+","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"Len"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":[{"mi":["ELP","i"]},{"mi":"S","mrow":{"mi":["k","i"],"mo":"-"}}],"mo":"\u2062"}}}}}}},"(compute discrepancy)"]},{"entry":{}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["if d=0",{},"(no change in polynominal)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"224pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"j=j+1"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"else"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"224pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if 2Len \u2267 k then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"ELP(x) = ELP(x) \u2212 ddxPELP(x)"]},{"entry":[{},{},"j=j+1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"224pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{},"temp(x)=ELP(x)","(temporary storage)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"ELP(x) = ELP(x) \u2212 ddxPELP(x)"]},{"entry":[{},{},"Len=k\u2212Len"]},{"entry":[{},{},"PELP(x)=temp(x)"]},{"entry":[{},{},"d=d"]},{"entry":[{},{},"j=1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"224pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"end"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"end"},{"entry":"end"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Once the error locator polynomial has been computed, the roots of such polynomial are found. To find such roots, ELP(x) is computed for every non zero z in GF (256) until \u03bd roots are found, where \u03bd is the degree of the error locator polynomial. If less than \u03bd roots are found, the errors are uncorrectable and the whole packet must be rejected. The inverse of the roots of ELP(x) are called the error locators. An error locator indicates the position of an error in the message, as follows.",{"@attributes":{"id":"p-0239","num":"0245"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":{"mi":"ELP","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"Y"}},"mo":"=","mn":"0"},"mo":[",","\u2062"],"mstyle":{"mtext":{}},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mrow":{"mi":"Y","mo":"\u2208","mrow":{"mi":"GF","mo":"\u2061","mrow":{"mo":["(",")"],"mn":"256"}}},"mo":["\u21d2","\u2062"],"mi":[{},"X"]},{"mfrac":{"mn":"1","mi":"Y"},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["is","the","error","locator"]}],"mo":"="}}},{"mtd":{"mrow":{"mrow":[{"mrow":{"mo":["\u21d2","\u2062"],"mi":{},"mrow":{"mi":["if","X"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},"mo":"=","msup":{"mi":["\u03b1","k"]}},{"mi":["the","symbol","in","position","k","is","corrupted"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}],"mo":","}}}]}}}}},"As an example, it is found that ELP(\u03b1)=0, \u03b1is an error locator. The inverse of \u03b1is computed, which is \u03b1=\u03b1\u03b1=\u03b1. It is concluded in such exemplary instance that the symbol in position  is corrupted, that is, rin the sequence {r,r, . . . r,r,r}. At this stage of the decoding process, if the error pattern is correctable, the positions of all corrupted symbols in the block are known. The set of error locators is:\n\n{()=0\n","One present technique to potentially speed up the computation of the roots of ELP(x) is to try only the elements of GF (256) that will point to errors within the block, that is: {1,\u03b1,\u03b1,\u03b1, . . . , \u03b1}.","The next step preferably per the present subject matter is to correct the errors. Such involves computing the error evaluator polynomial, defined by the following:\n\n()=()()mod()\n","where a new polynomial is introduced whose coefficients are the syndromes\n\n()=\n","The mod (x) in the definition of EEP(x) means that all terms of degree 10 or higher are discarded. It also involves use of a polynomial called the formal derivative of the error locator polynomial, as follows:\n\n()=\n","The error on the symbol indicated by the error locator Xis given by",{"@attributes":{"id":"p-0246","num":"0252"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"Error","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"k"}},"mo":"=","mfrac":{"mrow":[{"mi":"EEP","mo":"\u2061","mrow":{"mo":["(",")"],"msubsup":{"mi":["X","k"],"mrow":{"mo":"-","mn":"1"}}}},{"mi":"DER_ELP","mo":"\u2062","mrow":{"mo":["(",")"],"msubsup":{"mi":["X","k"],"mrow":{"mo":"-","mn":"1"}}}}]}}}}},"The corrected symbol is\n\nNew value of symbol=Old value of symbol+Error()\n","The format of the physical layer frame is represented by present . The Synch field of the Preamble (see ) of the physical layer frame is composed of an alternating zero-one sequence. It is intended to allow the remote receiver to detect the presence of an incoming message and to perform a data clock recovery. It indicates an imminent frame and it is also advantageously used by the receiver to measure the power strength (RSSI) of the received signal.","The Synch field length is given by the PHY layer parameter PHY_Synch_Length. The default value for this parameter is 32 bits (4 bytes).","The Start of Frame Delimiter (SFD) field (see ) is two-bytes long. It signals the end of the preamble and the beginning of the PHY header. It has a predefined fixed value given by the PHY layer parameter PHY_SFD_Value. If several networks operated by different utilities coexist in the same area, it is possible per the present subject matter to assign a specific SFD value to each network. As only the packets with the right SFD value are considered, this will prevent an endpoint from processing the packets intended for another network. When used in conjunction with the Utility ID, such feature advantageously increases the possible number of networks coexisting in the same area.","Still further per present features, as an option the SFD detection can be configured per present subject matter to accept the packet if only 15 of the 16 bits match PHY_SFD_Value. When used with FEC, such alternative serves to increase noise immunity per the present subject matter.","With reference to the PHY Header (see ), the Utility ID bits allow the distinction of the different utilities that use this protocol at the same location. It advantageously avoids a utility entering into a cell belonging to one of its competitors. When the UID of the packet doesn't match with the UID defined in the endpoint, the received packet is discarded. The subsequent two bits of the packet are preferably reserved, that is, not used initially, to preserve future uses, and should preferably be set to 0.","The Length bits indicate the length of the MPDU, in bytes. When the indicated number of bytes is received, the physical layer (if the outcome of the FEC decoding is a valid packet) indicates the arrival of a complete frame to the MAC layer, which will verify its integrity (CRC). Then the PHY layer, which is by default in receiving mode, looks for the next preamble.","To add some robustness to the PHY header that has no CRC, the fields UID, RSD and Length are preferably complemented bit by bit, per the present subject matter. If the complemented fields don't match with the associated fields, the received packet is discarded.","With reference to the Frame Body (see ), the MAC Protocol Data Unit (MPDU) contains all the information required at the MAC layer level. The Frame Body also contained redundant bytes, added according to the FEC algorithm explained hereinabove.","In the description herein of each layer in the document, interface and services with the upper layer are presented in the same way. A figure shows the different interactions between the layers. There are three different flows of information between them, namely, requests, confirmations, and indications. These different internal communications are then explained.","Regarding Requests, Layer-Name_Request-Name, are the services offered by layer to the layer above. When the service is not needed by the layer just above but by the one, two, or three times upper, the in-between layers should forward the service. The user may optionally shortcut the middle layers if desired for particular embodiments.","Regarding Confirmations, Layer-Name_Confirmation-Name, are answers of the requests. Every request has a unique confirmation per the present subject matter. Confirmations are not always sent immediately after a request; it depends on the service. The preferred approach is establish a number to the request and then give the same number when the confirmation is sent, in order to avoid misunderstanding. Note that the number associated to the request need not be correlated to the ID of the frames to send.","Regarding Indications, Layer-Name_Indication-Name, are sent by a layer to the layer above, they are not a response to a request, they usually report an event. The layer that sends an indication doesn't expect any confirmation.","Further with respect to interfacing and services among layers, the physical layer is in charge of sending and receiving radio packets on the medium. Therefore, per present subject matter, by default, the physical layer is in receive mode. As soon a packet is transmitted, the physical layer switches back to the receive mode. Channel changes are preferably requested by the upper layer, the MAC layer. The physical layer also manages the transceiver concerning its communication interface, channel calibration, PLL lock status, RSSI reading, and mode selection. In the transmit (Tx) mode, it computes an FCS (based on RS code) and adds it to the packet; it then adds a physical header (PHY-Header), and a preamble. Finally, it codes and modulates the radio packet at the required rate and frequency. In the Receive (Rx) mode, it listens to the medium until it finds a preamble. As soon as it recognizes the Start of Frame Delimiter at the end of the preamble, it saves the reception time (SACT) and measures the input power strength (RSSI). Then it demodulates and decodes the radio packet. After removing the preamble and the header, it corrects the packet if needed (and if it is possible) and indicates to the MAC layer the arrival of a new message. Dating of the message should be accurate enough to enable the proper operation of the protocol, as otherwise discussed herein with reference to the MAC layer.","The physical layer proposes different services, as represented by .","In conjunction with PHY Requests, referenced as PHY_Request_Send, the objective is to send a packet over the RF link at a specified channel and at given time. The requisite Input arguments are: MPDU, Channel, and Time to send the packet. The operation may be described as follows. The MAC layer requests from the PHY layer to send a packet. The channel is given with the request. The PHY layer sends the packet at the time indicated by the MAC. Timing information can be given by several alternative ways per the present subject matter, which the user is free to decide. As soon as the packet is transmitted, the physical layer switches back to receive mode on the time slot's default channel and confirms to the MAC layer the status of the transmission.","In conjunction with PHY Requests to change channel, referenced as PHY_Request_Change_Channel, the objective is to change the listening channel. The requisite Input arguments are Channel information. The operation may be described as follows. The MAC layer requests from the PHY layer to change the default receiving channel immediately.","In conjunction with PHY Requests to Read an RSSI value, referenced as PHY_Request_Read_RSSI, the objective is to read the RSSI value. There are no requisite Input arguments. The operation may be described as follows. The subject request asks for the PHY layer to read immediately the RSSI instantaneous value on the current channel.","In conjunction with PHY Requests to either start or stop, referenced as PHY_Request_Start_Stop_Rx, the objective is either to Start or Stop listening on the current default channel. The requisite Input arguments are whether to Start or Stop. Such operation may be described as follows. This request asks for the PHY layer to start or stop immediately to listening on the current default channel. Preferably, per present subject matter, the Stop request is mainly used when a power outage is detected to save energy.","In conjunction with PHY Confirmation, referenced as PHY_Confirmation_Send, the objective is the Answer of a PHY_Request_Send. The requisite Output arguments are the Status byte. The operation may be descried as confirming the status of a transmitted message. It can be Send_Ack, PLL_Unlock or any kind of errors.","In conjunction with PHY Change Confirmation, referenced as PHY_Confirmation_Change_Channel; the objective is the Answer of a PHY_Request_Change_Channel. The requisite Output arguments are the Status byte. The operation may be descried as confirming the status of the Change Channel Request. It can be Ack, PLL_Unlock or any kind of errors.","In conjunction with PHY Read Confirmation, referenced as PHY_Confirmation_Read_RSSI, the objective is the Answer of a PHY_Request_Read_RSSI. The requisite Output arguments are RSSI. The operation may be described as the PHY layer returns the current RSSI value. The value is one signed character, expressed in dBm.","In conjunction with PHY Confirmation of Start or Stop Reception, referenced as PHY_Confirmation_Start_Stop_Rx, the objective is the Answer of a PHY_Request_Start_Stop_Rx. The requisite Input arguments are the Status byte. The operation may be described as just confirms if the request has been well performed.","In conjunction with certain PHY Indications, referenced as PHY_Indication_Received, the objective is to Indicate the reception of an incoming packet. The requisite Output arguments are MPDU, SACT, and RSSI. The operation may be described as after the reception of a message, the PHY layer removes its header and gives the MPDU to the MAC layer. The PHY layer also indicated the RSSI measured during the reception and the SACT value (see MAC layer chapter for the definition of the SACT) when the SFD has been captured.","The Data Link layer is divided into two sub-layers, the MAC layer and the LLC layer. The MAC layer has various tasks, by which it organizes data transmission on the RF channels and manages the synchronization.","Specifically, with reference to Cyclic Redundancy Check (CRC), the first role of the MAC layer is to detect errors in the received datagram. Prior to transmission, the MAC layer computes a CRC based on the packet to be transmitted, and it adds them at the end of the packet. Due to that function, at the reception of the packet, the MAC layer has the ability to accept or discard messages depending on the value of the codes.","The second task of the MAC layer is the assembling and disassembling of the datagram. The MAC layer knows what kind of message the meter has received, who has sent (SA) it and for whom it is addressed (DA). Therefore, the MAC layer also performs acknowledgements. When a message is received, an acknowledgement message is transmitted back in the same time slot with an ACK or NACK argument, and with the frame number. This acknowledgement message will not be further acknowledged; the MAC layer provides acknowledgment at each hop of the message but there is no MAC end-to-end acknowledgment.","Another task is the neighborhood management. Due to the received messages and their header, the MAC layer manages a table, where several indications about the 1-hop neighbors are saved. When a neighbor hasn't transmitted anything for a long time, it is considered as having left and it is removed from the table. This table is used for several purposes, like synchronization. It is also shared with the network layer to allow message routing.","Another task performed by the MAC layer is the management of synchronization. The MAC layer readjusts the start of time slots in listening traffic and in receiving synchronization packets. Because it knows time division and the frequency hopping sequence, it can choose the channel to use. To synchronize with the other endpoints, if there is no traffic, the MAC layer sends periodic beacons.","The following describes parameters of the MAC layer, more specifically listing a variety of parameters which are adjustable (that is, tweakable). It provides a description of each parameter and some comments on how to modify their value (effect, limits . . . ) and\/or their relations with other parameters. Depending on the location and the band in which the present protocol subject matter operates, the default values of the MAC parameters change, as will be understood by those of ordinary skill in the art without requiring additional detailed discussion thereof.","MAC_Beacon_Period_SYNC","Description: The period of the beacons sent by a synchronized endpoint when it has no other messages to send. It corresponds to the maximal allowed period of radio inactivity.","Comments: The value of this parameter depends on the clock drift and on the time slot margins. It should allow the network to stay synchronized even if several beacons are not heard (i.e. it should be smaller than MAC_Neighbor_Timeout). The more important the clock drift is, the shorter the beacon period should be. The beacons are not sent exactly at each period but are randomized in order to avoid beacon collisions.\n\nMAC_CELL_Leaving_Process_Duration:\n","Description: The time interval between the reception of a SYNC_ACK from another cell (considered better by the endpoint) and the moment the endpoint actually switches cell.","MAC_CELL_Switch_Hysteresis","Description: This parameter defines the hysteresis in the decision process for cell switching.","MAC_CELL_Weight_CSI","Description: In the cell switching process, this parameter defines the weight of the cell size in cell selection.","MAC_CELL_Weight_GPD","Description: In the cell switching process, this parameter defines the weight of the GPD in cell selection.","MAC_CELL_Weight_Level","Description: In the cell switching process, this parameter defines the weight of the level in cell selection.","MAC_Clock_Accuracy:","Description: This is the crystal accuracy defined to include all influential parameters (tolerance, temperature and aging).","Comment: The better the clock accuracy is, the easier the synchronization is maintained.","MAC_Discovery_Beacon_Period:","Description: The period between two discovery beacons sent during the discovery phase.","Comment: This should be larger than the time needed to send one discovery beacon. It is also dependent on how quickly the firmware\/hardware can handle the transmission of a beacon.","MAC_Excellent_Connectivity_Threshold:","Description: The minimum number of SYNC fathers from which a node is considered to have an excellent connectivity degree.","MAC_FW_Accuracy:","Description: The accuracy of the firmware for dating the actual sending\/reception of a message.","Comment: This depends on the MCU and clock frequency.","MAC_GPD_TD:","Description: This parameter is used to model the fixed propagation delay through each node of the network. It is used to compute the GPD (Global average Propagation Delay).","Comments: Increasing the value of this parameter will make the system give an advantage to the paths with fewer hops.","MAC_HFC_Max:","Description: Specifies the span of the hyperframe counter.","MAC_HF_Length:","Description: The length in time slots of a hyperframe.","A hyperframe is a succession of time slots that follows the hopping hyper-sequence.","Comment: This length is the product of the super-sequence length by the number of channels.","HF_Length=Number_of_Channels*Hopping_Super_Sequence_Length","MAC_Hopping_Super_Sequence_Length:","Description: The length of a frequency hopping super-sequence, also the number of basic hopping sequences used in a hyper-sequence.","MAC_Listening_Window_Length:","Description: Length of the listening window during the discovery phase","Comments: Increasing this length will decrease the probability of collision between forced beacons but will slow down the discovery process if several discovery phases are needed to find a SYNC father.","MAC_LPD_Max:","Description: Maximum possible value for the LPD (Local average Propagation Delay).","MAC_LPD_NAVG:","Description: The sliding average window length used to compute the LPD (Local average Propagation Delay).","Comment: this window must be smaller than the MAC_Neighbor_Timeout value.","MAC_LPD_RSSI:","Description: Factor used to initialize the LPD (Local average Propagation Delay) from the RSSI reading.","MAC_LPD_Switch:","Description: Factor used to initialize the LPD (Local average Propagation Delay) from the RSSI reading.","MAC_Max_Discovery_Phase_Period:","Description: The maximum period between two discovery phases for a non-synchronized endpoint.","Comment: This is used after MAC_Max_Nb_of_Discovery_Phases unsuccessful discovery phases and should be much larger than MAC_Min_Discovery_Phase_Period.","MAC_Max_Nb_of_Discovery_Phases:","Description: The maximum number of unsuccessful discovery phases before increasing their period.","Comments: The reason for this parameter is to quiet down orphaned endpoints. It should be set high enough to make it possible for an endpoint to discover several cells.","MAC_Max_Nb_of_Neighbors:","Description: The maximum size of the MAC Neighbor Table.","MAC_Max_Nb_of_SYNC_Request:","Description: The maximum number of times an endpoint tries to send a SYNC request to each potential SYNC father.","MAC_Max_Nb_of_Transmitted_Bytes_sTS:","Description: The maximum number of bytes that can be transmitted during a sub time slot. This includes the entire packet, i.e., MPDU, PHY header and preamble.","Comment: This value, combined with the data rate, affects the Sub_TS length.","MAC_Max_Nb_of_Transmitted_Bytes_TS:","Description: The maximum number of bytes that can be transmitted during a time slot. This includes the entire packet, i.e., MPDU, PHY header and preamble.","Comment: This value depends on the data rate, the time slot length and the time slot margins.","MAC_Max_Packet_Length:","Description: The maximum length of PDU packets (expressed in bytes) that the MAC layer authorizes the upper layer to send (the LPDU length).","Comment: MAC_Max_Packet_Length=MAC_Max_Nb_of_Transmitted_Bytes_TS\u2212(Preamble+PHY_header+FEC+MAC_Header+FCS).","MAC_Min_Discovery_Phase_Period:","Description: The minimum period between two discovery phases for a non-synchronized endpoint.","Comment: This should be larger than the time needed to send the discovery beacons plus MAC_Listening_Window_Length.","MAC_Nb_of_Basic_Hopping_Sequences:","Description: The number of basic frequency hopping sequences that an endpoint can generate. Each hopping sequence is a succession of all the predefined channels. Each one of the MAC_Number_of_Channels channels appears once and only once in this succession.","Comment: This value should be greater than MAC_Hopping_Super_Sequence_Length.","MAC_Nb_of_Sub_TS:","Description: The number of sub time slots in a time slot. The beginning of a Sub-TS marks the potential beginning of the transmission of a packet.","Comments: The number of Sub-TS is ((TS_Length-2*TS_Margin)\/Sub_TS_Length). It is assumed that the length values are chosen to make this is an integer.","MAC_Max_nb_of_downlink_buffered_packets:","Description: The maximum number of packets that an endpoint can save into its memory. It concerns only the packets going from the Cell Master to the endpoints (Downlink).","MAC_Max_nb_of_uplink_buffered_packets:","Description: The maximum number of packets that an endpoint can save into its memory. It concerns only the packets going from endpoints to the Cell Master (Uplink).","MAC_Neighbor_Timeout:","Description: The time limit for the MAC layer to decide that an endpoint is not a neighbor anymore because the last reception happened more than MAC_Neighbor_Timeout ago.","Comments: This depends on the clock drift and the time slot margins. An endpoint should not be considered a neighbor if there is a chance it is no longer synchronized.","MAC_Number_of_Channels:","Description: The number of channels used in the basic frequency hopping sequences.","Comments: The minimum value for this parameter is fixed by the spread spectrum regulations: 15, 20, 25 or 50 channels depending on countries and smart frequency hopping features.","MAC_RSSI_Sampling_Rate:","Description: Frequency of RSSI reads during the environment analysis for the computation of averaged RSSI and RSSI auto-correlation function.","MAC_RXI_Decay:","Description: This constant is used to compute the Reception Rate Indicator (RXI). The RXI is periodically multiplied by this constant to make the indicator decay in time when no message is received.","MAC_RXI_Increment:","Description: This constant is used to compute the Reception Rate Indicator (RXI). Upon reception of a message from a neighbor, its RXI is incremented by this constant.","MAC_RXI_Threshold:","Description: RXI values above this threshold are considered to be an indication of a reliable link. This is used in the computation of figures of merit for the choice of synchronization fathers.","MAC_SACT_Resolution:","Description: The value of the least significant bit of the SACT timer when the value of this timer is exchanged between endpoints.","Comment: The SACT timer can be locally implemented with a higher resolution given by the parameter MAC_FW_Accuracy.","MAC_Sub_TS_Length:","Description: The length of a Sub_TS. It corresponds to the maximum length of the biggest MAC message (preamble+PHY header+FEC+MAC header+FCS).","Comment: It should be rounded up to obtain an integer number of Sub_TS per TS.","MAC_SYNC_Disc_Weight_CSI","Description: In the discovery phase, this parameter defines the weight of the CSI of neighbors in the synchronization father selection process.","MAC_SYNC_Disc_Weight_GPD","Description: In the discovery phase, this parameter defines the weight of the GPD of neighbors in the synchronization father selection process.","MAC_SYNC_Disc_Weight_Level","Description: In the discovery phase, this parameter defines the weight of the level of neighbors in the synchronization father selection process.","MAC_SYNC_Father_Request_Beacon_Threshold:","Description: Duration used to determine if an endpoint is still in synchronization with a father before accepting that another endpoint gets synchronized with it. If a message from a healthy father has been received within this time, there is no need to request a beacon from it before answering a SYNC request.\n\nComment: This value must be smaller than MAC_Beacon_Period_SYNC.\n\nMAC_SYNC_Request_Period:\n\nDescription: The minimum period between two different SYNC requests sent to the same potential SYNC father.\n\nMAC_Traffic_Density_max\n","Description: Any endpoint in the mesh will adjust its transmission randomization window in order to avoid creating a traffic input density above that limit for each one of its fathers.","Comments: The value of this parameter should always be less than one. Values close to one can improve the maximum throughput of the system but increase the risk of jamming the data traffic with collisions.","MAC_Traffic_Monitoring_Window","Description: Length of the sliding average window used by an endpoint to monitor the traffic of neighbors. This length is expressed in time slots units.","MAC_TS_Length:","Description: The length of a time slot. During the entire time slot, the same channel will be set except for sending forced beacons.","Comments: The maximum TS_Length value may be fixed by spread spectrum regulations in some countries, (e.g., 400 ms for the PHY-FHSS-NA-915). The default length corresponds to ((Max_Nb_of_Transmitted_Bytes_TS*8)\/Bit_Rate)+2*TS_Margin.","MAC_TS_Margin:","Description: The duration of each time interval at the extremities of a time slot when an endpoint is not allowed to transmit. When in receive mode, the endpoint should be listening across the whole time slot, including these intervals, in order to be able to complete the reception of a message coming from a neighbor with slightly misaligned time slots.\n\nComment: The TS_Margin value depends on the worst clock drift between two endpoints and between two received messages. Wider margins allow for more crystal drift or more time between messages but decrease the maximum number of transmitted bytes per TS and thus the throughput of the system.\n\nMAC_Tx_Window_max:\n","Description: The maximum value for the randomization window used by an endpoint to transmit its data packets.","Comments: Only one packet should normally be transmitted in a randomization window and the position of the packet within this window is random. The protocol does not forbid short packets to be transmitted in the same window but this must also follow the rules of priority.","MAC_Tx_Window_min:","Description: The minimum value for the randomization window used by an endpoint to transmit its data packets.","MAC_Unsynchronized_Timeout:","Description: Duration after which an endpoint still in discovery phase will reset its notion of forbidden cell (and number of discovery phases it already tried).","MAC_Warm_Start_Discovery_Duration:","Description: Number of discovery phases during which an endpoint with a preferred cell tries to synchronize only with it.","Comments: This value should be large enough to ensure a high probability of finding the same cell after an outage but small enough to not delay the possible synchronization with another cell if the preferred one is no longer available. This does not affect the notion of forbidden cell.\n\nMAC_Xdrift_Filter_A, MAC_Xdrift_Filter_B:\n\nDescription: These are the filter coefficients for crystal drift correction.\n\nComments: Modifying these coefficients will make the filter step response slower or faster. A faster step response can be desirable to speed up the frequency synchronization of the nodes. Any modification of these parameters should be done carefully to avoid making the system unstable, see the relevant appendix.\n\nMAC_Xdrift_LeapTS\n\nDescription: This is the interval between leap time slots. Every MAC_Xdrift_LeapTS time slots, the SACT is loaded with its initial value plus a small correction to compensate for the drift of the crystal.\n\nComments: Large values of this parameter will increase the resolution of the crystal drift compensation, but will also increase the importance of the correction to be applied at each leap time slot. Large values of MAC_Xdrift_LeapTS should only be used with good crystals in order to avoid a desynchronization between two leap time slots.\n\nMAC_Xdrift_Tmin:\n\nDescription: This is the minimum time interval over which the clock corrections need to be summed before a new crystal drift correction value can be computed.\n\nComments: The value of this parameter depends on the average error made when the clock (SACT) is adjusted from incoming packets. If uncertainties in the time of arrival of packets are important, this parameter should be increased to average out the uncertainties.\n","Depending on the local regulations and the frequency band in which the protocol operates, the default values of the MAC parameters change. The following table gives default values for the parameters related to the general or internal operation of the MAC layer as well as traffic load management.",{"@attributes":{"id":"p-0294","num":"0300"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":[{},{},"AC-","AC-",{},{}]},{"entry":["MAC Parameters","MAC-NA-","NA-","EU-","MAC-"]},{"entry":["MAC","915","2400","868","EU-2400","Units"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Clock_Accuracy","\u00b120",{},{},{},"ppm"]},{"entry":["FW_Accuracy","34",{},{},{},"\u03bcs"]},{"entry":["HFC_Max","255",{},{},{},"hyperframes"]},{"entry":["HF_Length","832",{},{},{},"TS"]},{"entry":["Hopping_Super_Sequence_Length","16",{},{},{},"basic seq"]},{"entry":["Max_Nb_of_Transmitted_Bytes_sTS","48",{},{},{},"bytes"]},{"entry":["Max_Nb_of_Transmitted_Bytes_TS","288",{},{},{},"bytes"]},{"entry":["Max_nb_of_downlink_buffered_packets","5",{},{},{},"packets"]},{"entry":["Max_nb_of_uplink_buffered_packets","5",{},{},{},"packets"]},{"entry":["Max_Packet_Length","176",{},{},{},"bytes"]},{"entry":["Nb_of_Basic_Hopping_Sequences","16",{},{},{},"sequences"]},{"entry":["Nb_of Sub_TS","6",{},{},{},"sub-TS"]},{"entry":["Number_of_Channels","52","5",{},"15","channels"]},{"entry":["RSSI_Sampling_Rate","66.667",{},{},{},"Hz"]},{"entry":["SACT_Resolution","100",{},{},{},"\u03bcs"]},{"entry":["Sub_TS_Length","20",{},{},{},"ms"]},{"entry":["Traffic_Density_max","0.8",{},{},{},"\u2014"]},{"entry":["Traffic_Monitoring_Window","256",{},{},{},"TS"]},{"entry":["TS_Length","150",{},{},{},"ms"]},{"entry":["TS_Margin","15",{},{},{},"ms"]},{"entry":["Tx_Window_max","256",{},{},{},"TS"]},{"entry":["Tx_Window_min","10",{},{},{},"TS"]},{"entry":["Xdrift_Filter_A"," 1\/16",{},{},{},"\u2014"]},{"entry":["Xdrift_Filter_B","0.732",{},{},{},"\u2014"]},{"entry":["Xdrift_LeapTS","256",{},{},{},"TS"]},{"entry":["Xdrift_Tmin","3",{},{},{},"min"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},"The next table gives default values for the parameters related to the discovery phase.",{"@attributes":{"id":"p-0296","num":"0302"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":[{},{},"MAC-","MAC-","MAC-",{}]},{"entry":["MAC Parameters","MAC-NA-","NA-","EU-","EU-"]},{"entry":["MAC","915","2400","868","2400","Units"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Discovery_Beacon_Period","20",{},"ms"]},{"entry":["Listening_Window_Length","2.5",{},"s"]},{"entry":["Max_Discovery_Phase_Period","30",{},"s"]},{"entry":["Max_Nb_of_Discovery_Phases","156",{},"Phases"]},{"entry":["Min_Discovery_Phase_Period","3.7",{},"s"]},{"entry":["Warm_Start_Discovery_Duration","104",{},"Phases"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The next table gives default values for the parameters related to synchronization, synchronization father choice, cell choice and neighbor table management.",{"@attributes":{"id":"p-0298","num":"0304"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"56pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":[{},{},{},{},"MAC-",{}]},{"entry":["MAC Parameters","MAC-NA-","MAC-","MAC-","EU-"]},{"entry":["MAC","915","NA-2400","EU-868","2400","Units"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Beacon_Period_SYNC","625",{},"TS"]},{"entry":["CELL_Leaving_Process_Duration","60",{},"seconds"]},{"entry":["CELL_Switch_Hysteresis","400",{},"\u2014"]},{"entry":["CELL_Weight_CSI","128",{},"\u2014"]},{"entry":["CELL_Weight_GPD","1",{},"\u2014"]},{"entry":["CELL_Weight_Level","0",{},"\u2014"]},{"entry":["Excellent_Connectivity_Threshold","3",{},"potential SYNC"]},{"entry":[{},{},{},"fathers"]},{"entry":["GPD_TD","8",{},"\u2014"]},{"entry":["LPD_NAVG","32",{},"\u2014"]},{"entry":["LPD_Max","255",{},"\u2014"]},{"entry":["LPD_Switch","\u221270",{},"dBm"]},{"entry":["LPD_RSSI","3",{},"\u2014"]},{"entry":["Max_Nb_of_Neighbors","10",{},"neighbors"]},{"entry":["Max_Nb_of_SYNC_Request","10",{},"attempts"]},{"entry":["Neighbor_Timeout","10",{},"minutes"]},{"entry":["RSSI_Var","225",{},"\u2014"]},{"entry":["RXI_Decay","0.9",{},"\u2014"]},{"entry":["RXI_Increment","20",{},"\u2014"]},{"entry":["RXI_Threshold","80",{},"\u2014"]},{"entry":["SP_CD1","100",{},"\u2014"]},{"entry":["SP_LPD1","200",{},"\u2014"]},{"entry":["SP_LPD2","1000",{},"\u2014"]},{"entry":["SP_LPD3","4000",{},"\u2014"]},{"entry":["SP_RXI1","400",{},"\u2014"]},{"entry":["SP_RXI2","2000",{},"\u2014"]},{"entry":["SYNC_Disc_Weight_CSI","128",{},"\u2014"]},{"entry":["SYNC_Disc_Weight_GPD","1",{},"\u2014"]},{"entry":["SYNC_Disc_Weight_Level","50",{},"\u2014"]},{"entry":["SYNC_Father_Request_Beacon_Threshold","625",{},"TS"]},{"entry":["SYNC_Merit_Hyst1","50",{},"\u2014"]},{"entry":["SYNC_Merit_Hyst2","150",{},"\u2014"]},{"entry":["SYNC_Request_Period","10",{},"TS"]},{"entry":["SYNC_Top_N","10",{},"\u2014"]},{"entry":["Unsynchronized_Timeout","2",{},"days"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The following generally discusses frequency and time division facets of the present subject matter. In particular, the present protocol subject matter is based on a frequency hopping system for better interference immunity and to be in accordance with the spread spectrum regulations in some countries. In North America, a frequency hopping system allows a transmitted power higher than a system using a single narrow channel. It means that frequency and time will be divided. To establish an RF link between two nodes, two conditions have to be respected, which are that the two entities have to operate at the same frequency and at the same time. The protocol respects these two conditions by adopting a time slot scheme.","The time frame is divided per present subject matter into regular time slots, each one operating on a different frequency. In the United States, the FCC rules (Part 15.247) specify that for a FHSS system, the average time of occupancy on any frequency shall not be greater than 0.4 second in a 20-second window. In Europe, the same limitation applies in the 2.4 GHz band. On the other hand, there is no dwell time per channel limitation in the 868 MHz band. Devices operating in the 868 MHz band shall comply with a general duty cycle limit that is averaged over all the channels used by the system. For the present subject matter, the duration of a time slot has been sized to contain one single maximum-size message, as represented by present .","Applicable FUSS regulations also specify the minimum number of frequencies that have to be used. In North America, in the 915 MHz band, if the channels are less than 250 kHz wide, the minimum number of channels is 50. For the 2.4 GHz band, in North America as well as in Europe, at least 15 channels are required. There is an exception to such rules. In particular, in the 2.4 GHz European band, at least 20 channels are required if an adaptive frequency hopping strategy is used. Adaptive frequency hopping allows the selection of the best channels to avoid interference. On the other hand, there is no minimum number of channels in the 868 MHz European band. The more channels there are in the system, the higher the isolation between adjacent cells will be, but the longer will be the synchronization time.","In order to make an RF communication possible, any two nodes of the network need to know precisely which channel to use in every time slot. To make such operation possible, the channel use is organized according to a frequency hopping sequence known by all the endpoints belonging to the network. Such sequence is designed to use all the channels equally on average.","To provide isolation between adjacent cells, each cell has its own frequency hopping sequence. Such sequence per present subject matter is discovered by all the endpoints of the cell during the synchronization process. To add more isolation between the cells, it has been chosen per present subject matter to organize the hopping pattern into hyperframes. See also present  representing present hyperframe and channel sequence subject matter, based on 15 exemplary channels, with 10 basic sequences. Such a hyperframe technique follows a frequency hopping hyper-sequence built with several different basic frequency hopping sequences, which make a longer sequence but always with the same sub-set of channels. The sequence is now constituted with K different basic sequences, which means MAC_HF_Length=K*MAC_Number_of_Channels time slots. Such present approach also adds a better immunity to jammers. In a given cell, all the hyperframes are preferably identical per present subject matter. Once the system has swept across a hyperframe, it repeats the same sequence in a periodic way.","With respect to present channel sequence assignment, per the present subject matter, all the endpoints know the different channel sequences that can be used but only one channel sequence is used by cell. The channel sequence is given by the cell relay. The sequence is computed by the knowledge of the specific algorithm which uses the C12.22 address of the cell relay as seed. To change the hopping sequence in a cell, the collection engine has to change the address of the cell relay.","If there are several cell relays in the same area, it is imperative that they follow different channel sequences. Only one cell relay is possible by cell (because cell relays are not synchronized with each other). On the contrary, per present subject matter, a high number of different cells can operate in the same area because they don't hear each other most of the time.","The cell number given to the cell relay is transmitted and forwarded to all the endpoints in the cell, per present subject matter. Such field is used to generate the hopping sequence, as otherwise described herein.","Cell isolation is achieved per present subject matter preferably through quasi-orthogonal sequences in a frequency hopping network. More particularly, in accordance with present subject matter, two nested pseudo-random sequences are utilized to isolate cells in a frequency hopping spread spectrum network. The inner sequence is generated with Galois field arithmetic and the outer sequence is a Fibonacci sequence that uses the cell unique address as a seed.","The present protocol subject mater is based on frequency hopping spread spectrum (FHSS) for better interference immunity and compliance with radio regulations in some countries. In a typical FHSS system all the nodes hop their channel frequency according to the same pseudo-random sequence in order to be perfectly synchronized for both reception and transmission. The frequency hopping pattern is the rule that assigns a channel number to each time slot of the slotted Aloha protocol. Such pattern is periodic, and it will repeat itself indefinitely.","As it is very difficult to maintain a good synchronization for a very large number of nodes, the system of the present subject matter is advantageously divided into cells. Each cell contains a limited number of nodes and has its own pseudo-random sequence for transceiver synchronization. Per present subject matter, all the nodes inside a cell are synchronized with each other but the different cells are not synchronized with each other. Technical problems of such approach which are addressed per the present subject matter include how to find a simple way to generate a pseudo-random sequence for each cell, and how to make sure that these sequences will be unique and provide sufficient isolation between adjacent cells.","The present subject matter combines the use of Galois field arithmetic and Fibonacci sequences to generate pseudo-random sequences. The resulting sequence is the combination of two nested sequences. The inner one is generated by Galois field arithmetic and the outer one is generated by a Fibonacci sequence using the cell address as a seed. The cell address is unique to each cell and will lead to completely different sequences for any two adjacent cells even if the addresses differ only by one.","The following is a formal description of the present hopping pattern construction subject matter.","The inner hopping sequence is constructed with a Galois field of order p, where p is a prime number. Addition and multiplication in this field are to be carried out modulo p. This Galois field is\n\n()={0,1,2,3, . . . ,1}\n","In any Galois field, one can find primitive elements. An element is said to be primitive if its successive powers generate all the non-zero elements of the field. If \u03b1 is a primitive element of the field, the field can be written as follows:\n\n()={0,1,\u03b1,\u03b1,\u03b1, . . . \u03b1}\n","To create the inner hopping sequence from this, only the non-zero elements of the field are selected and definition as follows is established of the ordered (p\u22121)-tuple (1,\u03b1,\u03b1,\u03b1, . . . \u03b1). The length of the inner hopping sequence (the number of hops in the sequence), is equal to the number of channels used by the system, N=p\u22121. The RF link will use several different inner hopping sequences. Each one of such sequences will be generated by its own primitive element. K different primitive elements are selected to generate K different inner hopping sequences. Such primitive elements are (\u03b1,\u03b1,\u03b1, . . . \u03b1).","The inner hopping sequences are numbered from 0 to K\u22121. The k-th hopping sequence is generated by the k-th primitive element and its expression is:\n\n()=(1,\u03b1,\u03b1,\u03b1, . . . \u03b1)\n\nOr, in a compact form\n\n()=\u03b10,1,2, . . . 1, 0,1,2, . . . 1\n","Where IHS(k, n) is the channel number of the n-th hop of the k-th inner hopping sequence and \u03b1is the primitive element of the k-th inner hopping sequence.","The outer hopping sequence is intended per present subject matter to provide a hopping pattern which is unique to each cell. To make the pattern unique, the outer hopping sequence is built with a Fibonacci sequence using the cell identifier as a seed, as follows:\n\n(0)=Cell Identifier(0)\n\n(1)=Cell Identifier(1)\n\n()=(1)+(2), 2,3,4, . . . , 1\n","Here the cell identifier is broken up into two parts: the most significant and the least significant part. The integer M is the length of the outer sequence As a present alternative, any extension of this process is possible per present subject matter. For example, one can break up the cell identifier in four parts and use a Tetranacci sequence, as follows:\n\n()=Cell Identifier(), 0,1,2,3\n\n()=(1)+(2)+(3)+(4), 4, . . . , 1\n","The elements of the outer sequence are used to select a specific N-hop inner frequency hopping sequence. For such purpose, the Fibonacci sequence elements are computed with modulo arithmetic in order to map into the set of available hopping sequences. From the inner sequence and the outer sequence the resulting hopping hyper sequence is obtained with the following nesting procedure:",{"@attributes":{"id":"p-0320","num":"0326"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mo":["{","}"],"mrow":{"mrow":[{"mo":["[","]"],"mrow":{"mrow":[{"mi":"IHS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"OHS","mo":"\u2061","mrow":{"mo":["(",")"],"mn":"0"}},"mo":",","mn":"0"}}},{"mi":"IHS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"OHS","mo":"\u2061","mrow":{"mo":["(",")"],"mn":"0"}},"mo":",","mn":"1"}}},{"mi":"IHS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"OHS","mo":"\u2061","mrow":{"mo":["(",")"],"mn":"0"}},{"mi":"N","mo":"-","mn":"1"}],"mo":","}}}],"mo":[",",",","\u2062",","],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},{"mo":["[","]"],"mrow":{"mrow":[{"mi":"IHS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"OHS","mo":"\u2061","mrow":{"mo":["(",")"],"mn":"1"}},"mo":",","mn":"0"}}},{"mi":"IHS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"OHS","mo":"\u2061","mrow":{"mo":["(",")"],"mn":"1"}},"mo":",","mn":"1"}}},{"mi":"IHS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"OHS","mo":"\u2061","mrow":{"mo":["(",")"],"mn":"1"}},{"mi":"N","mo":"-","mn":"1"}],"mo":","}}}],"mo":[",",",","\u2062",","],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},{"mi":"\u2026","mo":["\u2062","[","]"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mrow":[{"mi":"IHS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"OHS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"M","mo":"-","mn":"1"}}},"mo":",","mn":"0"}}},{"mi":"IHS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"OHS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"M","mo":"-","mn":"1"}}},"mo":",","mn":"1"}}},{"mi":"IHS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"OHS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"M","mo":"-","mn":"1"}}},{"mi":"N","mo":"-","mn":"1"}],"mo":","}}}],"mo":[",",",","\u2062",","],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}],"mo":[",",","]}},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}}},"As the computation of high powers of a primitive element can be difficult to implement on a microprocessor, it is recommended per present subject matter to compute the inner hopping sequence iteratively. With the first hop always designated as 1, each successive hop can be easily computed from the preceding hop by the following equation.",{"@attributes":{"id":"p-0322","num":"0328"},"maths":{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":["\u2003","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.em","height":"0.ex"}}},"mrow":{"mo":"{","mtable":{"mtr":[{"mtd":[{"mrow":{"mrow":{"mi":"IHS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"k","mo":",","mn":"0"}}},"mo":"=","mn":"1"}},{"mrow":{"mi":"n","mo":"=","mn":"0"}}]},{"mtd":[{"mrow":{"mrow":{"mrow":[{"mi":"IHS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["k","n"],"mo":","}}},{"msub":{"mi":["\u03b1","k"]},"mo":"\u2062","mrow":{"mi":"IHS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"k","mo":",","mrow":{"mi":"n","mo":"-","mn":"1"}}}}}],"mo":"="},"mo":","}},{"mrow":{"mrow":[{"mi":"k","mo":"=","mn":"0"},{"mi":"K","mo":"-","mn":"1"},{"mi":"n","mo":"=","mn":"1"},{"mrow":{"mi":["\u2026","N"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":"-","mn":"1"}],"mo":[",",",",",","\u2062",",",",",",",","],"mn":["1","2","2"],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}]}]}}}}}},"This inner hopping sequence is very readily computed with only the knowledge of the previous hop and the hopping sequence number. This is intended per present subject matter to be computed before each hop, avoiding the need to store all the possible hopping sequences in memory.","The use of two nested sequences per the present subject matter advantageously improves spreading and interference immunity. Also, a simple, iterative way to compute the hopping sequences is provided, a simple way to generate hopping sequences unique to each cell is provided, a simple way to isolate the cells is provided, and the iterative implementation leads to very low memory and computation load requirements.","The hopping super-sequence of the present subject matter is intended to provide a hopping pattern which is unique to each cell. To make the pattern unique, the hopping super-sequence is built with a Fibonacci sequence using the cell identifier CELL as a seed. CELL is a 2-byte address. That is first broken up into four 4-bit numbers, as follows:",{"@attributes":{"id":"p-0326","num":"0332"},"maths":{"@attributes":{"id":"MATH-US-00009","num":"00009"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":"\u2003","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"CELL","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":["15","14","13","12"],"mo":[",",",",","]}}},{"msub":{"mi":["C","id"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mn":"0"}}],"mo":"="}}},{"mtd":{"mrow":{"mrow":[{"mi":"CELL","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":["11","10","9","8"],"mo":[",",",",","]}}},{"msub":{"mi":["C","id"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mn":"1"}}],"mo":"="}}},{"mtd":{"mrow":{"mrow":[{"mi":"CELL","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":["7","6","5","4"],"mo":[",",",",","]}}},{"msub":{"mi":["C","id"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mn":"2"}}],"mo":"="}}},{"mtd":{"mrow":{"mrow":[{"mi":"CELL","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":["3","2","1","0"],"mo":[",",",",","]}}},{"msub":{"mi":["C","id"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mn":"3"}}],"mo":"="}}}]}}}}}},"The Fibonacci sequence is then constructed with the following:\n\n()=(1)+(2)+(3)+(4), 4,5, . . . , 3\n","In that sum all the additions should be carried out modulo 16. Each term in the sequence is then an integer between 0 and 15, as follows:\n\n0\u2266()\u226615\n","The integer M is the length of the super-sequence. One of ordinary skill in the art will observe that this particular indication is not a bona fide Fibonacci sequence because four terms are used in the sum instead of two. Some authors have coined the word Tetranacci to name such a sequence. The hopping super-sequence will be:\n\n=((4),(5), . . . , (3))\n","This can also be written:\n\n()=(4), 0\u22661\n","The elements of the super-sequence are used to select a specific N-hop basic frequency hopping sequence. If K=16, each element of the Fibonacci sequence points naturally to a hopping sequence. This is the case for the PHY-FHSS-NA-915 physical layer. If less than 16 basic hopping sequences are available, The Fibonacci sequence elements are converted to modulo K integers in order to map into the set of available hopping sequences, as follows:\n\n()=MOD((4),), 0\u22661\n","Given the hopping super-sequence:\n\n=((0),(1), . . . (1))\n\nAnd the set of K basic hopping sequences:\n\n()=((0),(1), . . . (1)), 0\u22661\n\nThe hyper-sequence is constructed in the following way:\n",{"@attributes":{"id":"p-0333","num":"0339"},"maths":{"@attributes":{"id":"MATH-US-00010","num":"00010"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mo":["{","}"],"mrow":{"mrow":[{"mo":["[","]"],"mrow":{"mrow":[{"mi":"HS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"HSS","mo":"\u2061","mrow":{"mo":["(",")"],"mn":"0"}},"mo":",","mn":"0"}}},{"mi":"HS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"HSS","mo":"\u2061","mrow":{"mo":["(",")"],"mn":"0"}},"mo":",","mn":"1"}}},{"mi":"HS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"HSS","mo":"\u2061","mrow":{"mo":["(",")"],"mn":"0"}},{"mi":"N","mo":"-","mn":"1"}],"mo":","}}}],"mo":[",",",","\u2062",","],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},{"mo":["[","]"],"mrow":{"mrow":[{"mi":"HS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"HSS","mo":"\u2061","mrow":{"mo":["(",")"],"mn":"1"}},"mo":",","mn":"0"}}},{"mi":"HS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"HSS","mo":"\u2061","mrow":{"mo":["(",")"],"mn":"1"}},"mo":",","mn":"1"}}},{"mi":"HS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"HSS","mo":"\u2061","mrow":{"mo":["(",")"],"mn":"1"}},{"mi":"N","mo":"-","mn":"1"}],"mo":","}}}],"mo":[",",",","\u2062",","],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},{"mi":"\u2026","mo":["\u2062","[","]"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mrow":[{"mi":"HS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"HSS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"M","mo":"-","mn":"1"}}},"mo":",","mn":"0"}}},{"mi":"HS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"HSS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"M","mo":"-","mn":"1"}}},"mo":",","mn":"1"}}},{"mi":"HS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"HSS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"M","mo":"-","mn":"1"}}},{"mi":"N","mo":"-","mn":"1"}],"mo":","}}}],"mo":[",",",","\u2062",","],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}],"mo":[",",","]}},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}}},"This M*N-hop hyper-sequence repeats itself indefinitely in a periodic way. During the first time slot, the endpoint's transceiver will use the frequency indicated by the first element of this hyper-sequence for both transmission and reception activities. For the second time slot, it will use the second element and so on.","The length of the hyper-sequence, M*N, is related to the MAC layer parameter:\n\n=MAC_HF_Length\n","A special case is worth mentioning. If the cell identifier is empty, that is, if it contains only zeros, the super-sequence will be a constant sequence of zeros. In this case the hyper-sequence reduces to the repetition of the first basic hopping sequence as follows:","[HS(0,0),HS(0,1), . . . , HS(0,N\u22121)]","The succession of M*N time slots using the channels given by this hyper-sequence is called a hyperframe. Present  illustrates a present exemplary structure of a hyperframe. The basic hopping sequence index is the hop number within each basic hopping sequence and the super-sequence index specifies the position within the super-sequence.","The hyper-sequence of the present subject matter has been designed to avoid having two different cells working with the same hopping pattern, provided they have different cell identifiers as defined herein. As it is likely that two adjacent cells will have close cell identifiers, it has been checked that the proposed algorithm leads to two very different hopping patterns even if the cell identifiers differ by only one bit.","These sequences are nevertheless not totally orthogonal and some collisions are unavoidable. One should also keep in mind that the clocks of adjacent cells will drift with respect to each other. The consequence is that two super-sequences that differ only by a cyclic permutation will not necessarily provide cell isolation in a reliable way. The probability for this to happen is however believed to be very low.","For the physical layer of the exemplary embodiment PHY-FHSS-NA-915 (regarding 915 MHz), the number of channels is:\n\n=MAC_Number_of_Channels=52\n\nThe number of basic hopping sequences is K=16, the super-sequence length is M=16 and the hyper-sequence length is:\n\n=MAC_HF_Length=52\u00d716=832\n\nPresent  gives the primitive elements for the K basic hopping sequences for a PHY-FHSS-NA-915 exemplary embodiment.\n","The basic hopping sequence generation rule is, for each of the 16 sequences",{"@attributes":{"id":"p-0343","num":"0349"},"maths":{"@attributes":{"id":"MATH-US-00011","num":"00011"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":"\u2003","mrow":{"mo":"\u2003","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":[{"mrow":{"mrow":{"mi":"HS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"k","mo":",","mn":"0"}}},"mo":"=","mn":"1"}},{"mrow":{"mi":"n","mo":"=","mn":"0"}}]},{"mtd":[{"mrow":{"mrow":{"mrow":[{"mi":"HS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["k","n"],"mo":","}}},{"mi":"MOD","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"msub":{"mi":["\u03b1","k"]},"mo":"\u2062","mrow":{"mi":"HS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"k","mo":",","mrow":{"mi":"n","mo":"-","mn":"1"}}}}},"mo":",","mn":"53"}}}],"mo":"="},"mo":","}},{"mrow":{"mrow":[{"mi":"k","mo":"=","mn":"0"},{"mi":"n","mo":"=","mn":"1"},{"mi":"\u2026","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mn":"51"}],"mo":[",",",",",","\u2062",",",",",",",","],"mn":["1","2","15","2"],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}]}]}}}}}}},"As an example, this is the detail for generation of the basic hopping sequence number 2. From the table of , the primitive element for the basic hopping sequence number 2 is 5. The sequence will be computed by:",{"@attributes":{"id":"p-0345","num":"0351"},"maths":{"@attributes":{"id":"MATH-US-00012","num":"00012"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":"\u2003","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":[{"mrow":{"mrow":{"mi":"HS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":["2","0"],"mo":","}}},"mo":"=","mn":"1"}},{"mrow":{"mi":"n","mo":"=","mn":"0"}}]},{"mtd":[{"mrow":{"mrow":{"mrow":[{"mi":"HS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":"2","mo":",","mi":"n"}}},{"mi":"MOD","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mn":"5","mo":"*","mrow":{"mi":"HS","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":"2","mo":",","mrow":{"mi":"n","mo":"-","mn":"1"}}}}},"mo":",","mn":"53"}}}],"mo":"="},"mo":","}},{"mrow":{"mrow":[{"mi":"n","mo":"=","mn":"1"},{"mi":"\u2026","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mn":"51"}],"mo":[",",","],"mn":"2"}}]}]}}}}}},"The first hop is always:\n\n","The second hop is:\n\n","The third hop is:\n\n","The fourth hop is:\n\n","The fifth hop is:\n\n","The sixth hop is:\n\n","Such process continues until the 52 hops are computed.","With reference to conducting communications with an adjacent cell, whether the hopping sequence should be implemented by a modulo n multiplication or by a table look-up is a question of trade-off between computation speed and memory. Although the iterative approach has been suggested above, either choice may be made by the user, in accordance with the present subject matter, without adversely affecting the broader aspects of the present protocol subject matter.","There is a situation where the conditions of such trade-off are different. When an endpoint wants to communicate with another endpoint belonging to a different cell, there is a need for it to be able to quickly compute the hopping pattern of the new cell in order to be able to chime in with the right frequency in the middle of the hopping pattern. If the iterative multiplication process is used in such case, it would lead to a number of modulo p multiplications as large as the hop number in the basic sequence. If this is in a given instance an excessive burden for the microcontroller, the present subject matter may alternatively use the exponentiation by squaring algorithm to speed up the computation. Such algorithm, adapted from cryptographic computations, can be applied iteratively and will lead to a number of operations proportional to the logarithm in base two of the hop number. The gain on computation time is therefore relatively large.","The exponentiation by squaring algorithm consists in the iterative application of the following equation:",{"@attributes":{"id":"p-0356","num":"0368"},"maths":{"@attributes":{"id":"MATH-US-00013","num":"00013"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msup":{"mi":["x","n"]},"mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":[{"mi":"x"},{"mrow":{"mi":"n","mo":"=","mn":"1"}}]},{"mtd":[{"msup":{"mrow":{"mo":["(",")"],"msup":{"mi":"x","mn":"2"}},"mfrac":{"mi":"n","mn":"2"}}},{"mrow":{"mi":["n","even"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}]},{"mtd":[{"msup":{"mrow":{"mi":"x","mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":"x","mn":"2"}}},"mfrac":{"mrow":{"mi":"n","mo":"-","mn":"1"},"mn":"2"}}},{"mtable":{"mtr":[{"mtd":{"mrow":{"mi":["n","odd"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}},{"mtd":{"mrow":{"mi":"n","mo":">","mn":"1"}}}]}}]}]}}}}},"br":[{},{}],"in-line-formulae":[{},{}],"i":["HS","k,n"],"sub":"k","sup":"n "},"The following example is based on computing the channel number for the hop number 33 of the basic sequence number 7 of the PHY-FUSS-NA-915 physical layer.","From the above-referenced table (), the basic hopping sequence number 7 uses the primitive element 19. Therefore, is computed:\n\n(7, 33)=\u03b1=19\n","A first application of the algorithm leads to:\n\n(7,33)=19\u00d719=19(19)(mod 53)\n","Now performing the first squaring: 19=361=43 (mod 53) and on to the next step:\n\n(7,33)=19(43)=19(43)(mod 53)\n","Second squaring: 43=1849=47 (mod 53)\n\n(7,33)=19(47)=19(47)(mod 53)\n","Third squaring: 47=2209=36 (mod 53)\n\n(7,33)=19(36)=19(36)(mod 53)\n","Fourth squaring: 36=1296=24 (mod 53)\n\n(7,33)=19(24)(mod 53)\n","Fifth squaring: 24=576=46 (mod 53)","And a final multiplication:\n\n(7,33)=19\u00d746=874=26(mod 53)\n","Even though the channel number is 26, the subject exemplary computation has been computed in only 6 operations instead of 32.","With reference to message positions and sub time slots, messages will have very different lengths. At one extremity, one would find MAC messages, such as beacons, which occupy a small percentage of the time slot duration, and at the other extremity, one would find messages from above layers, which occupy a complete time slot.","The TS length has been sized to contain one message of the maximum size, MAC_Max_Nb_of_Transmitted_Bytes. If the API layer requests a longer message, the LLC will fragment this message in packets. Of course, each packet will not exceed MAC_Max_Nb_of_Transmitted_Bytes (PHY header and preamble included), as otherwise also referenced in conjunction with the LLC layer description.","The MAC messages are the shortest messages that can be sent. Since the physical layer is by default in receiving mode, packets can be received in a timeslot where a packet has been sent. To limit the number of collisions inside a TS between the received and transmitted packets, timeslots are divided in sub-timeslots (Sub_TS) of equal sizes (MAC_Sub_TS_Length). Their size is set to fit in the longest of the MAC messages. For example, in  (showing TS margins and Sub Time Slots), up to 6 beacons from different neighbors can be received in a single TS.","The maximum size of a message that can fit into a sub time slot is Max_Nb_of_Transmitted_Bytes_sTS. If a message is too long to fit in one sub time slot, it will use several, but it will always start at the beginning of a sub time slot in order to occupy a minimum number of them. This is actually the concept of slotted aloha access which is here applied to the sub time slot structure of a time slot.","When a message should be sent, the selection of the Sub_TS number is randomized between the second and last sub-TS for a MAC message; A LPDU message will always start at the beginning of a TS (so in the first sub-TS).","Another aspect in the division of a TS, is the TS margins. At the beginning and at the end of each TS, a part of it has to be free of transmissions. If transmissions are not allowed in this part of the TS, receptions are.","These margins give the possibility of communication between two endpoints that are not perfectly synchronized. Length of these margins, MAC_TS_Margin, reflects the maximum authorized error of time synchronization between two resynchronizations, in the worst-case scenario (maximum clock errors, several missed beacons, no traffic, etc.).","The network per the present subject matter is divided into cells, where the traffic is expected to be low. Moreover, the network operates in an ISM band, where many other users occupy the same medium (with the same rules). So, the probability of collision due to the external environment is likely to be higher than the probability of collision within the subject network itself. That's why the slotted Aloha algorithm is appropriate to manage the access to the medium. The entire cell is synchronized in time and frequency (as described herein). When an endpoint wants to speak, it just pushes its message onto the medium on a random time slot. The recipient will receive the message because it is synchronized and because by default, an endpoint is listening to the medium (Physical Layer is, by default, in receive mode). Obviously, a collision occurs when two close endpoints want to speak in the same time slot, but this is solved by a repetition of the messages, repetition managed by the LLC layer. When pushing a data on the medium, the MAC layer doesn't care if it is an Uplink or Downlink message; the bit rate and all other parameters are the same for both ways. Data transmission is non-hierarchical and symmetrical.","Because channels are equally represented and because data can be pushed onto any time slot, the present protocol subject matter respects the uniform occupancy of the media over the band.","It is very important that the traffic remains very low to ensure a good working of the Slotted Aloha access. Slotted Aloha would allow up to 35% data load if the subject network were alone on the media. In a real-life situation, 3% data load is more adequate.","Each time a packet is received from a neighbor, the physical layer makes available an RSSI reading for that packet. For each neighbor in its neighbor table, the MAC layer will compute an average value of this RSSI with a Kalman filter. This filter will give an accurate estimate of the average RSSI as soon as a few RSSI readings will be available. The following pseudo-code gives the details of this algorithm:",{"@attributes":{"id":"p-0378","num":"0390"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Upon reception of a packet from neighbor X"]},{"entry":[{},"If this is the first packet received from X, then"]},{"entry":[{},"RSSI_Average = current RSSI reading for that packet"]},{"entry":[{},"RSSI_Cov = 255"]},{"entry":[{},"Else compute the new RSSI_Average with"]},{"entry":{}},{"entry":[{},{"maths":{"@attributes":{"id":"MATH-US-00014","num":"00014"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"KG","mo":"=","mfrac":{"mrow":[{"mo":["(",")"],"mrow":{"mi":["Old","RSSI_Cov"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},{"mrow":[{"mo":["(",")"],"mrow":{"mi":["Old","RSSI_Cov"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},{"mi":["MAC_RSSI","_Var"],"mo":"\u2062"}],"mo":"+"}]}}}}}]},{"entry":{}},{"entry":[{},"New RSSI_Average = (1\u2212KG)(Old RSSI_Average) + KG(Current RSSI"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"reading)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"New RSSI_Cov = (1 \u2212 KG)(Old RSSI_Cov)"]},{"entry":[{},"End if"]},{"entry":[{},"Update the neighbor table with the new RSSI_Average value and the new"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"RSSI_Cov value."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"RSSI_Cov is the estimate of the covariance of the RSSI, it has to be kept in memory for each neighbor as well as the average RSSI, RSSI_Average. RSSI_Var is a MAC layer parameter that corresponds to an estimate of the RSSI variance. RSSI and RSSI_Average are 1-byte two's complement coded variables. Their range extends from \u2212128 dBm to +127 dBm. RSSI_Cov is a 1-byte positive variable. KG is the Kalman gain, it is an intermediate result in the Kalman filter computation and its value is always less than one.","The Average RSSI gives a fair indication of the received signal quality, even in environments plagued with Rayleigh fading. As explained in another section of this document, this Average RSSI participates in the choice of the best synchronization father.","It is the task of the MAC layer to update the LPD (Local average Propagation Delay) associated with each neighbor and to compute the GPD (Global average Propagation Delay) from the endpoint to the Cell Relay via each neighbor. These values are used to sort and select neighbors. They are used to select the best access for synchronization or to make a choice between different available cells. The network layer will use these values to choose the best path for uplink (routing packets).","After every packet transmission that requires an acknowledgement, the MAC layer will know if the packet transmission was successful or not. If a positive or negative acknowledgement is received, the transmission will be considered successful. If no acknowledgement is received, the transmission will be considered to have failed. For every neighbor in its neighbor list, the MAC layer will update the individual LPD values as shown below:",{"@attributes":{"id":"p-0383","num":"0395"},"maths":{"@attributes":{"id":"MATH-US-00015","num":"00015"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["New","LPD"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mo":"{","mtable":{"mtr":[{"mtd":[{"mfrac":{"mrow":[{"mrow":{"mi":["MAC_LPD","_NAVG","Old","LPD"],"mo":["\u2062","\u00d7","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":"+","mn":"16"},{"mrow":{"mi":["MAC_LPD","_NAVG"],"mo":"\u2062"},"mo":"-","mn":"1"}]}},{"mrow":{"mi":["if","transmission","failed"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}]},{"mtd":[{"mfrac":{"mrow":[{"mn":"16","mo":["\u2062","\u00d7","\u2062","\u2062"],"mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":["MAC_LPD","_NAVG"],"mo":"\u2062"},"mo":"-","mn":"1"}},"mi":["Old","LPD"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mrow":[{"mi":["Old","LPD"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mn":"16","mo":["\u00d7","\u2062"],"mi":["MAC_LPD","_NAVG"]}],"mo":"+"}]}},{"mrow":{"mi":["if","transmission","succeeded"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}]}]}}],"mo":"="}}}},"In these equations the MAC parameter MAC_LPD_NAVG is an integer value that determines the depth of the sliding average window. A scaling factor of 16 has been introduced to allow an integer representation of LPD. The maximum allowed value for LPD is LPD_Max, any LPD computed value above LPD_Max should be truncated to LPD_Max. Note1: LPD is an integer and when the computation gives a number with decimals, these decimals should be truncated. Note2: the new LPD must always be different from the old one (except when the values are zero or LPD_Max). If the new LPD equals the old one and there was a failure the new LPD should be incremented by one; if there was a success of transmission then the LPD should be decremented by one.","The GPD (Global average Propagation Delay) is the average propagation delay between the endpoint and its associated Cell Relay. The network will compute this value step by step from the Cell Relay down to the endpoint. To avoid confusion, one can consider the following notation:","EP_GPD(X)\u2261Global Propagation Delay between the endpoint and the Cell Master if traffic is routed through the neighbor X.","An endpoint can compute the GPD to the Cell Relay via each one of its neighbors according to the following equation:\n\nEP_GPD()=GPD of neighbor +LPD between endpoint and neighbor +MAC_GPD_TD\n","MAC_GPD_TD is a MAC layer parameter introduced to model the fixed propagation delay through each node of the network (see appendix on path selection algorithm). The best one of these values will be called the endpoint GPD.","GPD=Min{EP_GPD(X)} for all neighbors X that are registered fathers","This GPD value will be included in the MAC header to make this information available to other endpoints. The allowed values for GPD are the integers between zero and 4095.","The node should update its GPD when it changes level or switches to another cell. The endpoint needs also to check if its GPD has not changed at each reception of a message from one of its fathers. In a more general way, an endpoint should always keep the lowest GPD it can, among its registered fathers (from the same cell).","At start-up the LPD values in the neighbor list should be initialized according to the RSSI value of the first message received from these neighbors. The initialization follows this rule:",{"@attributes":{"id":"p-0393","num":"0405"},"maths":{"@attributes":{"id":"MATH-US-00016","num":"00016"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"LPD","mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":[{"mn":"0"},{"mrow":{"mrow":{"mi":["if","RSSI"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":"\u2265","mi":"LPD_Switch"}}]},{"mtd":[{"mrow":{"mi":"Min","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mrow":{"mrow":{"mo":"-","mrow":{"mo":["(",")"],"mrow":{"mi":["RSSI","LPD_Switch"],"mo":"-"}}},"mo":"\u2062","mi":"LPD_RSSI"},"mo":",","mi":"LPD_Max"}}}},{"mrow":{"mrow":{"mi":["if","RSSI"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":"<","mi":"LPD_Switch"}}]}]}}}}}},"where LPD_RSSI and LPD_Switch are MAC layer parameters.","Stated another way, the present protocol subject matter provides advantageously for uplink routing without requiring a routing table. Such is achieved by addressing the main uplink path in the subject network. Such communication is used to convey the data, from every node of the network to a single extraction point. The challenge associated with such feature and presently achieved is for a node to find the path towards the extraction point without the knowledge of the network topology, that is, without a routing table. Following the objective of reaching the extraction point in a shortest time, the traffic should also be relatively spread so as to avoid peaks, as the traffic becomes more dense close to the extraction point.","Conceptually, per present subject matter, the synchronization process has given a level to every node in the network. Such level represents the number of hops between the node and the extraction point. Each node has a certain number of neighbor with a lower level (closer to extraction point), called fathers (or, parents) of the node; equal level, called brothers; and higher level (further from extraction point) called sons.","In accordance with present subject matter, a node should preferably propagate an uplink message to one of its fathers, which means a closer node from the head of the network. The message will at the end converge on the extraction point. The selected father to route an uplink message is belonging to the best father list. Fathers belonging to such list are those with the best GPD. Computation of the Global Propagation Delay, GPD, is otherwise explained herein. The lowest GPD indicates the shortest path in time. The selected father is not necessarily always the one with the best GPD. The node sends uplink messages randomly to one of these best fathers with a probability for each father inversely proportional to its GPD.","Advantageously, practice of such aspects of the present subject matter achieves the benefits that the shortest paths are selected, knowledge concerning only one hop neighbors is sufficient for the achievement, nodes don't need knowledge of the entire network, so that there are no routing table in the nodes, which results in a relatively large savings on required memory. In addition, generally speaking, traffic is spread over the network, due to randomization between fathers.","One aspect of the present protocol subject matter advantageously provides for real time clock distribution and recovery, particularly applicable in a network, for example, otherwise based on the slotted Aloha protocol.","Generally speaking, time is presently divided into time slots (TS) and the nodes send packets inside these time slots. The frequency used for communication changes at each TS according to a determined pattern: the hyperframe. A number, the Time Slot Number (TSN), is incremented at each TS and it rollovers when it reaches the hyperframe length, at which point the frequency pattern repeats itself. A second number, the HyperFrame Number (HFN), is also associated and incremented with each hyperframe.","Nodes are grouped in cell around a concentrator (or root node) and these 2 numbers are common to all the nodes in the cell; this way their transmitters are always set on the same RF frequency. These 2 numbers will be used by the nodes to refresh their \u201creal-time\u201d clock upon receiving a specific message which originates from the root node. Effectively the distribution of the clock will be done from the root node (extraction point of the nodes' data), which is connected to the internet and thus has access to an accurate real time clock (for example, NTP standard).","Generally, nodes operate with crystals, which results in limited accuracy. The present challenge which is successfully addressed herewith is to refresh periodically the time in each node before its clock drifts beyond the desired accuracy. Since the propagation is not instantaneous the system has to take the propagation delay into account.","The present solution is to advantageously broadcast regularly a timestamp (RITP) provided by the chosen real time clock. The creation of the timestamp will always be done at the root node level when the TSN and HFN of the cell are both zero. This broadcast will also contain the hyperframe number (HFN) corresponding to the initial broadcast by the root node; this allows detection of an overflow of HFN and adapt the RITP value in consequence. This message, following the broadcast protocol, will reach all nodes in the cell; the HFN maximum value is designed for the rollover to be much over the maximum propagation delay of this real time clock distribution.","When a node receives this broadcast it can update its \u201creal-time\u201d clock using the following formula:\n\nAbsolute time=(TSN+HFN*hyperframe_length)*Timeslot_Length+RITP\n\nWhere the hyperframe length is expressed in number of timeslots and the timeslot length is a time unit (note 150 ms in the present exemplary case). Note: if the HFN of reception is lower than the HFN included in the broadcast then there was a rollover and the RITP timestamp must be updated by adding HFN rollover value*hyperframe_length*Timeslot_Length. Such present solution gives an absolute time with a resolution equal to the time slot length.\n","When a node just synchronizes in a new network, the RITP timestamp (and HFN corresponding) is given in the synchronization acknowledgement. This way the new node has access to real time without waiting for the next ITP broadcast. Note: This assumes that the RITP broadcast is done each time HFN=TSN=0 to avoid more than one rollover of the HFN number.","Such aspects of the present protocol subject matter advantageously provides a simple way, even while using slotted Aloha architecture, to distribute a real time clock to all the nodes with a resolution of one Time Slot (despite the delay of propagation). It also allows a fast recovery of the real time clock immediately upon synchronizing to a new network.","Therefore, per present subject matter, time management in the MAC layer is performed with the use of several counters.  illustrates the global structure of such present protocol time keeping structure counters, while the following provides some additional description for each one of such counters.","As to the Slotted Aloha Countdown Timer (SACT), at the beginning of each time slot such timer is loaded with a value corresponding to the default time slot length, MAC_TS_Length. When this timer reaches the value zero, a new time slot begins. Every MAC_Xdrift_LeapTS time slots, the SACT is loaded with the value MAC_TS_Length plus a small correction to compensate for the drift of the crystal (see description of leap time slots in the chapter on drift correction).","The SACT is locally implemented with a resolution specified by the parameter MAC_FW_Accuracy but when SACT values are exchanged between endpoints or included in the MAC header for synchronization purpose, the SACT is defined with a resolution of MAC_SACT_Resolution \u03bcs.","The content of the Time Slot Counter is the time slot number (TSN). At the beginning of each time slot this counter is incremented. Its value runs from zero to MAC_HF_Length\u22121. MAC_HF_Length is the number of time slots in a hyperframe.","The content of the Hyperframe Counter is the hyperframe number (HFN). At the beginning of each hyperframe this counter is incremented. Its value runs from zero to MAC_HFC_Max\u22121. MAC_HFC_Max is the number of hyperframes spanned by the MAC Clock.","The Time Slot Counter can be split in two cascaded counters, the Basic Hopping Sequence Counter and the Super-Sequence Counter. The content of the Basic Hopping Sequence Counter indicates the position within a basic hopping sequence. At the beginning of each time slot this counter is incremented. Its value runs from zero to MAC_Number_of_Channels\u22121. MAC_Number_of_Channels is the number of channels used in a basic hopping sequence. The content of the Super-Sequence Counter indicates the position within the hopping super-sequence. When a basic hopping sequence is completed, this counter is incremented. Its value runs from zero to (MAC_HF_Length\/MAC_Number_of_Channels\u22121).","The Relative ITP timestamp (RITP) is initialized to zero at start-up. Once absolute time information is obtained from the network or from the application, this counter can be updated. At each overflow of the hyperframe counter the Relative ITP timestamp must be updated as otherwise explained herein. This timestamp can be implemented with the standard NTP (Network Time Protocol) format or with a shortened version of the standard NTP format according to the required accuracy and span.","Present  generally represents a standard ITP (Itron Time Protocol) timestamp format. From the above-referenced present protocol time management structure, one can define several time values. Two which are given here, will be useful for several purposes, and they are the absolute time and the relative time.","The absolute time corresponds to the real time clock of the application. It can be used to date any event in an absolute way. Its resolution is the time slot length. In terms of the time keeping counters, the absolute time value is given by the formula already referenced hereinabove.","In contrast, the relative time is used to measure durations on a time scale smaller than the span of the MAC clock. This time has a higher resolution because it uses the SACT. In terms of the time keeping counters, the relative time value is given by:\n\nRelative time=(TS_Length\u2212SACT*\u201cSACT time units\u201d)+(TSN+HFN*MAC_HF_Length)*TS_Length\n","The SACT time units depend on the implementation and are given by the parameters MAC_FW_Accuracy or MAC_SACT_Resolution. The span of this relative clock is given by Span of MAC clock=MAC_HFC_Max*MAC_HF_Length*MAC_TS_Length","At each overflow of the Hyperframe Counter, the Relative ITP timestamp needs to be updated as follows:\n\n(New value of RITP)=(Old value of RITP)+(Span of MAC clock)\n","An operation of generating an absolute timestamp is needed when the MAC layer has to inform the LLC layer that a new real time clock value has been delivered by the network. The timestamp value computed in such instance is the absolute time at the moment the MAC layer sends to the upper layers the indication of new timestamp arrival, as follows:\n\nAbsolute ITP timestamp=(TSN+HFN*MAC_HF_Length)*MAC_TS_Length+RITP\n","Relative to generation of a value for the Relative ITP timestamp, when the application communicates an ITP timestamp value to the MAC layer, the MAC layer will need to reference this timestamp to the MAC clock (TSN and HFN) and store the resulting value in its Relative ITP timestamp register. This will occur for instance in a Cell Relay when the application will need to true up the real time clocks of the cell. The RITP value will be computed with the following equation:\n\nRITP=(ITP timestamp value)\u2212(TSN+HFN*MAC_HF_Length)*MAC_TS_Length\n","Relative to present protocol subject matter Time Synchronization Services, there are two ways to propagate the time over an entire cell: at synchronization phase and by periodical update. The present absolute time subject matter will be used both inside the present network protocol subject matter itself (at the MAC layer) and at the application level (in this example, energy metering).","Each cell relay has an NTP client which allows it to receive an NTP timestamp from the WAN. It uses this NTP value to update its RITP. The cell relay sends periodically ITP broadcast messages to the entire cell, with exactly the same process as a \u201cregular\u201d broadcast message. This ITP broadcast message contains the RITP information, base of the time re-generation in endpoints. Each time an EP receives such a message, it reads and updates the RITP and forward the message to its sons.","The second way to acquire the RITP field is during the synchronization process. When an EP wakes up after a power failure, it no longer has any notion of time. The RITP field is given inside a SYNC ACK message after the EP requests synchronization with a synchronized neighbor. Thus, as soon an EP is synchronized, it advantageously knows the time per the present protocol subject matter.","In one aspect of the present subject matter, an objective advantageously achieved is to true up the real time clocks in every node of a cell. There is no requisite Input argument. The operation is described in the context of a service that is only used in a Cell Relay. The Cell Relay MAC layer builds an ITP broadcast packet. The MAC header of this packet contains the value of the RITP together with the HFN at the moment the packet is created. This packet is broadcast with the usual broadcast rules defined in this protocol. This broadcast will allow each recipient node to update its own Relative ITP timestamp. The recipient nodes will use the HFN value included in the packet to detect a possible overflow of the MAC clock since the ITP broadcast packet creation. The span of the MAC clock should be much longer than the expected travel time of a packet through the meshed network in order to avoid ambiguities.","In another aspect of the present subject matter, an objective advantageously achieved is the provision of a service which allows the application layer (through LLC and NET) to update the Relative ITP timestamp of the MAC layer. The requisite Input argument involves the Absolute ITP timestamp. The operation is again described in the context of a service that is only used in a Cell Relay. The MAC layer uses the absolute ITP timestamp to compute a Relative ITP timestamp value. The MAC layer then updates its RITP register with this computed value (See \u201cGeneration of a value for the Relative ITP timestamp\u201d above). This service is usually called before an ITP broadcast. It is distinct from the ITP broadcast service in order to avoid the uncontrolled aging of a timestamp in a packet waiting in a queue.","Still another aspect of the present subject matter is advantageous achievement of an objection of indicating to the application layer (through LLC and NET) that an ITP broadcast has been received. The requisite Output arguments are Absolute ITP timestamp, RITP, and The description of the operation is that the recipient endpoint retrieves the RITP and HFN values from the MAC header. It then compares the HFN value in the message header to its own HFN. This allows the MAC layer to detect a possible overflow of the Hyperframe Counter since the creation of the ITP broadcast packet. If no HFC overflow occurred, it writes the RITP value in its own RITP register. If an overflow occurred, it increments the RITP value with the span of the MAC clock and writes the result in its RITP register. The MAC layer then computes an absolute ITP timestamp (See \u201cGeneration of an absolute timestamp\u201d above) and sends to the LLC layer an indication with this absolute ITP timestamp as argument. This indication informs the LLC layer that the RITP has been updated in the MAC layer and gives to the LLC layer the value of a timestamp that can be used to update the real time clock of the application. The ITP broadcast packet is then forwarded to the endpoint's sons according to the usual broadcast rules. The RITP and HFN values retrieved from the ITP broadcast packet MAC header are also sent to the LLC layer with the purpose of allowing the reconstruction of the packet for the follow-up of the broadcast.","Another objective advantageously achieved with the present protocol subject matter allows an endpoint to obtain the value of the RITP and the value of the Hyperframe counter from its father at synchronization. Such operation is actually a part of the synchronization process, as otherwise discussed herein. However, for the sake of present clarity, it is simply noted that when an endpoint receives an acknowledgement to its synchronization request, it will update its RITP and HFN from the information contained in that acknowledgement.","An important aspect in a mesh network using a frequency hopping sequence is the synchronization process. Indeed, once every EP in the cell knows the channel sequence and the current TS in the sequence, they need to periodically maintain such information up-to-date. Due to clock drift, such information can become corrupted with time. Re-synchronization of the clock of every EP is therefore needed.","When the subject network is switched on for the first time, no components know when the time slots begin and which frequency to use. As in all synchronized systems, a metronome or equivalent operation is needed. The cell relay (or Cell Master) is the preferred such component in the present protocol subject matter because it is always considered as \u201csynchronized\u201d. For the other endpoints, per the present subject matter, the synchronization is hierarchical. Endpoints which can hear the relay (Cell Master) become synchronized, and then it is their turn to synchronize their neighbors. During such process, a level is given to each endpoint, which indicates how many hops they are from the cell relay (Cell Master).","A relay has a level \u201c1\u201d; a non-synchronized endpoint has a level \u201c0\u201d; and an endpoint that is at N hops from the cell relay has a level \u201cN+1\u201d. The respective levels relative to present synchronization protocol are represented in present .","To summarize terminology as otherwise referenced herein, an endpoint which is:\n\n","Present  represents the hierarchical synchronization aspects of the present subject matter, such that an endpoint keeps its synchronization from any synchronized neighbor that respects the following conditions:\n\n","The maximum level in a cell is 63. It is limited by the number of bits (6) allocated to this field in the messages. As a result of the rules above, an EP of level 63 cannot be used for synchronization.","Present  represent various aspects of the present protocol subject matter as relates to resynchronization between endpoints (EPs). Per present subject matter, an EP advantageously resynchronizes itself each time it receives a message from one of its fathers, by re-computing the beginning of its next time slot. At each beginning of time slot, a countdown timer called Slotted Aloha Countdown Timer, SACT, is set with the MAC_TS_Length value. When such timer reaches 0, the MAC layer switches to the next timeslot. The resynchronization process consists in re-computing the value of the SACT to align the sons' timeslots on the fathers' ones. This resynchronization is performed with the following algorithm:\n\n","Advantageously per such present operations, the endpoint auto adjusts the next time slot, which compensates for the internal drift of the device. By following such present process at each received message from a higher-level endpoint, the endpoint drastically decreases the probability of losing its synchronization.","Each time an endpoint receives a message from a neighbor endpoint, the MAC layer records two time values in the neighbor table: the SACT value read from the sender MAC header (SACT10 above) and the reception time of the packet. These values can then be used at any moment when the endpoint decides to synchronize with that neighbor.","The SACT is defined with a resolution of MAC_SACT_Resolution \u03bcs.","Dating received and transmitted messages should be accurate enough to allow the present protocol to work properly, and especially for the resynchronization process to work correctly. The crystal clock of the system should be chosen at \u00b1MAC_Crystal_Accuracy ppm and the firmware has to date the message at \u00b1MAC_FW_Accuracy \u03bcs. Dating a received message should be done by taking a snapshot of the SACT countdown timer when the SFD field is detected by the PHY layer, as it is otherwise explained herein.","A sender should also date the message and include the SACT value in the MAC header.","It is a difficult task to precisely compute the SACT at the exact moment when the PHY layer will send the first bit. Indeed, in the meantime, the MAC layer will have to build the header, compute the CRC and then give the message to the PHY layer; and then the PHY layer will have to add its header and configure the RF transmitter. It is an aspect of the present subject matter that it is preferable for a given implementation thereof (such as in producing the actual firmware to be used), to estimate a worst case time between the moment of the dating and the planned transmission, and set a timer with such time. During such allocation of time, the MAC and PHY layers should have enough time to prepare the packet. The PHY layer will then wait during the remaining time and send the first bit as soon as the timer reaches the defined value.","For a particular implementation using an off-the-shelf transceiver approach, it is noted that dating at the SFD reception is typically the most simple and preferred thing to do. If it is more convenient for a given implementation to date at another moment inside the message, the user is free to do so per the present subject matter, as long as remembering to take into account the length of the message.","When an endpoint receives a message, it can easily compute the beginning of the next time slot. But such information alone is not enough since the channel of the next time slot is not known at that moment. The endpoint will find this information in the MAC header. Three fields are important for the synchronization process. The first one is the level of the sender: (Re)-synchronization is only allowed with the fathers. The two other fields are the time slot number and cell address. As every endpoint can compute the channel sequence from the cell address contained in the header, and because the time slot number informs on where the sender is in this hyper sequence, the recipient can find the channel that the sender will use in the next time slot.","Such three fields are present in all the messages: beacons or other messages. So every message can be used for synchronization. The time slot number field has another use. Even if an endpoint receives a message on an adjacent channel, it will know the actual channel on which the message has been sent.","An EP re-synchronizes itself each time it receives a message from a SYNC father, whatever the nature of the message. If there is no traffic, dedicated messages (presently referred to as beacons) are sent periodically by every synchronized EP. If the traffic is dense enough compared to the default beacon periodicity, beacons are not sent. It can be viewed as a timer with the initial value MAC_Beacon_Periodicity_SYNC. Each time a packet is sent, the timer is restarted from the beginning. If the timer reaches \u20180\u2019, a beacon is sent.","Several parameters permit the computation of beacon periodicity of synchronized EPs. The most important is the clock accuracy of the EP. It is mainly dependent on the accuracy of the crystal (or oscillator) and of the firmware clock. Another parameter is the number of beacons one can assume a system can miss, due to collisions, jammers, etc. The last parameter is the maximum drift the system is authorized to have between 2 levels. For such computation, one may consider the worst case, when an EP has only one SYNC father.",{"@attributes":{"id":"p-0446","num":"0469"},"maths":{"@attributes":{"id":"MATH-US-00017","num":"00017"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":["Beacon_Periodicity","_SYNC"],"mo":"\u2062"},"mo":"=","mfrac":{"mi":"TS_Margin","mtable":{"mtr":[{"mtd":{"mrow":{"mn":"2","mo":["*","*"],"mi":"Clock_Accuracy"}}},{"mtd":{"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":["Max_Nb","_of","_Missed","_Beacons"],"mo":["\u2062","\u2062","\u2062"]},"mo":"+","mn":"1"}},"mo":"*","mi":"TS_Length"}}}]}}}}}},"TS_Margin=15 ms","Clock_Accuracy=\u00b120 ppm","Max_Nb_of_Missed_Beacons=3 missed beacons","TS_Length=150 ms","\u2192Beacon_Periodicity_SYNC=625 TS (this corresponds to 1 min 34 s)","In a low traffic situation with many endpoints transmitting periodic beacons, there is a significant probability that two endpoints will choose the same time slot and sub time slot to transmit their beacons. This probability increases roughly as the square of the number of endpoints and would be close to one in a cluster of 100 endpoints. This would lead to recurring collisions between those beacons. To prevent this situation, the actual transmission time of the beacons should be randomized within a \u00b120%, i.e. around 125 time slot (for MAC_Beacon_Period_SYNC=625) window while keeping the average periodicity defined above.","The Cell Size Indicator, CSI, is a 4-bit field contained in each MAC layer. This field value is set by the Cell Master depending on the size of the cell (determined by the number of entries in a NET Cell Master routing table). This will require an internal message from the NET layer of the Cell Master to its MAC layer. This field, like the GPD, will propagate with each message from the Cell Master. At each received message from one of its fathers, or from endpoints which were fathers, the node updates its CSI looking at the MAC header value. An endpoint (other than the Cell Master) always keeps the highest value of CSI among its fathers belonging to the same cell.","The algorithms to choose a cell during discovery phase and to switch cell will consist in selecting the best father according to their term. The CSI is one of the parameters used to determine this term. The values for the CSI are given in the network layer section.","Alternatively per the present subject matter, the CSI propagation could be based on the last message received from a father. Such approach avoids keeping this extra field in the neighbor table of each EP. The tradeoff is that during the propagation of a new value of CSI, there will be much more bounces (the other way makes it faster to increase the value and slower to decrease it).","A neighbor of an endpoint is called a potential synchronization father (or potential SYNC father) for that endpoint if it complies with all of the following conditions:\n\n","The forbidden character associated with a cell is set by the API layer. It can be set if the user decides that two close-by cells should never authorize endpoints from the other cell or if a cell is full. A cell can be re-authorized by the API layer. This information will also be reset if the meter stays non-synchronized for a long time, defined by the parameter MAC_Unsynchronized_Timeout.","Through a selection process described later, the more suitable potential synchronization father is chosen to become the synchronization father (or SYNC father for short). If this neighbor answers positively to the synchronization request, it becomes the actual SYNC father of the node.","It should be pointed out that the potential SYNC father conditions are evaluated at a given time. If a potential SYNC father (or a SYNC father) is not heard during MAC_Neighbor_Timeout, it will be removed from the MAC neighbor table and will be no more considered as a potential SYNC father (or SYNC father).","When an endpoint becomes synchronized with a cell, some of its potential fathers will be actual fathers and some others might be brothers or sons. On the other hand some fathers might not qualify to be potential SYNC fathers. The fathers that are also potential SYNC fathers will be called healthy fathers. Of course by definition a non synchronized endpoint has no father at all, it can only have potential SYNC fathers.  schematically represents Potential SYNC fathers and healthy fathers for a synchronized node.","The Connectivity Degree (CD) is a variable that measures the connectivity of a node with the network. Connectively Degree per present subject matter is represented by present . The CD value of a node depends only on the number of potential SYNC fathers it has among its neighbors. If the endpoint is not yet synchronized, all potential SYNC fathers are considered for the computation of CD. On the other hand if the endpoint is synchronized, only the brothers and fathers are taken into account. Notice that a synchronized endpoint should have at least one father (inferior level) in order to be considered having connectivity (CD>0). The table below shows how a value is assigned to CD as a function of the number of potential SYNC fathers. This degree is indicated in most of the MAC headers and shared with the neighborhood. It will be used by others for synchronization decisions.","In order to maintain its clock synchronized with the network, an endpoint must receive frequent enough beacons or messages from its fathers. There is therefore a need to assess the average rate at which an endpoint receives messages from a given neighbor. This will play an important role when deciding which neighbor can act as an efficient SYNC father. Neighbors that are only heard once in a while will be deemed bad potential SYNC fathers compared to others that are regularly heard. The Reception Rate Indicator (for short RXI) is easy to implement and provides an indication of the rate at which messages are heard from a neighbor, although it is not an exact measurement of the actual reception rate.","A variable of one byte is associated with each neighbor in the neighbor table. We call this variable the RXI of the neighbor X and write RXI(X). These RXI are managed according to the following rules:\n\n","High values of RXI indicate that the frequency of message reception is high. Therefore, neighbors with high RXI values have an advantage in the SYNC father selection process.","Other discussion herein reflects on how an EP keeps its synchronization from the cell clock per the present subject matter, which assumed for such point of discussion that the EP was already connected. At power-up of after a loss of synchronization, an EP is considered as non-synchronized and enters in a so-called Discovery Phase.","In other words, per present subject matter, this aspect has to do with the provision of a network discovery arrangement wherein a new node with no previous knowledge of its environment is able to establish a link to an existing network. Upon wake up, such new node will preferably transmit a discovery beacon over several channels in succession and then go into a listening mode to listen for any response. The transmitted discovery beacon includes information as to a specific channel on which the new node will listen. When synchronized nodes hear the discovery beacon, they transmit a message to the new node including information necessary for the new node to synchronize with the network. The transmitted message may include time, frequency, network identifier, etc. and is transmitted at the new node indicated frequency and at random times within a listening window. The new node may then collect information and choose the best network among desired criteria and synchronize with the chosen access node in the network.","In a frequency hopping network, nodes that just powered on and start from scratch have no idea of their environment. They need to connect and to synchronize with a network, which is complicated by the fact they don't know at which frequency and which time the network operates. The Discovery Phase of the present protocol subject matter is an algorithmic approach to enable the node to quickly analyze its environment and look for the best network it can connect with, without disturbing the operating network.","Broadly speaking, additional benefits of such present subject matter include that a new neighbor finds a connection with a network in a very short time, all the neighborhood networks are discovered, and all while the neighborhood operating networks are not disturbed from their regular activities.","More specifically, as the traffic is very low inside a cell and as the cell is continuously switching from one channel to another, it can take a long time for a non-synchronized endpoint to intercept a message from a synchronized one. To accelerate this process, the non-synchronized endpoint sends discovery beacons successively on all the channels. The order of channels follows the hopping sequence generated by a cell ID of 0. There is one discovery beacon per channel in the system. The channel of the first discovery beacon should be computed randomly to ensure that two non-synchronized endpoint will not choose the same at power up. Discovery beacons are sent every MAC_Discovery_Beacon_Period ms.","Each discovery beacon contains in the MAC header the Number of remaining Discovery Beacons (NDB field) to send, and the listening channel (RxC field). After sending all the discovery beacons, the endpoint enters in a listening state during MAC_Listening_Window_Length. The listening channel is the same than the one used for the first discovery beacon. There is a high probability that synchronized EPs in the radio range of the EP will receive at least one of these discovery beacons. The reception of one of these discovery beacons forces them to send a \u201cforced beacon\u201d at the required channel inside the listening window. As every synchronized EP in the neighborhood will do the same pattern, the listening window should be long enough to contain most of the answers. The formula below gives the length of the listening window, for a case where the number of collisions between the neighbors' answers is minimized.",{"@attributes":{"id":"p-0466","num":"0499"},"maths":{"@attributes":{"id":"MATH-US-00018","num":"00018"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Listening_Window","_Length"],"mo":["\u2062","\u2062"],"mrow":{"mo":["(",")"],"mi":"seconds"}},{"mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mi":["Max_Nb","_of","_Neighbors"],"mo":["\u2062","\u2062"]},{"mi":["Nb_of","_Sub","_TS"],"mo":["\u2062","\u2062"]}]}},"mo":"*","mi":"TS_Length"}],"mo":"="}}}},"MAC_Max_Nb_of_Neighbors=100 EPs","MAC_Nb_of_Sub_TS=6 Sub_TS","MAC_TS_Length=150 ms","\u2192MAC_Listening_Window_Length=2.5 seconds or 17 TS","Present  represents a Discovering phase example with basic frequency hopping sequence number 0 for an embodiment operative in PHY-FHSS-NA-915.","During the listening state, information on all the neighbors that have answered, and mainly synchronization information (address, level, time, channel, cell address, GPD, and RSSI), is saved in the neighbor table of the endpoint. At the end of the listening state, if there is no answer, the next discovery phase is started after a random time (see below). The channel of the first beacon of this new discovery phase is the next one, in the hopping sequence, after the one used in the previous listening window. This process is repeated with a period of MAC_Min_Discovery_Phase_Period modulated by a random time (maximum default value is 100 ms) to avoid repetitive collisions between non-synchronized endpoints. Between the end of the listening window and the start of the new discovery phase, the endpoint can stay in listening mode. This process stops at the end of a listening period if the endpoint has received at least one answer from a potential SYNC father (if it is a warm start then this answer must come from its preferred cell; see present discussion about warm vs. cold start).","In the situation that an endpoint doesn't succeed to synchronize with one cell after MAC_Max_Nb_of_Discovery_Phases discovery phases, the period of discovery phases will be increased from MAC_Min_Discovery_Phase_Period to MAC_Max_Discovery_Phase_Period. This will prevent an orphan from polluting the RF band with useless messages. The period will be reset to its initial value if the endpoint succeeds to synchronize.","At the end of the listening window, if at least one valid answer has been received, the EP goes into the next step. An answer or data message from a neighbor will be considered as valid for synchronization purpose if it meets the potential SYNC father conditions. It can be pointed out that non-synchronized endpoints, non-registered endpoints (RS=0), endpoints of level 63, non-connected endpoints (CD=0) or endpoints from a full cell (CSI=max value) are not allowed to send forced beacons. But there is a chance that an endpoint in discovery phase hears a message intended for another endpoint, in which case it should check the potential SYNC father conditions.","The next step for this endpoint that tries to become synchronized is to choose the best access to the network. For this selection the endpoint will consider all neighbors it has received an answer from or overheard a packet from, unless they were discarded for the aforementioned reasons. Among these neighbors, it will choose the best access using a criterion based on the following principles:\n\n","The level of a neighbor, as well as its CSI, is indicated in the MAC header. The EP_GPD values, on the other hand, need to be computed. Mathematically, EP_GPD=GPD of the neighbor (as reported in its MAC header)+LPD+MAC_GPD_TD.","The Local Propagation Delay (LPD) of a neighbor is usually computed from the track record of past communication attempts with that neighbor. This algorithm is explained in a dedicated chapter. During the discovery phase, computing a LPD is however impossible because the endpoint has not yet exchanged enough messages with the neighbor to gather statistically relevant information. In this case an estimation of the LPD based on the RSSI reading is used.","In order to make a selection based on a combination of the principles mentioned above, we introduce a term to characterize the ability of a neighbor to act as a suitable synchronization source.\n\nSYNC_Disc_Merit=EP_GPD*MAC_SYNC_Disc_Weight_GPD+MAC_SYNC_Disc_Weight_Level*LVL+MAC_SYNC_Disc_Weight_CSI*CSI\n","There are defined three MAC layer parameters, MAC_SYNC_Disc_Weight_GPD, MAC_SYNC_Disc_Weight_Level and MAC_SYNC_Disc_Weight_CSI. The values of these parameters will depend on the importance one wants to give to the GPD, level or to the cell size in the selection process. If one sets the last two parameters to zero, only the GPD will be used to select the synchronization point.","The selection process for the best access can be summarized as follows:\n\n","The table of present  gives an example for the use of the term with three neighbors and MAC_SYNCDisc_Weight_GPD=1, MAC_SYNC_Disc_Weight_Level=50. In this example the preferred neighbor is the third one.","The foregoing discussion described the mechanism for a cold start, i.e. the non-synchronized endpoint had no prior knowledge of the network. When an endpoint which is already synchronized and registered with a cell experiences a power outage and is then powered on again, it can use its knowledge of the network to recover more quickly its state from before the power outage. This process is called a warm start.","For a warm start, there will be a notion of preferred cell at the MAC layer level. The preferred cell is the one the endpoint was registered with before the power outage. At first, the endpoint will consider itself already registered (RS bit set to 1) and try to connect only to its previous cell. If after a number of discovery phases (defined by Warm_Start_Discovery_Duration) it has not managed to do so, it will consider the other cells and restart the discovery phase without preferred cell as in cold start.","During the warm start, the discovery beacons contain the address of the cell that the endpoint wants to synchronize with. This is to prevent endpoints belonging to other cells from sending forced beacons and flooding the link at each discovery phase for nothing. This field is set to 0 during cold start.","It is very important that the selected neighbor checks its own connectivity to the network before acknowledging a SYNC request. Before acknowledging a SYNC Request an endpoint must check if it has received a recent message from a healthy father during the last MAC_SYNC_Father_Request_Beacon_Threshold time slots. If it is not the case, it should request a beacon from the healthy father with the best LPD:\n\nMAC_SYNC_Father_Request_Beacon_Threshold\u2266Beacon_Periodicity_SYNC\n","Upon reception of a SYNC Request an endpoint will either answer with a SYNC ACK (or SYNC NACK) or send a beacon request to one of its healthy fathers if it has not received any recent message from any of them. In this last case the endpoint doesn't answer the synchronization request immediately but waits for the neighbor to retransmit its request. By the time the same neighbor requests again synchronization, the endpoint should be able to accept the request because it will have received a recent messages from one of its own healthy fathers. In this case the endpoint will send a SYNC ACK.","The endpoint which has received the synchronization request needs either to send the synchronization acknowledgment or to request a beacon in the time slot following the SYNC Request reception.","The father which has been requested to send a beacon, has to send it in one of the next time slots following the reception of the beacon request, before MAC_SYNC_Request_Period time slots have elapsed. If this node has already planned to send another message (that has the same header information as a beacon) in this window, it doesn't need to send a beacon.","The endpoint which has been asked for synchronization will send a SYNC NACK in the following cases:\n\n","Upon reception of a SYNC NACK from a neighbor, its Sync_Forbidden bit should be set to 1, which prevents further synchronization requests from being sent to this neighbor. Between successive discovery phases, the neighbor table should not be cleared in order to retain this information.","The forbidden bit associated with a neighbor should be cleared to 0 if the node notices a change in these parameters:\n\n","The forbidden bit of all the neighbors in the table should be cleared to 0 if:\n\n","A complete synchronization example is provided with reference to present . EP6 is a new meter and it has three neighbors on two different cells. EP4 is the best endpoint to synchronize with. In this example, there are only seven different channels.","If the only SYNC father requests synchronization from one of its son, the son has to refuse immediately. The son should also realize that it has lost its synchronization. A meter, which has refused a synchronization, has to be marked (Sync_Forbidden=1) not to be asked later again. If the properties of this meter change (level, cell, power up), the mark is removed.","The present protocol subject matter advantageously provides for Beacon Requests and RS bit resolving to avoid circular routes. Such subject matter primarily applies to the environment of a tree network where the nodes are organized in cells with a concentrator (or root node) at the \u201chead\u201d of each cell. Each node has a level associated with its place in the cell. As otherwise referenced herein, the root node is level 1 and is always synchronized (by definition). In order to get its data to the root node a node must be synchronized in the corresponding cell.","Stated another way, the present synchronization process requires a hand check between one synchronized node and another node. A node which synchronizes on another becomes its son and the other node becomes the father of the first one. The new node level is one more than the one of its father. Therefore, all nodes have a level above 1. Nodes of the same level are called brothers. The group of fathers, brothers and sons of a node are called its neighbors. Each node keeps a table of its neighbors.","The problem successfully addressed by the present subject matter relates to when a node (node1) looses its synchronization and asks one of its brothers or sons for synchronization. If one of these nodes (for example, node 2) accepts to give synchronization to node1, then it changes level (level of node2+1). After that, another node (for example, node 3) which had node1 as father can realize it is no longer the case (since level of node1 is now over its own level) and can try to find a new father to which to synchronize. Specifically, it can ask node1, which will accept. If node 3 was the father of node 2, it will start finding a new father. Left on its own, such process can become an endless loop with nodes asking synchronization to one another without a real path to the concentrator (and thus without being actually synchronized). The main part of this problem is the delay between the new state of a node and the time its neighbors realize it.","The solution of the present subject matter is based on Synchronization information, which is present in all messages; Beacons (which are packets with only the synchronization information); and based on beacon requests (which are packets requesting a beacon from a neighbor).","One of the main parts of information for synchronization takes the form of one bit (the RS bit) which indicates if a node still has fathers (that is, the RS bit set to 1) or not. This bit is present in all packets because this information must be updated as fast as possible and thus must make use of any communication. A node will accept to give synchronization only if it has received a relatively recent message from a father (with an RS bit set to 1).","When a node receives a synchronization request (SYNC_REQUEST), it will check if it has received a recent message from one of its fathers (with RS bit set to 1). If it finds such a father then it accepts to give synchronization (SYNC_ACK). Otherwise, it sends a Beacon Request to one of its fathers with the RS bit set to one. This father will send a beacon with all its synchronization information (including RS bit) in response. The node asking for synchronization will repeat its demand and this time the node receiving the request should have received the beacon and should be able to send a synchronization acknowledgement (SYNC_ACK). If a node, has no father with RS bit set to 1 it will refuse synchronization (SYNC_NACK).","The beacon request allows nodes to refresh the information of their neighbors when they consider it is not recent enough, especially in the case another node asked them synchronization (they must be sure to still have a good connectivity before accepting). Such present solution advantageously provides a relatively fast way to propagate the synchronization information between nodes, thereby avoiding that they create a virtual circular net without an actual root. The beacon request helps refresh the knowledge of a node on its neighbors if the information is considered too old.","Present  illustrates a configuration example while present  represents a Synchronization process, both relative to a complete synchronization example per the present protocol subject matter. With further reference to present , EP6 is a new meter and it has 3 neighbors on two different cells. EP4 is the best EP to synchronize with (best level, best GPD). In this example, there are only 7 different channels.","EP6, at power up, is level 0, not synchronized, and enters into its discovery phase. It sends successively beacons on the 7 channels, and its 3 neighbors receive each one a beacon, because time and frequency match at one lucky moment. After sending all the beacons, EP 6 enters in a listening state at a frequency that it has indicated in the former beacons. The 3 neighbors react to this stimulus by sending a \u201cforced\u201d beacon a few (random) time slots later at the required frequency. EP 6, which listens on the green channel receives these beacons and saves synchronization information. It should be noted that during this listening phase, EP3 can intercept messages from other EPs. Due to operation of the MAC header, EP3 would be able to save their synchronization information as it does with its 3 current neighbors.","At the end of this listening phase, it is time for synchronization. Accordingly, EP6 adjusts its time slots on EP4, and requests synchronization. EP4 checks that it still has a connection with the cell relay 1, its Sync father, by requesting a beacon, and as soon it receives the beacon, sends a SYNC ACK to EP6. EP6 becomes synchronized and becomes level 3 in the cell number 1.","Note that EPs numbers 3, 4, and 5 have broken their channel sequences during 1 TS to send a forced beacon on the green channel. It is not an issue because if another EP has heard them at this moment it would have read, in the header, the channel that would have be used (CELL address, and TS number). The fact that it is another channel that has been chosen is transparent for the MAC Layer.","Present  represents one example of an Initial Configuration, and present  represents an example of a new endpoint, both illustrative of circumstances of one endpoint finding a better endpoint for communication purposes, per present subject matter as further discussed herein.","Each endpoint should indicate in the MAC neighbor table which one of its fathers has sent the SYNC ACK to grant synchronization rights. The SYNC Father flag serves this purpose.","It may happen that the communication of a node with its SYNC father or the characteristics of the SYNC father deteriorates to the point that a new SYNC father needs to be found. Two cases need to be considered.\n\n","In this case a SYNC father selection process is immediately triggered. It can be noted that the selection process can lead to the same father as before, the selection being made according to the potential SYNC father criteria and the subject term.","If a node changes its level after the selection of a new SYNC father, then all flags should be removed except the last one set (for the father that just sent the SYNC ACK and allowed the endpoint to change its level). An endpoint should have only one father with the SYNC Father flag set. In this case the endpoint is considered synchronized. Note that a father that is not good for synchronization can still be used for routing messages (if it is still a father).","In order to compare the relative worth of neighboring endpoints as synchronization fathers, we consider a term regarding SYNC_Merit, which is defined by SYNC_Merit=EP_GPD+SYNC_Penalty_LPD+SYNC_Penalty_RXI+SYNC_Penalty_CD","This term is only computed for the neighbors that are potential SYNC fathers (see potential SYNC father conditions). The main component of this term is the EP_GPD. Additional terms are introduced to decrease the probability of choosing some neighbors that may be less suitable as synchronization fathers. The SYNC_Penalty_LPD term is necessary because the LPD has a finite range. When the LPD of a neighbor is truncated to its maximum value, LPD_Max, the actual propagation delay is not known and a constant is added to the term to take into account the risk of selecting that neighbor as a SYNC father. The SYNC_Penalty_LPD term is defined by:",{"@attributes":{"id":"p-0509","num":"0570"},"maths":{"@attributes":{"id":"MATH-US-00019","num":"00019"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["SYNC_Penalty","_LPD"],"mo":"\u2062"},{"mo":"{","mtable":{"mtr":[{"mtd":[{"mn":"0"},{"mrow":{"mrow":{"mi":["if","LPD"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":"<","mi":"LPD_Max"}}]},{"mtd":[{"mrow":{"mi":"SP_LPD","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},{"mrow":{"mrow":[{"mi":["if","LPD"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mrow":[{"mi":["LPD_Max","AND","RSSI"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"mstyle":[{"mtext":"-"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mo":["\u2062","\u2062","\u2062"],"mn":"80","mi":"dBm"}],"mo":">"}],"mo":"="}}]},{"mtd":[{"mrow":{"mi":"SP_LPD","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}},{"mrow":{"mrow":[{"mi":["if","LPD"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mrow":[{"mi":["LPD_Max","AND","dBm"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"-"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mn":"100"},{"mstyle":[{"mtext":"-"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mo":["\u2062","\u2062","\u2062"],"mn":"80","mi":"dBm"}],"mo":["\u2264","\u2264"],"mi":"RSSI"}],"mo":"="}}]},{"mtd":[{"mrow":{"mi":"SP_LPD","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"3"}},{"mrow":{"mrow":[{"mi":["if","LPD"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mrow":[{"mi":["LPD_Max","AND","RSSI"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"mstyle":[{"mtext":"-"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mo":["\u2062","\u2062","\u2062"],"mn":"100","mi":"dBm"}],"mo":"<"}],"mo":"="}}]}]}}],"mo":"="}}}},"The SYNC_Penalty_RXI term is necessary to avoid selecting as SYNC father an endpoint whose reception rate indicator is too low, it is defined by:",{"@attributes":{"id":"p-0511","num":"0572"},"maths":{"@attributes":{"id":"MATH-US-00020","num":"00020"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["SYNC_Penalty","_RXI"],"mo":"\u2062"},{"mo":"{","mtable":{"mtr":[{"mtd":[{"mn":"0"},{"mrow":{"mrow":{"mi":["if","RXI"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":"\u2265","mi":"RXI_Threshold"}}]},{"mtd":[{"mrow":{"mi":"SP_RXI","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},{"mrow":{"mrow":[{"mi":["if","RXI"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mi":["RXI_Threshold","AND","RSSI"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"mstyle":[{"mtext":"-"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mo":["\u2062","\u2062","\u2062"],"mn":"100","mi":"dBm"}],"mo":["<","\u2265"]}}]},{"mtd":[{"mrow":{"mi":"SP_RXI","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}},{"mrow":{"mrow":[{"mi":["if","RXI"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mi":["RXI_Threshold","AND","RSSI"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"mstyle":[{"mtext":"-"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mo":["\u2062","\u2062","\u2062"],"mn":"100","mi":"dBm"}],"mo":["<","<"]}}]}]}}],"mo":"="}}}},"The SYNC_Penalty_CD term introduces a preference for neighbors that have a better connectivity degree with the purpose of making the network more stable and reliable, it is defined by:",{"@attributes":{"id":"p-0513","num":"0574"},"maths":{"@attributes":{"id":"MATH-US-00021","num":"00021"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["SYNC_Penalty","_CD"],"mo":"\u2062"},{"mo":"{","mtable":{"mtr":[{"mtd":[{"mi":"\u221e"},{"mrow":{"mrow":{"mi":["if","CD"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":"=","mn":"0"}}]},{"mtd":[{"mi":"SP_CD1"},{"mrow":{"mrow":{"mi":["if","CD"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":"=","mn":"1"}}]},{"mtd":[{"mn":"0"},{"mrow":{"mrow":{"mi":["if","CD"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":"\u2265","mn":"2"}}]}]}}],"mo":"="}}}},"The case CD=0 has been mentioned here for the sake of clarity. A neighbor with CD=0 is not, by definition, a potential SYNC father and the term will never be computed in that case.","Periodically, an endpoint will run the new SYNC father selection process to see if a better SYNC father has become available. These periodic selection processes should occur about once every hyperframe. They will be implemented in such a way that different endpoints in a cell will run the process at different times, thus avoiding too many endpoints sending a SYNC request at the same time. A random time slot number could be used for this purpose. On the other hand, when an endpoint loses its SYNC father, it should immediately begin the selection process for a new one. The selection process for this new SYNC father is described below.","The neighbor table will be analyzed to sort out the neighbors that match the potential SYNC father conditions. If endpoints belonging to other cells appear in this list, they should be removed from the list. Endpoints from other cells, when they are overheard, are dealt with according to the cell switching decision process described in this document. The term SYNC_Merit will then be computed for all the potential SYNC fathers in the list. The neighbor with the best SYNC_Merit (lowest value) is called here X. The neighbor which had the best SYNC_Merit at the time of the previous selection process is called XP. If X is different from XP, a counter, SYNC_Top, is initialized to zero. If X is identical to XP, the counter SYNC_Top is incremented. If a neighbor manages to stay at the top of the potential SYNC father list for SYNC_Top_N hyperframes or more, it is entitled to become the new SYNC father provided that this change brings an improvement of SYNC_Merit larger than SYNC_Merit_Hyst1. At any rate, if choosing X as the new SYNC father brings an improvement in term greater than SYNC_Merit_Hyst2, the endpoint should select X as the new SYNC father. A detailed step-by-step description of this selection process is given below.\n\n",{"@attributes":{"id":"p-0517","num":"0579"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"If this list is empty, then"]},{"entry":[{},"Discard all pending MAC messages and go into discovery phase"]},{"entry":[{},"Else if the list contains at least one potential SYNC father"]},{"entry":[{},"Go to step 2"]},{"entry":[{},"End if"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0043","list-style":"none"},"li":{"@attributes":{"id":"ul0043-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0044","list-style":"none"},"li":["Step 2: Compute the term, SYNC_Merit, for each potential SYNC father.","Step 3: The potential SYNC father with the lowest SYNC_Merit value is identified (X). If the endpoint has lost its SYNC father, then","Step 4: Select X as the new SYNC father (lowest SYNC_Merit). Go to step 7.\n\nIf the endpoint still has its SYNC father, then\n","Step 5: SYNC father selection with temporal hysteresis according to the following algorithm:"]}}}},{"@attributes":{"id":"p-0518","num":"0584"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003\u2003If X \u2260 XP, then"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003SYNC_Top = 0"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003XP = X"]},{"entry":[{},"\u2003\u2003\u2003\u2003Else if X = XP, then"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003SYNC_Top \u2190 SYNC_Top +1"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003Comment: SYNC_Top is only incremented once"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003every hyperframe."]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003If {[SYNC_Top \u2267 SYNC_Top_N] AND"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003[SYNC_Merit(X) + SYNC_Merit_Hyst1 \u2266"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003SYNC_Merit(SYNC father)]},"]},{"entry":[{},"then"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003X is selected as new SYNC father"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Go to step 7"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003Else"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Keep the former SYNC father"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003End if"]},{"entry":[{},"\u2003\u2003End if"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0045","list-style":"none"},"li":{"@attributes":{"id":"ul0045-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0046","list-style":"none"},"li":"Step 6: Look for a better SYNC father with the algorithm"}}}},{"@attributes":{"id":"p-0519","num":"0586"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"If SYNC_Merit(X) + SYNC_Merit_Hyst2 \u2266 SYNC_Merit(SYNC"},{"entry":"father), then"},{"entry":"\u2003\u2003Select X as new SYNC father"},{"entry":"Else, keep the former SYNC father"},{"entry":"End if"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"ul":{"@attributes":{"id":"ul0047","list-style":"none"},"li":{"@attributes":{"id":"ul0047-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0048","list-style":"none"},"li":"Step 7: If a new SYNC father has been selected, send a SYNC request to X and wait for acknowledgement (SYNC requests are detailed in another part of this document)."}}}},{"@attributes":{"id":"p-0520","num":"0588"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"If the request is positively acknowledged, then"},{"entry":"\u2003\u2003Stop (process completed)"},{"entry":"\u2003\u2003Else if the request is not positively acknowledged (negatively"},{"entry":"acknowledged or not acknowledged at all) and the endpoint has a valid"},{"entry":"SYNC father"},{"entry":"\u2003\u2003\u2003\u2003Abort the process"},{"entry":"\u2003\u2003Else if the request is not positively acknowledged and the endpoint"},{"entry":"has no more SYNC father"},{"entry":"\u2003\u2003\u2003\u2003Go to step 1"},{"entry":"\u2003\u2003End if"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"During step 7, if the endpoint decides to synchronize with a new father, it should:","Keep its MAC synchronization","Keep its level (in its header)","Refuse any synchronization request: send SYNC NACK","Refuse any message: send NACK (see traffic management)","Indicate in its messages that it is no longer synchronized by setting the RS bit to zero.","Many Cell Masters (relays) can coexist in the field. These Cell Masters can be part of the same network or they can belong to different networks or to different utilities. Affiliation of an endpoint to a network is indicated by the UID field in the MAC header and by the SFD value in the PHY header. An endpoint will never move to another network but it can switch to another cell belonging to the same network. A utility can install additional Cell Masters in some areas in order to increase the data throughput capability or to unburden a large cell. Additional Cell Masters will also provide alternative routing paths that will contribute to the quality of service. To allow the traffic to be spread evenly across the available cells an endpoint which is already connected to a cell should have the possibility to switch to another cell, with or without external intervention.","The method of manually asking a meter to switch to another cell is very simple, if one of the endpoint belonging to the new cell is within radio range. The user should only send a message to the endpoint that tells it that its current cell is now forbidden and that the new one is preferred. Then the endpoint will enter in a discovery phase to look for the other cell and then synchronize with it.","An endpoint should also be able to switch to another cell automatically if it considers that it will have a better position in the new cell, and therefore a better access to the WAN. This switching has to be done with some precaution, because it can perturb an entire branch of the network. For this reason, the conditions to change to another cell should be stringent, particularly if everything works properly in the current one.","Before switching to another cell, an endpoint should of course know that at least one representative of this other cell is in the neighborhood. As the physical layer is, by default, in listening mode, it happens from time to time that an endpoint receives a message from another cell. Indeed even if the hopping sequences are not the same, they are never totally orthogonal because they use the same set of channels and they are not synchronized with the same time base. Occasionally, an endpoint will transmit a message when the channels of both cells are aligned, if some endpoints belonging to the other cell are within radio range, they will hear the message. With only one message overheard from an adjacent cell, due to the parameters contained in the MAC header, an endpoint will have all the information to switch to that adjacent cell.","If the endpoint judges that the adjacent cell doesn't provide a better access to the network, it will discard the information. If this access is better, the endpoint can choose to resynchronize with the adjacent cell.","The criterion to declare that an endpoint from another cell is a better access to the network is based on several parameters:\n\n","In order to make a selection based on a combination of the principles mentioned above, we introduce a term to compare cells with each other.\n\nCELL_Merit=MAC_CELL_Weight_GPD EP_GPD+MAC_CELL_Weight_Level*LVL++MAC_CELL_Weight_CSI*CSI\n","There are here defined three MAC layer parameters, MAC_CELL_Weight_GPD, MAC_CELL_Weight_Level and MAC_CELL_Weight_CSI. The values of these parameters will depend on the importance one wants to give to GPD, to the level or to the cell size in the cell switching decision process. If one sets the last two parameters to zero, only the GPD will be used to compare cells. Upon overhearing a message from an adjacent cell the endpoint will compute the term, CELL_Merit for the new cell and also for its current cell. The condition for cell switching is: CELL_Merit (new cell)<CELL_Merit (current cell)\u2212MAC_CELL_Switch_Hysteresis, where we have introduced a new MAC layer parameter, MAC_CELL_Switch_Hysteresis, whose role is to prevent a node from continuously switching back and forth between two cells. Once the endpoint has determined that the new cell is better than the current one it has to make sure that it will be accepted by the new cell before actually switching. For this purpose the endpoint will ask the endpoint from the other cell for synchronization. The SYNC Request and the SYNC (N)ACK will be exchanged as is done in other situations except that the endpoint needs to adjust its frequency and time of transmission considering the other cell operates on a different hopping sequence.","Once the new father of the endpoint that leaves the cell answers a SYNC ACK, the MAC layer needs to inform the layer above and stays in its old cell during MAC_CELL_Leaving_Process_Duration seconds before definitely leaves it. At that point, the different layers need to free their buffers and their pending actions. After the switch is done, the MAC layer informs the layer above again. This timing is necessary for the NET layer to deregister by sending a NET Cell Leaving Notification message.","An example of a complete process of cell switching is as follows:\n\n","During this process, until the SYNC acknowledgement is received and during the transition period, the endpoint should deal with its usual communication activities in its current cell.\n\n","Yet another aspect of the present protocol subject matter advantageously relates to a feedback control loop that may be used to correct imperfections of crystal clocks, and to maintain synchronization in a frequency hopping spread spectrum (FHSS) mesh network.","As otherwise discussed herein, the present protocol is based on frequency hopping spread spectrum (FHSS) for better interference immunity and to be in compliance with the radio regulations in some countries. In a FHSS system per the present subject matter, all the nodes hop their channel frequency according to the same pseudo-random sequence in order to be perfectly synchronized for both reception and transmission. The performance of such a system is based on the ability for each node to be able to maintain such form of synchronization over time. That is the reason why the node hardware requires a crystal time reference with good stability. Because such time references are expensive, it is useful to implement a software driven compensation mechanism to improve the time stability of the nodes.","In the present exemplary network, as otherwise discussed herein, a mesh-like structure is provided wherein the cell relay is the root of the mesh and the metronome of the network. As a rule, such timing information propagated away from the root to the cell nodes. In the present protocol subject matter, each time a node communicates with another node closer to the root, it will realign its clock to be in synchronization with the network. In addition, all such consecutive clock corrections advantageously are time averaged, filtered, and processed to give information about how fast the node's clock is running with respect to the average clock of the nodes closer to the root. Such present feature allows a software correction of the node's clock rhythm that will bring it in tune with the network for a long period of time. Therefore, generally speaking, the present subject matter provides benefits of allowing the usage of relatively low cost crystals in the network nodes but with increased time stability of the network.","More specifically, present  illustrates a typical distribution of resynchronizations and crystal drift corrections in time, per the present subject matter.","As otherwise referenced herein, good synchronization is the basis of the present protocol, wherefore an inherent limitation to that aspect would otherwise come mainly from the crystal accuracy. In order to limit the traffic and to avoid internal collisions, as few synchronization beacons as possible are sent. However, as a result, in low traffic conditions, the number of opportunities to resynchronize the clock with a father will therefore be relatively small. As a consequence, each endpoint would generally have a clock shift with the upper level. For relatively larger level numbers, such shift would become significant relative to the cell relay clock. This could lead to a loss of synchronization if the shift were allowed to grow above some limit. Moreover, as an endpoint can resynchronize its clock with several father endpoints, an averaging mechanism could be advantageously utilized.","One approach of the present subject matter as a solution is to anticipate the drift of the local crystal oscillator with respect to the father clocks. If such drift is assumed to be constant (shown to be a good assumption if the temperature doesn't change too quickly), an efficient compensation procedure can be implemented. Therefore, rather than waiting for the next resynchronization, the endpoint can adjust its time slot length to decrease the next clock resynchronization value. The compensation algorithm uses low-pass filtering to cope with multiple synchronization paths and to avoid instabilities. The detailed description of such algorithm is otherwise discussed herein.","Whenever the receiver resynchronizes its local clock, two values are recorded: the value of the correction, which is Clock_Correction(k), and the time of this resynchronization, which is Resync_Time(k). This time is given by the value of the system real-time-clock at the moment of the resynchronization. The parameter k is used here to number the successive resynchronization occurrences. From these two values and with the knowledge of the previous resynchronization time, it is theoretically possible to evaluate the relative drift of the local crystal oscillator, Xdrift. To be useful for the purpose of crystal drift compensation, these evaluations must be accurate.","Each clock correction value can be considered to be the result of two contributions. The first one is a slow drift due to a difference between the local crystal frequency and the average crystal frequency in the father endpoints. The second contribution is a random time shift occurring each time a packet travel time is estimated. This is summarized in the following equation:\n\nClock_Correction()=drift[Resync_Time()\u2212Resync_Time(1)]++\u03b4()\u2212\u03b4(1)\n","where \u03b4t(k) is a random error due to the uncertainty in the propagation time of the packet from the transmitter MAC layer to the receiver MAC layer when resynchronization number k is performed.","To reduce the contribution of random errors, successive clock corrections are preferably summed, as follows:\n\nClock_Correction()+Clock_Correction(1)==drift[Resync_Time(1)\u2212Resync_Time(1)]+\u03b4(1)\u2212\u03b4(1)\n","It is readily understood per the present disclosure that, in the evaluation of the crystal drift, the contribution of these random errors will become increasingly smaller as successive clock corrections are summed, as follows:",{"@attributes":{"id":"p-0549","num":"0635"},"maths":{"@attributes":{"id":"MATH-US-00022","num":"00022"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"Xdrift","mo":"=","mfrac":{"mrow":[{"mrow":[{"mo":["[","]"],"mrow":{"munderover":{"mo":"\u2211","mrow":[{"mi":["m","k"],"mo":"="},{"mi":["k","M"],"mo":"+"}]},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"Clock_Correction","mo":"\u2062","mrow":{"mo":["(",")"],"mi":"m"}}}},{"mi":"\u03b4","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"t","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["k","M"],"mo":"+"}}}},{"mi":"\u03b4","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"t","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"k","mo":"-","mn":"1"}}}}],"mo":["+","-"]},{"mrow":[{"mi":"Resync_Time","mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mi":["k","M"],"mo":"+"}}},{"mi":"Resync_Time","mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mi":"k","mo":"-","mn":"1"}}}],"mo":"-"}]}}}}},"For this reason, the successive clock correction values are summed up until they span a time larger than the minimum value specified by the MAC layer parameter MAC_Xdrift_Tmin. Once this time value is exceeded the crystal drift can be evaluated with the following:",{"@attributes":{"id":"p-0551","num":"0637"},"maths":{"@attributes":{"id":"MATH-US-00023","num":"00023"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"Xdrift","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},{"mfrac":{"mrow":[{"munderover":{"mo":"\u2211","mrow":[{"mi":"k","mo":"=","mrow":{"mrow":{"mi":"k","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}},"mo":"+","mn":"1"}},{"mi":"k","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}]},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"Clock_Correction","mo":"\u2062","mrow":{"mo":["(",")"],"mi":"k"}}},{"mrow":[{"mi":"Resync_Time","mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mi":"k","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}}},{"mi":"Resync_Time","mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mi":"k","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}}}}],"mo":"-"}]},"mo":"."}],"mo":"="}}}},"The summation range should respect the condition:\n\nResync_Time(())\u2212Resync_Time((1))>MAC_Xdrift_Tmin,\n","where MAC_Xdrift_Tmin is chosen large enough to have:",{"@attributes":{"id":"p-0554","num":"0640"},"maths":{"@attributes":{"id":"MATH-US-00024","num":"00024"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":[{"mn":"2","mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"max","mrow":{"mo":["\uf603","\uf604"],"mrow":{"mi":"\u03b4","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":"t","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"k"}}}}},{"mi":["MAC_Xdrift","_Tmin"],"mo":"\u2062"}]},"mo":"<","mrow":{"mi":"Xdrift_accuracy","mo":"."}}}}},"Xdrift_accuracy is the targeted accuracy of the algorithm (about 1 ppm). MAC_Xdrift_Tmin must also be much larger than the interval between two leap time slots (as otherwise discussed herein) in order for the time integration process to smooth out the crystal drift compensation glitches.","Present  represents in schematic format a local clock drift compensation algorithm for practice per the present protocol subject matter, while present  represents (also in schematic format) a low-pass filter for crystal drift correction, all in accordance with the present subject matter.","The herein referenced estimation regarding the reference drift will not be used directly to compensate for the crystal oscillator drift. In order to average over several synchronization sources and to get rid of the fluctuations, a low-pass filter (see present  representation) will be implemented. This low-pass filter is defined by:\n\ndrift_filt()=drift()+drift_filt(1),\n\nwhere Xdrift_filt(n) is the filtered crystal drift estimation and A, B are the filter coefficients that will be adjusted to obtain adequate averaging and to make the resultant feedback control loop stable enough. These two filter coefficients will have values given by the following MAC layer parameters:\n\n\u2261MACdrift_Filter\n\n\u2261MACdrift_Filter\n\nThe instantaneous length of the system time slot T(n) is defined, and such value can be expressed as the sum of the default time slot length and a small correction term:\n\n()=TS_Length+\u0394()\n\nThe instantaneous value of the time slot length is updated by:\n\n()=(1)(1+drift_filt()),\n\nAs the correction is expected to be very small, one can neglect the second order term. The simplified version is:\n\n()=(1)+TS_Length\u00d7drift_filt()\n\nIn practice, generally only the time slot length deviation needs to be computed:\n\n\u0394()=(1)+TS_Length\u00d7drift_filt()\u2212TS_Length\n\nThis can be expressed as a function of the previous deviation:\n\n\u0394()=\u0394(1)+TS_Length\u00d7drift_filt()\n","In order to make sure that the mathematical description of the algorithm represented by present  is well understood, the whole process is here summarized with pseudo-code.",{"@attributes":{"id":"p-0559","num":"0645"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"First initialization"},{"entry":"Xdrift_filt = 0"},{"entry":"Start_Time = first resynchronization time value"},{"entry":"Sum_Clock_Corr = 0"},{"entry":"Upon reception of a beacon or any valid message do"},{"entry":"\u2003\u2003Accumulate the clock correction"},{"entry":"\u2003\u2003Sum_Clock_Corr = Sum_Clock_Corr + Clock_Correction"},{"entry":"\u2003\u2003Update the time since the last crystal drift estimate"},{"entry":"Time_Since_Last_Xdrift_Update = Resync_Time \u2212 Start_Time"},{"entry":"\u2003\u2003If Time_Since_Last_Xdrift_Update < MAC_Xdrift_Tmin"},{"entry":"\u2003\u2003\u2003\u2003Then wait for next message"},{"entry":"\u2003\u2003\u2003\u2003Else do"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Compute the crystal drift"},{"entry":"Xdrift = Sum_Clock_Corr \/ Time_Since_Last_Xdrift_Update"},{"entry":"Filter the drift estimate"},{"entry":"Xdrift_filt=A * Xdrift + B * Xdrift_filt"},{"entry":"Update the time slot correction"},{"entry":"\u0394Tslot = \u0394Tslot + Xdrift_filt * TS_Length"},{"entry":"Initialize Start_Time for the next iteration"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Start_Time = last value of Resync_Time"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Initialize the clock correction accumulator for the next"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003iteration"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Sum_Clock_Corr = 0"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Wait for a new message"},{"entry":"\u2003\u2003End"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The accuracy required for proper crystal drift compensation is about 1 ppm. This will probably make a direct correction of the parameter MAC_TS_Length impossible, especially if the resolution of the SACT is not very high. Therefore, it is suggested, at the beginning of each time slot, to reload the countdown timer with the default time slot length value, MAC_TS_Length. Every MAC_Xdrift_LeapTS time slots, a \u201cleap time slot\u201d will be introduced. This is explained with the following pseudo-code:",{"@attributes":{"id":"p-0561","num":"0647"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"If Time_Slot_Number = 0 (modulo MAC_Xdrift_LeapTS)"]},{"entry":[{},"Then\u2002Count_Down_Timer \u2190 MAC_TS_Length +"]},{"entry":[{},"MAC_Xdrift_LeapTS * \u0394Tslot"]},{"entry":[{},"Else\u2003Count_Down_Timer \u2190 MAC_TS_Length"]},{"entry":[{},"End"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In the above code, Time_Slot_Number is a number starting from 0 and incremented at each time slot, it is not the time slot number used to identify the position within a hyperframe. It should be pointed out that for optimum crystal drift compensation, the above SACT reload should be performed with the full accuracy provided by the firmware, as specified by the parameter MAC_FW_Acccuracy. The resolution of the correction algorithm depends on the leap time slot interval as shown by the following equation:",{"@attributes":{"id":"p-0563","num":"0649"},"maths":{"@attributes":{"id":"MATH-US-00025","num":"00025"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":["Crystal","drift","correction","resolution"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":"=","mfrac":{"mrow":[{"mi":["LSB","of","SACT"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}}]},{"mi":["MAC_Xdrift","_LeapTS","MAC_TS","_Length"],"mo":["\u2062","*","\u2062"]}]}}}}},"A resolution better or equal to 1 ppm should be targeted. On the other hand, the leap time slot interval should be small enough to avoid clock corrections larger than the time slot margin. In satisfying such criteria, the following inequality should be respected:",{"@attributes":{"id":"p-0565","num":"0651"},"maths":{"@attributes":{"id":"MATH-US-00026","num":"00026"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":["MAC_Clock","_Accuracy"],"mo":["\u2062","\u2062"],"mrow":{"mo":"<<","mfrac":{"mrow":[{"mi":["MAC_TS","_Margin"],"mo":"\u2062"},{"mn":"2","mo":["*","\u2062","*","\u2062"],"mi":["MAC_Xdrift","_LeapTS","MAC_TS","_Length"]}]}}}}}},"Part of the advantages of the present protocol subject matter is the provision of a system which itself is based on a self management and optimization system of endpoints that is organized into cells. Each cell has a Cell relay which serves the purpose of relaying all the information to and from the network to another wide area network operating on a TCPIP protocol. Due to such fact, the assimilation of an endpoint to a given cell is uncontrolled and may grow unbounded. Of course, Cell relays have resource limitations and growing beyond certain limits will overload these resources.","The present particular aspect of the present subject matter is based on certain indicators of the cell size that is communicated to all endpoints in the cell. Endpoints that are joining the network and could have the possibility to join more than one cell will use this information in the decision process of which cell to join. If the indicators are that cell A is full or close to full, cell B will be chosen per present subject matter to synchronize with even if the indications are that cell A may be a much better cell for uploading network traffic.","Although cells operate in isolation due to the quasi orthogonal frequency hopping sequences, on rare occasion's traffic will be overheard from one cell to the other for the endpoints located on the touching boundaries. In these events, the cell size indicators can be used to drive a decision to migrate from a full cell to an empty or much less full cell. Accordingly, per present subject matter otherwise discussed herein, based on such present processes, the cell sizes will be managed and balanced over time, allowing self management and optimization to continue.","More particularly, present aspects of this subject matter are applicable for embodiments configured as a tree network where the nodes are organized in cells with a concentrator (or root node) at the \u201chead\u201d of each cell. As otherwise discussed herein, each node has a level associated with its place in the cell. The root node is level 1 and is always synchronized (by definition). In order to get its data to the root node a node must be synchronized in the corresponding cell. The synchronization process requires a hand check between one synchronized node and another node. A node which synchronizes on another becomes its son and the other node becomes the father of the first one. The new node level is one more than the one of its father. Therefore, all nodes have a level above 1. Nodes of the same level are called brothers. The group of fathers, brothers and sons of a node are called its neighbors.","Per present subject matter, each node keeps a table of its neighbors. The information on the neighbors is used for several purposes (synchronization, routing, and the like), including the transmission of broadcast packets. Effectively, the broadcast is actually a multicast message sent to all the sons of the node. It is thus important that each node is in the neighbor table of at least one of its fathers to insure the delivery of broadcast packets. This is one of the roles of the synchronization request: by sending a synchronization acknowledgement (SYNC_ACK), a father guarantees that its new son is in its neighbor table. Per present protocol, the father of a node which sent a SYNC_ACK is called the SYNC_FATHER of this node. The SYNC_FATHER is the only father which guarantees that the node is in its neighbor table, and thus the only father which guarantees it will send a broadcast to the node. A node must always have one SYNC_FATHER.","Whenever the memory of a node is limited, likewise so is its neighbor table. The technical problem becomes when the table is full and a new node requests synchronization. The synchronized node with the full table cannot acknowledge positively the synchronization request of the new node without inserting it in the table. Any such activity could lead to a node in the cell not receiving broadcasts (if it is not in the table of another father). Unfortunately, if the synchronization right is refused, then it could lead to an orphan node (not in a cell) not being able to deliver its data. In the same way, the \u201cfather\u201d node cannot make space for the new node by removing any of the neighbors in its table (because to do so could cause a node to not receive broadcasts).","The solution achieved by the present management protocol is primarily based on two things. First, a bit (EPSF for Enough Potential Sync Father) is sent in each packet and kept in the neighbor table for each neighbor. This bit is set to 1 by each node if the number of father and brothers in its neighbor table is above a given threshold (which is chosen to indicate that they could safely send a request to another node). The second part is the table out notification (TON) message. Based on the EPSF bit, a node receiving a new synchronization request while its neighbor table is full, can decide to remove one of its sons if this son's EPSF bit is one. But it must indicate to this son that it will no longer be in its neighbor table. Such is accomplished by sending the TON message to this son. Upon receiving this message, this son will look if this father was its SYNC_FATHER. If it was the case, then it must find another SYNC_FATHER to guarantee that it will be in the neighbor table of one of its fathers and thus receive broadcasts.","This solution provides a way to never refuse synchronization to a new node while making sure that all nodes are in the neighbor table of one of their fathers, and thus making sure that they will receive broadcast packets.","When it comes to neighborhood management and neighborhood information per the present protocol subject matter, the MAC layer is in charge of management vis-\u00e0-vis neighbors. Accordingly, each time an endpoint receives a message, it also saves or updates the parameter of the sender on a list. Therefore, per present subject matter, only 1-hop neighbor parameters are known and saved in the endpoint. The Cell relay is the only device that knows status of the endpoints belonging to its cell, but it is managed with the neighbor list in the network layer.","The MAC layer not only will manage its own neighbor table but will also indicate to the upper layers (particularly to the NET layer, by way of the LLC layer) some of the changes when they occur (for example, inclusion of a new neighbor).","The MAC Neighbor table contains parameters of the neighbors. It is limited in size by the variable Max_Nb_of_Neighbors. For each neighbor the parameters are:\n\n","Due to memory limitations, the neighbor table has a finite size and cannot contain more than Max_Nb_of_Neighbors entries. It is therefore necessary to get rid of some entries as they become useless for the operation of the network.","The neighbor table is managed according to the following general principles:\n\n","The process of freeing up space in the table can be further detailed as follows. It should be pointed out that this process is not carried out on an ongoing basis but only when a new potential SYNC father needs to be inserted in a table which is already full.\n\n","If an endpoint is not synchronized, any neighbor that match the potential SYNC father criterions can be added to its neighbor table. The relative importance of these entries will be defined according to the term for the discovery phase, SYNC_Disc_Merit.","If the endpoint is in a cold start process, only the neighbors belonging to the preferred cell will be allowed into the neighbor table. If the endpoint is in a warm start process, all potential SYNC fathers, whatever the cell they belong to, will be allowed into the table.","If an endpoint is synchronized, the importance of the entries is based on the synchronization term (SYNC_Merit). If a node needs to be taken out, the one with the highest SYNC_Merit should be removed. There is one exception to this rule: the SYNC father cannot be removed from the table. If a father needs to be removed when the SYNC father happens to have the worst SYNC_Merit, the next-to-worst should be removed.","The synchronization term depends, among other parameters, on the reception rate indicator, RXI. As newcomers have a low RXI, this will create a hysteresis for the inclusion of new neighbors in the table. This will limit the coming and going in the table.","In synchronized mode, nodes from other cells are not entered into the table. They are evaluated on the fly to check if they could offer a better synchronization point.","Present  also depicts in flowchart format present neighbor table management.","Endpoints have fixed MAC addresses and can potentially synchronize and connect to any cell. However, the protocol should take into account that some cells are forbidden. This can be the case if the user\/utility wants to control the repartition of endpoints in different cells, or merely if a user doesn't want to share its network with another user\/utility (this last case is normally handled by having different Utility IDs in the PHY header). In order to manage the membership of a cell, a Cell Address uniquely identifies each cell.","From the MAC layer standpoint, a node can be synchronized with any cell. It is therefore the role of the API layer to tell the MAC layer whether a cell is authorized or not. This information is then kept at the MAC layer level, which will not consider a forbidden cell for synchronization.","All the forbidden cells are re-authorized by the MAC layer if the endpoint stays non-synchronized for a period of time longer than MAC_Unsynchronized_Timeout.","In cold start, once the node is synchronized, it informs the API layer of this successful synchronization indicating the corresponding cell address. The API layer should then inform the MAC layer when the endpoint becomes registered. The MAC layer will not authorize other nodes to synchronize with itself if it is not registered. As soon a the node is registered, the MAC layer will save the cell address and use it as preferred cell in case of warm start.","In warm start, the node looks for its preferred cell. If it succeeds to find the cell and synchronize with one of its members, the MAC layer will consider itself already registered (RS bit=1), and will immediately authorize the synchronization requests of its neighbors. The API layer needs to tell the MAC layer whether this assumption was correct or not.","The warm start will accelerate the synchronization process of a cell after a large-scale power outage.","In general, per the present protocol subject matter, two kinds of messages are acknowledged: Monocast Data containing LPDU from LLC layer, and SYNC requests. Monocast Data are acknowledged (or not) with ACK (or NACK) messages and SYNC requests by SYNC ACK (or SYNC NACK) messages.","ACK, NACK, SYNC ACK and SYNC NACK must be sent in the time slot of the reception of the corresponding packet. More precisely, the acknowledgement should be sent in the last sub-time slot.","Each message that should be acknowledged has a MAC frame ID (FID), inserted in the MAC header. The (non-) acknowledgment message will mention this frame ID in its own MAC header. The MAC frame ID is a counter, incremented by the MAC layer at each sending of Monocast Data or SYNC request.","For each LPDU the LLC asked to send, the MAC layer will indicate back if the Monocast Data message has been acknowledged (ACK), non-acknowledged (NACK), or not acknowledged (neither ACK, nor NACK received).","The Broadcast Data messages are not acknowledged. They are not addressed to any node in particular and thus contain no destination address in their MAC header, or MAC frame ID. When the Broadcast Data message has been sent, the MAC layer will notify it to the LLC layer.","The present protocol subject matter advantageously uses a 32-bit CRC (Cyclic Redundancy Check) to avoid message corruption by either of noise or interference. The CRC is computed by the sender on the entire MAC header and LPDU and placed at the end of the frame. On the receiver side, the value of the CRC is used to verify the message validity. If the CRC matches the message, the frame is accepted. If it does not match, it is discarded.","The CRC used is the standard 32-bit IEEE 802.3 CRC. Present  provides a schematic representation of a typical CRC 32-bit implementation. The generator polynomial of such CRC is:\n\n()=1\n","The CRC is computed with a linear feedback shift register initialized to 0xFFFFFFFF (or any equivalent implementation). The computation begins with the first byte of the MAC header and ends with the last byte of the LPDU. Each byte is fed into the shift register with the least significant bit first. At the end of the polynomial division, the shift register contains the remainder of the division. The first byte to be shifted out of this register corresponds to the first redundancy byte. It is interpreted least significant bit first and should be complemented to one before being appended to the LPDU.","With reference to security, the present protocol subject matter preferably does not provide any encryption service. As such, the datagrams are preferably sent on the air interface without encryption. However, that is not to say that the present protocol subject matter is not a secure protocol. It is in fact a designed protocol, the physical layer for which uses a FHSS technique with a very long frequency-hopping pattern. Eavesdropping on such a system would require a significant engineering effort. This intrinsic security is further enhanced by the use of Fibonacci sequences to make the hopping pattern different in each cell.","Should such approach to security be considered insufficient for some critical applications, it is within the scope of the present subject matter to supplement such security by encrypting the user data in the applicative layers.","Certain advantageous aspects of the present subject matter relate to what may be regarded generally as network traffic regulation, or more specifically as network traffic load control. In particular, procedures are provided to avoid conditions under which the traffic load grows above a point of gridlock in a slotted Aloha mesh network. In certain aspects, the present procedures use the monitoring of received acknowledgements to evaluate the traffic density. At least several identifiable benefits of such present methodologies are that it allows the uplink traffic in a mesh network to flow in optimal conditions, and it avoids traffic gridlock due to operation of the network beyond its limit.","Per present subject matter, traffic load control is used to limit traffic in order to avoid using the channel beyond its optimal traffic density. This is necessary because the present protocol subject matter operates as a slotted Aloha system, and for such a system, traffic density above some limit can increase the collision rate to an unacceptable level and completely block the data flow (that is, data flow becomes gridlocked). The present traffic control preferably is used only for the upload traffic, from endpoints to the cell relay (or Cell Master).","More particularly, the present traffic load control subject matter is applicable to generally any mesh network with a node acting as a data extraction point. The data traffic from the individual nodes to this extraction point is regarded as the uplink traffic. As such uplink traffic generated in the network grows higher, internal collisions between packets will occur. At some point, such internal collisions will be frequent enough to degrade the effective throughput of the system. The relation between collision probability and effective throughput is well known from slotted Aloha theory. Textbook theory deals with the case where no external jammer is present. Here the situation is more difficult to analyze because there are both types of collisions at the same time, that is, internal collisions due to internal traffic, and external collisions with the other users of the band.","Accordingly, the present subject matter advantageously introduces a control mechanism to slow down the data traffic when it grows above some limit. The nodes need to be able to temporarily hold off transmissions and store messages in a buffer when they detect that the channel is too busy. This traffic load control will prevent the nodes from using the channel beyond its optimal traffic density. If this is not done, the traffic density can increase the collision rate to an unacceptable level that will not only decrease the performance but that may completely block the data flow.","Therefore, per the present subject matter, in order to control properly the traffic load, an endpoint needs to evaluate the amount of traffic going through the network. For present description purposes, a first node within the radio range of a second node and in the direction of the extraction point for the second node, will be called a father node relative to such second node. Present  is a schematic representation of the present subject matter traffic load monitoring, where a given node B is listening to the (N)ACK messages from its fathers A and C. For the afore-mentioned traffic load control purposes, an exemplary endpoint (node B in exemplary ) will record the acknowledgments transmitted by its fathers A and C and not intended for itself. Such acknowledgments will give enough information to assess the traffic load because in the present protocol, a node has to acknowledge all the data packets it receives. This approach is consistent with the fact that traffic management will be mainly used by the endpoints directly communicating with a cell relay, from which only acknowledgments are transmitted in an upload situation. However, such information is nevertheless not enough because a node needs to be able to distinguish between a low traffic situation that generates only a few acknowledgements and a very high traffic situation that also generates few acknowledgements because most of the packets are lost due to collisions. For this purpose, preferably each node will record all the communication attempts with the father nodes and will compute an average communication success rate. Combining both the rate of acknowledgments overheard and the communication success rate, a node will be able to estimate the traffic density in an unambiguous way.","In a formal way, one can define the traffic input density Ras the average number of data packets arriving at node A () in one time slot. This concept is useful to measure how busy is node A. It is also known from slotted Aloha theory that the traffic input density has an optimal value. If the traffic input density grows above that optimal value, the throughput goes down due to collisions. All the data packets arriving at node A are considered in the definition of traffic input density, whether they are successfully received or not. However, for practical reasons, packets emanating from node B are preferably excluded (since the focus is currently on trying to derive a behavior rule for such node B). Also defined are the average number of acknowledgments emanating form node A and overheard by node B (excluding those intended for node B) in one time slot, S. The communication success rate from node B to node A is called CSRand Qis defined as the probability for node B to be in listening state. From elementary probability theory it can be shown that the estimation for the traffic input density at node A is given by the following:",{"@attributes":{"id":"p-0608","num":"0720"},"maths":{"@attributes":{"id":"MATH-US-00027","num":"00027"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["R","A"]},"mo":"=","mfrac":{"msub":{"mi":["S","A"]},"mrow":{"msub":[{"mi":["CSR","BA"]},{"mi":["Q","B"]}],"mo":"\u2062"}}}}}},"To avoid overflowing a node with packets beyond the optimal traffic input density, the transmission rate of packets is limited per the present subject matter. For this, there is defined a maximum traffic input density, R. From slotted Aloha theory, this should be equal to one, but to be conservative by design, it is preferable to use a smaller value. The total traffic input density at node A is the sum of the estimated traffic density Rand the traffic that node B will generate for node A. Node B will modulate the traffic it generates for node A in order to prevent the total traffic input density at node A from exceeding the maximum allowed value R.","A straightforward way per present subject matter to implement this limitation is to send the messages at a random time within a randomization window of length T. The length of the randomization window should respect the following condition:",{"@attributes":{"id":"p-0611","num":"0723"},"maths":{"@attributes":{"id":"MATH-US-00028","num":"00028"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":{"mfrac":{"mn":"1","msub":{"mi":["T","W"]}},"mo":"+","msub":{"mi":["R","A"]}},"mo":"\u2264","msub":{"mi":["R","MAX"]}},"mo":","}}},"br":{},"sub":"W "},"Per present subject matter, if a node has several fathers, preferably it should size the length of its randomization window according to the father with the highest traffic input density, even if the packet is not intended for this father.","The following tasks preferably are performed in every node of the network. They are to monitor all acknowledgments overheard from the father nodes; to record all the communication successes\/failures with every father node; to keep a record of the time spent in transmission or listening state; to compute the probability for the receiver to be listening, Q; for every father node, to compute the communication success rate CSR and to compute the estimated traffic input density, R; and to slow down of hold off transmissions if the traffic input density for the busiest father becomes too large.","All such average variables (input traffic density, rate of overheard acknowledgments, communication success rate and probability for a node to be listening) can be computed with a sliding average algorithm to avoid using excessive microprocessor memory.","Referring to such subject matter in somewhat different terms, per present subject matter, a defined maximum traffic input density may be referred to as MAC_Traffic_Density_max, such that the total traffic input density at endpoint A, now including the traffic from B to A is given by:",{"@attributes":{"id":"p-0616","num":"0728"},"maths":{"@attributes":{"id":"MATH-US-00029","num":"00029"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mfrac":{"mn":"1","mi":"Tx_Window"},"mo":"+","msub":{"mi":["R","A"]}},{"mi":["MAC_Traffic","_Density","_max"],"mo":["\u2062","\u2062"]}],"mo":"="}}},"br":{}},{"@attributes":{"id":"p-0617","num":"0729"},"maths":{"@attributes":{"id":"MATH-US-00030","num":"00030"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"Tx_Window","mo":"=","mfrac":{"mn":"1","mrow":{"mrow":{"mi":["MAC_Traffic","_Density","_max"],"mo":["\u2062","\u2062"]},"mo":"-","msub":{"mi":["R","A"]}}}}}},"br":[{},{},{},{}],"sub":["A","ackA","BA","B ","BA ","B ","ackA "],"in-line-formulae":[{},{}]},{"@attributes":{"id":"p-0618","num":"0730"},"maths":{"@attributes":{"id":"MATH-US-00031","num":"00031"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"Tx_Window","mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":[{"mrow":{"mi":"round","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mi":"min","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mfrac":{"mn":"1","mrow":{"msub":[{"mi":["R","Amax"]},{"mi":["R","A"]}],"mo":"-"}},"mo":",","mrow":{"mi":["MAC_Tx","_Window","_max"],"mo":["\u2062","\u2062"]}}}}}}},{"mrow":{"mrow":{"mi":"if","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["R","A"]}},"mo":"<","msub":{"mi":["R","Amax"]}}}]},{"mtd":[{"mrow":{"mi":["MAC_Tx","_Window","_max"],"mo":["\u2062","\u2062"]}},{"mrow":{"mrow":{"mi":"if","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["R","A"]}},"mo":"\u2265","msub":{"mi":["R","Amax"]}}}]}]}}}}},"br":{},"sub":["Amax ","ackA","ackA "]},{"@attributes":{"id":"p-0619","num":"0731"},"maths":{"@attributes":{"id":"MATH-US-00032","num":"00032"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":["S","ackA"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},{"mrow":[{"mfrac":{"mrow":{"msub":{"mi":["N","TMW"]},"mo":"-","mn":"1"},"msub":{"mi":["N","TMW"]}},"mo":"\u2062","mrow":{"msub":{"mi":["S","ackA"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}}},{"mo":"{","mtable":{"mtr":[{"mtd":[{"mn":"0"},{"mrow":{"mi":["if","no","A","C","K","is","recieved","from","A"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"mo":["(",")"],"mi":"N"}}}]},{"mtd":[{"mfrac":{"mn":"1","msub":{"mi":["N","TMW"]}}},{"mrow":{"mi":["if","a","A","C","K","is","recieved","from","A"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"mo":["(",")"],"mi":"N"}}}]}]}}],"mo":"+"}],"mo":"="}}},"br":{},"sub":["TMW ","TMW ","B "]},{"@attributes":{"id":"p-0620","num":"0732"},"maths":{"@attributes":{"id":"MATH-US-00033","num":"00033"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":["Q","B"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},{"mrow":[{"mfrac":{"mrow":{"msub":{"mi":["N","TMW"]},"mo":"-","mn":"1"},"msub":{"mi":["N","TMW"]}},"mo":"\u2062","mrow":{"msub":{"mi":["Q","B"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}}},{"mo":"{","mtable":{"mtr":[{"mtd":[{"mn":"0"},{"mrow":{"mi":["if","endpoint","in","Tx","mode"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}]},{"mtd":[{"mfrac":{"mn":"1","msub":{"mi":["N","TMW"]}}},{"mrow":{"mi":["if","endpoint","in","Rx","mode"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}]}]}}],"mo":"+"}],"mo":"="}}}},"Of course, if an endpoint has several fathers, it should always size the length of its randomization window according to the father with the highest traffic input density, even if the packet is not intended for this father.","Due to hardware cost, the memory size to save messages will not be unlimited from a system point of view. Packets during their travel between endpoint and Cell Master are buffered into nodes. To avoid standing in front of irresolvable blocked traffic situations, when memory is full, packets storage should follow some important guidelines.","Packets storage should be divided into two categories:","Packets going uplink: Uplink, Broken Link, Outage Notification . . .","Packets going downlink: Downlink, Broadcast . . .","The number of packets belonging to each category should be monitored over time and is called nb_of_uplink_buffered_packets and nb_of_downlink_buffered_packets. There is a maximum number of packets that can be saved for each category.\n\nnb_of_uplink_buffered_packets\u2266MAC_Max_nb_of_uplink_buffered_packets\n\nnb_of_downlink_buffered_packets\u2266MAC_Max_nb_of_downlink_buffered_packets\n\nnb_of_uplink_buffered_packets+nb_of_downlink_buffered_packets\u2266memory size\n","To maintain this information it is necessary that the different layers indicate the category of the packet they send\/receive. As the Cell Master only receives uplink traffic and sends downlink traffic, these categories can be respectively compared to ingoing and outgoing buffered packets.","Once a buffer of either type is full, if a message of the corresponding type of is received, the MAC layer should respond to the sender with a NACK message and discard the packet as there is no place to save it.","For the Cell Master case, if the WAN connectivity is good, the uplink (ingoing) buffer should in theory never be full. Indeed the throughput of the WAN is highly superior to the Linknet one. If the uplink buffer happens to be full, the same algorithm is used and the Cell Master starts sending NACK to incoming packets. This situation will in counterpart highly degrade network performances and can bring about network instability and packets losses.","With respect to the following discussion points on the present scheduling of messages, it should be understood that in this context a message refers to any packet other than an acknowledgement. When the application layer requests it, or when there is a received message to forward, the NET layer determines the destination address(es). The LLC layer deals with the fragmentation and retransmission of messages. These two layers send requests to the MAC layer who adds the MAC header to the packets and send them to the physical layer for transmission.","Among these layers the MAC is in charge of scheduling in which time slot the message will be sent. The main objective of this scheduling is to randomize in time the transmissions in order to avoid collisions with neighbors' packets.","The MAC layer must not only schedule the data messages coming from the upper layers but also its own packets (acknowledgements, requests and beacons).","Messages can accept some delay in their transmission, while acknowledgements must be sent within the timeslot of the reception. These restrictions and the need for time randomization are the base for the packets scheduling process.","With reference to present priorities for messages, present  is a table that shows an exemplary message priority list in accordance with the present protocol subject matter. In general, there are two main kinds of packets the MAC layer must schedule: The ones coming from the upper layers (LPDU) and the ones generated by the MAC layer. The first category can be divided into two types, data and power outage notification, while the second category includes synchronization requests (SYNC RQST) and acknowledgements (SYNC ACK or SYNC NACK), other messages acknowledgement (ACK or NACK), beacons, beacon requests and discovery beacons. The data messages can have different MAC header depending of their nature (monocast, broadcast, broadcast ITP . . . ) but they will all be treated in the same way from a scheduling standpoint.","Some messages must be sent in priority; among all these messages, acknowledgements are the most important. A (N)ACK must be sent in the time slot the reception of the corresponding monocast message occurred; in the same way the SYNC (N)ACK must be sent in the same time slot as the corresponding SYNC RQST.","The MAC should normally not send more than one message in a given time slot, except several forced beacons if the hardware can handle it. In the rare case an EP would need to acknowledge more than one message or synchronization requests in the same time slot, then one should be sent and the other cancelled. The reason is that the EP who transmitted the initial message or request expects an acknowledgement in this time slot and considers the transmission a failure after that (it is thus useless to transmit a (N)ACK or SYNC (N)ACK after the current time slot). Although packets other than acknowledgements are initially randomized in a window, they are not absolutely restricted to it and can be postponed.","The requests are next in the priority list, with the SYNC RQST just before the RQST_Beacon.","All these packets are needed for the network to work properly and are thus higher in priority than the data to transport. The data is next on this list of priority, followed by the beacons (on a forced channel or not). These beacons are actually MAC headers used to give synchronization information. Since the same information is in all MAC headers, if any message is transmitted in the window where an unforced beacon is requested, this beacon does not need to be transmitted. Concerning the forced beacons, which are triggered by the reception of a discovery beacon, they need to be sent in the corresponding listening window, but only if there is a time slot available: including a new node to the network must not disturb the nodes already synchronized.","There are two exceptions that supersede the order of priority defined above: the first one is when an EP experiences a power outage, the API layer notifies it to the NET layer. This request changes the normal receiving mode into a passive, power saving mode interrupted by transmission of short outage notifications. If another EP receives one of these notifications, it will re-transmit it with a priority order of a normal data. The second case is during the discovery phase, where this order is meaningless since the MAC only transmits discovery beacons or listens for \u201cforced\u201d beacons.","Scheduling a message consists in deciding in which time slot it will be transmitted. There are several restrictions that apply to this task. First it must follow the priority rules described in the previous section; this priority is applied when two messages should be sent in the same time slot. Additional rules are needed to define this scheduling task.","As said above the acknowledgements are the highest priority and they also must be sent in the same time slot as the message or synchronization request that triggered them. The acknowledgements cannot be pushed in time as the messages can (all message can be postponed, excepted the forced beacons which have also a defined window but are of the lowest priority and can be cancelled to make place to any other packet if needed).","As a result of this first rule, if a message was scheduled in the same time slot as the reception of monocast data, then this message must be pushed by 1 time slot, to allow the MAC layer to acknowledge the received packet. Only acknowledgements can be sent in a time slot where a LPDU packet was received.","In order to not overload the network any LPDU and SYNC RQST must be randomized over time. The SYNC RQST randomization is done at the MAC layer and is discussed in another section.","Each time a packet is received from the LLC layer, the MAC layer adds it to a FIFO dedicated to data messages. If no data packet is being sent the MAC layer checks if there is a message in this FIFO. If it is the case then the transmission window is updated (see Traffic load control section) and a countdown timer is randomly determined. This timer is decremented at each time slot beginning and when it reaches zero the message is sent during the time slot.","There are several exceptions to this rule. If a higher priority message is already scheduled or an acknowledgement is expected then the message is left in the FIFO and the countdown timer set to expire for the next timeslot. On the contrary if a forced beacon was scheduled in the same time slot the data message is scheduled (and\/or in the next one for a monocast packet) then the forced beacon is cancelled.","The forced beacon should be sent in the listening window of the endpoint in discovery phase. It should be randomized in this window. If the time slot is already taken then the next time slot should be tested for availability, cycling to the beginning of the listening window if the end is reached. This procedure should continue until a space is found to transmit the forced beacon or the endpoint realizes that all time slots are already occupied, in which case it should cancel the forced beacon.","When a packet already scheduled is pushed in time to let the place for an acknowledgement, then all the packets scheduled later are pushed by the same time slot amount. This should concern only SYNC RQST and Beacon RQST, since the data packets stay in the FIFO until the time slot where they are sent (at which point it has already been determined that no acknowledgement was expected).","Finally, concerning there are several rules concerning the transmission inside a given time slot. The data messages are always sent at the beginning of the first sub-time slot; this maximizes the space available for data and allows the endpoints to send their acknowledgements in the last sub-time slot.","The synchronization acknowledgements should also be sent in the same time slot as the request; the SYNC RQST should be sent in the second sub-time slot and the corresponding acknowledgement in the last sub-time slot, whether the answer in negative or positive. If the SYNC RQST triggers a RQST Beacon to check the connection with one father then it should also be sent in the last sub-time slot (where the SYNC (N)ACK would be sent if the connection to a father was good).","The beacons should be randomized between the second and the fifth sub-time slot to not interfere with the start of data messages or the acknowledgements. The same rule should apply to the MAC outage packet.","In other present versions of the protocol the acknowledgments are made in the time slot following the message or the request, which meant that data packets could not be sent in successive time slots. The present version does not have this restriction, but it is compatible with the fact to not send data back to back if the hardware cannot handle it. The acknowledgements were put in the same time slot to be in the same frequency as the original packets and not to gain time. Summarized for the present version:\n\n","The present discussion more particularly relates to various outage notification system aspects of the present subject matter. Specifically, it is noted that endpoints that experience a power outage possess important information that if it could be relayed to the data collection system, can be applied for very useful network management purposes. However, during a power outage, the supply of energy has been cut off. For low cost devices which do not contain energy storage devices, this means that they have limited energy available and will not be able to continue to participate to the network. The problem then arises how to move this valuable information to the cell relay under these circumstances.","The present solution is advantageously based on using to relay the information the endpoints that do not experience a power outage. At each power out, there will be a self-defining fringe where endpoints within the power out zone will be able to communicate with endpoints that are still having power.","Endpoints that experience the power outage will enter a power out mode once a power failure is detected. The will immediately cease normal network operation and will initiate a few short power out messages over a randomized time window to avoid collisions. As it is still able to keep time accurately due to oscillator drift compensation, it will be able to select correct frequency channels and time to ensure powered endpoints in range will be able to capture these messages. Once power endpoints capture a power outage message, it will be able to store this information and send it using normal network protocol.","If the network connectivity has been influenced by the power outage, endpoints will use the normal network self management functions to re-establish connectivity if possible. Power out information is stored during this time and is not lost. If the power outage zone is large only a percentage of power out messages will be reported but should be sufficient to infer true outage problems with correlation with electricity network information, at least from the perspective of network management purposes.","More particularly, per present subject matter, when a power outage occurs, the MAC layer enters in a special mode (requested by API). The MAC layer stops listening and sends 3 very short messages with the EP remaining energy. Each such message is randomized (but still aligned with the timeslots) in a 5 s window. These outage messages are processed by everyone that can hear them. These messages are also numbered with an outage number (1 increment by outage, not by sent messages). If before the first outage message is sent, the EP recovers its power, then it cancels the outage notifications (but the API layer is free to send a power recovery message). But if the power comes back after the first outage message is sent, then the EP will send the remaining two.","When a neighbor that is still powered hears an outage message, its MAC layer indicates to the NET layer (through the LLC) the outage notification, the neighbor address, the outage number and the time when the outage message arrived. It will be the task of the NET layer to forward this information to the Cell Relay in the same way that is used for regular (or classical) uplink messages.","The present protocol subject matter beneficially affords analysis of other aspects of network related performance. Specifically, an embedded RF environmental evaluation tool is provided to gauge the performance needs of RF transceivers. In particular, a statistical radio environment analysis tool is embedded in the nodes of a subject mesh network for the purpose of providing guidelines for the improvement of the hardware.","The present system is intended for use in ISM bands. These bands usually feature a very high level of uncontrolled interference. The specifications of the RF hardware, as well as the expected performance of the network, strongly depend on the electromagnetic environment in these bands. Two aspects of this environment need to be considered. The first one is the path loss or propagation conditions. Although a lot of information is available on this topic for ISM bands, no reliable statistical data is available for the specific electricity-meter-to-electricity-meter situation relevant to this network. The second aspect of the problem is the interference level. The knowledge of this parameter is very important because the largest part of the cost of an RF transceiver is associated with interferences and how to efficiently fight them. The present subject matter provides for the implementation of an embedded environment analysis tool in the protocol. This is potentially an invaluable tool for network diagnosis and planning. It will also be the stepping-stone for a next generation hardware definition for any system because it will provide a means to support any cost reduction of the RF hardware, by providing extensive environment analysis back up to ensure that any resulting new hardware has the required specifications to work in its environment. For such purposes, the nodes of the network will probe the electromagnetic environment with the RSSI (Received Signal Strength Indicator) function of the receiver. Due to the continuously changing nature of this environment, a very large number of RSSI measurements are necessary to be valid from a statistical standpoint. Therefore, to avoid cluttering the limited bandwidth with all these measurements, a statistical data processing will be applied in the node. In this way, only significant information will have to be reported to the application. Two different kinds of environment analysis are specified in this protocol. The first one is used to explore the time characteristics of the interference and is a measurement of the RSSI auto-correlation function. The second one focuses on the intensity of the interference and is a measurement of the RSSI probability density function. The first kind of analysis will help answering questions like: what is the optimal packet length to avoid collisions with the other users of the band? The second analysis will help answer questions like: what is the necessary adjacent channel rejection to avoid collisions? What is the probability for a collision to occur if two nodes are some distance away from each other?","A chief benefit is that it enables optimization of RF hardware that needs to work in specific conditions, for practice of the present subject matter in a particular field environment.","Considering such present environmental analysis tools in greater detail, it will be understood that the specifications of the RF hardware, as well as the expected performance of the network, strongly depend on the electromagnetic environment. Two aspects of this environment need to be considered. The first one is the path loss or propagation conditions. The second aspect of the problem is the interference level. The MAC layer can probe the electromagnetic environment with the RSSI function of the receiver, and obtain a relatively large number of RSSI measurements for statistical validity. Two different kinds of environment analysis are specified in this protocol. The first one is used to explore the time characteristics of the interference and uses the RSSI auto-correlation function. The second one focuses on the intensity of the interference and uses the RSSI probability density function.","With respect to the subject environmental analysis functionality, the objective of the RSSI Autocorrelation Acquisition Mode is to measure the average RSSI and its auto-correlation function on a single channel. In this mode, the endpoint will interrupt for some time its normal hopping sequence and its usual communication tasks. The MAC layer will configure its receiver in continuous reception mode and will request RSSI readings from the PHY layer at a rate given by the MAC layer parameter RSSI_Sampling_Rate. These readings will then be processed to extract the average value and the auto-correlation function. The LLC layer sends the request to the MAC layer with two input arguments: the channel number to perform the analysis on and a maximum number of samples used to terminate the environment analysis.","The average RSSI, RSSI_avg, will be computed iteratively as explained by the following algorithm:",{"@attributes":{"id":"p-0664","num":"0781"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Initialization:",{}]},{"entry":[{},"RSSI_avg = 0",{}]},{"entry":[{},"n = 0",{}]},{"entry":[{},"For each RSSI reading do",{}]},{"entry":{}},{"entry":[{},{"maths":{"@attributes":{"id":"MATH-US-00034","num":"00034"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":"{","mrow":{"mtable":{"mtr":[{"mtd":{"mrow":{"mi":"n","mo":"\u2190","mrow":{"mi":"n","mo":"+","mn":"1"}}}},{"mtd":{"mrow":{"mrow":[{"mi":"RSSI_avg","mo":"\u2062","mrow":{"mo":["(",")"],"mi":"n"}},{"mfrac":{"mrow":{"mi":"RSSI","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},"mi":"n"},"mo":"+","mrow":{"mfrac":{"mrow":{"mi":"n","mo":"-","mn":"1"},"mi":"n"},"mo":["\u2062","\u2062"],"mi":"RSSI_avg","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}}}],"mo":"="}}}]},"mo":"\u2003"}}}}},{}]},{"entry":{}},{"entry":[{},"If n = maximum number of readings, then stop acquisition process",{}]},{"entry":[{},"end"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0665","num":"0782"},"maths":{"@attributes":{"id":"MATH-US-00035","num":"00035"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":"\u2003","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":["R","S","S"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mrow":{"mi":"I","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}},{"mi":["current","R","S","S","I","reading"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}],"mo":"="}}},{"mtd":{"mrow":{"mrow":[{"mi":["R","S","S","I_avg"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mrow":{"mo":["(",")"],"mi":"n"}},{"mi":["new","value","of","R","S","S"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mrow":{"mi":["I","_avg"],"mo":"\u2062"}}],"mo":"="}}},{"mtd":{"mrow":{"mrow":[{"mi":["R","S","S","I_avg"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}},{"mi":["old","value","of","R","S","S","I_avg"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]}],"mo":"="}}}]}}}}}},"For the computation of the auto-correlation function it is necessary store in memory the last 100 values of the RSSI. The auto-correlation function will only be evaluated for a restricted set of delay values. This set of values is:\n\nRSSI_AF_Delays={0,1,2,3,4,5,6,7,8,9,10,20,30,40,50,60,70,80,90,100}\n\nThese values correspond to the time delays\n",{"@attributes":{"id":"p-0667","num":"0784"},"maths":{"@attributes":{"id":"MATH-US-00036","num":"00036"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":[{"mi":["RSSI_AF","_Delays"],"mo":"\u2062"},{"mi":["RSSI_Sampling","_Rate"],"mo":"\u2062"}]},"mo":"."}}}},"At each RSSI reading, the averaged RSSI is first updated and then the auto-correlation function values are updated. The update process for the RSSI auto-correlation function values, AF_RSSI(m,n), is:",{"@attributes":{"id":"p-0669","num":"0786"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Initialization"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{},"AF_RSSI(m) =0 for each m \u03b5 RSSI_AF_Delays"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"After each RSSI_avg update do"]},{"entry":[{},"For each m \u03b5 RSSI_AF_Delays do"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"If n \u2267 m + 1"]},{"entry":[{},{},"temp = (RSSI(n) \u2212 RSSI_avg(n))(RSSI(n \u2212 m) \u2212 RSSI_avg(n))"]},{"entry":[{},{}]},{"entry":[{},{},{"maths":{"@attributes":{"id":"MATH-US-00037","num":"00037"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"AF_RSSI","mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mi":["m","n"],"mo":","}}},{"mfrac":{"mi":"temp","mrow":{"mi":["n","m"],"mo":"-"}},"mo":"+","mrow":{"mfrac":{"mrow":[{"mi":["n","m"],"mo":["-","-"],"mn":"1"},{"mi":["n","m"],"mo":"-"}]},"mo":["\u2062","\u2062"],"mi":"AF_RSSI","mrow":{"mo":["(",")"],"mrow":{"mi":"m","mo":",","mrow":{"mi":"n","mo":"-","mn":"1"}}}}}],"mo":"="}}}}]},{"entry":[{},{}]},{"entry":[{},{},"end"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0670","num":"0787"},"maths":{"@attributes":{"id":"MATH-US-00038","num":"00038"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":"\u2003","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":["R","S","S"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mrow":{"mi":"I","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}},{"mi":["current","R","S","S","I","reading"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}],"mo":"="}}},{"mtd":{"mrow":{"mrow":[{"mi":["R","S","S","I_avg"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mrow":{"mo":["(",")"],"mi":"n"}},{"mi":["new","value","of","R","S","S"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mrow":{"mi":["I","_avg"],"mo":"\u2062"}}],"mo":"="}}},{"mtd":{"mrow":{"mrow":[{"mi":"AF_RSSI","mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mi":["m","n"],"mo":","}}},{"mi":["new","value","of","RSSI","auto","correlation","function","for","delay","m"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"-"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}],"mo":"="}}},{"mtd":{"mrow":{"mrow":[{"mi":"AF_RSSI","mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mi":"m","mo":",","mrow":{"mi":"n","mo":"-","mn":"1"}}}},{"mi":["old","value","of","RSSI","auto","correlation","function","for","delay","m"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"-"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}],"mo":"="}}}]}}}}}},"When the requested number of RSSI readings is reached, the acquisition and update process stops. The RSSI_avg value and the AF_RSSI(m) values for each delay m are then reported to the LLC layer in the confirmation message. This report will then be forwarded to Net layer and to the API, which will send it to the Cell Relay. The structure of the output arguments for the confirmation is shown below:",{"@attributes":{"id":"p-0672","num":"0789"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["RSSI_avg","AF_RSSI(0)","AF_RSSI(1)","AF_RSSI(90)","AF_RSSI(100)"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Per the present subject matter, it should also be noted that this environment analysis process must be short enough to prevent the endpoint from loosing its synchronization with the mesh network. Moreover, the auto-correlation acquisition mode should be used preferably in nodes not too close from the Cell Relay in order to avoid disrupting the data flow through the network.","With respect to the subject environmental analysis functionality, the objective of the RSSI PDF Acquisition Mode is to measure the probability density function (PDF) of the RSSI readings on three selected channels. In this mode, the endpoint keeps hopping its channel number according to cell hopping sequence, as in normal mode. The node carries on with all its usual communication tasks and uses its spare time to probe the environment.","Three different channels are designated for RSSI PDF acquisition and they are part of the basic hopping sequence. The LLC layer sends the request to the MAC layer with four input arguments: the three channel numbers to analyze and a maximum counter value (RSSI_PDF_Max_Count) used to terminate the environment analysis. The RSSI PDF acquisition procedure is described further herein, and present  provides representation illustrations concerning such subject matter.","Whenever the receiver hops to one the channels selected for RSSI measurement, it will request a RSSI reading of the PHY layer. Only one RSSI reading is requested per time slot. This RSSI value will then be used to update the RSSI PDF for that channel. The PDF is an array of 24 bins, each one of these bins corresponds to a RSSI range of 3 dB as shown in present . A counter is associated with each bin. For instance, if the RSSI reading is equal to \u2212113 dBm, the counter associated with bin 2 will be incremented. In a general way:",{"@attributes":{"id":"p-0677","num":"0794"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Initialize all bin_k_counters to zero"]},{"entry":[{},"RSSI_min = \u2212118 dBm"]},{"entry":[{},"RSSI_step = 3 dB"]},{"entry":[{},"If RSSI_min + (k\u22121)*RSSI_step <= RSSI < RSSI_min +"]},{"entry":[{},"k*RSSI_step then"]},{"entry":[{},"bin_k_counter = bin_k_counter + 1"]},{"entry":[{},"if bin_k_counter = RSSI_PDF_Max_Count then"]},{"entry":[{},"\u2003\u2003exit acquisition process"]},{"entry":[{},"end"]},{"entry":[{},"end"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"There are some exceptions to this rule. If the RSSI value is above the upper bound of the last bin, the counter associated will the last bin should be incremented. In a similar way, if the RSSI value is below the lower bound of the first bin, the counter associated with the first bin should be incremented. If a start of frame delimiter is detected in a time slot, prior to the RSSI reading, this time slot should not be used for RSSI PDF update. If a start of frame delimiter is detected in a time slot, after the RSSI reading, this time slot can be used for RSSI PDF update. The purpose of this is to prevent Linknet traffic from interfering with the PDF acquisition. The goal of this measurement is to get an image of the external interferences sources on the channels used by the network. Each one of the bin counters starts from zero when the process is initialized and has a max range of 4095. When any of these counters reaches the maximum value RSSI_PDF_Max_Count (\u22664095), the RSSI PDF acquisition for that channel is stopped. When the RSSI PDF acquisition is completed for the three selected channels, the MAC layer can report the results to the LLC layer. The structure of the output is shown in present .","If the node loses synchronization, switches to another, cell or experiences a power outage (it could be done at power up), all the buffered messages should be deleted.","The MAC layer uses several types of messages to manage its numerous tasks. Not every message contains the same level of information. In order to save RF bandwidth and to not send useless bytes, the MAC header will be different for almost each message type. However, every message should provide synchronization information to anyone who can hear it. This way no message will be useless, even if a message is heard by an endpoint that is not the destination.","At the MAC layer level, the address of an endpoint is the serial number of the meter itself. Address is so fixed and unique, and is 4 Bytes long.","The message frame at MAC level is composed of:\n\n","Present  below shows all the fields that can be present at MAC level. The field and different message structures are otherwise described herein.","According to the present subject matter, there is a part of the header which is common to all types of messages:","LV, Layer Version: It indicates the version of the MAC layer.","FT, Frame Type: These bits indicate the type of the frame. See relative sections of present  for MAC frame type related information. Note that the message types are arranged in order of priority.","SA, Sender Address: The Sender\/Source Address is 4 bytes long.","The MAC header has a dynamic section, in which the fields below don't appear in every message. They are described here in a general way, with more details otherwise stated herein for each message type.","RS, Registration State:","It indicates whether the endpoint is registered to a cell or not. This information is provided by the NET layer.","The RS bit of the Cell Master is always 1.","RSD, Reserved:","Not used for the moment. This field should be set to 0.","CD, Connectivity Degree","This field indicates the degree of connectivity of the node with its fathers. Depending on the number of potential SYNC fathers the node has, the Connectivity Degree takes a different value. The CD value of the Cell Master is always set to the maximal value.\n\nCSI, Cell Size Indicator:\n\nIt indicates how full the cell is.\n\nLVL, Level:\n\nThis field indicates the level of the sender. A 0-level transmitter signals that the transmitter is not connected to the mesh network. A 1-level transmitter signals that the transmitter is a Cell Master. For the other value, if n is the number of hops to reach the Cell Master, the level is defined by LVL=n+1.\n\nGPD, Global Propagation Delay:\n\nThis field gives the global propagation delay between the sender and the Cell Master.\n\nSACT, Slotted Aloha Countdown Timer:\n\nThis field indicates the remaining time before the endpoint switches to the next time slot when the transmitter sends the message. SACT is expressed in MAC_SACT_Resolution_\u03bcs.\n\nTSN, Time Slot Number.\n\nThis field gives the time slot number in which the message is sent. Combined with the cell address (CELL), any endpoint can deduce the channel of this time slot.\n\nCELL, Cell address:\n\nThis field gives the address of the cell with which the endpoint is synchronized. These 2 bytes are used to compute the frequency hopping sequence used in the cell. In a Discovery Beacon, this field is used to specify the preferred cell in warm start. The Cell address is based on the C12.22 address of the Cell Relay WAN board.\n\nFID, Frame ID:\n\nThe Frame ID number is incremented and sent at each Sync Request and monocast data; it is sent in the (N)ACK or SYNC_(N)ACK to specify the packet they are answering to.\n\nOID, Outage ID:\n\nThe outage number of the endpoint that experiences a power failure.\n\nDA, Destination Address.\n\nThe Destination Address is 4-byte long.\n\nHFN, HyperFrame Number:\n\nThe hyperframe number can be used in several ways depending on the message type.\n\nRITP, Relative ITP:\n\nThe relative ITP is propagated in the network through a dedicated type of message. This is the ITP timestamp of the beginning of the hyperframe number 0.\n\nRxC, Reception Channel\n\nThis field indicates the channel number on which the EP will listen during the listening window of the discovery phase\n\nNDB, Number of remaining Discovery Beacons\n\nIt gives the number of remaining discovery beacons to send before the beginning of the listening window.\n","The frame body is only present in data message, that is, messages from the above layers. This field doesn't exist for the other messages:","LPDU, LLC Protocol Data Unit: This field carries the message for the layers above the MAC layer.","The Frame Check Sequence (FCS) field is used to detect potential errors in the frame:","CRC, Cyclic Redundant Code: These 4 bytes are allocated for a CRC-32 value to check the integrity of the MAC header and the frame body.","Beacons are empty messages with no specific destination. They only contain synchronization information; an endpoint sends beacons periodically when it does not generate any other traffic. The beacon length at MAC level is 19 bytes, as graphically represented by present .","A SYNC request is sent by an endpoint which wants to become synchronized with another. The FID field is a counter, incremented at each sent SYNC Request or Monocast Data. The SYNC request length at MAC level is 24 bytes, as graphically represented by present .","The following types of messages are used to acknowledge or not data messages and SYNC requests. The FID field refers to the FID of the message which is (non-)acknowledged. The (N)ACK or SYNC NACK length at MAC level is 24 bytes, as graphically represented by present .","A SYNC ACK message is an acknowledgment of a SYNC request. The FID field refers to the FID of the SYNC request message which is acknowledged. It differs from the SYNC NACK because the current hyperframe number, HFN, and the relative ITP of this hyperframe are also transmitted. The SYNC ACK length at MAC level is 29 bytes, as graphically represented by present . One special note is that this message doesn't fit in a single sub time slot (for 1 byte).","If an endpoint needs to update the synchronization information of one of its neighbors or just checks that it is still present, it can send it a request beacon. The Request Beacon length at MAC level is 23 bytes, as graphically represented by present .","The monocast data message is a data message sent to only one destination. It contains in the frame body the LPDU to carry. The FID field is a counter, incremented at each sent Monocast Data or SYNC Request. The monocast MAC frame length is LPDU length+24 bytes, as graphically represented by present .","The broadcast is a data message not addressed to anybody in particular but intended to any endpoint receiving it. The broadcast MAC frame length is LPDU length+19 bytes, as graphically represented by present .","The ITP messages are dedicated messages, initialized by the Cell Master, to propagate the RITP in the entire cell. They are considered as broadcast data messages with no frame body. The RITP field is fixed by the Cell Master when it initializes the message as the HFN field, which is the hyperframe number of the creation of the RITP. When EPs forward the ITP message, they keep the same HFN and RITP fields as the ones created by the Cell Master. The ITP length at MAC level is 24 bytes, as graphically represented by present .","The discovery beacon is a short message sent during the discovery phase by non-synchronized EPs. RxC field indicates the listening channel of the discovery phase, NDB the number of remaining discovery beacons to send before the listening window, and CELL is set to the cell address the node wants to synchronize with, in warm start (set to 0 in cold start). The Discovery Beacon length at MAC level is 13 bytes, as graphically represented by present .","Outage messages are the simplest and shortest messages that can be sent. When an endpoint realizes that there is power failure, it uses its last gasp to send several of these messages. The OID gives the outage number. At each new outage, the EP increments this outage number, which rollovers on 1 byte. For each outage, three outage messages are sent randomized in three intervals of 5 seconds (the OID stays the same for these three packets). The Outage message length at MAC level is 10 bytes, as graphically represented by present .","Present  schematically represents MAC Layer Services, which reflect functionality advantageously provided per the present protocol subject matter. Specifically, with an objective to send a message to one destination, MAC_Request_Send_Mono_Data, there is use of requisite input arguments: LPDU, Destination Address. The operation may be described as the LLC layer requests the MAC layer to send a message to one neighbor. The message is sent with the standard traffic management rules. Note that the neighbor is not necessarily in the neighbor table.","With an objection to send a broadcast message, MAC_Request_Send_Broadcast, there is use of requisite input arguments: LPDU. The operation may be described as the LLC layer requests the MAC layer to send a message to everybody in the neighborhood. The message is sent with the standard traffic management rules.","With an objective to send an RITP timestamp, MAC_Request_Send_ITP, there is no required use of input arguments. The operation may be described as the NET layer requests the MAC layer, by the way of the LLC, to send an ITP message to everybody in the neighborhood. This request follows the same approach as a MAC_Request_Send_Broadcast, except that there is no LPDU to carry. Instead of LPDU, the MAC adds in its header the RITP and the HFN of the creation of this RITP. The message is sent with the standard traffic management rules.","With an objective to measure the medium interference level on a specified channel and its time auto-correlation function, MAC_Request_Environment_Analysis_Auto-Correlation, there is use of the requisite input arguments: Channel number, Number of samples. The operation may be described as the API layer requests, by the way of the LLC and NET layers, the MAC layer to measure the RSSI on a specified channel, a given number of times. The MAC layer will then compute the average value of this RSSI as well as its auto-correlation function. The sampling acquisition rate of the RSSI is a MAC parameter, MAC_RSSI_Sampling_Rate. The values of the delays for the computation of the auto-correlation function are given by another MAC parameter, MAC_RSSI_AF_Delays.","With an objective to measure the medium interference level on three specified channels and its probability density function, MAC_Request_Environment_Analysis_PDF, there is use of the requisite input arguments: Channel numbers (3), RSSI_PDF_Max_Count (maximum value of bin counters). The operation may be described as the API layer requests, by the way of the LLC and NET layers, the MAC layer to measure the RSSI on three specified channels taken from the hopping sequence. For each one of these channels, the MAC layer will compute the RSSI probability density function (PDF). The acquisition process stops when a bin counter reaches the maximum allowed value for that request.","With an objective to give to the MAC layer the information whether a cell is authorized or not, MAC_Request_Cell_Authorization, there is use of the requisite input arguments: Cell Address, Cell Status. The operation may be described as the NET layer gives, by the way of the LLC layer, to the MAC layer the status of a cell. This one can be authorized, or forbidden.","With an objective to give to the MAC layer the information whether the NET layer is registered, MAC_Request_Cell_Registration, there is use of the requisite input arguments: Cell Address, Registration Status. The operation may be described as the NET layer informs, by the way of the LLC layer, of the NET registration status in the cell. Then the MAC layer can put the RS (Registered State) bit to 0 or 1 in its header.","With an objective to answer a MAC_Request_Send_Mono_Data, MAC_Confirmation_Send_Mono_Data, there is use of the requisite output arguments: Status of the message (ACK, NACK, No ACK). The operation may be described as it gives to the LLC layer the status of a Send Mono Data Request. Each confirmation is linked to the number of the associated request to avoid confusion. The confirmation can be a ACK or NACK if such messages have been received, or a No ACK status if the destination has not answered in the time slot it should had.","With an objective to answer a MAC_Request_Send_Broadcast and MAC_Request_Send_ITP, MAC_Confirmation_Send_Broadcast and MAC_Confirmation_Send_ITP, there is use of the requisite output arguments: Status. The operation may be described as it confirms to the LLC when the broadcast or the ITP has been sent, Then the LLC can proceed to the repetition if necessary.","With an objective to answer a MAC_Request_Environment_Analysis_Auto-Correlation, MAC_Confirmation_Environment_Analysis_Auto-Correlation, there is the use of requisite output arguments: average RSSI, RSSI auto-correlation function values. The operation may be described as the MAC layer sends to the layer above the RSSI average value and the values of the auto-correlation function computed during the requested environment analysis. The number of values for the auto-correlation function is the number of delays at witch this function was calculated. These delays are defined by the MAC layer parameter MAC_RSSI_AF_Delays.","With an objective to answer a MAC_Request_Environment_Analysis_PDF, MAC_Confirmation_Environment_Analysis_PDF, there is use of the requisite output arguments: RSSI PDF values for the three requested channels (3\u00d724 values). The operation may be described as the MAC layer sends to the layer above the RSSI PDF values (actually the values of the bin counters) for each one of the three requested channels.","With an objective to answer a MAC_Request_Cell_Authorization, MAC_Confirmation_Cell_Authorization, there is the use of the requisite output arguments: Status. The operation may be described as it just confirms that the request has been taken into account.","With an objective to answer a MAC_Request_Cell_Registration, MAC_Confirmation_Cell_Registration, there is use of the requisite output arguments: Status. The operation may be described as it just confirms that the request has been taken into account.","With an objective to forward a received LPDU message to the LLC layer, MAC_Indication_Received, there is use of the requisite output arguments: LPDU, Sender Address. The operation may be described as it gives to the LLC layer the LPDU that has been received with the sender address.","With an objective to inform that a broadcast ITP message has been received, MAC_Indication_ITP_Received, there is no use of any output arguments. The operation may be described as when a valid broadcast ITP message is received, the MAC layer updates the RITP field and informs the NET layer, by the way of the LLC layer, of that arrival. The result of this indication forces the NET layer to forward this ITP if not already done.","With an objective to update the ITP of the API layer, MAC_Indication_ITP_Update, there is the use of the requisite output arguments: Absolute ITP Timestamp. The operation may be described as the RITP can be updated after the reception of an ITP broadcast message or a SYNC ACK. The MAC layer then computes an update of the absolute ITP and sends it to the API layer. As soon as the ITP is computed, it should be given to the API layer very quickly. This indication has priority over all other indications.","With an objective to indicate to the above layer the MAC state, MAC_Indication_State, there is the use of the requisite output arguments: State, Cell address. The operation may be described as the MAC layer informs the upper layers after each state modification. The MAC layer can be not-synchronized or synchronized with a cell. In the last case, the address of the cell is indicated.","With an objective to indicate to the above layer that the MAC layer will soon leave the current cell, MAC_Indication_Cell_Leaving_process, there is no use of any output arguments. The operation may be described as the MAC layer informs the upper layers that it has found a new cell and it will leave soon the current one.","With an objective to inform that a power outage notification has been received, MAC_Indication_Outage_Received, there is use of the requisite output arguments: Outage ID, Sender Address, Outage Time. The operation may be described as it indicates to the NET layer, by the way of the LLC, that a neighbor has experienced an outage at a given time. It forces the Net layer to forward this notification to the Cell Master.","The MAC layer is organized in three modes: Non-Synchronized Mode, Synchronization Mode, and Synchronized Mode. When the meter is switched on or after a Black Out, the MAC layer goes into Non-Synchronized Mode. Present  represents such features and other aspects, including additional disclosure regarding MAC State Diagram subject matter.","The Logical Link Control layer is the second sub-layer of the Data Link layer, next to the Net layer. Its goal is to provide other functionalities for the Data Link layer, without burdening the MAC layer. These functionalities can independently operate above the MAC layer ones but still have the goal to optimize access to the medium.","Some services provided by the MAC layer are useless to the LLC layer, they are rather intended for layers above the Data Link layer, such as the NET layer. Therefore, in order not to break the layer approach, some services are merely forwarded from the MAC to the NET layer, and vice versa, going through the LLC layer as if it was a pipe.","The following listing describes the adjustable (that is, tweakable) parameters of the LLC layer with their associated preferred default values being referenced in present .","LLC_Duplication_Table_Size\n\n","LLC_Max_Message_Length\n\n","LLC_Max_Nb_of_Packets\n\n","LLC_Max_Nb_of_Downlink_Transmissions:\n\n","LLC_Max_Nb_of_Uplink_Transmissions:\n\n","LLC_Max_Packet_Length\n\n","LLC_Message_Timeout\n\n","LLC_Nb_of_Broadcast_Transmissions\n\n","LLC_Tx_Retry_Exp_Offset\n\n","LLC_Tx_Retry_Exp_Range\n\n","LLC_Tx_Retry_Exp_Start\n\n","Each monocast message sent by the LLC layer should be acknowledged at the MAC layer level. It will happen very often than the MAC layer will report that it didn't receive this acknowledgement. This can occur if the destination endpoint fails to receive the message or if the sender fails to receive the acknowledgement, due to collisions, interference or fading. In any case of failure, the LLC layer will send the message again until it is acknowledged or until the maximum number of attempts is reached. After LLC_Max_Nb_of_Downlink_Transmissions, or LLC_Max_Nb_of_Uplink_Transmissions, unsuccessful transmissions, the LLC layer reports a No-ACK failure status to the NET layer.","For broadcast data or ITP, the LLC will automatically repeat the message using the backoff algorithm once the MAC layer has notified that the former sending is gone and this until the specified number of attempts, Number_of_Broadcast_Transmissions, is reached.","When the LLC layer receives from the NET layer a request to send a packet, or when it reschedules a non-acknowledged transmission, it will introduce a random delay before actually sending the request to the MAC layer. The purpose of this delay is to avoid flooding the air interface with a large number of packets when the conditions of transmission are difficult. The LLC layer will compute the length of a randomization window, Tx_Wait, and will send the actual request to the MAC layer after a random delay with a uniform probability distribution between zero and Tx_Wait. The value of Tx_Wait is computed as a function of the repetition number. Tx_Wait is computed according to a truncated binary exponential backoff law as given by the following equation:",{"@attributes":{"id":"p-0741","num":"0876"},"maths":{"@attributes":{"id":"MATH-US-00039","num":"00039"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"Tx_Wait","mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":[{"mn":"0"},{"mrow":{"mrow":{"mi":["if","R"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":"\u2264","msub":{"mi":["R","start"]}}}]},{"mtd":[{"msup":{"mn":"2","mrow":{"mi":"R","mo":["-","-"],"msub":{"mi":["R","start"]},"mn":"1"}}},{"mrow":{"mrow":[{"mi":"if","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["R","start"]}},{"msub":[{"mi":["R","start"]},{"mi":["R","range"]}],"mo":"+"}],"mo":["<","<"],"mi":"R"}}]},{"mtd":[{"mrow":{"msup":{"mn":"2","msub":{"mi":["R","range"]}},"mo":"-","mn":"1"}},{"mrow":{"mrow":[{"mi":["if","R"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"msub":[{"mi":["R","start"]},{"mi":["R","range"]}],"mo":"+"}],"mo":"\u2265"}}]}]}}}}}},"Here R is the repetition number: it ranges from zero for the first transmission attempt to some maximal value given by (LLC_Max_Nb_of_Transmisions\u22121). The application of this exponential backoff law is delayed and truncated as can be seen from the above equation. This is also illustrated by present , which graphically represents delayed truncated binary exponential backoff for transmission retries if packets are not acknowledged. The rationale behind this is simple and can be explained in the following way. In the \u201cno wait time\u201d period, the transmitter is trying different channels to avoid interference or difficult propagation conditions. In the \u201cbinary exponential backoff\u201d period, the transmitter is progressively increasing the wait time to allow the network to recover from unusually difficult conditions (whatever they are). The \u201ctruncated exponential backoff\u201d is necessary to avoid introducing unrealistically long wait times in the system.","The beginning and end of the binary exponential backoff law are given by two LLC layer parameters:\n\n@LLC_Tx_Retry_Exp_Start\n\n@LLC_Tx_Retry_Exp_Range\n","An additional parameter introduces an offset in the application of the exponential law and gives a way to control the initial slope:\n\n@LLC_Tx_Retry_Exp_Offset\n","The following example illustrates the retransmission randomization window algorithm for Rstart=5, Rrange=5, Roffset=2, LLC_Max_Nb_of_Transmissions=15, and TS_Length=1. The first column (R=0) corresponds to the initial transmission attempt.",{"@attributes":{"id":"p-0746","num":"0881"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]},{"entry":[{},"R"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"16"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"11","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"12","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"13","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"14","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"15","colwidth":"21pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","1","2","3","4","5","6","7","8","9","10","11","12","13","14"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"15","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"16"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"11","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"12","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"13","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"14","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"15","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"16","colwidth":"21pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Tx_Wait","0","0","0","0","0","0","4","12","28","60","124","124","124","124","124"]},{"entry":{"@attributes":{"namest":"1","nameend":"16","align":"center","rowsep":"1"}}}]}}]}}},"If a packet is negatively acknowledged (NACK), the \u201cno wait time\u201d phase of the retransmission strategy should be bypassed because in this case we know that what happened is not due to a propagation problem or interference (see appendix). For similar reasons, in the special case of broadcast transmission, the non delayed exponential backoff should be used. Broadcasts generate a burst of traffic and internal collisions between nodes of the network are likely to occur and slow down the broadcast. The immediate use of an exponential backoff can mitigate this problem. See also present , which graphically represents truncated binary exponential backoff for transmission retries if packets are negatively acknowledged. In all these cases the repetition law is given by:",{"@attributes":{"id":"p-0748","num":"0883"},"maths":{"@attributes":{"id":"MATH-US-00040","num":"00040"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"Tx_Wait","mo":"=","mrow":{"mi":"TS_Length","mo":"\u00d7","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":[{"mrow":{"msup":{"mn":"2","msub":{"mi":["R","offset"]}},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"msup":{"mn":"2","mi":"R"},"mo":"-","mn":"1"}}}},{"mrow":{"mrow":{"mi":["if","R"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":"<","msub":{"mi":["R","range"]}}}]},{"mtd":[{"mrow":{"msup":{"mn":"2","msub":{"mi":["R","offset"]}},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"msup":{"mn":"2","msub":{"mi":["R","range"]}},"mo":"-","mn":"1"}}}},{"mrow":{"mrow":{"mi":["if","R"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":"\u2265","msub":{"mi":["R","range"]}}}]}]}}}}}}},"If a packet is not acknowledged and later negatively acknowledged on a subsequent transmission attempt, the retry law for negatively acknowledged packets should be applied. In the same way, if a packet is negatively acknowledged and later a retry is not acknowledged, the retry law for negatively acknowledged packets should be kept.","The LLC layer offers a non-duplication service. Because RF media generate a large number of collisions, the LLC layer can send a message more than once, and also receive the same packet several times. To avoid forwarding the received message to the NET layer several times, each transmitted packet has a LLC number, LLC FID. See present , for an example of an LLC Duplication Table. Due to this number, the LLC layer knows whether the packet has already been received. Should this happen, the packet is discarded.","At each new reception, the message number, the packet number and the sender address are saved in a FIFO, which contains properties of the LLC_Duplication_Table_Size last messages. So the oldest entry is replaced by the new one if not already present in the table. If a duplicated message is received, the existing associated entry in the table needs to be removed and rewritten as a new entry. This will ensure that this entry remains longer in the table.","It should be noted that at the reception of a message, the detection of duplicated packets should be done before the operation of reconstitution of a fragmented message.","If the node loses synchronization, switches to another cell, or experiences a power outage (it could be done at power up), the duplication table should be cleared.","Another service offered by the LLC layer is the fragmentation of messages. The LLC layer offers the upper layer to send messages of length up to LLC_Max_Message_Length bytes, a size that can be longer than the one offered by the MAC layer, which is limited by the time slot length. LLC_Max_Message_Length is limited by the physical size of the device memory that runs the protocol and by the fact the LLC layer cannot handle more than 15 packets.","If the NET layer asks to send a message larger than what the MAC layer can send, the LLC layer splits the message into several shorter packets. The packet number and the number of packets are mentioned in the LLC header to enable the reconstitution of the entire message at reception.","Each packet corresponds to an individual request sent to the MAC layer. The MAC layer treats these packets as regular complete messages.","The LLC layer computes the required number of packets depending on the message length and the maximum size the MAC layer can handle.","From a transmitter side perspective, the LLC layer splits the message into packets. A MAC request is associated with each packet. When the first packet is sent, a timeout counter of LLC_Message_Timeout length is started. Each packet can be sent several times, with the same repetition limitation as for a standard packet, until the packet is acknowledged by the MAC layer. When all the packets have been acknowledged, the LLC layer confirms to the NET layer that the message has been sent with success. If one packet has not been sent correctly or if the counter reaches LLC_Message_Timeout, the LLC layer informs the NET layer that the transmission has failed.","From the receiver side perspective, the receiver LLC layer when it receives the first packet of a fragmented message, starts the same counter of LLC_Message_Timeout length as that of the transmitter side. When all the packets have been received, the LLC layer regenerates the entire message and gives it to the NET layer. If the counter reaches LLC_Message_Timeout value and at least one packet is still missing, all the other packets are deleted.","LLC_Message_Timeout value should be long enough to let the MAC layer send correctly all the packets. The value can depend on the number of packet to send.","The present protocol subject matter offers a kind of broadcast service, or more specifically, a multicast one. The function is that the same message can be sent to all the endpoints of a cell. This is a true broadcast, which is not acknowledged but simply transmitted Number_of_Broacast_Transmissions times by each endpoint. It is intended to any endpoint hearing it (except the Cell Master, where the broadcasts originate).","The LLC header is 3 bytes long, as represented by present , which otherwise represents the full LLC Frame. Within such representation, the following additional frame information is applicable, as will be understood by one of ordinary skill in the art without further detailed explanation.","LV, Layer Version:\n\n","RSD, Reserved:\n\n","FID, Frame ID:\n\n","NOP, Number Of Packets:\n\n","PN, Packet Number:\n\n","Additionally, the NET Protocol Data Unit (NETPDU) contains information relative to the network layer.","The LLC Layer has a variety of interfaces and associated services (functionality), as represented in detail per present . The LLC layer ensures reliable functionality, not only of itself but in the services it provides for those in relationship with it, such as resulting in the LLC layer managing repetition and fragmentation of messages. For example, depending on (non-) acknowledgements, the LLC layer chooses if the packet has to be retransmitted or not.","With an objective to send a message to one destination, LLC_Request_Send_Mono_Data, there is use of requisite input arguments: NETPDU, and Destination Address. The operation may be described as the NET layer requests the LLC layer to send a message to one of its neighbors. The LLC layer fragments the message into several packets if needed before giving it to the MAC layer. The LLC layer also tries to send the message several times before reporting a success or an error to the NET layer.","With an objective to send a message to the neighborhood, LLC_Request_Send_Broadcast, there is use of requisite input arguments NETPDU. The operation may be described as the NET layer requests the LLC layer to send a message to all the endpoint's neighbors. The LLC layer fragments the message into several packets if needed before giving it to the MAC layer. The broadcast is repeated Number_of_Broacast_Transmissions times.","With an objective to send an RITP timestamp to the neighborhood, LLC_Request_Send_ITP, there is no use of input arguments. The operation may be described as the NET layer requests the LLC layer to send an ITP message to all the endpoint's neighbors. This request follows the same approach as a LLC_Request_Send_Broadcast, except that there is neither NETPDU, nor LPDU. The LLC forwards the request to the MAC layer, which is in charge of time stamping the message. The LLC layer manages the repetition of this message as a regular broadcast.","With an objective to measure the medium interference level on a specified channel and its time auto-correlation function, LLC_Request_Environment_Analysis_Auto-Correlation, there is use of requisite input arguments: Channel number, Number of samples. The operation may be described as a request being forwarded directly to the MAC layer.","With an objective to measure the medium interference level on three specified channels and its probability density function, LLC_Request_Environment_Analysis_PDF, there is use of requisite input arguments: Channel numbers (3), Max value of counter. The operation may be described as being a request forwarded directly to the MAC layer.","With an objective to give to the MAC layer the information whether a cell is authorized or not, LLC_Request_Cell_Authorization, there is use of requisite input arguments: Cell Address, Cell Status. The operation may be described as a request being forwarded directly to the MAC layer.","With an objective to give to the MAC layer the information whether the NET layer is registered, LLC_Request_Cell_Registration, there is use of requisite input arguments: Cell Address, Registration Status. The operation may be described as a request being forwarded directly to the MAC layer.","With an objective to answer an LLC_Request_Send_Mono_Data, LLC_Confirmation_Send_Mono_Data, there is use of requisite output arguments: ACK, NACK, No ACK, Destination Address of the sent packet. The operation may be described as it confirms to the NET layer whether the message has been successfully sent to destination or not. If not and if at least a NACK has been received, it should be notified to the NET Layer. The NET layer is then able to choose whether it has to transmit the packet to another destination. Upon receiving a failure confirmation for an uplink message, the NET layer will update its routing probabilities and send a new request to the LLC.","With an objective to answer an LLC_Request_Send_Broadcast and LLC_Request_Send_ITP, LLC_Confirmation_Send_Broadcast and LLC_Confirmation_Send_ITP, there is use of requisite output arguments: OK. The operation may be described as confirms to the NET layer that the broadcast has been sent.","With an objective to answer an LLC_Request_Environment_Analysis_Auto-Correlation, LLC_Confirmation_Environment_Analysis_Auto-Correlation, there is use of requisite output arguments: average RSSI, RSSI auto-correlation function values. The operation may be described as a forward of MAC_Confirmation_Environment_Analysis_Auto-Correlation from the MAC layer to the NET layer.","With an objective to answer an LLC_Request_Environment_Analysis_PDF, LLC_Confirmation_Environment_Analysis_PDF, there is use of requisite output arguments RSSI PDF values for the three requested channels (3\u00d724 values). The operation may be described as a forward of a MAC_Confirmation_Environment_Analysis_PDF from the MAC layer to the NET layer.","With an objective to answer an LLC_Request_Cell_Authorization, LLC_Confirmation_Cell_Authorization, there is the use of requisite output arguments: Status. The operation may be described as a forward of MAC_Confirmation_Cell_Authorization from the MAC layer to the NET layer.","With an objective to answer an LLC_Request_Cell_Registration, LLC_Confirmation_Cell_Registration, there is use of requisite output arguments: Status. The operation may be described as a forward of MAC_Confirmation_Cell_Registration from the MAC layer to the NET layer.","With an objective to forward a received NETPDU message to the NET layer, LLC_Indication_Received, there is use of requisite output arguments: NETPDU, Sender Address. The operation may be described as after assembling all the packets if the message was fragmented, the LLC layer gives the received NETPDU to the NET layer.","With an objective to inform that a broadcast ITP message has been received, LLC_Indication_ITP_Received, there is no use of any output arguments. The operation may be described as a direct forward of the MAC_Indication_ITP_Received from the MAC layer to the NET layer.","With an objective to update the ITP of the API layer, LLC_Indication_ITP_Update, there is use of the requisite output arguments: Absolute ITP Timestamp. The operation may be described as a direct forward of the MAC_Indication_ITP_Update from the MAC layer to the NET layer. This indication has priority over all other indications.","With an objective to indicate to the above layer the MAC state, LLC_Indication_State, there is the use of requisite output arguments: State, Cell address. The operation may be described as the LLC layer gets this indication directly from the MAC_Indication_State.","With an objective to indicate to the above layer that the MAC layer will soon leave the current cell, LLC_Indication_Cell_Leaving_process, there is no use of any output arguments. The operation may be described as a direct forward of the MAC_Indication_Cell_Leaving_process from the MAC layer to the NET layer. Before forwarding, the LLC layer frees its buffers and pending actions.","With an objective to inform that a power outage notification has been received, LLC_Indication_Outage_Received, there is the use of requisite output arguments: Outage ID, Sender Address, Outage Time. The operation may be described as a direct forward of the MAC_Indication_Outage_Received from the MAC layer to the NET layer.","The following relates more particularly to the network (NET) layer. The network layer is the third layer of the OSI model and the highest layer of the Linknet protocol. It is the heart of the routing mechanism. All endpoints have the same network layer except the Cell Master, which has extended routing functions. The NET layer main task is to decide what the destination of messages is, but it is also in charge of the cell registration process, which is internal to the RF LAN.","Per the EP (End Point) NET layer feature, the NET layer forwards any message to the next hop. It also provides data on its neighborhood to the cell relay. Per the CR (Cell Relay or Cell Master) NET layer, the Net layer offers to send a message to a particular EP (downlink message) in the cell or to the entire cell (broadcast message). The CR NET layer doesn't offer to send a message to a specific set of EPs in the cell. Also, the network layer is active only while the endpoint is synchronized, and it will let the application layer use the network only if it is registered at the NET level.","NET Parameters may be listed as follows, including their respective identifications, descriptions, and default values:","NET_Broadcast_Life_Expectancy:\n\n","NET_CR_Downlink_Duplication_Table_Size:\n\n","NET_CR_Duplication_Table_Size:\n\n","NET_Downlink_Life_Expectancy.\n\n","NET_Endpoint_TimeOut:\n\n","NET_EP_Duplication_Table_Size:\n\n","NET_Max_Registration_Attempts:\n\n","NET_Max_Nb_of_EPs:\n\n","NET_Nb_of_Fathers_Routing:\n\n","NET_Nb_of_Endpoints_Neighbor_List:\n\n","NET_Neighbor_List_First_Time:\n\n","NET_Neighbor_List_Max_Period:\n\n","NET_Neighbor_List_Min_Period:\n\n","NET_Reg_Send_Config_Period:\n\n","NET_Registration_Retry:\n\n","NET_Registration_Send_Max:\n\n","NET_Registration_Send_Min:\n\n","NET_Uplink_Life_Expectancy.\n\n","With respect to the so-called Neighbor table, the network layer uses the Neighbor table of the MAC layer, with reading rights. That means that the network layer can't modify values in such table. Present  depicts NET LAYER PARAMETER DEFAULT VALUES subject matter.","Before authorizing upper layers to use the network, an endpoint should be registered at a NET layer level. NET registration process starts as soon as the endpoint gets its synchronization from the MAC layer. There are two ways to proceed whether the endpoint was previously registered with the cell, which leads to a warm start process, or if it is joining a new cell, which leads to a cold start process.","The behavior during this cell registration process can also be viewed from two sides, the endpoint or the Cell Master.","In the Cold Start scenario, the following events that must happen before the API layer can access the Network:\n\n","Several particular items of note are:\n\n","In the Warm Start condition circumstances, it is much simpler and faster:\n\n","When a Cell Master receives a Cell Registration requests it should send a Cell Registration confirmation and update its routing table with the new information (add the endpoint if it is not already there) unless the routing table is full, in which case it should send a Cell Out Notification. For more detail on the actions of a Cell Master when receiving a packet, see the remaining disclosure herewith.","During a cold start, the Cell Master is receiving a lot of Cell Registration Requests in a narrow time window. It has therefore not enough time to send all the Registration confirmation at the same rate it receives requests. As a consequence, the Cell Master should keep track of the requests it receives and then sends the confirmation when it has time to do it. During a cell cold start, the number of \u201cpending registrations\u201d can be very high (around half of cell size).","The pending registration list can be handled by setting a flag in the routing table the corresponding endpoints (1 bit*max cell size=1 kb=125 B) and periodically sweep the table to know which endpoints needs a registration confirmation.","The pending registration could also be done as a list of addresses to send confirmation to; this is a tradeoff between memory space and code execution time and the choice is let to the implementation.","In both cases, when there are many stacked confirmations, they should be sent at a maximum rate of NET_Reg_Config_Send_Period. It is to ensure that we are not ourselves flooding the network with downlink messages.","When an endpoint switches cell, it will register in the new cell. The issue is that it is still registered in the old cell; this is not an issue for routing since the API level will realize that the endpoint moved cell but this can be an issue for cell size management. Effectively the cell size indicator (CSI) used in the cell switching process is based on the number of endpoint in the NET routing table of the Cell Master and if this number does not reflect the reality then the switching process does no longer work properly. This is why it is important that the old Cell Master be informed of the departure of endpoints from its cell. This is the role of the Cell Leaving Notification message.","As soon as the MAC layer notifies that a neighbor from a better cell is reachable, it plans a SYNC request and waits for the SYNC ACK. The SYNC ACK received, the MAC layer triggers some actions at each layer:\n\n","LLC:\n\n","NET:\n\n","During MAC_CELL_Leaving_Process_Duration seconds, the endpoint acts as usual except it cannot decide to start the same process with a third cell. It is implied that during this period the endpoint will have enough time to send the Net message AND also to forward the same kind of information from sons which decide themselves to change cell (they probably see the same new cell at the same time).","When the timer expires, whatever the status of remaining messages to send, the MAC layer resynchronizes its clock and switches to the new cell. LLC and NET layer are notified by this switching. Therefore, they free again their buffers, pending actions . . . . The NET layer (and the API) is then able to register with the new Cell Master.","The entire routing algorithm is based on the fact that every endpoint in the cell knows its 1-hop neighborhood and knows nothing beyond that 1-hop range. The situation is slightly different for the Cell Master and will be explained in a dedicated section.","The protocol features two different routing directions, uplink and downlink. Uplink is used by a meter to send a message to the Cell Master and downlink is used to convey a message from the Cell Master to a meter. These two routing directions use different mechanisms as explained below.","Another routing mechanism is the broadcast, used to convey a message to every endpoint of the cell.","Each packet that is going through the NET layer contains a timestamp of when it was generated. Each time a packet is routed at the NET layer level, the lifetime of the packet is checked against its life expectancy and it is deleted if is too old.","More particularly, to perform an uplink communication, the endpoint has to send its message to the Cell Master. The endpoint does not know where its Cell Master is but it knows that its fathers can reach it. Therefore, it has to send the uplink message to one of its fathers. The protocol should limit its choice to the NET_Nb_of_Fathers_Routing best fathers, based on the SYNC_Merit. It should randomly select one of these fathers with a probability for each father inversely proportional to its SYNC_Merit, and then send the uplink message to that father. Every synchronized and registered father of the cell is suitable for uplink routing.","If the LLC reports a failed transmission (after all the retries), the NET layer will look again in the neighbor table (which is now updated according to the results of the previous transmission attempts) and reselect a random father among the NET_Nb_of_Fathers_Routing best ones, using the same probabilistic selection algorithm as in the first instance. The uplink message is then forwarded to the LLC layer for transmission to the newly selected father. This process continues until the LLC reports a successful transmission or until the endpoint goes to power fail, becomes unsynchronized or switches to a new cell.","When the selected father receives this uplink message, it will proceed in a similar fashion. This process is repeated until the best father is the Cell Master.","Before an Uplink packet is routed to one of the endpoint's fathers, the NET layer check that it is not older than NET_Uplink_Life_Expectancy. If it is older then it is deleted.","In contrast, for a downlink path, that is, sending a message from the Cell Master to a specific endpoint, is a very easy thing as far as endpoints are concerned. Indeed the entire path is indicated in the network header. This path is specified by the Cell Master, which has a complete knowledge of all the endpoints in the cell.","When an endpoint receives a downlink message, it reads its network header and automatically finds the next destination to contact. This is repeated until the final destination is reached. Before forwarding the message to the next node, the endpoint removes its own address in the routing path of the NET header. The endpoint should forward the message to next address in the header, even if this address doesn't match any node in its own neighbor table.","Before a downlink packet is forwarded to the next hop, the NET layer check that it is not older than NET_Downlink_Life_Expectancy. If it is older then it is deleted.","If, for any reason, the next node cannot be reached (after the LLC layer retries), the message has to be sent back to the Cell Master by the uplink path. This message is called a Broken Link message. A Broken Link message is made of:","The original downlink message","The intended final destination address","The NET frame ID of the downlink message","A new NET frame ID for the Broken Link","The Addresses of the missing link.","It will be the task of the Cell Master to find another path, by taking into account network changes that occurred in the mid-time. The Cell Master will then re-send the downlink message if a path to the destination is still available.","There is no acknowledgement at network layer level. If the user of the protocol wants to be sure that its downlink message has reached the final destination, it has to request it in the application layer.","As noted later the Cell Registration Confirmation and the Cell Out Notification are special cases of downlink packets which do not generate a broken link.","A broadcast message is only initiated at the Cell Master level. All the endpoints connected to the cell should receive the broadcast message. In order to simplify this heavy operation in a large cell, the protocol does not guarantee that the message will be delivered to 100% of endpoints and does not provide for an acknowledgement at the network layer level. Upper layers should manage repetition of the message to those that haven't received it. This can be done by addressing the message to each remaining endpoint by a common downlink path. The network layer doesn't either inform upper layers of which endpoints haven't been reached (if it was the case, the network layer would proceed to the repetition itself).","The broadcast technique is based on the fact that each endpoint repeats the broadcast message Number_of_Broacast_Transmissions number of times and each endpoint can receive the broadcast from any other endpoint. For one broadcast message sent by the Cell Master, an endpoint will receive as many replicas as it has neighbors; this mechanism allows a good coverage of the cell. Note that the Cell Master should never accept a broadcast message, as it always generate them.","A filter mechanism is implemented at the network layer level to send only once the broadcast message to the application layer and also to forward it once. A broadcast message number (NET FID) is contained in the NET header to remove messages that have already been received (same mechanism as in the LLC layer). With this duplication detection the broadcast will not be repeated infinitely in the cell.","The duplication detection will work as long as there are less broadcasts being forwarded in the cell than there are spaces in the table of duplication detection. This should normally be the case if the network is used properly. As a failsafe, a timeout mechanism has been added. At initialization of the broadcast, the Cell Master accesses the current Hyperframe Number (HFN) and inserts it into the NET header. When an endpoint in the cell receives this broadcast it should always accept it (after checking if it is not a duplication), but only retransmit it if the broadcast is not too old by comparing the HFN contained into the header and the current HFN. The maximum lifetime of a broadcast in the cell is NET_Broadcast_Life_Expectancy.","The NET layer offers a non-duplication service for:","Uplink path\n\n","Broadcast","Broadcast and Outage Notifications can be relayed using several paths in the network. This redundancy contributes to a better quality of message delivery. But it can also increase drastically the amount of traffic. For other messages using uplink routing mechanism, duplication also happens but less often. Notice that the downlink path is not concerned here as it cannot be duplicated. Using this duplication detection feature with Downlink messages will even degrade performances of the service.","To avoid forwarding the received message several times to the API layer or to the next endpoint, each transmitted message has a NET identification number, NET FID or NET OID. Due to this number, the NET layer knows whether the packet has already been received. Should this happen, the packet is discarded.","At each reception of a message, the message number (NET FID or OID) and the sender address are written in a dedicated table called the NET duplication table (see, for example, present ). This table contains the properties of the NET_EP_Duplication_Table_Size last messages and is managed as a FIFO buffer. If the table is full when a new message comes in, the oldest entry of the table is thrown out as the new one is entered into the table. If the new entry is identical to another entry in the table, this indicates that a duplicate message has been received. In this case the oldest copy is removed from the table as the new one is entered into the table. In this way the information will remain longer in the table.","The Cell Master duplication table size can be extended to NET_CR_Duplication_Table_Size. It will ensure a better filtering before forwarding messages to the API layer, mainly useful for Outage Notifications that can be very numerous in a short period of time. For a Broadcast (coming from the Cell Master), the sender address field should be set to zero. For an Outage Notification, the sender address should correspond to the original sender address specified in the ORG field. In the particular case of a Broken Link, the sender address is specified in the BRKS field. If the node loses synchronization, switches to another cell or experiences a power outage (it could be done at power up), the duplication table should be cleared.","With reference to a Neighbor list, if the knowledge of the 1-hop neighborhood is enough for an endpoint, it is not the case for the Cell Master. This one has to know the content of the cell to compute downlink paths. Therefore, all the endpoints should send regularly their NET Neighbor List using an uplink message.","The Neighbor List is generated from the NET neighbor table. It consists of the NET_Nb_of Endpoints_Neighbor_List best fathers, i.e. fathers with lowest SYNC_Merit, represented by their MAC addresses. Endpoint addresses are sorted, the best one appears first in the list. This information is enough for the Cell Master to route packets to any specific endpoint.","As an option, if the number of fathers present in the neighbor table is inferior to NET_Nb_of Endpoints_Neighbor_List, the Neighbor List can be completed with the best brothers (if they are valid for routing packets). However the downlink path algorithm should be clever enough to detect circular path.","Only synchronized and registered neighbors of the cell can be members of the Neighbor List.","The first Neighbor List is sent NET_Neighbor_List_First_Time after the endpoint becomes synchronized to a cell for a warm start, and NET_Neighbor_List_Min_Period for a cold start.","Neighbor Lists should be updated every time an endpoint is removed from the list or a new endpoint is added to the list. Neighbor Lists are then sent at a period of NET_Neighbor_List_Min_Period if a change occurred in the previous period. If an endpoints changes level this should raise a flag that will trigger the transmission of a Neighbor List at the end of the current period. If an endpoint undergoes a cell switch, then it should be in cold start in its new cell and should apply the corresponding process of registration.","If such a change doesn't occur, Neighbor Lists are sent with a period of NET_Neighbor_List_Max_Period.","A randomization time of \u00b120% should be added to these periods and times to avoid repetitive collisions.","The Cell Master is the only endpoint that can initialize a Broadcast message and in the same way the only one that can't receive one. It should indicate in the NET header the current hyperframe number (HFN) at the creation time.","Part of the advantageous features of the present protocol subject matter relate to a downlink routing mechanism. In particular, the downlink communication represents a transmission from the head of the network to a single node in the mesh network. However, the point is to find a node that could be everywhere but which one must be able to access it in the shortest time.","The following more particularly addresses cell relay functionality in relation to a routing table. To perform a downlink communication, the Cell Master (or relay) needs to have received first a minimal number of Neighbor Lists in order to compute the best path to reach the destination.","As every endpoint in the cell is supposed to have sent information of their best fathers, the Cell Master has the knowledge to reach any endpoint in the cell. It just has to arrange the information it receives inside a routing table. This routing table is updated each time a new Neighbor List (or Broken Link message; see dedicated section) is received.","Because each endpoint knows its fathers, the Cell Master can construct all the possible paths between any endpoint and itself (it is in fact limited by the number of fathers in the Neighbor List but this provides enough possible paths without overloading the Cell Master with too much data to collect and process). The fathers in the Neighbor lists are provided in order starting from the best one. The best path can be determined by choosing the first father in the list starting from the final destination up to the Cell Master.","The table will permanently move, therefore the algorithm needs to check that each hop of the creation, the path does not go through the same node. It could else lead to infinite loop or circular path. If the path reached such case, the algorithm should go reversely in the path and tries with the alternative fathers. If no path is found, the NET layer destroys the packet and reports a failure to the API layer. If there is an issue due to a broken link or circular path, this technique does not guarantee that the new path found will be the second best but it ensures that it will find a path if there is one.","Each time the Cell Master receives an updated Neighbor List, it will use it to update its routing table. It should be noticed that the Cell Master does only need to replace the corresponding entry in the table without re-computing anything.","When the Cell Master needs to send a downlink message to an endpoint, it selects the best path and mentions all the steps (node addresses) of the path in the network header. Then it sends the message to the first endpoint of the path, and this one will forward it to the second, and so on, until the final destination is reached. Every node present in the routing table can be selected for routing.","Finally if no message from an endpoint has been received for NET_Endpoint_TimeOut, the endpoint should be deleted from the table as well as the paths through it. The API layer can also request from the NET layer to remove a specified node from the table.","Present  is an example of a downlink path computation to reach endpoint . The 3 best fathers are mentioned in the Neighbor Lists. Some endpoint that doesn't have 3 fathers put their brothers as alternative paths. Each endpoint's neighbors are here sorted by their SYNC_Merit. The generated path is: 10\u21908\u21907\u21902\u2190CM.","A downlink message follows the path indicated by the Cell Master, but due to the possible delay between the routing table update and this downlink packet, the network configuration can have and some endpoints may not be reachable anymore (power failure, cell switching, obstacles . . . ). When the LLC layer reports a failure to transmit the message to the next destination, the network layer should send back to the Cell Master a Broken Link. If, due to hardware limitation, there is no space into the memory to allocate the broken link in the up-going message buffer, this one should be destroyed.","When the Broken Link arrives at the Cell Master, this one should update its routing table by removing the link. The Downlink is then re-sent if a path still exists. This Broken Link mechanism does not apply to the Cell Registration confirmation or to the Cell Out Notification; for details see the cell size management section herein.","Present  is a CR Routing Table for a Downlink routing example. When the number of entries in the routing table changes bracket, the Cell Master updates its Cell Size Indicator according to the per present  and provides this information to the MAC layer. The MAC layer will indicate this information in its header and propagate it through the cell. When the cell is full, i.e. when the CSI takes its maximum value; no endpoint can request to join the cell.","When the routing table reaches NET_Max_Nb_of_EPs entries, the table and the cell are considered full. In this case every new Neighbor List that arrives at the Cell Master should be used to find a path to send a NET Cell Out Notification to this node, and then deleted. The node that receives this NET Cell Out Notification should acknowledge the packet at MAC layer and leave the cell after a couple of time slots (to make sure the acknowledgment was successfully received).","The NET Cell Out Notification is a particular case of a downlink message with no payload. It should be treated as a downlink message except that no Broken Link message should be sent if a link is broken on the path. This is justified by the fact that the Cell Master has destroyed all information relative to this endpoint and therefore will not be able to find an alternative path. Note that the NET Cell Out Notification can also be used by upper management software to suppress a selected endpoint in a cell. The NET Cell Registration Confirmation should not also trigger a broken link if the message fails to be delivered. The reason is that the Cell Registration process has its own retry mechanism which handles such failures. When the Cell Master receives a Cell Leaving Notification it should remove the corresponding endpoint from its routing table and update its Cell Size Indicator.","The table of present  summarizes actions in the Cell Master NET layer when the routing table is full or when a node is not in the routing table.","The following relates more particularly to outage notification transport and to the functional area of cell registration in accordance with present subject matter. As it is additionally explained in relation to the MAC layer section, an EP can hear, at MAC level, that a neighbor experiences a power outage. When this event occurs, the MAC layer indicates it to the Net layer, with the outage ID and the time when the message has been received as parameters. As a consequence, the Net layer should build a Net outage message, with all these parameters (Neighbor address, Outage ID, and Outage Time), and send it to the Cell relay as a normal uplink message. When the NET outage message reaches the Cell Relay, the message is given to the API layer.","When an endpoint is not NET registered, the API layer can't send any packet. The RFLAN should inform the API layer when the endpoint becomes registered or deregistered (this last case happens when the endpoint goes back to discovery phase or switches cell). Note that the Cell Master is always considered NET registered.","Once the Endpoint is NET registered, the API layer is authorized to communicate and it can start its own registration process.","When an endpoint switches to another cell, the NET and the API layers will need to register with this new cell. The NET layer informs first the API layer that it is no longer registered to a cell and cannot send packets. The process following is similar to the connection to a cell from the discovery phase.","The Linknet protocol will be implemented in an architecture that will have limited storage capacity. There is thus a non negligible probability that the allocated memory to save messages prior to be sent can be full. Each time the API layer asks to send a message, the NET layer confirms or refuses the request. It means that the NET layer can destroy the packet to send and report a failure to the API layer. The API layer should then be in charge of postponing its request and keep the packet into its own memory.","The Cell Master NET layer can also report a failure to the API layer if the path to the destination can't be computed or if the destination is not in the routing table.","With respect to the NET Frame, it should be understood that the network message is divided into two parts:\n\n","Present  illustrates all the fields that can be present at NET level. The field and different message structures are otherwise described herein.","In the Common Section of the Network Header, there are the following aspects, with present  providing a Table which presents various facets regarding the NET Frame type information:","LV, Layer Version:","The version of the network layer","FT, Frame Type:","The network frame type","In the Dynamic Section of the Network Header, there are the following aspects, some of which fields don't appear in every message (hence, the Dynamic nature of this Header Section). They are described here in general terms, with other details of various of the message types otherwise discussed herein.","ORG, Original Sender:\n\n","FID, Frame ID:\n\n","PL, Path Length:\n\n","PATH:\n\n","RSD, Reserved:\n\n","NBN, Number of Neighbors:\n\n","NA, Neighbor Address:\n\n","BRK S, BRoKen link Sender:\n\n","BRK D, BRoKen link Destination:\n\n","HFN, HyperFrame Number:\n\n","DW FD, Final Destination:\n\n","DW FID, DoWnlink Frame ID;\n\n","OID, Outage ID:\n\n","OT, Outage Time:\n\n","With further reference to the Frame Body, and related Application PDU (APIPDU), it contains information relative to the application layer. It is the final message the protocol delivers to application layer. It can be delivered to the destination endpoint or to the cell relay.","The following more particularly relates to NET messages. The NET header length for an uplink message is 8 bytes, as represented by present . The Trace packet is used for debugging purpose. However, the NET header length for a downlink path is 5 bytes plus 4 bytes times the path length, as represented by present . This does not include the next destination which is passed in parameter to be placed in the MAC header. The ORG field is not included since all downlink messages originate in the cell relay. Additionally, per present , HOP-N is the address of the final destination of the downlink message, while HOP-1 is the address of the next destination of the downlink message.","When an endpoint wants to send its Neighbor List to the Cell Master, it inserts it at the location of the frame body. The Cell Registration Request uses the same format but with a different Frame Type. As represented by present , the Neighbor List or Cell Registration Request length at NET level is 21 bytes.","It is a combination of an uplink message and a Neighbor List message. As represented by present , the NET header length for an uplink with Neighbor List message is 21 bytes.","As represented by present , the broadcast NET header length is 4 bytes. HFN field refers to the MAC hyperframe number when the Cell Master initializes the broadcast.","When the Cell Master wants to reject one node from the cell, it sends a Cell Out Notification to this node. This message length is 5 bytes plus 4 bytes times the path length. As represented by present , the Cell registration Confirmation uses the same packet with a different frame type to confirm to a node that it is accepted in the Cell.","If during a downlink transmission an endpoint does not manage to forward the message to the next endpoint then a Broken Link is reported. The Broken Link message consists in the addresses of the 2 EPs defining the Broken Link and the original message (which was not stored in the Cell Master). This Broken Link message will be used by the Cell Master to update its routing table and compute a new best path. As represented by present , the NET header length of the Broken Link message is 18 bytes.","If an EP hears an outage message (at a MAC level) from an EP which experiences a power outage, it timestamps the outage notification with its local time using ITP format. It should then create a (NET) outage message and send it to the Cell Master in the same way as an uplink message. The OID is the same as in the original MAC outage message. And the OT field is the ITP timestamp of the reception of the (MAC) outage notification. As represented by present , the NET header length of the outage message is 11 bytes.","The Cell Leaving Notification is sent by an endpoint just before leaving a cell. This informs the Cell Master that this endpoint can be removed from the routing table and the CSI adjusted accordingly. As represented by present , the Cell Leaving Notification NET length is 8 bytes.","With reference to NET interfaces and services, it will be appreciated that the Network layer proposes a variety of different services, as illustrated in significant detail by the subject matter included in present . The network layer is in charge of routing. The network layer knows the 1-hop neighborhood and can make a decision as to the path to take to forward a packet in the Uplink or Downlink direction. If the message has arrived at its destination, either in an endpoint or a cell relay (Cell Master), it gives it to the API layer.","The following more particularly relates to functionality of the present protocol subject matter with reference to NET Requests.","With an objective to send a message to one destinations, NET_Request_Send_Mono_Data, there is use of input arguments: APIPDU, destination address. The operation may be described as the API layer asks the NET layer to send a message to the Cell Master. For the Cell Master: The API layer asks the NET layer to send a message to one particular endpoint.","With an objective to send a broadcast message to the entire cell, as far as Cell Relay only, NET_Request_Send_Broadcast, there is use of the requisite input arguments: APIPDU. The operation may be described as the API layer requests the NET layer to send a message to the entire cell.","With an objective to send an RITP broadcast to the entire cell, as far as Cell Relay only, NET_Request_Send_ITP, there is no use of any input arguments. The operation may be described that the API layer requests the NET layer to send an ITP message to the entire cell. This request follows the same approach as a NET_Request_Send_Broadcast, except that there is no NETPDU. The MAC layer will be in charge of time stamping the message.","With an objective to update the RITP of the MAC layer, as far as the Cell Relay (Cell Master) only, NET_Request_Update_ITP, there is use of requisite input arguments: Absolute ITP time stamp. The operation may be described as the API layer requests the MAC layer to update its RITP with a new value of ITP. This request has priority over all other requests and is forwarded directly to the LLC layer.","With an objective to measure the medium interference level on a specified channel and its time auto-correlation function, NET_Request_Environment_Analysis_Auto-Correlation, there is use of input arguments: Channel number, Number of samples. The operation may be described as a request that is forwarded directly to the LLC layer.","With an objective to measure the medium interference level on three specified channels and its probability density function, NET_Request_Environment_Analysis_PDF, there is use of requisite input arguments: Channel numbers (3), Max value of counter. The operation may be described as a request that is forwarded directly to the LLC layer.","With an objective to give to the MAC layer the information whether a cell is authorized or not, NET_Request_Cell_Authorization, there is use of requisite input arguments: Cell Address and Cell Status. The operation may be described as a request that is forwarded directly to the LLC layer.","With an objective to give to remove a node from the routing table, as far as the Cell Relay (Cell Master) only, NET_Request_Remove_Node, there is use of requisite input arguments: Node Address. The operation may be described as the API layer can inform the Linknet layers that a node is not belonging to the cell anymore. The NET layer will so remove the node from the routing table and update the number of endpoint in the cell.","With an objective to send a Cell Out notification to node, as far as the Cell Relay (Cell Master) only, NET_Request_Eject_Node, there is use of requisite input arguments: Node Address. The operation may be described as a request that the API layer can request the Net layer to get a node out of the cell. The NET layer will then send a Cell Out Notification to this node and remove it from the routing table.","The following more particularly relates to functionality of the present protocol subject matter with reference to NET Confirmations.","With an objective to answer a NET_Request_Send_Mono_Data, NET_Request_Send_Broadcast and NET_Request_Send_ITP, NET_Confirmation_Send_Mono_Data, NET_Confirmation_Send_Broadcast and NET_Confirmation_Send_ITP, there is use of requisite output arguments: Status. The operation may be described as giving the status of the request. It can be Message transmitted, Message failed to be transmitted, Buffer Full, Path to destination not found or any other kinds of errors.","With an objective to answer NET_Request_Update_ITP, as far as Cell Relay only, NET_Confirmation_Update_ITP, there is use of requisite output arguments: Status. The operation may be described as it gives the status of the request.","With an objective to answer NET_Request_Environment_Analysis_Auto-Correlation, NET_Confirmation_Environment_Analysis_Auto-Correlation, there is use of requisite output arguments: average RSSI and RSSI auto-correlation function values. The operation may be described as a forward of LLC_Confirmation_Environment_Analysis_Auto-Correlation from the LLC layer to the API layer.","With an objective to answer NET_Request_Environment_Analysis_PDF, NET_Confirmation_Environment_Analysis_PDF, there is the use of requisite output arguments: RSSI PDF values for the three requested channels (3\u00d724 values). The operation may be described as a forward of LLC_Confirmation_Environment_Analysis_PDF from the LLC layer to the API layer.","With an objective to answer NET_Request_Cell_Authorization, NET_Confirmation_Cell_Authorization, there is use of requisite output arguments: Status. The operation may be described as a forward of LLC_Confirmation_Cell_Authorization from the LLC layer to the API layer.","With an objective to answer a NET_Request_Remove_Node, as far as Cell Relay (Cell Master) only, NET_Confirmation_Remove_Node, there is use of requisite output arguments: Status. The operation may be described as it gives the status of the request.","With an objective to answer a NET_Eject_Remove_Node, as far as Cell Relay (Cell Master) only, NET_Confirmation_Eject_Node, there is use of requisite output arguments: Status. The operation may be described as it gives the status of the request.","The following more particularly relates to functionality of the present protocol subject matter with reference to NET Indications.","With an objective to indicate to the API layer that a message was received for it and provide this message, NET_Indication_Received, there is use of output arguments: APIPDU. The operation may be described as when a message reaches its final destination, the NET layer gives the message to the API layer.","With an objective to update the ITP of the API layer, as far as the Cell Relay only, NET_Indication_ITP_Update, there is use of output arguments: Absolute ITP Timestamp. The operation may be described as a direct forward of the LLC_Indication_ITP_Update from the LLC layer to the API layer. This indication has priority over all other indications.","With an objective to indicate to the above layer the NET state, NET_Indication_State, there is use of requisite output arguments: State and Cell address. The operation may be described as the NET layer indicates to API layer whether the endpoint is synchronized and registered with a cell. Once it is, the API layer gets the rights to use the network.","With an objective to indicate to the API layer that a outage notification has been received, as far as Cell Relay only, NET_Indication_Outage_Received, there is use of requisite output arguments: EP address, Outage ID and Outage Time. The operation may be described as when a Cell relay (or Cell Master) receives an outage notification through the RF LAN, it should give it to the API layer. The API layer will report to the collection engine using C12.22 format.","The following relates to stability analysis of the crystal drift compensation algorithm and indicates how to compute the filter coefficients. To discuss the behavior of the drift correction process, present  provides a diagrammatical model of the feedback control loop.","With more specific reference to such , TS_Length_Cell is the default time slot length of the cell as seen from the endpoint (that is, as measured with the endpoint's own time reference). Any discrepancy between the endpoint time reference and the cell time reference will result in a difference between TS_Length and TS_Length_Cell. Considering the loop reaction to a sudden change in TS_Length_Cell, one can adjust the filter coefficients to make this response well-behaved.","For such analytical purposes, present  is a simplification of the diagram of present . For such simplification, the represented loop may be described by the following recurrence equations:\n\n()=()+(1)\n\n()=(1)+()\n\n()=TS_Length_Cell\u2212()\n","As is well understood by those of ordinary skill in the art, the z-transforms of these equations are:",{"@attributes":{"id":"p-0947","num":"1154"},"i":["X","z","AX","z","Bz","X","z","T","z","z","T","z","X","z","X","z","T","z"],"sub":["2","1","2","slot","slot","2","1","slot"],"sup":["\u22121","\u22121"],"br":[{},{}],"in-line-formulae":[{},{},{},{}]},"Solving for Xand then for T:",{"@attributes":{"id":"p-0949","num":"1156"},"maths":[{"@attributes":{"id":"MATH-US-00041","num":"00041"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"msub":{"mi":"X","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"z"}},"mo":"=","mfrac":{"mrow":[{"msub":{"mi":"AX","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"z"}},{"mn":"1","mo":"-","msup":{"mi":"Bz","mrow":{"mo":"-","mn":"1"}}}]}}}},{"@attributes":{"id":"MATH-US-00041-2","num":"00041.2"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"msub":{"mi":["T","slot"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"z"}},"mo":["=","\u2062"],"mi":{},"mfrac":{"mrow":[{"msub":{"mi":"X","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"z"}},{"mn":"1","mo":"-","msup":{"mi":"z","mrow":{"mo":"-","mn":"1"}}}]}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mfrac":{"mrow":[{"msub":{"mi":"AX","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"z"}},{"mrow":[{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","msup":{"mi":"z","mrow":{"mo":"-","mn":"1"}}}},{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","msup":{"mi":"Bz","mrow":{"mo":"-","mn":"1"}}}}],"mo":"\u2062"}]}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mfrac":{"mrow":[{"mi":["A","TS_Length","_Cell"],"mo":["\u00d7","\u2062"]},{"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","msup":{"mi":"z","mrow":{"mo":"-","mn":"1"}}}},{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","msup":{"mi":"Bz","mrow":{"mo":"-","mn":"1"}}}}],"mo":"\u2062"},"mo":"+","mi":"A"}]}}}}]}}}]},"The final expression for Tis:",{"@attributes":{"id":"p-0951","num":"1158"},"maths":{"@attributes":{"id":"MATH-US-00042","num":"00042"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"msub":{"mi":["T","slot"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"z"}},"mo":"=","mfrac":{"mrow":[{"mi":["A","TS_Length","_Cell"],"mo":["\u00d7","\u2062"]},{"mn":"1","mo":["+","-","+"],"mi":"A","mrow":{"mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"+","mi":"B"}},"mo":"\u2062","msup":{"mi":"z","mrow":{"mo":"-","mn":"1"}}},"msup":{"mi":"Bz","mrow":{"mo":"-","mn":"2"}}}]}}}}},"And the transfer function of the loop is:",{"@attributes":{"id":"p-0953","num":"1160"},"maths":{"@attributes":{"id":"MATH-US-00043","num":"00043"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":[{"mrow":[{"msub":{"mi":["T","slot"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"z"}},{"mi":["TS_Length","_Cell"],"mo":"\u2062"}]},{"mfrac":{"mi":"A","mrow":{"mn":"1","mo":"+","mi":"A"}},"mrow":{"mn":"1","mo":["-","+"],"mrow":[{"mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mn":"1","mo":"+","mi":"B"},{"mn":"1","mo":"+","mi":"A"}]}},"mo":"\u2062","msup":{"mi":"z","mrow":{"mo":"-","mn":"1"}}},{"mrow":{"mo":["(",")"],"mfrac":{"mi":"B","mrow":{"mn":"1","mo":"+","mi":"A"}}},"mo":"\u2062","msup":{"mi":"z","mrow":{"mo":"-","mn":"2"}}}]}}],"mo":"="}}}},"This is a second order low-pass transfer function. To look at the dynamic behavior, one finds the poles of this function, written here in the standard form:",{"@attributes":{"id":"p-0955","num":"1162"},"maths":[{"@attributes":{"id":"MATH-US-00044","num":"00044"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mn":"1","mrow":{"mn":"1","mo":["+","+"],"mrow":[{"msub":{"mi":"b","mn":"1"},"mo":"\u2062","msup":{"mi":"z","mrow":{"mo":"-","mn":"1"}}},{"msub":{"mi":"b","mn":"2"},"mo":"\u2062","msup":{"mi":"z","mrow":{"mo":"-","mn":"2"}}}]}}}},{"@attributes":{"id":"MATH-US-00044-2","num":"00044.2"},"math":{"@attributes":{"overflow":"scroll"},"mi":"where"}},{"@attributes":{"id":"MATH-US-00044-3","num":"00044.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":"b","mn":"1"},"mo":"=","mrow":{"mo":"-","mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mn":"1","mo":"+","mi":"B"},{"mn":"1","mo":"+","mi":"A"}]}}}},{"msub":{"mi":"b","mn":"2"},"mo":"=","mrow":{"mo":["(",")"],"mfrac":{"mi":"B","mrow":{"mn":"1","mo":"+","mi":"A"}}}}],"mo":[",","\u2062"],"mstyle":{"mtext":{}}}}}]},"The zeros of z+bz+bare",{"@attributes":{"id":"p-0957","num":"1164"},"maths":{"@attributes":{"id":"MATH-US-00045","num":"00045"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":"z","mrow":{"mn":["1","2"],"mo":","}},"mo":"=","mrow":{"mrow":[{"mo":"-","mfrac":{"msub":{"mi":"b","mn":"1"},"mn":"2"}},{"mfrac":{"mi":"j","mn":"2"},"mo":"\u2062","mrow":{"msqrt":{"mrow":{"mrow":{"mn":"4","mo":"\u2062","msub":{"mi":"b","mn":"2"}},"mo":"-","msubsup":{"mi":"b","mn":["1","2"]}}},"mo":"."}}],"mo":"\u00b1"}}}},"br":{},"sub":["1","2 "]},{"@attributes":{"id":"p-0958","num":"1165"},"maths":{"@attributes":{"id":"MATH-US-00046","num":"00046"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":[{"mi":"Re","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":"z","mrow":{"mn":["1","2"],"mo":","}}}},{"mo":"-","mfrac":{"msub":{"mi":"b","mn":"1"},"mn":"2"}}],"mo":"="},{"msup":{"mrow":{"mo":["\uf603","\uf604"],"msub":{"mi":"z","mrow":{"mn":["1","2"],"mo":","}}},"mn":"2"},"mo":"=","msub":{"mi":"b","mn":"2"}}],"mo":[",","\u2062"],"mstyle":{"mtext":{}}}}}},"A simple time-saving approach to evaluate the filter coefficients is to map the poles of the discrete-time transfer function to the poles of the corresponding continuous-time transfer function. These poles are given by s=\u2212\u03b6\u03c9\u00b1j\u03c9\u221a{square root over (1\u2212\u03b6)}, where \u03b6 is the damping factor and \u03c9is the angular frequency of the equivalent continuous-time system. These poles are related to the poles in the z-plane by z=e, leading to the following expression for the poles in the z-plane:",{"@attributes":{"id":"p-0960","num":"1167"},"maths":{"@attributes":{"id":"MATH-US-00047","num":"00047"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":"z","mrow":{"mn":["1","2"],"mo":","}},"mo":"=","mrow":{"msup":[{"mi":"\u2147","mrow":{"mrow":{"mo":"-","msub":{"mi":"\u03b6\u03c9","mn":"0"}},"mo":"\u2062","mi":"T"}},{"mi":"\u2147","mrow":{"mrow":{"mo":"\u00b1","msub":{"mi":"j\u03c9","mn":"0"}},"mo":["\u2062","\u2062"],"mi":"T","msqrt":{"mrow":{"mn":"1","mo":"-","msup":{"mi":"\u03b6","mn":"2"}}}}}],"mo":"\u2062"}}}}},"Thereafter, one may write the transfer function coefficients in terms of the continuous-time system parameters:\n\n=\u22122cos(\u03c9\u221a{square root over (1\u2212\u03b6)}) and .\n","Solving for A and B gives:",{"@attributes":{"id":"p-0963","num":"1170"},"maths":{"@attributes":{"id":"MATH-US-00048","num":"00048"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":"\u2003","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mi":"A","mo":"=","mrow":{"mfrac":{"msup":{"mi":"\u2147","mrow":{"mn":"2","mo":["\u2062","\u2062"],"msub":{"mi":"\u03b6\u03c9","mn":"0"},"mi":"T"}},"mrow":{"mrow":{"mn":"2","mo":["\u2062","\u2062"],"msup":{"mi":"\u2147","mrow":{"msub":{"mi":"\u03b6\u03c9","mn":"0"},"mo":"\u2062","mi":"T"}},"mrow":{"mi":"cos","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":"\u03c9","mn":"0"},"mo":["\u2062","\u2062"],"mi":"T","msqrt":{"mrow":{"mn":"1","mo":"-","msup":{"mi":"\u03b6","mn":"2"}}}}}}},"mo":"-","mn":"1"}},"mo":"-","mn":"1"}}}},{"mtd":{"mrow":{"mi":"B","mo":"=","mfrac":{"mn":"1","mrow":{"mrow":{"mn":"2","mo":["\u2062","\u2062"],"msup":{"mi":"\u2147","mrow":{"msub":{"mi":"\u03b6\u03c9","mn":"0"},"mo":"\u2062","mi":"T"}},"mrow":{"mi":"cos","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":"\u03c9","mn":"0"},"mo":["\u2062","\u2062"],"mi":"T","msqrt":{"mrow":{"mn":"1","mo":"-","msup":{"mi":"\u03b6","mn":"2"}}}}}}},"mo":"-","mn":"1"}}}}}]}}}}}},"The relevant design parameter is the number of samples used to compute the average (actually it is a low-pass filter and not an average). This is arbitrarily defined as the number of samples needed to reach the overshoot of the step response:",{"@attributes":{"id":"p-0965","num":"1172"},"maths":{"@attributes":{"id":"MATH-US-00049","num":"00049"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["N","avg"]},"mo":"=","mrow":{"mfrac":[{"mrow":[{"mi":["oscillation","period"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mn":"2","mo":"\u2062","mi":"T"}]},{"mi":"\u03c0","mrow":{"mi":"T","mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":"\u03c9","mn":"0"},"msqrt":{"mrow":{"mn":"1","mo":"-","msup":{"mi":"\u03b6","mn":"2"}}}}}],"mo":"="}}}}},"The following equations are obtained to compute the filter coefficients in terms of Nand the damping factor \u03b6:",{"@attributes":{"id":"p-0967","num":"1174"},"maths":{"@attributes":{"id":"MATH-US-00050","num":"00050"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":"\u2003","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":{"mrow":{"mi":"A","mo":"=","mrow":{"mfrac":{"mrow":[{"mi":"exp","mo":["(",")"],"mfrac":{"mrow":[{"mn":"2","mo":"\u2062","mi":"\u03c0\u03b6"},{"msub":{"mi":["N","avg"]},"mo":"\u2062","msqrt":{"mrow":{"mn":"1","mo":"-","msup":{"mi":"\u03b6","mn":"2"}}}}]}},{"mrow":{"mn":"2","mo":["\u2062","\u2062"],"mrow":[{"mi":"exp","mo":["(",")"],"mfrac":{"mi":"\u03c0\u03b6","mrow":{"msub":{"mi":["N","avg"]},"mo":"\u2062","msqrt":{"mrow":{"mn":"1","mo":"-","msup":{"mi":"\u03b6","mn":"2"}}}}}},{"mi":"cos","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mi":"\u03c0","msub":{"mi":["N","avg"]}}}}]},"mo":"-","mn":"1"}]},"mo":"-","mn":"1"}}}},{"mtd":{"mrow":{"mi":"B","mo":"=","mfrac":{"mn":"1","mrow":{"mrow":{"mn":"2","mo":["\u2062","\u2062"],"mrow":[{"mi":"exp","mo":["(",")"],"mfrac":{"mi":"\u03c0\u03b6","mrow":{"msub":{"mi":["N","avg"]},"mo":"\u2062","msqrt":{"mrow":{"mn":"1","mo":"-","msup":{"mi":"\u03b6","mn":"2"}}}}}},{"mi":"cos","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mi":"\u03c0","msub":{"mi":["N","avg"]}}}}]},"mo":"-","mn":"1"}}}}}]}}}}}},"For example, N=16.5 and \u03b6=0.7 give A= 1\/16 and B=0.732.","Present  illustrates the step response of such loop in reaction to a change in the cell time slot length from 100 ms to 110 ms. The system reaches a stable value after about 20 resynchronizations with the expected overshoot of 4.6%. The following default values for the MAC layer parameters may be used for one preferred exemplary embodiment:",{"@attributes":{"id":"p-0970","num":"1177"},"maths":[{"@attributes":{"id":"MATH-US-00051","num":"00051"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":["MAC_Xdrift","_Filter","_A"],"mo":["\u2062","\u2062"]},"mo":"=","mfrac":{"mn":["1","16"]}}}},{"@attributes":{"id":"MATH-US-00051-2","num":"00051.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":["MAC_Xdrift","_Filter","_B"],"mo":["\u2062","\u2062"]},"mo":"=","mn":"0.732"}}}]},"The use of minimal propagation delay path to optimize a mesh network is another present advantageous feature set. In a mesh network, a method is presently proposed to compute to propagation delay between any node of the network and the root node of the network. This propagation delay is then used as criterion to select the best path among several in the network.","The stability and performance of the mesh network is based on its ability to self-optimize and to self-heal its topology. This self-optimization of the network is also fundamental to balance and limit the traffic load. It is therefore important to provide the protocol with a good path selection algorithm. The best path should have the following properties:","The best path should have the shortest latency from transmitter to receiver.","The best path should minimize the number of retransmissions.","The best path should cause as few interference as possible.","The present subject matter is to use the \u201cshortest path\u201d criterion to choose the best path among several. The shortest path is here defined as the path with the shortest average propagation delay. Reference is made herein to the diagrammatical illustrations of present , B, and C.","When a communication attempt from node A to node B fails, node A retransmits the message a second time or as many times as necessary to make the transmission successful. For practical purposes the number of retransmission attempts is limited to some maximum value in order to avoid losing time on a broken link. The average time spent to transmit a message from node A to node B is called in this protocol the local propagation delay (LPD) from A to B. It is straightforward to extend this concept to a more complex path. For instance the propagation delay between nodes A and D along the path ABCD (see present ) is the sum of the propagation delays from A to B, B to C and C to D.","In order to avoid using too much memory in a node, each node is only aware of its immediate neighbors and therefore cannot directly make the sum of all the propagation delays all the way to the root node. To solve this problem each node in the network will compute two kinds of delays: the local propagation delay (LPD) and the global propagation delay (GPD). A node will compute the LPD for each one if its neighboring nodes in the direction of the network root. The GPD of a node is defined as the shortest total propagation delay from the node all the way to the root node of the network. Here shortest means that if there are several possible paths from a node to the root node, the one with the shortest propagation delay is selected and used to define the node's global propagation delay (GPD).","As an example, for the network illustrated in present , the GPD from A to the root will be:\n\nGPD()=Min{[LPD()+LPD()],[LPD()+LPD()]}\n","To make the GPD computation possible with only the knowledge of the immediate neighborhood, the GPD information is propagated step by step from the root to the nodes.","As an example, for the network illustrated in present , the GPD from A to the root will be computed in this way:\n\nGPD()=Min{[LPD()+GPD()],[LPD()+GPD()]},\n","where GPD(A) is the total propagation delay from A to the root and GPD(B) is the total propagation delay from B to the root.","The detailed operations to be performed inside a node are then:\n\n","Mathematical details of such present subject matter may be outlined as follows. If we consider a single hop (point-to-point) link, in a collision free environment the average propagation delay D will be given by:\n\n,\n\nwhere Tis the time needed by a packet to travel from the transmitter to the receiver.\n","Considering the effect of collisions on the average propagation delay means considering all the possible cases: no collision occurred, one collision occurred, two collisions, and so on. The propagation delay will be given by:\n\n+()(1\u2212)+(+2)(1\u2212)\n\nHere P is the packet success rate and Tis the wait time between retransmissions.\n","To keep the further derivation simple, one may assume that this time is constant. The expression can be factored in this way:\n\n1+(1\u2212)+(1\u2212)(1\u2212)[1+2(1\u2212)+3(1\u2212). . . ]\n","Substituting the sum of the geometric series:",{"@attributes":{"id":"p-0988","num":"1199"},"maths":[{"@attributes":{"id":"MATH-US-00052","num":"00052"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mn":"1","mo":["+","+","+","+"],"mi":["x","\u2026"],"msup":[{"mi":"x","mn":"2"},{"mi":"x","mn":"3"}]},"mo":"=","mfrac":{"mn":"1","mrow":{"mn":"1","mo":"-","mi":"x"}}}}},{"@attributes":{"id":"MATH-US-00052-2","num":"00052.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":{"mn":"1","mo":["+","+","+"],"mrow":[{"mn":"2","mo":"\u2062","mi":"x"},{"mn":"3","mo":"\u2062","msup":{"mi":"x","mn":"2"}}],"mi":"\u2026"},"mo":"=","mfrac":{"mn":"1","msup":{"mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","mi":"x"}},"mn":"2"}}},"mo":","}}}],"br":{}},{"@attributes":{"id":"p-0989","num":"1200"},"maths":{"@attributes":{"id":"MATH-US-00053","num":"00053"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"D","mo":"=","mrow":{"msub":{"mi":["T","d"]},"mo":"+","mrow":{"msub":{"mi":["T","r"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mrow":{"mn":"1","mo":"-","mi":"P"},"mi":"P"}}}}}}}},"Due to the constantly changing environment, this average propagation delay value should preferably be updated after each use of any given link. The expression of the average propagation delay as a function of the link utilization number n is written as follows:",{"@attributes":{"id":"p-0991","num":"1202"},"maths":{"@attributes":{"id":"MATH-US-00054","num":"00054"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"D","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},{"msub":{"mi":["T","d"]},"mo":"+","mrow":{"msub":{"mi":["T","r"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mn":"1","mo":"-","mrow":{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}},{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}]}}}}],"mo":"="}}}},"This delay can be split in a static part and dynamic part:\n\n()=(),\n\nwhere D(n) is the part of the propagation delay due to retransmissions, normalized to the retransmission wait time. D(n) is directly related to the packet success rate by:\n",{"@attributes":{"id":"p-0993","num":"1204"},"maths":{"@attributes":{"id":"MATH-US-00055","num":"00055"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"msub":{"mi":["D","r"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},"mo":"=","mfrac":{"mrow":[{"mn":"1","mo":"-","mrow":{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}},{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}]}}}}},"After each packet transmission attempt on a given link, the packet success rate P(n) is updated with a sliding average as shown below:",{"@attributes":{"id":"p-0995","num":"1206"},"maths":{"@attributes":{"id":"MATH-US-00056","num":"00056"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},{"mfrac":{"mrow":{"mi":"PS","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},"msub":{"mi":["N","av"]}},"mo":"+","mrow":{"mfrac":{"mrow":{"msub":{"mi":["N","av"]},"mo":"-","mn":"1"},"msub":{"mi":["N","av"]}},"mo":"\u2062","mrow":{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}}}}],"mo":"="},"mo":","}}},"br":{},"sub":"av "},{"@attributes":{"id":"p-0996","num":"1207"},"maths":{"@attributes":{"id":"MATH-US-00057","num":"00057"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"PS","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},{"mo":"{","mtable":{"mtr":[{"mtd":[{"mn":"0"},{"mrow":{"mi":["if","transmission","n","failed"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}]},{"mtd":[{"mn":"1"},{"mrow":{"mi":["if","transmission","n","succeeded"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}]}]}}],"mo":"="}}}},"From the PSR update equation, one can derive an equation to update the propagation delay:",{"@attributes":{"id":"p-0998","num":"1209"},"maths":{"@attributes":{"id":"MATH-US-00058","num":"00058"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":["D","r"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},{"mrow":[{"mfrac":{"mn":"1","mrow":{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}},"mo":"-","mn":"1"},{"mfrac":{"mn":"1","mrow":{"mfrac":{"mrow":{"mi":"PS","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},"msub":{"mi":["N","av"]}},"mo":"+","mrow":{"mfrac":{"mrow":{"msub":{"mi":["N","av"]},"mo":"-","mn":"1"},"msub":{"mi":["N","av"]}},"mo":"\u2062","mrow":{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}}}}},"mo":"-","mn":"1"}],"mo":"="}],"mo":"="}}},"br":{}},{"@attributes":{"id":"p-0999","num":"1210"},"maths":{"@attributes":{"id":"MATH-US-00059","num":"00059"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},"mo":"=","mfrac":{"mn":"1","mrow":{"mn":"1","mo":"+","mrow":{"msub":{"mi":["D","r"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}}}}}},"br":{}},{"@attributes":{"id":"p-1000","num":"1211"},"maths":{"@attributes":{"id":"MATH-US-00060","num":"00060"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"msub":{"mi":["D","r"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},{"mfrac":{"mn":"1","mrow":{"mfrac":{"mrow":{"mi":"PS","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},"msub":{"mi":["N","av"]}},"mo":"+","mrow":{"mfrac":[{"mrow":{"msub":{"mi":["N","av"]},"mo":"-","mn":"1"},"msub":{"mi":["N","av"]}},{"mn":"1","mrow":{"mn":"1","mo":"+","mrow":{"msub":{"mi":["D","r"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}}}}],"mo":"\u2062"}}},"mo":"-","mn":"1"}],"mo":["=","\u2062"],"mi":{}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mrow":{"mfrac":{"mrow":[{"msub":{"mi":["N","av"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"+","mrow":{"msub":{"mi":["D","r"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}}}}},{"mrow":{"mrow":[{"mi":"PS","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},{"mo":["(",")"],"mrow":{"mn":"1","mo":"+","mrow":{"msub":{"mi":["D","r"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}}}}],"mo":"\u2062"},"mo":["+","-"],"msub":{"mi":["N","av"]},"mn":"1"}]},"mo":"-","mn":"1"}}}}]}}}},"The equations to update the propagation delay of any link are then:",{"@attributes":{"id":"p-1002","num":"1213"},"maths":{"@attributes":{"id":"MATH-US-00061","num":"00061"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":["D","r"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},{"mo":"{","mtable":{"mtr":[{"mtd":[{"mfrac":{"mrow":[{"mrow":{"msub":{"mi":["N","av"]},"mo":"\u2062","mrow":{"msub":{"mi":["D","r"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}}},"mo":"+","mn":"1"},{"msub":{"mi":["N","av"]},"mo":"-","mn":"1"}]}},{"mrow":{"mrow":{"mi":"if","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mi":"PS","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}},"mo":"=","mn":"0"}}]},{"mtd":[{"mfrac":{"mrow":[{"mrow":[{"mo":["(",")"],"mrow":{"msub":{"mi":["N","av"]},"mo":"-","mn":"1"}},{"msub":{"mi":["D","r"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}}],"mo":"\u2062"},{"mrow":{"msub":{"mi":["D","r"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}},"mo":"+","msub":{"mi":["N","av"]}}]}},{"mrow":{"mrow":{"mi":"if","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mi":"PS","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}},"mo":"=","mn":"1"}}]}]}}],"mo":"="}}}},"If a transmission attempt fails, we use the first equation; if it succeeds, we use the second one. This can be easily extended to a multi-hop path in the following way:",{"@attributes":{"id":"p-1004","num":"1215"},"maths":{"@attributes":{"id":"MATH-US-00062","num":"00062"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"D","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},{"mrow":[{"msub":[{"mi":["N","hop"]},{"mi":["T","d"]}],"mo":"\u2062"},{"msub":{"mi":["T","r"]},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"k","mo":"=","mn":"1"},"msub":{"mi":["N","hop"]}},"mo":"\u2062","mrow":{"msub":{"mi":"D","mrow":{"mi":["r","k"],"mo":","}},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}}}],"mo":"+"}],"mo":"="}}},"br":{}},{"@attributes":{"id":"p-1005","num":"1216"},"maths":{"@attributes":{"id":"MATH-US-00063","num":"00063"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":{"mi":"D","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},"msub":{"mi":["T","r"]}},"mo":"=","mrow":{"mrow":[{"msub":{"mi":["N","hop"]},"mo":"\u2062","mfrac":{"msub":[{"mi":["T","d"]},{"mi":["T","r"]}]}},{"munderover":{"mo":"\u2211","mrow":{"mi":"k","mo":"=","mn":"1"},"msub":{"mi":["N","hop"]}},"mo":"\u2062","mrow":{"msub":{"mi":"D","mrow":{"mi":["r","k"],"mo":","}},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}}}],"mo":"+"}}}}},"Main benefits include: leads to an optimal path selection; and can be implemented in each node with only the local knowledge of the neighborhood.","The following relates to present protocol subject matter regarding operation for traffic load management, particularly including response scenarios involving packet transmission failures.","In order to best convey present traffic management rules, one needs to make several simplifying assumptions because the problem of RF collisions is extremely complex. The issue at hand is not the same as trying to make accurate traffic load evaluations. Detailed traffic load management algorithms are set forth in the protocol description otherwise herein.","To begin with, one may analyze the possible causes for a packet transmission failure and corresponding possible cure for each case, assuming in a first step that the cause of the failure is known. This will consider analysis of the problem of traffic flow at the cell relay and derive a simple traffic limitation rule from this special case. Thereafter, a more global strategy can be outlined to deal with these failures through adequate wait times and retransmissions. This strategy is designed to optimize the latency and the throughput of individual links between nodes. It is not designed to evenly share the traffic between the different paths of the meshed network. The proposed load management will prevent the network from collapsing if demand exceeds the network capacity, but it does not replace load management at the application level. Load management at the application layer is expected to spread the traffic as evenly as possible in time and to avoid requesting too much data at the same time. LAN network overload should remain an exceptional situation.","Present  is a table relating to various scenarios of transmission failure causes and solutions, per present protocol subject matter, which are further commented on herein.","The following is with particular reference to the  \u201cPossible cause (1)\u201d set of conditions. Rayleigh fading is strongly frequency dependent. As a consequence, some channels will have a much better packet success rate than others. This will be particularly noticeable with long distance links with a weak link margin. It will not be uncommon to see more than 10-dB difference between the link budgets of two channels. Such a difference will make some channels unusable for data transmission purpose, even when no jamming signals are present. Rayleigh fading is due to multi-path interference and the environmental conditions that make a channel poor will vary in time and from node to node. It is therefore not simple to exclude these bad channels from the list. Furthermore, the radio regulations in the US prevent one from doing so entirely; all the channels must be used in the same way. When a packet fails to be acknowledged due to such conditions, the solution is to try again on another channel. There is no need to wait before the next transmission attempt in this case. Additional wait time here would only increase the system latency. In some extreme cases, the system will fail to transmit successfully its packets on all the available channels. This can be caused by harsh environmental conditions like a thunderstorm or by the presence of a big obstruction close to the endpoint. This condition can also come with a loss of synchronization. In this case, the endpoint will have to introduce a significant wait time and resume its transmissions later, as outlined in the table of present .","The following is with particular reference to the  \u201cPossible cause (2)\u201d set of conditions. The ISM band used by the present protocol subject matter is a shared band. Other users of the band will interfere with such transmissions and some packets will be lost due to collisions. Of course, this phenomenon will be more important for long distance links due to a weaker link margin. Interferers can be narrow-band low power transmitters, frequency hoppers or high-power wide-band transmitters. The bandwidth of any interferer will nonetheless be small compared to the whole ISM bandwidth and, in most cases, the retransmission on a different channel will be sufficient to avoid the interference. As in the previous case there is no need to wait before attempting a retransmission. Additional wait time here would only increase the system latency. In some extreme cases, the system will fail to transmit successfully its packets on all the available channels. This can be caused by a very high power jammer close enough to the endpoint to de-sense its receiver front end. In this case, the endpoint will have to introduce a significant wait time and resume its transmissions later, as outlined in the table of present .","The following is with particular reference to the  \u201cPossible cause (3)\u201d set of conditions. As the traffic generated by the present protocol subject matter grows higher, internal collisions between packets will occur. At some point, these internal collisions will be frequent enough to degrade the effective throughput of the system. In this case transmitting on another channel will not improve the situation because every endpoint follows the same hopping pattern. From a collision probability standpoint, the system behaves as if only one channel was used. The relation between collision probability and effective throughput is well known from slotted Aloha theory. Textbook theory deals with the case where no external jammer is present. Here the situation is more difficult to analyze because we have both types of collisions at the same type: internal collisions due to subject traffic and external collisions with the other users of the band. Hence, it is desirable to introduce a regulation mechanism to slow down the subject traffic when it grows above some limit, as outlined in the table of present .","The following is with particular reference to the  \u201cPossible cause (4)\u201d set of conditions. When an endpoint cannot handle an incoming message due to memory limitations, it will reply with a negative acknowledgment and discard the received message. This can also be caused by traffic congestion in a remote node of the network. When a node needs to slow down its traffic, it will reply with a negative acknowledgement when its input buffer fills up. This condition will propagate step by step along the upstream traffic path. The recipient of a negative acknowledgement should either try another destination or retransmit after some wait time, as outlined in the table of present .","The following provides additional discussion with reference to analysis of the upload traffic flow at the cell relay, in accordance with present protocol subject matter. The cell relay is the point where all the traffic converges. If a gridlock occurs, it will most likely occur at the cell relay, it is therefore important to analyze the traffic conditions in this specific case. Only the upload situation is considered here because this is the relevant case for traffic load management. Present  diagrammatically represents a model for the traffic load of the present subject matter, at the cell relay, and useful for the reference in the present discussion.","As the actual situation is extremely complex, some simplifications are desired in order to more readily characterize some present traffic management rules. An assumption is made, for instance, that the cell relay (endpoint A in present ) can only hear the transmissions from level 2 endpoints (endpoints Bin ). This is an idealized assumption. In an actual implementation, sporadic successful transmissions between level 3 endpoints and the cell relay will more likely occur. An assumption is also made that the level 2 endpoints are out of range of each other. This looks like an idealized situation for level 2 endpoints but it is a worst case from the cell relay standpoint because a level 2 endpoint has no knowledge of the traffic sent by its neighbors to the cell relay in this case. Another present simplifying assumption is that two packets, two acknowledgements, or a packet and an acknowledgement arriving in a receiver in the same time slot will always collide and result in nothing at all being received. This is of course a pessimistic assumption, but only extensive simulations will allow a more accurate modeling of the collision process.","The following notation is utilized to describe the traffic flow:\n\n","The total traffic input density seen by the cell relay is the sum of the traffic densities generated by all the sons of the cell relay (endpoints Bin ). The total traffic breaks down in data packets and acknowledgements. The data traffic is given by:",{"@attributes":{"id":"p-1019","num":"1235"},"maths":{"@attributes":{"id":"MATH-US-00064","num":"00064"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}},{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"N"},"mo":"\u2062","mrow":{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["B","i"]},"mo":[",",","],"mi":["A","A"]}}}}],"mo":"="}}},"br":{},"sub":["1","2","N","i ","i "]},{"@attributes":{"id":"p-1020","num":"1236"},"maths":{"@attributes":{"id":"MATH-US-00065","num":"00065"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"U","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","C","A"],"mo":[",",","]}}},{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"N"},"mo":"\u2062","mrow":{"mi":"U","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["B","i"]},"mo":[",",","],"mrow":{"mi":"Sof","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["B","i"]}}},"mi":"A"}}}}],"mo":"="}}},"br":{}},{"@attributes":{"id":"p-1021","num":"1237"},"maths":{"@attributes":{"id":"MATH-US-00066","num":"00066"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"C","mo":"@","mrow":{"mover":{"munder":{"mo":"\u22c3","mrow":{"mi":"i","mo":"=","mn":"1"}},"mi":"N"},"mo":"\u2062","mrow":{"mi":"Sof","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["B","i"]}}}}},"mo":","}}},"br":{}},"The data packet throughput at the cell relay is given by:",{"@attributes":{"id":"p-1023","num":"1239"},"maths":{"@attributes":{"id":"MATH-US-00067","num":"00067"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"S","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}},{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"N"},"mo":"\u2062","mrow":{"mrow":[{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["B","i"]},"mo":[",",","],"mi":["A","A"]}}},{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["B","i"]},"mo":",","mi":"A"}}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mi":["P","S"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]}}],"mo":"="}}},"br":{},"sub":"i "},{"@attributes":{"id":"p-1024","num":"1240"},"maths":{"@attributes":{"id":"MATH-US-00068","num":"00068"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["P","S"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mrow":{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["B","i"]},"mo":",","mi":"A"}}}},{"mrow":[{"mi":"exp","mo":["[","]"],"mrow":{"mrow":[{"mo":"-","mrow":{"munderover":{"mo":"\u2211","munder":{"mrow":[{"mi":"k","mo":"=","mn":"1"},{"mi":["k","i"],"mo":"\u2260"}]},"mi":"N"},"mo":"\u2062","mrow":{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["B","k"]},"mo":[",",","],"mi":["A","A"]}}}}},{"munderover":{"mo":"\u2211","munder":{"mrow":[{"mi":"k","mo":"=","mn":"1"},{"mi":["k","i"],"mo":"\u2260"}]},"mi":"N"},"mo":"\u2062","mrow":{"mi":"U","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["B","k"]},"mo":[",",","],"mrow":{"mi":"Sof","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["B","k"]}}},"mi":"A"}}}}],"mo":"-"}},{"msub":{"mi":["PSR","e"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"A"}},{"mi":"Q","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"A"}}],"mo":["\u2062","\u2062"]}],"mo":"="}}}},"The first term in the expression of the PSR is the probability for all other level 2 endpoints to be silent when Btransmits its packet. This probability is given by the Poisson distribution for \u201czero event\u201d. The expression in brackets is the average value of the number of events in a single time slot. The next term, PSR(A), is the probability for the data packet to be received without collision with interferers outside the present subject matter network. Finally Q(A) is the probability for endpoint A to be in the receiving state when the packet arrives. This probability is equal to one minus the probability for endpoint A to be acknowledging a previously received packet:\n\n()=1\u2212()\n","The cell relay will acknowledge each received packet, this provides a relation between the number of packets successfully received by A and the number of acknowledgements arriving at B:\n\n()=()\n","The number of acknowledgements successfully received by Bis given by:",{"@attributes":{"id":"p-1028","num":"1244"},"maths":{"@attributes":{"id":"MATH-US-00069","num":"00069"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"V","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"A","mo":[",",","],"msub":[{"mi":["B","i"]},{"mi":["B","i"]}]}}},{"mrow":[{"mi":"U","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"A","mo":[",",","],"msub":[{"mi":["B","i"]},{"mi":["B","i"]}]}}},{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"A","mo":",","msub":{"mi":["B","i"]}}}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mi":["A","S"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]}],"mo":["=","\u2062"],"mi":{}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mrow":{"mrow":[{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["B","i"]},"mo":[",",","],"mi":["A","A"]}}},{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["B","i"]},"mo":",","mi":"A"}}},{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"A","mo":",","msub":{"mi":["B","i"]}}}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mi":["P","S","A","S"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]}}}}]}}},"br":[{},{},{}],"sub":["i","i","i","i","i","i","i","i","e","i","i","i"],"in-line-formulae":[{},{}],"i":["A,B","R","Sof","B","B",",B","U","Sof","B","Sof","B","B","PSR","B"],"sup":["2","2"]},"From the application standpoint the relevant traffic is the number of packets received by the cell relay after deletion of the duplicated packets. A duplicated packet is generated when the acknowledgement fails to be received by the sender of the packet. This number of unique packets should be equal to the number of acknowledgements successfully received by the level 2 endpoints, T(B,A,A)=V(A,B,B)","It follows a relation between T(B,A,A) and R(B,A,A):\n\n()=()()ASR()\n","In this equation PSR(B,A)ASR(A,B) is the success rate for the transmission of packet and the reception of the following acknowledgement. This is the \u201cpacket success rate\u201d that the endpoint Bwill measure when trying to send its packet to the cell relay. The total rate of reception of not duplicated packets is obtained by summing the preceding equation:",{"@attributes":{"id":"p-1032","num":"1248"},"maths":{"@attributes":{"id":"MATH-US-00070","num":"00070"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}},{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"N"},"mo":"\u2062","mrow":{"mrow":[{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["B","i"]},"mo":[",",","],"mi":["A","A"]}}},{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["B","i"]},"mo":",","mi":"A"}}},{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"A","mo":",","msub":{"mi":["B","i"]}}}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mi":["P","S","A","S"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]}}],"mo":"="}}}},"The number of acknowledgements sent by A to Bis related to the traffic rate by:",{"@attributes":{"id":"p-1034","num":"1250"},"maths":{"@attributes":{"id":"MATH-US-00071","num":"00071"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"U","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"A","mo":[",",","],"msub":[{"mi":["B","i"]},{"mi":["B","i"]}]}}},{"mrow":{"mrow":[{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["B","i"]},"mo":[",",","],"mi":["A","A"]}}},{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["B","i"]},"mo":",","mi":"A"}}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mi":["P","S"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]},"mo":"=","mfrac":{"mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["B","i"]},"mo":[",",","],"mi":["A","A"]}}},{"mi":["A","S"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mrow":{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"A","mo":",","msub":{"mi":["B","i"]}}}}}]}}],"mo":"="}}}},"In a similar way, the acknowledgements received by the cell relay but intended for the level 3 endpoints are also proportional to the total traffic:",{"@attributes":{"id":"p-1036","num":"1252"},"maths":{"@attributes":{"id":"MATH-US-00072","num":"00072"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"U","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["B","i"]},"mo":[",",","],"mrow":{"mi":"Sof","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["B","i"]}}},"mi":"A"}}},"mo":"=","mfrac":{"mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"Sof","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["B","i"]}}},"mo":[",",","],"msub":[{"mi":["B","i"]},{"mi":["B","i"]}]}}},{"mi":["A","S"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mrow":{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["B","i"]},"mo":",","mrow":{"mi":"Sof","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["B","i"]}}}}}}}]}}}}},"The total contribution of acknowledgements to the traffic at the cell relay is then:",{"@attributes":{"id":"p-1038","num":"1254"},"maths":{"@attributes":{"id":"MATH-US-00073","num":"00073"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"U","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","C","A"],"mo":[",",","]}}},{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"N"},"mo":"\u2062","mfrac":{"mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"Sof","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["B","i"]}}},"mo":[",",","],"msub":[{"mi":["B","i"]},{"mi":["B","i"]}]}}},{"mi":["A","S"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mrow":{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["B","i"]},"mo":",","mrow":{"mi":"Sof","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["B","i"]}}}}}}}]}}],"mo":"="}}}},"To make the problem tractable, it is necessary to make further assumptions. A further such assumption is that the number of sons of A is large. In this case, the individual contributions of each Bto the total traffic is small and the packet success rate becomes independent of i as follows:\n\n()=exp[\u2212()\u2212()]()()\n","To simplify the expression for the acknowledgement success rate, we will notice that implementation of the present protocol subject matter does not result in a pure Aloha system. When a son of a level 2 endpoint hears its father sending a packet, it will postpone its own transmission to avoid interfering with the acknowledgement its father is expecting. The probability for Bto receive in the same time slot an acknowledgement from one its sons (intended for its grandson) and an acknowledgement from A is also much smaller than previously assumed. This would only occur if, in the previous time slot, Bhad sent a packet to A and the son of Bhad also sent a packet to its own son. This is likely to produce a collision. The acknowledgement success rate will therefore be approximated with:\n\nASR()=\n\nwhere we further assumed that the external collision rate is the same for all endpoints.\n","The relation between the throughput and the input traffic density at the cell relay simplifies to:\n\n()=()ASR()()\n","The acknowledgment rate from level 2 to level 3 is approximated in the same way:\n\nASR(())=\n","And the acknowledgement input density at the cell relay becomes:",{"@attributes":{"id":"p-1044","num":"1260"},"maths":{"@attributes":{"id":"MATH-US-00074","num":"00074"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"U","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","C","A"],"mo":[",",","]}}},{"mfrac":[{"mrow":[{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"N"},"mo":"\u2062","mrow":{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"Sof","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["B","i"]}}},"mo":[",",","],"msub":[{"mi":["B","i"]},{"mi":["B","i"]}]}}}},{"mi":["P","S"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msub":{"mi":["R","e"]}}]},{"mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}},{"mi":["P","S"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msub":{"mi":["R","e"]}}]}],"mo":"="}],"mo":"="}}},"br":{}},{"@attributes":{"id":"p-1045","num":"1261"},"maths":{"@attributes":{"id":"MATH-US-00075","num":"00075"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["P","S"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mrow":{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A"],"mo":","}}}},{"mrow":[{"mi":"exp","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mrow":{"mo":"-","mrow":{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}}},"mo":"-","mfrac":{"mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}},{"mi":["P","S"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msub":{"mi":["R","e"]}}]}}}},{"msub":{"mi":["R","e"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mn":"1","mo":"-","mfrac":{"mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}},{"mi":["P","S"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msub":{"mi":["R","e"]}}]}}}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mi":["P","S"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]}],"mo":"="}}}},"After substitution in the relation between T (B, A, A) and R (B, A, A), the following is obtained:",{"@attributes":{"id":"p-1047","num":"1263"},"maths":{"@attributes":{"id":"MATH-US-00076","num":"00076"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}},{"mrow":[{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}},{"mi":"exp","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mrow":{"mo":"-","mrow":{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}}},"mo":"-","mfrac":{"mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}},{"mi":["P","S"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msub":{"mi":["R","e"]}}]}}}},{"msubsup":{"mi":["R","e"],"mn":"2"},"mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mn":"1","mo":"-","mfrac":{"mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}},{"mi":["P","S"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msub":{"mi":["R","e"]}}]}}}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mi":["P","S"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]}],"mo":"="}}}},"This can be written in this way:",{"@attributes":{"id":"p-1049","num":"1265"},"maths":{"@attributes":{"id":"MATH-US-00077","num":"00077"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":[{"mfrac":{"mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}},{"mi":["P","S"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msub":{"mi":["R","e"]}}]},"mo":"\u2062","mrow":{"mi":"exp","mo":"\u2061","mrow":{"mo":["[","]"],"mfrac":{"mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}},{"mi":["P","S"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msub":{"mi":["R","e"]}}]}}}},{"mi":["P","S"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mrow":{"msub":{"mi":["R","e"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mn":"1","mo":"-","mfrac":{"mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}},{"mi":["P","S"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msub":{"mi":["R","e"]}}]}}}}}]},"mo":"=","mrow":{"mrow":[{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}},{"mi":"exp","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mo":"-","mrow":{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}}}}}],"mo":"\u2062"}}}}},"The left-hand side of this equation is a monotonic function of T (B, A, A), the right-hand side has a maximum value for R (B, A, A)=1, it follows an equation that can be solved to find the maximum possible value of T (B, A, A):",{"@attributes":{"id":"p-1051","num":"1267"},"maths":{"@attributes":{"id":"MATH-US-00078","num":"00078"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"mfrac":{"mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}},{"mi":["P","S"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msub":{"mi":["R","e"]}}]},"mo":"\u2062","mrow":{"mi":"exp","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mn":"1","mo":"+","mfrac":{"mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}},{"mi":["P","S"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msub":{"mi":["R","e"]}}]}}}}},{"mi":["P","S"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mrow":{"msub":{"mi":["R","e"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mn":"1","mo":"-","mfrac":{"mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}},{"mi":["P","S"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"msub":{"mi":["R","e"]}}]}}}}}],"mo":"-"},"mo":"=","mn":"0"}}}},"Present , respectively, illustrate various aspects of such relations. In particular, present  graphically illustrates Data throughput, T(B,A,A) and PSR (with acknowledgement) vs traffic input density, R(B,A,A) for PSRe=0.8, while present  graphically illustrates Data throughput, T(B,A,A) vs PSRe. In any event, whatever the external collision rate, the maximum throughput is always obtained for R (B, A, A)=1. Such interesting feature is used for traffic load management per the present protocol subject matter.","In contrast to the foregoing discussion concerning analysis of the upload traffic flow at the cell relay, in accordance with the present protocol subject matter, the following more particularly relates to evaluation of such upload traffic flow.","In order to control properly the traffic load per present subject matter, an endpoint needs to evaluate the amount of traffic going through the network. From electromagnetic theory, it is known that any transmission path from antenna to antenna is reciprocal. For simplicity, one may make the additional assumption that the links are balanced, that is, the transmitted powers and sensitivities are the same for all endpoints. One can then say that if node A is a father for node B, every packet transmitted by A will be heard by B, with the exceptions of the packets lost by collision or because Bwas not in reception mode at the right moment. This provides node Bwith a simple, approximate way to know the amount of traffic its father is handling at any moment. Node Bneeds to listen to the acknowledgments transmitted by the cell relay. The acknowledgments will give enough information to assess the traffic load.","For each received packet, the cell relay sends an acknowledgement. It is therefore calculated that U (A, B, B)=S (B, A, A). The rate of acknowledgements successfully received by Bis given by:\n\n()=()ASR()()\n\nwhere Q(B) is included because endpoint Bis monitoring acknowledgements intended for other endpoints and is not always in listening state when these acknowledgements arrive.\n","It is known that the traffic input density is given by R (B, A, A)=S (B, A, A)\/PSR (A, B). The relation between R (B,A,A) and V (A, B, B) is:",{"@attributes":{"id":"p-1057","num":"1273"},"maths":{"@attributes":{"id":"MATH-US-00079","num":"00079"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}},"mo":"=","mfrac":{"mrow":[{"mi":"V","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["A","B"],"mo":[",",","],"msub":{"mi":["B","i"]}}}},{"mi":["P","S","A","S"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mrow":[{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["A","B"],"mo":","}}},{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"A","mo":",","msub":{"mi":["B","i"]}}}},{"mi":"Q","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["B","i"]}}}]}]}}}}},"When measuring V (A, B, B), one should consider all acknowledgements (positive or negative) sent by A and received by B. But the acknowledgements intended for Bare not taken into account in this computation. Only the acknowledgements addressed to other endpoints are recorded here because the purpose is to evaluate the external subject traffic the endpoint A has to deal with. V (A, B, B) can be measured by counting all the received acknowledgements occurring in a sliding time window. If one expresses the packet success rate in terms of the average propagation delay, the result is as follows:",{"@attributes":{"id":"p-1059","num":"1275"},"maths":{"@attributes":{"id":"MATH-US-00080","num":"00080"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"mi":"PSR","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A"],"mo":","}}},{"mi":"ASR","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["A","B"],"mo":","}}}],"mo":"\u2062"},"mo":"=","mfrac":{"mn":"1","mrow":{"mn":"1","mo":"+","msub":{"mi":["LPD","BA"]}}}}}}},"The traffic input density can be seen by endpoint A as a function of the propagation delay and the rate of reception of acknowledgments. The following equation will indicate how busy is endpoint A:",{"@attributes":{"id":"p-1061","num":"1277"},"maths":{"@attributes":{"id":"MATH-US-00081","num":"00081"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A","A"],"mo":[",",","]}}},"mo":"=","mfrac":{"mrow":[{"mrow":[{"mi":"V","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["A","B"],"mo":[",",","],"msub":{"mi":["B","i"]}}}},{"mo":["(",")"],"mrow":{"mn":"1","mo":"+","msub":{"mi":["LPD","BA"]}}}],"mo":"\u2062"},{"mi":"Q","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["B","i"]}}}]}}}}},"The following more particularly relates to traffic management algorithms per the present protocol subject matter. When the LLC layer receives from the NET layer a request to send a packet, or when it reschedules a non-acknowledged transmission, it will compute the length of the wait time (Tx_Wait) before the request to send can be forwarded to the MAC layer. This wait time is computed as a function of the repetition number. The purpose of such approach is to avoid flooding the air interface with a large number of packets when the conditions of transmission are difficult.","When the MAC layer receives a request to send a packet from the LLC layer, the randomization window length (Tx_Window) is computed as a function the traffic load, its purpose is to avoid using the slotted Aloha interface above its optimal point. The transmission of a packet will always occur within the randomization window, after the wait time. Such facet of the present subject matter is illustrated by present , which graphically represents the wait time and randomization window for the (re-)transmission of a packet. Such wait time is preferably computed according to a binary exponential backoff law, as otherwise explained herein.","The following more particularly addresses advantageous mitigation of collision circumstances, per present subject matter. In this context, the simultaneous (or overlapping) reception of two or more packets is referred to as a collision. If the colliding packets have the same power, both will be lost. If one packet is received with a higher power (higher than some carrier to interference ratio) and if the more powerful packet arrives first, the stronger packet is received successfully and the weaker one is lost. Such a set of conditions and\/or events are represented by present , that is, representing such a collision episode where one packet (designated as packet 1) is lost.","If the weaker packet arrives first, two scenarios are possible, depending on the type of receiver used in the pertinent portion of the implementation. If the receiver has relatively more limited functionalities, it will lock on the preamble of the first packet, go into sync word search and then into a demodulation phase. When the stronger packet arrives, the receiver is not in a preamble search state and misses the stronger packet sync word. Both packets are lost. Such a set of conditions and\/or events are represented by present , that is, representing a collision episode where both packets (designated as packet 1 and packet 2) are lost. In the situation where the received happens to be a more sophisticated device, the receiver is able to demodulate a packet and concurrently search for a new preamble. In such case, it can receive the stronger packet. The weaker one (packet 1) is however lost in all cases.","To mitigate the probability of collision with any kind of receiver, it can be useful per present subject matter to avoid using the first sub time slot for acknowledgments. Such preferred approach will avoid the destruction of some packets by weaker acknowledgements arriving just before the packet.","While the present subject matter has been described in detail with respect to specific embodiments thereof, it will be appreciated that those skilled in the art, upon attaining an understanding of the foregoing may readily produce alterations to, variations of, and equivalents to such embodiments. Accordingly, the scope of the present disclosure is by way of example rather than by way of limitation, and the subject disclosure does not preclude inclusion of such modifications, variations and\/or additions to the present subject matter as would be readily apparent to one of ordinary skill in the art.","In addition, various discussion herein makes us of and\/or relies on abbreviations and acronyms, having the intended meanings as set forth in the following Table of Definitions, which forms part of the present disclosure.",{"@attributes":{"id":"p-1069","num":"0000"},"ul":{"@attributes":{"id":"ul0183","list-style":"none"},"li":{"@attributes":{"id":"ul0183-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0184","list-style":"none"},"li":["ACK\u2014Acknowledgement","AMI\u2014Advanced Metering Initiative","API\u2014Application Layer Interface","C12.22\u2014ANSI standard protocol for interfacing to data communication networks. It is the recommended API protocol to be used with Linknet protocol.","CM\u2014Cell Master","CR\u2014Cell Relay","CRC\u2014Cyclic Redundancy Check","ERC\u2014European Radiocommunications Committee","EP\u2014Endpoint, network node","EP_GPD\u2014Global average Propagation Delay between an endpoint and the Cell Master through a specified neighbor.","ETSI\u2014European Telecommunications Standards Institute","FCC\u2014Federal Communications Commission","FCS\u2014Frame Check Sequence","FEC\u2014Forward Error Correction","FH\u2014Frequency Hopping","FHSS\u2014Frequency Hopping Spread Spectrum","GF\u2014Galois Field","GPD\u2014Global average Propagation Delay between an endpoint and the Cell Master (the minimum EP_GPD for an endpoint)","IEEE\u2014Institute of Electrical and Electronics Engineers","ISM\u2014Industrial, Scientific and Medical","ISO\u2014International Standards Organization","ITP\u2014Itron Time Protocol","Linknet\u2014The name of the protocol described in the present document","LLC\u2014Logical Link Control layer","LPDU\u2014LLC PDU","LPD\u2014Local PD. Propagation Delay between two neighboring EPs","MAC\u2014Medium Access Control layer","MPDU\u2014MAC PDU","NACK\u2014Negative acknowledgement","NET\u2014Network layer","NETPDU\u2014NET PDU","OSI\u2014Open Systems Interconnection","PDF\u2014Probability Density Function","PDU\u2014Protocol Data Unit","PHY\u2014Physical layer","PPDU\u2014Physical layer PDU","PSR\u2014Packet Success Rate","RITP\u2014Relative Itron Time Protocol","RS\u2014Reed-Solomon or Registered State","RSSI\u2014Received Signal Strength Indicator","RTOS\u2014Real Time Operating System","SAP\u2014Service Access Point","SFD\u2014Start of Frame Delimiter","TS\u2014Time Slot","RF2Net\u2014Previous project name for Linknet development","WAN\u2014Wide Area Network","Zigbee\u2014Standard IEEE protocol."]}}}}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A full and enabling disclosure of the present subject matter, including the best mode thereof, directed to one of ordinary skill in the art, is set forth in the specification, which makes reference to the appended figures, in which:",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 3C"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 3D"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 3E"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 3F"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 21A"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 21B"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIGS. 26A and 26B"},{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 30A"},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 30B"},{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 39"},{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 41"},{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 42"},{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 43"},{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 44"},{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 45"},{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 46"},{"@attributes":{"id":"p-0093","num":"0092"},"figref":"FIG. 47"},{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 48"},{"@attributes":{"id":"p-0095","num":"0094"},"figref":"FIG. 49"},{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 50"},{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 51"},{"@attributes":{"id":"p-0098","num":"0097"},"figref":"FIG. 52"},{"@attributes":{"id":"p-0099","num":"0098"},"figref":"FIG. 53"},{"@attributes":{"id":"p-0100","num":"0099"},"figref":"FIG. 54"},{"@attributes":{"id":"p-0101","num":"0100"},"figref":"FIG. 55"},{"@attributes":{"id":"p-0102","num":"0101"},"figref":"FIG. 56"},{"@attributes":{"id":"p-0103","num":"0102"},"figref":"FIG. 57A"},{"@attributes":{"id":"p-0104","num":"0103"},"figref":"FIG. 57B"},{"@attributes":{"id":"p-0105","num":"0104"},"figref":"FIG. 57C"},{"@attributes":{"id":"p-0106","num":"0105"},"figref":"FIG. 57D"},{"@attributes":{"id":"p-0107","num":"0106"},"figref":"FIG. 58"},{"@attributes":{"id":"p-0108","num":"0107"},"figref":"FIG. 59"},{"@attributes":{"id":"p-0109","num":"0108"},"figref":"FIG. 60"},{"@attributes":{"id":"p-0110","num":"0109"},"figref":"FIG. 61"},{"@attributes":{"id":"p-0111","num":"0110"},"figref":"FIG. 62"},{"@attributes":{"id":"p-0112","num":"0111"},"figref":"FIG. 63"},{"@attributes":{"id":"p-0113","num":"0112"},"figref":"FIG. 64"},{"@attributes":{"id":"p-0114","num":"0113"},"figref":"FIG. 65"},{"@attributes":{"id":"p-0115","num":"0114"},"figref":"FIG. 66"},{"@attributes":{"id":"p-0116","num":"0115"},"figref":"FIG. 67"},{"@attributes":{"id":"p-0117","num":"0116"},"figref":"FIG. 68"},{"@attributes":{"id":"p-0118","num":"0117"},"figref":"FIG. 69"},{"@attributes":{"id":"p-0119","num":"0118"},"figref":"FIG. 70"},{"@attributes":{"id":"p-0120","num":"0119"},"figref":["FIG. 71","FIG. 70"]},{"@attributes":{"id":"p-0121","num":"0120"},"figref":"FIG. 72"},{"@attributes":{"id":"p-0122","num":"0121"},"figref":"FIGS. 73A","b":["73","73"]},{"@attributes":{"id":"p-0123","num":"0122"},"figref":"FIG. 74"},{"@attributes":{"id":"p-0124","num":"0123"},"figref":"FIG. 75"},{"@attributes":{"id":"p-0125","num":"0124"},"figref":"FIG. 76"},{"@attributes":{"id":"p-0126","num":"0125"},"figref":"FIG. 77"},{"@attributes":{"id":"p-0127","num":"0126"},"figref":"FIG. 78"},{"@attributes":{"id":"p-0128","num":"0127"},"figref":"FIG. 79"},{"@attributes":{"id":"p-0129","num":"0128"},"figref":"FIG. 80"}]},"DETDESC":[{},{}]}
