---
title: Apparatus, method, and system to allocate redundant components
abstract: In general, a method, apparatus, and system determine the allocation of the one or more redundant components while fault testing the memory. In an embodiment of an apparatus, one or more memories and one or more processors are located on a single chip. Each memory has one or more redundant components associated with that memory. The one or more redundant components include at least one redundant column. The one or more processors contain redundancy allocation logic having an algorithm. The algorithm determines the allocation of the one or more redundant components to repair one or more defects detected in the one or more memories while fault testing the memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07127647&OS=07127647&RS=07127647
owner: Virage Logic Corporation
number: 07127647
owner_city: Fremont
owner_country: US
publication_date: 20010924
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DISCUSSION"],"p":["This application is a continuation in part of provisional U.S. patent application Ser. No. 60\/301,901, filed on Jun. 29, 2001.","The present invention relates generally to integrated circuits consisting of stand-alone memory devices or embedded memories, and more specifically to a memory having a column and\/or row redundancy scheme.","Random defects occurring during the manufacturing of an integrated circuit with embedded memory blocks can render certain non-redundant elements of an integrated circuit memory device, such as a memory column, defective. For example, particle contamination during the manufacturing process may cause broken or shorted out columns and bit defects.","Redundant elements in an integrated circuit memory device, such as redundant columns, are used to compensate for these random defects. Initial testing of an integrated circuit memory occurs after the manufacturing process. During initial testing of an integrated circuit memory device, defective elements are replaced by non-defective elements referred to as redundant elements. Thus, redundant columns may be used in a scheme to replace defective non-redundant columns, discovered during initial testing of the integrated circuit memory device. The use of redundant elements is important in increasing the overall yield of an integrated circuit memory device.",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1","b":["102","102","104","106","104","108","102","108","108","110","110","102","108","102","112","102"]},"The required external test solution  is expensive, time-consuming, may not achieve a dramatic increase in yield, and in the future it may not be a feasible solution for SoC testing. The memory tester  assumes that the memories  used in a SoC  are readily accessible directly from the I\/O pins of the chip. A designer must carefully route each embedded memory  to enable pin access. As more embedded memories  are physically located onto a chip containing the entire system, more design time is required to route the embedded memories  and establish the pin connections. Meanwhile, the die size may increase from the extra routing, and chip packages may enlarge accordingly. The physical size and spacing requirements of SoC  dies may not accommodate the extra space need to test the memories. Also, memory tester  may not be able to test the memories at the speed of the chip.","A method, apparatus, and system that determine the allocation of the one or more redundant components while fault testing the memory. In an embodiment of an apparatus, one or more memories and one or more processors are located on a single chip. Each memory has one or more redundant components associated with that memory. The one or more redundant components include at least one redundant column. The one or more processors contain redundancy allocation logic having an algorithm. The algorithm determines the allocation of the one or more redundant components to repair one or more defects detected in the one or more memories while fault testing the memory.","While the invention is subject to various modifications and alternative forms, specific embodiments thereof have been shown by way of example in the drawings and will herein be described in detail. The invention should be understood to not be limited to the particular forms disclosed, but on the contrary, the intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the invention.","In the following description, numerous specific details are set forth, such as examples of specific data signals, named components, connections, sequence of specific registers changing status, etc., in order to provide a thorough understanding of the present invention. It will be apparent, however, to one skilled in the art that the present invention may be practiced without these specific details. In other instances, well known components or methods have not been described in detail but rather in a block diagram in order to avoid unnecessarily obscuring the present invention. Thus, the specific details set forth are merely exemplary. The specific details may be varied from and still be contemplated to be within the spirit and scope of the present invention. The term coupled is defined as meaning connected either directly or indirectly.","In general, a method, apparatus, and system determine the allocation of the one or more redundant components while fault testing the memory. In an embodiment of an apparatus, one or more memories and one or more processors are located on a single chip. Each memory has one or more redundant components associated with that memory. The one or more redundant components include at least one redundant column. The one or more processors contain redundancy allocation logic having an algorithm. The algorithm determines the allocation of the one or more redundant components to repair one or more defects detected in the one or more memories while fault testing the memory.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2","b":["202","204","206","208","210","212","214","216","218","204","206","204","208","210"]},"The processor  enables a complete embedded memory self-test and repair function to be included on-chip . The processor  increases the yield of useable memories  by repairing defective memory components at a very high rate. In an embodiment, the processor  contains multiple engines to determine how much redundancy is needed and how to partition the redundant components throughout each unique memory array. The processor  understands the redundancy scheme, the failure history of the process being used, and how the unit has failed.","The processor  on the chip  that automatically tests the memory  allocates redundancy resources and coordinates or performs any necessary repairs. In an embodiment, the processor  tests the memory instances  at speed; that is, at the speed they will run in the application. After testing and repair of the memory instances , the processor  turns the memory operation over to the normal address, data and control busses on the SoC.","The repair data signature created by the processor  is sent to an external tester (not shown) via the one or more external interfaces . In an embodiment, the processor  communicates the repair data signature during wafer probe. In an embodiment, the laser repair equipment (not shown) programs the fuse box  with the necessary repair information. The fuse box  retains the permanent memory repair signature unique to that individual SoC . The signature can be executed either at wafer sort or at system power-on. In an embodiment, the processor  determines and stores the repair data signature in order to eliminate the need for a fuse box . In an embodiment, the processor  after system power-on transfers the corresponding repair data signature directly into the scan flip-flops contained within each unique memory instance  in the SoC .","In an embodiment, the processor  may perform all the appropriate testing and repair coordination of the memory instances  in order to increase yield, eliminate expensive external memory testers, and allow test and repair functions to occur in the field rather than at the factory. In an embodiment, the only factory testing required is to test the logic portion of the SoC  and, if applicable, coordinate the fuse box  programming. Thus, testing and repair of the memory instances  may occur in the field. In an embodiment, the processor  reduces the previous techniques of having four external test stages (memory test, laser repair, memory re-test, logic test) to one external test stage (logic test). In an embodiment, if a hard repair is used then there may be three external test stages, i.e. memory test, laser repair, and memory retest.","The system supports both factory and field repair methods. Factory repair takes place during wafer probe in the factory, using the laser programmed fuse box . Field repair uses a test and repair function residing in the processor  to make repairs after product deployment.","The factory repair has the advantage of performing test and repair at the wafer level. The wafer  can be subjected to a variety of stringent conditions during testing that helps insure high memory instance  and SoC  reliability during extended voltage, temperature and frequency conditions.","The field repair operation tests and repairs memory instances  each time the end product powers up or is reset. The processor  initiates and operates the test program, determines defective memory locations (if any), allocates redundancy resources, and produces a repair signature that resides in a location on the memory . This volatile repair signature is applied to the redundancy control logic and remains there as long as power is applied.","The field repair feature allows a new test every time the processor  is powered up or reset under control of the application's software but it is performed at ambient temperature and typically under non-stressful conditions.","The SoC  supports both repair functions: factory repair for manufacturing defects, and field repair for any subsequent problems that may materialize over the life of the end product.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 3","b":["302","304","306","308"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 4","b":["402","404","402","406","404"]},"Referring to , the processor can use the BISD engine  to find the defects and the BIRA engine  to repair the memory. The BIST engine  runs a test program to detect faults in the memory array. The BIRA engine  allocates the available redundant components to repair the memory and sends the repair information to the Reconfiguration Data engine . The Reconfiguration Data engine  translates redundancy allocation into a memory-specific repair signature that can be both sent to the external memory tester to be programmed into a fuse box or sent directly to scan chain registers in the memories themselves.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 5","b":["502","504","506","508","510","502","504","506","508","510","502","502","512","504","506","508","510","504","506","508","510","514","516","512","504","506","508","510","516","516","504","506","508","510","512"]},"In an embodiment, an extension of the processor is the Intelligent Wrapper (IW)  for example, at the first memory. The intelligent wrapper  associated with each memory instance , , ,  is used in conjunction with the processor  to perform test and repair of the memory as well as allow normal memory functioning in the system. The intelligent wrapper  contains functions such as address counters, registers, data comparators and multiplexors. The intelligent wrapper  is located close to the memory core to allow at-speed testing of these functions. Thus, the processor  in conjunction with its intelligent wrapper  increase useable memory yields due to the processor's ,  ability to detect nearly all defects, including performance defects that external memory testers commonly miss because they cannot run tests at chip speed. Further, the processor's ,  on-chip repair function allows in the factory repairs and in the field repairs. The external interface , such as the standard JTAG 1149.1 port, enables the one or more processors to communicate with the chip's other IP cores.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 6","b":["602","604","606","608","610","612","614","616","602","608","614","602","608","604","606","604","606","612"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 7","b":["700","700","700","704","706","708","710","700","704","706","704","708","710","700","700","712","714","716","718","700","712","704","714","706","716","704","706","720","704","704","716","720","704","722","706","718","704","706"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 8","b":["802","804"]},"In an embodiment, the plurality of registers may be as follows. Row register-Row_ , and row register Row_  record the faulty row addresses. Thus, each row register ,  may identify and store the address of a faulty row. In an embodiment, the amount of row registers equals the number of redundant rows. Status bit register-En  and status bit register-En  record the status of redundant row registers. These status bits indicate that the corresponding addresses recorded must be selected for repair if the memory is declared repairable after BIST. Thus, the status bit registers ,  indicate whether the corresponding redundant row is available or unavailable as a substitute row. In an embodiment, the BIST and BIRA operations are performed simultaneously.","Similarly, status bit register-CL (not shown) and status bit register-CH (not shown) record the status of redundant column registers. The status bit registers indicate whether the corresponding redundant column is available or unavailable as a substitute column. Column register Col_L  and column register Col_H  record the faulty column addresses located in the lower bank and upper bank, respectively. In an embodiment, the total amount of status bit registers equals the number of redundant rows plus the number of redundant columns.","Cross-reference row register-Row_L  and cross-reference row register Row_H  record the row addresses connected with the faults recorded in column registers Col_L  and Col_H . Each cross reference register allows an assigned redundant column, thus unavailable, to be released and reset to available status, if an assigned redundant row will also be substituting for the defective memory cell that the assigned redundant column was substituted for. In an embodiment, the BIRA engine  may couple to additional registers, such as sub input output registers which together with the column registers ,  specify the faulty column addresses of sub input output circuits associated with each memory array.","The BIRA engine  processes one or more built-in-redundancy-analysis algorithms to determine whether a memory is repairable. The BIRA engine  takes into consideration the process failure history, address mapping, and examines information about available redundancy, and the current fault data that is specific to each unique memory. The BIRA engine  combines this information and sends the information to the Reconfiguration Data engine to translate the redundancy allocation into a memory-specific repair signature.","In an embodiment, the organization and sequence of how the BIRA engine  assigns the redundant components determines whether a memory array will be repairable or not repairable, thereby, increasing or decreasing the yield of useable memories on the chip. The BIRA engine  may use many discrete algorithms, however, a one or more algorithms will be described and illustrated to demonstrate aspects of the invention.","A first Built-In-Redundancy-Analysis algorithm is based on the following main logic steps.","First, if at least two faulty cells are encountered in a word either in the lower bank or the upper bank of the memory array, then the row requires repair with a redundant row. If an available redundant row does not exist, then the memory array is considered unrepairable.","Second, if a single faulty cell is encountered in a word either in the lower bank or the upper bank of the memory array then a redundant column is used for repair, if available. If no spare column is available but a spare row is available, then a redundant row is used for repair. Otherwise, the memory array is considered unrepairable.","Third, the BIRA engine  works in parallel with the BIST logic providing the fault data. Thus, the BIRA engine  may possess three states of decision regarding the assignment of redundant components to substitute for defects in the memory detected by BIST logic. In an embodiment, the three states of decision are not set, tentatively set, and locked in. The starting state of decision for redundant rows and redundant columns is not set. Not set means that the component is available to be assigned to substitute for a defective component.","As noted in the first logic step, if at least two faulty cells are encountered in a word, then a redundant row is assigned to substitute for the defective component. In this case, the BIRA engine  locks in the state of decision for this redundant row to substitute for the defective row. Thus, this particular redundant row is now unavailable to be assigned to replace another defective component. Note, the redundant row globally replaces the entire row in both the lower bank and the upper bank irrespective of whether the two fault cells exist in the upper bank or in the lower bank or in both.","As noted in the second logic step, if a single faulty cell is encountered in a word, then a redundant column is the first choice to substitute for the defective component. The BIRA engine  tentatively sets the state of decision for this redundant column to substitute for the defective component. Thus, this particular redundant column is currently unavailable to be assigned to replace another defective component; however, the status of this redundant column may be released back to available upon certain conditions. If a new fault is encountered requiring repair with a redundant row, (i.e. at least two faulty cells are encountered in a word) and a faulty row is connected with an assigned redundant column, i.e. the corresponding cross-referencing registers contain the same address as the faulty row, then the corresponding column register is reset together with the status bit register and cross referencing register. The released redundant column has become available for further repair purposes and the newly assigned redundant row satisfies the first logic step to have a locked in state of decision. If an available redundant row does not exist, then the memory array is considered unrepairable.","Fourth, the BIRA algorithm may use a marching algorithm, which sequentially examines the addresses of the memory array. The BIRA algorithm may make several passes to attempt to repair a memory. If at least one of the BIRA algorithms passes eliminates all of the defective components in the memory through redundant component substitution, then the state of decision for each redundant memory component is locked in. The memory is repaired. The BIRA engine  sends the repair information to the Reconfiguration Data generation engine.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 9","b":["902","904"]},"On the third pass , the BIRA algorithm alters the second logic step to choose to replace a single defective memory cell with a redundant row rather than a redundant column. The BIRA engine sets the state of decision for that assigned redundant row as tentatively set. On the fourth pass , the BIRA algorithm does both alter the second logic step to choose to replace a single defective memory cell with a redundant row rather than a redundant column and examines the memory array in the backward direction.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 10","b":["1002","1004","1006","1008","1010","1012","1014","1016"]},"The memory array  is split into two halves a lower bank  and an upper bank . Many word lines exist in each bank. For example, the top horizontal grouping of memory blocks is a word line, in the lower bank . Similarly, the top horizontal grouping of memory blocks in the upper bank  is an example of a word line. The row address spans from row address   through row address  . And the column address spans from address  through address . Note this is just an exemplary memory array  and how a first BIRA algorithm might be employed.","The BIST program sends data to the BIRA engine indicating the location of faulty memory cells, such as a first faulty memory cell  located in the first word line  contained within the lower bank . The first faulty memory cell  is located at row address   and also at column address . Located next to the first faulty cell , going horizontally, is a second faulty memory cell  constituting a second fault or defect with in the first word line . In an embodiment, when the BIRA algorithm encounters two faulty cells in a single word line, a first logical steps dictates that a redundant row will be substituted for the defective component.","A faulty memory cell could be an actual faulty defective bit cell within the memory, a defective multiplexor or sense amp going to that bit cell, a faulty input output circuit routing to that cell, some interconnection between those components going to that cell or some other condition to render the memory location inoperable. In an embodiment, a redundant component, such as either the redundant row or the redundant column, has the necessary components within the redundant component to substitute for any of those defects.","The exemplary use of the BIRA algorithm assumes that the memory array  has two redundant columns, a first redundant column and a second redundant column as shown in . The exemplary use of the BIRA algorithm also assumes that the memory has two redundant rows, a first redundant row and a second redundant row. Additionally assumed is that the memory array  has been split into an upper bank  and a lower bank . The specific amounts of components and the types of components are just examples to illustrate an embodiment of the invention. One or more of any of these components could exist. In an embodiment, the BIRA algorithm examines these variables as shown in .",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 11","FIG. 15"],"b":["0","1022","1","1012","0","1022","1","1016","1","1016","1032","2","1020","1","1012","1018"]},"Referring to , the BIRA algorithm continues marching in a forward direction on the first pass through the addresses of the memory array . The BIRA algorithm finishes its analysis of row address   and starts its analysis of row address- . The BIRA algorithm detects a fourth faulty cell in the upper bank  in the second word line. The BIRA algorithm determines that this is a single faulty cell contained in a word line and therefore follows the second logical step to replace the single faulty cell with a redundant column. The BIRA engine changes the contents in column register-Col_H  from a logical 0 to a logical 1 to indicate the column address of the defective component. The cross-reference register Row_H  changes it's content to reflect a 1 which is the row address connecting or cross referencing the defective row with the defective column.","Referring to ,  illustrates the first BIRA algorithm continuing its forward march on the first pass through the memory array . The BIRA algorithm detects a fifth faulty memory cell in the third word line contained in the lower bank . According to the second logical step, since the BIRA algorithm detects only a single error, the BIRA algorithm assigns a redundant column to substitute for the defective faulty component. Thus, the BIRA engine changes the contents in column register Col_L  to record a logical 1 in memory block corresponding with fifth column address to indicate that the second redundant column has been assigned to substitute for the fifth memory column in the fifth address slot. The BIRA engine changes the contents in cross reference register Row_L  to record row address  , in order to reflect the row address corresponding to the defect which caused the redundant row to be assigned to that defective column. The second redundant column replaces the defective column in fifth address slot, which is reflected by the contents in the column register Col_L  and cross reference register Row_L .","Referring to ,  illustrates the BIRA algorithm continuing a forward march through the memory array  on the first pass. The BIRA algorithm examines the fourth word line in both the lower bank  and in the upper bank . The BIRA algorithm detects a sixth memory fault in the lower bank  occurring in the fifth column address. The BIRA algorithm references the BIRA registers and detects that the second redundant column has been assigned to substitute for this defective memory cell already through contents of column register Col_L . The BIRA algorithm then continues its forward march through the memory array  and discovers a single defect in the seventh faulty memory cell located within the upper bank  occurring in column address . The BIRA algorithm references the BIRA registers and detects that the first redundant column has substituted for this defective component already. The BIRA algorithm references the column register Col_H  and detects that the contents reflect column address .","Referring to ,  illustrates the first BIRA algorithms continued march through the memory array  on the first pass. The BIRA algorithm examines defects in the fifth word line contained in the memory array . The BIRA algorithm detects a single fault occurring in the fifth word line contained in the lower bank . The eighth faulty memory cell is located in column address . The BIRA algorithm does not have any redundant columns left to replace this single fault with a redundant column, therefore according to the second logical step, the BIRA algorithm uses an available redundant row to replace this defective component.","Thus, the BIRA engine assigns the second redundant row to globally replace the bottom word line in the lower bank  and the bottom word line in the upper bank . The BIRA registers reflect this change. The BIRA engine changes the contents in row register Row  to reflect row address number 4 and stores the faulty row address in its contents. The BIRA engine changes the contents in status bit register En  to a logical 1 to indicate that the second redundant row is not longer available to substitute for the defective component. However, since a single fault was detected, then the state of decision for this redundant row is only tentatively set. The BIRA algorithm then proceeds to examine the memory addresses in the upper bank  and detects multiple faults, a ninth faulty memory cell existing in column address  and a tenth faulty memory cell existing in column address . The BIRA algorithm references the BIRA registers and detects that row register Row  assigns the second redundant row to replace row address  . Therefore, the BIRA algorithm determines that these errors are already covered by a redundant component.","The BIRA algorithm then goes to the fourth logical step, once the highest memory address is achieved and checks to see if all the faults in this memory array  were substituted by redundant components. In this example, the redundant components substitute for the defective components in order to replace every defect that occurred in this memory array . The BIRA algorithm then determines that this memory array  is repaired on the first pass. Therefore, the BIRA algorithm need not continue the BIRA algorithm with a second testing pattern such as a second pass, third pass, or fourth pass through this memory array .","Once the BIRA algorithm determines that one of passes or testing techniques, in this case the first pass, was successful, then the BIRA algorithm locks in the state of decision contained in the BIRA registers for each redundant component and sends the fault information onto the reconfiguration data engine. Thus, this example illustrates an embodiment of how the BIRA algorithm performs dynamic allocation and swapping of redundant components while still testing or detecting faults in the memory. The BIRA algorithm may optimize the final organization and allocation of assigning redundant components in order to replace defective components associated with the memory.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 16","FIG. 25","FIG. 16"],"b":["1632","1618","6","1618","5","1618","1620","1","1620","2","1620"]},"Referring to , the BIRA algorithm starts with the first pass. The BIRA algorithm encounters a first memory defect in the lower bank  in the sixth column address. In a single fault failure the BIRA engine assigns a redundant column to replace the defective component and sets the state of decision as tentatively set. Column register Col_L  changes the contents of its register to a logical 1 in the sixth column address position to reflect that the first redundant column has been assigned to replace the column in the sixth column address. Cross reference register Row_L  changes the content in its register to read a logical 0 to indicate the first defective memory cell is also found in row address  .","Referring to , the BIRA algorithm continues a forward march through the memory addresses by proceeding to the second word line. The second word line in the lower bank  contains no defects. The BIRA algorithm does detect a defect in the second word line in the upper bank  contained in column address . Upon detecting a single fault failure the BIRA engine assigns a second redundant column to replace the defective component. Column register Col_H  changes the contents of its register to a logical 1 in the first column address position to reflect that the second redundant column has been assigned to replace column . Cross reference register Row_L  changes the contents in its register to reflect that the memory defect covered by the second redundant column also occurs in row address  .","Referring to , the BIRA algorithm continues its march through the first pass of the memory addresses of the memory array . The BIRA algorithm detects a fault in the third word line contained in the lower bank  occurring in column address . Upon detecting a single fault failure, the BIRA algorithm would assign a redundant column to substitute for the defective component. However, according to the second logical step, if no redundant columns are available, then the BIRA algorithm assigns a redundant row. Row register Row  reflects the assignment of the first redundant row by recording the row address   in its contents. Status bit register En  changes the contents in its register to a logical 1 to reflect that the first redundant row is no longer available to be assigned to substitute for a defective memory component.","Referring to , the BIRA algorithm continues its forward march using the first pass through the memory array  starting at the fourth word line in the lower bank . The BIRA algorithm detects a single fault failure in the fourth word line in the lower bank  occurring in column address . The BIRA algorithm having no redundant columns available assigns a redundant row to substitute for this defect. The BIRA registers reflect the assignment of the second redundant row by row register Row  changing the contents of its register to record row address  . Status bit register En  changes the contents in its register to a logical 1 to indicate that the second redundant row in no longer available to substitute for a defective component. The BIRA algorithm then proceeds to detect a defective memory cell in the upper bank  contained in row address  . The BIRA algorithm references the BIRA registers to detect that the row register Row  contains a row address   already, thereby, substituting the second redundant row covering that defective component.","Referring to , the BIRA algorithm continues the forward march using the first pass though the memory array . The BIRA algorithm detects a fault in the fifth word line in the upper bank  in the column address . Upon detecting a single fault, the BIRA algorithm attempts to use a second logical step to assign a redundant column, however in this case all of the redundant columns have already been assigned. The BIRA algorithm references the BIRA registers and both column registers indicate that the redundant columns have been assigned and their corresponding status bit registers for those columns (not shown) indicate that those redundant columns have been assigned. The BIRA algorithm then tries to proceed to the second part of the second logical step and assign a redundant row to fix this error. However, the BIRA algorithm references the BIRA registers and discovers that the status bit registers for both redundant rows indicate that neither of the redundant rows is available to be assigned to substitute for a defective component. Therefore the BIRA algorithm determines that it has no available redundant components to assign to substitute for the defect found in the fifth word line in the upper bank . The BIRA algorithm determines that the redundant component cannot be substituted and cover all the defects in the memory array . The BIRA algorithm then proceeds by resetting all the registers and starting a second pass to try to repair this memory array .",{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 22","b":["1632","1632","1632","1632","1632"]},"As noted, the BIRA algorithm commences the second pass by starting at the highest memory address and proceeding to the lowest memory address. The BIRA algorithm commences its sequential march through the memory addresses in the upper bank  in the fifth word line. The BIRA algorithm detects a faulty memory cell in column address . The BIRA algorithm detects a single fault in the fifth word line and therefore, in accordance with the second logical step, assigns a redundant column to substitute for that defective component. The BIRA registers reflect the assignment of the first redundant column. Column register Col_H  changes the its content to correspond to column address  to indicate that a first redundant column has been assigned to substitute for the defective second column. Cross-reference register Row_H  changes the contents in its register to store the address of the corresponding row of this defective memory cell. Thus, cross-reference register Row_H  changes its contents to reflect column address .",{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 22","b":["1632","1620","2","3","1628","1602","3","1628"]},"Referring to , the BIRA algorithm continues with its backwards march through the memory address in row address  . In the lower bank , the BIRA algorithm detects a fault memory cell in the lower bank  in column address . Upon detecting a single fault, the BIRA algorithm assigns a redundant column to replace the defective component. The BIRA registers reflect this assignment of the second redundant column. Column registers Col_L  changes the content in the register corresponding to the fifth column address location to a logical 1. This indicates that the second redundant column has been assigned to substitute for a fifth column contained within the lower bank . Additionally the cross-reference register Row_L  changes its contents to reflect the row address that cross references to this faulty memory cell that has been replaced by a redundant column. The cross-reference register changes its content to read row address  .","The BIRA algorithm continues with its backwards march through the addresses. In row address  , the BIRA algorithm detects no errors in the upper bank . However, the BIRA engine detects an error in row address   and column address  of the lower bank . The BIRA engine references the BIRA registers and detects that this defect occurs in the fifth column. Thus, the second redundant row already substitutes for this defective component. The BIRA algorithm then may proceed with its backwards march of the next row of addresses.","Referring to , the BIRA algorithm detects a defect in row address   in the first column contained within the upper bank . The BIRA algorithm according to the second logical step first tries to assign a redundant column to repair this single defect in a word, however, the BIRA engine determines that both the first redundant column and second redundant column are unavailable to be assigned as substitutes. Therefore, according to the second logical step, the BIRA engine assigns the first redundant row to substitute for the defective component containing this faulty memory cell. The BIRA registers reflect this assignment of this first redundant row. Accordingly, row register Row  changes the content of its register to a logical 1 to represent the row address of the component containing the defect that it is substituting. Status bit register En  changes the content of its registers to a logical 1 to indicate that the first redundant row is no longer available to be assigned as a substitute component.","The BIRA algorithm continues its backward march through the memory array  and detects no faults in the second word contained in the lower bank . Also, the BIRA algorithm detects no faults in the top word contained in the upper bank .","Referring to , the BIRA algorithm detects a fault in column address  and row address   of the lower bank . According to the second logical step, the BIRA algorithm checks and sees that there are no redundant columns available and thus assigns a redundant row to replace a this single defect that it discovered in the first word line in the lower bank . The BIRA registers reflect this assignment of the second redundant row. The row register Row  changes the content in its register to reflect the address of the defective component, in this case the defective row, row address  . The status bit register En  changes the content in its register to reflect logical 1 to indicate that the second redundant row is no longer available to be assigned as a substitute component.","The BIRA algorithm reaches the lowest address in the memory array  and proceeds to the fourth logical step. Upon proceeding to the fourth logical step, the BIRA algorithm determines that this memory is repaired because all the defects have been substituted for by redundant components. The BIRA algorithm then changes the state of decision for the redundant components to locked in and sends the repair information onto the reconfiguration data engine.",{"@attributes":{"id":"p-0086","num":"0085"},"figref":["FIG. 26","FIG. 30","FIG. 26"],"b":["2618","2620","0","2622","2","2626","3","2628","2620","1","2","2626","4","2630","2632","2632"]},"The third pass sequentially marches through the memory array  addresses from lowest to highest, however the second logical step is altered to replace the very first single memory fault encountered with a redundant row rather than with a redundant column. Thus,  illustrates the starting condition of the BIRA algorithm and the BIRA registers after being reset at the completion of the unsuccessful second pass. The BIRA registers including the column register the cross-reference register the row register and the status bit registers are reset to a condition of a logical 0.","Referring to , the BIRA engine commences the BIRA algorithm by analyzing row address   and detects a faulty memory cell in the first word line in the lower bank  at column address . Upon detecting the single fault, the BIRA algorithm then replaces the single fault with a redundant row vice a redundant column. The BIRA engine assigns the first redundant row to substitute for the defective component. The BIRA registers reflect this assignment. The column register Row  changes its content to the row address that corresponds to the faulty memory cell and thus contains row address  . The status bit register En  changes its contents to reflect a logical 1 to indicate that the first redundant row is no longer available to be substituted for a defective component.","Referring to , the BIRA algorithm continues marching though the memory array  and detects no errors in the first word line in the upper bank  at row address  . The BIRA algorithm then checks row address   of the lower bank  and detects no errors. The BIRA algorithm then detects a single fault in the second word line in the upper bank  contained within row address  . The BIRA algorithm, in accordance with the second logical step, replaces the single fault failure in that word with a redundant column.","The BIRA registers reflect this assignment of a redundant column to replace the faulty memory cell. Column register Col_H  changes its content in the bit position corresponding to column address  to reflect that the first redundant column has been assigned to substitute for column  in the upper bank . The cross reference register Row_H  also changes the contents to a logical 1 to indicate that the faulty memory cell now substituted by the first redundant column cross references to row address  . Thus, cross-reference register Row_H  stores a logical 1.","Referring to , the BIRA algorithm continues to sequentially march through the addresses of the memory array  and detects the next defect in the third word line contained within the lower bank . Column address  contains the faulty memory cell. Upon detecting a single fault failure in the word line, the BIRA algorithm, in accordance with the second logical step, replaces a single fault failure with a second redundant column. The BIRA registers reflect this assignment of the second redundant column. The column register Col_L  changes the content of its register corresponding to column address  to a logical 1. The cross-reference register Row_L  changes its contents to reflect the row address that cross references to the second redundant column. Thus the cross-reference register in this case changes its contents to row address .","The BIRA algorithm then continues to march on and finds a defect in the third word line contained in the upper bank  at column address . The BIRA algorithm references the BIRA registers and detects that the first redundant column substituting for the second column in the upper bank  already covers this faulty memory cell.","The BIRA algorithm continues to march forward through the memory addresses in the memory array . The BIRA algorithm detects a faulty memory cell in row address   of the lower bank . The faulty memory cell is also located in column address . The BIRA algorithm references the BIRA registers and detects that the faulty memory cell in column address  in the lower bank  is already covered by substitution of the second redundant column. Column register Col_L  contains column address . Thus, the BIRA algorithm continues to march through the memory addresses and detects no further errors in row address  .","Referring to , the BIRA algorithm continues the forward march through the memory addresses starting at column address  and detects no errors in the fifth word line contained within the lower bank . The BIRA algorithm then detects a fault in the fifth word line contained in the upper bank . The faulty memory cell exists in the row address   and also in column address . The BIRA registers and finds that this faulty cell is not covered by any redundant component at this point.","Being a single fault failure within a single word, the BIRA engine, in accordance with the second logical step, checks to see if any redundant rows are available to substitute for the defective component containing this faulty memory cell. The status bits for the redundant columns (not shown) indicate that the first redundant column and the second redundant column are unavailable to be assigned as substitute components.","The BIRA algorithm then checks to see if any redundant rows are available to be assigned as a substitute component to replace the component containing this faulty memory cell. The BIRA engine detects that after referencing the BIRA registers that the second redundant row is available to be assigned as a substitute component. The BIRA engine then assigns the second redundant row to replace this faulty memory cell found in the row address  . The BIRA engine reflects this assignment. Row register Row  changes its content within its register to indicate row address  . The status bit register En  changes its contents to a logical 1 to indicate that the second redundant row is no longer available to be used as a substitute component.","The BIRA algorithm eventually reaches the highest address in the memory array  and determines that no further faults exist. The BIRA algorithm proceeds to the fourth logical step. The BIRA algorithm has covered all of the existing defects in the memory array  with redundant components and determines that the memory is repaired. The BIRA engine then changes the state of decision for the redundant components stored in the BIRA registers to a locked in state of decision and sends the repair information and fault information to the reconfiguration data engine.","If the BIRA engine had not successfully repaired this memory array  then the BIRA engine would have reset the BIRA registers and preceded with the fourth pass thorough this memory array  in an attempt to repair this memory array . This allocation of redundant components to repair faults found in the memory can occur at power up or start up. In an embodiment, each time this redundancy allocation can differ and change in the field as different defects occur to the memory array .","The sequence of operations for the algorithm may be stored in a machine-readable medium. A machine-readable medium includes any mechanism that provides (i.e., stores and\/or transmits) information in a form readable by a machine (e.g., a computer). For example, a machine-readable medium includes read only memory (ROM); random access memory (RAM); magnetic disk storage media; optical storage media; flash memory devices; electrical, optical, acoustical or other form of propagated signals (e.g., carrier waves, infrared signals, digital signals, etc.).","While some specific embodiments of the invention have been shown the invention is not to be limited to these embodiments. For example, most functions performed by electronic hardware components may be duplicated by software emulation. Thus, a software program written to accomplish those same functions may emulate the functionality of the hardware components in input-output circuitry. The application specific processor may be a finite state machine. The BIRA algorithm may make one or more passes through the memory array and alter how redundant components are assigned. The invention is to be understood as not limited by the specific embodiments described herein, but only by scope of the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The drawings refer to the invention in which:",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 11","FIG. 15"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 16","FIG. 25"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 26","FIG. 30"]}]},"DETDESC":[{},{}]}
