---
title: Window server event taps
abstract: Methods, devices and an associated application programming interface are described that permits a user to register event tap routines (“ETRs”) with an application such as, for example, a window server application. Event tap routines permit events such as human interface device events to be processed at multiple points and in a manner not provided during normal window server operations. Event tap routines may effect passive or active event responses. Passive ETRs may merely record the occurrence of an event or the time between successive events without modifying or altering the event's processing sequence within a window server. Active ETRs, on the other hand, effect some programmatic response to an event. For example, active ETRs may modify the state of an event, delete the event, create one or more additional events or cause the event to be processed “out of sequence” by the window server application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08438580&OS=08438580&RS=08438580
owner: Apple Inc.
number: 08438580
owner_city: Cupertino
owner_country: US
publication_date: 20100923
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This disclosure is a continuation application and claims priority to U.S. patent application Ser. No. 11\/020,875, now U.S. Pat. No. 7,818,755, entitled \u201cWindow Server Event Taps\u201d by Michael J. Paquette, filed 22 Dec. 2004 which is incorporated by reference in its entirety.","The invention relates generally to graphically-oriented computer operating systems and more particularly, but not by way of limitation, to a method and system for processing events in general and human interface device events in particular.","Most modern computer systems employ operating systems that support graphical user interfaces. Central to these operating systems is the use of a low-level application referred to as a \u201cwindow server.\u201d One function of a window server is to receive, annotate and route signals from external devices (e.g., human interface devices such as keyboards, pointer devices and tablets) to the appropriate application (e.g., an audio, video or multimedia application). It will be recognized that most modern operating systems treat signals generated by human interface devices as \u201cevents\u201d which are typically embodied as data structures or objects. In accordance with this view, human interface devices generate input signals which are received by the operating system, converted to an event (ordinarily by a software routine referred to as a \u201cdevice driver\u201d) and passed to the window server. The window server, in turn, associates each event with a given user or session through a series of processing steps and routes the event to the appropriate application.","This general architecture permits a software developer to customize an application's event-driven interaction with a user. In accordance with one prior art approach, for example, a developer may use an Application Programming Interface (\u201cAPI\u201d) to obtain access to events immediately prior to their being delivered to a specified application. Event receipt may be used to trigger execution of a developer-specified routine to effect the desired (i.e., modified) human interface device response. In accordance with another prior art approach, all events sent to a window server may be intercepted and processed in accordance with customized developer routines to identify and extract those events for which specialized processing is desired.","One drawback to the former approach is that it limits event response customization to unique\/specified applications. One drawback to the latter approach is that it requires developers to develop custom software to receive and identify those events they wish to process and, further, to ensure that those events are subsequently sent to the operating system's window server for conventional processing. Another drawback to the latter approach is that it requires all applications executing in such an environment to communicate with the customized event screening software rather the standard window server application.","Thus, it would be beneficial to provide a means for responding to human interface device events as they are processed by a window server-on receipt (input), immediately prior to being routed to the appropriate application (output) and at processing points within the window server between its input and output.","The invention provides a method to process user interface events through the use of event tap routines (\u201cETRs\u201d). As used herein, an \u201cevent tap routine\u201d is a procedure that is invoked by one or more of a plurality of points during event processing by a controlling application such as, for example, a window server application. Event tap routines may effect passive or active event responses. Passive ETRs may record the occurrence of an event or the time between successive events without modifying or altering the event's processing sequence within a window server. Active ETRs may be used to effect some programmatic response to an event. In one embodiment, the invention provides a method that includes receiving a user interface event from an operating system, identifying the user interface event as belonging to at least one of a plurality of registered user interface event types, determining the user interface event is associated with an event processing routine, causing the event processing routine to process the user interface event and receiving a result from the user-level event processing routine. Methods in accordance with the invention may be stored in any media that is readable and executable by a computer system.","In another embodiment, the invention provides a user interface event application programming interface (API) including a function allowing a user to register an event processing routine at a specified one of a plurality of user interface event taps within a window server application, wherein the registered event processing routine is associated with a specified user interface event type and is invoked when an event of the associated type is received by the window server application at the specified tap.","Methods and devices to process human interface device events  are described. In the disclosed embodiments (see ), applications  utilize application programming interface (\u201cAPI\u201d)  to register event tap routines (\u201cETR\u201d)  with window server application . Event tap routines  permit events  to be processed at multiple points (e.g., tap- to tap-N) and in a manner not provided during normal window server operations . Event tap routines (which may also be referred to as event filter routines) are separate from and not necessarily associated with the application to which the event is targeted. Illustrative applications  include, but are not limited to, user-level applications such as audio, video and multimedia applications\u2014each of which may present one or more windows to the user. Illustrative human interface devices include, but are not limited to, pointer devices (e.g., a mouse, trackpad, trackball and joystick), keyboards, control devices (e.g., a front panel knob, switch, slider or button or a game's data glove, throttle or steering wheel) and display devices. As used herein, events are user actions initiated through one or more human interface devices.","Event processing in accordance with the invention may be passive or active. Passive ETRs may, for example, merely record the occurrence of an event or the time between successive events without modifying or altering the event's processing sequence (e.g., ) within window server . Active ETRs, on the other hand, effect some programmatic response to an event. For example, active ETRs may be used to effect human interface device event responses that conform to Section 508 of the Rehabilitation Act of 1973 (see 29 U.S.C. 794), a primary purpose of which is to ensure that electronic and information technology equipment purchased by Federal agencies is accessible to, and usable by, individuals with disabilities. Active ETRs in accordance with the invention may also change an event's type, alter the processing sequence of an event by window server , delete an event so that further processing of the event by window server  is halted, or generate one or more additional events that are then processed by window server .","The following descriptions are presented to enable any person skilled in the art to make and use the invention as claimed and is provided in the context of the particular examples discussed below, variations of which will be readily apparent to those skilled in the art. Accordingly, the claims appended hereto are not intended to be limited by the disclosed embodiments, but are to be accorded their widest scope consistent with the principles and features disclosed herein.","As noted above, ETRs are registered with window server  through API , one embodiment of which is defined in the section entitled \u201cIllustrative API\u201d of this disclosure. Registration permits a user to specify an ETR that is to be performed at one or more of a plurality of points (\u201ctaps\u201d) during window server human interface device (\u201cHID\u201d) event processing. When an ETR registers, it identifies one or more events to be observed, an action to be performed (e.g., a routine or function to execute) and indicates whether the ETR is passive or active. In one embodiment, routines may be designated to run when an event is (1) received and accepted by window server \u2014a HID type event, (2) prior to being associated with a specific session or user\u2014a session type event, (3) after being associated with a specific session or user\u2014an annotated session type event and\/or (4) immediately prior to being routed to a target application\u2014a connection type event.","Referring to , the general operation of window server  in accordance with the invention is illustrated. As events  are received by window server  a first check  is performed to determine if the event is associated with a registered HID event type. If it is, HID ETR  is performed. During continued window server event processing (blocks  through ), one or more additional checks  may be made and additional ETRs executed (block ). Prior to routing an event to its targeted application\/window , a final check  may be made to cause application and\/or window specific processing to occur via ETR . One of ordinary skill in the art will recognize that the multiple-event-tap architecture of  is applicable to not only the operation of window server , but also to messages transmitted between various applications\u2014operating system or user-level applications. In a MAC OS\u00ae environment, for example, events may be generated by one application and sent to another application by way of Apple events using AppleScript. (AppleScript\u00ae is a registered trademark of Apple Computer, Inc. of Cupertino, Calif.)","A specific embodiment of window server  as designed and implemented for the MAC OS\u00ae X operating system is illustrated in . (MAC OS is a registered trademark of Apple Computer, Inc. of Cupertino, Calif.) As events  are received, each is time-stamped and checked to determine if it is consistent with the current state of the computer system\u2014that is, not spurious (block ). Illustrative HID events  include, but are not limited to, keystrokes, mouse movements and\/or clicks, trackpad movements and\/or clicks, tablet events, scroll wheel actions, computer system power switch activation, suspend and resume actions associated with a specific application and\/or process, computer system sleep and wake events, display brightness changes, volume control changes and timer activations. That is, substantially any user interface input event.","A check is then made to determine if at least one HID type event ETR has been registered with window server  (block ). If a HID ETR has been registered (the \u201cYES\u201d prong of block ), the appropriate HID ETR is invoked (block ). HID ETR  represents one or more registered ETRs, each of which may have its own callback routine to effect its desired action. In one embodiment, each event is presented to the registered ETR as an opaque object, referenced by a number of keys, to return an appropriate value. If an ETR's callback routine fails to return cleanly, the ETR associated with the callback function is disabled. This can happen, for example, if the callback function raises an exception rather than returning. (The affected application may re-establish an event tap after a timeout period has expired.) On completion of the one or more HID ETRs (block ) or in the event no HID type ETR has been registered (the \u201cNO\u201d prong of block ), the overall state of the user interface is updated (block ). Acts in accordance with block  include, for example, moving the displayed cursor's position or presentation and updating the state of any user interface element (e.g., windows and applications). In some operating systems, HID events A from, for example, tablets are input to window server  at block . Once admitted to window server , events A may be processed in accordance with any remaining event tap check (e.g., at blocks , , and\/or ).","Next, a check is made to determine if at least one session type event ETR has been registered with window server  (block ). If a session ETR has been registered (the \u201cYES\u201d prong of block ), the appropriate session ETR is invoked (block ). It will be recognized that a \u201csession\u201d is that collection of applications and processes associated with a single user login. Following the acts of block  or when no session type event ETR has been registered (the \u201cNO\u201d prong of block ), the current event object is annotated to, for example, identify the window and connection (e.g., owner\/application) associated with the event (block ). A check is then made to determine if at least one annotated session type event ETR has been registered with window server  (block ). If an annotated session ETR has been registered (the \u201cYES\u201d prong of block ), the appropriate annotated session ETR is invoked (block ). Following the acts of block  or when no annotated session type event ETR has been registered (the \u201cNO\u201d prong of block ), the current event object is routed to its associated connection (block ). If at least one connection type event ETR has been registered with window server  (the \u201cYES\u201d prong of block ), the appropriate connection ETR is invoked (block ). Following the acts of block  or when no connection type event ETR has been registered (the \u201cNO\u201d prong of block ), the current event object is delivered to its application\/process (block ).","In one embodiment, when an event is passed to an ETR, window server  continues to be responsive to remote procedure calls. In addition, the ordering of events is maintained. That is, events not being filtered (events processed via the \u201cNO\u201d prongs of blocks , ,  or ) are not permitted to pass earlier events which are being filtered (events processed via the \u201cYES\u201d prongs of blocks , ,  or ).","As noted above and detailed in the section Illustrative API, each ETR may be passive or active. If the ETR is passive, it does not generate any side-effects. If the ETR is active, its callback routine may be used to effect any desired action. For example, active ETRs may pass an event back to window server  unmodified (e.g., at , ,  or ), modify an event, discard an event or create one or more additional events that are inserted in window server processing at any specified tap point (e.g., at , ,  and\/or ).","For security reasons, in one embodiment keyboard events are not routed to any event tap other than the HID type tap (block ) when secure text input is active. It will be recognized that \u201csecure input\u201d is a mode of operation that prevents a program from reading the text input or keyboard events which are directed to the \u201cforeground\u201d or currently active program. Secure text input is typically used for entering passwords and similar sensitive data that other programs should not see. In addition, a notification of secure input being active may be posted through, for example, an API. For the same reasons, if an ETR modifies an event so as to make it a keyboard event, that event will not be passed to any further taps on it's way to its associated application while secure text input is active. It will be recognized that HID type ETRs or taps (see block ) have access to events from all sessions and for all users. Thus, some embodiments may restrict the registration of HID type ETRs to the super-user or administrator (e.g., the \u201croot\u201d user). In contrast, session taps (e.g., blocks ,  and ) process events for only a specific user. Accordingly, registered ETRs for these event types may be placed under the same security constraints as the session owner. In another embodiment, an emergency override key sequence not likely to be encountered by accident is provided to disable all active taps. This will allow a user to regain control over a window server in which an ETR has disrupted normal event flow.","One benefit of the invention is that it provides a user with the ability to customize an application's response to a human interface device event at multiple locations within a window server's processing scheme. Another benefit of the invention is that it provides an easy to use API to facilitate the registration and revocation of ETRs. Yet another benefit of the invention is that device event response can be passive or active, where an active response can include the modification or deletion of the triggering event or the creation of one or more additional events. Still another benefit of the invention is that techniques in accordance therewith allows the addition of system-wide behaviors in response to input events. Such behaviors may be added by a third party (e.g., software vendor) without modifying the operating system or the operating system's window server application. Modified system-wide behaviors may include support for novel user input methods or the addition of specialized feedback in response to input events, such as sound or tactile feedback, for example.","Various changes in the components and in the details of the illustrated operational methods are possible without departing from the scope of the following claims. For instance, the illustrative system of , window server  is illustrated as being a monolithic application. This is not necessary. In addition, acts in accordance with  may or may not incorporate the ability to receive events from external devices such as, for example, tablets (denoted as element A in ). Further, more than one event tap routine may be registered at any given tap location (e.g., , ,  and  in ) and that multiple tap routines at multiple tap locations may simultaneously be registered and active. It will also be recognized that acts in accordance with  may be embodied in computer software, that such software may execute at the kernel (protected), the user (unprotected) level or a combination of kernel and user levels within an operating system. For example, window server operations identified in  at elements , , ,  and  may be performed by computer software executing at the kernel level while individual event tap routines (or, more precisely, ETR callback functions) may operate at the user level. In another embodiment, events  (see ) may originate from an application other than the operating system or an external device. For example, one of ordinary skill in the art will recognize that Apple Events (and AppleScript\u00ae) may be created and sent by a first application to a second application.","It will also be recognized that computer programs may be executed by a programmable control device. A programmable control device may be a single computer processor, a special purpose processor (e.g., a digital signal processor, \u201cDSP\u201d), a plurality of processors coupled by a communications link or a custom designed state machine. Custom designed state machines may be embodied in a hardware device such as an integrated circuit including, but not limited to, application specific integrated circuits (\u201cASICs\u201d) or field programmable gate array (\u201cFPGAs\u201d). Storage devices suitable for tangibly embodying program instructions include, but are not limited to: magnetic disks (fixed, floppy, and removable) and tape; optical media such as CD-ROMs and digital video disks (\u201cDVDs\u201d); and semiconductor memory devices such as Electrically Programmable Read-Only Memory (\u201cEPROM\u201d), Electrically Erasable Programmable Read-Only Memory (\u201cEEPROM\u201d), Programmable Gate Arrays and flash devices.","Illustrative API:","The following illustrative embodiment of an Application Programming Interface (\u201cAPI\u201d) in accordance with the invention is applicable to the Apple\u00ae OS X operating system. (Apple is a registered trademark of Apple Computer, Inc. of Cupertino, Calif.)","CGEventSource:","The CGEventSource is an opaque representation of the source of an event. This API permits the user to obtain a CGEventSource from an event, and to create a new event with a CGEventSource. One typical usage would be to take the event source from an event entering the filter (ETR), and to use that source for any new events created as a result of the received event. This has the effect of marking the events as being related.","typedef struct_CGEventSource * CGEventSource;","CGEventRef:","The CGEventRef object may be created or copied, retained, released, and modified. The object provides an opaque representation of one low level hardware (human interface device) event.",{"@attributes":{"id":"p-0033","num":"0032"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/* Return the CFTypeID for CGEventRefs. *\/"]},{"entry":[{},"CG_EXTERN CFTypeID CGEventGetTypeID(void);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This API provides the ability to create a NULL event, or to create specialized events reflecting a state specified as parameters to the creation functions.",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/* Create a NULL event to be filled in. \u2018source\u2019 may be NULL. *\/"},{"entry":"CG_EXTERN CGEventRef CGEventCreate(CGEventSource source);"},{"entry":"\/*"},{"entry":"* Create mouse events."},{"entry":"* The event source may be taken from another event, or may be"},{"entry":"* NULL. mouseType should be one of the mouse event types."},{"entry":"* mouseCursorPosition should be the global coordinates the mouse"},{"entry":"* is at for the event. For kCGEventOtherMouseDown,"},{"entry":"* kCGEventOtherMouseDragged, and kCGEventOtherMouseUp events,"},{"entry":"* the mouseButton parameter should indicate which button is"},{"entry":"* changing state."},{"entry":"* The current implementation of the event system supports a"},{"entry":"* maximum of thirty-two buttons. Mouse button 0 is the primary"},{"entry":"* button on the mouse. Mouse button 1 is the secondary"},{"entry":"* mouse button (right). Mouse button 2 is the center button, and"},{"entry":"* the remaining buttons would be in USB device order."},{"entry":"*\/"},{"entry":"CG_EXTERN CGEventRef CGCreateMouseEvent(CGEventSource"},{"entry":"source,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGEventType mouseType,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGPoint mouseCursorPosition,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGButtonCount mouseButton );"},{"entry":"\/*"},{"entry":"* Create keyboard events."},{"entry":"* The event source may be taken from another event, or may be NULL."},{"entry":"* Based on the virtual key code values entered,"},{"entry":"* the appropriate key down, key up, or flags changed events are"},{"entry":"* generated."},{"entry":"* All keystrokes needed to generate a character must be entered,"},{"entry":"* including SHIFT, CONTROL, OPTION, and COMMAND keys."},{"entry":"For example,"},{"entry":"* to produce a \u2018Z\u2019, the SHIFT key must be down, the \u2018z\u2019 key must go"},{"entry":"* down, and then the SHIFT and \u2018z\u2019 key must be released:"},{"entry":"* CGCreateKeyboardEvent((CGKeyCode)56, true ); \/\/ shift down"},{"entry":"* CGCreateKeyboardEvent((CGKeyCode)6, true ); \/\/ \u2018z\u2019 down"},{"entry":"* CGCreateKeyboardEvent((CGKeyCode)6, false ); \/\/ \u2018z\u2019 up"},{"entry":"* CGCreateKeyboardEvent((CGKeyCode)56, false ); \/\/ \u2018shift up"},{"entry":"*\/"},{"entry":"CG_EXTERN CGEventRef CGCreateKeyboardEvent(CGEventSource"},{"entry":"source,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGKeyCode virtualKey,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003bool keyDown );"},{"entry":"CG_EXTERN CGEventRef CGEventCopy(CGEventRef event);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"CFRetain( ) and CFRelease( ) may be used to retain and release CGEventRefs. A set of type codes, accessor functions, and data tags are defined to permit access and modification of data within CGEventRefs.","Event Type Codes:","The following enumeration describes all event types currently presented in this API.",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/* Event types *\/"},{"entry":"typedef enum {"},{"entry":"\/* mouse events *\/"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003kCGEventLeftMouseDown =","1,","\/* left mouse-down event *\/"]},{"entry":["\u2003\u2003kCGEventLeftMouseUp =","2,","\/* left mouse-up event *\/"]},{"entry":["\u2003\u2003kCGEventRightMouseDown =","3,","\/* right mouse-down"]},{"entry":[{},{},"event *\/"]},{"entry":["\u2003\u2003kCGEventRightMouseUp =","4,","\/* right mouse-up event *\/"]},{"entry":["\u2003\u2003kCGEventMouseMoved =","5,","\/* mouse-moved event *\/"]},{"entry":["\u2003\u2003kCGEventLeftMouseDragged =","6,","\/* left mouse-dragged"]},{"entry":[{},{},"event *\/"]},{"entry":["\u2003\u2003kCGEventRightMouseDragged =","\u20027,","\/* right mouse-dragged"]},{"entry":[{},{},"event *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/* keyboard events *\/"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003kCGEventKeyDown =","10,","\/* key-down event *\/"]},{"entry":["\u2003\u2003kCGEventKeyUp =","11,","\/* key-up event *\/"]},{"entry":["\u2003\u2003kCGEventFlagsChanged =","\u200212,","\/* flags-changed"]},{"entry":[{},{},"(modifier *\/"]},{"entry":[{},{},"\/* event keys) *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/* Specialized control devices *\/"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003kCGEventScrollWheel = 22,","\/* Scroll wheel input"]},{"entry":[{},"device *\/"]},{"entry":["\u2003\u2003kCGEventTabletPointer = 23,","\/* specialized tablet"]},{"entry":[{},"pointer *\/"]},{"entry":[{},"\/* event, in addition to *\/"]},{"entry":[{},"\/* tablet mouse event *\/"]},{"entry":["\u2003\u2003kCGEventTabletProximity = 24,","\/* specialized tablet"]},{"entry":[{},"prox- *\/"]},{"entry":[{},"\/* imity event, in"]},{"entry":[{},"addition *\/"]},{"entry":[{},"\/* to tablet mouse event *\/"]},{"entry":["\u2003\u2003kCGEventOtherMouseDown = 25,","\/* Mouse button 2-31"]},{"entry":[{},"down *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2003\u2003kCGEventOtherMouseUp = 26, \/* Mouse button 2-31 up *\/"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003kCGEventOtherMouseDragged = 27","\/* Drag with mouse"]},{"entry":[{},"button *\/"]},{"entry":[{},"\/* 2-31 down *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} CGEventType;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Tablet devices may generate mice events with embedded tablet data, or tablet pointer and proximity events. The tablet events as mouse events allow tablets to be used with programs which are not tablet-aware.","High Level Accessor Functions:","The following functions provide high level access to selected event data.",{"@attributes":{"id":"p-0043","num":"0042"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef uint64_t CGEventTimestamp;"},{"entry":"typedef uint64_t CGEventFlags;"},{"entry":"CGEventSource CGEventGetSource(CGEventRef event);"},{"entry":"void CGEventSetSource(CGEventRef event, CGEventSource source);"},{"entry":"CGEventType CGEventGetType(CGEventRef event);"},{"entry":"void CGEventSetType(CGEventRef event, CGEventType type);"},{"entry":"CGEventTimestamp CGEventGetTimestamp(CGEventRef event);"},{"entry":"void CGEventSetTimestamp(CGEventRef event, CGEventTimestamp"},{"entry":"\u2003\u2003\u2003\u2003timestamp);"},{"entry":"CGPoint CGEventGetLocation(CGEventRef event);"},{"entry":"void CGEventSetLocation(CGEventRef event, CGPoint location);"},{"entry":"CGEventFlags CGEventGetFlags(CGEventRef event);"},{"entry":"void CGEventSetFlags(CGEventRef event, CGEventFlags flags);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Low Level Event Accessor Functions:","Additional low level functions provide access to specialized fields of the events include the following.",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"intmax_t CGEventGetIntegerValueField(CGEventRef event,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGEventField field);"},{"entry":"double CGEventGetDoubleValueField(CGEventRef event,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGEventField field);"},{"entry":"CGPoint CGEventGetPointValueField(CGEventRef event,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGEventField field);"},{"entry":"void CGEventSetIntegerValueField(CGEventRef event,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGEventField field,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003intmax_t value);"},{"entry":"void CGEventSetDoubleValueField(CGEventRef event,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGEventField field, double value);"},{"entry":"void CGEventSetPointValueField(CGEventRef event,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGEventField field, CGPoint point);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The CGEventSetPointValueField and CGEventGetPointValueField only works on fields capable of holding point data. The other functions work on any other field in the event record, performing the appropriate type conversions and range clamping automatically.","Low Level Event Accessor Keys:","Additional keys and values found in mouse events, including the OtherMouse events include the following.","kCGMouseEventNumber",{"@attributes":{"id":"p-0050","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["Key associated with an integer encoding the mouse button event number as an integer. Matching mouse-down and mouse-up events will have the same event number.\n\nkCGMouseEventClickState\n","Key associated with an integer encoding the mouse button clickState as an integer.","A clickState of 1 represents a single click. A clickState of 2 represents a double-click.","A clickState of 3 represents a triple-click.\n\nkCGMouseEventPressure\n","Key associated with a double encoding the mouse button pressure. The pressure value may range from 0 to 1.0, with 0 representing the mouse being up. This value is commonly set by tablet pens mimicking a mouse.\n\nkCGMouseEventButtonNumber\n","Key associated with an integer representing the mouse button number. The left mouse button reports as button 0. A right mouse button reports as button 1. A middle button reports as button 2 and additional buttons report as the appropriate USB button.\n\nkCGMouseEventDeltaX\n\nkCGMouseEventDeltaY\n","Key associated with an integer encoding the mouse delta since the last mouse movement event.\n\nkCGMouseEventInstantMouser\n","Key associated with an integer value, non-zero if the event should be ignored by the Inkwell subsystem.\n\nkCGMouseEventSubtype\n","Key associated with an integer encoding the mouse event subtype as a kCFNumberIntType."]}}}},{"@attributes":{"id":"p-0051","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"enum CGEventMouseSubtype {",{}]},{"entry":[{},"kCGEventMouseSubtypeDefault","= 0,"]},{"entry":[{},"kCGEventMouseSubtypeTabletPoint","= 1,"]},{"entry":[{},"kCGEventMouseSubtypeTabletProximity","= 2"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Tablets may generate specially annotated mouse events, which will contain additional keys and values. Mouse events of subtype CGEventMouseSubtypeTabletPoint may also use the tablet accessor keys. Mouse events of subtype kCGEventMouseSubtypeTabletProximity may also use the tablet proximity accessor keys.","Additional keys and values found in keyboard events include the following.","kCGKeyboardEventAutorepeat",{"@attributes":{"id":"p-0054","num":"0000"},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":["Key associated with an integer, non-zero when this is an autorepeat of a key-down, and zero otherwise.\n\nkCGKeyboardEventKeycode\n","Key associated with the integer virtual keycode of the key-down or key-up event.\n\nkCGKeyboardEventKeyboardType\n","Key associated with the integer representing the keyboard type identifier."]}}}},"Additional keys and values found in scroll wheel events include the following.",{"@attributes":{"id":"p-0056","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"kCGScrollWheelDeltaAxis1"]},{"entry":[{},"kCGScrollWheelDeltaAxis2"]},{"entry":[{},"kCGScrollWheelDeltaAxis3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":{"@attributes":{"id":"ul0005-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":["Key associated with an integer value representing a change in scrollwheel position.\n\nkCGScrollWheelEventInstantMouser\n","Key associated with an integer value, non-zero if the event should be ignored by the Inkwell subsystem."]}}}},"Additional keys and values found in tablet pointer events, and in mouse events containing embedded tablet event data include the following.",{"@attributes":{"id":"p-0058","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"kCGTabletEventPointX"]},{"entry":[{},"kCGTabletEventPointY"]},{"entry":[{},"kCGTabletEventPointZ"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0007","list-style":"none"},"li":{"@attributes":{"id":"ul0007-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0008","list-style":"none"},"li":["Key associated with an integer encoding the absolute X, Y, or Z tablet coordinate in tablet space at full tablet resolution.\n\nkCGTabletEventPointButtons\n","Key associated with an integer encoding the tablet button state as a kCFNumberLongType. Bit  is the first button, and a set bit represents a closed or pressed button.\n\nkCGTabletEventPointPressure\n","Key associated with a double encoding the tablet pen pressure. 0 represents no pressure, and 1.0 represents maximum pressure.\n\nkCGTabletEventTiltX\n\nkCGTabletEventTiltY\n","Key associated with a double encoding the tablet pen tilt. 0 represents no tilt, and 1.0 represents maximum tilt.\n\nkCGTabletEventRotation\n","Key associated with a double encoding the tablet pen rotation.\n\nkCGTabletEventTangentialPressure\n","Key associated with a double encoding the tangential pressure on the device. 0 represents no pressure, and 1.0 represents maximum pressure.\n\nkCGTabletEventDeviceID\n","Key associated with an integer encoding the system-assigned unique device ID."]}}}},{"@attributes":{"id":"p-0059","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"kCGTabletEventVendor1"]},{"entry":[{},"kCGTabletEventVendor2"]},{"entry":[{},"kCGTabletEventVendor3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0009","list-style":"none"},"li":{"@attributes":{"id":"ul0009-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0010","list-style":"none"},"li":"Key associated with an integer containing vendor-specified values."}}}},"Additional keys and values found in tablet proximity events, and in mouse events containing embedded tablet proximity data:","kCGTabletProximityEventVendorID",{"@attributes":{"id":"p-0061","num":"0000"},"ul":{"@attributes":{"id":"ul0011","list-style":"none"},"li":{"@attributes":{"id":"ul0011-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0012","list-style":"none"},"li":["Key associated with an integer encoding the vendor-defined ID, typically the USB vendor ID.\n\nkCGTabletProximityEventTabletID\n","Key associated with an integer encoding the vendor-defined tablet ID, typically the USB product ID.\n\nkCGTabletProximityEventPointerID\n","Key associated with an integer encoding the vendor-defined ID of the pointing device.\n\nkCGTabletProximityEventDeviceID\n","Key associated with an integer encoding the system-assigned device ID.\n\nkCGTabletProximityEventSystemTabletID\n","Key associated with an integer encoding the system-assigned unique tablet ID.\n\nkCGTabletProximityEventVendorPointerType\n","Key associated with an integer encoding the vendor-assigned pointer type.\n\nkCGTabletProximityEventVendorPointerSerialNumber\n","Key associated with an integer encoding the vendor-defined pointer serial number.\n\nkCGTabletProximityEventVendorUniqueID\n"]}}}},"Key associated with an integer encoding the vendor-defined unique ID.","kCGTabletProximityEventCapabilityMask",{"@attributes":{"id":"p-0063","num":"0000"},"ul":{"@attributes":{"id":"ul0013","list-style":"none"},"li":{"@attributes":{"id":"ul0013-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0014","list-style":"none"},"li":["Key associated with an integer encoding the device capabilities mask.\n\nkCGTabletProximityEventPointerType\n","Key associated with an integer encoding the pointer type.\n\nkCGTabletProximityEventEnterProximity\n","Key associated with an integer, non-zero when pen is in proximity to the tablet, and zero when leaving the tablet."]}}}},"Registering an Event Tap:","A function registers an event tap, taking a pointer to the program's tap function (also referred to as a callback routine or function) and an arbitrary reference to be passed to the tap function, and returning a CFMachPortRef the program can add to the appropriate run loop using CFRunLoopAddSource( ). Taps may be placed at the point where HIDSystem events enter the server, at the point where HIDSystem and remote control events enter a session, at the point where events have been annotated to flow to a specific application, or at the point where events are delivered to the application. Taps may be inserted at a specified point at the head of pre-existing filters, or appended after any pre-existing filters. Taps may be passive event listeners, or active filters. An active filter may pass an event through unmodified, modify an event, or discard an event. When a tap is registered, it identifies the set of events to be observed with a mask, and indicates if it is a passive or active event filter. Multiple event type bitmasks may be OR'ed together. Releasing the CFMachPortRef will release the tap. The CGEventTapProxy is an opaque reference to state within the client application associated with the tap. The tap function may pass this reference to other functions, such as the event-posting routines.",{"@attributes":{"id":"p-0066","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/* Possible tapping points for events *\/"},{"entry":"typedef enum {"},{"entry":"\u2003\u2003\u2003\u2003kCGHIDEventTap,"},{"entry":"\u2003\u2003\u2003\u2003kCGSessionEventTap,"},{"entry":"\u2003\u2003\u2003\u2003kCGAnnotatedSessionEventTap"},{"entry":"} CGEventTap;"},{"entry":"typedef enum {"},{"entry":"\u2003\u2003\u2003\u2003kCGHeadInsertEventTap,"},{"entry":"\u2003\u2003\u2003\u2003kCGTailAppendEventTap"},{"entry":"} CGEventTapPlacement;"},{"entry":"enum {"},{"entry":"\u2003\u2003\u2003\u2003kCGEventTapOptionListenOnly = 0x00000001"},{"entry":"};"},{"entry":"typedef uint32_t CGEventTapOptions;"},{"entry":"#define CGEventMaskBit(eventType)\u2003\u2003(1ULL << (eventType))"},{"entry":"typedef uint64_t CGEventMask;"},{"entry":"typedef void * CGEventTapProxy;"},{"entry":"\/*"},{"entry":"* The callback is passed a proxy for the tap, the event type, the"},{"entry":"* incoming event, and the refcon the callback was registered with."},{"entry":"* The function should return the (possibly modified) passed in event,"},{"entry":"* a newly constructed event, or NULL if the event is to be deleted."},{"entry":"* The CGEventRef passed into the callback is retained by the calling"},{"entry":"* code, and is released after the callback returns and the data is"},{"entry":"* passed back to the event system. If a different event is returned"},{"entry":"* by the callback function, then that event will be released by the"},{"entry":"* calling code along with the original event, after the event data"},{"entry":"* has been passed back to the event system."},{"entry":"* If an event tap is set to be listen-only, then the returned value,"},{"entry":"* if not NULL, is released without being passed back to the event"},{"entry":"* system."},{"entry":"*\/"},{"entry":"typedef void (*CGEventTapCallBack) (CGEventTapProxy proxy,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGEventType type, CGEventRef event,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003void *refcon, CGEventRef *pEventOut);"},{"entry":"\/* Return the a CFMachPortRef for the event tap. *\/"},{"entry":"CG_EXTERN CFMachPortRef CGEventTapCreate(CGEventLocation"},{"entry":"tap,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGEventTapPlacement place,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGEventTapOptions options,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGEventMask eventsOfInterest,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGEventTapCallBack callback,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003void * refcon );"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Events being routed to individual applications may be tapped using another function. CGEventTapCreateForPSN( ) will report all events being routed to the specified application.",{"@attributes":{"id":"p-0068","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/* Return the CFMachPortRef for an event tap for the specified"]},{"entry":[{},"* process. *\/"]},{"entry":[{},"#include <HIServices\/Processes.h>"]},{"entry":[{},"CG_EXTERN"]},{"entry":[{},"CFMachPortRef CGEventTapCreateForPSN(ProcessSerialNumber"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003*psn,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGEventTapPlacement place,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGEventTapOptions options,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGEventMask eventsOfInterest,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGEventTapCallBack callback,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003void * refcon );"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Posting New Events:","A function to post events from a tap is provided. The events are posted to the same points that an event returned from an event tap would be posted to. If an event tap posts new events, the new events enter the system before the event returned by the tap enters the system. This order may be changed by explicitly posting the filtered event along with new events in the desired order, and then returning NULL from the callback. Events posted into the system will be seen by all taps placed after the tap posting the event.",{"@attributes":{"id":"p-0071","num":"0098"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/* Post an event from the event tap into the event stream. *\/"},{"entry":"CG_EXTERN void CGEventTapPostEvent(CGEventTapProxy proxy,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGEventRef event );"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Functions to post events into the system at various points are provided. Each event posted by these functions enters the system at a point immediately before any taps instantiated for that point, and will pass through any such taps. This mechanism permits an external process to establish an event routing policy, for example, by tapping events at the kCGAnnotatedSessionEventTap and then posting the events to the desired PSN.",{"@attributes":{"id":"p-0073","num":"0100"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/* Post an event from the event tap into the event stream. *\/"},{"entry":"CG_EXTERN void CGPostEvent(CGEventTapLocation tap,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGEventRef event );"},{"entry":"\/* Post an event from the event tap into the event stream"},{"entry":"* for a specific application. *\/"},{"entry":"CG_EXTERN void CGPostEventToPSN(ProcessSerialNumber *psn,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGEventRef event );"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Typical Usage as an Event Monitor:","This sample code demonstrates the use of this API in the context of a simple event monitor.",{"@attributes":{"id":"p-0076","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#include <ApplicationServices\/ApplicationServices.h>"},{"entry":"#include <stdlib.h>"},{"entry":"#include <unistd.h>"},{"entry":"static const char * eventType[ ] ="},{"entry":"{"},{"entry":"\u201cNullEvent\u201d, \u201cLMouseDown\u201d, \u201cLMouseUp\u201d, \u201cRMouseDown\u201d,"},{"entry":"\u201cRMouseUp\u201d, \u201cMouseMoved\u201d, \u201cLMouseDragged\u201d,"},{"entry":"\u201cRMouseDragged\u201d, \u201cMouseEntered\u201d, \u201cMouseExited\u201d,"},{"entry":"\u201cKeyDown\u201d, \u201cKeyUp\u201d, \u201cFlagsChanged\u201d, \u201cKitdefined\u201d,"},{"entry":"\u201cSysDefined\u201d, \u201cAppDefined\u201d, \u201cTimer\u201d, \u201cCursorUpdate\u201d,"},{"entry":"\u201cJournaling\u201d, \u201cSuspend\u201d, \u201cResume\u201d, \u201cNotification\u201d,"},{"entry":"\u201cScrollWheel\u201d, \u201cTabletPointer\u201d, \u201cTabletProximity\u201d,"},{"entry":"\u201cOtherMouseDown\u201d, \u201cOtherMouseUp\u201d, \u201cOtherMouseDragged\u201d"},{"entry":"};"},{"entry":"static CGEventRef eventCallback(CGEventTapProxy proxy,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CGEventType type, CGEventRef event,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003void *refcon)"},{"entry":"{"},{"entry":"\u2003\u2003if (type < (sizeof eventType \/ sizeof eventType[0]) )"},{"entry":"\u2003\u2003\u2003\u2003printf(\u201c%s\\n\u201d, eventType[type] );"},{"entry":"\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003printf(\u201cEvent Type 0x%x\\n\u201d, type);"},{"entry":"\u2003\u2003return NULL;"},{"entry":"}int"},{"entry":"main( )"},{"entry":"{"},{"entry":"\u2003\u2003CFMachPortRef eventPort;"},{"entry":"\u2003\u2003CFRunLoopSourceRef eventSrc;"},{"entry":"\u2003\u2003CFRunLoopRef\u2003\u2003runLoop;"},{"entry":"\u2003\u2003runLoop = CFRunLoopGetCurrent( );"},{"entry":"\u2003\u2003if (runLoop == NULL )"},{"entry":"\u2003\u2003\u2003\u2003printf(\u201cNo run loop?\\n\u201d );"},{"entry":"\u2003\u2003\/*"},{"entry":"\u2003\u2003* Create an event tap."},{"entry":"\u2003\u2003* The tap listens for annotated session events, the"},{"entry":"\u2003\u2003* last tap point before events are sent to applications."},{"entry":"\u2003\u2003*\/"},{"entry":"\u2003\u2003eventPort = CGCreateEventTap(kCGAnnotatedSessionEventTap,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003kCGHeadInsertEventTap,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003kCGEventTapOptionListenOnly,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003kCGEventMaskForAllEvents,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003eventCallback,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003NULL );"},{"entry":"\u2003\u2003if (eventPort == NULL )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003printf(\u201cNULL event port\\n\u201d );"},{"entry":"\u2003\u2003\u2003\u2003exit(1 );"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003\/* Make an event source for our event tap port *\/"},{"entry":"\u2003\u2003eventSrc = CFMachPortCreateRunLoopSource(NULL, eventPort, 0);"},{"entry":"\u2003\u2003if (eventPort == NULL )"},{"entry":"\u2003\u2003\u2003\u2003printf(\u201cNo event run loop src?\\n\u201d );"},{"entry":"\u2003\u2003\/* Listen for events on our event tap port *\/"},{"entry":"\u2003\u2003CFRunLoopAddSource(runLoop, eventSrc,"},{"entry":"\u2003\u2003kCFRunLoopDefaultMode);"},{"entry":"\u2003\u2003\/* Go log events. Never returns. *\/"},{"entry":"\u2003\u2003CFRunLoopRun( );"},{"entry":"\u2003\u2003exit(0 );"},{"entry":"\u2003\u2003return 0;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
