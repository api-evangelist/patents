---
title: Accessing open data using business intelligence tools
abstract: A method for querying an Open Data Protocol (“opendata”) opendata provider includes receiving a relational database query, parsing the relational database query, creating an execution plan, transmitting an opendata query to the opendata provider, transforming a response into a relational format, and providing the transformed response in reply to the relational database query. The method further includes mapping content of an opendata entity data model to a relational model catalog, and processing a portion of the execution plan by an opendata driver implemented at the server. The method can further include the server retrieving document metadata from the opendata provider, building an internal model of the document metadata, and responding to a metadata request. A system for implementing the method and a non-transitory computer readable medium are also disclosed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08868648&OS=08868648&RS=08868648
owner: Business Objects Software Ltd.
number: 08868648
owner_city: Dublin
owner_country: IE
publication_date: 20120514
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["There is a vast amount of data available today and data is now being collected and stored at a rate never seen before. Much, if not most, of this data however is locked into specific formats that can be accessed by specific applications. This data is often difficult to access or to integrate into new applications and uses.","The Open Data Protocol (Odata) is a Web protocol for querying and updating data that provides a way to unlock data and free it from application-specific formats. Odata does this by applying and building upon web technologies such as HTTP, Atom Publishing Protocol (AtomPub) and JSON (JavaScript Object Notation) to provide access to information from a variety of applications, services, and data stores. Odata can be used to expose and access information from a variety of sources including, but not limited to, relational databases, file systems, content management systems and traditional web sites.","A system and method according to an embodiment can provide business intelligence tools, applications, and\/or platforms access to data stored in an Open Data Protocol data source.","The Open Data Protocol (herein referred to as \u201cOdata\u201d or \u201copendata\u201d) is an open protocol that can be used to query, add, and\/or update data in a data store coupled to an electronic communication network. Providers of Odata sources may expose their data to access via the electronic communication network by using the Odata protocol. Systems according to an embodiment can provide access to the information in these opendata sources so that business intelligence tools can generate reports using information available via the electronic communication network. In some embodiments, these business intelligence tools can be accessing data using a relational database protocol.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1","b":["100","100","110","110"]},"Server  can include parsing engine module , mapping engine , and opendata driver module  that are coupled to the central controller. The parsing engine, mapping engine, and opendata driver can be dedicated hardware, software, and\/or firmware modules.","Server  can be in communication with data store . Data store  can be part of an object-relational database management system, a relational database management system, or any other database management system. Data store  can be a repository for one or more instantiations of abstract syntax tree  and relational model catalog  sent to the datastore by opendata driver module . Communication between the server (e.g., opendata driver module ) and data store  can be either over electronic communication network , or a dedicated communication path. In another embodiment, opendata driver  can store abstract syntax tree  and relational model catalog  in memory internal to the server.","Electronic communication network  can be, can comprise, or can be part of, a private internet protocol (IP) network, the Internet, an integrated services digital network (ISDN), frame relay connections, a modem connected to a phone line, a public switched telephone network (PSTN), a public or private data network, a local area network (LAN), a metropolitan area network (MAN), a wide area network (WAN), a wireline or wireless network, a local, regional, or global communication network, an enterprise intranet, any combination of the preceding, and\/or any other suitable communication means. It should be recognized that techniques and systems disclosed herein are not limited by the nature of network .","Connected to server  via electronic communication network  are one or more client computer(s) , , . The client computers can be any type of computing device suitable for use by an end user (e.g., a personal computer, a workstation, a thin client, a netbook, a notebook, tablet computer, etc.). The client computer can be coupled to a disk drive (internal and\/or external). The client computers can include a business intelligence tool application or any application that can pull data using relational database queries (e.g., data migration tools, management tools that can present data in graphic form (tabular, charts, etc.), and the like). The business intelligence tool application can, for example, be based on a relational database model, such as a table that is organized into rows and columns.","A business intelligence tool can utilize graphs, charts, and conditional highlighting; drill down into, and across, reports; sort, filter, and format data; model scenarios visually; provide pre-integrated, pretested solutions; provide a combined resource planning and solution to consolidate data. Queries can include, for example, (i) projection; (ii) filtering; (iii) ordering; (iv) grouping; (v) an aggregate function; (vi) a nested query; and\/or (vii) joining sales data, purchase order data, and\/or information about employees from one or more data sources in the form of a table or report. The user might direct a query to, and receive data from, various data sources (either coupled locally to the client computer or via electronic communication network ). Embodying systems and methods parse, map, and\/or transform the relational database request so that data can be made accessible to the business intelligence tool from an opendata provider.","Connected to the electronic communication network can be opendata provider . Opendata provider  can be coupled to an opendata data source. Data within the opendata data source can be organized according to the Open Data Protocol and opendata provider  can include applications that can expose data within the opendata data source. However, the systems and methods presented herein operate independent of the particular specifics regarding the configuration of the opendata provider and\/or the opendata source. For purposes of this disclosure, the opendata provider and opendata source can be viewed as \u201cblack boxes\u201d that receive queries and provide responses as described below.","By way of example, server  can be implemented as ConnectionServer, a component used by SAP Business Objects Enterprise (BOE) products (SAP, Walldorf, Germany) to connect to various data sources. Server  further can include opendata driver module  that is configured to provide support for relational database query operations that may not be defined in the Odata protocol, or those queries not implemented by the particular developer of opendata provider  even though supported by the Odata protocol standard. The opendata driver module can be used to perform relational database query operations that were not included by the application developer for the one or more applications resident on an opendata provider. Accordingly, server  and opendata driver module  permit connection to one or more opendata providers so that business intelligence reporting can access data from opendata data sources.","Data can be requested by using uniform resource identifiers (URI) and implementing representational state transfer (REST) principles. Data can be exposed in an Entity Data Model, which can implement an Entity Relationship Model. According to some embodiments, EntitySets, AssociationSets and FunctionImports can be mapped, transformed, and represented as relational database objects to permit integration to business intelligence tools (for example, BOE products). In accordance with these embodiments, these database objects can be queried using relational database queries (e.g., Structured Query Language (SQL)). The relational database queries can be mapped to Odata requests supported by the opendata provider for processing. Other relational database query operations not supported by the opendata provider can be processed by opendata driver .","A business intelligence tool can communicate with server  to obtain access to an opendata data provider via an application program interface (API). In accordance with an embodiment, the API used by the business intelligence tool can be the same API it might use to access other types of data sources, such as relational database management systems. Server  can establish a communication connection with open data provider  to download metadata document(s). The metadata documents can be used to build an internal metadata models. These metadata models may be located in server  internal memory, or an external memory connected to the server\u2014for example data store . Embodying methods can adapt an OData Entity Data Model to a relational model that is exposed by server  to the business intelligence tool. The business intelligence tool can query metadata and data from the opendata data source as it would any other data source.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2","b":["200","150","152","154","205","110","110","110","210","140","215","220","112","114","120"]},"In accordance with an embodiment, a metadata request, step , received at the server from the business intelligence tool can be mapped to the data in the internal model to generate a response, step .","Further, in accordance with some embodiments, a relational database request (e.g., a SQL query) sent by the business intelligence tool, step  can be parsed and transformed to an abstract syntax tree that may be stored in data store . Opendata driver  can create an execution plan, step . This execution plan can be based on the relational database request received at step . The execution plan can include Odata operations supported by the opendata provider, as well as further operations which might not be supported by the opendata provider's configuration.","The server can transmit an opendata query, step , containing supported operations to the opendata provider. This opendata query can use an Odata protocol URI, as described above. A response from the opendata provider to the server, step , can be a document, file, etc. and may, for example, by in XML or JSON format. This response can be parsed and transformed to a relational format according to the metadata transformations, step . Additional operations, which might not have been processed by the opendata provider, can be processed at the server by opendata driver , step . A result set can be returned to the business intelligence tool, step .",{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 3","FIG. 2"],"b":["300","300","110","302","110","300","305","110","300","340"]},"The relational database query received at step  can be parsed, step , using parsing engine module . An execution plan can be created, step , by opendata driver  based on the results of the step . The execution plan can contain both opendata operations supported by opendata provider , and non-supported opendata operations. At least a portion of the execution plan containing supported operations can be sent to the opendata provider for processing, step . A response from the opendata data source can be transformed, step , into a relational format. The transformation of the response can be performed in mapping engine .","If the relational database query contained operators not supported by the opendata provider, step , process  can continue at step . If there were no unsupported query operators, process  can continue at step .","The portion of the execution plan containing non-supported operations can be processed at server  by opendata driver , step . In one implementation, opendata driver  may also process at least a portion of the supported operations.","The response(s) from steps  and  can be provided to the business intelligence tool at step .","In accordance with some embodiments, if a metadata request is received, step , by server  from a business intelligence tool, process  can include retrieving document metadata, step , from the opendata provider. A model of the document metadata internal to the server (e.g., stored in data store  or in the server internal memory) can be built, step . The content of an entity data model and the document metadata can be mapped, step , to a relational model catalog (e.g., a table having rows, columns, pages, etc.). The content mapping can be performed by mapping engine . In one implementation, this relational model catalog can be the relational model catalog accessed at step . Access to the catalog(s) can be performed by mapping engine , which is configured to transform relational model queries to opendata queries (and vice versa). A response to the metadata request can be sent from the server (step ). In some embodiments, steps - can be performed prior to receiving a request for metadata so that the relational model catalog accessed by mapping engine  (step , described above) can include document metadata.","An opendata provider can expose data in an opendata source into Entity Data Models (EDM), which can be transformed into relational model formatted data and exposed by an API in server , as described above. Mapping and\/or transforming between these data formats are described below.","In the Entity Data Model, EntitySets, AssociationSets and Functionlmports can be contained in EntityContainers. Each EntityContainer can be mapped into a qualifier (e.g., a relational model catalog).","In accordance with some embodiments, an EntitySet can be mapped into a table (e.g., a relational model catalog): An entry of an EntitySet can be defined in an EntityType. The key of the EntityType can be translated into the key of the table. A primitive property can be translated into a table column, and a complex property type can be flattened into a set of primitive properties and table columns. By way of example, the following XML file can perform such operations:",{"@attributes":{"id":"p-0034","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<EntityType Name=\u201cCustomer\u201d>"]},{"entry":[{},"<Key>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<PropertyRef Name=\u201cCustomerID\u201d \/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/Key>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Property Name=\u201cCustomerID\u201d Type=\u201cEdm.String\u201d \/>"]},{"entry":[{},"<Property Name=\u201cCompanyName\u201d Type=\u201cEdm.String\u201d \/>"]},{"entry":[{},"<Property Name=\u201cContactName\u201d Type=\u201cEdm.String\u201d \/>"]},{"entry":[{},"<Property Name=\u201cContactTitle\u201d Type=\u201cEdm.String\u201d \/>"]},{"entry":[{},"<Property Name=\u201cAddress\u201d Type=\u201cEdm.String\u201d \/>"]},{"entry":[{},"<Property Name=\u201cCity\u201d Type=\u201cEdm.String\u201d \/>"]},{"entry":[{},"<Property Name=\u201cPostalCode\u201d Type=\u201cEdm.String\/>"]},{"entry":[{},"<NavigationProperty Name=\u201cOrders\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Relationship=\u201cNorthwindModel.FK_Orders_Customers\u201d"]},{"entry":[{},"FromRole=\u201cCustomers\u201d ToRole=\u201cOrders\u201d \/>"]},{"entry":[{},"\u2003<\/EntityType>"]},{"entry":[{},"<EntitySet Name=\u201cCustomers\u201d"]},{"entry":[{},"EntityType=\u201cNorthwindModel.Customer\u201d \/>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In accordance with an embodiment, an AssociationSet can relate two EntitySets. For example, associations can be instantiated as AssociationSet in Odata, which can be defined by an Association type. If at least one entity's multiplicity is 1 or 0.1, the association can be translated into a referential constraint in each of the two related tables. If both entities' multiplicity are *, the association can be translated into a table, and this table can have a referential constraint to each of the entities.","Deriving from the CSDL (conceptual schema definition language) standard, an attribute \u201cRole\u201d can be mandatory in AssociationEnd elements. Otherwise the role definition could not be resolved. The following XML file is an example of this concept.",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Association Name=\u201cFK_Orders_Customers\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<End Role=\u201cCustomers\u201d Type=\u201cNorthwindModel.Customer\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Multiplicity=\u201c0..1\u201d \/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<End Role=\u201cOrders\u201d Type=\u201cNorthwindModel.Order\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Multiplicity=\u201c*\u201d \/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<ReferentialConstraint>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Principal Role=\u201cCustomers\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<PropertyRefName=\u201cCustomerID\u201d \/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/Principal>"]},{"entry":[{},"<Dependent Role=\u201cOrders\u201d>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<PropertyRefName=\u201cCustomerID\u201d \/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/Dependent>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/ReferentialConstraint>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/Association>"]},{"entry":[{},"<AssociationSet Name=\u201cFK_Orders_Customers\u201d"]},{"entry":[{},"Association=\u201cNorthwindModel.FK_Orders_Customers\u201d>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<End Role=\u201cCustomers\u201d Entity Set=\u201cCustomers\u201d \/>"]},{"entry":[{},"<End Role=\u201cOrders\u201d EntitySet=\u201cOrders\u201d \/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/AssociationSet>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Properties and NavigationProperites can be mapped to one or more columns. Each primitive property can be mapped to one column with the property name as column name. For properties with a complex type, the number of resulting columns can depend on the number of primitive sub-properties. For each primitive property in a complex type one column can be generated. This rule can also apply to nested complex properties. The name of such a generated column can be the concatenation of the name of the properties' complex type and the name of the primitive type in the enclosing complex type separated by a separation character (e.g., \u201c-\u201d, \u201c\/\u201d, etc.), which is not part of the simple identifier in the EDM to avoid name clashes. The following XML file demonstrates this transformation:",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<ComplexType Name=\u201cPerson\u201d>"]},{"entry":[{},"<Property Name=\u201cName\u201d Type=\u201cEdm.String\u201d\/>"]},{"entry":[{},"<Property Name=\u201cAddress\u201d Type=\u201cAddress\u201d\/>"]},{"entry":[{},"<\/ComplexType>"]},{"entry":[{},"<ComplexType Name=\u201cAddress\u201d>"]},{"entry":[{},"<Property Name=\u201cCity\u201d Type=\u201cEdm.String\u201d\/>"]},{"entry":[{},"<Property Name=\u201cStreet\u201d Type=\u201cStreet\u201d\/>"]},{"entry":[{},"<\/ComplexType>"]},{"entry":[{},"<ComplexType Name=\u201cStreet\u201d>"]},{"entry":[{},"<Property Name=\u201cName\u201d Type=\u201cEdm.String\u201d\/>"]},{"entry":[{},"<Property Name=\u201cNumber\u201d Type=\u201cEdm.Int32\u201d\/>"]},{"entry":[{},"<\/ComplexType>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"As described above, using a separation character, this mapping can result in, for example, in columns for Name, Address\/City, Address\/Street\/Name, and Address\/Street\/Number.","Additionally to declared properties, EntityTypes can have dynamic properties in Odata if the EntityType is declared as OpenEntityType. As those properties are not in the metadata, they are not known to the opendata driver. Consequently, to map these properties into catalog fields, some embodiments can include one or more of the following options. Dynamic properties could be ignored. In this mode, dynamic properties are ignored and would not appear in the result set. Alternatively, a column could be added to the catalog. Column \u201cdynamic_properties\u201d to the EntityType, which can contain a comma separated list of the dynamic property values.","For example, a result set can have any number of properties greater than the two mandatory columns. By way of example, but without limiting embodiments, a result set could contain an additional column \u201cname\u201d and \u201cbirthday\u201d that could be mapped to the \u201cdynamic_properties\u201d column. A value could be e.g. \u201cPeter, 1990-10-03\u201d.","In accordance with some embodiments, and consistent with an implementation of the Open Data Protocol, type inheritance can be supported by parsing engine , mapping engine , and opendata driver .","In the Odata Entity Data Model, an EntityType can inherit from another EntityType, and a ComplexType can inherit from another ComplexType. Additionally, both EntityType and ComplexType can be abstract. Consequently, EntitySets with a declared type X can contain entities of the non-abstract type X and non-abstract derived types of X.","Furthermore, derived types can be declared in the same namespace, and also in other namespaces. Adding a Using directive to a namespace can alter the return types of EntitySets in a \u201cused\u201d namespace, as now EntitySets of the \u201cused\u201d namespace can also contain derived types of the namespace containing the Using directive.","This is a challenge for mapping to a relational model, because in a relational model all rows are expected to follow the same schema. To solve this problem, in accordance with an embodiment, inherited types can be flattened. For a specific EntitySet, the result schema can be the result of a merge to one general type. This general type can contain the columns of the declared type and all subtypes. To prevent name clashes, columns declared in derived types can be prefixed with the name of the EntityType.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 4","b":["400","410","420"]},"In a relational model, such as the model constructed in server , all types can be represented by one schema. Therefore, the types can be merged into one general schema which can contain the columns of all types. For the example depicted in , the schema would look like shown in .",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 5","b":["500","500","400","410","320"]},"Service operations, exposed as FunctionImports, represent stored procedures in Odata. These service operations can be mapped to stored procedures. Even if a client does not support stored procedures, some Odata providers expose their data only as a FunctionImport. For this reason, opendata driver  is configured to map FunctionImports to tables.","Stored procedures can be exposed as tables by using the concept of InputColumns as parameters. Some Odata providers expose their information by stored procedures, and if the client does not support stored procedures data access would not be possible. Therefore, if set in the configuration, two owners can be available where one owner exposes EntitySets as tables and the other owner exposes FunctionImports as tables. Name clashes between EntitySets and FunctionImports with the same name could be avoided.","In some implementations, FunctionImports can be mapped to stored procedures. FunctionImports are described in ServiceOperations in Odata, where a FunctionImport can have any number of input parameters and can define a return type. If there is an association that relates two EntityTypes, there is a NavigationProperty in each of these two EntityTypes to navigate from one entity to the other. Also if there is an association that relates two EntityTypes, there is an AssociationSet between the EntitySets of the respective EntityTypes. Each referential constraint between one entity called principal, and another entity called dependent is mapped into a referential constraint from dependent to principal.","In accordance with some embodiments, SQL operations can be executed by the opendata provider. This ability can impact the amount of data which needs to be transferred over the network and processed by opendata driver . Those SQL operations that could be executed by the opendata provider can be mapped to Odata operations which need to be requested as parameter in the resource URI. For example:","Projection\n\n","Selection, Sorting\n\n","Table I provides illustrative examples of mapping representative SQL-99 operators to Odata operations. To obtain the full syntax of an Odata operation, the Open Data Protocol specification should be consulted.",{"@attributes":{"id":"p-0057","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE I"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Operation","SQL-99","Odata"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Projection","SELECT <attribute_list>","$select=<attribute_list>"]},{"entry":[{},"SELECT Name, Price FROM Orders","http:\/\/host\/service.svc\/Orders?$select=Name,Price"]},{"entry":["Filter","WHERE <bool_expression>","$filter=<bool_expression>"]},{"entry":[{},"SELECT * FROM Orders WHERE Country=\u2019France\u2019","http:\/\/host\/service.svc\/Orders?$filter=Country eq"]},{"entry":[{},{},"\u2032France\u2032"]},{"entry":["Rename","AS","\u2014"]},{"entry":["Sort","ORDER BY <attribute_list> [ASC |","$orderby=<attribute_list> [ASC |"]},{"entry":[{},"DESC]","DESC]"]},{"entry":[{},"SELECT * FROM Orders ORDER BY Country","http:\/\/host\/service.svc\/Orders?$orderby=Country"]},{"entry":["Distinct","DISTINCT","\u2014"]},{"entry":[{},"SELECT DISTINCT name FROM Orders"]},{"entry":["Join *","JOIN","$expand=<expand_expr>"]},{"entry":[{},"SELECT * FROM Orders JOIN Customer","http:\/\/host\/service.svc\/Orders?$expand=Customer"]},{"entry":["Grouping **","GROUP BY","\u2014"]},{"entry":["Union, Union","UNION, UNION ALL","\u2014"]},{"entry":"All"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":"* Currently, there is a limitation for the Join operation: The leftmost entity property must define a NavigationProperty in the EntityType which defines how the data is joined with the target EntityType (structural join)."},{"entry":"** In Odata 2.0, only $count is supported as group function. For other groupings, only server specific functions can be used in the query URI. Therefore, there is no mapping from SQL Group By clauses."}]}}}}},"As discussed above, there are a few opendata providers that might not provide the full set of operations provided in the Odata standard. Therefore, these capabilities are defined in opendata driver's  configuration file, so that the driver can handle operations which are not implemented by the opendata provider.","The \u201ctop\u201d operator is used to implement the maxRow parameter in the server.",{"@attributes":{"id":"p-0060","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"$top=<m>"]},{"entry":[{},"http:\/\/host\/service.svc\/Orders?$top=15"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Table II provides illustrative examples of mapping representative SQL-99 filter expressions to Odata filter expressions.",{"@attributes":{"id":"p-0062","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE II"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"FILTER EXPRESSIONS","SQL-99","ODATA"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Conjunction","AND","and"]},{"entry":[{},"Disjunction","OR","or"]},{"entry":[{},"Negate","\u2212x","\u2212x"]},{"entry":[{},"Not","NOT x","!x"]},{"entry":[{},"Multiply","x * y","x mul y"]},{"entry":[{},"Divide","x\/y","x div y"]},{"entry":[{},"Addition","x + y","x add y"]},{"entry":[{},"Subtraction","x \u2212 y","x sub y"]},{"entry":[{},"Modulo","x % y","x mod y"]},{"entry":[{},"Less than","x < y","x lt y"]},{"entry":[{},"Greater than","x > y","x gt y"]},{"entry":[{},"Less than or equal","x <= y","x le y"]},{"entry":[{},"Greater than or equal","x >= y","x ge y"]},{"entry":[{},"Equals","x = y","x eq y"]},{"entry":[{},"Not equals","x != y","x ne y"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Table III provides illustrative examples of mapping representative SQL-99 functions to Odata functions. In Odata 2.0, count is currently the only implemented grouping function. Opendata driver  can execute another grouping function. This is also the case if the count operation needs to be executed after other operations are completed on the driver's side. This can consume more time, as the full dataset needs to be transferred, and the data needs to be sorted and grouped on the driver side.",{"@attributes":{"id":"p-0064","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE III"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Function","SQL-99","Odata 2.0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Count","count","$count"]},{"entry":[{},"Average","avg","\u2014"]},{"entry":[{},"Minimum","min","\u2014"]},{"entry":[{},"Maximum","max","\u2014"]},{"entry":[{},"Sum","sum","\u2014"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Table IV provides illustrative examples of mapping representative EDM types to ConnectionServer types. Each EDM type can be mapped to one JAVA_Type and one SQL_Type.",{"@attributes":{"id":"p-0066","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE IV"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["EDM Primitive Type","SQL_Type","JAVA_Type"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Edm.Binary","SQL_Binary","JAVA_Binary"]},{"entry":["Edm.Boolean","SQL_Bit","JAVA_Byte"]},{"entry":["Edm.Byte","SQL_SmallInt","JAVA_Short"]},{"entry":["Edm.DateTime","SQL_TimeStamp","JAVA_TimeStamp"]},{"entry":["Edm.Decimal","SQL_Decimal","JAVA_BigDecimal"]},{"entry":["Edm.Double","SQL_Double","JAVA_Double"]},{"entry":["Edm.Single","SQL_Float","JAVA_Float"]},{"entry":["Edm.Guid","SQL_VarChar","JAVA_String"]},{"entry":["Edm.Int16","SQL_SmallInt","JAVA_Short"]},{"entry":["Edm.Int32","SQL_Integer","JAVA_Int"]},{"entry":["Edm.Int64","SQL_BigInt","JAVA_Long"]},{"entry":["Edm.SByte","SQL_SmallInt","JAVA_Short"]},{"entry":["Edm.String","SQL_VarChar","JAVA_String"]},{"entry":["Edm.Time","SQL_Time","JAVA_Time"]},{"entry":["Edm.DateTimeOffset","SQL_VarChar","JAVA_String"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"In accordance with some embodiments, opendata driver  can connect to an opendata provider so that a business intelligence tool can generate reports by accessing Odata EntitySets, AssociationSets and FunctionImports resident in an opendata data source. A system and method in accordance with an embodiment implements mapping\/transforming EntitySets and AssociationSets into relational tables (catalog(s)) and enabling using the Associations to execute structural joins. FunctionImports can be mapped\/transformed to either stored procedures, or by choice of the user, to tables. This dual approach for mapping FunctionImports can permit business intelligence tools that do not support stored procedures to access data from an opendata provider that exposes data only by FunctionImports. Inheritance and dynamic properties can be mapped into the relational model.","In accordance with an embodiment of the invention, a computer program application stored in non-volatile memory or computer-readable medium (e.g., register memory, processor cache, RAM, ROM, hard drive, flash memory, CD ROM, magnetic media, etc.) may include code or executable instructions that when executed may instruct or cause a controller or processor to perform methods discussed herein such as a method for mapping and\/or transforming relational model queries to gain access to data stored in an opendata data source.","The computer-readable medium may be a non-transitory computer-readable media including all forms and types of memory and all computer-readable media except for a transitory, propagating signal. In one implementation, the non-volatile memory or computer-readable medium may be external memory.","Although specific hardware and data configurations have been described herein, note that any number of other configurations may be provided in accordance with embodiments of the invention. Thus, while there have been shown, described, and pointed out fundamental novel features of the invention as applied to several embodiments, it will be understood that various omissions, substitutions, and changes in the form and details of the illustrated embodiments, and in their operation, may be made by those skilled in the art without departing from the spirit and scope of the invention. Substitutions of elements from one embodiment to another are also fully intended and contemplated. The invention is defined solely with regard to the claims appended hereto, and equivalents of the recitations therein."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":["FIG. 3","FIG. 2"],"b":"300"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 5","FIG. 4"]}]},"DETDESC":[{},{}]}
