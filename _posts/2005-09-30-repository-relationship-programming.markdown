---
title: Repository relationship programming
abstract: Embodiments of systems, methods and computer program products are described for implementing repository relationship programming. Implementations described herein describe processes for implementing a union of concerns, integrating concerns, assembling concerns and separating concerns.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07984422&OS=07984422&RS=07984422
owner: 
number: 07984422
owner_city: 
owner_country: 
publication_date: 20050930
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Union of Concerns","Integration of Concerns","Assembly of Concerns","Separation of Concerns"],"p":["This application claims the benefit of U.S. Provisional Application No. 60\/614,648 filed Sep. 30, 2004 which is incorporated by reference herein in its entirety.","Embodiments described herein relate generally to programming systems and methods.","As functional complexity increases, or business rules change, the backbone process of computer programs deprecate, made useless by dependencies between decision-logic and task-logic, or made useless by alterations to the data signature that allows interactions between programs.","The current state of the art is starting from scratch with a completely new set of programs, leaving the defects and deficiencies of legacy programs behind, while creating a completely new set of the same. Typically, the protocols for program organization are centered on the naming of programs and program properties.","Programs are generally written to account for \u201clogical steps\u201d of a given process, which gives rise to the tendency to write lengthy programs consisting of decision-logic mixed with task-logic. Alterations to the expected programming process may mandate rewriting entire sections of code.","An alteration to a single business rules may indicate the need to rewrite one ore more logical processes, to account for the correct implementation of a process series, or sequence, of decisions and related tasks. The convolution of programming logical steps is compounded by the need for cross-program communications, a need usually handled by a series of parameters in the originating program handled by a series of matching parameters in the receiving program. Any change to the expected programming process may also affect the content, sequence, and naming of parameters used in program communication.","Adding new functionality to an existing application is a concept referred to as layering programs. This means new programs need to be inserted at specific points in the process, and some existing programs may need to be updated. The way to implement a new \u201clayer\u201d is to begin the process of rewriting logical steps represented by one or more program modules, accounting for alterations to parameters between programs, and accounting for alterations to the sequence of program execution.","The long term benefits of the traditional approach to computer programming fail to materialize when attempting to integrate legacy program applications with newly developed modules.","Embodiments of systems, methods and computer program products are described for implementing repository relationship programming. For example, embodiments of a system, method, and computer program product for creating a union relationship (i.e., creating a union of concerns) is described where one or more repository instances capable of being modified are identified in a set of repository instances. In each identified repository instance (i.e., those repository instance(s) determined to be capable of being modified), a union transmitter may be implemented. A determination may then be made as to whether each inclusion instance (in a set of one or more inclusion instances) has a union receptor that matches to a corresponding implemented union transmitter in the identified repository instance(s). After this determination, each matching union receptor may then be enabled.","In one embodiment, the identifying of one of more repository instances capable of being modified may include comparing the set of repository instances to a union baseline\/list that identifies repository instances that can be modified. In another embodiment, the identifying one of more repository instances capable of being modified may include determining the presence of a union receptor in each repository instance in the set of repository instances.","In one embodiment, each implemented union transmitter may be intended for a single union receptor. In another embodiment, the union transmitter may be implemented at a union initiation point in the repository instance. In one embodiment, the union initiation point may be identified from a union focus property obtained from a datagram received by a Task Aspect.","In a further embodiment, the set of one or more inclusion instances may be identified from a datagram. In another embodiment, each matched implemented union trigger and enabled union receptor may provide an entry point in the given repository instance (i.e., the repository instance having the implemented union trigger for the associated inclusion instance (i.e., the inclusion instance that has the enable union receptor) to permit the inclusion instance to become a program layer of the receptor instance at runtime. In one embodiment, each enabled union receptor may be constrained to the matching union transmitter.","Embodiments are described for implementing repository relationship programming involving the union and integration of modular programs where the operations of union and integration are made possible by a combination process involving dynamic communication channels between programs and source code organization. More specifically, embodiments of a system, method, and computer program product are described for creating a relationship union between modular programs.","In accordance with an embodiment of the present invention, the application controller locates and assembles individual programs as a collective, referred to as a repository. The concept of a program repository, or collective, is introduced as classes (programs) that are grouped into a collective and assigned the equivalent of a \u201cDewey Decimal System identifier\u201d, which is used to categorize, sequence, or otherwise visually indicate the intended functionality or usage thereof. The object-identifiers of individual programs can be collected, stored, and used to dynamically create a union between independent programs at runtime. The object-identifier of individual embedded objects (properties) within each program can also be collected, stored, and are used as common properties across programs. The combined operations of a union of concerns followed by the integration of concerns can be used create an environment where legacy programs and new development programs are seamlessly integrated at runtime. A union of concerns is an operation where programs \u201cmerge\u201d at specific points after program assembly. The integration of concerns connects common properties between legacy and new development programs that may be located in a plurality of physical locations.","Embodiments of a system, method and computer program product for creating a union between multiple programs are described herein. In this process, a data element located in a repository collective program is obtained, stored, and matched against a data element stored within a Task Aspect program. The data element obtained from each repository program (i.e., a repository program data element) includes information that identifies a specific object and categorical use within the application. Examining the repository program data element, a Task Aspect program determines whether or not the repository program should have its properties subjected to an alteration. If the repository program is determined to be an intended target for modifications, the Task Aspect will process the alterations to the properties of the repository program.","In one embodiment, the place marking the transmission point for a union may be obtained from repository programs using specific descriptive information embedded within a program. In another embodiment, the place marking the reception point for a union can be obtained from repository programs using specific descriptive information embedded within a program. In a further embodiment, the object identifiers of union transmitters can be matched to one or more reception points that create union receptors.","With the above description in mind, a union of concerns may generally be defined as the ability to dynamically deviate the process-flow of a legacy program. A plurality of newly developed programs modify the process-flow or data of a specific legacy program, at a specified point. The resulting deviations can enhance, extend, replace, monitor, and\/or modify the expected results of the original program without the need to modify legacy source code.","One benefit of a union of programs is that it can remove the need for multiple inheritance. The benefits of a union of concerns becomes apparent in regulated environments, where alterations to source code must be tracked and audited, and in environments where program features are made available or extended, on demand. A union of concerns can provide a seamless mechanism for dynamic program control. Union operations are commonly performed across multiple programs, providing the software developers with an easy way to apply new business rules, at any point, in the form of a precondition or post-condition process. Optionally, the union of concerns process can be used to dynamically replace specifically identified software modules. A union of concerns is about dynamic program interaction for program modules that can be assembled or reassembled\u2014at any time\u2014in order to create feature-based behaviors, using standard business rules specified in metadata, or user interactions specified from a graphical user interface (GUI).",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 1","b":["100","102","104","100","102","104"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 2","FIG. 1","FIG. 2"],"b":["200","100","100","202","204"]},"With the assistance of the exemplary implementation set forth in operations A- through A-, further details of various embodiments for creating a union of concerns will be described.","In operation A-, as set forth in the exemplary code below, the Task Aspect receives a datagram that comprises information that uniquely identifies instances upon which the Task Aspect will perform one or more property modifications. Instances matched to this information are referred to as the union baseline and contain a known focus point that is matched to the union initiation point.","Operation A-:",{"@attributes":{"id":"p-0036","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class taskManager;"},{"entry":"\u2003public list components \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list baselineIdentification \/ (initialValue={\u2018demo.repository301."},{"entry":"\u2003christmasbonus\u2019});"},{"entry":"\u2003setBaseline: method;"},{"entry":"\u2003\u2003dcl object thisProgram=getnitemo(components, \u2018task aspect\u2019);"},{"entry":"\u2003\u2003thisProgram.loadBaseline(baselineIdentification);"},{"entry":"\u2003endmethod;"},{"entry":"endclass;"},{"entry":"class taskAspect;"},{"entry":"\u2003public char name \/ (state=\u2018o\u2019, initialValue=\u2018task aspect\u2019);"},{"entry":"\u2003public list components \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list baselineIdentification \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list focusInformation \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list inclusionInstances \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list repositoryInstances \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003\u2003loadBaseline: method datagram:list;"},{"entry":"\u2003\u2003\u2003copylist(datagram, \u2018N\u2019, baselineIdentification);"},{"entry":"\u2003\u2003endmethod;"},{"entry":"endclass;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In operation A-, as set forth in the exemplary code below, the Task Aspect receives a datagram that includes information that identifies the union trigger name as well as the order-of-operations for the execution cycle in relation to the union focus property. The order of operations can be specified as preprocess or postprocess. The union focus property may also identify a specific property, referred to as the union initiation point, within the union baseline instances. Example behaviors that can be created by union of concerns, as specified by focus properties, include branching the standard execution cycle into other repository programs, accomplished by, preprocess and postprocess deviations as pictured in . Optionally a preprocess or postprocess deviation can be supplemented by disabling or enabling method properties within the union baseline, as needed.","Operation A-:",{"@attributes":{"id":"p-0038","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class taskManager;"},{"entry":"\u2003public list components \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list unionInformation \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003setFocus1: method;"},{"entry":"\u2003\u2003dcl num rc;"},{"entry":"\u2003\u2003rc=insertc(unionInformation, \u2018calc01\u2019, \u22121, \u2018union focus property\u2019);"},{"entry":"\u2003\u2003rc=insertc(unionInformation, \u2018before\u2019, \u22121, \u2018union focus sequence\u2019);"},{"entry":"\u2003\u2003rc=insertc(unionInformation, \u2018christmas bonus precondition\u2019, \u22121,"},{"entry":"\u2003\u2003\u2003\u2018union focus transmitter\u2019);"},{"entry":"\u2003\u2003dcl object thisProgram=getnitemo(components, \u2018aspect001\u2019);"},{"entry":"\u2003\u2003thisProgram.loadFocus(unionInformation);"},{"entry":"\u2003endmethod;"},{"entry":"\u2003setFocus2: method;"},{"entry":"\u2003\u2003dcl num rc;"},{"entry":"\u2003\u2003rc=insertc(unionInformation, \u2018calc01\u2019, \u22121, \u2018union focus property\u2019);"},{"entry":"\u2003\u2003rc=insertc(unionInformation, \u2018after\u2019, \u22121, \u2018union focus sequence\u2019);"},{"entry":"\u2003\u2003rc=insertc(unionInformation, \u2018christmas bonus postcondition\u2019, \u22121,"},{"entry":"\u2003\u2003\u2003\u2018union focus transmitter\u2019);"},{"entry":"\u2003\u2003dcl object thisProgram=getnitemo(components, \u2018aspect001\u2019);"},{"entry":"\u2003\u2003thisProgram.unionFocus(unionInformation);"},{"entry":"\u2003endmethod;"},{"entry":"endclass;"},{"entry":"class taskAspect;"},{"entry":"\u2003public char name \/ (state=\u2018o\u2019, initialValue=\u2018task aspect\u2019);"},{"entry":"\u2003public list components \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list baselineIdentification \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list focusInformation \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list inclusionInstances \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list repositoryInstances \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003loadFocus: method datagram:list;"},{"entry":"\u2003\u2003dcl num rc=insertl(focusInformation, copylist(datagram), \u22121);"},{"entry":"\u2003endmethod;"},{"entry":"endclass;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In operation A-, as set forth in the exemplary code below, the Task Aspect receives a datagram comprising program object identifiers that are referred to as the union inclusion of a union operation. The union inclusion of a union operation may contain receptor directives that are matched, by union trigger name, to information associated to the union initiation point.","Operation A-:",{"@attributes":{"id":"p-0040","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class taskManager;"]},{"entry":[{},"\u2003public list components \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003public list inclusionInstances \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003setInclusion: method;"]},{"entry":[{},"\u2003\u2003dcl object thisProgram=getnitemo(components, \u2018task aspect\u2019);"]},{"entry":[{},"\u2003\u2003thisProgram.loadInclusion(inclusionInstances);"]},{"entry":[{},"\u2003endmethod;"]},{"entry":[{},"endclass;"]},{"entry":[{},"class taskAspect;"]},{"entry":[{},"\u2003public char name \/ (state=\u2018o\u2019, initialValue=\u2018task aspect\u2019);"]},{"entry":[{},"\u2003public list components \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003public list baselineIdentification \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003public list focusInformation \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003public list inclusionInstances \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003public list repositoryInstances \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003loadInclusion: method datagram:list;"]},{"entry":[{},"\u2003\u2003copylist(datagram, \u2018N\u2019, inclusionInstances);"]},{"entry":[{},"\u2003endmethod;"]},{"entry":[{},"endclass;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In operation A-, as set forth in the exemplary code below, the Task Aspect receives a datagram that includes program object identifiers that are referred to as repository instances. Repository instances comprise the standard programs and processes of an application. Specified repository instances are used in coordination with union baseline information, and when used together, identify two distinct categories of instances that are subject to union operations.","Operation A-:",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class taskManager;"},{"entry":"\u2003public list components \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list inclusionInstances \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003setInstances: method;"},{"entry":"\u2003\u2003dcl object thisProgram=getnitemo(components, \u2018assembly routine\u2019);"},{"entry":"\u2003\u2003thisProgram.runInterface(\u2018REPOSITORY399\u2019, inclusionInstances);"},{"entry":"\u2003endmethod;"},{"entry":"\u2003setRepository: method;"},{"entry":"\u2003\u2003dcl object thisProgram=getnitemo(components, \u2018task aspect\u2019);"},{"entry":"\u2003\u2003thisProgram.loadRepository(inclusionInstances);"},{"entry":"\u2003endmethod;"},{"entry":"endclass;"},{"entry":"class taskAspect;"},{"entry":"\u2003public char name \/ (state=\u2018o\u2019, initialValue=\u2018task aspect\u2019);"},{"entry":"\u2003public list components \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list baselineIdentification \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list focusInformation \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list inclusionInstances \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list repositoryInstances \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003loadRepository: method datagram:list;"},{"entry":"\u2003\u2003copylist(datagram, \u2018N\u2019, repositoryInstances);"},{"entry":"\u2003endmethod;"},{"entry":"endclass;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In operation A-, as set forth in the exemplary code below, the Task Aspect receives a repository collective of object identifiers (e.g., the object identifiers of inclusion instances) upon which an operation is performed to identify union receptors. The Task Aspect iterates through each object, examining event handler properties for event handlers that exist in a disabled state, extracting a full set of parameter information from each event handler.","Operation A-:",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class taskAspect;"},{"entry":"\u2003public char name \/ (state=\u2018o\u2019, initialValue=\u2018task aspect\u2019);"},{"entry":"\u2003public list components \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list baselineIdentification \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list focusInformation \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list inclusionInstances \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list repositoryInstances \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list receptorID \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list receptorEvent \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list receptorMethod \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003runReceptorDirectives: method;"},{"entry":"\u2003\u2003dcl num xDirective rc xComponent activeStatus;"},{"entry":"\u2003\u2003dcl object thisProgram;"},{"entry":"\u2003\u2003dcl list thisDirective;"},{"entry":"\u2003\u2003do xComponent = 1 to listlen(inclusionInstances);"},{"entry":"\u2003\u2003\u2003dcl list directive={ };"},{"entry":"\u2003\u2003\u2003thisProgram=getitemo(inclusionInstances, xComponent);"},{"entry":"\u2003\u2003\u2003thisProgram._getEventHandlers(directive, \u2018Y\u2019);"},{"entry":"\u2003\u2003\u2003do xDirective = 1 to listlen(directive);"},{"entry":"\u2003\u2003\u2003\u2003thisDirective=getiteml(directive, xDirective);"},{"entry":"\u2003\u2003\u2003\u2003activeStatus=1;"},{"entry":"\u2003\u2003\u2003\u2003if nameditem(thisDirective, \u2018state\u2019)=0 then activeStatus=0;"},{"entry":"\u2003\u2003\u2003\u2003if nameditem(thisDirective, \u2018sender\u2019)=0 then activeStatus=0;"},{"entry":"\u2003\u2003\u2003\u2003if itemtype(thisDirective, nameditem(thisDirective, \u2018sender\u2019))"},{"entry":"\u2003\u2003\u2003\u2003\u2003NE \u2018C\u2019 then activeStatus=0;"},{"entry":"\u2003\u2003\u2003\u2003if getnitemc(thisDirective, \u2018sender\u2019) NE \u2018*\u2019 then activeStatus=0;"},{"entry":"\u2003\u2003\u2003\u2003if activeStatus then do;"},{"entry":"\u2003\u2003\u2003\u2003\u2003rc=inserto(receptorID, thisProgram, \u22121);"},{"entry":"\u2003\u2003\u2003\u2003\u2003rc=insertc(receptorEvent, getnitemc(thisDirective, \u2018event\u2019),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u22121);"},{"entry":"\u2003\u2003\u2003\u2003\u2003rc=insertc(receptorMethod, getnitemc(thisDirective,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2018method\u2019), \u22121);"},{"entry":"\u2003\u2003\u2003\u2003end;"},{"entry":"\u2003\u2003\u2003end;"},{"entry":"\u2003\u2003\u2003rc=dellist(directive, \u2018Y\u2019);"},{"entry":"\u2003\u2003end;"},{"entry":"\u2003endmethod;"},{"entry":"endclass;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In operation A-, as set forth in the exemplary code below, the Task Aspect iterates though instances received in operation , removing instances that do not match information received in operation A-. A union-transmitter is implemented in each instance using information received in operation A-.","Operation A-:",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class taskAspect;"},{"entry":"\u2003public char name \/ (state=\u2018o\u2019, initialValue=\u2018task aspect\u2019);"},{"entry":"\u2003public list components \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list baselineIdentification \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list focusInformation \/ (sendEven=\u2018N\u2019);"},{"entry":"\u2003public list inclusionInstances \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list repositoryInstances \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list receptorID \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list receptorEvent \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list receptorMethod \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list transmitterMethods \/ (initialValue={"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2018unionOnly\u2019,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2018createTransmitter\u2019"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003});"},{"entry":"\u2003runUnionTransmiter: method;"},{"entry":"\u2003\u2003dcl num i;"},{"entry":"\u2003\u2003do i=1 to listlen(transmitterMethods);"},{"entry":"\u2003\u2003\u2003call send(_self_, getitemc(transmitterMethods, i));"},{"entry":"\u2003\u2003end;"},{"entry":"\u2003endmethod;"},{"entry":"\u2003unionOnly: method \/ (description=\u2018remove instances not subject to"},{"entry":"\u2003union-transmitter"},{"entry":"\u2003\u2003implementation\u2019);"},{"entry":"\u2003\u2003dcl num xComponent;"},{"entry":"\u2003\u2003dcl object thisProgram;"},{"entry":"\u2003\u2003do xComponent=listlen(repositoryInstances) to 1 by \u22121;"},{"entry":"\u2003\u2003\u2003thisProgram=getitemo(repositoryInstances, xComponent);"},{"entry":"\u2003\u2003\u2003if thisProgram.description NE getitemc(baselineIdentification) then"},{"entry":"\u2003\u2003\u2003\u2003delitem(repositoryInstances, xComponent);"},{"entry":"\u2003\u2003end;"},{"entry":"\u2003endmethod;"},{"entry":"\u2003createTransmitter: method \/ (description=\u2018create union transmitter"},{"entry":"\u2003as specified\u2019);"},{"entry":"\u2003\u2003dcl num rc xComponent xUnion;"},{"entry":"\u2003\u2003dcl char thisProperty thisSequence thisTransmitter;"},{"entry":"\u2003\u2003dcl object thisProgram;"},{"entry":"\u2003\u2003dcl list metadata={ };"},{"entry":"\u2003\u2003do xComponent=1 to listlen(repositoryInstances);"},{"entry":"\u2003\u2003\u2003do xUnion=1 to listlen(unionInformation);"},{"entry":"\u2003\u2003\u2003\u2003thisProperty =getnitemc(unionInformation, \u2018union focus"},{"entry":"\u2003\u2003\u2003\u2003property\u2019);"},{"entry":"\u2003\u2003\u2003\u2003thisSequence =getnitemc(unionInformation, \u2018union focus"},{"entry":"\u2003\u2003\u2003\u2003sequence\u2019);"},{"entry":"\u2003\u2003\u2003\u2003thisTransmitter=getnitemc(unionInformation, \u2018union focus"},{"entry":"\u2003\u2003\u2003\u2003transmitter\u2019);"},{"entry":"\u2003\u2003\u2003\u2003if thisSequence=\u2018Before\u2019 then rc=insertc(metadata, \u2018B\u2019, \u22121,"},{"entry":"\u2003\u2003\u2003\u2003\u2018execute\u2019);"},{"entry":"\u2003\u2003\u2003\u2003if thisSequence=\u2018After\u2019 then rc=insertc(metadata, \u2018A\u2019, \u22121,"},{"entry":"\u2003\u2003\u2003\u2003\u2018execute\u2019);"},{"entry":"\u2003\u2003\u2003\u2003rc=insertc(metadata, thisTransmitter, \u22121, \u2018name\u2019);"},{"entry":"\u2003\u2003\u2003\u2003rc=insertc(metadata, thisProperty, \u22121, \u2018method\u2019);"},{"entry":"\u2003\u2003\u2003\u2003rc=insertc(metadata, \u2018Y\u2019, \u22121, \u2018enabled\u2019);"},{"entry":"\u2003\u2003\u2003\u2003thisProgram=getitemo(repositoryInstances, xComponent);"},{"entry":"\u2003\u2003\u2003\u2003thisProgram._addEvent(metadata);"},{"entry":"\u2003\u2003\u2003\u2003rc=dellist(metadata);"},{"entry":"\u2003\u2003\u2003end;"},{"entry":"\u2003\u2003end;"},{"entry":"\u2003endmethod;"},{"entry":"endclass;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In operation A-, as set forth in the exemplary code below, the Task Aspect iterates though instances identified as union inclusions in operation A-. The union receptor name for each iteration is obtained and used for searching a list of union transmitter names (e.g., operations A- and\/or A-). For each iteration where a match between union-receptor name and union-transmitter name is verified, the Task Aspect creates and enables one union-receptor constrained to one union-transmitter identified during the transmitter name search.","Operation A-:",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class taskAspect;"},{"entry":"\u2003public char name \/ (state=\u2018o\u2019, initialValue=\u2018task aspect\u2019);"},{"entry":"\u2003public list components \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list baselineIdentification \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list focusInformation \/ (sendEvent=\u2018N\u2019); public list"},{"entry":"\u2003inclusionInstances \/"},{"entry":"\u2003(sendEvent=\u2018N\u2019); public list repositoryInstances \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list receptorID \/"},{"entry":"\u2003(sendEvent=\u2018N\u2019); public list receptorEvent \/ (sendEvent=\u2018N\u2019); public"},{"entry":"\u2003list receptorMethod \/"},{"entry":"\u2003(sendEvent=\u2018N\u2019);"},{"entry":"\u2003runUnionReceptor: method \/ (description=\u2018create a union-receptor"},{"entry":"\u2003\u2003constrained to a single transmitting instance\u2019);"},{"entry":"\u2003\u2003dcl num xTransmitter xComponent;"},{"entry":"\u2003\u2003dcl char thisreceptorMethod thisReceptorEvent;"},{"entry":"\u2003\u2003dcl object thisTransmitterID thisreceptorID thisProgram;"},{"entry":"\u2003\u2003do xComponent=1 to listlen(receptorID);"},{"entry":"\u2003\u2003\u2003xTransmitter =searchc(transmitterEvent, getitemc(receptorEvent,"},{"entry":"\u2003\u2003\u2003xComponent));"},{"entry":"\u2003\u2003\u2003thisTransmitterID =getitemo(transmitterID, xTransmitter);"},{"entry":"\u2003\u2003\u2003thisReceptorID =getitemo(receptorID, xComponent);"},{"entry":"\u2003\u2003\u2003thisReceptorMethod=getitemc(receptorMethod, xComponent);"},{"entry":"\u2003\u2003\u2003thisReceptorEvent =getitemc(receptorEvent, xComponent);"},{"entry":"\u2003\u2003\u2003thisProgram=getitemo(receptorID, xComponent);"},{"entry":"\u2003\u2003\u2003thisProgram._addEventHandler(thisTransmitterID,"},{"entry":"\u2003\u2003\u2003thisReceptorEvent,"},{"entry":"\u2003\u2003\u2003thisReceptorMethod);"},{"entry":"\u2003\u2003end;"},{"entry":"\u2003endmethod;"},{"entry":"endclass;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 3","FIG. 3","FIG. 3"],"b":["300","1","4","302","304","306","5","7"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 4","FIG. 3","FIG. 4"],"b":["400","300"]},"The union of concerns approach can be used to remove the need for invasive programming on legacy code, allowing the original source code to remain in the system without any modification, while providing secondary programs an entry point to become a \u201cprogram layer\u201d at runtime. Optionally, the union of concerns approach can be modified to create constrained assembly lines of programs for parallel processing constrained to a single Task Manager program.","In accordance with one embodiment, the union of concerns may involve methods for identifying of a repository program on which to perform a union-relationship and identifying a specific point in a repository program where a union-relationship can be implemented. The union of concerns may also include logic for creating a union-relationship transmission point and\/or reception point in one or more of the repository programs.","In order to implement the union of concerns, it may be useful to carry out an integration of concerns to avoid problems arising from parent-child relations between programs, and can become very important when integrating visual component programs, referred to as a graphical user interface, with backend server programs. The integration of concerns is intended to eliminate parent-child relationships between programs in the application while removing the concept of hierarchical program design at the same time. This approach uses specified attributes in one category of program repository as common property, or globally accessible, to be accessed as-needed by programs in other repository categories.","In an embodiment, the content of each repository program is scanned for properties that are designated for integration operations across objects, which includes the identification of source property locations and target property locations. The name of a program collective (which may be assigned according to a generally accepted logic categorization chart) is information that can be used to determine the identity of programs that are source property containers or programs that are target property containers.","The object identifier and descriptive information of properties used to create an integration of concerns can be obtained from all repository programs and stored.","In one embodiment, the object identifier of each repository program may be scanned, resulting in a list of information for use in the integration of concerns operation. This list may contain the object identifier of a repository program matched with the object identifier of a program property that has been identified as source property. In another embodiment, the resulting list of information may contain the object identifier of a repository program matched with the object identifier of a program property that has been identified as target property.","In one embodiment, a Task Aspect program can iterate sequentially through the list of target properties to search the list of source properties for a single match. Although property names are used in the examples set forth herein, the match criteria can be based on property name or descriptive information elements associated directly to each property. Upon locating a matching source and target property (based on the match criteria), the Task Aspect program can then assign the source property object identifier to the target property.","A relationship is created between repository programs through attributes that are designated as multiple ownership properties, which replace the need to match parameter signatures located in invoking programs with parameter signatures in a receptor programs. Multiple ownership properties create a static pathway for information traversals between calling and receiving programs. This approach removes the need for most hard coded parameters, thereby removing the need to track parameter reception by typecast and sequence.","The integration relationship can be created dynamically, which allows legacy programs to be easily integrated with newly developed programs, as the program assembly routine and integration routine create no differentiation between legacy modules and new modules. This way, one may add functionality, features, or swap entire program repositories, without coding alterations to the existing code base. Optionally, by using integrated concerns comprising of one or more program object-identifiers instead of attribute object-identifiers, the functionality of visual components and non-visual components can exist as a single layer, enhancing the ability to categorically separate concerns.","Further description of the various aspects of an integration of concerns will be described using the following exemplary operations B- through B- and with the further assistance .","In operation B-, as set forth in the exemplary code below, the Task Aspect receives three containers filled with program object-identifiers, categorized by a datagram. The datagram indicates the category of program according to a generally accepted logic categorization chart, processing the datagram. The Task Aspect copies inbound program object-identifiers into the specified storage location. One datagram indicates the storage location is designated to hold instances categorized as common workspace, referred to as \u201crepository000\u201d series. One datagram indicates whether the storage location is designated to hold instances categorized as targets, which may be any repository other than \u201crepository000\u201d series. One datagram indicates whether the storage location is designated to hold instances categorized as beans, which may be custom named as needed. Optionally, this storage location may contain instances without regard for repository categorizations.","Operation B-:",{"@attributes":{"id":"p-0062","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class taskAspect;"]},{"entry":[{},"\u2003public char name \/ (state=\u2018o\u2019, initialValue=\u2018task aspect\u2019);"]},{"entry":[{},"\u2003public list components \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003public list transport \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003public list sourceRepository \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003public list targetRepository \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003public list repositoryInstances \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003public list beanBag \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003public list focusIdentification \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003public list unionInformation \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003eventhandler loadSourceRepository \/ (sender=\u2018*\u2019, event=\u2018source"]},{"entry":[{},"\u2003repository\u2019);"]},{"entry":[{},"\u2003eventhandler loadTargetRepository \/ (sender=\u2018*\u2019, event=\u2018target"]},{"entry":[{},"\u2003repository\u2019);"]},{"entry":[{},"\u2003eventhandler loadBeanBag \/ (sender=\u2018*\u2019, event=\u2018bean bag\u2019);"]},{"entry":[{},"\u2003loadSourceRepository: method container:list;"]},{"entry":[{},"\u2003\u2003copylist(container, \u2018N\u2019, sourceRepository);"]},{"entry":[{},"\u2003\u2003copylist(container, \u2018N\u2019, repositoryInstances);"]},{"entry":[{},"\u2003endmethod;"]},{"entry":[{},"\u2003loadTargetRepository: method container:list;"]},{"entry":[{},"\u2003\u2003copylist(container, \u2018N\u2019, targetRepository);"]},{"entry":[{},"\u2003\u2003copylist(container, \u2018N\u2019, repositoryInstances);"]},{"entry":[{},"\u2003endmethod;"]},{"entry":[{},"\u2003loadBeanBag: method container:list;"]},{"entry":[{},"\u2003\u2003copylist(container, \u2018N\u2019, beanBag);"]},{"entry":[{},"\u2003endmethod;"]},{"entry":[{},"endclass;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 5","b":["502","504","506","508"]},"In operation B-, as set forth in the exemplary code below, the Task Aspect iterates through the listing of objects originating within a common workspace repository, creating a listing of information containing program object-identifier, property object-identifier, and the name of the property. One group of information is created for each data element in each instance identified as a property source when creating a mutual ownership relationship. Each data element within the group of information gained from the iteration operation is stored in separate container. This operation may be restricted to attributes declared as \u201cPUBLIC\u201d and typecast as \u201cLIST.\u201d Optionally, restrictions can restrict the identification process of source attributes. This program may restrict processing to attributes with specific descriptive information. Source code instances are depicted in  as \u201cworkspace1\u201d and \u201cworkspace2.\u201d","Operation B-:",{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class taskAspect;"},{"entry":"\u2003public char name \/ (state=\u2018o\u2019, initialValue=\u2018task aspect\u2019);"},{"entry":"\u2003public list components \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list transport \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list sourceRepository \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list targetRepository \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list repositoryInstances \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list beanBag \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list focusIdentification \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list unionInformation \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list sourceCategory \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list sourceInstance \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list sourceAttribute \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list targetCategory \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list targetInstance \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list targetAttribute \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003_init: method \/ (state=\u2018o\u2019);"},{"entry":"\u2003\u2003_super( );"},{"entry":"\u2003\u2003dcl num rc;"},{"entry":"\u2003\u2003rc=insertl(transport, sourceCategory, \u22121, \u2018sourceCategory\u2019);"},{"entry":"\u2003\u2003rc=insertl(transport, sourceInstance, \u22121, \u2018sourceInstance\u2019);"},{"entry":"\u2003\u2003rc=insertl(transport, sourceAttribute, \u22121, \u2018sourceAttribute\u2019);"},{"entry":"\u2003\u2003rc=insertl(transport, targetCategory, \u22121, \u2018targetCategory\u2019);"},{"entry":"\u2003\u2003rc=insertl(transport, targetInstance, \u22121, \u2018targetInstance\u2019);"},{"entry":"\u2003\u2003rc=insertl(transport, targetAttribute, \u22121, \u2018targetAttribute\u2019);"},{"entry":"\u2003\u2003rc=insertl(transport, sourceRepository, \u22121, \u2018sourceRepository\u2019);"},{"entry":"\u2003\u2003rc=insertl(transport, targetRepository, \u22121, \u2018targetrepository\u2019);"},{"entry":"\u2003\u2003rc=insertl(transport, beanBag, \u22121, \u2018beanBag\u2019);"},{"entry":"\u2003endmethod;"},{"entry":"\u2003identifySourceProperty: method;"},{"entry":"\u2003\u2003dcl object thisProgram=getnitemo(components, \u2018source property\u2019);"},{"entry":"\u2003\u2003thisProgram.runInterface(transport);"},{"entry":"\u2003endmethod;"},{"entry":"endclass;"},{"entry":"class sourceProperty;"},{"entry":"\u2003public char name \/ (state=\u2018o\u2019, initialValue=\u2018source property\u2019);"},{"entry":"\u2003runInterface: method transport:list;"},{"entry":"\u2003\u2003dcl object thisProgram;"},{"entry":"\u2003\u2003dcl num xAttribute rc xComponent;"},{"entry":"\u2003\u2003dcl list thisAttribute={ };"},{"entry":"\u2003\u2003dcl list repositoryInstances=getniteml(transport, \u2018sourceRepository\u2019);"},{"entry":"\u2003\u2003dcl list sourceCategory =getniteml(transport, \u2018sourceCategory\u2019);"},{"entry":"\u2003\u2003dcl list sourceInstance =getniteml(transport, \u2018sourceInstance\u2019);"},{"entry":"\u2003\u2003dcl list sourceAttribute =getniteml(transport, \u2018sourceAttribute\u2019);"},{"entry":"\u2003\u2003do xComponent = 1 to listlen(repositoryInstances);"},{"entry":"\u2003\u2003\u2003dcl list componentAttribute={ };"},{"entry":"\u2003\u2003\u2003thisProgram=getitemo(repositoryInstances, xComponent);"},{"entry":"\u2003\u2003\u2003thisProgram._getAttributes(componentAttribute, \u2018Y\u2019);"},{"entry":"\u2003\u2003\u2003do xAttribute = 1 to listlen(componentAttribute);"},{"entry":"\u2003\u2003\u2003\u2003thisAttribute=getiteml(componentAttribute, xAttribute);"},{"entry":"\u2003\u2003\u2003\u2003if nameditem(thisAttribute, \u2018category\u2019) then do;"},{"entry":"\u2003\u2003\u2003\u2003\u2003if upcase(getnitemc(thisAttribute,\u2018type\u2019))=\u2018LIST\u2019 and"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003upcase(getnitemc(thisAttribute,\u2018category\u2019)) in"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003(\u2018COMMON\u2019) and"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003upcase(getnitemc(thisAttribute,\u2018scope\u2019))=\u2018PUBLIC\u2019"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003then do;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003rc=insertc(sourceCategory, upcase(getnitemc(thisAttribute,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2018category\u2019)),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u22121, thisProgram.description);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003rc=insertc(sourceAttribute, getnitemc(thisAttribute,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2018name\u2019), \u22121,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003thisProgram.description);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003rc=inserto(sourceInstance, thisProgram, \u22121,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003thisProgram.description);"},{"entry":"\u2003\u2003\u2003\u2003\u2003end;"},{"entry":"\u2003\u2003\u2003\u2003end;"},{"entry":"\u2003\u2003\u2003end;"},{"entry":"\u2003\u2003\u2003rc=dellist(componentAttribute, \u2018Y\u2019);"},{"entry":"\u2003\u2003end;"},{"entry":"\u2003\u2003rc=dellist(thisAttribute);"},{"entry":"\u2003endmethod;"},{"entry":"endclass;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In operation B-, as set forth in the exemplary code below, the Task Aspect iterates through the listing of objects originating within any repository except a common workspace repository, creating an information group comprising of program object-identifier, property object-identifier, and the name of the property. One group of information is created for each data element in each instance identified as a property target when creating a mutual ownership relationship. Each data element within the group of information gained from the iteration operation is stored in separate container. This operation is restricted to attributes declared as \u201cPUBLIC\u201d and typecast as \u201cLIST.\u201d Optionally, additional restrictions can restrict the identification process to specific attributes, or attributes with a matching source property entry. This program restricts processing to attributes with a blank category descriptor. Target instances are depicted in  as \u201ctask1,\u201d \u201ctask2\u201d and \u201ctask3.\u201d","Operation B-:",{"@attributes":{"id":"p-0067","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class taskAspect;"},{"entry":"\u2003public char name \/ (state=\u2018o\u2019, initialValue=\u2018task aspect\u2019);"},{"entry":"\u2003public list components \/ (sendEvent=\u2018N\u2019);"},{"entry":"* cut;"},{"entry":"\u2003identifyTargetProperty: method;"},{"entry":"\u2003\u2003dcl object thisProgram=getnitemo(components, \u2018target property\u2019);"},{"entry":"\u2003\u2003thisProgram.runInterface(transport);"},{"entry":"\u2003endmethod;"},{"entry":"endclass;"},{"entry":"class targetProperty;"},{"entry":"\u2003public char name \/ (state=\u2018o\u2019, initialValue=\u2018target property\u2019);"},{"entry":"\u2003runInterface: method transport:list;"},{"entry":"\u2003\u2003dcl num xAttribute xComponent rc;"},{"entry":"\u2003\u2003dcl object thisProgram;"},{"entry":"\u2003\u2003dcl list repositoryInstances=getniteml(transport, \u2018targetRepository\u2019);"},{"entry":"\u2003\u2003dcl list targetAttribute =getniteml(transport, \u2018targetAttribute\u2019);"},{"entry":"\u2003\u2003dcl list targetCategory =getniteml(transport, \u2018targetCategory\u2019);"},{"entry":"\u2003\u2003dcl list targetInstance =getniteml(transport, \u2018targetInstance\u2019);"},{"entry":"\u2003\u2003do xComponent = 1 to listlen(repositoryInstances);"},{"entry":"\u2003\u2003\u2003dcl list componentAttribute={ };"},{"entry":"\u2003\u2003\u2003dcl list thisAttribute={ };"},{"entry":"\u2003\u2003\u2003thisProgram=getitemo(repositoryInstances, xComponent);"},{"entry":"\u2003\u2003\u2003thisProgram._getAttributes(componentAttribute, \u2018Y\u2019);"},{"entry":"\u2003\u2003\u2003do xAttribute = 1 to listlen(componentAttribute);"},{"entry":"\u2003\u2003\u2003\u2003thisAttribute=getiteml(componentAttribute, xAttribute);"},{"entry":"\u2003\u2003\u2003\u2003if nameditem(thisAttribute, \u2018category\u2019) then do;"},{"entry":"\u2003\u2003\u2003\u2003\u2003if upcase(getnitemc(thisAttribute,\u2018type\u2019))=\u2018LIST\u2019 and"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003upcase(getnitemc(thisAttribute,\u2018category\u2019)) in (\u2018\u2019) and"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003upcase(getnitemc(thisAttribute,\u2018scope\u2019))=\u2018PUBLIC\u2019"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003then do;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003rc=insertc(targetCategory, upcase(getnitemc(thisAttribute,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2018category\u2019)),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u22121, thisProgram.description);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003rc=insertc(targetAttribute, getnitemc(thisAttribute, \u2018name\u2019),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u22121,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003thisProgram.description);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003rc=inserto(targetInstance, thisProgram, \u22121, thisProgram."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003description);"},{"entry":"\u2003\u2003\u2003\u2003\u2003end;"},{"entry":"\u2003\u2003\u2003\u2003end;"},{"entry":"\u2003\u2003\u2003\u2003rc=clearlist(thisAttribute);"},{"entry":"\u2003\u2003\u2003end;"},{"entry":"\u2003\u2003\u2003rc=dellist(thisAttribute, \u2018Y\u2019);"},{"entry":"\u2003\u2003\u2003rc=dellist(componentAttribute, \u2018Y\u2019);"},{"entry":"\u2003\u2003end;"},{"entry":"\u2003endmethod;"},{"entry":"endclass;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In operation B-, as set forth in the exemplary code below, the Task Aspect iterates sequentially through a list of properties identified as target property names, involved in a mutual relationship, as defined by the process in operation B-. This program searches the list of source property names for a matching entry. When a matching entry is found, the attribute object-identifier of the source property is assigned to the target property, within the corresponding target instance.","Operation B-:",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class taskAspect;"},{"entry":"\u2003public char name \/ (state=\u2018o\u2019, initialValue=\u2018task aspect\u2019);"},{"entry":"\u2003public list components \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003* cut ;"},{"entry":"\u2003integration: method;"},{"entry":"\u2003\u2003dcl object thisProgram=getnitemo(components, \u2018integration\u2019);"},{"entry":"\u2003\u2003thisProgram.runInterface(transport);"},{"entry":"\u2003endmethod;"},{"entry":"endclass;"},{"entry":"class integrationAssignments;"},{"entry":"\u2003public char name \/ (state=\u2018o\u2019, initialValue=\u2018integration\u2019);"},{"entry":"\u2003runInterface: method transport:list;"},{"entry":"\u2003\u2003dcl num xTarget xSource;"},{"entry":"\u2003\u2003dcl char targetName;"},{"entry":"\u2003\u2003dcl list sourceID targetID;"},{"entry":"\u2003\u2003dcl object thisSource thisTarget;"},{"entry":"\u2003\u2003dcl list sourceCategory =getniteml(transport, \u2018sourceCategory\u2019);"},{"entry":"\u2003\u2003dcl list targetCategory =getniteml(transport, \u2018targetCategory\u2019);"},{"entry":"\u2003\u2003dcl list sourceAttribute=getniteml(transport, \u2018sourceAttribute\u2019);"},{"entry":"\u2003\u2003dcl list targetAttribute=getniteml(transport, \u2018targetAttribute\u2019);"},{"entry":"\u2003\u2003dcl list sourceInstance =getniteml(transport, \u2018sourceInstance\u2019);"},{"entry":"\u2003\u2003dcl list targetInstance =getniteml(transport, \u2018targetInstance\u2019);"},{"entry":"\u2003\u2003do xTarget=1 to listlen(targetAttribute);"},{"entry":"\u2003\u2003\u2003targetName=getitemc(targetAttribute, xTarget);"},{"entry":"\u2003\u2003\u2003thisTarget=getitemo(targetInstance, xTarget);"},{"entry":"\u2003\u2003\u2003xSource=searchc(sourceAttribute, targetName);"},{"entry":"\u2003\u2003\u2003if xSource > 0 then do;"},{"entry":"\u2003\u2003\u2003\u2003thisSource=getitemo(sourceInstance, xSource);"},{"entry":"\u2003\u2003\u2003\u2003sourceID=thisSource._getAttributeValue(targetName);"},{"entry":"\u2003\u2003\u2003\u2003targetID=thisTarget._getAttributeValue(targetName);"},{"entry":"\u2003\u2003\u2003\u2003if getitemc(sourceCategory, xSource)=\u2018COMMON\u2019 then do;"},{"entry":"\u2003\u2003\u2003\u2003\u2003thisTarget._setAttributeValue(targetName, sourceID);"},{"entry":"\u2003\u2003\u2003\u2003end;"},{"entry":"\u2003\u2003\u2003end;"},{"entry":"\u2003\u2003end;"},{"entry":"\u2003endmethod;"},{"entry":"endclass;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 6","b":["602","604","606","608"]},"The integration operation joins, or links, attributes across instances. In theory, if it possible to use SQL to perform the operation called integration of concerns, we would expect to see the following exemplary code set forth in operation B-.","Operation B-:",{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"proc SQL-Magic;"]},{"entry":[{},"\u2003\u2003push objectIdentifiers"]},{"entry":[{},"\u2003\u2003located in sourceInstances workspace1, workspace2"]},{"entry":[{},"\u2003\u2003into targetInstances task1, task2, task2"]},{"entry":[{},"\u2003\u2003where attributeName in sourceInstances = attributeName"]},{"entry":[{},"\u2003\u2003in targetInstances;"]},{"entry":[{},"quit;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In operation B-, as set forth in the exemplary code below, this program obtains a list of program object-identifiers identified by the Task Aspect in operation B- as repository beans (\u201crepositoryBeans\u201d). This program then iterates sequentially over each instance, without regard to repository category, and obtains a listing of attributes within each instance. This program searches the listing of instance attributes for an attribute named \u201cBEANS.\u201d When an attribute named \u201cBEANS\u201d is located, the program object-identifiers identified as beans are copied into the attribute named beans within that instance.","Operation B-:",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class taskAspect;"]},{"entry":[{},"\u2003public char name \/ (state=\u2018o\u2019, initialValue=\u2018task aspect\u2019);"]},{"entry":[{},"\u2003public list components \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003public list transport \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003* cut ;"]},{"entry":[{},"\u2003beanPool: method;"]},{"entry":[{},"\u2003\u2003dcl object thisProgram=getnitemo(components, \u2018bean pool\u2019);"]},{"entry":[{},"\u2003\u2003thisProgram.runInterface(transport);"]},{"entry":[{},"\u2003endmethod;"]},{"entry":[{},"endclass;"]},{"entry":[{},"class beanPool;"]},{"entry":[{},"\u2003public char name \/ (state=\u2018o\u2019, initialValue=\u2018bean pool\u2019);"]},{"entry":[{},"\u2003runInterface: method transport:list;"]},{"entry":[{},"\u2003\u2003dcl object thisProgram;"]},{"entry":[{},"\u2003\u2003dcl num rc xComponent;"]},{"entry":[{},"\u2003\u2003dcl list repositoryInstances=getniteml(transport,"]},{"entry":[{},"\u2003\u2003\u2018repositoryInstances\u2019);"]},{"entry":[{},"\u2003\u2003dcl list beanBag =getniteml(transport, \u2018beanRepository\u2019);"]},{"entry":[{},"\u2003\u2003do xComponent = 1 to listlen(repositoryInstances);"]},{"entry":[{},"\u2003\u2003\u2003dcl list componentAttribute={ };"]},{"entry":[{},"\u2003\u2003\u2003thisProgram=getitemo(repositoryInstances, xComponent);"]},{"entry":[{},"\u2003\u2003\u2003thisProgram._getAttributes(componentAttribute, \u2018Y\u2019);"]},{"entry":[{},"\u2003\u2003\u2003if nameditem(componentAttribute, \u2018beans\u2019) then"]},{"entry":[{},"\u2003\u2003\u2003\u2003copylist(beanBag, \u2018N\u2019, thisProgram.beans);"]},{"entry":[{},"\u2003\u2003\u2003rc=dellist(componentAttribute, \u2018Y\u2019);"]},{"entry":[{},"\u2003\u2003end;"]},{"entry":[{},"\u2003endmethod;"]},{"entry":[{},"endclass;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In operation B-, the concept of a bean pool is extended, using event directives to accomplish the integration of concerns operation. This operation can be performed optionally, or in conjunction with the standard integration of concerns. While this operation is resource intensive, it may be beneficial when used to connect visual elements and non-visual elements in an application, effectively networking programs that exist in two separate layers. First, a calling program in the application issues an event coupled with a parameter declared as a \u201cLIST.\u201d Programs coded with a responding eventhandler insert their own program object identifier into the LIST parameter. This results with the LIST property in calling program being loaded with program object identifiers, which may be provided by visual widgets as well as non visual programs.","Operation B-:",{"@attributes":{"id":"p-0076","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class pushbutton1 extends sashelp.classes.pushbutton_c.class;"},{"entry":"\u2003eventhandler network \/ (sender=\u2018*\u2019, event=\u2018bean pool\u2019);"},{"entry":"\u2003network: method arg:list;"},{"entry":"\u2003\u2003dcl num rc=inserto(arg, _self_, \u22121);"},{"entry":"\u2003endmethod;"},{"entry":"\u2003* more statements ;"},{"entry":"endclass;"},{"entry":"class combobox1 extends sashelp.classes.combobox_c.class;"},{"entry":"\u2003eventhandler network \/ (sender=\u2018*\u2019, event=\u2018bean pool\u2019);"},{"entry":"\u2003network: method arg:list;"},{"entry":"\u2003\u2003dcl num rc=inserto(arg, _self_, \u22121); endmethod; * more statements;"},{"entry":"\u2003endclass;"},{"entry":"class task;"},{"entry":"\u2003public list beans \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list messages \/ (sendEvenr=\u2018N\u2019);"},{"entry":"\u2003\u2003getBeans: method; _sendEvent(\u2018bean pool\u2019, beans);"},{"entry":"\u2003endmethod;"},{"entry":"\u2003runInterface: method;"},{"entry":"\u2003\u2003dcl num i;"},{"entry":"\u2003\u2003dcl object thisProgram;"},{"entry":"\u2003\u2003do i=1 to listlen(beans) while (listlen(messages)=0);"},{"entry":"\u2003\u2003\u2003thisProgram.getitemo(beans, i);"},{"entry":"\u2003\u2003\u2003thisProgram.behavior1( );"},{"entry":"\u2003\u2003end;"},{"entry":"\u2003endmethod;"},{"entry":"endclass;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In accordance with one embodiment, the integration of concerns may involve a method for designating a program property to be used as property-in-common across objects created from a plurality of repository collectives as well as a method for identifying a program property location as the receptor for a common property identifier. The integration of concerns may also involve for creating a listing of information. The listing of information may comprise: (1) source property identifiers with associated program identifier(s); (2) target property identifiers with associated program identifier(s); (3) union-relationship transmission triggers with associated program identifier(s); and\/or (4) union-relationship reception points with associated program identifier(s). The integration of concerns may further involve logic for altering a target-program property by assigning a source property object-identifier to its designated target property.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 7","FIG. 7"],"b":["700","702","704"]},"The assembly process for repository programs includes the acquisition of data that specifies the physical location of a repository collective, the acquisition of repository program names, and class instantiation, and program sequencing. The assembly routine obtains a listing of class names in the container, performs an instantiation operation on each class, resulting in the creation of an instance. This approach removes hard-coded program names from the source code. Optionally, the ability to implement controls governing the execution-sequencing of individual programs as a separate concern allows the dynamic selection of repository collectives, which in traditional programming occurs during the initial application startup phase, and may also occur as needed during the course of the application.","In accordance with an embodiment of an assembly of concerns process, collective programs in a specified repository are located. For each collective, the respective object identifier(s) is created and stored for the duration of the application. The programs of repositories designated as source containers may be located and instantiated so that the object identifiers can be collected into one or more specified containers. In on embodiment, the programs of repositories designated as target containers can be located and instantiated so that the object identifiers are collected into one or more specified target containers.","Operation C- sets forth exemplary code for an assembly process in accordance with an illustrative embodiment.","Operation C-:",{"@attributes":{"id":"p-0082","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class assembly;"},{"entry":"\u2003public char name \/ (state=\u2018o\u2019, initialValue=\u2018assembly routine\u2019);"},{"entry":"\u2003public num sequenceFlag \/ (sendEvent=\u2018N\u2019, initialValue=0);"},{"entry":"\u2003public char libraryName \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list repositoryNames \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list rawVector \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list repositoryVector \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list processedVector \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list messages \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list activeMethods \/ (initialValue={"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2018step1\u2019,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2018step2\u2019,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2018step3\u2019,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2018step4\u2019,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2018step5\u2019,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2018step6\u2019,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2018step7\u2019,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003});"},{"entry":"\u2003runInterface: method repositoryContainer:list instanceContainer:list;"},{"entry":"\u2003\u2003dcl num xMethod xItem;"},{"entry":"\u2003\u2003copylist(repositoryContainer, \u2018N\u2019, repositoryNames);"},{"entry":"\u2003\u2003do xItem=1 to listlen(repositoryNames);"},{"entry":"\u2003\u2003\u2003do xMethod=1 to listlen(activeMethods) while"},{"entry":"\u2003\u2003\u2003(listlen(messages)=0);"},{"entry":"\u2003\u2003\u2003\u2003call send(_self_, getitemc(activeMethods, xMethod));"},{"entry":"\u2003\u2003\u2003end;"},{"entry":"\u2003\u2003\u2003call send(_self_, \u2018iterationCleanup\u2019);"},{"entry":"\u2003\u2003end;"},{"entry":"\u2003\u2003copylist(processedVector, \u2018N\u2019, instanceContainer);"},{"entry":"\u2003\u2003call send(_self_, \u2018cycleCleanup\u2019);"},{"entry":"\u2003endmethod;"},{"entry":"\u2003step1: method;"},{"entry":"\u2003\u2003dcl char thisRepository=upcase(popc(repositoryNames));"},{"entry":"\u2003\u2003dcl num rc;"},{"entry":"\u2003\u2003submit continue sql;"},{"entry":"\u2003\u2003create table work.temp as"},{"entry":"\u2003\u2003\u2003select * from sashelp.vcatalg"},{"entry":"\u2003\u2003\u2003where libname=\u2018&libraryName\u2019 and"},{"entry":"\u2003\u2003\u2003\u2003\u2003memname=\u2018&thisRepository\u2019 and"},{"entry":"\u2003\u2003\u2003\u2003\u2003objtype=\u2018CLASS\u2019;"},{"entry":"\u2003\u2003\u2003quit;"},{"entry":"\u2003\u2003\u2003endsubmit;"},{"entry":"\u2003\u2003\u2003if symgetn(\u2018sqlrc\u2019) then"},{"entry":"\u2003\u2003\u2003\u2003rc=insertc(messages, \u2018zero class structures in catalog\u2019, \u22121);"},{"entry":"\u2003endmethod;"},{"entry":"\u2003step2: method;"},{"entry":"\u2003\u2003dcl num rc dset;"},{"entry":"\u2003\u2003dcl char arg1 arg2 arg3 arg4;"},{"entry":"\u2003\u2003dset=open(\u2018work.temp\u2019, \u2018i\u2019);"},{"entry":"\u2003\u2003do while (fetch(dset)=0);"},{"entry":"\u2003\u2003\u2003arg1=getvarc(dset, varnum(dset, \u2018libname\u2019));"},{"entry":"\u2003\u2003\u2003arg2=getvarc(dset, varnum(dset, \u2018memname\u2019));"},{"entry":"\u2003\u2003\u2003arg3=getvarc(dset, varnum(dset, \u2018objname\u2019));"},{"entry":"\u2003\u2003\u2003arg4=getvarc(dset, varnum(dset, \u2018objtype\u2019));"},{"entry":"\u2003\u2003\u2003\u2003rc=insertc(rawVector, compress(arg1||\u2018.\u2019||arg2||\u2018.\u2019||arg3||\u2018.\u2019"},{"entry":"\u2003\u2003\u2003\u2003||arg4), \u22121);"},{"entry":"\u2003\u2003end;"},{"entry":"\u2003\u2003rc=close(dset);"},{"entry":"\u2003\u2003rc=delete(\u2018work.temp\u2019);"},{"entry":"\u2003endmethod;"},{"entry":"\u2003step3: method;"},{"entry":"\u2003\u2003dcl num xProgram rc;"},{"entry":"\u2003\u2003dcl object thisProgram;"},{"entry":"\u2003\u2003do xProgram=1 to listlen(rawVector);"},{"entry":"\u2003\u2003\u2003thisProgram=instance(loadclass(getitemc(rawVector, xProgram)));"},{"entry":"\u2003\u2003\u2003rc=inserto(repositoryVector, thisProgram, \u22121);"},{"entry":"\u2003\u2003end;"},{"entry":"\u2003endmethod;"},{"entry":"\u2003step4: method;"},{"entry":"\u2003\u2003dcl num i rc;"},{"entry":"\u2003\u2003dcl object thisProgram;"},{"entry":"\u2003\u2003dcl list componentAttribute={ };"},{"entry":"\u2003\u2003do i=1 to listlen(repositoryVector);"},{"entry":"\u2003\u2003\u2003thisProgram=getitemo(repositoryVector, i);"},{"entry":"\u2003\u2003\u2003thisProgram._getAttributes(componentAttribute, \u2018Y\u2019);"},{"entry":"\u2003\u2003\u2003if nameditem(componentAttribute, \u2018sequence_id\u2019) then do;"},{"entry":"\u2003\u2003\u2003\u2003sequenceFlag+1;"},{"entry":"\u2003\u2003\u2003\u2003nameitem(repositoryVector, i, thisProgram.sequence_id);"},{"entry":"\u2003\u2003\u2003end;"},{"entry":"\u2003\u2003\u2003rc=clearlist(componentAttribute, \u2018D\u2019);"},{"entry":"\u2003\u2003end;"},{"entry":"\u2003endmethod;"},{"entry":"\u2003step5: method;"},{"entry":"\u2003\u2003dcl num rc;"},{"entry":"\u2003\u2003if sequenceFlag=listlen(repositoryVector) then"},{"entry":"\u2003\u2003\u2003rc=sortlist(repositoryVector, \u2018name\u2019);"},{"entry":"\u2003endmethod;"},{"entry":"\u2003step6: method;"},{"entry":"\u2003\u2003dcl num xProgram;"},{"entry":"\u2003\u2003dcl object thisProgram;"},{"entry":"\u2003\u2003do xProgram=1 to listlen(repositoryVector);"},{"entry":"\u2003\u2003\u2003thisProgram=getitemo(repositoryVector, xProgram);"},{"entry":"\u2003\u2003\u2003nameitem(repositoryVector, xProgram, thisProgram.name);"},{"entry":"\u2003\u2003end;"},{"entry":"\u2003endmethod;"},{"entry":"\u2003step7: method;"},{"entry":"\u2003\u2003copylist(repositoryVector, \u2018N\u2019, processedVector);"},{"entry":"\u2003endmethod;"},{"entry":"\u2003iterationCleanup: method;"},{"entry":"\u2003\u2003dcl num rc;"},{"entry":"\u2003\u2003rc=clearlist(messages);"},{"entry":"\u2003\u2003rc=clearlist(rawVector);"},{"entry":"\u2003\u2003rc=clearlist(repositoryVector);"},{"entry":"\u2003\u2003sequenceFlag=0;"},{"entry":"\u2003endmethod;"},{"entry":"\u2003cycleCleanup: method;"},{"entry":"\u2003\u2003dcl num rc;"},{"entry":"\u2003\u2003rc=clearlist(repositoryNames);"},{"entry":"\u2003\u2003rc=clearlist(processedVector);"},{"entry":"\u2003endmethod;"},{"entry":"endclass;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"At \u201cstep1\u201d in operation C-, the assembly routine receives a datagram which is information that indicates the physical location of one or more program repositories. The datagram in this example is shown as a library reference which is a pointer to a physical location.","At \u201cstep2\u201d in operation C-, the assembly routine receives one datagram comprising of two parameters. The first parameter is an attribute object-identifier used as container of one or more repository names, where the names are specified by the generally accepted categorization chart. The second parameter is an attribute object-identifier used as a container for program object-identifiers created from programs within the repositories specified in the first parameter.","At \u201cstep3\u201d in operation C-, the assembly routine iterates over the list of repository names, applies the information indicating physical program location, and obtains a listing of information that comprises the full program name, restricting the gathering process to compiled objects called classes. The full program name is assembled and stored as a single unit of information within the assembly routine, referred to as the raw data vector.","At \u201cstep4\u201d in operation C-, the assembly routine iterates over the items in the raw-vector using the full program name to instantiate each class. The resulting program object-identifier is stored within the assembly routine, referred to as the repository-vector.","At \u201cstep5\u201d in operation C-, the assembly routine iterates over the items in the repository-vector. The attribute names within each instance are searched for a specified attribute name that is used to indicate that the program object identifiers within the current repository should be sequenced for normal program execution. The attribute names are searched for an attribute named \u201cSEQUENCE_ID.\u201d Each time the specified sequencing attribute name is located, a counter is incremented by 1, and the container element holding that program object-identifier is renamed to the same value found within \u201cSEQUENCE_ID.\u201d If every program in the current repository has the specified sequence attribute present, a flag can be set to indicate that sorting may be required to set the execution sequence for programs within the current repository. The sequencing of programs in a repository may be helpful when implementing a union of concerns in a specified step-action sequence.","At \u201cstep6\u201d in operation C-, the assembly program evaluates the flag set as seen in \u201cstep5\u201d to determine if sorting the instances located in the repository-vector is required. If sorting is required, the repository-vector can be sorted by name. This implementation results in program object identifiers that are sequenced according to data obtained from individual programs within a repository collective, where the sorting process itself is conditional on the presence of a specifically named property. A repository collective can indicate order of execution, independently of other decision logic, removing or reducing the need to hardcode program execution sequence.","At \u201cstep7\u201d in operation C-, the instance located in repository-vector are transferred into processed-vector. If multiple repository names are specified, the assembly program begins secondary iterations with \u201cstep4.\u201d","At \u201cstep8\u201d in operation C-, the assembly program transfers program object-identifiers currently within the processed-vector into the outbound instance container which was the second part of the datagram.","In accordance with one embodiment, the assembly and storage of program object-identifiers (i.e., the assembly of concerns) may involve logic for obtaining physical program names within a specified program repositories and logic for storing the object-identifier of each repository program into a specified container.","In a separation of concerns, five program-logic structures can be identified and separated while two program-logic structures can be removed. Program statements and blocks of program statements can be separated into independent programs to create a generally accepted logic categorization chart (where the assignment of specific category identification may be subjective or object as needed). Separation of concerns may be used to separate concerns that are intended for use in union of concerns implementation during the initial application development. Separation of concerns may also be used to identify new programs that exist as separate entities. Separation of concerns may further be integrated and layered into the application during secondary development efforts.","The functionality of all computer programming languages can be listed in reference manuals as a standalone command, or as series of individual commands. In both of these cases, the commands may be divided into sections called categories, with a specific purpose fulfilled by each category. A concern is a command, or complete set of commands that fulfill one categorical process, within one logical task. A concern is encapsulated as a complete and separate program, without compile-time dependencies on other programs, and is able to exist as a separate and standalone entity.","A repository represents an encapsulation of one or more concerns where the category designation for each concern can be mapped back to the categorical divisions of commands within a reference manual. Optionally, categorically naming and mapping repository names can be extended as needed, providing the names are generally accepted and visually self-documenting. A series of repositories within one category represents a grouping of concerns, where each repository within a series may represent a group of similar functions, may represent legacy code separation from newly developed code, represents a separation of decision-logic and task-logic, and so on. The categorical naming of logic, functional, or behavioral categories can be used to create a generally accepted logic categorization chart.","A separation of concerns begins with the categorical naming of program repositories and includes the program or program series within a repository, as well as the grouping of logic statements within a program work-unit, referred to as a method. In this instance, a method may e a container for program statements and temporary property declarations. Logic within a method may be limited in content to physically separate five key structural elements:\n\n","A separation of concerns may also require the removal of two structural elements:\n\n","The separation of key elements provides an insulation between concerns, which can be useful in planning and implementing concerns that are \u201cre-factored\u201d to the lowest necessary level at the beginning of the system development life cycle. The early identification of key structural elements means that separation of concerns, integration of concerns, and union of concerns can be systematically implemented according to a generally accepted logic categorization chart. The separation of concerns organizes program code in principled ways, which allows the encapsulation of logic at increasingly granular levels without creating an overburdening structure within the application. Generally speaking, separation of concerns may be viewed as being all about the preparing modules of software for operations that include assembly, integration, and union.","Operation D- shows exemplary code for a standard entry point for an object-oriented application.","Operation D-:",{"@attributes":{"id":"p-0099","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"init: dcl object thisProgram = _newcontroller( );"]},{"entry":[{},"\u2003\u2003thisProgram.runInterface( );"]},{"entry":[{},"\u2003\u2003thisProgram._term( );"]},{"entry":[{},"return;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Operation D- sets forth exemplary code for a standard skeleton of repository program. The execution of a repository program may begin with a method commonly designated as the primary runtime interface. In this example, the primary runtime method is named \u201crunInterface.\u201d The logic and data that defines \u201celement A\u201d can include the logic within \u201crunInterface\u201d and the data located within the property named \u201cactiveMethods.\u201d The logic in \u201crunInterface\u201d sequentially iterates through data items located in \u201cactiveMethods,\u201d providing the count of data items within the property named messages remains zero. A concern that alters the contents of messages must be coded in a separate method from other logic, or must be coded as a separate repository program. The expected result is that the singular task of the method named \u201crunInterface\u201d is the initiation and monitoring of the execution cycle.","Operation D-:",{"@attributes":{"id":"p-0101","num":"0107"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class controller;"]},{"entry":[{},"\u2003public list messages \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003public list activeMethods \/ (initialValue={"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2018step1\u2019,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2018step2\u2019,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2018step3\u2019"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003});"]},{"entry":[{},"\u2003runInterface: method;"]},{"entry":[{},"\u2003\u2003dcl num i;"]},{"entry":[{},"\u2003\u2003do i=1 to listlen(activeMethods) while (listlen(messages)=0);"]},{"entry":[{},"\u2003\u2003\u2003call send(_self_, getitemc(activeMethods, i));"]},{"entry":[{},"\u2003\u2003end;"]},{"entry":[{},"\u2003endmethod;"]},{"entry":[{},"\u2003step1: method;"]},{"entry":[{},"\u2003endmethod;"]},{"entry":[{},"\u2003step2: method;"]},{"entry":[{},"\u2003endmethod;"]},{"entry":[{},"\u2003step3: method;"]},{"entry":[{},"\u2003endmethod;"]},{"entry":[{},"endclass;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Operation D- shows exemplary code that uses information located in an external data container to drive the execution path of the application. The execution path within operation D- may be defined in terms of three methods, as detailed by the data content of the property named \u201cactiveMethods.\u201d The execution path may be outside of operation D- and can be defined in terms of a single program, or a series of programs, where the number of programs and sequence of execution are specified through repository names contained within the \u201cSLIST\u201d entity named \u201crepositoryNames.\u201d","Operation D-:",{"@attributes":{"id":"p-0103","num":"0109"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"class controller;"},{"entry":"\u2003public list components \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list messages \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list repositoryNames \/ (sendEvent=\u2018N\u2019);"},{"entry":"\u2003public list activeMethods \/ (initialValue={"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2018step1\u2019,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2018step2\u2019,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2018step3\u2019"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003});"},{"entry":"\u2003runInterface: method;"},{"entry":"\u2003\u2003dcl num i;"},{"entry":"\u2003\u2003do i=1 to listlen(activeMethods) while (listlen(messages)=0);"},{"entry":"\u2003\u2003\u2003call send(_self_, getitemc(activeMethods, i));"},{"entry":"\u2003\u2003end;"},{"entry":"\u2003endmethod;"},{"entry":"\u2003step1: method \/ (description=\u2018access external metadata\u2019);"},{"entry":"\u2003\u2003dcl num rc;"},{"entry":"\u2003\u2003rc=fillist(\u2018CATALOG\u2019,"},{"entry":"\u2003\u2003\u2003\u2018anyLibary.anyCatalog.repositoryNames.slist\u2019,"},{"entry":"\u2003\u2003\u2003repositoryNames);"},{"entry":"\u2003\u2003if listlen(repositoryNames)=0 then"},{"entry":"\u2003\u2003\u2003rc=insertc(messages, \u2018absence of repository names\u2019, \u22121);"},{"entry":"\u2003endmethod;"},{"entry":"\u2003step2: method \/ (description=\u2018application assembly specified"},{"entry":"\u2003by library name\u2019);"},{"entry":"\u2003\u2003dcl object thisProgram=instance(loadclass(\u2018anyLibrary."},{"entry":"\u2003\u2003\u2003anyRepository.assembly.class\u2019));"},{"entry":"\u2003\u2003thisProgram.libraryName=\u2018ANYLIBRARY\u2019;"},{"entry":"\u2003\u2003thisProgam.runInterface(repositoryNames, components);"},{"entry":"\u2003\u2003copylist(thisProgram.messages, \u2018n\u2019, messages) thisProgram._term( );"},{"entry":"\u2003endmethod;"},{"entry":"\u2003step3: method \/ (description=\u2018repository program execution\u2019);"},{"entry":"\u2003\u2003dcl num i;"},{"entry":"\u2003\u2003dcl object thisProgram;"},{"entry":"\u2003\u2003do i=1 to listlen(components) while (listlen(messages)=0);"},{"entry":"\u2003\u2003\u2003thisProgram=getitemo(components, i); thisProgram.runInterface( );"},{"entry":"\u2003\u2003\u2003copylist(thisProgram.messages, \u2018N\u2019, messages)"},{"entry":"\u2003\u2003end;"},{"entry":"\u2003endmethod;"},{"entry":"endclass;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"An illustrative content listing for \u201canylibrary.anyCatalog.repositoryNames.slist.\u201d (as set forth in operation D-) is presented as follows:",{"@attributes":{"id":"p-0105","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SLIST(\u2018REPOSITORY401\u2019 {C}"]},{"entry":[{},"\u2003\u2003\u2018REPOSITORY402\u2019 {C}"]},{"entry":[{},"\u2003\u2003\u2018REPOSITORY403\u2019 {C}"]},{"entry":[{},"\u2003\u2003\u2018REPOSITORY201\u2019 {C}"]},{"entry":[{},"\u2003\u2003\u2018REPOSITORY801\u2019 {C}"]},{"entry":[{},"}[3]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In accordance with the illustrative content listing for \u201canylibrary.anyCatalog.repositoryNames.slist,\u201d  shows an illustrative content listing of \u201canyLibary.REPOSITORY401.\u201d","Operation D- shows exemplary code for demonstrating the implementation of logic representing a decision occurring separately from corresponding task logic. Decision logic in computer programs is generally written as a test condition, or series of test conditions, where the final result is negative, positive, or specified value. Separating the structure of decision logic from other categories of logic can be performed by storing the results of the decision condition as a unique data element located in a property that can be accessed application-wide after integration of concerns. In this example, a negative result on the test condition in method \u201cdecisionPoint\u201d triggers one of two items to be inserted into the common property is named status. The evaluation of the test condition is the logic that represents a decision, while the insertion of data into the common property is a unique specified value.","Operation D-:",{"@attributes":{"id":"p-0108","num":"0114"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class businessRule045;"]},{"entry":[{},"\u2003public list status \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003runInterface: method;"]},{"entry":[{},"\u2003\u2003dcl num rc;"]},{"entry":[{},"\u2003\u2003submit continue sql;"]},{"entry":[{},"\u2003\u2003create table work.temp as"]},{"entry":[{},"\u2003\u2003\u2003select distinct anyColumnName"]},{"entry":[{},"\u2003\u2003\u2003from anyLibrary.anyTable;"]},{"entry":[{},"\u2003\u2003endsubmit;"]},{"entry":[{},"\u2003\u2003if symgetn(\u2018sqlobs\u2019)=0"]},{"entry":[{},"\u2003\u2003\u2003then rc=insertn(status, 0, \u22121, \u2018BR045A\u2019);"]},{"entry":[{},"\u2003\u2003\u2003else rc=insertn(status, 0, \u22121, \u2018BR045B\u2019);"]},{"entry":[{},"\u2003endmethod;"]},{"entry":[{},"endclass;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Operation D- shows exemplary code for demonstrating the implementation of logic representing a task corresponding to the decision specified in operation D-. In practice, a task concerns may contain no self-determination logic. For demonstrative purposes, the example the task concern named \u201ctask045\u201d contains self-determination logic that evaluates the presence of a specified data value in a shared property. The structure of the task is separated from other concerns by its existence as a standalone program. Task program \u201ctask045\u201d can be executed at any time, but the individual task implementations are only activated when a specific data value created in another application program is detected within the shared property.","Operation D-:",{"@attributes":{"id":"p-0110","num":"0116"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class task045;"]},{"entry":[{},"\u2003public list status \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003public list messages \/ (sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003public list activeMethods \/ (initialValue={"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2018task1\u2019,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2018task2\u2019"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003});"]},{"entry":[{},"\u2003runInterface: method;"]},{"entry":[{},"\u2003\u2003dcl num i;"]},{"entry":[{},"\u2003\u2003do i=1 to listlen(activeMethods) while (listlen(messages)=0);"]},{"entry":[{},"\u2003\u2003call send(_self_, getitemc(activeMethods, i));"]},{"entry":[{},"\u2003\u2003end;"]},{"entry":[{},"\u2003\u2003call send(_self_, \u2018cleanup\u2019);"]},{"entry":[{},"\u2003endmethod;"]},{"entry":[{},"\u2003task1: method;"]},{"entry":[{},"\u2003\u2003if getnitem(status, \u2018BR045A\u2019)=0 then return;"]},{"entry":[{},"\u2003\u2003* more statements ;"]},{"entry":[{},"\u2003endmethod;"]},{"entry":[{},"\u2003task2: method;"]},{"entry":[{},"\u2003\u2003if getnitem(status, \u2018BR045B\u2019)=0 then return;"]},{"entry":[{},"\u2003\u2003* more statements ;"]},{"entry":[{},"\u2003endmethod;"]},{"entry":[{},"\u2003cleanup: method;"]},{"entry":[{},"\u2003\u2003dcl num rc=clearlist(status);"]},{"entry":[{},"\u2003endmethod;"]},{"entry":[{},"endclass;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Operation D- shows exemplary code for demonstrating the implementation of properties common to multiple programs. In practice, the only logic statements permitted in this category of component are statements that clear data values from properties that are specified as common, or involved in multiple ownership. Multiple ownership of a single property across multiple programs is implemented through integration of concerns.","Operation D-:",{"@attributes":{"id":"p-0112","num":"0118"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class workspace;"]},{"entry":[{},"\u2003public list messages \/ (category=\u2018COMMON\u2019, sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003public list status \/ (category=\u2018COMMON\u2019, sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003public list dataVector \/ (category=\u2018COMMON\u2019, sendEvent=\u2018N\u2019);"]},{"entry":[{},"\u2003runInterface: method;"]},{"entry":[{},"\u2003\u2003dcl num rc;"]},{"entry":[{},"\u2003\u2003rc=clearlist(messages);"]},{"entry":[{},"\u2003\u2003rc=clearlist(status);"]},{"entry":[{},"\u2003\u2003rc=clearlist(dataVector, \u2018D\u2019);"]},{"entry":[{},"\u2003endmethod;"]},{"entry":[{},"endclass;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Operation D- shows exemplary code for demonstrating two program directives that become deprecated when using an assembly service as seen in operation C-. Directives that identify programs using the import statement create a hard-coded dependency on another program, creating tight-coupling between programs, which in turn creates program inflexibility. Identical problems are seen with class instantiations that specifically name a program and program location.","Operation D-:",{"@attributes":{"id":"p-0114","num":"0120"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"import anyLibrary.anyCatalog;"]},{"entry":[{},"class anyName;"]},{"entry":[{},"\u2003_init: method \/ (state=\u2018o\u2019);"]},{"entry":[{},"\u2003\u2003dcl object thisProgram ="]},{"entry":[{},"\u2003\u2003_newanyLibrary.anyCatalog.anyProgram.class( );"]},{"entry":[{},"\u2003endclass;"]},{"entry":[{},"endclass;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Program relationships can be created between the implementations of decision-logic concern, integration of concerns, and task-logic concern. Hundreds of individual programs divided by category, function, and sequence can be seamlessly integrated and function as if written as a single program. Program relationships created by the additional implementation of union of concerns provides the ability to layer in new functionality as-needed without disturbing existing code.","Categorizing logic to create a generally accepted logic categorization chart can be as subjective or objective as needed, where the categorizations are used to organize relationships between programs within the application, by defining a relationship as the programs within a repository. A repository is a container, where the usage of the container in intended to be identified internally, externally, or through metadata. The numbering and naming of a repository may be insignificant. The categorization of repository containers for specific program logic representing sequential steps, segments within category, program grouping by logical feature, programs grouping by function, can be used to create a generally accepted \u201cDewey Decimal System\u201d for organizing program, or for organizing relationships between programs.","The usage of a repository containing programs and metadata intended to represent a single category of logic provides the ability to zero in on specific problems, bypassing the traditional need to trace through an entire application to locate specific logic. For example, program issues related to importing data from an external data repository would be located in a data source repository (e.g., \u201crepository401,\u201d \u201crepository402,\u201d etc.). Issues related to the appearance of titles or footnotes on a report would only be located in a report repository (e.g., \u201crepository801,\u201d \u201crepository802,\u201d etc.).","Some exemplary basic categories of computer program logic that can be used in business applications are shown in  and are described as follows:\n\n",{"@attributes":{"id":"p-0119","num":"0136"},"figref":"FIG. 10","b":["1002","1004"]},"In accordance with one embodiment, the categorizing program logic statements and program logic blocks into separate containers (i.e., the separation of concerns) may involve the identification and classification of program logic statements and program logic blocks according to a generally accepted logic categorization chart. Each identified concern (or series of concerns) may be separated according to at least one of functionality, sequence, and usage, based in principal on the generally accepted logic categorization chart. Each identified concern (or series of concerns) may be encapsulated as separate and self contained program within a repository whose physical name maps to the generally accepted logic categorization chart.",{"@attributes":{"id":"p-0121","num":"0138"},"figref":"FIG. 11","b":["1100","1102","1104","1105","1104","1106","1108","1110","1112","1104","1114"]},"A representative hardware environment associated with the various components of  is depicted in . In the present description, the various sub-components of each of the components may also be considered components of the system. For example, particular software modules executed on any component of the system may also be considered components of the system. In particular,  illustrates an exemplary hardware configuration of a computer  having a central processing unit , such as a microprocessor, and a number of other units interconnected via a system bus . The computer  shown in  includes a Random Access Memory (RAM) , Read Only Memory (ROM) , an I\/O adapter  for connecting peripheral devices such as, for example, disk storage units  and printers  to the bus , a user interface adapter  for connecting various user interface devices such as, for example, a keyboard , a mouse , a speaker , a microphone , and\/or other user interface devices such as a touch screen or a digital camera to the bus , a communication adapter  for connecting the computer  to a communication network  (e.g., a data processing network) and a display adapter  for connecting the bus  to a display device . The computer may utilize an operating system such as, for example, a Microsoft Windows operating system (O\/S), a Macintosh O\/S, a Linux O\/S and\/or a UNIX O\/S.","Those of ordinary skill in the art will appreciate that embodiments may also be implemented on platforms and operating systems other than those mentioned. One of ordinary skilled in the art will also be able to combine software with appropriate general purpose or special purpose computer hardware to create a computer system or computer sub-system for implementing various embodiments described herein. It should be understood the use of the term logic may be defined as hardware and\/or software components capable of performing\/executing sequence(s) of functions. Thus, logic may comprise computer hardware, circuitry (or circuit elements) and\/or software or any combination thereof.","The embodiments set forth herein have been described in relation to programs written using the SAS System. Embodiments of the present invention may also be implemented using computer program languages such as, for example, ActiveX, Java, C, and the C++ language and utilize object oriented programming methodology. Any such resulting program, having computer-readable code, may be embodied or provided within one or more computer-readable media, thereby making a computer program product (i.e., an article of manufacture). The computer readable media may be, for instance, a fixed (hard) drive, diskette, optical disk, magnetic tape, semiconductor memory such as read-only memory (ROM), etc., or any transmitting\/receiving medium such as the Internet or other communication network or link. The article of manufacture containing the computer code may be made and\/or used by executing the code directly from one medium, by copying the code from one medium to another medium, or by transmitting the code over a network.","Object oriented programming (OOP) has become increasingly used to develop complex applications. As OOP moves toward the mainstream of software design and development, various software solutions require adaptation to make use of the benefits of OOP. A need exists for these principles of OOP to be applied to a messaging interface of an electronic messaging system such that a set of OOP classes and objects for the messaging interface can be provided.","OOP is a process of developing computer software using objects, including the steps of analyzing the problem, designing the system, and constructing the program. An object is a software package that contains both data and a collection of related structures and procedures.","Since it contains both data and a collection of structures and procedures, it can be visualized as a self-sufficient component that does not require other additional structures, procedures or data to perform its specific task. OOP, therefore, views a computer program as a collection of largely autonomous components, called objects, each of which is responsible for a specific task. This concept of packaging data, structures, and procedures together in one component or module is called encapsulation.","In general, OOP components are reusable software modules which present an interface that conforms to an object model and which are accessed at run-time through a component integration architecture. A component integration architecture is a set of architecture mechanisms which allow software modules in different process spaces to utilize each others capabilities or functions. This is generally done by assuming a common component object model on which to build the architecture. It is worthwhile to differentiate between an object and a class of objects at this point. An object is a single instance of the class of objects, which is often just called a class. A class of objects can be viewed as a blueprint, from which many objects can be formed.","OOP allows the programmer to create an object that is a part of another object. For example, the object representing a piston engine is said to have a composition-relationship with the object representing a piston. In reality, a piston engine comprises a piston, valves and many other components; the fact that a piston is an element of a piston engine can be logically and semantically represented in OOP by two objects.","OOP also allows creation of an object that \u201cdepends from\u201d another object. If there are two objects, one representing a piston engine and the other representing a piston engine wherein the piston is made of ceramic, then the relationship between the two objects is not that of composition. A ceramic piston engine does not make up a piston engine. Rather it is merely one kind of piston engine that has one more limitation than the piston engine; its piston is made of ceramic. In this case, the object representing the ceramic piston engine is called a derived object, and it inherits all of the aspects of the object representing the piston engine and adds further limitation or detail to it. The object representing the ceramic piston engine \u201cdepends from\u201d the object representing the piston engine. The relationship between these objects is called inheritance.","When the object or class representing the ceramic piston engine inherits all of the aspects of the objects representing the piston engine, it inherits the thermal characteristics of a standard piston defined in the piston engine class. However, the ceramic piston engine object overrides these ceramic specific thermal characteristics, which are typically different from those associated with a metal piston. It skips over the original and uses new functions related to ceramic pistons. Different kinds of piston engines have different characteristics, but may have the same underlying functions associated with it (e.g., how many pistons in the engine, ignition sequences, lubrication, etc.). To access each of these functions in any piston engine object, a programmer would call the same functions with the same names, but each type of piston engine may have different\/overriding implementations of functions behind the same name. This ability to hide different implementations of a function behind the same name is called polymorphism and it greatly simplifies communication among objects.","With the concepts of composition-relationship, encapsulation, inheritance and polymorphism, an object can represent just about anything in the real world. In fact, one's logical perception of the reality is the only limit on determining the kinds of things that can become objects in object-oriented software. Some typical categories are as follows:\n\n","With this enormous capability of an object to represent just about any logically separable matters, OOP allows the software developer to design and implement a computer program that is a model of some aspects of reality, whether that reality is a physical entity, a process, a system, or a composition of matter. Since the object can represent anything, the software developer can create an object which can be used as a component in a larger software project in the future.","Some benefits of object classes can be summarized, as follows:\n\n","Class libraries are very flexible. As programs grow more complex, more programmers are forced to reinvent basic solutions to basic problems over and over again. A relatively new extension of the class library concept is to have a framework of class libraries. This framework is more complex and consists of significant collections of collaborating classes that capture both the small scale patterns and major mechanisms that implement the common requirements and design in a specific application domain. They were first developed to free application programmers from the chores involved in displaying menus, windows, dialog boxes, and other standard user interface elements for personal computers.","Frameworks also represent a change in the way programmers think about the interaction between the code they write and code written by others. In the early days of procedural programming, the programmer called libraries provided by the operating system to perform certain tasks, but basically the program executed down the page from start to finish, and the programmer was solely responsible for the flow of control. This was appropriate for printing out paychecks, calculating a mathematical table, or solving other problems with a program that executed in just one way.","The development of graphical user interfaces began to turn this procedural programming arrangement inside out. These interfaces allow the user, rather than program logic, to drive the program and decide when certain actions should be performed. Today, most personal computer software accomplishes this by means of an event loop which monitors the mouse, keyboard, and other sources of external events and calls the appropriate parts of the programmer's code according to actions that the user performs. The programmer no longer determines the order in which events occur. Instead, a program is divided into separate pieces that are called at unpredictable times and in an unpredictable order. By relinquishing control in this way to users, the developer creates a program that is much easier to use. Nevertheless, individual pieces of the program written by the developer still call libraries provided by the operating system to accomplish certain tasks, and the programmer must still determine the flow of control within each piece after it's called by the event loop. Application code still \u201csits on top of\u201d the system.","Even event loop programs require programmers to write a lot of code that should not need to be written separately for every application. The concept of an application framework carries the event loop concept further. Instead of dealing with all the nuts and bolts of constructing basic menus, windows, and dialog boxes and then making these things all work together, programmers using application frameworks start with working application code and basic user interface elements in place. Subsequently, they build from there by replacing some of the generic capabilities of the framework with the specific capabilities of the intended application.","Application frameworks reduce the total amount of code that a programmer has to write from scratch. However, because the framework is really a generic application that displays windows, supports copy and paste, and so on, the programmer can also relinquish control to a greater degree than event loop programs permit. The framework code takes care of almost all event handling and flow of control, and the programmer's code is called only when the framework needs it (e.g., to create or manipulate a proprietary data structure).","A programmer writing a framework program not only relinquishes control to the user (as is also true for event loop programs), but also relinquishes the detailed flow of control within the program to the framework. This approach allows the creation of more complex systems that work together in interesting ways, as opposed to isolated programs, having custom code, being created over and over again for similar problems.","Thus, as is explained above, a framework basically is a collection of cooperating classes that make up a reusable design solution for a given problem domain. It typically includes objects that provide default behavior (e.g., for menus and windows), and programmers use it by inheriting some of that default behavior and overriding other behavior so that the framework calls application code at the appropriate times.","There are three main differences between frameworks and class libraries:\n\n","Sun Microsystems defines Java as: \u201ca simple, object-oriented, distributed, interpreted, robust, secure, architecture-neutral, portable, high-performance, multithreaded, dynamic, buzzword-compliant, general-purpose programming language. Java supports programming for the Internet in the form of platform-independent Java applets.\u201d Java applets are small, specialized applications that comply with Sun's Java Application Programming Interface (API) allowing developers to add \u201cinteractive content\u201d to Web documents (e.g., simple animations, page adornments, basic games, etc.). Applets execute within a Java-compatible browser (e.g., Netscape Navigator) by copying code from the server to client. From a language standpoint, Java's core feature set is based on C++. Sun's Java literature states that Java is basically, \u201cC++ with extensions from Objective C for more dynamic method resolution.\u201d","JavaScript is an interpreted programming or script language from Netscape. It is somewhat similar in capability to Microsoft's Visual Basic, Sun's Tcl, the UNIX-derived Perl, and IBM's REX. In general, script languages are easier and faster to code in than the more structured and compiled languages such as C and C++. JavaScript is used in Web site development to do such things as: automatically change a formatted date on a Web page; cause a linked-to page to appear in a popup window; and cause text or a graphic image to change during a mouse rollover.","JavaScript uses some of the same ideas found in Java. JavaScript code can be imbedded in HTML pages and interpreted by the Web browser (or client). JavaScript can also be run at the server as in Microsoft's Active Server Pages before the page is sent to the requestor. Both Microsoft and Netscape browsers support JavaScript.","Another technology that provides similar function to Java is provided by Microsoft and ActiveX Technologies, to give developers and Web designers wherewithal to build dynamic content for the Internet and personal computers. ActiveX includes tools for developing animation, 3-D virtual reality, video and other multimedia content. The tools use Internet standards, work on multiple platforms, and are being supported by over 100 companies. The group's building blocks are called ActiveX Controls, small, fast components that enable developers to embed parts of software in hypertext markup language (HTML) pages. ActiveX Controls work with a variety of programming languages including Microsoft Visual C++, Borland Delphi, Microsoft Visual Basic programming system and, in the future, Microsoft's development tool for Java, code named \u201cJakarta.\u201d ActiveX Technologies also includes ActiveX Server Framework, allowing developers to create server applications. One of ordinary skill in the art readily recognizes that ActiveX could be substituted for Java without undue experimentation to practice the invention.","A technology of Active X is the component object model (COM). Used in a network with a directory and additional support, COM becomes the distributed component object model (DCOM). The main thing that you create when writing a program to run in the ActiveX environment is a component, a self-sufficient program that can be run anywhere in your ActiveX network. This component is known as an ActiveX control. ActiveX is Microsoft's answer to the Java technology from Sun Microsystems. An ActiveX control is roughly equivalent to a Java applet. OCX stands for \u201cObject Linking and Embedding control.\u201d Object Linking and Embedding (OLE) was Microsoft's program technology for supporting compound documents such as the Windows desktop. The Component Object Model now takes in OLE as part of a larger concept. Microsoft now uses the term \u201cActiveX control\u201d instead of \u201cOCX\u201d for the component object. An advantage of a component is that it can be re-used by many applications (referred to as component containers). A COM component object (ActiveX control) can be created using one of several languages or development tools, including C++ and Visual Basic, or PowerBuilder, or with scripting tools such as VBScript.","Serialization involves saving the current state of an object to a stream, and restoring an equivalent object from that stream. The stream functions as a container for the object. Its contents include a partial representation of the object's internal structure, including variable types, names, and values. The container may be transient (RAM-based) or persistent (disk-based). A transient container may be used to prepare an object for transmission from one computer to another. A persistent container, such as a file on disk, allows storage of the object after the current session is finished. In both cases the information stored in the container can later be used to construct an equivalent object containing the same data as the original. The example code in this article will focus on persistence.","Inheritance may be defined as a relationship that defines one entity in terms of another. Class inheritance defines a new class in terms of one or more parent classes. The new class may inherit its interface and implementation from its parent class(es). The new class is called a subclass or a derived class. Class inheritance may combine interface inheritance and implementation inheritance. Interface inheritance defines a new interface in terms of one or more existing interfaces while implementation inheritance defines a new implementation in terms of one or more existing implementations. In object-oriented programming, inheritance may further be defined as an ability to create new classes (or interfaces) that contain all the methods and properties of another class (or interface), plus additional methods and properties. For example, if class (or interface) \u201cB\u201d inherits from class (or interface) \u201cA\u201d, then class B is said to be derived from class A. Class B may be referred to as a base (or super) class (or interface) for class D.","When a class of objects is defined, any subclass that is defined may inherit the definition of one or more general classes. In the case where some modification to the definition is needed in the subclass, new methods and\/or properties may be included in the definition.","A bit stream may be defined as a continuous transfer of bits over some medium. For example, a bit stream may comprise a series of transmitted bits through a transmission link.","A superclass (as referred to as a base or parent class) is one from which other classes are derived using inheritance. In class inheritance, the subclass is said to inherit its interface and implementation from its superclass(es). In object orientated programming, a superclass may be a class that is above another class in the class hierarchy. For example, class \u201cA\u201d may be a superclass of class \u201cB\u201d if classes A and B are on the same branch of a class hierarchy tree and class A is higher on that branch than class B.","In general, introspection may comprise the ability of an object to reveal information about itself as an object such as for example, the object's class, superclass), the messages the object is capable of responding to, and the protocols to which the object conforms. In Java, introspection may further comprise a process by which a class is read in order to create a representation of the object's application program interface (API). Introspection may be carried out by the Java Introspector class, which is part of the Java Core Reflection API. Introspection may be used to provide additional information about an object, supplementing information learned by reflection.","Run-time may be defined as a time during which a program is active and being executed or executing (i.e., the time the program is being run).","Design time may be defined as a time during which an application is being built in a development environment\/process. Code may be created and edited during design time.","Transmission Control Protocol\/Internet Protocol (TCP\/IP) is a basic communication language or protocol of the Internet. It can also be used as a communications protocol in the private networks called intranet and in extranet. TCP\/IP is a two-layering program. The higher layer, Transmission Control Protocol or TCP, manages the assembling of a message or file into smaller packet that are transmitted over the Internet and received by a TCP layer that reassembles the packets into the original message. The lower layer, Internet Protocol or IP, handles the address part of each packet so that it gets to the right destination. Each gateway computer on the network checks this address to see where to forward the message. Even though some packets from the same message are routed differently than others, they'll be reassembled at the destination.","TCP\/IP uses a client\/server model of communication in which a computer user (a client) requests and is provided a service (such as sending a Web page) by another computer (a server) in the network. TCP\/IP communication is primarily point-to-point, meaning each communication is from one point (or host computer) in the network to another point or host computer. TCP\/IP and the higher-level applications that use it are collectively said to be \u201cstateless\u201d because each client request is considered a new request unrelated to any previous one (unlike ordinary phone conversations that require a dedicated connection for the call duration). Being stateless frees network paths so that everyone can use them continuously. (Note that the TCP layer itself is not stateless as far as any one message is concerned. Its connection remains in place until all packets in a message have been received.). Several higher layer application protocols use TCP\/IP to get to the Internet. These include the World Wide Web's Hypertext Transfer Protocol (HTTP), the File Transfer Protocol (FTP), Telnet, and the Simple Mail Transfer Protocol (SMTP). These and other protocols are often packaged together with TCP\/IP as a \u201csuite.\u201d Personal computer users usually get to the Internet through the Serial Line Internet Protocol (SLIP) or the Point-to-Point Protocol. These protocols encapsulate the IP packets so that they can be sent over a dial-up phone connection to an access provider's modem.","Protocols related to TCP\/IP include the User Datagram Protocol (UDP), which is used instead of TCP for special purposes. Other protocols are used by network host computers for exchanging router information. These include the Internet Control Message Protocol (ICMP), the Interior Gateway Protocol (IGP), the Exterior Gateway Protocol (EGP), and the Border Gateway Protocol (BGP).","Internetwork Packet Exchange (IPX) is a networking protocol from Novell that interconnects networks that use Novell's NetWare clients and servers. IPX is a datagram or packet protocol. IPX works at the network layer of communication protocols and is connectionless (that is, it doesn't require that a connection be maintained during an exchange of packets as, for example, a regular voice phone call does). Packet acknowledgment is managed by another Novell protocol, the Sequenced Packet Exchange (SPX). Other related Novell NetWare protocols are: the Routing Information Protocol (RIP), the Service Advertising Protocol (SAP), and the NetWare Link Services Protocol (NLSP).","Wireless refers to a communications, monitoring, or control system in which electromagnetic radiation spectrum or acoustic waves carry a signal through atmospheric space rather than along a wire. In most wireless systems, radio frequency (RF) or infrared transmission (IR) waves are used. Some monitoring devices, such as intrusion alarms, employ acoustic waves at frequencies above the range of human hearing.","Encryption is the conversion of data into a form, called a ciphertext, that cannot be easily understood by unauthorized people. Decryption is the process of converting encrypted data back into its original form, so it can be understood. Rivest-Shamir-Adleman (RSA) is an Internet encryption and authentication system that uses an algorithm developed in 1977 by Ron Rivest, Adi Shamir, and Leonard Adleman. The RSA algorithm is a commonly used encryption and authentication algorithm and is often included as part of a web browser. The RSA algorithm involves multiplying two large prime numbers (a prime number is a number divisible only by that number and 1) and through additional operations deriving a set of two numbers that constitutes the public key and another set that is the private key. Once the keys have been developed, the original prime numbers are no longer important and can be discarded. Both the public and the private keys are needed for encryption\/decryption but only the owner of a private key ever needs to know it. Using the RSA system, the private key never needs to be sent across the Internet. The private key is used to decrypt text that has been encrypted with the public key. Thus, if a first party sends a message to a second party, the recipient second party may be able to find out the first party's public key (but not the first party's private key) from a central administrator and encrypt a reply message back to the first party using the first party's own public key. When the first party receives the reply message, the reply message may be decrypted by the first party with the first party's private key. In addition to encrypting messages (which ensures privacy), a first party may be able authenticate themselves to second party so that the second party can confirm the identity of the first party (and thus know that it is really the first party who sent the message) by using a private key to encrypt a digital certificate. When the second party receives the encrypted digital certificate, the second party may use the first party's public key to decrypt it.","A browser is an application program that provides a way to look at and interact with all the information on the World Wide Web. The word \u201cbrowser\u201d seems to have originated prior to the Web as a generic term for user interfaces that let you browse (navigate through and read) text files online. A Web browser may be considered a client program that uses the Hypertext Transfer Protocol (HTTP) to make requests of Web servers throughout the Internet on behalf of the browser user. While some browsers also support e-mail (indirectly through e-mail Web sites) and the File Transfer Protocol (FTP), a Web browser may not be required for those Internet protocols and more specialized client programs are more popular.","A pop-up is a graphical user interface (GUI) display area, usually a small window, that suddenly appears (\u201cpops up\u201d) in the foreground of the visual interface. Pop-ups can be initiated by a single or double mouse click or rollover (sometimes called a mouseover), and also possibly by voice command or can simply be timed to occur. A pop-up window is usually smaller than the background window or interface; otherwise, it is may be called a replacement interface. On the World Wide Web, JavaScript (and less commonly Java applets) may be used to create interactive effects including pop-up and full overlay windows. A menu or taskbar pulldown can be considered a form of pop-up. So can the little message box you get when you move your mouse over taskbars in many PC applications.","Plug-in applications are programs that can easily be installed and used as part of your Web browser. A plug-in application is recognized automatically by the browser and its function is integrated into the main HTML file that is being presented.","Based on the foregoing specification, embodiments of the invention may be implemented using computer programming or engineering techniques including computer software, firmware, hardware or any combination or subset thereof. Any such resulting program\u2014having computer-readable code\u2014may be embodied or provided in one or more computer-readable media, thereby making a computer program product (i.e., an article of manufacture) implementation of one or more embodiments described herein. The computer readable media may be, for instance, a fixed drive (e.g., a hard drive), diskette, optical disk, magnetic tape, semiconductor memory such as for example, read-only memory (ROM), flash-type memory, etc., and\/or any transmitting\/receiving medium such as the Internet and\/or other communication network or link. An article of manufacture containing the computer code may be made and\/or used by executing the code directly from one medium, by copying the code from one medium to another medium, and\/or by transmitting the code over a network. In addition, one of ordinary skill in the art of computer science may be able to combine the software created as described with appropriate general purpose or special purpose computer hardware to create a computer system or computer sub-system embodying embodiments or portions thereof described herein.","Special thanks to Lynet Prum, Phnom Penh, Cambodia.","While various embodiments have been described, they have been presented by way of example only, and not limitation. Thus, the breadth and scope of any embodiment should not be limited by any of the above described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3","b":["1","4","5","7"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
