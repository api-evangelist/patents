---
title: Reliable media streaming
abstract: A reliable streaming system increases reliability of live and on-demand streaming media events through a robust server architecture that allows fast failover and recovery in the event of network, hardware, or other failures. The system provides for failover of encoders, ingest servers, which receive encoded media data from encoders, and origin servers, which serve as the retrieval point of last resort for connecting clients. The system also provides a push proxy mechanism that allows one copy of data to feed redundant servers and pre-warm caches, saving on provisioned bandwidth. In addition, the system provides a distribution server role that allows content to be automatically syndicated to a region when needed. Thus, the reliable streaming system provides a streaming solution with no single point of failure and redundancy and fast failover built into the content network architecture.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08392748&OS=08392748&RS=08392748
owner: Microsoft Corporation
number: 08392748
owner_city: Redmond
owner_country: US
publication_date: 20091103
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present application claims priority to U.S. Provisional Patent Application No. 61\/249,255 entitled \u201cRELIABLE MEDIA STREAMING,\u201d and filed on Oct. 6, 2009, which is hereby incorporated by reference.","Streaming media is multimedia that is constantly received by, and normally presented to, an end-user (using a client) while it is being delivered by a streaming provider (using a server). One problem with existing media streaming architectures is the tight coupling between server and client. A stateful connection between client and server creates additional server overhead, because the server tracks the current state of each client. This also limits the scalability of the server. In addition, the client cannot quickly react to changing conditions, such as increased packet loss, reduced bandwidth, user requests for different content or to modify the existing content (e.g., speed up or rewind), and so forth, without first communicating with the server and waiting for the server to adapt and respond. Often, when a client reports a lower available bandwidth, the server does not adapt quickly enough, causing breaks in the media to be noticed by the user on the client as packets that exceed the available bandwidth are not received and new lower bit rate packets are not sent from the server in time. To avoid these problems, clients often buffer data, but buffering introduces latency, which for live events may be unacceptable.","In addition, the Internet contains many types of downloadable media content items, including audio, video, documents, and so forth. These content items are often very large, such as video in the hundreds of megabytes. Users often retrieve documents over the Internet using HTTP through a web browser. The Internet has built up a large infrastructure of routers and proxies that are effective at caching data for HTTP. Servers can provide cached data to clients with less delay and by using fewer resources than re-requesting the content from the original source. For example, a user in New York may download a content item served from a host in Japan, and receive the content item through a router in California. If a user in New Jersey requests the same file, the router in California may be able to provide the content item without again requesting the data from the host in Japan. This reduces the network traffic over possibly strained routes, and allows the user in New Jersey to receive the content item with less latency.","Unfortunately, live media often cannot be cached using existing protocols, and each client requests the media from the same server or set of servers. In addition, when streaming media can be cached, it is often done by specialized cache hardware, not existing and readily available HTTP-based Internet caching infrastructure. The lack of caching limits the number of parallel viewers and requests that the servers can handle, and limits the attendance of a live event. The world is increasingly using the Internet to consume up to the minute live information, such as the record number of users that watched live events such as the opening of the 2008 Olympics via the Internet. The limitations of current technology are slowing adoption of the Internet as a medium for consuming this type of media content.","Moreover, reliably delivering media presentations and live events on the Internet depends on the ability to gracefully recover from errors without compromising the user experience. Current systems cannot silently absorb minor errors and glitches, and may experience catastrophic errors from which the systems cannot recover. Current systems attempt to solve these problems by over-utilizing limited or expensive resources such as bandwidth or redundant hardware.","A reliable streaming system is described herein that increases reliability of live and on-demand streaming media events through a robust server architecture that allows fast failover and recovery in the event of network, hardware, or other failures. The system includes preparation for encoder failover, including support for using intentionally short-lived connections on lossy networks. The system provides for failover of ingest servers, which receive encoded media data from encoders, and origin servers, which serve as the retrieval point of last resort for connecting clients. The system also provides a push proxy mechanism that allows one copy of data to feed redundant servers and pre-warm caches, saving on provisioned bandwidth. In addition, media data is provided by the system in well-formed fragments (e.g., chunks) that are available at well-known URLs and are cacheable by existing Internet cache infrastructure. Finally, the system provides a distribution server role that allows content to be automatically syndicated to a region when needed. Thus, the reliable streaming system provides a streaming solution with no single point of failure and redundancy and fast failover built into the content network architecture.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","A reliable streaming system is described herein that increases reliability of live and on-demand streaming media events through a robust server architecture that allows fast failover and recovery in the event of network, hardware, or other failures. The system includes preparation for encoder failover, including support for using intentionally short-lived connections on lossy networks. Some networks deprioritize long-lived connections by gradually decreasing the available bandwidth. While this may be appropriate for some network traffic, it can be particularly challenging for on-going traffic, such as a feed related to a television channel that broadcasts all the time or for long durations. The system also provides for failover of ingest servers, which receive encoded media data from encoders, and origin servers, which serve as the retrieval point of last resort for connecting clients. The system also provides a push proxy mechanism that allows one copy of data to feed redundant servers and pre-warm caches, saving on provisioned bandwidth. In addition, media data is provided by the system in well-formed fragments (e.g., chunks) that are available at well-known URLs and are cacheable by existing Internet cache infrastructure. Finally, the system provides a server role called a distribution server that allows content to be automatically syndicated to a region when needed. Thus, the reliable streaming system provides a streaming solution with no single point of failure and redundancy and fast failover built into the content network architecture.","In some embodiments, the reliable streaming system uses a particular data transmission format between the server and client. The client requests fragments of media from a server that include a portion of the media. For example, for a 10-minute file, the client may request two-second or smaller fragments. Note that unlike typical streaming where the server pushes data to the client, in this case the client pulls media fragments from the server. In the case of a live stream, the server may be creating the media on the fly and producing fragments to respond to client requests. Thus, the client may only be several fragments behind the server in terms of how fast the server creates fragments and how fast the client requests fragments.","Each fragment contains metadata and media content. The metadata may describe useful information about the media content, such as the bit rate at which the media content was encoded, where the media content fits into a larger media element (e.g., this fragment represents offset 1:10 in a 10 minute video clip), the codec used to encode the media content, and so forth. The client uses this information to place the fragment into a storyboard of the larger media element and to properly decode and playback the media content.","Each fragment of media provided by the system is referenced by clients using a tuple of, for example, publishing point path, track name, track attributes, and fragment start time, which is represented in a URL such as: http:\/\/<publishingpointpath>\/QualityLevels(<trackattributes>\/Fragments(<trackname>=<fragmentstarttime>). To receive data from one or more data sources (which may include encoders, servers, or data insertion applications), the server can act in one of two modes for a given publishing point: 1) the server can listen for \u201cpush\u201d connections on a URL (e.g., http:\/\/<publishingpointpath>\/Streams(<uniqueid>)) where data is delivered using an HTTP POST, or 2) the server can \u201cpull\u201d data from other servers using an HTTP GET. The use of fragments and URL references facilitates mechanisms that can locate fragments across a redundant server topology.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1","b":["100","105","150","145","105","110","115","120","125","130","135"]},"The server role component  receives configuration information that defines a particular server's role in a content network and prepares the server to carry out that role. For example, a particular server may act as an ingest server that receives data from one or more encoders, an origin server that provides a point of contact for clients to receive media fragments, or a distribution server that is part of a regional cache of media fragments. Each of these server roles is described further herein.","The encoder interface component  provides an interface between the system  and one or more encoders that provide encoded media data. The encoders may push data to the system  using common network protocols. For example, the encoders may use an HTTP POST request to provide encoded media data to the system . The encoders may each use a distinguished URL that specifies the encoder that is the source of the encoded media data, which the server may match to the information received by the register event component  when the media event was registered.","The encoder interface component  may specify a particular format for received encoded media data, such as an MP4 or other media container (e.g., MKV). The MP4 container format allows multiple types of data to be associated in a single file. The individual data that makes up an MP4 container is called a box, and each box typically has a label that identifies the type of data stored in the box. Encoders may place metadata information in the boxes such as the type of encoding used to encode the encoded media data, as well as the encoded media data itself.","The system  may configure encoders to lower overall latency produced by the system. For example, the system  may configure encoders not to include B-frames in streams so that the decoder can more quickly decode frames without waiting for subsequent frames to which B-frames would refer. In addition, the system  may instruct encoders to produce fragments that include less than a whole GOP, so that the encoder can push fragments to the server  more quickly.","The index fragment component  creates and maintains an index table of fragments received from various encoders. Because the system  is receiving media fragments on an on-going basis during an event from potentially many encoders, the system  uses the index table to keep track of what media fragments have been received and from which encoders (or in which formats). Each encoder may use a common method for identifying media fragments (e.g., a time stamp using a synchronized clock) so that the index fragment component  can correlate fragments from different encoders that represent the same period in a live event. In this way, the system  can detect when media fragments are missing and can provide clients with manifest information about available media fragments.","The fragment data store  stores received media fragments and the created index table of fragments to provide to clients in response to received client requests. The fragment data store may include a database, disk drive, or other form of data storage (e.g., a Storage Area Network (SAN) or a cloud-based storage service).","The client interface component  receives client requests for media fragments and provides manifest data and media fragments to clients. When a client initially connects to the system , the client may send a request for a client manifest. The client interface component  invokes the build client manifest component  to create a manifest that includes information about the encodings available from the system , and fragments stored by the system  up to the current time based on the index table. The client can use this information either to begin requesting ongoing live fragments, or to skip backwards in time to earlier portions of a presentation. The client can use this technique, for example, if the client joins a live event that is already in progress and wants to catch up with the previous portions of the event.","The build client manifest component  builds a manifest to satisfy a client request that includes information about each of the encodings available from the system  and fragments stored by the system  up to the current time. The build client manifest component  also provides a manifest to include with each media fragment that provides information to the client about the current media fragment as well as potentially subsequent fragments. By combining the initially received manifest with subsequent manifests provided with each media fragment, the client can build an up to date manifest that includes complete information about the media event from the start up until the current time. When the media event completes, the client has a complete storyboard of the media event that the client can use for on-demand viewing of the media event.","In some embodiments, the client interface component  responds to client requests for available fragments without waiting for subsequent fragments from which to include information with the current fragment. The client can request subsequent fragments by referencing the current fragment. For example, if the client last requested a fragment at time , and wants the subsequent fragment, the client may send a request to get the fragment following the fragment at time . In this way, the server can send fragments without introducing additional latency by waiting for subsequent fragments before sending a fragment.","The client  includes a chunk request component , a chunk parsing component , a manifest assembly component , and a media playback component . Each of these components is described in further detail herein.","The chunk request component  makes requests from the client for individual media chunks from the server. As shown in , the client's request may pass first to an edge server (e.g., an Internet cache), then to an origin server, and then to an ingest server. At each stage, if the requested data is found, then the request does not go to the next level. For example, if the edge server has the requested data, then the client receives the data from the edge server and the origin server does not receive the request. Each chunk may have a URL that individually identifies the chunk. Internet cache servers are good at caching server responses to specific URL requests (e.g., HTTP GET). Thus, when the first client calls through to the server  to get a chunk, the edge servers cache that chunk and subsequent clients that request the same chunk may receive the chunk from the edge server (based on the cache lifetime and server time to live (TTL) settings). The chunk request component  receives the chunk and passes it to the chunk parsing component  for interpretation. The chunk request component  may request chunks by referencing a previous chunk (e.g., give me the chunk after chunk N).","The chunk parsing component  interprets the format of a media chunk received by the chunk request component  and separates the chunk into its component parts. Typically, the chunk includes a header portion containing metadata, and a data portion containing media content. The chunk parsing component provides the metadata to the manifest assembly component  and the media content to the media playback component . The media content may include mixed media types, such as video and audio data related to a presentation.","The manifest assembly component  builds a manifest that describes the media element to which received media content belongs. Large media files that clients download as a whole (i.e., not streamed) often include a manifest describing the whole file, the codecs and bit rates used to encode various portions of the file, markers about meaningful positions with the file, and so forth. During streaming, particularly live content, a server  cannot provide a complete manifest because the event is still ongoing. Thus, the server  provides as much of the manifest as it can through the metadata in the media chunks. The server  may also provide an application-programming interface (API), such as a predefined URL, for the client to request the manifest up to the current point in the media stream. This can be useful when the client  joins a live, streamed event after the event is already in progress. The manifest allows the client  to request previously streamed portions of the media element (e.g., by rewinding), and the client  continues to receive new portions of the manifest through the metadata of the streamed media chunks.","The manifest assembly component  builds a manifest similar to that available for a complete media file. Thus, as the event proceeds if the user wants to skip backwards in the media (e.g., rewind or jump to a particular position), then skip forward again, the user can do so and the client  uses the assembled manifest to find the appropriate chunk or chunks to playback to the user. When the user pauses, the system  may continue to receive media chunks (or only the metadata portion of chunks based on a distinguished request URL), so that the manifest assembly component  can continue to build the manifest and be ready for any user requests (e.g., skip to the current live position or play from the pause point) after the user is done pausing. The client-side assembled manifest allows the client  to play the media event back as on-demand content as soon as the event is over, and to skip around within the media event as it is going on.","The media playback component  plays back received media content using the client hardware. The media playback component  may invoke one or more codecs to interpret the container within which the media content is transported and to decompress or otherwise decode the media content from a compressed format to a raw format (e.g., YV12, RGBA, or PCM audio samples) ready for playback. The media playback component  may then provide the raw format media content to an operating system API (e.g., Microsoft DirectX) for playback on local computer system sound and video hardware, such as a display and speakers. The server  can influence latency on the client  by the encoding used. For example, encodings that include B-frames may cause the client to buffer received data longer before playing it back. By encoding video data without B-frames, the server can cause the client to playback video with less latency.","The computing device on which the system is implemented may include a central processing unit, memory, input devices (e.g., keyboard and pointing devices), output devices (e.g., display devices), and storage devices (e.g., disk drives or other non-volatile storage media). The memory and storage devices are computer-readable storage media that may be encoded with computer-executable instructions (e.g., software) that implement or enable the system. In addition, the data structures and message structures may be stored or transmitted via a data transmission medium, such as a signal on a communication link. Various communication links may be used, such as the Internet, a local area network, a wide area network, a point-to-point dial-up connection, a cell phone network, and so on. A \u201ccomputer-readable storage device\u201d, as used herein, encompasses statutory storage devices and media that are common in the art and does not include non-statutory transmission media or data signals.","Embodiments of the system may be implemented in various operating environments that include personal computers, server computers, handheld or laptop devices, multiprocessor systems, microprocessor-based systems, programmable consumer electronics, digital cameras, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and so on. The computer systems may be cell phones, personal digital assistants, smart phones, personal computers, programmable consumer electronics, digital cameras, and so on.","The system may be described in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other devices. Generally, program modules include routines, programs, objects, components, data structures, and so on that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 2","b":["210","240","270","220","230","220","230","220","230"]},"The content delivery network , where the reliable streaming system operates, includes one or more ingest servers , one or more origin servers , and zero or more distribution servers . The ingest servers  receive encoded media in each of the encoding formats from the encoders  and create a manifest describing the encoded media. The ingest servers  may create and store the media fragments described herein or may create the fragments on the fly as they are requested. The ingest servers  can receive pushed data, such as via an HTTP POST, from the encoders , or via pull by requesting data from the encoders . The encoders  and ingest servers  may be connected in a variety of redundant configurations. For example, each encoder may send encoded media data to each of the ingest servers , or only to one ingest server until a failure occurs. The origin servers  are the servers that respond to client requests for media fragments. The origin servers  may also be configured in a variety of redundant configurations. Distribution servers  provide regionally distributable caches that can be prepared for a particular media event, such as a live performance.","In some embodiments, the ingest servers  comprise one or more servers dedicated to ingesting encoder media streams. An administrator or content author may create a publishing point that defines a URL at which clients of the ingest servers  can find a particular media element (e.g., a live event). For example, using IIS, the administrator may publish a URL \u201chttp:\/\/ingserver\/pubpoint.isml.\u201d The publishing point is used by the encoders  to provide new media data to the ingest servers  and by the origin servers  to request media data from the ingest servers . Each encoder may use a distinguished URL to connect to the ingest servers  so that the ingest servers  can detect different encodings of the same data. For example, based on the URL in the previous example, an encoder may send an HTTP POST to provide media data to the ingest server using the URL \u201chttp:\/\/ingserver\/pubpoint.isml\/Streams(stream1).\u201d The ingest servers  store the received data for later retrieval by clients of the ingest servers  (e.g., the origin servers ). The POST may contain various types of media formats, such as an MP4 container. An MP4 container contains various types of information, called boxes, that are typically labeled with a four-letter code, such as \u201cftyp\u201d to describe the type of encoding used and \u201cmoov\u201d to contain audiovisual data. Whether using MP4 or other container formats, the encoder may add additional boxes or information to the stream, such as a \u201cManifestBox\u201d that contains a manifest describing the media element.","When the ingest servers  receive a request for data, the ingest servers  provide the data stored earlier. The ingest servers  may support several types of requests, including a request for encoder stream manifest that identifies the available encoder streams and a request for data from a specific stream (including portions of the stream data). The type of request may be identified by the URL of the request. For example, when the ingest servers  receive the URL \u201chttp:\/\/ingserver\/pubpoint.isml\/StreamManifest,\u201d the ingest servers  return an encoder manifest that contains identifiers for each available encoder. When the ingest servers  receives the URL \u201chttp:\/\/ingserver\/pubpoint.ism\/Streams(stream1),\u201d the ingest servers  send a corresponding media stream for the encoder associated with the identifier \u201cEncoder1\u201d in response. The response may include the MP4 data, such as the cached \u201cftyp,\u201d \u201cManifestBox,\u201d and \u201cmoov\u201d boxes described above followed by media fragments in a FIFO buffer. The ingest servers  may also receive partial data requests (e.g., during failover scenarios) of the form \u201chttp:\/\/ingserver\/pubpoint.ism\/Streams(stream1)\/StartTime(12345678),\u201d that cause the ingest servers  to skip sending \u201cftyp,\u201d \u201cManifestBox,\u201d and \u201cmoov\u201d boxes and to try to start from the media fragment that is closest to the specified timestamp.","The origin servers  receive requests for media streams from media clients and retrieve requested media streams from one or more ingest servers . Like the ingest servers , an administrator or content author registers a publishing point on the origin server, and then associates the ingest servers  and\/or encoder URLs with the publishing point. The origin servers  may first request (e.g., using an HTTP GET request) a manifest from the ingest servers  that describes the available streams. The origin server then submits separate requests for each encoder stream to the ingest server, and the ingest server responds with the requested media stream as received from the encoder.","The origin servers  may separately receive manifest information about the media stream and media fragments that represent parts of a larger media element being provided by the media stream. The origin servers  build an index of each fragment received from each stream based on a timestamp or other identifier provided by each encoder that allows the origin servers  to correlate data from each encoder. The origin servers  may build their own MP4 container or other storage format from the received data from which to respond to media client requests. By building a file of a known format from a live event, the origin server may be able to provide a unified download of a media file quickly after the event.","When the origin servers  receive a media client request, the origin servers  generate a client manifest by appending the index that the server has built to the static stream information received from the encoder manifest(s). If there are multiple streams, then the origin servers  merge the stream manifests into a comprehensive client manifest. This allows the client to be selective in which encoding type the client requests without obtaining further information from the origin servers . The server provides the manifest to the client using a standard response type that can be cached by existing Internet infrastructure, such as an HTTP response. Because the manifest data may change over time, the server may set a short cache timeout value (e.g., time to live (TTL)) on the manifest response.","The external network  includes edge servers  and other Internet (or other network) infrastructure and clients . When a client makes a request for a media fragment, the client addresses the request to the origin servers . Because of the design of network caching, if one of the edge servers  contains the data, then that edge server may respond to the client without passing along the request. However, if the data is not available at the edge server, then the edge server forwards the request to one of the distribution servers , which may forward the request to one of the origin servers . Likewise, if one of the origin servers  receives a request for data that is not available, the origin server may request the data from one of the ingest servers .","Distribution servers  can be used by a content network provider to protect origin servers for popular content and un-warm edge caches by consolidating requests from a particular region into one set of requests to the origin server. An origin server may periodically send data to keep a distribution server connection open to prevent sparse media data that is sent irregularly from the origin server to the distribution server from opening and closing many connections. Because distribution servers understand the content format and manifests, distribution servers can also be used to filter out malicious or erroneous requests from clients that are not valid (e.g., for fragments not identified in the manifest), further protecting origin servers.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 3","b":["310","320","330","350","310"]},"Similarly, the ingest servers  can operate in a redundant fashion. Initially, the 1st ingest server may receive all of the data and the origin servers  may receive media fragments from the 1st ingest server. The 1st ingest server may also push received fragments to the 2nd ingest server in case the 1st ingest server fails. If the 1st ingest server fails, then the 2nd ingest server can inform the active encoder or encoders to send future fragments to the 2nd ingest server, and the 2nd ingest server can continue pushing the media fragments to the origin servers . Likewise, the origin servers  can act in a redundant fashion for the next layer of the content delivery network, the distribution servers  in the diagram. The distribution servers  may initially pull data from the 1st origin server, but if the 1st origin server fails, the distribution servers  can pull data from the 2nd origin server. In this way, the network topology provides a highly redundant content delivery network with no single point of failure. In addition, administrators can dynamically add new servers to the network and assign them an appropriate role. For example, if the encoders are overloaded or are experiencing a high failure rate, then the administrator can rotate in additional encoders. As another example, if certain regions were creating a high level of demand, then the administrator could deploy additional distribution servers  or repurpose existing servers in those regions to act as distribution servers  and ease the burden on the content network.","As shown, the encoder can upload a single copy of media fragments that the ingest server can replicate to a co-located origin server or other failover servers. This saves the encoder bandwidth, as it gets the benefit of failover while uploading only one copy of the data. In addition, over a lossy encoder\/server link, it is often desirable to have an ingest server onsite with the encoder that pushes data to an origin server. This allows a complete local archive to be kept in cases of catastrophic link failure, and can leverage all server-to-server resiliency features to ensure quality of service across the connection.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 4","FIG. 3"],"b":["410","420","430"]},"Continuing in block , the system determines that at least one of the encoder, the ingest server, the origin server, or the distribution server has experienced a failure that disrupts transmission of the media data. For example, an encoder may fail and the system may direct a second encoder to begin providing media data to the ingest server. As another example, an ingest server may fail and the system may direct a second ingest server to begin providing media data to origin servers. Continuing in block , the system directs a receiver of media data to retrieve the media data from a redundant server with access to the encoded media data. After block , these steps conclude.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 5","b":["510","520","530"]},"Continuing in block , the client receives the requested media fragment. For example, the client may receive a \u201c200 OK\u201d response to an HTTP GET request for the fragment that includes the data of the fragment along with any related metadata. Continuing in block , the client displays the received media fragment without interruption to the streaming media presentation. If the client is able to retry and receive the media fragment in a fast amount of time relative to the length of each fragment and the pace of the presentation, then the client will have the fragment in time to continue playing media from the fragment without any user interruption. Even though a server went down, the system is able to automatically recover without administrator intervention and with little or no interruption to clients. After block , these steps conclude.","In some embodiments, the reliable streaming system configures distribution servers to start pulling data only after requested by a client. This allows distribution servers to be prepared for heavy loads, but to avoid consuming bandwidth unless those loads occur. For example, a partner of a content provider may know that a particular movie or audio CD will be released on a particular day, and may contract for a certain level of bandwidth to be available from the content provider to support the release. The content provider can prepare a distribution server to be ready for the load in a region where the content will be released. However, if other events preempt consumers' desire for the item, the distribution server will not consume unnecessary bandwidth retrieving fragments related to the item without corresponding client requests.","In some embodiments, the reliable streaming system configures distribution servers to cache a predetermined period of media data. For example, an administrator may configure the distribution servers to cache the last N minutes of a media presentation. This may be helpful for media presentations that are expected to be viewed live or with a slight delay, but that are unlikely to be viewed after they become stale.","In some embodiments, the reliable streaming system employs smart caching technology to rotate content cached by elements of the system. For example, the reliable streaming system may work with Application Request Routing (ARR) of Microsoft IIS to discard cached media fragments that have not been requested for a certain time or that are unlikely to be requested in the future. In addition, the system may prioritize frequently requested fragments or fragments with expected high demand and keep such fragments in the cache longer.","In some embodiments, the reliable streaming system allows clients to view previously live content on-demand after the live event has concluded. The same media fragments that clients retrieved during the live event can also be retrieved by clients connecting after the event has occurred. These fragments may also be available from Internet cache servers without a particular request reaching a content network.","In some embodiments, the reliable streaming system produces segmented archives for long running media presentations by splitting the archive of media fragments along time boundaries into distinct on-demand presentations. For example, a particular media stream may run all the time (e.g., a television channel), but clients may only be allowed to skip back to view the previous two hours. The system allows this by segmenting the ongoing manifest into a new manifest or a marker in the manifest that makes the presentation appear to be only two hours long. This allows the client to display a seek bar with an appropriate duration of available past media data. In addition, the client and server may delete fragments that fall outside of the trailing archive window to recover disk space. An administrator can also segment the archive according to other criteria. For example, the administrator could carve out a particular hour of a much longer live media presentation and save the hour as a single on-demand media presentation. The server saves the appropriate media fragments and produces a manifest that corresponds to the selected hour of the presentation.","The reliable streaming system may request and receive media content in a variety of encodings. In some embodiments, the reliable streaming system uses custom MP4 boxes. The Motion Picture Experts Group (MPEG) version 4 standard provides for boxes within the format that can contain custom data. The MP4 extension is the file format commonly associated with this version of content. The system may leverage boxes to include the custom metadata and media content chunks. Other media formats provide similar customization of content within a container and may be used by the system.","In some embodiments, the reliable streaming system conforms to the guidelines of the Representational State Transfer (REST) style of software architecture for distributed hypermedia systems. One concept in REST is that an application can interact with a resource by knowing only the identifier of the resource (e.g., a URI) and the action requested (e.g., retrieval), and without knowing whether there are caches, proxies, gateways, firewalls, tunnels, or anything else between the application and the server actually holding the information. Following REST guidelines allows the system to use existing Internet infrastructure and pre-existing resource-conserving techniques such as caching. Some example REST-based principles that the system implements in some embodiments include: each URI identifies exactly one response, each URI points to a server resource that is stateless and cacheable, and each URI is intuitive and uses nouns (verbs are HTTP verbs). In particular, the system may avoid making requests using query strings and may use substantially unique keys for start times that are requested via URLs.","From the foregoing, it will be appreciated that specific embodiments of the reliable streaming system have been described herein for purposes of illustration, but that various modifications may be made without deviating from the spirit and scope of the invention. Accordingly, the invention is not limited except as by the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
