---
title: Method and apparatus for graphical data compression
abstract: A system comprising a first computer and a second computer remotely located from the first computer and in communication with the first computer via a network. The second computer comprises an encoder module which encodes and transmits a pixel color datum to the first computer. The encoder module encodes the pixel color datum by generating a bit indicative of the number of different pixel color data encoded since a datum having a same color as the pixel color datum was last encoded.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07817849&OS=07817849&RS=07817849
owner: Hewlett-Packard Development Company, L.P.
number: 07817849
owner_city: Houston
owner_country: US
publication_date: 20050818
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","NOTATION AND NOMENCLATURE","DETAILED DESCRIPTION"],"p":["This application may contain subject matter related to the commonly-assigned, co-pending application entitled, \u201cSystems and Methods of Providing Image Copy and Modify Commands to a Receiver with an Associated Display,\u201d having application Ser. No. 10\/988,776, a filing date of Nov. 15, 2004, and incorporated herein by reference.","Some electronic systems enable a computer user to view on his display images that are generated on another computer remotely located from his computer. In some such systems, graphical data generated on the remotely located computer is transmitted to the user's computer, accompanied by one or more commands. The commands cause the user's computer to modify the user's display based on the graphical data. Various data compression techniques are used to enhance the transmission efficiency of the graphical data. However, many of these techniques contain inherent problems that maintain transmission efficiency at undesirably low levels.","Certain terms are used throughout the following description and claims to refer to particular system components. As one skilled in the art will appreciate, companies may refer to a component by different names. This document does not intend to distinguish between components that differ in name but not function. In the following discussion and in the claims, the terms \u201cincluding\u201d and \u201ccomprising\u201d are used in an open-ended fashion, and thus should be interpreted to mean \u201cincluding, but not limited to. . . .\u201d Also, the term \u201ccouple\u201d or \u201ccouples\u201d is intended to mean either an indirect or direct electrical connection. Thus, if a first device couples to a second device, that connection may be through a direct electrical connection, or through an indirect electrical connection via other devices and connections.","The following discussion is directed to various embodiments of the invention. Although one or more of these embodiments may be preferred, the embodiments disclosed should not be interpreted, or otherwise used, as limiting the scope of the disclosure, including the claims. In addition, one skilled in the art will understand that the following description has broad application, and the discussion of any embodiment is meant only to be exemplary of that embodiment, and not intended to intimate that the scope of the disclosure, including the claims, is limited to that embodiment.","Described herein is a graphical data compression technique that enhances transmission efficiency over that of other electronic systems. Using this technique, colors of individual pixels that together comprise the graphical data are encoded and transmitted in a bit stream. The color of a particular pixel in the bit stream is encoded using bits that indicate when a pixel of the same color last appeared in the bit stream. Further, if the particular pixel color is immediately followed by additional pixels of the same color, these additional pixels are collectively encoded using bits that indicate the quantity of these additional pixels. The compression technique also may be applied to other, non-graphical types of data (e.g., command data).",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1","b":["10","10","30","12","25","25","30","12","25","30","12","30","35","36","32","34","35","36","12","32","32","34","36","35","12"]},"The remote computer  comprises a sender\/receiver , a mirror driver , an encoder\/cache  (e.g., encoder module), a graphics subsystem , a graphics application  and a display . Input data provided to the input device  of console  (e.g., by a user) is transferred to the sender\/receiver  via the network . The input data is transferred from the sender\/receiver  to the graphics application . In turn, the graphics subsystem  uses commands output from the graphics application  to generate or modify images on the display .","In operation, the remote computer  determines changes that occur to the images on the graphics subsystem  and forms \u201cCOPY\u201d and \u201cMODIFY\u201d commands or other types of commands, stores such commands in a plurality of command buffers (not specifically shown), and transmits the commands from the command buffers to the console  when appropriate. Further information on COPY and MODIFY commands, as well as other commands that may be used to manipulate graphical data, may be obtained from the commonly-owned, co-pending application entitled, \u201cSystems and Methods of Providing Image Copy and Modify Commands to a Receiver with an Associated Display,\u201d having an application Ser. No. 10\/988,776 and a filing date of Nov. 15, 2004. The console  executes the commands and implements the changes defined by the commands on the display . Once the console  has executed all of the commands provided to it by the remote computer , the console  submits an Image Update Request (IUR) across the network  to the remote computer  to indicate that the console  is ready to process additional image update commands, if any are left to be performed. In response, the remote computer  may then send more COPY and MODIFY commands to the console . The process repeats as the console  implements changes to the images shown on display  to replicate the images generated by the remote computer's graphics subsystem  as shown on display .","The graphics application  running on the remote computer  comprises any one of a plurality of executable programs. The graphics application  causes images to be shown on display  by providing graphic commands to the graphics subsystem . In the embodiment illustrated, the sender\/receiver  is a software application that runs on the remote computer's processor  (shown in  and discussed in detail below). The sender\/receiver  receives IURs from the sender\/receiver  over network . In response, the sender\/receiver  requests regions to be modified or copied from the mirror driver . For those regions that are to be modified, the sender\/receiver  obtains the pixel data associated with the images from the graphics subsystem . Obtaining a modify region from the graphics subsystem entails reading a graphics frame buffer in the graphics subsystem . A graphics frame buffer in the remote computer's graphics subsystem  includes pixel values that are to be applied to pixels on the display. In accordance with an embodiment of the invention, compression of pixel color information is implemented using a pixel color encoder\/cache  that helps reduce the amount of data that needs to be transmitted from sender\/receiver  to sender\/receiver  as discussed in detail further below. The mirror driver  tracks all of the regions of the display \u201csurface\u201d that have been drawn on, and the type of graphics commands along with any attributes of the graphics commands that are drawn in the region. The mirror driver  formulates COPY and MODIFY commands and loads them into at least one command buffer for subsequent use by the sender\/receiver .","Referring briefly to  in conjunction with , each of the remote computer  and console  comprises a processor , storage , and, as noted above, a graphics subsystem ,  and a display , . Each executable code, for example the graphics application , mirror driver , the sender\/receiver  and the sender\/receiver  in the illustrated embodiment, are executed by the respective processor  in that system and are stored in storage . Storage  may comprise volatile storage such as random access memory, non-volatile storage such as a hard disk drive, or a combination thereof. Each of the graphics subsystems  and  may comprise additional executable code such as application programming interfaces (APIs), graphics drivers, and one or more hardware components such as a graphics adapter. Each graphics subsystem also includes at least one frame buffer into which pixel color values are temporarily stored to render pixels on the associated display.","Referring to , remote computer  executes the graphics application  that causes images such as text, lines, etc., to be shown by the graphics subsystem  on display . Via network , the remote computer  also sends image update commands to the console . The image update commands dictate to the console  how to alter the information shown on display  so as to replicate that which is being shown on display . The input device  permits a user of the console  to effectively interact with the graphics application  as if the graphics application were being executed on the console .","In accordance with an embodiment of the invention, an encoder\/cache  as shown in  and located in the remote computer  in one embodiment, helps minimize the amount of pixel information that needs to be transmitted from the remote computer  to the console  when graphical updates occur to display . Although the present invention is concerned with minimizing the data sent from remote computer  to console , in other embodiments, the present invention can be used in systems requiring reduction in the amount of graphical information sent bidirectionally. Such a bidirectional system may require the use of an encoder\/cache  on both the remote computer  and the console , as opposed to just the remote computer .","In accordance with embodiments of the invention, a variable width coded bit stream where the smallest width is one bit is used to provide information to the console  regarding changes to the graphical screen display , so that the console  may update display  to reflect what is displayed on display . For example, a particular region of the graphical screen display  may have been updated, and the image on the display  may need to be updated accordingly. To provide the console  with the graphical data necessary to update the display , the variable width bit stream is sent from the remote computer  to the console . As previously described, colors of individual pixels that together comprise the graphical data are encoded using the encoder\/cache  and are transmitted in the bit stream. The color of a particular pixel in the bit stream is encoded using bits that indicate when a pixel of the same color last appeared in the bit stream. Further, if the particular pixel color is immediately followed by additional pixels of the same color, these additional pixels are collectively encoded using bits that indicate the quantity of these additional pixels.","The data compression technique may be used in conjunction with a variety of commands (e.g., the MODIFY command) comprising graphical data parameters, which graphical data parameters are intended to update only a portion of the display . The data compression technique also may be used when transmitting streams of graphical data that are used to update some or all of the display . The scope of disclosure is not, however, solely limited to compression of graphical data and may be used to compress non-graphical data as well.  is now used to describe this graphical data compression technique in general terms. Shown in  is an image , which may be displayed on, for instance, one or both of the displays , . The image  is made up of multiple horizontal rows (not specifically shown). The image  has dimensions of 16 pixel rows by 16 pixel columns. Shown in the image  is a capital letter \u201cH.\u201d Assume for purposes of explanation that the letter H is colored black, and the remainder of the image  (i.e., the background) is white. Further, as shown, the shortest distance from the left edge  of the image  to the left edge  of the letter \u201cH\u201d is 3 pixels. The distance from the left edge  of the letter \u201cH\u201d to an intermediate edge  of the letter \u201cH\u201d is 2 pixels. Similarly, the distance from the intermediate edge  to another intermediate edge  of the letter \u201cH\u201d is 6 pixels. The distance from the intermediate edge  to the right edge  of the letter \u201cH\u201d is 2 pixels. Finally, the distance from the right edge  of the letter \u201cH\u201d to the right edge  of the letter \u201cH\u201d is 3 pixels.","Any pixel row of the image  that falls into the region indicated by \u201c\u201d in  may be encoded using the graphical data compression technique as follows: first, a color code indicating a white pixel is sent from the remote computer  to the console , followed by a code indicating that the white pixel is to be repeated 2 additional times. In this way, the console  produces 3 white pixels on the display  to represent the region between edges  and . The remote computer  then transmits a color code indicating a black pixel to the console , followed by a code indicating that the black pixel is to be repeated once. As such, the console  produces 2 black pixels on the display  to represent the region between edges  and . However, because the 6 pixels following the 2 black pixels are white, and further because white pixels already have been transmitted, the compression technique further comprises sending a code indicating the last time a white pixel appeared in the bit stream, followed by a code indicating that the white pixel is to be repeated an additional 5 times. Specifically, the code indicates that only one color (i.e., the 2 black pixels used to represent the region between edges  and ) has been transmitted since the last time a white pixel was transmitted (i.e., the 3 white pixels used to represent the region between edges  and ). In this way, the console  produces 6 white pixels on the display  to represent the region between edges  and . Because no code explicitly specifying a white pixel is sent, transmission efficiency is improved, since the code used to indicate the last appearance of a white pixel in the bit stream is smaller in size than a code explicitly indicating a white pixel.","Similarly, although 2 black pixels follow the 6 white pixels, because black pixels already have appeared in this bit stream, the remote computer  sends to the console  a code indicating the last time a black pixel appeared in the bit stream, followed by a code indicating that the black pixel is to be repeated an additional 1 time. In this way, the console  produces 2 black pixels on the display  to represent the region between edges  and . Because no code explicitly specifying a black pixel is sent, transmission efficiency is improved, for reasons described further below. This process continues until all the pixels in the pixel row being transmitted have been sent to the console . A similar process is repeated for all of the pixel rows of the image, thus generating the letter \u201cH\u201d on the display .","Pixels in bit streams are encoded by the encoder\/cache  prior to transmission from the remote computer  to the console . Pixels are encoded by the encoder\/cache  on an individual basis but may be grouped into larger units called \u201cblocks,\u201d as described below. Each block is a 16 pixel by 16 pixel square, thus comprising a total of 256 pixels.  shows the operation of the encoder\/cache  in detail. Encoded\/cache  comprises a cache , an \u201cupdate cache entries\u201d (UCE) module , a counter , a comparator module  and a coder module . The contents of the cache  are described first, followed by the general operation of the encoder\/cache .","The cache  comprises a data structure having a plurality of entries, such as illustrative entry . Entry  may comprise four fields: a \u201cPixel Color RGB\u201d field that describes pixel colors, a \u201cRecently Used\u201d field that describes whether the color indicated in the Pixel Color RGB field has been used within the last pixel block, an \u201cActive Entry\u201d field that indicates whether entry  is valid, and a \u201cLeast Recently Used\u201d (LRU) field that indicates how recently the color indicated by the Pixel Color RGB field was encoded in the bit stream. In some embodiments, the LRU field of an entry may be an index field used to describe the location of the entry in relation to the other entries in the cache . The most recently used entry is on the \u201ctop\u201d of the cache , while the least recently used entry is on the \u201cbottom\u201d of the cache . In the case shown in the figure, the entry  is the most recently used entry, since it is on the top of the cache , and thus the LRU field of the entry  indicates an index of \u201c0.\u201d","The Pixel Color RGB field comprises three numbers that range from 0 to 15. One of the three numbers corresponds to \u201cRed,\u201d while a second of the three numbers corresponds to \u201cGreen\u201d and the third number corresponds to \u201cBlue,\u201d thus forming the acronym \u201cRGB.\u201d The shade of each of the three aforementioned colors is indicated by the number corresponding to that color. A variety of colors can be created by mixing different shades of the colors red, green and blue. For example, a dark shade of blue can be described with a \u201c15, \u201d whereas a light shade of blue is described with a \u201c0.\u201d A medium-shade of blue may be described with a \u201c7\u201d or an \u201c8.\u201d Similarly, a dark shade of red can be described with a \u201c15, \u201d and a light shade of red can be described with a \u201c0, \u201d while a mildly light shade of red can be described with a \u201c3.\u201d","In this way, each of the three colors can be assigned different shade numbers to produce one of 4,096 different combinations of numbers. Each combination produces a different color, or at least a different shade of a single color. For example, a combination of \u201c0 0 0\u201d might produce a deep black, while a combination of \u201c15 15 15\u201d might produce a brilliant white, both of which are obviously different colors. However, a combination of \u201c15 14 15\u201d still may produce white, albeit slightly darker than the combination \u201c15 15 15.\u201d In this way, various combinations may be created to produce various colors. Accordingly, the Pixel Color RGB field is used to describe a color associated with the entry . For instance, if the entry  is associated with a very light green, then the Pixel Color RGB field for entry  may contain the combination \u201c0 1 0.\u201d In at least some embodiments, each specific value from 0-15 may be represented in the Pixel Color RGB field with a 12-bit combination. For example, the combination \u201c0 0 0\u201d may be represented by \u201c0000 0000 0000.\u201d","As mentioned above, in some embodiments, although pixels are steadily processed in a bit-stream, the pixels may be considered to be processed in 256-pixel blocks. Pixels are considered to be processed in 256-pixel blocks for purposes of cache  upkeep\/maintenance. The Recently Used field indicates whether the entry  (i.e., the color indicated in the Pixel Color RGB field) has been used in the most recently processed 256-pixel block. If the color\/entry  has been used in the most recent pixel block, the Recently Used field comprises a \u201c1.\u201d Conversely, if the color\/entry  has not been used in the most recent pixel block, the Recently Used field comprises a \u201c0.\u201d In this way, after a complete 256-pixel block has been processed by the encoder\/cache , entries in the cache  that have not been used and that may be wasting cache space can be deactivated and\/or deleted by a process known as \u201cpruning,\u201d described further below.","An entry, such as entry , is activated or deactivated based on the status of the Active Entry field. If the Active Entry field comprises a \u201c1,\u201d then the entry is active (i.e., valid) and can be used by the remainder of the encoder\/cache . Conversely, if the Active Entry field comprises a \u201c0,\u201d then the entry is inactive (i.e., invalid) and may not be used by the encoder\/cache .","Referring again to all portions of the encoder\/cache , a pixel color that is to be encoded by the encoder\/cache  arrives in the encoder\/cache  via connection  as part of a bit stream. The pixel color is routed to the UCE module  via connections , . The pixel also is routed to the cache  via connections , , and to the comparator  via connections , . The pixel also is routed to the coder  via connection .","Upon receiving a pixel, the comparator  compares the pixel color to entries in the cache  (described in detail further below). If the comparator  finds a match, or a \u201chit,\u201d in the cache , then the comparator  asserts the HIT connections , . The comparator  also sends an indication as to the location of the matching color in the cache  via LRU connections , . Upon receiving the HIT signal via connection  and the LRU signal via connection , the UCE module  updates the cache  via connection . The UCE module  uses the LRU signal received from the comparator  via connection  to locate the entry having a LRU field that corresponds to the LRU signal. For example, if the LRU signal received via the connection  indicates a location of \u201c5,\u201d then the UCE module  finds an entry having an LRU index of \u201c5\u201d and moves this entry to the top of the cache .","If the comparator  compares the received pixel color to the cache  and does not find a hit (i.e., a \u201cmiss\u201d), then the UCE module  inserts the received pixel color into an entry at the top of the cache  and pushes all of the other entries down by one index position. Because in some embodiments the cache  may comprise only 17 entries, the least recently used entry positioned at the bottom of the cache  is deleted from the cache  to make space for the new cache entry.","As mentioned above, the UCE module  receives a PRUNE signal via connection . One purpose of the PRUNE signal is to remove, or at least deactivate, entries in the cache  whose pixel colors were not used in the immediately preceding block. The PRUNE signal is asserted by some logic (not shown) on the remote computer  when a full pixel block (i.e., 256 pixels) has been processed by the encoder\/cache .","When the UCE module  receives an asserted PRUNE signal, the UCE module  deactivates entries which were not used in the immediately preceding pixel block (i.e., entries having \u201c0\u201d values in corresponding Recently Used fields). Also in response to an asserted PRUNE signal, the UCE module  ensures that entries which were used in the immediately preceding pixel block (i.e., entries having \u201c1\u201d values in corresponding Recently Used fields) are kept active. The UCE module  accomplishes this by copying, for each entry in the cache , the value in the Recently Used field to the Active Entry field. Thus, if an entry was not used in the preceding block, then the \u201c0\u201d value in its Recently Used field is copied to its Active Entry field, thus deactivating the entry, or at least keeping a previously deactivated entry inactive. Similarly, if an entry was used in the preceding block, then the \u201c1\u201d value in its Recently Used field is copies to its Active Entry field, thus activating the entry, or at least keeping a previously active entry active. The Active Counter  communicates with the UCE module  via connections ,  to keep track of the number of active entries in the cache . In at least some embodiments, the Active Counter  keeps track of the number of active entries by communicating with the cache  via connections , . Further, in some embodiments, if the UCE module  receives two consecutive assertions from the PRUNE signal, then the entries in the cache  are cleared and the Active Counter  is set to \u201c0.\u201d","The coder  receives the pixel via connection , the HIT signal via connection , the location signal via connection , and an indication as to the number of active entries in the cache  via connection . Using this information, the coder  generates a bit pattern to represent the pixel color received via connection  (i.e., encodes the pixel color). The coder  can encode the pixel color using any suitable coding syntax. One such encoding syntax is now presented, followed by an example of how the encoding syntax may be implemented.","As previously mentioned, data encoded by the coder  is encoded in blocks. For graphical data, each block may comprise 256 pixels, although the scope of disclosure is not limited as such. Command data, which causes the console  to use the graphical data to generate images on the display , is also sent in blocks. The start of a block is marked by a single bit. A \u201c0\u201d bit indicates that the block is a block of pixels. A \u201c1\u201d bit indicates that the block is a block of commands.","In a pixel block, each of the 256 pixels is separately encoded, unless a particular pixel is repeated (i.e., is followed by additional pixels of the same color as the particular pixel). In case of repeated pixels, the particular pixel and the pixels of the same color that follow the particular pixel are encoded together into a single code. The syntax used to encode a pixel or pixels depends on a variety of factors, such as the number of entries in the cache , the position of the pixel color in the cache , the number of repeated pixels, etc. In general, a code used to represent a single pixel has the format:\n\n[Initial pixel code] [Index] [Number of repetitions]\n\nwhere the [Index] portion is optional in some cases. The [Initial pixel code] and [Index] portions of the code are generated by the coder  and indicate the location of a corresponding pixel in the cache . The [Number of repetitions] portion of the code is generated by a separate counting logic (not specifically shown) external to but associated with the encoder\/cache . The [Number of repetitions] portions of the code indicates the number of times the pixel is to be repeated, as described in detail below.\n","This separate counting logic receives, via connection , each pixel that the encoder\/cache  receives. The separate counting logic comprises a counter that is incremented each time a pixel is received that has the same color as an immediately preceding pixel. If a pixel is received with a different color than that of the immediately preceding pixel, then the counter is deactivated and the value of the counter is used by the logic to generate the [Number of repetitions] portions of the code. The counter then is cleared and is reactivated. The syntax of the [Number of repetitions] portion of code is described further below.","In the case that a pixel color corresponds to the second-to-top entry in the cache  (i.e., an entry with a LRU field value of \u201c1\u201d), or if there is only a single color in the cache , then the pixel is encoded as:\n\n1 [Number of repetitions]\n\nwhere the \u201c1\u201d corresponds to the [Initial pixel code], and where [Number of repetitions] is generated by the separate counting logic. The optional [Index] value is omitted. In the case that a received pixel color corresponds to the top entry in the cache  (i.e., an entry with a LRU field value of \u201c0\u201d), and if there are 2 colors in the cache , then the pixel is encoded as:\n\n01 [Number of repetitions]\n\nwhere the [Index] is omitted. The previous case is encoded with an Initial Pixel Code of \u201c1, \u201d whereas the latter case is encoded with an Initial Pixel Code of \u201c01.\u201d This is because \u201c1\u201d is easier to transmit than \u201c01,\u201d and because the previous case is more common in operation than is the latter case, the \u201c1\u201d code is used in the previous case. The scope of disclosure, however, is not limited as such.\n","In the case that the cache  comprises 3 entries, a received pixel is encoded as:\n\n01 n[Number of repetitions]\n\nwhere \u201cn\u201d indicates the value of the LRU field (i.e., the index) of the corresponding cache  entry, and where [Number of repetitions] is generated by the separate counting logic using a syntax described further below.\n","In the case that the cache  comprises fewer than 6 entries, but more than 3 entries, a received pixel is encoded as:\n\n01 nn [Number of repetitions]\n\nwhere \u201cnn\u201d indicates the value of the LRU field of the corresponding cache  entry. In the case that the  comprises fewer than 10 entries but more than 5 entries, a received pixel is encoded as:\n\n01 nnn [Number of repetitions]\n\nwhere \u201cnnn\u201d indicates the value of the LRU field of the corresponding cache  entry. In the case that the cache  comprises 10 or more entries, a received pixel is encoded as:\n\n01 nnnn [Number of repetitions]\n\nwhere \u201cnnnn\u201d indicates the value of the LRU field of the corresponding cache  entry.\n","The values \u201cn,\u201d \u201cnn,\u201d \u201cnnn,\u201d and \u201cnnnn\u201d above are encoded based on the LRU field of corresponding cache  entries. For instance, for a cache  comprising 17 entries, the \u201cnnn\u201d value for a received pixel may be encoded according to the following scheme:",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"\u201cnnnn\u201d value","LRU index"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0000","0 (Most recently used)"]},{"entry":[{},"0001","2"]},{"entry":[{},"0010","3"]},{"entry":[{},"0011","4"]},{"entry":[{},"0100","5"]},{"entry":[{},"0101","6"]},{"entry":[{},"0110","7"]},{"entry":[{},"0111","8"]},{"entry":[{},"1000","9"]},{"entry":[{},"1001","10"]},{"entry":[{},"1010","11"]},{"entry":[{},"1011","12"]},{"entry":[{},"1100","13"]},{"entry":[{},"1101","14"]},{"entry":[{},"1110","15"]},{"entry":[{},"1111","16 (Least recently used)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Thus, if a received pixel value corresponds to the most recently used entry in the cache  (i.e., the entry with a LRU index of \u201c0\u201d), the received pixel is encoded as:\n\n01 0000 [Number of repetitions]\n\nwhere [Number of repetitions] is generated by the separate counting logic as described further below. Similarly, if a received pixel value corresponds to the least recently used entry in the cache  (i.e., the entry with LRU index of \u201c16\u201d), the received pixel is encoded as:\n\n01 1111 [Number of repetitions]\n\nIn addition, the UCE module  shifts the entry with LRU index \u201c16\u201d to the top position, since this entry is the most recently used entry, and the entry is reassigned a LRU index of \u201c0.\u201d\n","In the case that a received pixel value corresponds to the second-to-most recently used entry (i.e., the entry with LRU index of \u201c1\u201d), the received pixel is encoded as:\n\n1 [Number of repetitions]\n\nbecause, for efficiency reasons described above, there is no \u201cnnnn\u201d value that corresponds to an entry with LRU index \u201c1.\u201d Similar schemes may be used to represent LRU indices for \u201cn,\u201d \u201cnn,\u201d and \u201cnnn.\u201d\n","The above encoding examples assume that a received pixel has a matching entry (i.e., a \u201chit\u201d) in the cache . In the case of a miss, where the received pixel does not have a matching entry in the cache , the received pixel is encoded as follows:\n\n000 rrrrggggbbbb [Number of repetitions]\n\nwhere \u201c000\u201d is the [Initial Pixel Code], \u201crrrrggggbbbb\u201d is a specific 12-bit combination (explained above) that produces the precise color associated with the received pixel, and [Number of repetitions] is generated by the separate counting logic, as described below. The UCE module  may insert a new entry in the cache  for the new pixel color, as previously discussed.\n","A special case is present when a miss occurs for a received pixel, and the received pixel has a gray-scale color. A received pixel has a gray-scale color when the shade of each component color\u2014red, green and blue\u2014is equal. For example, a color having a RGB combination of \u201c5 5 5\u201d is a gray-scale color. Similarly, a color having a RGB combination of \u201c8 8 8\u201d is a gray-scale color. In this special case, the received pixel is encoded as:\n\n000 wwww [Number of repetitions]\n\nwhere \u201c000\u201d is the [Initial pixel code] and where \u201cwwww\u201d is the color code for the received pixel. Although the received pixel color has three components\u2014red, green and blue\u2014since these three components are all the same, it is unnecessary to encode all three components. Encoding one component is sufficient. For example, if a received pixel has a RGB combination of \u201c5 5 5,\u201d then the received pixel is encoded as:\n\n000 0101 [Number of repetitions]\n\nsince \u201c0101\u201d is the, binary representation for \u201c5.\u201d The UCE module  also inserts a new entry at the top of the cache  for the received pixel.\n","In any case, the coder  encodes pixels using the techniques described above and outputs the encoded graphical data on connections , . Specifically, the coder  outputs the [Initial pixel code] and [Index] portions of a code on the code sequence connection . In some embodiments, the code sequence connection  comprises up to 15 physical wire connections which are used as necessary to output a particular code. Because in some cases all 15 connections will not be used, the connection  is used to indicate which connections are used and which are not used.","As mentioned above, the [Number of repetitions] portion of a code is generated by the separate counting module, which is not specifically shown. The separate counting module comprises a counter and has access to the stream of pixels entering the encoder\/cache  via connection . each time a pixel is received that has the same color as an immediately preceding pixel. If a pixel is received with a different color than that of the immediately preceding pixel, then the counter is deactivated and the value of the counter is used by the logic to generate the [Number of repetitions] portions of the code. The counter then is cleared and is reactivated. In the case that the counter is \u201c0\u201d (i.e., there are no repeating pixels), the counting module generates a [Number of repetitions] code that comprises a \u201c0.\u201d In the case that the counter is \u201c1\u201d (i.e., there is one repeating pixel), the counting module generates a [Number of repetitions] code that comprises a \u201c1 0.\u201d The following table shows various numbers of repeated pixels and the corresponding [Number of repetitions] code for each:",{"@attributes":{"id":"p-0052","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Number of","[Number of"]},{"entry":["repeated pixels","repetitions] code"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","0"]},{"entry":["1","1 0"]},{"entry":["2","11 000"]},{"entry":["3","11 001"]},{"entry":["4","11 010"]},{"entry":["5","11 011"]},{"entry":["6","11 100"]},{"entry":["7","11 101"]},{"entry":["8","110 000"]},{"entry":["9","110 001"]},{"entry":["10","110 010"]},{"entry":["11","110 011"]},{"entry":["12","110 100"]},{"entry":["13","110 101"]},{"entry":["14","110 110"]},{"entry":["15","110 111"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The above [Number of repetitions] codes are used for repeating pixels. In some cases, entire rows also may be repeated. In such cases, values of 1-15 are used to indicate the number of times a row that is being encoded is to be repeated. A repeat code indicates that a current pixel is repeated until the end of the row, and then the row is duplicated the number of times specified. The repeat code is as follows:\n\n111 nnnnnnnn\n\nwhere \u201cnnnnnnnn\u201d specifies the number of times the row is to be repeated.\n",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 4","FIG. 4"],"i":["a ","b "],"b":["440","200","440","440","450","202","202","200","440","202","202","200","440"]},"The encoder\/cache  processes the block  from left to right and from top to bottom. Beginning at the upper left corner of the block , the pixel value received by the encoder\/cache  is black, since the background is black (i.e., a RGB combination of \u201c0 0 0\u201d). The comparator  does not find the pixel color \u201c0 0 0\u201d in the cache . Accordingly, the UCE module  adds the color \u201c0 0 0\u201d to the cache , as shown in . The cache  now contains 2 active colors. The output code sequence (i.e., [Initial pixel code] and [Index]) for this gray-scale color, which was not originally present in the cache , is \u201c000 0000.\u201d As seen in block  in , this color repeats 18 times, since there are 15 additional pixels on this row and 3 additional pixels on the next row that are black. Accordingly, the pixel repeat sequence (i.e., [Number of repetitions]) is \u201c11 111 00010010.\u201d","The next pixel encountered is the top portion of the \u201cC:\u201d green text in block . The green text has a RGB combination of \u201c0 8 0,\u201d but this combination is not found by the comparator  in the cache  of . Accordingly, the UCE module  adds the green color represented by RGB combination \u201c0 8 0\u201d to the cache , as shown in . The cache  now comprises 3 active colors. The output code sequence for this non-gray scale color not found in the cache  of is \u201c001 0000 1000 0000.\u201d This pixel color is repeated three times, as seen in block  of . Thus, the pixel repeat sequence is \u201c11 001.\u201d","The next pixel encountered in the block  is in the black background. The black background, as explained above, has a RGB combination of \u201c0 0 0.\u201d This combination is found in the cache  of , and the corresponding LRU value is \u201c1.\u201d Thus, the output code sequence is simply \u201c1.\u201d Upon a cache hit, the entry of the hit is moved up to the top position in the cache , and all entries above the hit are moved down one position. This shifting of entry positions is reflected in . This black pixel is repeated an additional 10 times on the current row and the following row, until the green \u201cC :\u201d text is encountered again. Accordingly, the pixel repeated sequence for these additional 10 black pixels is \u201c11 110 010.\u201d The next pixel (at location 2, 2) is \u201c0 8 0.\u201d This color is in the cache  of with the LRU value of \u201c1.\u201d The output code sequence is simply \u201c1.\u201d The encoder\/cache  continues in this manner until all pixels in the block  have been encoded.","As previously explained, both pixel blocks and command blocks may be encoded by the encoder\/cache . When received by the console , command blocks contain instructions that specify how the console  is to use the data found in pixel blocks to generate images on the display . In some embodiments, a received command block contains instructions that apply to a pixel block received before the command block is received. In other embodiments, a received command block contains instructions that apply to a pixel block received after the command block is received. Command blocks may contain any of a variety of commands, such as \u201cmove\u201d commands and \u201crepeat\u201d commands. Although the scope of disclosure is not limited to encoding such commands in any particular manner, in at least some embodiments, commands may be encoded using the following syntax:",{"@attributes":{"id":"p-0059","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Code","Action"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"000 000","Move pixel block 1 block right"]},{"entry":[{},"000 001","Move pixel block 2 blocks right"]},{"entry":[{},"000 010","Move pixel block 3 blocks right"]},{"entry":[{},"000 011","Move pixel block 4 blocks right"]},{"entry":[{},"000 100","Move pixel block 5 blocks right"]},{"entry":[{},"000 101","Move pixel block 6 blocks right"]},{"entry":[{},"000 110","Move pixel block 7 blocks right"]},{"entry":[{},"000 111","Move pixel block 8 blocks right"]},{"entry":[{},"001 xxxxxxx","Move pixel block up to 127 blocks"]},{"entry":[{},"1 xxxxxxxyyyyyyy","Move pixel block up to 127 blocks in"]},{"entry":[{},{},"either or both X, Y - directions"]},{"entry":[{},"01 100 xxxxxxx yyyyyyy","Set mode (x, y)"]},{"entry":[{},"01 101","Timeout - Close frame, ignore"]},{"entry":[{},{},"remaining bits in current byte"]},{"entry":[{},"11 nnnnnnn","Repeat block up to 127 times"]},{"entry":[{},"01 0","Repeat pixel block 1 time"]},{"entry":[{},"10 000","Repeat pixel block 2 times"]},{"entry":[{},"10 001","Repeat pixel block 3 times"]},{"entry":[{},"10 010","Repeat pixel block 4 times"]},{"entry":[{},"10 011","Repeat pixel block 5 times"]},{"entry":[{},"10 100","Repeat pixel block 6 times"]},{"entry":[{},"10 101","Repeat pixel block 7 times"]},{"entry":[{},"10 110","Repeat pixel block 8 times"]},{"entry":[{},"10 111","Repeat pixel block 9 times"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In this way, pixel blocks and command blocks are encoded on the remote computer  and are transferred to the console  via network . The console  receives the blocks and uses the command block to determine how to use the pixel block to generate or modify images on the display . Thus, an image is displayed on the display  that matches an image shown on the display .",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 6","b":["600","600","14","602","200","14","600","202","200","604","202","606","202","600","202","608","202","202","606","600","202","202","610"]},"In any case, the process  further comprises transferring data corresponding to the new or matching entry to the coder  (block ). The coder  encodes the pixel data from the corresponding new or matching entry (block ). The process then comprises using coder  to encode command data received from graphics subsystem  (block ). As previously described, the command data instructs the computer console  as to what is to be done with the graphical data transmitted immediately before or immediately after the command data. The encoded pixel data then is transferred to the console  via the network  (block ). The process  also comprises transferring encoded command data to the console  via the network  (block ). The encoded pixel and command data is then decoded on the console  (block ), and the console  uses the decoded pixel and command data to generate an image on the display  (block ). This image is identical or at least similar to the image shown on the display . The scope of disclosure is not limited to performing the steps of process  in any particular order or fashion.","The above discussion is meant to be illustrative of the principles and various embodiments of the present invention. Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a detailed description of exemplary embodiments of the invention, reference will now be made to the accompanying drawings in which:",{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 4","FIG. 3"],"i":"a "},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIGS. 4","FIG. 3","FIG. 4"],"i":["b","e ","a"],"b":"4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 5","FIG. 1"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
