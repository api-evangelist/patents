---
title: Load balancing and merging of tessellation thread workloads
abstract: In one embodiment described herein, a graphics engine with shader unit thread load balancing functionality executes shader instructions from multiple execution threads in a smaller number of execution threads by combining instructions from multiple threads at runtime. In one embodiment, multiple shader unit threads containing less than a minimum number of instructions are combined to minimize the discrepancy between the shortest and longest thread. In one embodiment, threads are merged when they contain a common output register.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09607353&OS=09607353&RS=09607353
owner: Intel Corporation
number: 09607353
owner_city: Santa Clara
owner_country: US
publication_date: 20150218
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["The present patent application is a Continuation application claiming priority from application Ser. No. 13\/631,865, filed Sep. 29, 2012, titled \u201cLOAD BALANCING AND MERGING OF TESSELLATION THREAD WORKLOADS,\u201d and now issued as U.S. Pat. No. 8,982,124, which is incorporated herein by reference in its entirety.","The described embodiments are generally related to the field of computer graphics. More particularly, embodiments relate to the load balancing and merging of computer graphics shader core workloads.","Three Dimensional (3D) models with low geometric detail may not fully convey the desired complexity of a 3D object. Higher detailed objects with a larger number of smaller polygons and an increased number of vertices are better suited for use in certain scenarios. However, using a finely detailed object defined by a larger number of vertices requires a larger amount of system resources than a coarsely detailed object. Accordingly, as the number of polygons and vertices increases in accordance with higher geometric detail, the 3D graphics engine will approach the limit of available processing capability and system bandwidth.","Graphics engines featuring support for hardware accelerated tessellation provide one solution by allowing the creation of geometrically complex 3D objects for use in the final 3D scene while storing and animating less complex objects using a relatively low number of polygons. Coarse geometric models are stored and animated, then the polygons of the geometric model are increased in detail by subdividing the polygons into smaller, more finely detail polygons during the rendering of the final 3D object, allowing an adaptable level of geometric detail. Hardware accelerated tessellation can be accomplished utilizing small programs known as \u201cshaders\u201d that execute on the graphics engine. Graphics applications generally supply shader programs in a high level language, along with polygons, textures, and other object data, as defined by one or more published Application Programming Interface (API). Such high level shaders are not hardware specific, so manufacturers of graphics hardware provide functionality to convert high level shader input into low level commands tailored for specific hardware. In some instances those commands are run in parallel on the graphics hardware when multi-threaded shader execution is supported.","Modern graphics engines utilize multiple parallel processors referred to as \u201cshader cores\u201d to execute multiple simultaneous threads of shader instructions. As high level shader programs are converted into low level commands, hardware specific optimizations are often included into the programs to better utilize the features of specific graphics hardware. Some graphics engines are designed explicitly to perform a large number of parallel operations using a larger number of shader cores, each executing a small number of instructions, while other graphics engines feature a smaller number of relatively more powerful shader cores capable of performing a larger number of instructions per core.","Described herein are embodiments of a graphics engine with shader unit thread load balancing functionality that performs runtime merging of multiple execution threads. Hardware accelerated tessellation functionality is implemented utilizing programmable pipeline stages that allow custom, runtime configuration of graphics hardware utilizing programs compiled from a high level shader language that are executed using one or more shader execution cores. In one embodiment, the programs are executed in a multi-threaded manner and the graphics engine driver software balances the size and number of threads dispatched to the shader cores to enhance system performance.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"b":["100","100","170","180","150","170","180","172","182","170","176","178","180","186","188","170","180","150","178","188","172","182","132","134","133"]},"Processors ,  exchange information with a chipset  via individual P-P interfaces ,  using point to point interface circuits , , , . Chipset  may optionally exchange information with the coprocessor  via a high-performance interface . In one embodiment, the coprocessor  is a special-purpose processor, such as high-throughput Many Integrated Core (MIC) processor, a graphics engine, or the like. A shared cache (not shown) is included in both processors and optionally, outside of both processors and connected with the processors via P-P interconnect, such that either or both processors' local cache information is stored in the shared cache if a processor is placed into a low power mode.","Chipset  is coupled to a first bus  via an interface . In one embodiment, first bus  is a Peripheral Component Interconnect (PCI) bus, or a bus such as a PCI Express bus or another third generation I\/O interconnect bus, although the scope of the present invention is not so limited. As shown in , various I\/O devices  are coupled to first bus , along with a bus bridge  which couples first bus  to a low pin count bus . In one embodiment, one or more additional processor(s)  (e.g. MIC processors, graphics engines, Digital Signal Processors) are coupled to first bus . Various devices couple to the low pin count bus  including a keyboard and\/or mouse , communication devices  and a storage unit  such as a disk drive or other mass storage device which includes instructions\/code or data . Further, an audio I\/O  can couple to the second bus . Note that other architectures are possible. For example, instead of the point-to-point architecture of , a system can implement a multi-drop bus or other such architecture.","Each of the processors  and  are some version of the processor  of , which shows a block diagram of a processor  that has one or more cores and an optional integrated memory controller and integrated graphics. The solid lined boxes in  illustrate a processor  with a single core A, a system agent , a set of one or more bus controller units , while the optional addition of the dashed lined boxes illustrates an alternative processor  with multiple cores A-N, a set of one or more integrated memory controller unit(s)  in the system agent unit , and special purpose logic .","Different implementations of the processor  include: 1) a CPU with the special purpose logic  being integrated graphics and\/or scientific (throughput) logic (which includes one or more cores), and the cores A-N being one or more general purpose cores (e.g., general purpose in-order cores, general purpose out-of-order cores, a combination of the two); 2) a coprocessor with the cores A-N being a large number of special purpose cores for graphics and\/or scientific calculations; and 3) a coprocessor with the cores A-N being a large number of general purpose in-order cores. Thus, the processor  can be a general-purpose processor, coprocessor or special-purpose processor, such as, for example, a network or communication processor, compression engine, graphics processor, GPGPU (general purpose graphics processing unit), a high-throughput many integrated core (MIC) coprocessor (including 30 or more cores), embedded processor, or the like. The processor can also be implemented across several chips, or entirely on one chip.","The memory hierarchy includes one or more levels of cache within the cores, a set of one or more shared cache units , and external memory (not shown) coupled to the set of integrated memory controller units . The set of shared cache units  includes one or more mid-level caches, such as level 2 (L2), level 3 (L3), level 4 (L4), or other levels of cache, a last level cache (LLC), and\/or combinations thereof. While in one embodiment a ring based interconnect unit  interconnects the integrated graphics logic , the set of shared cache units , and the system agent unit \/integrated memory controller unit(s) , alternative embodiments use any number of well-known techniques for interconnecting such units. In one embodiment, coherency is maintained between one or more cache units  and cores A-N.","The system agent  includes those components coordinating and operating cores A-N. The system agent unit  includes, for example, a power control unit (PCU) and a display unit. The PCU includes logic and components needed for regulating the power state of the cores A-N and the integrated graphics logic . The display unit is for driving one or more externally connected displays. The cores A-N can be homogenous or heterogeneous in terms of architecture instruction set. In one embodiment, cores A-N use the same instruction set. Alternatively, two or more of the cores A-N execute the same instruction set, while one or more cores execute a subset of that instruction set or a different instruction set. For example, in one embodiment, the processor  contains 4 cores A-D to execute a general purpose instruction set, and also contains core E and, optionally, core F to execute an instruction set containing graphics specific instructions.","Embodiments of the invention include implementations of the processor  coupled to special purpose logic  configured as shown in . In one embodiment, graphics logic as in  contains a ring based interconnect unit  coupled to ring based interconnect unit . Commands coming from the ring based interconnect are interpreted by a command streamer  which supplies instructions to individual components of a 3D graphics pipeline. The command streamer  directs the operation of a vertex fetcher  component which reads vertex data from memory and executes 3D vertex level commands provided by the command streamer . The vertex fetcher  provides vertex data to a vertex shader  which performs coordinate space transformation and lighting operations to each vertex. The vertex fetcher  and vertex shader  execute command threads via a thread dispatcher  to acquire and process vertex data. Dispatched commands run via one or more shader arrays ,  containing numerous special purpose cores to process commands from a programmable graphics pipeline.","The shader arrays ,  have an attached cache  which is specific for each shader array ,  or shared between the arrays. The cache can be configured as a data cache, an instruction cache, or a single cache which is partitioned to contain data and instructions in different partitions. Embodiments of the invention also feature tessellation components in the graphics pipeline to perform hardware accelerated tessellation of 3D objects. A programmable tessellation controller  and programmable tessellation evaluator  each execute one or more threads in sequence or concurrently on one or more special purpose cores contained within the shader core arrays , . The tessellation controller is programmed via a shader program referred to as a Hull Shader in the Direct3D API, or a Tessellation Control Shader in the OpenGL API. Different APIs program the tessellation controller differently, but shader programs from each API accept a group of vertices known as a \u201cpatch\u201d, which is processed to generate a set of tessellation control data and constant data. The control data is used by the tessellation evaluator  to interpret the generated vertices, while the tessellation controller  sends an output patch and patch constant data to the tessellation generator .","The tessellation generator  functions at the direction of the tessellation controller  and contains special purpose logic to generate a set of finely detailed geometric objects based on the coarse geometric model that is provided as input to the graphics pipeline. A tessellation evaluator  post-processes the set of geometric objects generated by the tessellation generator  to determine, among other things, the proper positioning coordinates for the vertices in the set of newly generated geometric objects. The tessellation evaluator  is configured by a shader program referred to as a tessellation evaluation shader program in the OpenGL API or a domain shader, as is known in the Direct3D API.","The geometric objects can then be processed by a geometry shader  via one or more threads dispatched to the shader core arrays , , or can proceed directly to the clipper . The geometry shader operates on entire geometric objects, rather than vertices or patches of vertices as in previous stages of the graphics pipeline. If the tessellation units , ,  are not enabled, the geometry shader  receives input directly from the vertex shader . The geometry shader  is programmable by a geometry shader program to perform geometry tessellation if the tessellation units are disabled; however the geometry shader lacks the special purpose logic of the tessellation generator and will not perform as efficiently in most cases. If an application is to bypass the rasterizer, and needs access to vertex data, the processed vertex data is written to one or memory buffers via a ring bus interconnect  by an output streamer . Vertex data destined for the rasterizer is then processed by a clipper , which is either a fixed function clipper or a programmable clipper with both clipping and geometry shader functions. After the clipper, vertex data is dispatched over an interconnect bus to the render output pipeline, where a rasterizer  dispatches pixel shaders to convert the geometric objects into their per pixel representations. The render output pipeline is discussed in more detail below.","One embodiment of a graphics engine contains a media engine , 2D engine , and display controller  that contains special purpose fixed function logic and operates independently of the 3D pipeline, or alternatively contain programmable elements that use the shader cores for execution. The display controller  is generally connected to a display device (not shown) which can be an integrated display device, as in a laptop computer, or an external display device attached via an external display device connector such as, for example, a display port or thunderbolt connector.","The graphics engine of  has an interconnect bus to allow data and message passing amongst the major components of the graphics engine. In one embodiment the shader core array ,  and associated caches ,  and texture sampler unit  connect to this data bus through a data port  to perform memory access and communicate with render output pipeline components of the graphics engine. The render output pipeline contains a rasterizer and depth test component  which converts vertex based objects into their associated pixel based representation. An associated render cache  and depth cache  are also available in some embodiments. A pixel operations component  is available to perform pixel based operations on the data, though in some instances, pixel operations associated with 2D operations (e.g. bit block image transfers with blending) are performed by the 2D engine , or substituted at display time by the display controller  using overlay display planes. In one embodiment a cache  is available that is shared amongst all graphics components allowing the sharing of data among graphics engine components without the use of main system memory.","Embodiments of the invention are not specific to any one application programming interface, as graphics driver software is used to translate API calls specific to one graphics library to hardware specific commands. One embodiment provides support to the Open Graphics Library supported by the Khronos Group, the Direct3D library from the Microsoft Corporation, or, in one embodiment, both OpenGL and D3D. If tessellation support using these APIs is desired, then at least OpenGL 4.0 or Direct3D 11.0 would be optimal. Future APIs with a compatible 3D pipeline would also be supported if a mapping can be made from the render pipeline of that future API to the pipeline embodied in the graphics hardware.","Tessellation as embodied operates on a group of vertices known as patches that contain a group of vertices that will be tessellated. Patches of vertices will not have an explicit or implied geometric ordering, but provide a framework from which to interpolate vertices during tessellation. The Direct3D domain shader, or OpenGL tessellation evaluation shader, then transforms the generated vertices into a polygonal form. In one embodiment, an OpenGL vertex shader provides an array of vertices, along with attributes corresponding to various output variables. The tessellation control shader will then execute for each vertex and generate two sets of data; control variables that the tessellation evaluator will use to interpret the additional vertices generated by the tessellation generator and tessellation values that the tessellation generator will use to generate new vertices.","In one embodiment, tessellation control is enabled utilizing the Direct3D API. In Direct3D, a shader program named a hull shader controls the tessellation controller  to perform the tessellation control functionality that enables the patch to be tessellated by the tessellation generator . In the hull shader program, the vertices are processed to define the control points used by the domain shader to position the generated vertices after tessellation. Additionally, the hull shader specifies the tessellation factors that define how the new vertices are generated. The Direct3D API refers to the vertices in the vertex patch as control points. These vertices are the edge points of the control polygon the domain shader uses when positioning the new vertices. In OpenGL, the equivalent of the Direct3D hull shader is the tessellation control shader.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 4","FIG. 3"],"b":["311","313","317","307","311","405","405","406","407","402","410","411","313","317"]},"The tessellation generator  generates new vertices by creating new primitives inside of the patch of vertices. In one embodiment, triangles, quads (e.g. rectangles and squares), or lines can be drawn within the vertex patch and then new vertices are generated by subdividing the polygons to make new, smaller polygons. New vertices are then interpolated based on the smaller polygons. For example, a patch containing four vertices can be drawn as a quad primitive, and then subdivided into two triangles. Those two triangles are then subdivided into smaller triangles based on the tessellation factors. Alternately, a quad can be subdivided by a tile of smaller quads. Numerous configurations are possible. The inner tessellation factor controls the number of primitives that are generated within the patch of vertices, and the outer tessellation level controls the number of times to subdivide along the edge of the vertex patch. The vertices generated by the tessellation generator are based on the vertex patch, without regard to the larger set of vertices in the geometric object. The output control points  define how the tessellation evaluator  transforms the newly generated vertices for use within the 3D scene.","Each control point will be referenced with a control point identification number to allow the shader program to determine which control point is currently being evaluated. In one embodiment, the number of patch constant phase threads that are dispatched to hardware is runtime managed based on the current state of the graphics hardware, including, for example, the number of available shader cores and number of shader units attempting to dispatch threads to the shader cores at any one time. An additional consideration is the length and subsequent execution time of each shader thread. Generally, though not universally, the execution time of a shader thread is proportional to the number of operations to be performed within the thread. However, having to execute a multitude of very short threads can impact overall performance because of the overhead introduced with each additional thread, and because each thread used by one shader unit limits the number of free thread contexts available for other shader units. Accordingly, performance improvements can be seen when combining a large number of shorter threads into a smaller number of longer threads, as long as the individual thread size is not allowed to grow beyond a certain hardware specific threshold.","For example, if the tessellation controller dispatches enough threads to the shader array to prevent vertex shader or geometry shader operations, then overall pipeline performance can be limited. Additionally, it can be beneficial to merge operations into a common thread to exploit data parallelism via the use of Single Instruction Multiple Data (SIMD) operations. SIMD operations can perform a single instruction across multiple vectors of data and allow parallel operations on information without requiring additional execution threads. The ability to limit instruction threads is desirable because the programmable elements on the data pipeline can, from time to time, attempt to dispatch more hardware execution threads to the shader array than the shader array infrastructure can allow, slowing pipeline operation speed. This is notable in the instance that numerous small threads are dispatched from multiple shader units on the data pipeline and delay the execution of larger, more critical threads. For example, if the tessellation controller dispatches enough threads to the shader array to prevent vertex shader or geometry shader operations, then overall pipeline performance can be limited.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 5","b":["501","500","502"]},"If there are no common outputs across the various threads, trigger event  occurs and the device transitions to the Instruction Length Merge  state. Alternatively, the device can merge similar length shaders and find there is still a shader length imbalance across the set of threads for a given shader unit, which will trigger transition , also to the Instruction Length Merge  state, but in that instance, the device has state information that indicates whether a common output declaration exists within the multiple threads that was not used to merge those threads, which will dictate the force merge operation in the event threads are force merged to conform to a thread limit imposed on a particular shader unit. Force merge scenarios will be discussed in further detail below.","The Instruction Length Merge  state will perform an action that merges certain threads in a set of threads to transform a shader program containing several threads with few instructions into a program with a smaller number of threads, while retaining the same functionality. If at this point the shader unit program has been merged by length, and merged or evaluated for common output declarations, and the number of threads in the program do not exceed the limit set for threads from that shader unit, trigger condition  will occur and the Instruction Length Merge  state will transition to Exit process , which continues with the shader program's execution process or evaluates a new set of threads from a different shader unit program.","In one embodiment, the number of threads that dispatch from a single shader unit can be limited dynamically by the hardware or to a value set by the graphics driver. In this embodiment, a minimum amount of thread availability is maintained to certain shader units by placing limits on other shader units, preventing a scenario where, for example, a critical calculation cannot dispatch to the shader cores due to a lack of available threads in which to execute the shader unit instructions. Threads from a shader unit can be combined so that the same instructions are dispatched in a fewer number of threads. If a shader unit max thread limit is imposed and the current number of threads exceeds the limit, condition  occurs and the device transitions to the Force Merge  super-state where, if there exists a common output among the registers that was not previously merged due to thread balance issues, state  will merge threads while disregarding shader balance issues. In this action, a hypothetical shader of 10 lines sharing a common output with a shader of 50 lines will be merged, where the Common Output Merge  state would have bypassed those shaders because of the latency hiding benefit that could have been derived. If there are no common outputs, state  combines as many shaders as possible into a smaller number of longer threads until the number of threads is below the maximum number of allowed threads for that shader unit, at which condition  will trigger a transition to Exit process .","During the execution of a 3D application utilizing shader code written in a high level language, the high level shader program is converted or assembled into one or more low level shader languages, including shader byte-code, shader assembly, or operation codes for hardware specific instructions. Assembly shader code is used as an example in the tables below; the shader assembly code illustrates the discrete phases and multi-threaded logic of a shader program. While examples of shader merge operations will be illustrated using assembly level shader code, embodiments of the invention are not limited to operating at the assembly level and may operate on other stages of execution.","A shader program for a tessellation controller (e.g. tessellation controller  of ) consists of a per-control point phase and a per-patch patch constant phase, as illustrated in . Calculations for dynamic level of detail, or other tessellation techniques or optimizations are performed in this phase, however, in some instances no computations are made, and an individual phase will pass-through input data to the appropriate output registers without making modifications.","Examples of assembly language for a tessellation control shader are shown in Tables I-IV below. Table I shows a portion of a hull shader program of Direct3D used to control the tessellation controller  of .",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE I"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Low level shader with three threads."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"101","hs_fork_phase"]},{"entry":[{},"102","dcl_input vicp[32][2].x"]},{"entry":[{},"103","dcl_output o6.x"]},{"entry":[{},"104","mov o6.x, vicp[0][2].x"]},{"entry":[{},"105","ret"]},{"entry":[{},"106","hs_fork_phase"]},{"entry":[{},"107","dcl_input vicp[32][2].y"]},{"entry":[{},"108","dcl_output o6.y"]},{"entry":[{},"109","mov o6.y, vicp[0][2].y"]},{"entry":[{},"110","ret"]},{"entry":[{},"111","hs_fork_phase"]},{"entry":[{},"112","dcl_input vicp[32][2].z"]},{"entry":[{},"113","dcl_output o6.z"]},{"entry":[{},"114","mov o6.z, vicp[0][2].z"]},{"entry":[{},"115","ret"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"In Table 1, the x, y and z components of the input control point register are addressed in parallel. In embodiments containing shader arrays with a large number of less powerful shader cores, improved performance is realized in some instances by performing as many operations in parallel as possible. For example, in Table I a first shader thread beginning on line  writes to output o6.x, a second shader thread on line  writes to output o6.y, and a third shader thread on line  writes to output o6.z. In one embodiment, more powerful shader cores with a complex instruction set are used and a single shader core is able to execute instructions faster than several less powerful shader cores. In that instance, performance improvements are seen when several threads of instructions are combined into a smaller number of threads. For example, it is possible to merge the three shader computations in Table I to output only once to o6 across channels x, y, and z. At this state this merge operation is limited to cases that will not result in widely disproportional shader lengths across a set of threads. For example, a shader with 10 instructions generally will not be merged with a shader with 50 instructions because the latency created by the output write of the shorter shader is hidden by the longer shader's additional 40 instructions. The example shader threads illustrated in Table I are similar in size and contain a common output declaration, so these threads can be merged into one thread, as demonstrated in Table II below.",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE II"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Merged low level shader with one thread."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"201","hs_fork_phase"]},{"entry":[{},"202","dcl_input vicp[32][2].xyz"]},{"entry":[{},"203","dcl_output o6.xyz"]},{"entry":[{},"204","mov o6.xyz, vicp[0][2].xyz"]},{"entry":[{},"205","Ret"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"In the shader assembly code of Table II, the instructions from the three threads shown in Table I are executed in one thread with a single set of instructions that copies three channels of the vicp input register to three channels of the o6 output register. In one embodiment, the instruction on line  will perform more efficiently than the three threads of instructions of Table I.","The above technique is limited to instances where multiple threads operate on multiple channels of the same output register. If the shader program does not contain multiple threads that write to a common output, alternate merge techniques can combine threads based on the number or type of instructions performed in each thread. For example, in one embodiment, related instructions that perform similar functionality are combined into a single thread at shader compile time, which enhances threading efficiency by grouping common operations and reducing the number of threads pending execution. Additionally, merging related instructions exposes the instructions to additional back end compiler optimizations, increasing the runtime efficiency of the compiled code. As shown in , this operation can be performed in addition to a common output merge or as an alternative to a common output merge if there are no common outputs across the various threads.","An example of a shader program with five threads is shown in Table III below. In one embodiment, three of the threads illustrated below will be combined into a single thread a by the shader compiler.",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE III"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Low level shader with five threads."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["301","hs_fork_phase"]},{"entry":["302","dcl_output_siv o0.x, finalQuadUeq0EdgeTessFactor"]},{"entry":["303","mov o0.x, cb2[4].w"]},{"entry":["304","ret"]},{"entry":["305","hs _fork_phase"]},{"entry":["306","dcl_output_siv o1.x, finalQuadVeq0EdgeTessFactor"]},{"entry":["307","mov o1.x, cb2[4].w"]},{"entry":["308","ret"]},{"entry":["309","hs_fork_phase"]},{"entry":["310","dcl_output_siv o2.x, finalQuadUeq1EdgeTessFactor"]},{"entry":["311","mov o2.x, cb2[4].w"]},{"entry":["312","ret"]},{"entry":["313","hs_fork_phase"]},{"entry":["314","dcl_output_siv o3.x, finalQuadVeq1EdgeTessFactor"]},{"entry":["315","mov o3.x, cb2[4].w"]},{"entry":["316 ","ret"]},{"entry":["317 ","hs_fork_phase"]},{"entry":["318 ","dcl_input vPrim"]},{"entry":["319","dcl_output o22.xyzw"]},{"entry":["320","dcl_temps 1"]},{"entry":["321","iadd r0.x, vPrim, cb3[0].x"]},{"entry":["322","ishl r0.x, r0.x, l(1)"]},{"entry":["323","id_indexable(buffer)(uint,uint,uint,uint) r0.xyzw, r0.xxxx, t0.xyzw"]},{"entry":["324 ","iadd r0.xyzw, r0.xyzw, l(\u22123, \u22123, \u22123, \u22123)"]},{"entry":["325 ","mov o22.x, cb0[r0.x + 1024].x"]},{"entry":["326","mov o22.y, cb0[r0.y + 1024].x"]},{"entry":["327 ","mov o22.z, cb0[r0.z + 1024].x"]},{"entry":["328","mov o22.w, cb0[r0.w + 1024].x"]},{"entry":["329","ret"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In Table III, on lines , , , and , four shader threads each declare a separate output register that contains an edge tessellation factor system-value parameter. This shader program sets different edge tessellation factors in different output registers in each thread. The threads do not share an output register utilizing different component masks, so cannot be merged by a common output. However, their operations can be combined into a single thread without exceeding the length of the longest thread, which begins on line . In one embodiment, outputs to registers containing related system variables that occur across multiple threads are grouped and executed as a single thread. An example of an assembly shader program demonstrating the executed logic after shader instruction merging is illustrated in Table IV.",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE IV"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Merged low level shader with two threads."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["401","hs_fork_phase"]},{"entry":["402","dcl_output_siv o0.x, finalQuadUeq0EdgeTessFactor"]},{"entry":["403","dcl_output_siv o1.x, finalQuadVeq0EdgeTessFactor"]},{"entry":["404","dcl_output_siv o2.x, finalQuadlUeq1EdgeTessFactor"]},{"entry":["405","dcl_output_siv o3.x, finalQuadVeq1EdgeTessFactor"]},{"entry":["406","mov o0.x, cb2[4].w"]},{"entry":["407","mov o1.x, cb2[4].w"]},{"entry":["408","mov o2.x, cb2[4].w"]},{"entry":["409","mov o3.x, cb2[4].w"]},{"entry":["410","ret"]},{"entry":["411","hs_fork_phase"]},{"entry":["412","dcl_input vPrim"]},{"entry":["413","dcl_output o22.xyzw"]},{"entry":["414","dcl_temps 1"]},{"entry":["415","iadd r0.x, vPrim, cb3[0].x"]},{"entry":["416","ishl r0.x, r0.x, l(1)"]},{"entry":["417","id_indexable(buffer)(uint,uint,uint,uint) r0.xyzw, r0.xxxx, t0.xyzw"]},{"entry":["418","iadd r0.xyzw, r0.xyzw, l(\u22123, \u22123, \u22123, \u22123)"]},{"entry":["419","mov o22.x, cb0[r0.x + 1024].x"]},{"entry":["420","mov o22.y, cb0[r0.y + 1024].x"]},{"entry":["421","mov o22.z, cb0[r0.z + 1024].x"]},{"entry":["422","mov o22.w, cb0[r0.w + 1024].x"]},{"entry":["423","ret"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In the shader program with merged threads illustrated in Table IV, the edge tessellation value writes are all grouped into a single thread, as opposed separate, smaller threads. Additionally, the four merged threads do not exceed the length of the longest thread in the program, which begins on line ",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 6","b":["610","650","612","634","616","620","622"]},"In one embodiment, the operating system  is a Microsoft Windows operating system from the Microsoft Corporation or, alternately, is a UNIX based operating system. When utilizing the Direct3D API, the operating system  contains a front end shader compiler  to convert shaders written in a high level shader language to shaders represented by a low level shader language. In one embodiment, however, the OpenGL API is enabled, which passes the high level shader directly to the user mode graphics driver  which is capable of performing high level shader compilation. The user mode graphics driver  contains a back end shader compiler  to convert the shader code into a hardware specific representation. In one embodiment, the methods discussed above are implemented in the user mode graphics driver , or back end shader compiler  as appropriate under the circumstances, depending on the capability or configuration of the graphics engine. Embodiments of the processor with integrated graphics  can also perform the thread management logic within the graphics pipeline hardware or microcode.","The user mode graphics driver uses OS kernel mode functions  to communicate with a kernel mode graphics driver , and the kernel mode graphics driver  communicates with a processor which, in one embodiment, is a processor with integrated graphics  which contains general purpose processor cores  and graphics specific shader execution cores . In the alternative, a discrete, non-integrated graphics core attached to the processor via a bus is also possible. In one embodiment, all or part of the threading enhancement logic is implemented in one or more of the graphics specific shader cores , or within the thread dispatch logic  of the graphics engine , as illustrated in .","To the extent various operations or functions are described herein, they can be described or defined as hardware circuitry, software code, instructions, configuration, and\/or data. The content can be embodied in hardware logic, or as directly executable software (\u201cobject\u201d or \u201cexecutable\u201d form), source code, high level shader code designed for execution on a graphics engine, or low level assembly language code in an instruction set for a specific processor or graphics core. The software content of the embodiments described herein can be provided via an article of manufacture with the content stored thereon, or via a method of operating a communication interface to send data via the communication interface. A non-transitory machine readable storage medium can cause a machine to perform the functions or operations described, and includes any mechanism that stores information in a form accessible by a machine (e.g., computing device, electronic system, etc.), such as recordable\/non-recordable media (e.g., read only memory (ROM), random access memory (RAM), magnetic disk storage media, optical storage media, flash memory devices, etc.). A communication interface includes any mechanism that interfaces to any of a hardwired, wireless, optical, etc., medium to communicate to another device, such as a memory bus interface, a processor bus interface, an Internet connection, a disk controller, etc. The communication interface can be configured by providing configuration parameters and\/or sending signals to prepare the communication interface to provide a data signal describing the software content. The communication interface can be accessed via one or more commands or signals sent to the communication interface.","Various components described herein can be a means for performing the operations or functions described. Each component described herein includes software, hardware, or a combination of these. The components can be implemented as software modules, hardware modules, special-purpose hardware (e.g., application specific hardware, application specific integrated circuits (ASICs), digital signal processors (DSPs), etc.), embedded controllers, hardwired circuitry, etc. Besides what is described herein, various modifications can be made to the disclosed embodiments and implementations of the invention without departing from their scope. Therefore, the illustrations and examples herein should be construed in an illustrative, and not a restrictive sense. The scope of the invention should be measured solely by reference to the claims that follow."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the invention are illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. It should be noted that different references to \u201can\u201d or \u201cone\u201d embodiment in this disclosure are not necessarily to the same embodiment, and such references mean at least one.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
