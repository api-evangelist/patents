---
title: Operating system and architecture for embedded system
abstract: An improved operating system and architecture, particularly useful for aircraft, provides a schedule for multiple tasks that ensures that each task has sufficient execution time and does not interfere with any other tasks. In the operating system, each task is scheduled to a deadline monotonic algorithm. The algorithm creates a schedule for the tasks in which the tasks are time partitioned by task, not by task level. The APIs in the operating system are provided by the services. Thus, changing a service, e.g. because of a change in hardware, is facilitated, since the service will provide the proper API.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08789051&OS=08789051&RS=08789051
owner: Hamilton Sundstrand Corporation
number: 08789051
owner_city: Rockford
owner_country: US
publication_date: 20041118
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["The present invention relates generally to operating systems and architecture and more particularly to an operating system and run-time architecture for safety critical systems.","Aircraft systems that contain software are subject to functionality restrictions and the verification requirements specified in the RTCA\/DO-178B (DO-178B) Standard, \u201cSoftware Considerations in Airborne Systems and Equipment Certification.\u201d The Federal Aviation Authority in conjunction with its worldwide counterparts recognizes and enforces adherence to this standard. In the RTCA\/DO-178B standard, there are three concepts of interest defined, the first being \u201cLevels of software criticality,\u201d the second concept being protection, and the third, which is closely related to the second, is the concept of partitioning.","Software levels of criticality, as defined in the DO-178B standard, are defined as five differing levels (e.g. Levels A, B, C, D, E), where Level A represents software of the highest criticality and Level E the lowest in terms of the software's function in controlling safety critical function on the aircraft. Thus the standard provides a method to classify high criticality functions and tasks from lower level criticality functions and tasks. Safety critical standards from other industries may define this concept similarly.","The DO-178B standard defines partitioning as the separation of software levels of criticality in both time and space running on a single CPU. Thus a partitioned design provides both Time Partitioning and Space Partitioning. Time Partitioning is the ability to separate the execution of one task from another task, such that a failure in one task will not impede the execution of the other. Space Partitioning is defined as the separation of space for two partitions, such that one partition cannot corrupt the other partition's memory (space), or access a critical resource. The DO-178B standard defines protection as the protection of one partition from another partition, such that a violation of either time or space in partition has no effect on any other partition in the system.","Many existing task analysis and scheduling techniques exist in real-time preemptive operating systems today. One method of interest is Deadline Monotonic Analysis (DMA) and Scheduling (DMS) (reference Embedded Systems Programming see \u201cDeadline Monotonic Analysis,\u201d by Ken Tindell, June 2000, pp. 20-38.). Deadline Monotonic Analysis DMA) is a method of predicting system schedule-ability where the system is a CPU with multiple tasks that are to be executed concurrently. DMA requires that the analyst have the following basic information for every task to be scheduled in the system: 1) Task period, the task cycle or rate of execution. 2) Task Deadline, the time that the task must complete execution by as measured from the start of a task period. 3) The task's worst case execution time (WCET), the worst-case execution path of the task in terms of instructions converted to time. Armed with this basic information the analyst can use the DMA mathematics or formulas to predict if the system can be scheduled. i.e. whether all tasks will be able to meet their deadlines in every period under worst case execution scenarios. If the system can be scheduled then the system can be executed using a runtime compliant Deadline Monotonic Scheduler (DMS).","Existing Deadline Monotonic Schedulers use a dynamic method for determining individual task execution at runtime. At each timing interval, an evaluation is made at run-time to determine whether the currently executing task is to be preempted by a higher priority task, or whether a new task is due to be started on an idle system. This dynamic method achieves the goals of schedule-ability, but does introduce an element of variability, since the individual preemption instances and task initiation times may vary over successive passes through the schedule. For example, in an existing Deadline Monotonic Scheduler, individual task execution may be \u201cslid\u201d to an earlier execution time if the preceding task finishes early or aborts. Also, the number and placement of preemptions that take place are similarly affected, and so individual tasks may vary anywhere within the bounds defined by their DMS parameters.","Even though the amount of variability in existing Deadline Monotonic Schedulers is limited to the schedule parameters, it is nevertheless undesirable for certain applications where a higher degree of predictability and repeatability is desired, for example, DO-178B (avionics) and other safety critical applications","In a partitioned design, tasks inside of one partition communicate data via Application Programming Interfaces (APIs) or APplication\/EXecutive (or APEX) has they are called in ARINC 653 compliant designs. The RTCA\/DO-178B standard concept of protection requires that partitions be protected from each other such that a violation of either time or space in partition has no effect on any other partition in the system. This concept of protection applies to the APIs or APEX interfaces as well.","In ARINC 653 compliant designs, partitions are given access to the APEX interface during the partition's window of execution. During this window, a partition can request or send data to any resource available in the system via calls to the appropriate APEX interface.","In the case of the ARINC 653 compliant designs, all partitions have access to all of the APEX interfaces to request or send information. Thus, the standard has no concept for restricted use or protected services or restricted interfaces.","Many safety critical industries like aviation provide regulatory guidelines for the development of embedded safety critical software. Adherence to safety critical software design standards involves creation of design and verification artifacts that must support and prove the pedigree of the software code and its particular application to the assessed software criticality level.","Adherence to these safety critical standards typically means that designers will spend less than 20% of their time producing the actual code, and greater than 80% producing the required supporting artifacts, and in some cases the time spent producing the code can enter the single digits.","While adherence to these standards is meant to produce error-free embedded software products, the cost associated with the production of these products is high. As a result the producers seek as much reuse as possible. Due to the critical nature of these products in the industries that they serve, the safety critical standards also provide guidance for reuse.","The reuse guides, like those provided by the FAA for avionics designs, typically state that a software configuration item can be reused without additional effort if it has not changed, implying that its artifacts have not changed in addition to the code.","Today, only one standard exists for a partitioned software design in the safety critical world of avionics, that standard is the ARINC 653 standard. The ARINC 653 standard supports application partitions that could be reused across multiple applications, since the standard provides a common APEX or user interface to the Operating System functions. Using the APEX interface as specified in the standard, it is possible to write an application that does not change across multiple applications. Such an application would be a candidate for reuse and reduced work scope in its successive applications as defined by safety critical guidelines like thus provided by the FAA.","One of the flaws with specifying the user interface or APEX or API's as a part of the executable operating system code is that the underlying system hardware, like an aircraft avionics communications device or protocol and or other system hardware devices tend to change from program to program (or aircraft to aircraft).","In addition, most aircraft OEM's change aircraft specifications from aircraft to aircraft. Thus any changes in the user interface, APEX or API's will cause changes in the application software or application partitions. Once the software or its artifacts have changed, its chances for reuse via a reduced work scope as provided by industry guidance, like that of the FAA, has evaporated. Architectures which separate the Operating Systems user interfaces from the hardware device or services interfaces better serve reuse claims.","In summary, existing safety critical operating systems contain many noticeable drawbacks, among these are the following:","1) They do not ensure that the individual tasks grouped within a partition will be individually time partitioned.","2) They do not provide the flexibility to space partition multiple tasks of the same criticality either individually or in subgroups.","3) The architecture requires the operating system to provide all Application Programming Interfaces (API's) or APEX's in the case of ARINC 653, to all partitions.","4) Access to system hardware or CPU resources is provided by operating system via the API (or APEX in the case of ARINC 653), thus the interface for these resources is controlled by the operating system, and could change from platform to platform, limiting the ability to reuse software without change.","5) The architecture and API or APEX interfaces provide no mechanism for exclusive use of critical resources by a partition, the concept of protected resources.","6) The architecture and API or APEX interfaces are open to use by any caller and as such does not provide protection for each partition.","7) Runtime dynamic compliant Deadline Monotonic Schedulers do not limit task execution variability.","The present invention provides an improved operating system and architecture, particularly useful for safety critical systems like aircraft. In the operating system, each task is scheduled to a deadline monotonic algorithm. The algorithm creates a schedule for the tasks in which the tasks are time partitioned by task, not by task level. The schedule is created when the operating system is started or at compile time. The schedule is created based upon time blocks, which are the period of time between time interrupts (preferably a constant value).","In creating the schedule, each task has an associated period, which indicates the rate at which the task needs to be executed. Each task also has an associated worst case execution time (WCET), which is the time the task needs to execute from its beginning until its end. Further, each task has an associated deadline, which indicates the time that a task needs to finish its execution, as measured from the beginning of the period. The schedule is then created using a deadline monotonic algorithm based upon the WCETs, periods and deadlines of the many tasks. The schedule is constant and is repeated over and over. The schedule does not change during operation, even if some tasks are terminated or restarted. Each task has specific time blocks in which it is permitted to run. Therefore, one task cannot starve or block any other tasks and the fixed schedule ensures that each task receives the necessary processor time to execute and meet its WCET, period and deadline.","Additionally, in the architecture provided in the present invention, the non-operating system APIs are provided by the services and are located outside of the operating system's executable code partition. Thus, changing a service, e.g. because of a change in hardware, is facilitated outside of the operating system, since the service will provide the proper API outside of the operating system's partition or executable code. Because the non-operating system APIs are not part of the operating system, the architecture and non-operating system API interfaces can provide exclusive use of critical resources by a particular partition.","The architecture described herein supports reuse at multiple layers by providing more software layers (ARINC 653 provides only two) and by having each service provide its own set of API (equivalent to ARINC 653's APEX's), such that the code and the artifacts for these services could support a reuse claim.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 1","b":["20","22","20","26","28","30","22","34","34","34","34","34","34","34","28"],"sub":["1","2","3","4","5","6 ","N"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 2","FIG. 1"],"b":["30","40","44","46","48","50","44","30","50","70","54","56","30","50","60","62","62","64","64","70","62","72"],"sub":["1 ","N","1 ","N"]},"The application tasks -in each partition  run in user mode and are certified to level of criticality required by function hazard assessment and system safety assessment. The application tasks  can have their own partitions  or can share a partition  with one or more tasks  of the same criticality level, as shown. The application tasks  interface with the application specific support services , core support services  and the operating system  through the APIs , . It should be noted that the application tasks  do not interface with the hardware  directly. The core support service  and application specific support service  run in user mode, while the operating system  runs in supervisor mode.","The tasks within the core support service  can each have their own unique partitions or can share a partition with one or more core support services of the same criticality level. The tasks within the core support services  interface with the application tasks , other application specific support services , operating system  and the BSP services  through APIs , , .","The application specific support services  module contains tasks that run in user mode. The services  are reserved for services that change from aircraft to aircraft, such as particular data formats and responses to certain safety critical conditions that are tailored for a specific aircraft. The application specific support services  tasks are certified to a level of criticality required by functional hazard assessment and system safety assessment. Application specific support service  tasks can have their own unique partitions or can share a partition with one or more tasks of the same criticality level. The tasks in each application specific support services  interface with the applications , core support services , operating system , and the BSP services  through APIs ,  and . The tasks in the BSP services  run in user mode. The interfaces will be particular to the product's hardware interfaces. The hardware interfaces can either be tasks or device drivers. Tasks can have their own unique partitions or can share a partition of one or more tasks of the same criticality level (hardware access and partition needs must be considered). Device drivers can be called by any tasks in any partition to read data without delay. Device drivers can handle writing to hardware I\/O, if an exclusive device driver (one per task). The BSP services  interface with the core support services  application specific support services  and operating system  through BSP interfaces .","The APIs comprise two types: message queues and device drivers. Referring to , the message queues -(only two shown for purposes of illustration) can have fixed length messages or variable length messages and provide communication across partitions. The message queues -pass multiple messages between an application task  in one partition and an application task  in another partition . Message queues are controlled by the RTOS  (in terms of size, shape, access, etc) and are implemented using system calls. Each message queue -is dedicated to sending messages from one specific task  to another specific task  in a single direction. Each queue -has one task  as the sender and the other task  as the receiver. If the two tasks  require handshaking, then two queues must be created, such as in the example shown. Message queue sends messages from task to task while message queue sends messages from task to task . Each task  has a queue  for each of the tasks  to which it has to send data and a queue  for each of the tasks  from which it has to receive data.","Referring to , in use, a sending task (such as the \u201cgalley light switch task\u201d) copies its message to the queue (\u201cgalley light to communications\u201d queue), which resides in the RTOS  during the task's execution slot. Referring to , I\/O communications services is one of the services  shown generically in . During the task's execution slot, the receiving task, I\/O communications services (in this example), copies the message from the queue . In this example, the I\/O communications services would then map the output data to the hardware  (via BSP Interfaces  of , not shown in ).","Referring to , device drivers (one device driver is shown) can also be used to read information between task partitions . Device drivers have a single entry point and are re-entrant and pre-emptive. The device drivers are implemented using system calls and there is no data delay. The device drivers are operated in user mode by the RTOS and can traverse space partitions. The I\/O communications services retrieves inputs from hardware  during its period of execution and places an image of the data into a memory map . As shown in , a task (in this example again, the \u201cgalley light switch task\u201d) requests the communication I\/O device driver . The request is handled in the RTOS  executing in supervisor mode. RTOS  adds code and data partition to the MMU for the device driver . Execution is then placed in user mode and the device driver is invoked. Referring to , the communication I\/O device driver executes with memory that is partitioned for both the galley light switch task , and the I\/O communications services . The device driver copies the requested inputs into the galley light switch data partition. Referring to , when the device driver is finished, execution returns to the RTOS  in supervisor mode. The RTOS  removes the code and data partition from the MMU for the device driver . Execution is then returned to the requesting task , and the total execution time required to run the device driver is charged to the requesting task .","The space partitioning is illustrated conceptually in . A mask  is defined by Block Address Translation (BAT) registers , , , and is used for space partitioning. For example, a task  is assigned data BAT entry , which defines a partition  in RAM of memory , for example. Transition lookaside buffer  defines a partition  in RAM for task . Further, instruction BAT entry register  defines partition  in ROM of memory of memory .","Tasks  are assigned to a partition ,  and . Every task  switch loads in the predefined registers ,  of the partition that task  belongs to. No searches are required if a BAT miss is encountered. The miss is a space partitioning fault. The transition lookaside buffer  on chip page table registers are used for stack protection. No searches are required if a TLB miss occurs. The miss is a space partitioning fault. The BAT registers ,  are defined at compile time. All registers can be used for designer to allocate. The last register is multiplexed with a device driver. For communication, all tasks  can write to the last register.","For the instruction BATs , the first register is assigned to the operating system API instruction area (function call). The second to the last registers can be used for a designer to allocate. The last register is multiplexed with a device driver. Switching tasks requires first a check that a Single Event Upset (SEU) did not occur in the BAT registers. Then the BAT registers ,  are updated with the new tasks  partition BAT values. The system then checks that the SEU did not occur for the TLB registers for the stacked protection. The current TLB registers are invalidated for the current task  and the TLB registers  are updated with the new tasks  values.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 11","b":["88","90","92","94","100","102","104","110","112","114","102","102","94","104","94","104","120"]},"Referring to , the schedule  does not change during operation. For example, the first three execution blocks  are always for Task A, even if A should terminate or fail. A status register  has a plurality of registers  that each correspond to the time blocks in the schedule . The status register  indicates the expected operation of the task associated with that particular status register . For example, the \u201c1\u201d may mark the beginning of a task for restarting the task. The \u201c0\u201d may signify that the Task may continue executing. The \u201c2\u201d indicates that the Task should end. An index  of the deadline monotonic scheduler  is incremented at each timer interrupt . The index  indicates which execution block in the schedule  is currently being performed.","The DM scheduler  ensures that no task can starve or block another task, because the DM scheduler  will only give each task the exact execution blocks that are allotted it in the schedule . Therefore, if Task A, for example, fails to complete before the third execution block, where the status register  of \u201c2\u201d indicates that the Task A should end, Task A is terminated, put to sleep or restarted. In the fourth execution block, Task C begins on schedule. If necessary, the entire control system  may be restarted.","A new schedule can be inserted when the index  reaches the end of the current schedule . The index  is then set to the beginning of the new schedule. For example, the system  may utilize a first, startup schedule for startup and another normal schedule for normal operation. The startup schedule may permit some of the various tasks more time to start up, with different WCETs, periods and deadlines. Once the system  is in full operation, the normal schedule may be seamlessly switched into operation.","In this manner, tasks can also be added to the schedule. The WCETs, periods and deadlines of the tasks to be added are input and stored and the DM scheduler  creates a new schedule including the new task(s). New space partitions can also be added for the new task(s) as well. Therefore, when new tasks are added, there is no need to thoroughly re-test the entire system, since the operation of the prior tasks is known to be within guidelines and the new task(s) is time and space partitioned from the prior tasks.","In accordance with the provisions of the patent statutes and jurisprudence, exemplary configurations described above are considered to represent a preferred embodiment of the invention. However, it should be noted that the invention can be practiced otherwise than as specifically illustrated and described without departing from its spirit or scope."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Other advantages of the present invention can be understood by reference to the following detailed description when considered in connection with the accompanying drawings wherein:",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 5","FIG. 3"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 6","FIG. 2"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 8","FIG. 6"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 9","FIG. 6"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
