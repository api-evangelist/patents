---
title: Methods and apparatus for rendering vector art on graphics hardware
abstract: Methods and apparatus for ray-casting 2D animated vector art on graphics hardware. Embodiments maintain curves in their analytic form when transmitted to the GPU. On the CPU, the curves in the vector art may be subdivided into a plurality of monotonic curve segments. A plurality of intervals may be generated from the curve segments. Further subdivision may be applied on the CPU to any interval that includes more than n curves, where n is the maximum number of curves that can be processed in parallel in the pixel shader. On the GPU, the pixels are evaluated to determine whether each pixel is inside or outside of the curve network. The technique used in the GPU may be based on a point-in-polygon algorithm that casts rays from points under test and counts the number of curve crossings before the rays exit the shape using a modified implicit formula.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08379025&OS=08379025&RS=08379025
owner: Adobe Systems Incorporated
number: 08379025
owner_city: San Jose
owner_country: US
publication_date: 20090828
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","Description of the Related Art","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS","Example Implementations","CONCLUSION"],"p":["Conventionally, web based 2D graphics engines such as Adobe\u00ae Flash\u00ae technology employ two-dimensional (2D) bounded B\u00e9zier shapes as their primitive of choice. 2D bounded B\u00e9zier shapes provide a compact representation, and are efficient for data transmission. Conventional three-dimensional (3D) graphics APIs (application programming interfaces) and GPUs (graphics processing units), however, are designed around efficiently rendering triangles. This mismatch poses significant challenges when trying to use graphics hardware to render B\u00e9zier bounded content, particularly animated content and particularly when rendering on less powerful devices.","One approach to offloading rendering of B\u00e9zier bounded content to graphics hardware is to run 2D planar mapping on the content. The content in this form can then be triangulated and sent to the GPU for rendering. However, triangulation can be expensive on the CPU, and this approach only produces piece-wise linear approximations to the true curved B\u00e9zier segments.","Loop and Blinn presented a resolution independent way of rendering B\u00e9zier bounded shapes on the GPU (Loop, C., and Blinn, J., 2005: Resolution independent curve rendering using programmable graphics hardware, 052005 , ACM, New York, N.Y., USA, 1000-1009). This technique relies on converting curve segments into their implicit form and evaluating inside-outside tests in the pixel shader. Loop and Blinn's method requires significant preprocessing to decompose space into triangular regions in which only a single curve is needed in performing the inside-outside test. This preprocessing phase requires Delaunay triangulation and subdivision, which can be time-consuming, particularly for animated content.","Kokjima et al. proposed a combination of inside-outside testing using a stencil buffer and the work by Loop and Blinn (Kokojima, Y., Sugita, K., Saito, T., and Takemoto, T., 2006: Resolution independent rendering of deformable vector objects using graphics hardware, 06: 2006 , ACM, New York, N.Y., USA, 118). However, processing complex shapes using stencil buffer logic can result in a significant amount of overdraw. On low-end GPU devices with minimal frame buffer bandwidth, the cost of resolving such shapes with stenciling may be prohibitive.","Graphics Hardware Technology","Graphics hardware for use in various computer systems is commercially available from vendors such as NVIDIA Corporation, ATI Technologies (AMD), and others. An example of graphics hardware, which may be referred to as a graphics card or graphics processing unit (GPU), may implement one or more application programmer interfaces (APIs) that permit programmers to invoke the graphics functionality of the GPU(s). Geometry and texturing information may be sent to the GPU for appropriate graphics processing on the hardware.","In the past, graphics cards were typically implemented to provide a fixed function pipeline (FFP). These graphics cards implemented a few fixed graphics functions and provided little if any programmatic control beyond selecting a function. More recently, graphics hardware that provides much more control by the programmer has been introduced. GPUs and their associated APIs, for example, now typically provide programmable shader functionality. Vertex shaders are programmable to operate on vertex data, while pixel shaders are programmable to operate on pixel data. Using the APIs, appropriate shader code may be developed by the programmer, loaded into the GPU, and plugged directly into the graphics pipeline.","Various embodiments of methods and apparatus for ray-casting 2D animated vector art on graphics hardware are described. Embodiments may provide methods for rendering quadratic B\u00e9zier-bounded two-dimensional (2D) vector art, such as Adobe\u00aeFlash\u00ae technology or SVG (Scalable Vector Graphics) technology vector content, using graphics hardware such as a graphics processing unit (GPU). Embodiments provide methods for rendering vector art on graphics hardware without expensive triangulation. Embodiments of vector art rendering methods as described herein may reduce the CPU overhead required for processing geometry, and place the primary burden of rendering the content onto the graphics hardware. Embodiments may provide methods that leverage graphics hardware to efficiently render quadratic B\u00e9zier content directly, thus eliminated the need for expensive CPU-side planar mapping and triangulation. Embodiments of the vector art processing methods may be resolution independent and affine invariant, may provide high performance when compared to conventional methods, and may allow the processing load to be redistributed between the GPU and CPU to accommodate different hardware configurations. Embodiments of methods for rendering vector art using graphics hardware may be implemented in or as a vector art rendering module. The vector art rendering module includes both CPU-side and GPU-side components or submodules.","Embodiments of the vector art rendering module may maintain curves in their analytic form when transmitted to the GPU. On the GPU, the curve networks may be evaluated to determine whether the pixel is inside or outside of the curve network. In some embodiments, the technique used in the GPU in the discard operation may be based on a point-in-polygon algorithm that casts rays from points under test and counts the number of crossings before the rays exit the shape using a modified implicit formula.","For complex artwork with a large numbers of curves, the ray casting operation described above may result in the need to test against a virtually unbounded set of curves in the pixel shader. Embodiments of the vector art rendering module may thus implement a method to bound the number of curves needed for such an inside-outside test, thus avoiding looping and branching in the pixel shader component on the GPU. The method for bounding the number of curves needed for the inside-outside test may be performed on the CPU side. However, this method is less CPU-intensive than the triangulation methods used in conventional vector art rendering techniques such as the Loop-Blinn technique.","In embodiments, an example of B\u00e9zier-bounded 2D vector art to be rendered may be obtained. In a CPU-side component of the vector art rendering module, the curves in the vector art may be subdivided into a plurality of monotonic curve segments. In some embodiments, the curves in a curve network of an example B\u00e9zier-bounded 2D vector art are subdivided into a plurality of y-monotone curve segments. The curve segments are monotonic in y; that is, each curve segment has only a single crossing horizontally, in x. A plurality of rectangular regions, which may be referred to as rectangles, may be generated from the curve segments. In some embodiments, the start and end events of the curve segments are sorted in y to form a plurality of intervals. Each interval may be represented as a rectangle that bounds the portions of the curve segments that are in or cross through the interval.","GPUs are generally able to perform at least some parallel processing. For example, pixel shaders may be able to process R, G, B and Alpha channels in parallel. Embodiments may take advantage of the parallel processing capabilities of GPUs to process multiple curves in parallel in the pixel shader. After generating the intervals on the CPU, further subdivision may be applied on the CPU to any interval that includes more than n curves, where n is the maximum number of curves that can be processed in parallel in the pixel shader. In some embodiments, n=4. In some embodiments, this subdivision may be applied in x.","After the above method to bound the number of curves is performed on the CPU, GPU rendering may be performed on the resultant rectangles. The analytic curve data representing the set of monotonic curves may be transferred to the graphics hardware, for example as an array of curve control points. For each rectangle, data representing the bounds of the rectangle and referencing the curve segments included in the rectangle is sent to the graphics hardware. On the graphics hardware, when processing a rectangle, a vertex shader coalesces the respective curves to produce the implicit forms of the respective curves for the rectangle and forwards the implicit forms of the curves to the pixel shader. For each rectangle, the pixel shader applies an inside-outside test using ray casting at each pixel within the rectangle and the implicit forms of the curves within the rectangle to discard fragments that lie outside of the bounded curve network, and appropriately renders the pixels that lie inside of the bounded curve network. The pixel shader may use a modified form of the implicit formula (\u0125(x,y)=r+|r|r) in the inside-outside testing. This processing may be done on the pixel shader in parallel, with up to n curves being processed in parallel. Each rectangle effectively clips the bounds of the inside-outside testing on that rectangle so that points above or below the curves are not unnecessarily tested against the curves within the rectangle.","While the invention is described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that the invention is not limited to the embodiments or drawings described. It should be understood, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention. The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description. As used throughout this application, the word \u201cmay\u201d is used in a permissive sense (i.e., meaning having the potential to), rather than the mandatory sense (i.e., meaning must). Similarly, the words \u201cinclude\u201d, \u201cincluding\u201d, and \u201cincludes\u201d mean including, but not limited to.","In the following detailed description, numerous specific details are set forth to provide a thorough understanding of claimed subject matter. However, it will be understood by those skilled in the art that claimed subject matter may be practiced without these specific details. In other instances, methods, apparatuses or systems that would be known by one of ordinary skill have not been described in detail so as not to obscure claimed subject matter.","Some portions of the detailed description which follow are presented in terms of algorithms or symbolic representations of operations on binary digital signals stored within a memory of a specific apparatus or special purpose computing device or platform. In the context of this particular specification, the term specific apparatus or the like includes a general purpose computer once it is programmed to perform particular functions pursuant to instructions from program software. Algorithmic descriptions or symbolic representations are examples of techniques used by those of ordinary skill in the signal processing or related arts to convey the substance of their work to others skilled in the art. An algorithm is here, and is generally, considered to be a self-consistent sequence of operations or similar signal processing leading to a desired result. In this context, operations or processing involve physical manipulation of physical quantities. Typically, although not necessarily, such quantities may take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared or otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to such signals as bits, data, values, elements, symbols, characters, terms, numbers, numerals or the like. It should be understood, however, that all of these or similar terms are to be associated with appropriate physical quantities and are merely convenient labels. Unless specifically stated otherwise, as apparent from the following discussion, it is appreciated that throughout this specification discussions utilizing terms such as \u201cprocessing,\u201d \u201ccomputing,\u201d \u201ccalculating,\u201d \u201cdetermining\u201d or the like refer to actions or processes of a specific apparatus, such as a special purpose computer or a similar special purpose electronic computing device. In the context of this specification, therefore, a special purpose computer or a similar special purpose electronic computing device is capable of manipulating or transforming signals, typically represented as physical electronic or magnetic quantities within memories, registers, or other information storage devices, transmission devices, or display devices of the special purpose computer or similar special purpose electronic computing device.","Various embodiments of methods and apparatus for ray-casting 2D animated vector art on graphics hardware are described. Embodiments may provide methods for rendering quadratic B\u00e9zier-bounded two-dimensional (2D) vector art, such as Adobe\u00ae Flash\u00ae technology or SVG (Scalable Vector Graphics) technology vector content, using graphics hardware such as a graphics processing unit (GPU). In this document, \u201cGPU\u201d and \u201cgraphics hardware\u201d may be used interchangeably.  shows an example of B\u00e9zier bounded 2D vector art that may be rendered using embodiments. B\u00e9zier bounded shapes, for example as represented in Adobe\u00ae Flash\u00ae technology and SVG technology, may have complex networks of curves, which may be both concave and self intersecting.","Conventional 3D graphics APIs and GPUs are designed to efficiently render triangles. Thus, conventional methods of rendering vector art using graphics hardware have relied upon CPU-side triangulation to prepare the art for rendering by the graphics hardware. However, triangulating content at runtime on a CPU is expensive, and for animated vector art, where triangulation may need to be performed at each \u201cframe\u201d, the CPU cost may be prohibitive, particularly on systems with relatively low-power CPUs. Embodiments provide methods for rendering vector art on graphics hardware without expensive triangulation. Embodiments of vector art rendering methods as described herein may reduce the CPU overhead required for processing geometry, and place the primary burden of rendering the content onto the graphics hardware. Embodiments may provide methods that leverage graphics hardware to efficiently render quadratic B\u00e9zier content directly, thus eliminated the need for expensive CPU-side planar mapping and triangulation. Embodiments of the vector art processing method described herein may be resolution independent and affine invariant. When a change is made to the vector artwork, if the content does not change, for example if the art is only being rotated, scaled, or translated, reprocessing is not required. Embodiments may provide high performance when compared to conventional methods, and may allow the processing load to be redistributed between the GPU and CPU to accommodate different hardware configurations.","Embodiments of methods for rendering vector art using graphics hardware as described herein may be implemented in or as a vector art rendering module. The vector art rendering module includes both CPU-side and GPU-side components or submodules. An example vector art rendering module is illustrated in . An example system on which embodiments of the vector art rendering module may be implemented is illustrated in .","Embodiments of the vector art rendering module maintain curves in their analytic form when transmitted to the GPU. On the GPU, the curve networks are evaluated to determine whether the pixel is inside or outside of the curve network. A discard operation is used to eliminate pixels that are outside of the bounded region. Pixels that are inside the bounded region are appropriately rendered. The technique used by the GPU in the discard operation may be based on a point-in-polygon algorithm that casts rays from points under test and counts the number of crossings before the rays exit the shape. In the non-degenerate case, an even number of crossings results in a point that is outside of the shape, as illustrated in .",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 2","FIG. 2"],"b":["1","2","3","4","5","1","2","3","4","5","1","1","2","2","3","3","4","4","5","5"]},"While  shows rays being cast horizontally on the x axis, in a positive direction from left to right, note that the direction the rays are cast is arbitrary; rays may cast horizontally, from right to left, or vertically, from top to bottom or from bottom to top, to produce similar results.","For complex artwork with a large numbers of curves, the ray casting operation described above may result in the need to test against a virtually unbounded set of curves in the pixel shader. As described below, embodiments of the vector art rendering module as described herein may thus implement a method to bound the number of curves needed for such an inside-outside test, thus avoiding looping and branching in the pixel shader component on the GPU. The method for bounding the number of curves needed for the inside-outside test may be performed on the CPU side. However, this method is less CPU-intensive than the triangulation methods used in conventional vector art rendering techniques.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 3","FIG. 4A","FIG. 4B","FIG. 4A"],"b":["100","102","0","12"]},"As indicated at , a plurality of rectangular regions, referred to simply as rectangles, may be generated from the curve segments. In some embodiments, the start and end events of the curve segments are sorted in y to form a plurality of intervals. Each interval may be represented as a rectangle that bounds the portions of the curve segments that are in or cross through the interval.  illustrates a plurality of intervals i through i for the curve segments illustrated in  according to some embodiments.","GPUs are generally able to perform at least some parallel processing. For example, pixel shaders may be able to process R, G, B and Alpha channels in parallel. Embodiments may take advantage of the parallel processing capabilities of GPUs to process multiple curves in parallel in the pixel shader. After generating the intervals as illustrated in , further subdivision may be applied on the CPU to any interval that includes more than n curves, where n is the maximum number of curves that can be processed in parallel in the pixel shader. In some embodiments, n=4. In some embodiments, this subdivision may be applied in x.  illustrates a subdivision of the intervals i through i illustrated in  into subintervals represented by rectangles b through b according to some embodiments. In , interval i included, or was crossed by, a total of six curve segments (C, C, C, C, C, and C). Assuming n=4, interval i includes more than the maximum number of curves. In , interval i has been subdivided into two subintervals: rectangle b, which includes or is crossed by curves C, C, and C, and rectangle b, which includes or is crossed by curves C, C, and C.  shows a list of the rectangles shown in  according to some embodiments. For each rectangle, the respective curve segments that are included in or that cross the rectangle are listed.","While the above discussion of elements  through  assumes that the curves of the vector art are subdivided into a plurality of y-monotone curve segments, and the method proceeds from there, the choice of direction is arbitrary. Embodiments may instead subdivide the curves into x-monotone curve segments, and proceed with the above processing appropriately.","As indicated at , pixels within each rectangle may be processed on the graphics hardware according to an inside-outside ray casting test to discard external pixels and appropriately render internal pixels. After the above method to bound the number of curves is performed on the CPU, GPU rendering may be performed on the resultant rectangles. Each interval or sub-interval is directly rendered in the GPU. The analytic curve data representing the set of monotonic curves as illustrated in  may be transferred to the graphics hardware, for example as an array of curve control points. In practice, this may be done as soon as the curves have been monotonized. For each rectangle, data representing the bounds of the rectangle and referencing the curve segments included in the rectangle is sent to the graphics hardware. On the graphics hardware, when processing a rectangle, a vertex shader coalesces the respective curves to produce the implicit forms of the respective curves for the rectangle and forwards the implicit forms of the curves to the pixel shader. For each rectangle, the pixel shader applies an inside-outside test using ray casting at each pixel within the rectangle and the implicit forms of the curves within the rectangle to discard fragments that lie outside of the bounded curve network, and appropriately renders the pixels that lie inside of the bounded curve network. This processing may be done on the pixel shader in parallel, with up to n curves being processed in parallel. A rectangle effectively clips the bounds of the inside-outside testing so that points above or below the curves in the rectangle are not unnecessarily tested against the curves within the rectangle.","Some embodiments may employ modified forms of conventional implicit equations to enable inside-outside testing across multiple curves to be performed, as described below.","Curve Implicitization and Point-in-Polygon Testing","A quadratic B\u00e9zier curve can be defined as follows:\n\n()=\u2003\u2003(1)\n\nwith:\n\n\u22122\n\n2()\n\n\u2003\u2003(2)\n\nwhere Pand Pare the start and end control points (in x and y) through which the curve passes, and Pis the control point. The parameter t\u03b5[0,1] can be used to sample the curve between its two end points.\n","In computational geometry, the problem of testing whether a point lies inside a bounded region may be referred to as point-in-polygon testing. One approach to point-in-polygon testing is based on ray casting (also known at the crossing number or even-odd rule algorithm). The even-odd rule algorithm may implemented in vector-based graphic software, and may be used to determine how a graphical shape with more than one closed outline will be filled. Given a point in space to be queried, an infinite ray may be cast, and it can be shown in the non-degenerate cases that the number of edges that the ray crosses is sufficient for determining whether the point lies inside or outside of the bounded region, as shown in . An odd number of crossings classifies points as inside the shape, and an even number as outside the shape. This test works regardless of whether the shape in question is complex (with self intersections) or concave.","For a B\u00e9zier bounded shape, and a point P\u03b5 in question, a method may traverse the list of curves and test the number of times a particular ray originating at P crosses the curves. While the choice of ray-direction is arbitrary, this discussion assumes that the rays are cast in the positive x direction along horizontal scanlines. To solve for the intersection points along a scanline P, Equation 1 can be set to y, and solved for t. This yields the following expression:",{"@attributes":{"id":"p-0047","num":"0046"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"y"}},{"mo":"\u00b1","mfrac":{"mrow":[{"msqrt":{"mrow":{"mrow":[{"mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":"P","mn":"2"},{"mi":"P","mn":"0"}],"mo":["-","+"],"mrow":{"mn":"2","mo":"\u2062","msub":{"mi":"P","mn":"1"}}}},"mo":"\u2062","mi":"y"},{"msub":[{"mi":"P","mn":"0"},{"mi":"P","mn":"2"}],"mo":"\u2062"}],"mo":["-","+"],"msubsup":{"mi":"P","mn":["1","2"]}}},"mo":["-","+"],"msub":[{"mi":"P","mn":"1"},{"mi":"P","mn":"0"}]},{"msub":[{"mi":"P","mn":"2"},{"mi":"P","mn":"0"}],"mo":["-","+"],"mrow":{"mn":"2","mo":"\u2062","msub":{"mi":"P","mn":"1"}}}]}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"3"}}]}}}}},"The quadratic nature of the B\u00e9zier curve yields two potentially real solutions, since a ray can cross such a curve in as many as two places. By plugging any real T(P)\u03b5[0,1] values back into Equation 1, the locations in xalong the scanline that intersect the curve may be obtained. To compute the number of crossings for a point P only requires checking whether the xscanline intersection locations are greater than P.","Using Equations 1 and 3, an implicit function may be formulated as follows:\n\n()=(())\u2212\u2003\u2003(4)\n","The sign of evaluating G at coordinate x and y indicates whether a ray fired in the positive x direction intersects the curve. However, the cost of evaluating G for every pixel on the screen in question is expensive. For this reason, embodiments may use alternative implicit forms as described below.","Methods exist for converting parametric curves into implicit forms. Such an implicit is a function h(x,y) that evaluates to zero for any point that lies on the curve. The function will be positive or negative for any points lying away from the curve, and varies depending on which side of the curve the points lie. This provides an efficient and convenient method for testing which side of the curve a point lies, and has compact GPU implementations as shown by Loop and Blinn.","For a point x and y, it is known that the following two implicit formulas must simultaneously be satisfied:\n\n()+=0\n\n()+=0\u2003\u2003(5)\n","For any two polynomials:\n\n()=\n\n()=\n\nthe observation that, if f(x) and g(x) have a common root at x, then the equation:\n\n()()\u2212()()=0\n\nwill be satisfied for any value of y may be used. The expression has (x\u2212y) as a factor since the equation is always satisfied by x=y. By evaluating:\n\n()()\u2212()()=()\n\nthe following is produced:\n",{"@attributes":{"id":"p-0054","num":"0053"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mrow":[{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"mrow":{"mo":["(",")"],"mrow":{"mrow":[{"msub":[{"mi":"a","mn":"0"},{"mi":"b","mn":"0"}],"mo":"\u2062"},{"msub":[{"mi":"a","mn":"1"},{"mi":"b","mn":"1"}],"mo":"\u2062"}],"mo":"-"}}},{"mrow":{"mo":["(",")"],"mrow":{"mrow":[{"msub":[{"mi":"a","mn":"0"},{"mi":"c","mn":"1"}],"mo":"\u2062"},{"msub":[{"mi":"a","mn":"1"},{"mi":"c","mn":"0"}],"mo":"\u2062"}],"mo":"-"}}}]},{"mtd":[{"mrow":{"mo":["(",")"],"mrow":{"mrow":[{"msub":[{"mi":"a","mn":"0"},{"mi":"c","mn":"1"}],"mo":"\u2062"},{"msub":[{"mi":"a","mn":"1"},{"mi":"c","mn":"0"}],"mo":"\u2062"}],"mo":"-"}}},{"mrow":{"mo":["(",")"],"mrow":{"mrow":[{"msub":[{"mi":"b","mn":"0"},{"mi":"c","mn":"1"}],"mo":"\u2062"},{"msub":[{"mi":"b","mn":"1"},{"mi":"c","mn":"0"}],"mo":"\u2062"}],"mo":"-"}}}]}]}},{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"mi":"x"}},{"mtd":{"mn":"1"}}]}}],"mo":"\u2061"},"mo":"=","mn":"0"}},{"mrow":{"mo":["(",")"],"mn":"6"}}]}}}}},"For a square matrix system with n unknowns, a non-trivial solution exists only if the determinant of the matrix vanishes. Thus, the determinant of the matrix in Equation 6 forms the desired implicit function. By plugging into the implicit equation, the constant terms for a given curve may be collected:\n\n\n\n\u22122\n\n2()\n\n\u2003\u2003(7)\n","The implicit formula h(x,y) may now be given by:\n\n()=\u2003\u2003(8)\n\nwhere rand rmay be computed as follows:\n\n\n\n;\n\n;\u2003\u2003(9)\n","The terms rand rvary linearly and thus can be sent down the graphics pipeline as interpolated vertex attributes. Only Equation 8 needs to be evaluated in the pixel shader, making the implicit test fast to evaluate.","The implicit formula given in Equation 8 is valid for all of , however, parametric curves are defined over a range of t values typically between 0 and 1. Loop and Blinn bound each curve with a triangle cage made up of the curve's three control vertices. This ensures that the implicit formula is never evaluated outside of the valid t range for a particular curve. However, this may pose a problem when multiple curves overlap, since only a single curve is tested at a time by Loop and Blinn's method. To resolve this problem, Loop and Blinn apply subdivision to ensure that no other curve is contained within another curve's control cage. However, for regions of high curvature, and for narrow regions bounded by two curves, this can lead to a significant amount of subdivision.","Embodiments of a vector art rendering module as described herein may avoid much of the CPU overhead of conventional methods, and may allow multiple curves to be processed simultaneously using a ray casting point-in-polygon algorithm as described herein. Embodiments may employ an implicit form that efficiently answers the question as to which side of a curve a point lies with respect to a horizontal ray query. Embodiments may simplify the processing by monotonizing all of the curves in one planar direction (x or y) so that each curve has only a single crossing point for a scanline in the other planar direction. In the discussion, the curves are assumed to be monotonized in the y direction.","Curve Monotonization","Splitting a curve into monotone pieces is a relatively straightforward operation that at most doubles the number of curves in an input set. By setting the derivative of Expression 1 to zero, embodiments may solve for the parametric tlocation for splitting the curve by taking the derivative of Equation 1.",{"@attributes":{"id":"p-0061","num":"0060"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"msub":{"mi":["t","s"]},"mo":"=","mrow":{"mo":"-","mfrac":{"mrow":[{"msub":[{"mi":"P","mrow":{"mn":"1","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"y"}},{"mi":"P","mrow":{"mn":"0","mo":"\u2062","mi":"y"}}],"mo":"-"},{"msub":[{"mi":"P","mrow":{"mn":"2","mo":"\u2062","mi":"y"}},{"mi":"P","mrow":{"mn":"0","mo":"\u2062","mi":"y"}}],"mo":["-","+"],"mrow":{"mn":"2","mo":"\u2062","msub":{"mi":"P","mrow":{"mn":"1","mo":"\u2062","mi":"y"}}}}]}}}},{"mrow":{"mo":["(",")"],"mn":"10"}}]}}}}},"Given the parametric location t, embodiments subdivide the curve into two curves. Each is guaranteed to have only a single crossing in x between the y bounds of its control points. A curve can be subdivided into two curves at a parametric location tas follows:\n\n(1)+\n\n(1)2(1)\n\n(1)+\u2003\u2003(11)\n","The new curve control points are given by (P,P,P) and (P,P,P) respectively.","Modified Implicit Form","When plotting the implicit formula given in Equation 8, the shape forms a parabola as shown in . However, this form cannot be reliably used to count horizontal ray crossings by looking at the sign of the implicit formula test. As shown in , the test for points p and p would produce correct results; a test at p would produce a positive result, correctly indicating that the ray does not intersect the curve, and a test at p would produce a negative result, correctly indicating that the ray intersects the curve. However, at point p, the test would produce a positive result, indicating that the ray missed the curve, which is incorrect. To overcome this problem, embodiments may mirror or reflect the parabola around a control vertex at an end point of the curve, as shown in , thus causing the curve to go up instead of curving down as in . The given implicit representation then satisfies the desired ray query for any y monotone curve. Note that, in , the ray casting test at p produces a negative result, which is correct.","The setup for this new implicit form may be given as follows:\n\nif()swap();\n\n\u22122\n\n\n\n\n\n\n\n=(||)?\n\n=(||)?(\u2212):()\n\n=2.0*()\n\n\n\n=(0)?(\u2212):()\n\n\u2003\u2003(12)\n","The modified implicit formula \u0125(x, y) is given by:\n\n()=\u2003\u2003(13)\n\nwhere interpolants rand rare computed the same way as in equation 9.\n\nVector Art Processing Module Implementations\n","The following provides details on how this modified implicit form may be used with a ray-casting method using graphics hardware in implementations of a vector art processing module as described herein. Embodiments of a vector art processing method, implemented in a vector art processing module, may employ a combination of CPU side preparation of the data with GPU processing.","In the following discussion, an example implementation is assumed where the GPU can handle ray-intersection of at most n=4 curves in parallel. In practice, higher end GPUs may handle larger sets of curves. The larger the value of n, the lower the CPU load required to process the curves, but at the cost of additional instructions in the vertex shader and pixel shader. Also note that the example implementation assumes y-relative and x-relative operations. However, the orientation of the described operations is arbitrary.","CPU Side Preparation",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 7","b":["200","202","204","206","208","210"]},"As indicated at  of , the input curve set is analyzed to generate a set of y monotone curve segments. CPU side preparation may start by scanning through the obtained list of curves and splitting all non-y monotone curves into curve segments. In some embodiments, non-monotone curves may be detected by checking whether a curve's control vertex Pis bounded in y between its starting and end vertices Pand P.","The analytic curve data representing the set of monotonic curves may be transferred to the graphics hardware, for example as an array of curve control points. In some embodiments, the CPU processing component may transfer an array of floating point data to the graphics hardware after converting the curves to the monotonic form; the array indicates the control points of the curves. Thus, every curve gets transferred once and only once to the graphics hardware.","However, in some cases, the CPU processing component may not be able to transfer all of the analytic curve data to the graphics hardware at one time. For example, some GPUs may not allow access to textures (which may be used as a constant memory) from a vertex shader. As another example, some GPUs may only have a limited amount of vertex shader constant memory to which curve data can be transferred. As another example, a large and\/or complex piece of vector art may include so many curves that the analytic curve data may not fit into the vertex shader constant memory.","A solution that may be used in some embodiments to at least some situations in which the curve data cannot all be transferred to the graphics hardware is to split the art into sub-pieces on the CPU to reduce the curve count so that curve data for each sub-piece fits into vertex shader constant memory. This may, in pathological cases, take additional processing time, but would not cost much for typical shapes.","Another solution that may be used in some embodiments is to encode the curves that pass through a rectangular region into the rectangular region before passing the rectangular region to the graphics hardware for processing. Every rectangular region that is submitted to the graphics hardware may thus encode the curves that pass through it. This data can be sent down as vertex attributes of the rectangular region. In some embodiments, this may be done by redundantly encoding the curve values for each vertex of the rectangular region (i.e. each rectangular region vertex will have a copy of the curve data for the rectangular region). This approach increases the bandwidth to the graphics hardware; however, the approach may avoid some of the limitations of certain graphics hardware by not requiring the use of constant memory on the graphics hardware to transfer analytic curve data. This approach also allows for the implicit values to be computed on the CPU and transmitted to the graphics hardware instead of the curve data at each vertex. This may avoid redundant computation of curve data.","As indicated at  of , the curve segments' starting and ending points are sorted in increasing y and placed in a min priority queue E. For each curve, two events e are placed onto a min priority queue E. Each curve event includes either the min or the max y value of the curve, an indication of which curve the event belongs to, and a flag indicating whether the event is the start or end of a curve. As indicated at  of , subsets of the curves through each y interval are identified. Dividing curve lists up along the y intervals ensures that the implicit ray query test given in Equation 13 is not performed outside of a curve's range in y. As indicated at  of , for each subset of curves, spatial subdivision is performed, if necessary, until each curve subset contains n or fewer curves. Subdividing the intervals ensures that each interval passed to the graphics hardware includes no more than n curves, where n is the maximum number of curves that can be processed in parallel in the pixel shader. In some embodiments, n=4. An example sweep line algorithm in pseudocode form that may be used in some embodiments for finding lists of curves through each y interval and for performing spatial subdivision is given below.",{"@attributes":{"id":"p-0076","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Begin sweep line algorithm"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003E","\/\/ Min priority queue of curve events"]},{"entry":["\u2003while |E| do",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\u2003\u2003fIntervalStart = yLocation(front(E))"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003while |E| do",{}]},{"entry":["\u2003\u2003\u2003e \u2190 pop(E)","\/\/ Pop event e from list"]},{"entry":["\u2003\u2003\u2003c \u2190 getCurve(c)","\/\/ Get curve associated with e"]},{"entry":["\u2003\u2003\u2003if isStartOfCurve(e) then",{}]},{"entry":["\u2003\u2003\u2003\u2003A \u2190 A \u222ac","\/\/ Add curve to active list"]},{"entry":["\u2003\u2003\u2003else",{}]},{"entry":["\u2003\u2003\u2003\u2003A \u2190 A\\c","\/\/ Remove curve from active list"]},{"entry":["\u2003\u2003\u2003end if",{}]},{"entry":["\u2003\u2003end while",{}]},{"entry":["\u2003\u2003if |A|then",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\u2003intervalEndY \u2190 yLocation(front(E))"},{"entry":"\u2003\u2003\u2003ProcessCurveSet(A, intervalStartY, intervalEndY)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003end if",{}]},{"entry":["\u2003end while",{}]},{"entry":"End sweep line algorithm"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The sweep line algorithm pulls events off of the queue E and maintains an active list of curves through a bounded span in y. These sets are processed in the ProcessCurveSet( ) subroutine. This subroutine starts by computing the bounds of curves in x. Once this bounding box has been formed, a check is performed to see if the number of curves is n or less. If so, this rectangular region (along with the indices of the active curves) is added to the vertex array stored for the shape. The indices may be stored as texture coordinates for the rectangle.","In some cases, further refinement of the rectangular spaces may be required until there are n our fewer curves in each bounding box. In some embodiments, this may be performed by subdividing the rectangular regions in either x or y until there are n or fewer curves in each rectangle.","In embodiments, in the graphics hardware, even-odd parity ray casting testing is used to determine whether a point lies inside the bounded geometry. In an even-odd parity ray casting test, a given ray is tested against all curves until the bounds of the shape have been reached. In embodiments where rays are cast in a positive x direction, a subdivision in y does not impact the query since rays are fired in the positive x direction; however, a division in x does. Thus, for some rectangles, for example b and b of , an even-odd parity ray casting test for a point in the rectangle may give the wrong result. For example, a ray cast to test a point in b would also intersect the curves in b.","To handle the above situation, some embodiments may employ the following method that modifies the even-odd parity test. An observation is made that curves may be processed through any local subregion of space if the number of curve intersections to the right of the subregion is constant. By determining the constant number of intersections to the right of the rectangular region, the even-odd parity test may be modified to account for the curves to the right of the subregion that will be trivially intersected by any ray emanating from within the subregion. In some embodiments, the rectangular regions may be subdivided in x from right to left. During each subdivision, the parity of the number of curves entirely to the right of each subblock (rectangular region) is tracked. This results in an overall parity for each subregion.","When passing a rectangular region to the vertex shader, the parity of the rectangular region may be indicated by negating the transmitted curve indices. Based on the parity, the vertex shader flips the sign of rand rfor the first curve in the set before forwarding the data to the pixel shader. This effectively switches the even-odd counting rule for the subregion.","As indicated at , rectangular bounded regions that each bound a curve subset, with their respective curve indices, are placed into vertex arrays for rendering by the graphics hardware. Once the list of rectangular regions (with their contained curved indices) has been built, this data may be cached into a vertex array for the shape. Note that this information does not need to be recomputed unless the shape undergoes a non-rigid transformation or topology change. During rendering, the vertex arrays, along with the curve data, is submitted to the GPU for rendering with the shaders enabled as described in the following discussion.","GPU Side Processing","In some embodiments, GPU processing may include two components: vertex shader processing and pixel shader processing. The following describes examples of vertex shader processing and pixel shader processing according to some embodiments.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 8","b":["300","0","1","0","1"]},"As indicated at , the pixel shader performs a ray casting test at each pixel in each rectangle using a modified implicit formula to determine whether the pixel is inside or outside the shape. The pixel shader evaluates equation 13 given the interpolated r and r values. The pixel shader does this for every pixel location in the respective rectangle. When evaluating equation 13 for a given pixel, the pixel shader does it for all n curves in parallel. The method allows n curves to be processed in the pixel shader in parallel in each ray cast test. If there are fewer than n active curves in a rectangle, the method used insures that the value of the implicit evaluates to 1 for the inactive curve(s) so that inactive curves do not affect the answer.","Vertex Shader Processing","As indicated at  of , the vertex shader coalesces the curves referenced by the rectangles to produce the implicit forms of the respective curves for each rectangle. In some embodiments, the vertex shader coalesces the curves referenced by the primitives (i.e., the rectangles to be processed in the graphics hardware as determined by the CPU processing) and computes the interpolant values rand rfor each curve for each vertex to produce the implicit forms of the respective curves for a respective rectangle. The curve data can either be stored in uniform vertex shader memory or in texture memory. The former has stricter limits on the size of shapes that can be rendered, while the latter requires GPUs capable of accessing textures in the vertex shader. In some embodiments, the curve data may be stored in its raw form, which requires the vertex shader to evaluate both Equations 12 and 9 for each vertex. In some embodiments, as an alternative, the values G, G, and Gmay be pre-computed on the CPU and transmitted instead of the raw curve data. The latter approach may avoid redundant evaluation of curve data.","The vertex shader computes rand rfor the four referenced curves, and packs the result in a four way SIMD (Single Instruction, Multiple Data) layout into interpolants Rand Rfor processing in the pixel shader. SIMD is a technique that may be used to achieve data level parallelism. In some cases, not all subregions will contain n active curves. For any inactive curves, the method may set r=0 and r=1. These values are guaranteed not to change the result of the even-odd parity check done in the pixel shader.","As mentioned previously, in some cases, primitives may be submitted to the vertex shader with negative indices to denote a desired flip in parity for the even-odd test in the pixel shader. To handle such cases, the interpolant sign of the first curve (i.e. Rx and Rx) in the curve set may be flipped in the vertex shader. This effectively switches the even-odd parity check in the pixel shader without incurring additional per-pixel cost.","Pixel Shader Processing","As indicated at  of , the pixel shader may perform a ray casting test at each pixel in each rectangle using a modified implicit formula to determine whether the pixel is inside or outside the shape. Example OpenGL Shading Language (GLSL) code for a pixel shader processing implementation for four curves (n=4) that may be used in some embodiments is provided below. The example code is not intended to be limiting:","varying vec4 R0,R1;","uniform vec4 color;","void main( ) {\n\n","}","In this example, the (x, y, z, w) channels of the varying interpolants hold rand rvalues for the four curves respectively in a SIMD manner. The result of the implicit calculation is stored in imp and is positive if the ray hits the curve. Computing whether the number of intersections is even or odd can be accomplished in a number of ways. For example, the intersections may be summed and a modulus operation applied. However, multiplying the implicit results together and checking the resulting sign yields the same result. Multiplying the implicit results together and checking the resulting sign is equivalent to applying a sequence of exclusive or's (XORs), and is more efficient in graphics hardware than summing the intersections and applying a modulus operation.",{"@attributes":{"id":"p-0095","num":"0099"},"figref":["FIG. 9","FIGS. 2 through 7","FIG. 10","FIGS. 1"],"b":["400","400","410","420","420","422","428","400","2","4","410","410","412","414","422","428","428","428","404","404","450","460","412","414"]},"Ray Tracing 2D Vector Art on 3D Surfaces","A curved region of a 3D surface may have a mapping of how that surface can be flattened into 2D that allows textures or 2D artwork to be wrapped onto the surface of a 3D model. If the artwork being mapped is vector art, when a ray hits the surface of the 3D model, embodiments of the vector art rendering module may be used to perform a fast query to find out where the ray intersects the vector art and what color to apply for a point in the 3D surface. The vector art rendering module may be applied to generate the rectangles, monotonic curve segments, and so on described above. This information may be stored. When a ray hits the 3D surface, the ray may be mapped onto the 2D model to obtain its 2D location. The 2D location may be mapped to a particular rectangle generated by the vector art rendering module. Once the rectangle is determined, the implicitization and inside-outside test for the point at which the ray intersects the 2D surface may be performed on the GPU as described herein to determine if the point is inside or outside the vector art, and the point may then be rendered appropriately.","Example System","Embodiments of a vector art rendering module as described herein may be executed on one or more computer systems, which may interact with various other devices. One such computer system is illustrated by . In different embodiments, computer system  may be any of various types of devices, including, but not limited to, a personal computer system, desktop computer, laptop, notebook, or netbook computer, mainframe computer system, handheld computer, workstation, network computer, a camera, a set top box, a mobile device, a consumer device, video game console, handheld video game device, application server, storage device, a peripheral device such as a switch, modem, router, or in general any type of computing or electronic device.","In the illustrated embodiment, computer system  includes one or more processors  coupled to a system memory  via an input\/output (I\/O) interface . Computer system  further includes a network interface  coupled to I\/O interface , and one or more input\/output devices , such as cursor control device , keyboard , audio device , display(s) , and multitouch-enabled device(s) . In some embodiments, it is contemplated that embodiments may be implemented using a single instance of computer system , while in other embodiments multiple such systems, or multiple nodes making up computer system , may be configured to host different portions or instances of embodiments. For example, in one embodiment some elements may be implemented via one or more nodes of computer system  that are distinct from those nodes implementing other elements.","In various embodiments, computer system  may be a uniprocessor system including one processor , or a multiprocessor system including several processors  (e.g., two, four, eight, or another suitable number). Processors  may be any suitable processor capable of executing instructions. For example, in various embodiments, processors  may be general-purpose or embedded processors implementing any of a variety of instruction set architectures (ISAs), such as the x, PowerPC, SPARC, or MIPS ISAs, or any other suitable ISA. In multiprocessor systems, each of processors  may commonly, but not necessarily, implement the same ISA.","Computer system  may include at least one graphics processing unit (GPU) . A graphics processing unit or GPU  may be considered a dedicated graphics-rendering device for a personal computer, workstation, game console or other computing or electronic device. Modern GPUs may be very efficient at manipulating and displaying computer graphics, and their highly parallel structure may make them more effective than typical CPUs for a range of complex graphical algorithms. For example, a graphics processor may implement a number of graphics primitive operations in a way that makes executing them much faster than drawing directly to the screen with a host central processing unit (CPU). GPU components of a vector art rendering module as described herein, such as a vertex shader and a pixels shader, may be implemented by program instructions configured for execution on one of, or parallel execution on two or more of, such GPUs . The GPU(s) may implement one or more application programmer interfaces (APIs) that permit programmers to invoke the functionality of the GPU(s) as described herein. Suitable GPUs may be commercially available from vendors such as NVIDIA Corporation, ATI Technologies (AMD), and others.","System memory  may be configured to store program instructions and\/or data accessible by processor . In various embodiments, system memory  may be implemented using any suitable memory technology, such as static random access memory (SRAM), synchronous dynamic RAM (SDRAM), nonvolatile\/Flash-type memory, or any other type of memory. In the illustrated embodiment, program instructions and data implementing desired functions, such as those described above for embodiments of a vector art rendering module, are shown stored within system memory  as program instructions  and data storage , respectively. In other embodiments, program instructions and\/or data may be received, sent or stored upon different types of computer-accessible media or on similar media separate from system memory  or computer system . Generally speaking, a computer-accessible medium may include storage media or memory media such as magnetic or optical media, e.g., disk or CD\/DVD-ROM coupled to computer system  via I\/O interface . Program instructions and data stored via a computer-accessible medium may be transmitted by transmission media or signals such as electrical, electromagnetic, or digital signals, which may be conveyed via a communication medium such as a network and\/or a wireless link, such as may be implemented via network interface .","In one embodiment, I\/O interface  may be configured to coordinate I\/O traffic between processor , system memory , and any peripheral devices in the device, including network interface  or other peripheral interfaces, such as input\/output devices . In some embodiments, I\/O interface  may perform any necessary protocol, timing or other data transformations to convert data signals from one component (e.g., system memory ) into a format suitable for use by another component (e.g., processor ). In some embodiments, I\/O interface  may include support for devices attached through various types of peripheral buses, such as a variant of the Peripheral Component Interconnect (PCI) bus standard or the Universal Serial Bus (USB) standard, for example. In some embodiments, the function of I\/O interface  may be split into two or more separate components, such as a north bridge and a south bridge, for example. In addition, in some embodiments some or all of the functionality of I\/O interface , such as an interface to system memory , may be incorporated directly into processor .","Network interface  may be configured to allow data to be exchanged between computer system  and other devices attached to a network, such as other computer systems, or between nodes of computer system . In various embodiments, network interface  may support communication via wired or wireless general data networks, such as any suitable type of Ethernet network, for example; via telecommunications\/telephony networks such as analog voice networks or digital fiber communications networks; via storage area networks such as Fibre Channel SANs, or via any other suitable type of network and\/or protocol.","Input\/output devices  may, in some embodiments, include one or more display terminals, keyboards, keypads, touchpads, scanning devices, voice or optical recognition devices, or any other devices suitable for entering or retrieving data by one or more computer system . Multiple input\/output devices  may be present in computer system  or may be distributed on various nodes of computer system . In some embodiments, similar input\/output devices may be separate from computer system  and may interact with one or more nodes of computer system  through a wired or wireless connection, such as over network interface .","As shown in , memory  may include program instructions  configured to implement embodiments of a vector art rendering module as described herein, and data storage  comprising various data accessible by program instructions . In one embodiment, program instructions  may include software elements of embodiments of a vector art rendering module as illustrated in the above Figures. Data storage  may include data that may be used in embodiments. In other embodiments, other or different software elements and data may be included.","Those skilled in the art will appreciate that computer system  is merely illustrative and is not intended to limit the scope of a vector art rendering module as described herein. In particular, the computer system and devices may include any combination of hardware or software that can perform the indicated functions, including a computer, personal computer system, desktop computer, laptop, notebook, or netbook computer, mainframe computer system, handheld computer, workstation, network computer, a camera, a set top box, a mobile device, network device, internet appliance, PDA, wireless phones, pagers, a consumer device, video game console, handheld video game device, application server, storage device, a peripheral device such as a switch, modem, router, or in general any type of computing or electronic device. Computer system  may also be connected to other devices that are not illustrated, or instead may operate as a stand-alone system. In addition, the functionality provided by the illustrated components may in some embodiments be combined in fewer components or distributed in additional components. Similarly, in some embodiments, the functionality of some of the illustrated components may not be provided and\/or other additional functionality may be available.","Those skilled in the art will also appreciate that, while various items are illustrated as being stored in memory or on storage while being used, these items or portions of them may be transferred between memory and other storage devices for purposes of memory management and data integrity. Alternatively, in other embodiments some or all of the software components may execute in memory on another device and communicate with the illustrated computer system via inter-computer communication. Some or all of the system components or data structures may also be stored (e.g., as instructions or structured data) on a computer-accessible medium or a portable article to be read by an appropriate drive, various examples of which are described above. In some embodiments, instructions stored on a computer-accessible medium separate from computer system  may be transmitted to computer system  via transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as a network and\/or a wireless link. Various embodiments may further include receiving, sending or storing instructions and\/or data implemented in accordance with the foregoing description upon a computer-accessible medium. Accordingly, the present invention may be practiced with other computer system configurations.","Various embodiments may further include receiving, sending or storing instructions and\/or data implemented in accordance with the foregoing description upon a computer-accessible medium. Generally speaking, a computer-accessible medium may include storage media or memory media such as magnetic or optical media, e.g., disk or DVD\/CD-ROM, volatile or non-volatile media such as RAM (e.g. SDRAM, DDR, RDRAM, SRAM, etc.), ROM, etc., as well as transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network and\/or a wireless link.","The various methods as illustrated in the Figures and described herein represent example embodiments of methods. The methods may be implemented in software, hardware, or a combination thereof. The order of method may be changed, and various elements may be added, reordered, combined, omitted, modified, etc.","Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. It is intended that the invention embrace all such modifications and changes and, accordingly, the above description to be regarded in an illustrative rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 4B","FIG. 4A"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 4C","FIG. 4B"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 4D","FIG. 4C"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 5","FIG. 4D"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 6B","FIG. 6A"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
