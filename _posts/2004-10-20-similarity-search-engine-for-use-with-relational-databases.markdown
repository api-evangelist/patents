---
title: Similarity search engine for use with relational databases
abstract: The invention provides a system and method for defining a schema and sending a query to a Similarity Search Engine to determine a quantitative assessment of the similarity of attributes between an anchor record and one or more target records. The Similarity Search Engine makes a similarity assessment in a single pass through the target records having multiple relationship characteristics. The Similarity Search Engine is a server configuration that comprises a Gateway for command and response routing, a Virtual Document Manager for document generation, a Search Manager for document scoring, and an Relational Database Management System for providing data persistence, data retrieval and access to User Defined Functions. The Similarity Search Engine uses a unique command syntax based on the Extensible Markup Language to implement functions necessary for similarity searching and scoring.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07020651&OS=07020651&RS=07020651
owner: Infoglide Software Corporation
number: 07020651
owner_city: Austin
owner_country: US
publication_date: 20041020
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims benefit of U.S. Provisional Application No. 60\/356,812, filed on Feb. 14, 2002, and is a divisional application of prior application Ser. No. 10\/365,828, filed on Feb. 13, 2003 Now U.S. Pat No. 6,829,606. Prior application Ser. No. 10\/365,828, filed on Feb. 13, 2003 is incorporated herein by reference.","The invention relates generally to the field of search engines for use with large enterprise databases. More particularly, the present invention enables similarity search engines that, when combined with standard relational database products, gives users a powerful set of standard database tools as well as a rich collection of proprietary similarity measurement processes that enable similarity determinations between an anchor record and target database records.","Information resources that are available contain large amounts of information that may be useful only if there exists the capability to segment the information into manageable and meaningful packets. Database technology provides adequate means for identifying and exactly matching disparate data records to provide a binary output indicative of a match. However, in many cases, users wish to determine a quantitative measure of similarity between an anchor record and target database records based on a broadly defined search criteria. This is particularly true in the case where the target records may be incomplete, contain errors, or are inaccurate. It is also sometimes useful to be able to narrow the number of possibilities for producing irrelevant matches reported by database searching programs. Traditional search methods that make use of exact, partial and range retrieval paradigms do not satisfy the content-based retrieval requirements of many users. This has led to the development of similarity search engines.","Similarity search engines have been developed to satisfy the requirement for a content-based search capability that is able to provide a quantitative assessment of the similarity between an anchor record and multiple target records. The basis for many of these similarity search engines is a comparison of an anchor record band or string of data with target record bands or strings of data that are compared serially and in a sequential fashion. For example, an anchor record band may be compared with target record band #, then target record band #, etc., until a complete set of target record bands have been searched and a similarity score computed. The anchor record bands and each target record band contain attributes of a complete record band of a particular matter, such as an individual. For example, each record band may contain attributes comprising a named individual, address, social security number, driver's license number, and other information related to the named individual. As the anchor record band is compared with a target record band, the attributes within each record band are serially compared, such as name-name, address-address, number-number, etc. In this serial-sequential fashion, a complete set of target record bands are compared to an anchor record band to determine similarity with the anchor record band by computing similarity scores for each attribute within a record band and for each record band. Although it may be fast, there are a number of disadvantages to this \u201cband\u201d approach for determining a quantitative measure of similarity.","Using a \u201cband\u201d approach in determining similarity, if one attribute of a target record band becomes misaligned with the anchor record band, the remaining record comparisons may result in erroneous similarity scores, since each record attribute is determined relative to the previous record attribute. This becomes particularly troublesome when confronted with large enterprise databases that inevitably will produce an error, necessitating starting the scoring process anew. Another disadvantage of the \u201cband\u201d approach is that handling large relational databases containing multiple relationships may become quite cumbersome, slowing the scoring process. Furthermore, this approach often requires a multi-pass operation to fully process a large database. Oftentimes, these existing similarity search engines may only run under a single operating system.","There is a need for a similarity search engine that provides a system and method for determining a quantitative measure of similarity in a single pass between an anchor record and a set of multiple target records that have multiple relationship characteristics. It should be capable of operating under various operating systems in a multi-processing environment. It should have the capability to similarity search large enterprise databases without the requirement to start over again when an error is encountered.","The present invention of a Similarity Search Engine (SSE) for use with relational databases is a system and method for determining a quantitative assessment of the similarity between an anchor record or document and a set of one or more target records or documents. It makes a similarity assessment in a single pass through the target records having multiple relationship characteristics. It is capable of running under various operating systems in a multi-processing environment and operates in an error-tolerant fashion with large enterprise databases.","The present invention comprises a set of robust, multi-threaded components that provide a system and method for scoring and ranking the similarity of documents that may be represented as Extensible Markup Language (XML) documents. This search engine uses a unique command syntax known as the XML Command Language (XCL). At the individual attribute level, attribute similarity is quantified as a score having a value of between 0.00 and 1.00 that results from the comparison of an anchor value attribute (search criterion) vs. a target value attribute (database field) using a distance function that identifies am attribute similarity measurement. At the document or record level, which comprises a \u201croll-up\u201d or aggregation of one or more attribute similarity scores determined by a parent computing or choice algorithm, document or record similarity is a value normalized to a score value of between 0.00 and 1.00 for the document or record. A single anchor document containing multiple attributes, usually arranged in a hierarchical fashion, is compared to multiple target documents also containing multiple attributes.","The example of Table 1 illustrates the interrelationships between attributes, anchor attribute values, target attribute values, distance functions and attribute similarity scores. There is generally a single set of anchor value attributes and multiple sets of target value attributes. The distance functions represent measurement algorithms to be executed to determine an attribute similarity score. There may be token level attributes at a lowest hierarchical level as well as intermediate level attributes between the highest or parent level and the lowest or leaf level of a document or record. Attribute similarity scores at the token level are determined by designated measurement functions to compute a token attribute similarity score of between 0.00 and 1.00. Choice or aggregation algorithms are designated to roll-up or aggregate scores in a hierarchical fashion to determine a document or record similarity score. Different weighting factors may also be used modulate the relative importance of different attribute scores. The measurement functions, weighting functions, aggregation algorithms, anchor document, and target documents are generally specified in a \u201cschema\u201d document. In Table 1, anchor value attributes of \u201cJohn\u201d, \u201cAustin\u201d, and \u201cNavy\u201d are compared with target value attributes of \u201cJon\u201d, \u201cRound Rock\u201d, and \u201cDark Blue\u201d using distance functions \u201cString Difference\u201d, \u201cGeoDistance\u201d, and \u201cSynonymCompare\u201d to compute attribute similarity scores of \u201c0.75\u201d, \u201c0.95\u201d, and \u201c1.00\u201d, respectively.",{"@attributes":{"id":"p-0011","num":"0010"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},"ANCHOR","TARGET","DISTANCE",{}]},{"entry":["ATTRIBUTE","VALUE","VALUE","FUNCTION","SCORE"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","John","Jon","StringDifference","0.75"]},{"entry":["City","Austin","Round Rock","GeoDistance","0.95"]},{"entry":["Shirt Color","Navy","Dark Blue","SynonymCompare","1.00"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"This Similarity Search Engine (SSE) architecture is a server configuration comprising a Gateway, a Virtual Document Manager (VDM), a Search Manager (SM) and an SQL\/Relational Database Management System (RDMS). The SSE server may serve one or more clients. The Gateway provides command and response routing as well as user management functions. It accepts commands from clients and routes those commands to either the VDM or the SM. The purpose of the VDM is XML document generation, particularly schema generation. The purpose of the SM is XML document scoring, or aggregation. The VDM and the SM each receive commands from the Gateway and in turn make calls to the RDMS. The RDMS provides token attribute similarity scoring in addition to data persistence, data retrieval and access to User Defined Functions (UDFs). The UDFs include measurement algorithms for computing attribute similarity scores. The Gateway, VDM and SM are specializations of a unique generic architecture referred to as the XML Command Framework (XCF), which handles the details of threading, distribution, communication, resource management and general command handling.","There are several system objects that the SSE relies on extensively for its operation. These include a Datasource object, a Schema object, a Query object and a Measure object. A Datasource object is a logical connection to a data store, such as a relational database, and it manages the physical connection to the data store. A Schema object, central to SSE operation, is a structural definition of a document with additional markup to provide database mapping and similarity definitions. A Query object is a command that dictates which elements of a database underlying a Schema object should be searched, their search criteria, the similarity measures to be used and which results should be considered in the final output. A Measure object is a function that operates on two strings and returns a similarity score indicative of the degree of similarity between the two strings. These Measure objects are implemented as User Defined Functions (UDFs).","A method having features of the present invention for performing similarity searching comprises the steps of receiving a request instruction from a client for initiating a similarity search, generating one or more query commands from the request instruction, each query command designating an anchor document and at least one search document, executing each query command, including computing a normalized document similarity score having a value of between 0.00 and 1.00 for each search document in each query command for indicating a degree of similarity between the anchor document and each search document, and creating a result dataset containing the computed normalized document similarity scores for each search document, and sending a response including the result dataset to the client. The step of generating one or more query commands may further comprise identifying a schema document for defining structure of search terms, mapping of datasets providing target search values to relational database locations, and designating measures, choices and weight to be used in a similarity search. The step of computing a normalized document similarity score may comprise computing attribute token similarity scores having values of between 0.00 and 1.00 for the corresponding leaf nodes of the anchor document and a search document using designated measure algorithms, multiplying each token similarity score by a designated weighting factor, aggregating the token similarity scores using designated choice algorithms for determining a document similarity score having a value of between 0.00 and 1.00 for the search document. The step of computing attribute token similarity scores may further comprise computing attribute token similarity scores in a relational database management system, the step of multiplying each token similarity score may further comprise multiplying each token similarity score in a similarity search engine, and the step of aggregating the token similarity scores may further comprise aggregating the token similarity scores in the similarity search engine. The step of generating one or more query commands may comprise populating an anchor document with search criteria values, identifying documents to be searched, defining semantics for overriding parameters specified in an associated schema document, defining a structure to be used by the result dataset, and imposing restrictions on the result dataset. The step of defining semantics may comprise designating overriding measures for determining attribute token similarity scores, designating overriding choice algorithms for aggregating token similarity scores into document similarity scores, and designating overriding weights to be applied to token similarity scores. The step of imposing restrictions may be selected from the group consisting of defining a range of similarity indicia scores to be selected and defining percentiles of similarity indicia scores to be selected. The step of computing a normalized document similarity score may further comprise computing a normalized document similarity score having a value of between 0.00 and 1.00, whereby a normalized similarity indicia value of 0.00 represents no similarity matching, a value of 1.00 represents exact similarity matching, and values between 0.00 and 1.00 represent degrees of similarity matching. The step of computing attribute token similarity scores having values of between 0.00 and 1.00 may further comprise computing attribute token similarity scores having values of between 0.00 and 1.00, whereby a attribute token similarity value of 0.00 represents no similarity matching, a value of 1.00 represents exact similarity matching, and values between 0.00 and 1.00 represent degrees of similarity matching. The step of generating one or more query commands may further comprise generating one or more query commands whereby each query command includes attributes of command operation, name identification, and associated schema document identification. The method may further comprise receiving a schema instruction from a client, generating a schema command document comprising the steps of defining a structure of target search terms in one or more search documents, creating a mapping of database record locations to the target search terms, listing semantic elements for defining measures, weights and choices to be used in similarity searches, and storing the schema command document into a database management system. The method may further comprise the step of representing documents and commands as hierarchical XML documents. The step of sending a response to the client may further comprise sending a response including an error message and a warning message to the client. The step of sending a response to the client may further comprise sending a response to the client containing the result datasets, whereby each result dataset includes at least one normalized document similarity score, at least one search document name, a path to the search documents having a returned score, and at least one designated schema. The method may further comprising receiving a statistics instruction from a client, generating a statistics command from the statistics instruction, which may comprise the steps of identifying a statistics definition to be used for generating statistics, populating an anchor document with search criteria values, identifying documents to be searched, delineating semantics for overriding measures, parsers and choices defined in a semantics clause in an associated schema document, defining a structure to be used by a result dataset, imposing restrictions to be applied to the result dataset, identifying a schema to be used for the basis of generating statistics, designating a name for the target statistics table for storing results, executing the statistics command for generating a statistics schema with statistics table, mappings and measures, and storing the statistics schema in a database management system. The method may further comprise the step of executing a batch command comprising executing a plurality of commands in sequence for collecting results of several related operations. The method may further comprise selecting measure algorithms from the group consisting of name equivalents, foreign name equivalents, textual, sound coding, string difference, numeric, numbered difference, ranges, numeric combinations, range combinations, fuzzy, date oriented, date to range, date difference, and date combination. The method may further comprise selecting choice algorithms from the group consisting of single best, greedy sum, overall sum, greedy minimum, overall minimum, and overall maximum. Another embodiment of the present invention is a computer-readable medium containing instructions for controlling a computer system to implement the method above.","In an alternate embodiment of the present invention, a system for performing similarity searching comprises a gateway for receiving a request instruction from a client for initiating a similarity search, the gateway for generating one or more query commands from the request instruction, each query command designating an anchor document and at least one search document, a search manager for executing each query command, including means for computing a normalized document similarity score having a value of between 0.00 and 1.00 for each search document in each query command for indicating a degree of similarity between the anchor document and each search document, means for creating a result dataset containing the computed normalized document similarity scores for each search document, and the gateway for sending a response including the result dataset to the client. The means for computing a normalized similarity score may comprise a relational database management system for computing attribute token similarity scores having values of between 0.00 and 1.00 for the corresponding leaf nodes of the anchor document and a search document using designated measure algorithms, and the search manager for multiplying each token similarity score by a designated weighting factor and aggregating the token similarity scores using designated choice algorithms for determining a document similarity score having a value of between 0.00 and 1.00 for the search document. Each one or more query commands may further comprise a measure designation, and the database management system further comprises designated measure algorithms for computing a token similarity score. Each query command may comprise an anchor document populated with search criteria values, at least one search document, designated measure algorithms for determining token similarity scores, designated choice algorithms for aggregating token similarity scores into document similarity scores, designated weights for weighting token similarity scores, restrictions to be applied to a result dataset document, and a structure to be used by the result dataset. The computed document similarity scores may have a value of between 0.00 and 1.00, whereby a normalized similarity indicia value of 0.00 represents no similarity matching, a value of 1.00 represents exact similarity matching, and values between 0.00 and 1.00 represent degrees of similarity matching. The relational database management system may include means for computing an attribute token similarity score having a value of between 0.00 and 1.00, whereby a token similarity indicia value of 0.00 represents no similarity matching, a value of 1.00 represents exact similarity matching, and values between 0.00 and 1.00 represent degrees of similarity matching. Each query command may include attributes of command operation, name identification, and associated schema document identification for providing a mapping of search documents to database management system locations. The system may further comprise the gateway for receiving a schema instruction from a client, a virtual document manager for generating a schema command document, the schema command document comprising a structure of target search terms in one or more search documents, a mapping of database record locations to the target search terms, semantic elements for defining measures, weights, and choices for use in searches, and a relational database management system for storing the schema command document. The system of claim , wherein each result dataset may include at least one normalized document similarity score, at least one search document name, a path to the search documents having a returned score and at least one designated schema. Each result dataset may include an error message and a warning message to the client. The system may further comprise the gateway for receiving a statistics instruction from a client and for generating a statistics command from the statistics instruction, the search manager for identifying a statistics definition to be used for generating statistics, populating an anchor document with search criteria values, identifying documents to be searched, delineating semantics for overriding measures, weights and choices defined in a semantics clause in an associated schema document, defining a structure to be used by a result dataset, imposing restrictions to be applied to the result dataset, identifying a schema to be used for the basis of generating statistics, designating a name for the target statistics table for storing results, and a statistics processing module for executing the statistics command for generating a statistics schema with statistics table, mappings and measures, and storing the statistics schema in a database management system. The system may further comprise the gateway for receiving a batch command from a client for executing a plurality of commands in sequence for collecting results of several related operations. The system may further comprise selecting measure algorithms selected from the group consisting of name equivalents, foreign name equivalents, textual, sound coding, string difference, numeric, numbered difference, ranges, numeric combinations, range combinations, fuzzy, date oriented, date to range, date difference, and date combination. The system may further comprise choice algorithms selected from the group consisting of single best, greedy sum, overall sum, greedy minimum, overall minimum, and overall maximum.","In another embodiment of the present invention a system for performing similarity searching comprises a gateway for handling all communication between a client, a virtual document manager and a search manager, the virtual document manager connected between the gateway and a relational database management system for providing document management, the search manager connected between the gateway and the relational database management system for searching and scoring documents, and the relational database management system for providing relational data management, document and measure persistence, and similarity measure execution. The virtual document manager may include a relational database driver for mapping XML documents to relational database tables. The virtual document manager may include a statistics processing module for generating statistics based on similarity search results. The relational database management system may include means for storing and executing user defined functions. The user defined functions include measurement algorithms for determining attribute token similarity scores.","Another embodiment of the present invention is a method for performing similarity searching that comprises the steps of creating a search schema document by a virtual document manager, generating one or more query commands by a gateway, executing one or more query commands in a search manager and relational database management system for determining the degree of similarity between an anchor document and search documents, and assembling a result document containing document similarity scores of between 0.00 and 1.00. The step of creating a schema document may comprise designating a structure of search documents, datasets for mapping search document attributes to relational database locations, and semantics identifying measures for computing token attribute similarity search scores between search documents and an anchor document, weights for modulating token attribute similarity search scores, choices for aggregating token attribute similarity search scores into document similarity search scores, and paths to the search document structure attributes. The step of generating one or more query commands may comprise designating an anchor document, search or schema documents, restrictions on result sets, structure of result sets, and semantics for overriding schema document semantics including measures, weights, choices and paths. The step of executing one or more query commands may comprise computing token attribute similarity search scores having values of between 0.00 and 1.00 for each search document and an anchor document in a relational database management system using measures, and modulating the token attribute similarity search scores using weights and aggregating the token attribute similarity scores into document similarity scores having values of between 0.00 and 1.00 in the search manager using choices. The step of assembling a result document may comprise identifying associated query commands and schema documents, document structure, paths to search terms, and similarity scores by the search manager. The search schema, the query commands, the search documents, the anchor document and the result document may be represented by hierarchical XML documents. The method may further comprise selecting measure algorithms from the group consisting of name equivalents, foreign name equivalents, textual, sound coding, string difference, numeric, numbered difference, ranges, numeric combinations, range combinations, fuzzy, date oriented, date to range, date difference, and date combination. The method may further comprise selecting choice algorithms from the group consisting of single best, greedy sum, overall sum, greedy minimum, overall minimum, and overall maximum. Another embodiment of the present invention is a computer-readable medium containing instructions for controlling a computer system to implement the method above.","Before describing the architecture of the Similarity Search Engine (SSE), it is useful to define and explain some of the objects used in the system. The SSE employs a command language based on XML, the Extensible Markup Language. SSE commands are issued as XML documents and search results are returned as XML documents. The specification for Extensible Markup Language (XML) 1.0 (Second Edition), W3C Recommendation 6 Oct. 2000 is incorporated herein by reference. The syntax of the SSE Command Language XCL consists of XML elements, their values and attributes that control the behavior of the SSE. Using SSE commands, a client program can define and execute searches employing the SSE.","The SSE commands are shown here in abstract syntax notation using the following conventions:","Regular type Shows command words to be entered as shown (uppercase or lowercase)","Italics Stands for a value that may vary from command to command","XML tags are enclosed in angled brackets. Indentations are used to demark parent-child relationships. Tags that have special meaning for the SSE Command Language are shown in capital letters. Specific values are shown as-is, while variables are shown in italic type. The following briefly defines XML notation:",{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["<XXX>","Tag for XML element named XXX"]},{"entry":["<XXX attribute=\u201dvalue\u201d\/>","XML element named XXX with specified"]},{"entry":[{},"value for attribute"]},{"entry":["<XXX>value<\/XXX>","XML element named XXX containing value"]},{"entry":["<XXX>","XML element named XXX containing"]},{"entry":["<YYY>value<\/YYY>","element named YYY with the value that"]},{"entry":["<\/XXX>","appears between the tags. In xpath notation,"]},{"entry":[{},"this structure would be written as XXX\/YYY"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The SSE relies primarily on several system objects for its operation. Although there are other system objects, the primary four system objects include a Datasource object, a Schema object, a Query object and a Measure object.","A Datasource object describes a logical connection to a data store, such as a relational database. The Datasource object manages the physical connection to the data store. Although the SSE may support many different types of datasources, the preferred datasource used in the SSE is an SQL database, implemented by the vdm.RelationalDatasource class. A relational Datasource object is made up of attributes comprising Name, Driver, URL, Usemame and Password, as described in Table 2.",{"@attributes":{"id":"p-0068","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["ATTRIBUTE","PURPOSE"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","Within the context of an SSE, the name uniquely"]},{"entry":[{},"identifies this datasource"]},{"entry":["Driver","The actual class name of the JDBC driver used to"]},{"entry":[{},"connect to the relational data store"]},{"entry":["URL","The URL, as defined by the driver, used to locate the"]},{"entry":[{},"datasource on a network"]},{"entry":["Username","The username the SQL database requires for a login"]},{"entry":["Password","The password the SQL database requires for a login"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A Schema object is at the heart of everything the SSE does. A Schema object is a structural definition of a document along with additional markup to provide SQL database mapping and similarity definitions. The definition of a Schema object comprises Name, Structure, Mapping and Semantics, as described in Table 3.",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["ATTRIBUTE","PURPOSE"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","Within the context of an SSE, the name uniquely"]},{"entry":[{},"identifies this schema"]},{"entry":["Structure","The structure clause of a schema defines the XML output"]},{"entry":[{},"format of documents which are built based on"]},{"entry":[{},"this schema."]},{"entry":["Mapping","The mapping clause of a schema defines how each of the"]},{"entry":[{},"elements of the structure map to relational fields and"]},{"entry":[{},"tables as defined by the datasource"]},{"entry":["Semantics","The semantics clause of a schema defines the default"]},{"entry":[{},"similarity settings to be used when issuing a query"]},{"entry":[{},"against this schema\/datasource"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A Query object is an XCL command that dictates which elements of a Schema object (actually the underlying database) should be searched, their search criteria, the similarity measures to be used and which results should be considered in the final output. The Query object format is sometimes referred to a Query By Example (QBE) because an \u201cexample\u201d of what we are looking for is provided in the Query. Attributes of a Query object comprise a Where clause, Semantics, and Restrict, as described in Table 4.",{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["ATTRIBUTE","PURPOSE"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Where clause","The WHERE clause serves as the QBE portion of the"]},{"entry":[{},"query, this is what we are looking for."]},{"entry":["Semantics","The SEMANTICS clause of a query determines how"]},{"entry":[{},"we want to search the database. This includes:"]},{"entry":[{},"similarity functions to use to compare values"]},{"entry":[{},"weights of elements in the overall score"]},{"entry":[{},"how to combine the element scores into an overall score"]},{"entry":["Restrict","The RESTRICT clause of a query dictates which portions"]},{"entry":[{},"of the result we are interested in. E.g. those document"]},{"entry":[{},"that score 0.80 or greater, or the top 20 documents etc.."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A Measure object is a function that takes in two strings and returns a score (between 0.000 and 1.000) of how similar the two strings are. These Measure objects are implemented as User Defined Functions (UDFs) and are compiled into a native library in an SQL Database. Measure objects are made up of attributes comprising Name, Function and Flags, as described in Table 5.",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["ATTRIBUTE","PURPOSE"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","Within the context of an SSE, the name uniquely"]},{"entry":[{},"identifies this measure"]},{"entry":["Function","The associated native measure implementation associated"]},{"entry":[{},"to this name. For example, a measure named"]},{"entry":[{},"\u201cString Difference\u201d may actually call"]},{"entry":[{},"the STDIFF( ) function"]},{"entry":["Flags","There are several other flags that indicated whether"]},{"entry":[{},"the function operates on character data, numeric"]},{"entry":[{},"data, date data etc. or a combination of them."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Turning now to ,  depicts a high level architecture  of the Similarity Search Engine (SSE). The SSE architecture  includes an SSE Server  that comprises a Gateway , a Virtual Document Manager (VDM) , a Search Manager (SM)  and a Relational Database Management System (RDMS) . The Gateway  provides routing and user management. The VDM  enables XML document generation. The SM  performs XML document and scoring. The RDMS  (generally an SQL Database) provides token attribute scoring as well as data persistence and retrieval, and storing User Defined Functions (UDFs) . The SSE Server  is a similarity search server that may connect to one or more Clients  via a Client Network . The SSE Server also connects to a RDMS .","The Gateway  serves as a central point of contact for all client communication by responding to commands sent by one or more clients . The Gateway  supports a plurality of communication protocols with a user interface, including sockets, HTTP, and JMS. The Gateway  is implemented as a gateway.Server class, a direct descendent of the xcf.BaseCommandServer class available in the unique generic architecture referred to as the XML Command Framework (XCF), which handles the details of threading, distribution, communication, resource management and general command handling. The XCF is discussed below in more detail. Therefore, the Gateway  inherits all the default command handling and communication functions available in all XCF Command Servers. The Gateway  relies on several types of command handlers for user definition, user login and logout, and command routing.","To add a user to the system, the Gateway  makes use of a user class to encapsulate what a \u201cuser\u201d is and implements a component class interface, which is inherited from the generic XCF architecture. Instances of XCF Component command handlers used by the Gateway  to add, remove or read a user definition are shown in Table 6.",{"@attributes":{"id":"p-0078","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["COMMAND HANDLER","FUNCTIONALITY"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["xcf.commands.ComponentAdd","Adds a user to the server. In order to"]},{"entry":["(gateway.commands.UserWrite)","properly create the User object to"]},{"entry":[{},"hold a user's information as opposed"]},{"entry":[{},"to a standard component, the"]},{"entry":[{},"ComponentAdd command handler"]},{"entry":[{},"is subclassed by UserWrite."]},{"entry":["xcf.commands.ComponentRemove","Remove a user from the server."]},{"entry":["xcf.commands.ComponentRead","Reads one or all user definitions"]},{"entry":[{},"from the server."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"When a user definition has been added to the system, a user must log in and log out of the system. Instances of command handlers used only by the Gateway  for user login and user logout are shown in Table 7.",{"@attributes":{"id":"p-0080","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["COMMAND HANDLER","FUNCTIONALITY"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["gateway.commands.UserLogin","Retrieves username and password from"]},{"entry":[{},"USER\/login XCL command and"]},{"entry":[{},"validates against list of registered users."]},{"entry":[{},"If successful, validation is returned"]},{"entry":[{},"to requestor and user is added to list"]},{"entry":[{},"of logged in users. If not successful, an"]},{"entry":[{},"error condition is returned to requestor."]},{"entry":["gateway.commands.UserLogout","Retrieves username and password from"]},{"entry":[{},"USER\/logout XCL command and"]},{"entry":[{},"removes user from list of logged"]},{"entry":[{},"in users."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The Gateway  includes several instances of command handlers inherited from the generic XCF architecture to properly route incoming XML Command Language (XCL) commands to an appropriate target, whether it is the VDM , the SM , or both. These command handlers used by the Gateway  for routing are shown in Table 8.",{"@attributes":{"id":"p-0082","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["COMMAND HANDLER","FUNCTIONALITY"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["xcf.commands.SynchronizedPassthrough","Passes an XCL command"]},{"entry":["(SPT)","through to one or more"]},{"entry":[{},"targets, one after the other."]},{"entry":[{},"If one of the commands"]},{"entry":[{},"passed through fails, the"]},{"entry":[{},"command handler reports"]},{"entry":[{},"the failure and terminates"]},{"entry":[{},"execution."]},{"entry":["xcf.commands.Passthrough","Passes an XCL command to"]},{"entry":["(PT)","one target. The target must"]},{"entry":[{},"determine and report success"]},{"entry":[{},"or failure."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Table 9 shows the routing of command types processed by the Gateway , and which command handler shown in Table 8 is relied upon for the command execution.",{"@attributes":{"id":"p-0084","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},"COMMAND",{},"COMMAND"]},{"entry":["COMMAND TYPE","OPERATION","ROUTING","HANDLER"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SCHEMA","Write, Delete","VDM, SM","SPT"]},{"entry":["DATASOURCE","Write, Delete","VDM, SM","SPT"]},{"entry":["DOCUMENT","Write, Delete","VDM, SM","SPT"]},{"entry":["MEASURE","All","SM","PT"]},{"entry":["CHOICE","All","SM","PT"]},{"entry":["STATISTICS","All","SM","PT"]},{"entry":["QUERY","All","SM","PT"]},{"entry":["All others","\u2014","VDM","PT"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":["110","120","110","130"]},"The VDM  is responsible for XML document management, and connects between the Gateway  and the RDMS . The VDM  is implemented by the vdm.Server class, which is a direct descendent of the xcf.BaseCommandServer class available in the unique generic architecture referred to as the XML Command Framework (XCF), which handles the details of threading, distribution, communication, resource management and general command handling. The XCF is discussed below in more detail. Therefore, the VDM  inherits all the default command handling and communication functions available in all XCF Command Servers. Unlike XML databases having proprietary storage and search formats, the VDM  uses existing relational tables and fields to provide dynamic XML generation capabilities without storing the XML documents.","The VDM  provides its document management capabilities through Document Providers. The most visible function to a Client  of the VDM  is the creation and maintenance of SCHEMA documents, which define parameters used for similarity searching. A Document Provider is defined by the vdm.DocProvider interface and is responsible for generating and storing XML documents based on a schema definition. Although described embodiments of the SSE Server  only implement one DocProvider, which is an SQL based document provider, if the DocProvider implements the interface, the document provider can be any source that generates an XML document. For example, document providers may be file systems, web sites, proprietary file formats, or XML databases. For a user to retrieve relational data, the user must know where the data resides and how it is connected. A Datasource object encapsulates all the connection information.","There are several types of command handlers required by the VDM  in order to satisfactorily execute XCL commands. These include the document related command handlers shown in Table 10.",{"@attributes":{"id":"p-0088","num":"0087"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["COMMAND HANDLER","FUNCTIONALITY"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["vdm.commands.DocumentRead","Builds an XML document based on a schema, its"]},{"entry":[{},"mapping, and a primary key, by assembling from records"]},{"entry":[{},"and fields."]},{"entry":["vdm.commands.DocumentWrite","Writes an XML document based on a schema, its"]},{"entry":[{},"mapping, and a primary key, by disassembling into"]},{"entry":[{},"records and fields."]},{"entry":["vdm.commands.DocumentDelete","Deletes an XML document based on a schema, its"]},{"entry":[{},"mapping, and a primary key, by removing relevant"]},{"entry":[{},"records."]},{"entry":["vdm.commands.DocumentCount","Counts the number of unique documents for a particular"]},{"entry":[{},"schema."]},{"entry":["vdm.commands.DocumentLock","Locks a document based on its schema name and primary"]},{"entry":[{},"key. Subsequent locks on this document will fail until it is"]},{"entry":[{},"unlocked."]},{"entry":["vdm.commands.DocumentUnlock","Unlocks a document based on its schema name and"]},{"entry":[{},"primary key."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"120"},{"@attributes":{"id":"p-0089","num":"0088"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["COMMAND HANDLER","FUNCTIONALITY"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["vdm.commands.SchemaWrite","Initializes a DocProvider based on"]},{"entry":[{},"the schema and mapping defined"]},{"entry":[{},"for the schema."]},{"entry":["xcf.commands.ComponentRead","Provides a means to read a schema."]},{"entry":["vdm.commands.SchemaDelete","Uninitializes a DocProvider and drops"]},{"entry":[{},"it from the list of available schemas."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"120"},{"@attributes":{"id":"p-0090","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["COMMAND HANDLER","FUNCTIONALITY"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["vdm.commands.DatasourceWrite","Creates and initializes the"]},{"entry":[{},"vdm.ConnectionInfo object that"]},{"entry":[{},"contains all relevant datasource"]},{"entry":[{},"information."]},{"entry":["vdm.commands.DatasourceDelete","Uninitializes a datasource and"]},{"entry":[{},"removes it from the list of"]},{"entry":[{},"available datasources."]},{"entry":["xcf.commands.ComponentRead","Provides a means to read a"]},{"entry":[{},"datasource."]},{"entry":["vdm.commands.DatasourceMetadata","Connects to the datasource and"]},{"entry":[{},"examines all the tables, field types"]},{"entry":[{},"and lengths, indices, view defined"]},{"entry":[{},"in the datasource so that the"]},{"entry":[{},"DocProvider may make informed"]},{"entry":[{},"decisions on how to best handle"]},{"entry":[{},"the data."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":["120","140"]},"The VDM  includes a Relational Database Driver (RDD)  for providing a link between XML documents and the RDMS . The RDD  implements the DocProvider interface, supporting standard functions defined in that class, including reading, writing and deleting XML documents.","The RDD  is initialized by calling the initialize(String map) function, where this map is an XML document describing the relationships between the XML documents to be dealt with and the relational database. For instance, consider an example XML document  that follows the form shown in . When building an XML document  from the RDMS , Datasets  can specify that the data in claim\/claimant\/name should come from the Claimants table  of the RDMS , while \/claim\/witness\/name should come from the Witnesses table . Conversely, when writing an existing XML document  of this form out to the RDMS , the Datasets  will tell the RDD  that it should write any data found at \/claim\/claimant\/name out to the \u201cname\u201d field of the Claimants table , and write the data found at \/claim\/witness\/name out to the \u201cname\u201d field of the Witnesses table . Through describing these relationships, the Datasets  allows the RDD  to read, write, and delete XML documents for the VDM .","Internally, these Datasets  define relationships that are stored in a Java model. At the beginning of initialization, the XML map  is parsed and used to build a hierarchy of Datasets , one level of hierarchy for each database table referenced in the Datasets . This encapsulation of the XML parsing into this one area minimizes the impact of syntax changes in the XML map . These Datasets  have an XML form and may describe a document based on a relational table or a document based on a SQL statement. If based on a relational table, then initializing the RDD  with these Datasets  will allow full read\/write functionality. However, if based on an SQL statement, then the initialized RDD  will allow documents to be generated from the RDMS , but not to be written out to it. In the common usage, in which the Dataset  is describing a relational table, <BIND> tags define the key fields used in the master-detail relationship. The topmost Dataset's <BIND> tag simply describes its primary key, since it has no relationship with any higher-level Dataset. Dataset <PATH> tags describe where the data being read from the tables in the RDMS  should be stored in the XML document , and visa-versa when writing XML document data to the RDMS. A Dataset <EXPRESSION> tag indicates whether the Dataset describes a document based on a relational table or a document based on an SQL statement.","The VDM  relies on three functions to provide the functionality of building XML documents from underlying RDMS. Each of these three functions returns the resultant document(s) as a String. The functions are singleRead, multipleRead and expressionRead.","Consider the singleRead function:\n\n","Consider the expressionRead function:\n\n","Consider the multipleRead function:\n\n","Composition of documents follows a basic algorithm. A row is taken from the topmost array of arrays, the one representing the master table of the document. The portion of the XML document that takes information from that row is built. Next, if there is a master-detail relationship, the detail table is dealt with. All rows associated with the master row are selected, and XML structures built from their information. In this manner, iterating through all of the table arrays, the document is built. Then, the master array advances to the next row, and the process begins again. When it finishes, all of the documents will have been built, and they are returned in String form.","The VDM relies on two functions for writing XML documents out to an underlying RDMS. These functions are singlewrite and multipleWrite. Consider the singlewrite function:\n\n","Consider the multiplewrite function:\n\n","The VDM relies on three methods for deleting the data represented in an XML document from the underlying RDMS. The functions are singleDelete, multipleDelete and expressiondelete. Consider the singleDelete function:\n\n","Consider the multipleDelete function:\n\n","Consider the expressionDelete function:\n\n","The SM  is responsible for XML document and SQL searching and scoring, and connects between the Gateway  and the RDMS . The SM  is implemented as a search.Server class, which is a direct descendent of the xcf.BaseCommandServer class available in the unique generic architecture referred to as the XML Command Framework (XCF), which handles the details of threading, distribution, communication, resource management and general command handling. The XCF is discussed below in more detail. Therefore, the SM  inherits all the default command handling and communication functions available in all XCF Command Servers. The SM  does not maintain any of its own indexes, but uses a combination of relational indexes and User Defined Functions (UDFs)  to provide similarity-scoring methods in addition to traditional search techniques. The SM  sends commands to the RDMS  to cause the RDMS  to execute token attribute similarity scoring based on selected UDFs. The SM  also performs aggregation of token attribute scores from the RDMS  to determine document or record similarity scores using selected choice algorithms. SQL commands sent by the SM  to the RDMS  are used execute functions within the RDMS  and to register UDFs  with the RDMS .","There are several types of command handlers required by the SM  in order to satisfactorily execute XCL commands. These include schema, datasource, measure (UDF), and choice related command handlers. The schema related command handlers are shown in Table 13.",{"@attributes":{"id":"p-0106","num":"0114"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["COMMAND HANDLER","FUNCTIONALITY"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["search.commands.SchemaWrite","Stores a simple XML version of"]},{"entry":[{},"a schema."]},{"entry":["xcf.commands.ComponentRead","The default component reader"]},{"entry":[{},"provides a means to read a schema."]},{"entry":["vdm.commands.ComponentRemove","The default component deleter"]},{"entry":[{},"provides a means to delete"]},{"entry":[{},"a schema."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"130"},{"@attributes":{"id":"p-0107","num":"0115"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 14"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["COMMAND HANDLER","FUNCTIONALITY"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["search.commands.DatasourceWrite","Creates and initializes the"]},{"entry":[{},"vdm.ConnectionInfo object that"]},{"entry":[{},"contains all relevant datasource"]},{"entry":[{},"connection information."]},{"entry":["vdm.commands.ComponentRemove","The default component deleter"]},{"entry":[{},"provides a means to delete"]},{"entry":[{},"a datasource."]},{"entry":["xcf.commands.ComponentRead","The default component reader "]},{"entry":[{},"provides a means to read a"]},{"entry":[{},"datasource."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"130"},{"@attributes":{"id":"p-0108","num":"0116"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 15"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["COMMAND HANDLER","FUNCTIONALITY"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["search.commands.MeasureWrite","Stores an XML version of"]},{"entry":[{},"a measure"]},{"entry":["xcf.commands.ComponentRead","The default component reader"]},{"entry":[{},"provides a means to read a"]},{"entry":[{},"measure."]},{"entry":["vdm.commands.ComponentRemove","The default component deleter"]},{"entry":[{},"provides a means to delete a"]},{"entry":[{},"measure."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"130"},{"@attributes":{"id":"p-0109","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 16"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["COMMAND HANDLER","FUNCTIONALITY"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["search.commands.ChoiceWrite","Stores an XML version of"]},{"entry":[{},"a choice."]},{"entry":["xcf.commands.ComponentRead","The default component reader"]},{"entry":[{},"provides a means to read a choice."]},{"entry":["vdm.commands.ComponentRemove","The default component deleter"]},{"entry":[{},"provides a means to delete"]},{"entry":[{},"a choice."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":["130","140"]},"A similarity search is generally initiated when the Gateway  receives a QUERY command containing a search request from a Client , and the Gateway  routes the QUERY command to the SM . The SM  generally executes the QUERY command by accessing a SCHEMA previously defined by a Client  and specified in the QUERY command, and parsing the QUERY command into a string of SQL statements. These SQL statements are sent to the RDMS  where they are executed to perform a similarity search of token attributes and scoring of the attributes of the target documents specified in the SCHEMA and stored in the RDMS . The attribute similarity scores are then returned to the SM  from the RDMS  where weighting factors specified in the SCHEMA are applied to each score and Choice algorithms specified in the SCHEMA aggregate or \u201croll-up\u201d the attribute scores to obtain an overall similarity score for each target document or record specified in the SCHEMA or QUERY command. The scores are then returned to the Gateway  by the SM  in a RESULT document, which is then returned to the Client .","As an example of attribute scoring by the SM , consider the following SQL statement sent by the SM  to the RDMS :\n\n",{"@attributes":{"id":"p-0112","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE 17"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"CUSTOMER ID","SIMILARITY SCORE - FIRST NAME"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1","1.0"]},{"entry":[{},"2","0.0"]},{"entry":[{},"3","0.75"]},{"entry":[{},"4","0.50"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Taking this example further, with more attributes, we could score more data with the SQL statement sent to the RDMS  by the SM :\n\n",{"@attributes":{"id":"p-0114","num":"0126"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"center"}}],"thead":{"row":{"entry":[{},"TABLE 18"]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]},{"entry":[{},"SIMILARITY SCORE"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CUSTOMER ID","FIRST NAME","MIDDLE NAME","LAST NAME"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","1.0","1.0","1.0"]},{"entry":["2","0.0","0.0","0.0"]},{"entry":["3","0.75","1.0","0.72"]},{"entry":["4","0.50","0","0.1"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":["130","140","140","130"]},"In addition to this behavior, we can selectively limit the documents returned\/examined by applying restriction logic to the search. Consider the SQL statement sent by the SM  to the RDMS :\n\n",{"@attributes":{"id":"p-0116","num":"0132"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"center"}}],"thead":{"row":{"entry":[{},"TABLE 19"]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]},{"entry":[{},"SIMILARITY SCORE"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CUSTOMER ID","FIRST NAME","MIDDLE NAME","LAST NAME"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","1.0","1.0","1.0"]},{"entry":["3","0.75","1.0","0.72"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":["2","4"]},"Once a set of attribute scores is returned from the RDMS , the SM  determines the overall score of a record (or document) by aggregation through use of a Choice algorithm specified in the associated SCHEMA. An example of aggregation may be simple averaging the scores of the attribute after first multiplying them by relative weight factors, as specified in a QUERY command. In the example case, all fields are weighted evenly (1.00), and therefore the score is a simple average.  depicts an example of a RESULT document from the example of Table 19.","The Statistics Processing Module (SPM)  enables the acquisition of statistical information about the data stored in search tables in the RDMS , using the built-in functions available in the RDMS . This enables the definition of statistics after search data has been stored in the RDMS . The Statistics Processing Module (SPM)  gives the user the ability to specify the fields upon which they wish to obtain statistics. The list of fields selected will act as a combination when computing occurrences. For example, the most frequently occurring first, middle, and last name combination. In addition to the fields, the user will be able to provide count restriction (e.g., only those with 4 or more occurrences) along with data restriction (e.g., only those records in Texas).","Turning now to ,  depicts a process  for handling a STATISTICS command in a Search Manager (SM)  when the SSE Server  receives a STATISTICS command and a CommandHandler is invoked to handle the process. When the SM  receives a STATISTICS command, the Statistics Definition to be used in the generation process is identified . The SCHEMA (search table) from which these statistics are based is then identified . Next, an SQL statement is issued to extract the necessary statistical information from the SCHEMA . If the results of a QUERY command are not already present, a new statistics table is created to store the results of a QUERY command . The statistics table is then populated with the results of the QUERY command . A statistics SCHEMA (with mapping and measures) is generated . And lastly, the newly created statistics SCHEMA is added to the SM  so that the statistics table becomes a new search table and is exposed to the client as a searchable database .  depicts the dataflow  in the statistics command process of .","Statistic Definitions are considered Components that fit into the ComponentManager architecture with their persistence directory being \u201cstatistics\u201d, as described below with regard to the CommandServer of the XCF. The management commands are handled by the ComponentAdd, ComponentRemove and ComponentRead CommandHandlers available in the CommandServers registered CommandHandlers.","Turning back to , the RDMS  is generally considered to be an SQL database, although it is not limited to this type of database. In one embodiment of the present invention, the RDMS  may comprise a DB Relational Database Management System by IBM Corporation. The SM  communicates with the RDMS  by sending commands and receiving data across a JDBC application programming interface (API). The SM  is able to cause the RDMS  to execute conventional RDBMS commands as well as commands to execute the User Defined Functions (UDFs)  contained in a library in the RDMS  for providing similarity-scoring methods in addition to traditional search techniques. The VDM  also communicates with the RDMS  via a JDBC application programming interface (API).","UDFs  provide an extension to a Relational Database Management System (RDMS) suite of built-in functions. The built-in functions include a series of math, string, and date functions. However, none of these built-in functions generally provide any similarity or distance functional capability needed for similarity searching. The UDFs  may be downloaded into the RDMS  by the SSE server  provide the functions required for similarity searching. UDFs  may be written in C, C++, Java, or a database-specific procedure language. The implementations of these UDFs  are known as Measures. The Measures compare two strings of document attributes and generate a score that is normalized to a value between 0.00 and 1.00. They can be called from any application that has knowledge of the signature of the function, for example, parameters, type, and return type. For a RDMS  to be capable of calling UDFs , the function signatures must match what the database expects a UDF  to be, and the function library and entry point must be declared to the RDMS . The library of functions are compiled and deployed into the UDF library directory of the host RDMS , and the UDFs  are registered with the RDMS  by an SQL command. The measures are described below in more detail.","Turning now to ,  describes the Measures implemented as UDFs  in an embodiment of the SSE. The term \u201ctokenized Compare\u201d is used in the Measure descriptions of . In the present context, it means to use domain-specific (and thus domain-limited) knowledge to break the input strings into their constituent parts. For example, an attribute of a street address can be broken down into tokens comprising Number, Street Name, Street Type, and, optionally, Apartment. This may improve the quality of scoring by allowing different weights for different tokens, and by allowing different, more specific measures to be used on each token.","Turning now to ,  depicts an architecture of the XML Command Framework (XCF) . The Gateway, VDM and SM described above each rely on the flexible design of the XCF  for core processing capability. The XCF  functions as XML in and XML out, that is, it generates an XML response to an XML command. It is based upon a unique XML command language XCL that strongly focuses on the needs of search applications. The details of XCL are described below. The architecture of the XCF  comprises the following major entities: CommandServer  for configuration, overall flow, and central point of contact; CommandExecutor  for executing XML commands and providing XML result; CommandResponse  for receiving XML results; CommandHandlerFactory  for registration and identification of CommandHandlers ; Component Manager  for management of Components , Acceptors  and Connectors , Interceptors , and LifetimeManagers ; and CommandDispatcher  containing a Queue  for CommandHandler  thread management. CommandHandlers  process individual XML commands. Components  are pluggable units of functionality. Connectors  and Acceptors  provide for communication into and out of the CommandServer . Interceptors  hook to intercept incoming commands. LifetimeManagers  manage lifetime of CommandHandler  execution. Each of these entities is defined as an interface that allow for multiple implementations of an entity. Each interface is an object that has at least one base implementation defined in XCF. Each interface is limited to the contract imposed by the interface.","The CommandServer  is the central point-of-contact for all things in the XCF. It is responsible for overall execution flow and provides central access to services and components of the system. Most objects that reference the XCF services are passed a CommandServer reference in a constructor or in a setter method. Central access to synchronization objects can be placed here, as all supporting objects will have access. Being the central point of most things, it is also responsible for bootstrapping, initialization and configuration.","The interface to the CommandExecutor  is defined as:\n\n","The CommandResponse interface  must be implemented when calling a CommandExecutor  execute method. The contract is:\n\n","The CommandHandlers  provide means for interpreting and executing XML commands for solving a particular problem. For each problem that needs a solution, there is an assigned CommandHandler . First, consider a standard XML command:\n\n",{"@attributes":{"id":"p-0129","num":"0148"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"224pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 20"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["ATTRIBUTE","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Type","This is the name by which common commands are grouped. It is analogous"]},{"entry":[{},"to a noun representing an object. There are many types of"]},{"entry":[{},"CommandHandlers, including DATASOURCE, SCHEMA, DOCUMENT,"]},{"entry":[{},"etc. They are shown above in Table 4."]},{"entry":["Action","This is the action or operation that is to be performed on this object. This is"]},{"entry":[{},"analogous to a verb. Examples include READ, WRITE, DELETE,"]},{"entry":[{},"EXECUTE, etc."]},{"entry":["Version","This indicates the version of the command that this CommandHandler is"]},{"entry":[{},"expecting. For example, there could be multiple DOCUMENT\/READs"]},{"entry":[{},"registered, each with its own version. As the XML Command Language"]},{"entry":[{},"(XCL) evolves, the version allows maintaining of backward compatibility for"]},{"entry":[{},"old syntaxes while enabling the addition of new CommandHandlers in"]},{"entry":[{},"different versions for supporting new syntaxes."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The command handlers  provide template methods for the following functions:\n\n","There are several standard CommandHandlers  that are responsible for overall management of the CommandServer . These are shown in Table 21 along with the CommandHandler PassThrough, which is not automatically registered.",{"@attributes":{"id":"p-0132","num":"0155"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 21"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["COMMANDHANDLERS","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ComponentAdd","Serves as a general-purpose handler to add new components to the"]},{"entry":[{},"system. It is a template for ensuring components are configured,"]},{"entry":[{},"activated and added properly. The BaseCommandServer makes"]},{"entry":[{},"use of this CommandHandler 742 for CONNECTORS,"]},{"entry":[{},"ACCEPTORS and INTERCEPTORS."]},{"entry":["ComponentRemove","Serves as a general-purpose handler to remove existing"]},{"entry":[{},"components from the system and ensuring they are deactivated"]},{"entry":[{},"correctly. This CommandHandler 742 is used for CONNECTORS,"]},{"entry":[{},"ACCEPTORS and INTERCEPTORS."]},{"entry":["ComponentRead,","Dedicated to return component configuration information."]},{"entry":["ComponentList","ComponentRead returns a configuration for a particular item or"]},{"entry":[{},"items, whereas ComponentList only returns the names of the items."]},{"entry":["CommandStatus,","These CommandHandlers 742 handle command status and"]},{"entry":["CommandCancel","command cancellation."]},{"entry":["SystemCleanup","This CommandHandler 742 calls a garbage collector."]},{"entry":["DoNothing","This is a utility handler that makes sure the system can respond to"]},{"entry":[{},"commands."]},{"entry":["BatchExecute","This handler is a general-purpose wrapper for executing sub-"]},{"entry":[{},"commands nested in a BATCH op = \u201cexecute\u201d command."]},{"entry":["PassThrough","If a command will not be handled by one CommandServer 710,"]},{"entry":[{},"this CommandHandler 742 can be registered to pass the command"]},{"entry":[{},"to a CommandConnector for passage to another CommandServer"]},{"entry":[{},"710."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The CommandHandlerFactory  serves as a factory for CommandHandlers . There is only one instance of this object per CommandServer . This object is responsible for the following functions:\n\n","A Component  is identified by its type and name. The type enables grouping of Components  and name uniquely identifies Components  within the group. The Component  is responsible for determining its name, and ComponentManager  handles grouping on type. The lifecycle of a component  is:\n\n","Since the Component interface is very flexible and lightweight, many system objects are defined as Components . These include CommandAcceptors , CommandConnectors , CommandInterceptors , and LifetimeManager . If a Component  does not perform any function, but is simply a definition, a generic utility Component  implementation may be used. This utility only ensures that the configuration of the Component  is valid XML and it has a name=\u201cxxx\u201d at the root level.","The CommandDispatcher  exposes a single method for InterruptedException. The ComrnmandDispatcher interface  differs from the CommandExecutor  because it expects an initialized CommandHandler  rather than an XML string, and it delegates the command response functionality to the CommandHandler  itself. Internally, the BaseCommandDispatcher uses a PooledExecutor. As a command is added, it is placed in this bounded pool and when a thread becomes available, the CommandHandler's run( ) method is called.","The function of the LifetimeManager  is to keep track of any objects that requires or requests lifetime management. A LifetimeManager  is an optional part of a CommandServer  and is not explicitly listed in the CommandServer interface . It can be registered as a separate Component , and can manage anything that implements the LifetimeManager interface . The only objects that require Lifetime management are CommandHandlers . During its setup, the BaseCommandServer creates a CommandLifetimeManager component that is dedicated to this task of managing the lifetime of commands\/CommandHandlers  that enter the system. CommandHandlers themselves do not implement the Lifetime Manager interface .","CommandInterceptors  are components that can be added to a CommandServer . Their function is to intercept commands before they are executed. Implementations of CommandInterceptor  should raise a CommandlnterceptionException if evaluation fails. BaseCommandServer  will evaluate all registered Interceptors  before calling the dispatcher. If one fails, the dispatcher will not be called and the CommandInterceptorException's getMessage( ) will be placed in the error block of the response.","The Acceptor  and Connector  pair is an abstraction of the communication between clients and CommandServers , and between a CommandServers  and other CommandServers . CommandAcceptors  and CommandConnectors  extend the Component interface , and are therefore seen by the CommandServer  as Components  that are initialized, configured, activated and deactivated similar to all other Components . The ComponentManager  manages acceptors  and Connectors .","A CommandAcceptor  is an interface that defines how commands are accepted into a CommandServer . It is the responsibility of the CommandAcceptor  to encapsulate all the communication logic necessary to receive commands. It passes those commands (in string form) to the CommandServer  via its CommandExecutor interface . Once a command is successfully executed, it is the responsibility of the CommandAcceptor  to pass the result back across the communication channel.","Similar to the CommandAcceptor , the CommandConnector  encapsulates all the communication logic necessary for moving commands across a \u201cwire\u201d, but in the case of a Connector , it is responsible for sending commands, as opposed to receiving commands. It is a client's connection point to a CommandServer . For every CommandAcceptor implementation , there is generally a CommandConnector implementation . The CommandConnector interface  extends the CommandExecutor interface , thereby implying that it executes commands. This enables location transparency as both CommandServer  and CommandConnector  expose the CommandExecutor interface .","As discussed, CommandAcceptors  and CommandConnectors  are Components  that are managed by a CommandServer's ComponentManager . The Acceptors  and Connectors  are the clients' view of the CommandServer . Several implementations of Acceptor\/Connector interfaces provide most communication needs. These classes are shown in Table 22.",{"@attributes":{"id":"p-0143","num":"0178"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 22"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"PROTOCOL","ACCEPTOR","CONNECTOR"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Sockets","raw.RawAcceptor","raw.RawConnector"]},{"entry":[{},"HTTP","http.HTTPAcceptor","http.HTTPConnector"]},{"entry":[{},"JMS","jms.JMSAcceptor","jms.JMSConnector"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":"754"},"Turning now to ,  depicts a process  for handling an XCL command in a CommandServer . An XCL command is formulated, a CommandResponse object is provided, and a CommandServer's CommandExecutor interface is called . Inside the CommandServer , the CommandExecutor  calls a CommandHandlerFactory  with a raw XCL command string . Inside the CommandHandlerFactory , the XCL command string is parsed, a registered CommandHandler  is found with the same TYPE, action and version signature as the XCL command, a CommandHandler prototype is cloned with the runtime state information, and it is passed back to the CommandServer . The CommandServer  gives the newly cloned CommandHandler  a reference and the same CommandResponse object provided in the first step . The CommandServer  then delegates execution of the CommandHandler  to the CommandDispatcher  by placing it in its Queue , . When ready, the CommandDispatcher  will grab a thread from the Queue , . The CommandDispatcher  will then call the CommandHandler run( ) method . Once running, the CommandHandler  can do whatever is required to satisfy the request, making use of system services of the CommandServer , . Once a result (or error) has been generated, the CommandHandler  places the value in setResult( ), loads its CommandResponse object setValue( ) with result, and the result passes back to the caller .  depicts a dataflow  of an XCL command process steps shown in  in a CommandServer architecture.","The SSE employs a Command Language based on XML, the Extensible Markup Language. This Command Language is called XCL. XCL commands are issued as XML documents and search results are returned as XML documents. The syntax of XCL consists of XML elements, their values and attributes, which control the behavior of the Similarity Search Engine Server. Using XCL commands, a client program can define and execute searches employing the SSE Server.","This description introduces the Application Programming Interface (API) for the SSE Server. All SSE commands are formed in XML and run through the execute interface, which is implemented for both Java and COM. For Java, there are synchronous and asynchronous versions. For COM, the interface is always synchronous. For both versions, there are similar methods. The first accepts a string and would be appropriate when the application does not make extensive use of XML, or when it wants to use the SAX parser for speed and does not employ an internal representation. The other method accepts a DOM instance and opens the door to more advanced XML technologies such as XSL.","Turning now to ,  depicts the general XCL command format. Logically, XCL commands look like XML documents. Each command is a document and its clauses are elements. Command options are given by element or attribute values. The XCL command language provides three main types of commands for building similarity applications\u2014a SCHEMA command that defines the document set for the similarity search, a QUERY command that searches the document set, and some administrative commands for managing documents, queries, measures, and so on. The SCHEMA command has three main clauses. A STRUCTURE clause describes the structure of the documents to be searched, arranging data elements into an XML hierarchy that expresses their relationships. A MAPPING clause maps search terms with target values from the datasources. A SEMANTICS clause indicates how similarity is to be assessed. The QUERY command also has several clauses. A WHERE clause indicates the structure and values for the search terms. A FROM clause describes the datasources to be accessed. SELECT and RESTRICT clauses describe the result set and scoring criteria. And an optional SEMANTICS clause overrides semantics defined in the SCHEMA. The administrative commands allow the application to read, write, and delete the documents, queries, schemas, measures, parsings, choices, and datatypes used in the search. For multi-user situations, a simple locking protocol is provided.","XCL commands return result sets in the form of XML documents. The QUERY command contains similarity scores for the documents searched. The result set can return scores for entire documents or for any elements and attributes they contain. In case of problems, the result set contains error or warning messages. Results can be returned synchronously or asynchronously. The synchronous calls block until the result set is ready, while the asynchronous calls return immediately with results returned via a callback coded in the client. Depending on the needs of the application, the results can be retrieved in either string or DOM format. The ResultSet class used by SSE Command Language mimics the ResultSet class for JDBC, allowing applications to iterate through the results to access their contents.","All XCL commands operate on XML documents and produce document sets as results. An XML document begins at a top node (the root element), and elements can be nested, forming a hierarchy. The bottom or \u201cleaf\u201d nodes contain the document's content (data values). A document set is a collection of documents with the same hierarchical layout, as defined by the schema for the search. An anchor document is a hierarchy of XML elements that represent the data values to be used as search criteria. Currently, there can be only one instance of each element in the anchor document. However, the target documents can have repeated groups.","Turning now to ,  depicts a hierarchical layout  that allows multiple tables ,  to be mapped onto the search document  via datasets ,  through the use of the VDM Relational Database Driver  discussed above. The Database values are mapped to their corresponding places in the virtual XML document to be searched. A target document  is a hierarchy of values drawn from a relational database , . Values from the Relational Database ,  are captured via OBDC or JDBC. Target documents can span multiple tables, joined by master\/detail fields. Documents examined by the SSE Server are virtual in the sense that they provide hierarchical representations that match the structure of the search schema while the data they contain still resides in the database tables , . In many cases, the target documents are a direct reflection of tables being tapped in the search. Each valued element corresponds to field (column) in a table, and group elements correspond to the tables themselves , . The hierarchical layout allows multiple tables ,  to be mapped onto the virtual XML search document , even tables from other databases in the case of a cross-database search. The relationship between the target documents and datasource is mapped as part of the schema defined for the search. A database can have many schemas, providing different ways of searching it.","Turning now to ,  depicts the format of a SCHEMA command. The SCHEMA command enables a user to manage the schema for a search document, defining the hierarchical structure of the document and mapping its elements to data sources and similarity measures. A SCHEMA command for a search document comprises of its STRUCTURE clause, its MAPPING clause, and its SEMANTICS clause. The STRUCTURE clause defines the search terms and their relationships in XML format. The MAPPING clause defines the target values and where they reside. The SEMANTICS clause can include overrides to the default similarity measures, choices, and weights. Schemas can be listed, read, written, deleted, locked, and unlocked by the SCHEMA command, as required. Search schemas must be coded manually according to the syntax given here. Predefined datatypes provide shortcuts for those wishing to use standard domain-oriented elements and measures. Search schemas normally reside in an SSE schema repository. The \u201clist\u201d operator of the SCHEMA command returns a childless <SCHEMA> element for each schema in the repository. With a \u201cread\u201d operator, the SCHEMA command returns the schema indicated. Or if the schema name is given as \u201c*\u201d, the \u201cread\u201d operator returns all schemas in the directory. The \u201cwrite\u201d operator causes the SCHEMA command to write the specified search schema into the directory, overwriting any existing schema with the same name. The \u201cdelete\u201d operator purges the specified document. The \u201clock\u201d and \u201cunlock\u201d operations provide a simple locking protocol to prevent conflicting updates in case several DOCUMENT operations are attempted at once by different clients. The operation attribute returns as \u201clocked\u201d or \u201cdenied\u201d to indicate the success of the operation. For example, the command <SCHEMA op=\u201clist\u201d name=\u201c*\u201d\/> calls for a list of schemas shown in .","Turning now to ,  depicts the format for a STRUCTURE clause. The SSE Server uses the hierarchical structure of the XML anchor document to express definitions, options, and overrides throughout the XCL command language. The XML structure of the anchor document is defined in the STRUCTURE clause, specifying the data elements involved in the search along with their positions in the search document. The SEMANTICS clause refers to this structure in mapping these elements to information sources, similarity measures, and so on. A unique aspect of the XML hierarchy shown in the STRUCTURE clause is that no values are given. Elements that represent search terms are shown as empty\u2014i.e., just the XML tag. The values are to be supplied by the associated datasources. In the case of a \u201cflat\u201d search, all the target values are for child elements belonging to the parent. In a \u201chierarchical\u201d search, the search terms may occur at different levels of the hierarchy with multiple occurrences of values for child elements. However, the anchor document cannot specify repeated values.  depicts an example of a STRUCTURE clause for a hierarchical search.","Turning now to ,  depicts the format of the MAPPING clause, which associates elements in the anchor document with target fields in the database. The MAPPING clause governs the mapping between elements of the XML search document and the elements of a relational database. Its contents are: database name, location, driver, username, and password. When multiple databases are connected, the mapping also indicates the node in the search document schema to populate with data from the database. Each database table or view is represented by a dataset, which gives the bindings of database fields to elements and attributes in the search schema. Datasets bind with each other to join the database tables into a hierarchy that matches the structure of the search schema. The MAPPING clause for a relational datasource contains a <DATASET> element for every table in the database that contains target values for the search. <DATASET> contains the datasource attribute that identifies the object used as the datasource. The <DATASET> also contains an <EXPRESSION> element that tells SSE that the datasource is a relational table. The <DATASET> also includes a <PATH> element that indicates which element in the search schema contains the search terms for target values drawn from the table. Target values are mapped to the search schema with a <FIELD> element for each field to be included. The <DATASET> for a relational table also contains a <BIND> element that defines master\/detail relationships with other tables. This binding resembles a JOIN operation by the DBMS, associating a foreign key in the detail table with a primary key in the master table.  depicts an example of a MAPPING clause. For example the <MAPPING> may include two <DATASET> elements, the first to describe the master Product table, and the second to describe the detail Model table.","Turning now to ,  depicts the format of the SEMANTICS clause, which assigns measures, choices, and weights to search terms. The SEMANTICS clause provides intelligence to guide the search. By default, standard measures based on datasource datatypes are assigned to the search terms. Sometimes these provide adequate results, but other times applications require measures that take into account the way the data is used. New semantics are assigned with the APPLY clause, which consists of a repeatable PATH clause and up to one each of the following: MEASURE clause, CHOICE clause, and WEIGHT clause. The PATH clause indicates an element in the search schema that is to receive new semantics. The xpath notation traces a hierarchical path to the element beginning at the root. When several elements are to receive the same semantics, they can be listed in the same <APPLY> clause. The MEASURE clause allows the use of refined measures for the elements indicated in the APPLY clause. For those elements, the measure specified in the MEASURE clause takes precedence over any measure specified in the original schema. The specified measure can either be a variation on the standard measure, a new measure defined using the SSE syntax, or a user-coded measure. The CHOICE clause enables a different pairing algorithm to be assigned to parsed values of the elements indicated in the APPLY clause. These algorithms perform aggregation of the similarity search scores of the attributes determined by the measure algorithms. The WEIGHT clause allows a relative weight to be assigned to the scores of the elements listed in the APPLY clause. By default, all elements and attributes belonging to the same parent are assigned equal weights. That is, the scores of the child elements and attributes are averaged to produce the score for the parent. If necessary, the scores are normalized to produce an overall score in the range 0.00 to 1.00. For example, in scoring a name, <LAST> might be assigned a WEIGHT of 0.70, <MIDDLE> a WEIGHT of 0.10, and <FIRST> a WEIGHT of 0.20. The resulting score for would then be calculated as:\n\nscore=(0.70)*(score<LAST>)+(0.10)*(score<MIDDLE>)+(0.20)*(score<FIRST>).\n\nWithout the WEIGHT clause, the calculation would be:\n\nscore=(score<LAST>+score<MIDDLE>+score <FIRST>)\/3.\n","Turning to ,  depicts the hierarchical structure  of the SCHEMA command . As described above, the SCHEMA command  comprises a STRUCTURE clause , a SEMANTICS clause  and a MAPPING clause . The SEMANTICS clause  comprises a MEASURE clause  for identifying Measures  to be used for scoring document attribute tokens, a CHOICE clause  for identifying the Aggregation algorithms  for \u201crolling up\u201d token scores to obtain document scores, a WEIGHTING clause  for emphasizing or de-emphasizing token scores, and a PATH clause  for indicating a path to an element of a search schema in a RDMS to which the SEMANTICS clause  will apply. The MEASURE clause  contains a partial list of MEASURES algorithms  for determining token attribute scores.  above describes a more detailed list of MEASURE algorithms. The CHOICE clause  contains a partial list of CHOICE algorithms  for aggregating token scores into document scores.","Turning now to , Figure depicts the format of the QUERY command. The QUERY command initiates a similarity search, which scores matches between search terms indicated in a WHERE clause and target values drawn from the relational datasource indicated in the FROM clause. The RESTRICT clause and SELECT clause determine what results are returned. The QUERY command looks to the search schema for the structure and semantics of the search, or to subordinate SEMANTICS clauses that override the default settings in the schema document.","The format of the WHERE clause is shown in . The WHERE clause indicates the anchor to be compared to target values drawn from the datasources specified in the FROM clause. The anchor document is structured as a hierarchy to indicate parent\/child relationships, reflecting the STRUCTURE clause of the search schema. For the SSE Server, the WHERE clause takes the form of an XML document structure populated with anchor values, i.e. the values that represent the \u201cideal\u201d for the search. This document's structure conforms to the structure of the search schema. However, only the elements contributing to the similarity need to be included. Hierarchical relationships among elements, which would be established with JOIN operations in SQL, are represented in SSE Command Language by the nesting of elements in the WHERE clause. No matter where they occur in the document structure, all elements included in the WHERE clause are scored against the target values drawn from the associated datasource. Unlike its SQL counterpart, the SSE Server's WHERE clause does not always qualify or select a collection of records for further processing. In a similarity search, every target value receives a score. The results returned to the application client can be controlled with RESTRICT and SELECT clauses, but the similarity search looks at every document. The SSE's WHERE clause tells the SSE Server which elements and attributes to score. A more direct comparison in SQL might be the list of data items in the main clause of the command.  depicts an example of the WHERE clause. A WHERE clause is required in any QUERY that does similarity scoring. Without a WHERE clause, a QUERY can still return documents according the SELECT clause.","The format of the FROM clause is shown in . The FROM clause associates the QUERY with the document set being searched. The FROM clause identifies the set of documents to be examined in the search. These are virtual documents drawn from relational datasources according to a predefined mapping. The FROM clause offers two ways to identify search documents. The first draws target values from a relational datasource through the VDM. The second presents the documents themselves as part of the FROM clause.  depicts examples of a FROM clause that indicates the search should examine the entire set for \u201cacme_products\u201d.  depicts an example of a FROM clause that indicates the search should examine the documents shown.","Turning now to ,  depicts the format of the RESTRICT clause. The RESTRICT clause places limits on the results returned by the QUERY. The RESTRICT clause offers three methods for culling the results of a QUERY before they are returned to the client. When a RESTRICT clause contains multiple methods, they are applied in the order listed, each working on the result of the one before it. The SCORE clause includes <START> and <END> elements (both required, neither repeating) to define the range of scores for documents to be returned. If the <START> score is greater than the <END> score, the documents receiving scores in that range are returned in descending order by score. That is, the score closest to 1.00 comes first. When the <END> score is the larger, the results are in ascending order. The INDEX clause includes <START> and <END> elements (both required, neither repeating) to define a sequence of documents to return. For this purpose, candidate documents are numbered sequentially and the documents with sequence numbers falling in the range between <START> and <END> are returned. This is useful for clients that need a fixed number of documents returned. The sequence numbers must be positive integers.  depicts an example of the RESTRICT clause. This RESTRICT clause first limits the scores to those over 0.80. Then it returns the first three. If there are not at least three remaining, it returns what's left.","The format of the SELECT clause is shown in . The SELECT clause allows the application to determine the structure of the result set. Otherwise, the results consist of a list of all documents examined with a similarity score for each document. The SELECT clause governs the contents of the result set returned to the client. By default, the client receives a list of DOCUMENT elements, each with a score that indicates its degree of similarity to the search terms in the QUERY. The score is reported as an added attribute for the <DOCUMENT> element, along with its name and schema. If the boolean for scoring is set to false, only the document name and schema are returned. Likewise, if the QUERY does not include a WHERE clause, no scoring is performed. A SELECT clause that includes a structure from the search schema returns <DOCUMENT> elements containing that structure, each with the target value considered in the search. If the boolean for scoring is set to true (default), the result set includes <DETAIL> elements that contain a <PATH> element structure given in the WHERE clause and a <SCORE> element with the similarity score.  depicts an example of a SELECT clause that returns both target values and similarity scores.","The QUERY command also contains a SEMANTICS clause, as shown in . The SEMANTICS clause in a QUERY command has the same format as a SEMANTICS clause in a SCHEMA command, and is discussed above in the description of  and . A SEMANTICS clause specifies the semantics to use in the QUERY, and will override the default SEMANTICS clause contained in the SCHEMA command. For details on the MEASURE clause, CHOICE clause, and WEIGHT clause and PATH clause comprising a SEMANTICS clause, refer to their descriptions above in  and  relative to the SCHEMA command.","For traditional exact-match searches, results are just a list of the documents that satisfy the search's matching criteria. However, similarity searches normally regard all documents as similar to some degree, so the result of a similarity search is a list of all the documents searched, each with a similarity score that tells how similar it is to the search criteria. Optionally, the client can limit the result set to documents with a specified degree of similarity\u2014for example a score of 90% or above\u2014according to the requirements of the application. The client may also request details showing the anchor and target values that were compared to produce the document score.","Turning now to ,  depicts the format of a RESPONSE structure. A successful QUERY command returns a <RESULT> element whose contents are determined by the SELECT clause as just described above. An unsuccessful QUERY may return an <ERROR> or <WARNING> to the client. A RESPONSE format showing only scores of a similarity search is depicted in , and a RESPONSE format showing details of a similarity search is depicted in . Commands other than a QUERY command return results, but not similarity scores. For these other commands, <RESULT> contains an element that echoes the original command and contains set of elements of the type requested. A \u201clist\u201d operation produces a set of childless elements of the type requested, each with an identifying name attribute. A \u201cread\u201d operation returns complete XML structures for the elements requested. The <DETAIL> element depicted in  is included when the score attribute of a QUERY command SELECT clause is set to \u201ctrue\u201d. This produces a list of elements and attributes used in the WHERE clause of the QUERY command and the target values used to produce the scores. Each score is reported in a <SCORE> element of an APPLY clause along with a <WHERE> element with the xpath of the search term and a <FROM> element with the xpath of the target value. When multiple target values are involved, the xpath includes an index to indicate which one was chosen for scoring, e.g. the third value (in tree order) for a product's model number would be Product\/Model\/Number. In addition to the name attribute, which indicates which result document the details concern, the <DETAIL> element preserves any attributes from the original command. When the DETAIL concerns an unnamed document, such as the result of an embedded QUERY, an index attribute is added and its value indicates the document's sequence number among others in the set.  shows an example of a RESPONSE with results of a similarity search containing scores for three documents, where document's score is based on comparing its values with the search terms, a unique name identifies the document, and a search schema used in the command.","Turning now to ,  depicts the format of a DOCUMENT command. The DOCUMENT command enables the application to manage document sets involved in the search. The DOCUMENT command includes operations for managing the document set used in the search. The \u201clist\u201d operation returns a childless <DOCUMENT> element for each document in the set. The \u201cread\u201d operation retrieves documents from the datasource according to the mapping defined in the schema. The \u201clock\u201d and \u201cunlock\u201d operations provide a simple locking protocol to prevent conflicting updates in case several DOCUMENT operations are attempted at once by different clients. The operation attribute returns as \u201clocked\u201d or \u201cdenied\u201d to indicate the success of the operation. When \u201c*\u201d is specified instead of the document name, the \u201cread\u201d operation returns all documents. Likewise, the \u201c*\u201d tells the \u201cdelete\u201d, \u201clock\u201d, \u201cunlock\u201d, and \u201cindex\u201d operations to affect all documents in the set. Currently, the \u201clist\u201d operation requires name=\u201c*\u201d and returns only the first 100 documents. Search documents need an identifier to serve as the primary key. The document name can be anything as long as it is unique within the set. Where documents are drawn from relational datasources, it is customary to use the primary key for the root table as the document name.  depicts an example of a search document representative of the search document depicted in  above. To carry out a search of this document, the structure would be populated with the values used in the search to form the anchor document. The same structure is used to return the results of a search, including the documents found to be similar to the search criteria, in addition to the scores indicating the degree of similarity for each document.","Turning now to ,  depicts a format of a STATISTICS command definition template, where bold italic represents optional sections. The Statistics Processing Module (SPM), discussed above in regard to  uses this definition template.  is an example of a simple STATISTICS definition. The FROM clause identifies a document Schema and the SELECT clause identifies a last, first and middle name of a claimant.  depicts a SCHEMA response to a STATISTICS generation command.","Turning now to ,  depicts the format of a BATCH command. BATCH commands provide a way to collect the results of several related operations into a single XML element. Each command in the batch is executed in sequence.","There are additional commands that are used for administrative and maintenance purposes. The DATASOURCE command is used for identifying and maintaining datasources in the Relational Database Management System (RDMS). The MEASURE command is used for creating and maintaining the measures for determining document attribute and token similarity scores stored in the RDMS as User Defined Functions (UDFs). The CHOICE command is used for creating and maintaining aggregation (roll-up) algorithms stored in the RDMS and used by the Search Manager for determining overall document similarity scores.","Turning now to ,  depicts the overall process of setting up a schema. Prior to beginning this process, a target database must be imported into the Relational Database Management System associated with the SSE Server, as shown in . In addition, the user must have knowledge of the structure of the data within the imported database. The structure knowledge is required for the user to set up a schema. With reference to , the VDM synthesizes XML documents from relational data, and the SM synthesizes relational data from XML documents. Referring to , a schema must be established  by the Client sending  and the Gateway receiving  a command. The command is transmitted to the SSE Server from the Client using sockets, HTTP or JMS protocol. The command is converted to XCL by the Gateway and it is determined if it is a SCHEMA command.  depicts an example of a SCHEMA command based on the format shown in . Turning back to , after a client issues a Schema command  and the command is received by the Gateway , the Gateway determines that the command is a Schema command . Since this is a SCHEMA command, the Gateway sends the SCHEMA command to the VDM . When the Schema command is received by the VDM , the VDM builds relational tables and primary key tables based on the Schema command attributes . These tables are then stored for future use .","Turning now to , , B, and C depicts the overall process of executing a SSE search. After one or more schemas have been defined, the SSE is ready to accept a QUERY command. A typical QUERY command based on the format shown in  might resemble the example QUERY command shown in . Turning now to , when a client issues a QUERY command  that is received by the Gateway , it is determined if there is a WHERE clause in the command . If there were no WHERE clause in a QUERY command , the command would be examined to determine if there was a SELECT clause in the QUERY command . If there were no SELECT clause , RESULT would be returned to the client . If there were a SELECT clause in the Query command , indicating a selection of the structure for the result set to be produced by the QUERY command, the QUERY command would be sent to the VDM . Upon receipt of the QUERY command by the VDM, the VDM extracts the SELECTed values from the RDMS  and includes the SELECTed values in a RESULT set , which is returned to the client . If there were a WHERE clause in a QUERY command , the QUERY command would be sent to the SM .","Turning now to , the QUERY command is received at the SM . It is then determined if the QUERY command is a side-by-side comparison . If it is a side-by-side comparison , a recursive process for scoring nested elements is initiated. If it is not a side-by-side comparison , it is determined if the target is a valid schema . If it is not a valid schema , an error condition is returned to the client as a RESULT . Otherwise, the process moves to a determination of a REPEATING GROUP query  in . The recursive process for scoring nested elements that is entered if the Query requires a side-by-side comparison  comprises determining if a root element of a document has been scored . If it has, RESULT is returned to the client , otherwise it is determined if the element has unscored children . If the root element has unscored children , the next unscored child type is examined  and it is determined if this element has unscored children . If this element does not have unscored children , MEASURE and CHOICE are applied to this element type , and the next unscored child type is examined . This process continues until the root element of the document has been scored  and RESULT returned to the client.","Turning now to , if a target is a valid schema  from , a determination is made of whether the QUERY is a REPEATING GROUP query . If it is a REPEATING GROUP query , a score and primary key is determined for every record in the underlying dataset. If it is not a REPEATING DATASET , the process continues by beginning a SQL statement with primary key , building a UDF call for every attribute and measure , building FROM\/JOIN clauses for all tables used , building WHERE clauses for any restrictive measure used , and executing the SQL statement . Next, for every record in the SQL result set, overall score for records using weights in SEMANTICS is calculated , dismissing a record  if the score does not meet restriction , and appending score\/pkey to results  if the score does meet restriction . The pkeys and scores replace FROM clause  and control is returned to the Gateway to determine if there is a SELECT clause , and processed as described above in . If the QUERY is a REPEATING GROUP query , a score and primary key is determined for every record in the underlying dataset. This process comprises retrieving an XML document from the VDM  and performing a side-by-side scoring  using the recursive process for scoring nested elements describe above including steps , , ,  and . A record is dismissed  if the score does not meet restriction , and appending score\/pkey to results  if the score does meet restriction . The pkeys and scores replace FROM clause  and control is returned to the Gateway to determine if there is a SELECT clause , and processed as described above in .","An SQL command from the example SCHEMA and QUERY commands shown above may be as follows:","SELECT PKEY STRDIFF(PERSONS.FIRST.\u201cJOE\u201d), STRDIFF(PERSON.LAST.SMITH)","Turning now to ,  depicts an example data table in the RDMS and associated RESULT from the example SQL command above.  depicts the result of the Query command described above that would be returned to the client as a RESULT within a RESPONSE. This RESPONSE corresponds to the results illustrated in .","Although the present invention has been described in detail with reference to certain preferred embodiments, it should be apparent that modifications and adaptations to those embodiments might occur to persons skilled in the art without departing from the spirit and scope of the present invention."],"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF THE DRAWINGS"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["These and other features, aspects and advantages of the present invention will become better understood with regard to the following description, appended claims, and accompanying drawings wherein:",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 9B"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIGS. 22A and 22B"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIGS. 26A","b":["26","26"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 29","FIG. 11"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 39"}]},"DETDESC":[{},{}]}
