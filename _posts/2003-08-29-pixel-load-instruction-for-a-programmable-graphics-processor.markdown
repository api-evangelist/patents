---
title: Pixel load instruction for a programmable graphics processor
abstract: A pixel load instruction for a programmable graphics processor. The pixel load instruction may be used during processing of graphics data to load graphics data from a writable output buffer into a local storage element. Using the pixel load instruction may ensure that the graphics data loaded is current, i.e., any pending writes to the location storing the graphics data are completed prior to loading the graphics data. Furthermore, the pixel load instruction may be enabled and disabled for one or more writable output buffers by setting or clearing bits in a pixel load enable register.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07091979&OS=07091979&RS=07091979
owner: NVIDIA Corporation
number: 07091979
owner_city: Santa Clara
owner_country: US
publication_date: 20030829
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DISCLOSURE OF THE INVENTION"],"p":["One or more aspects of the invention generally relate to processing graphics data in a programmable graphics processor, and more particularly to reading graphics data from a writable output buffer.","Current graphics data processing is exemplified by systems and methods developed to perform a specific operation on several graphics data elements, e.g., linear interpolation, tessellation, texture mapping, depth testing. Traditionally graphics processing systems were implemented as fixed function computation units and more recently the computation units are programmable to perform a limited set of operations. Computation units are connected in a \u201cshading pipeline\u201d to perform shading operations.","The shading pipeline includes a write interface for writing graphics data to graphics memory, such as writing color data to a color buffer for display as an image. The shading pipeline also includes a texture read interface for reading texture data from a texture map stored in graphics memory. Conventionally a writable output buffer, such as a color buffer for display may not be read from by the texture read interface. Therefore, prior to accessing the color buffer as a texture map, such as during reflection mapping, the color buffer may be copied to a read-only texture buffer. Copying the color buffer to a texture buffer requires reading the color buffer and writing the texture buffer, using memory bandwidth which is often a valuable resource in a graphics subsystem.","For the foregoing reasons, it is desirable to directly read from a color buffer using the texture read interface without copying the color buffer to a texture buffer.","Various embodiments of the invention a pixel load program instruction. The pixel load program instruction includes a source position corresponding to a location within a writable buffer and a destination address corresponding to a local storage element.","Various embodiments of a method of the invention include a method of executing a pixel load program instruction in a graphics processor. A graphics primitive is received. Determination that a pixel load enable is enabled. A sync bundle is output. Confirmation that the sync bundle processing is complete is received. The graphics primitive is rasterized to produce fragments.","Yet further embodiments of a method of the invention include executing a pixel load shader program instruction in a graphics processor. A graphics fragment associated with a position is received. A sync bundle is output. Confirmation that the sync bundle processing is complete is received. The graphics fragment is output.","Various embodiments of the invention include a programmable graphics processor for execution of program instructions. The programmable graphics processor includes a rasterizer configured to process primitives to produce fragments and a pixel load unit coupled to the rasterizer, the pixel load unit configured to generate a sync bundle for each primitive and determine if the sync bundle processing is complete.","Various embodiments of the invention include a pixel load unit for detecting pixel collisions during fragment shading. The pixel load unit includes a first coverage data buffer configured to store first pixel coverage data, a second coverage data buffer configured to store second pixel coverage data, and a pixel collision detector coupled to the first coverage data buffer and coupled to the second coverage data buffer, the pixel collision detector configured to detect pixel collisions during fragment shading.","Further embodiments of the invention include a computing system. The computing system includes a host processor, a host memory, a system interface, and a programmable graphics processor. The host memory stores programs for the host processor. The system interface is configured to interface with the host processor. The programmable graphics processor includes a pixel load unit, a read interface, a fragment processing unit, and a write interface. The pixel load unit is configured to generate and output sync bundles using position data associated with fragments. The read interface is configured to read data from one or more buffers. The fragment processing unit is configured to receive the fragments and the data read from the one or more output buffers and generate processed fragments. The write interface is configured to write the processed fragments to the one or more output buffers.","The current invention involves a new programmable graphics processor instruction, a pixel load shader program instruction and systems and methods for processing graphics data using the pixel load shader program instruction. Furthermore, the pixel load shader program instruction may be enabled and disabled for one or more writable output buffers by setting or clearing bits in a pixel load enable register using a pixel load shader program enable instruction.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1","b":["100","110","107","100","110","114","112","112","115","115","112","115"]},"Host computer  communicates with Graphics Subsystem  via System Interface  and a Graphics Interface . Graphics Subsystem  includes a Local Memory  and a Programmable Graphics Processor . Programmable Graphics Processor  uses memory to store graphics data and program instructions, where graphics data is any data that is input to or output from computation units within Programmable Graphics Processor . Graphics memory is any memory used to store graphics data or program instructions to be executed by Programmable Graphics Processor . Graphics memory may include portions of Host Memory , Local Memory  directly coupled to Programmable Graphics Processor , register files coupled to the computation units within Programmable Graphics Processor , and the like.","In addition to Graphics Interface , Programmable Graphics Processor  includes a Graphics Processing Pipeline , a Memory Controller  and an Output Controller . Data and program instructions received at Graphics Interface  can be passed to a Geometry Processor  within Graphics Processing Pipeline  or written to Local Memory  through Memory Controller . Memory Controller  includes read interfaces and write interfaces that each generate address and control signals to Local Memory , storage resources, and Graphics Interface . Storage resources may include register files, caches, FIFOs (first in first out), and the like. In addition to communicating with Local Memory , and Graphics Interface , Memory Controller  also communicates with Graphics Processing Pipeline  and Output Controller  through read and write interfaces in Graphics Processing Pipeline  and a read interface in Output Controller . The read and write interfaces in Graphics Processing Pipeline  and the read interface in Output Controller  generate address and control signals to Memory Controller .","Within Graphics Processing Pipeline , Geometry Processor  and a programmable graphics fragment processing pipeline, Fragment Processing Pipeline , perform a variety of computational functions. Some of these functions are table lookup, scalar and vector addition, multiplication, division, coordinate-system mapping, calculation of vector normals, tessellation, calculation of derivatives, interpolation, and the like. Geometry Processor  and Fragment Processing Pipeline  are optionally configured such that data processing operations are performed in multiple passes through Graphics Processing Pipeline  or in multiple passes through Fragment Processing Pipeline . Each pass through Programmable Graphics Processor , Graphics Processing Pipeline  or Fragment Processing Pipeline  concludes with optional processing by a Raster Analyzer . Data produced in a pass through Programmable Graphics Processor , Graphics Processing Pipeline  or Fragment Processing Pipeline  may be written to an output buffer in graphics memory to be read from during a subsequent pass.","Vertex programs are sequences of vertex program instructions compiled by Host Processor  for execution within Geometry Processor  and Rasterizer . Shader programs are sequences of shader program instructions compiled by Host Processor  for execution within Fragment Processing Pipeline . Geometry Processor  receives a stream of program instructions (vertex program instructions and shader program instructions) and data from Graphics Interface  or Memory Controller , and performs vector floating-point operations or other processing operations using the data. The program instructions configure subunits within Geometry Processor , Rasterizer  and Fragment Processing Pipeline . The program instructions and data are stored in graphics memory. When a portion of Host Memory  is used to store program instructions and data the portion of Host Memory  can be uncached so as to increase performance of access by Programmable Graphics Processor . Alternatively, configuration information is written to registers within Geometry Processor , Rasterizer  and Fragment Processing Pipeline  using program instructions, encoded with the data, or the like.","Data processed by Geometry Processor  and program instructions are passed from Geometry Processor  to a Rasterizer . Rasterizer  is a sampling unit that processes graphics primitives and generates sub-primitive data, such as pixel data or fragment data. Graphics primitives include geometry, such as points, lines, triangles, quadrilaterals, meshes, surfaces, and the like. Rasterizer  converts graphics primitives into sub-primitive data, performing scan conversion on the data processed by Geometry Processor . Rasterizer  outputs fragment data or pixel data and shader program instructions to Fragment Processing Pipeline . Each fragment is at least a portion of a pixel, i.e., a pixel includes at least one fragment. Therefore the shader programs configure Fragment Processing Pipeline  to operate on fragments.","The shader programs configure the Fragment Processing Pipeline  to process fragment data by specifying computations and computation precision. A Fragment Shader  optionally is configured by shader program instructions such that fragment data processing operations are performed in multiple passes within Fragment Shader . Fragment Shader  outputs processed fragment data and codewords generated from shader program instructions to Raster Analyzer . Raster Analyzer  includes a read interface and a write interface to Memory Controller  through which Raster Analyzer  accesses data stored in one or more output buffers in Local Memory  or Host Memory . Raster Analyzer  optionally performs near and far plane clipping and raster operations, such as stencil, z test, blending, and the like, using fragment data read from the one or more buffers in Local Memory  or Host Memory  at the x,y position associated with the fragment data and the processed fragment data to produce output data. The output data from Raster Analyzer  is written back to an output buffer in Local Memory  or Host Memory  at the x,y position within the output buffer associated with the output data. Alternatively, the position is represented as a pair of coordinates other than x,y, e.g., (s,t), (u,v), and the like.","In various embodiments Memory Controller , Local Memory , and Geometry Processor  are configured such that data generated at various points along Graphics Processing Pipeline  may be output via Raster Analyzer  and provided to Geometry Processor  or Fragment Shader  as input. The output data is represented in one or more formats as specified by the codewords. For example, color data may be written as 16, 32, 64, or 128 bit per pixel fixed or floating-point RGBA (red, green, blue, and alpha) to be scanned out for display. Specifically, four 16 bit floating point components (RGBA) are combined forming 64 bits of color data for each fragment. The output data, e.g., color, depth, and other parameters, may be processed according to a shader program and stored in one or more output buffers in graphics memory to be used as texture maps, e.g., shadow map, height field, stencil, displacement maps, and the like, by the shader program. Alternatively, color and depth output data may be written to an output buffer, and later read and processed by Raster Analyzer  to generate the final pixel data prior to being scanned out for display via Output Controller .","When processing is completed, an Output  of Graphics Subsystem  is provided using Output Controller . Alternatively, Host Processor  reads the composited frame, e.g., output buffer, stored in Local Memory  through Memory Controller , Graphics Interface  and System Interface . Output Controller  is optionally configured by opcodes, received from Graphics Processing Pipeline  via Memory Controller , to deliver data to a display device, network, electronic control system, other Computing System , other Graphics Subsystem , or the like.","In an embodiment, Fragment Processing Pipeline  is configured by shader program instructions to perform depth testing prior to shading. Computed depth values are stored in a writable and readable output buffer, e.g., depth buffer. Conventionally, a shading unit, such as Fragment Shader , may not read the depth buffer and depth testing is performed by Raster Analyzer . The depth buffer may be copied to a buffer that may be read by a conventional shading unit. In contrast, various embodiments of Fragment Processing Pipeline  may be configured to read values from the depth buffer using a read interface that may also be used to read texture data, without copying the depth buffer.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 2A","b":["220","325","220","225","230","175","175","230"]},"A Fragment , such as a pixel, within displayed Buffer  is associated with an x,y position relative to Display . For example, displayed Output Buffer  is positioned at an x offset and a y offset relative to the upper left corner of Display . The x,y position of Fragment  relative to upper left corner of Display , i.e., screen position, is determined by combining the x offset and y offset with the x,y position of Fragment  within displayed Output Buffer , e.g. relative to the upper left corner of displayed Output Buffer . The x,y position of Fragment  relative to displayed Output Buffer , i.e., window position, is consistent regardless of the position of displayed Output Buffer  within Display . In an alternate embodiment the x,y origin is in the upper left corner of Display  and the x,y position of Fragment  is described relative to the x,y origin. In this embodiment the x,y position of Fragment  changes as the position of displayed Output Buffer  within Display  changes.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 2B","b":["250","220","225","260","220","266","240","105","260","266","260","266","266"]},"A Memory Location Address  is used to access Memory Location . Memory Location Address  may be computed based on an x,y position within Output Buffer  and a base memory space address, Memory Location Address , corresponding to a first location within Section . In an alternate embodiment Memory Location Address  is computed based on an x,y position within Display , an x offset of displayed Output Buffer , a y offset of displayed Output Buffer , and Memory Location Address .","Memory locations within a Section  store data for Output Buffer . For example, a Memory Location  stores data associated with Fragment , e.g., color, depth, stencil, shadow depth, map data, and the like. Section  has a base memory space address. Each output buffer is associated with a unique output buffer identifier that may be used to determine the output buffer's corresponding base memory space address. For example a lookup table containing the base memory space address corresponding to each output buffer identifier may be stored in Graphics Processing Pipeline .","A pixel load shader instruction, PLD shader program instruction, may be used to read data from an output buffer. The PLD instruction includes a source position and a destination address. The source position may specify a location within a writable output buffer such as Output Buffer  or Output Buffer . Data is read from the source position and stored in a storage element within Fragment Shader , described further herein, corresponding to the destination address. The data read from the source position is converted to a data format associated with the destination address. For example, when the destination address corresponds to a 32 bit floating point data format and the data read from the source position is represented in a 16 bit floating point data format, the data read form the source position is converted to a 32 bit floating point data format. Alternatively, when the destination address corresponds to an 8 bit fixed point data format and the data read from the source position is represented in a 24 bit floating point data format, the data read form the source position is converted to a 24 bit floating point data format.","When pixel load enable is enabled and a pixel load shader program instruction is received by Fragment Shader , the source position read is \u201ccurrent\u201d. Fragment Shader  ensures that the data read from an output buffer is \u201ccurrent\u201d by confirming that all pending write accesses (initiated prior to receiving the PLD instruction) to the writable output buffer are completed prior to reading the output buffer, as described further herein. When pixel load enable is disabled and a pixel load shader program instruction is received a predetermined value, such as zero is loaded into the storage element corresponding to the destination address. In some embodiments pixel load enable is enabled or disabled using a pixel load enable shader program instruction. Furthermore, the pixel load enable instruction may include an enable bit or field for each output buffer.","For example, Output Buffer  is a color buffer, storing color data, e.g. texture data, being produced by Graphics Processing Pipeline . The color data is read from Output Buffer  using PLD instructions (after enabling Output Buffer  using the pixel load enable instruction) to produce data stored in Output Buffer . PLD instructions are used to read directly from Output Buffer  via a read interface in Fragment Shader  without first copying Output Buffer  to a read-only buffer.","In an embodiment fragments written to Output Buffer  are processed by depth testing prior to shading. When a fragment produces data for Pixel  in Output Buffer  a write to Memory Location Address  may be pending for several clock cycles depending on the number of pipeline stages in Fragment Processing Pipeline , arbitration scheme used by Memory Controller , and the like. A RAW (read after write) conflict exists when a write to an (x,y) position, e.g., Pixel , within an output buffer is pending when a read from the same (x,y) position in the output buffer is received. Specifically, a RAW conflict exists in the embodiment when a read from Memory Location Address  is received while a write to Memory Location Address , is pending. The RAW conflict is removed when the write to Memory Location Address  is completed.","Flushing Fragment Processing Pipeline  prior to reading from Output Buffer  ensures that the data read from Output Buffer  is current by confirming that all pending write accesses (initiated prior to processing the flush instruction) to the writable output buffer are completed prior to reading the output buffer. Conventionally, a flush instruction idles the computation units within Fragment Processing Pipeline  as the flush instruction passes through Fragment Processing Pipeline , reducing fragment throughput. It is desirable to read from a writable output buffer to process fragment data without flushing Fragment Processing Pipeline  or minimizing the number of times Fragment Processing Pipeline  is flushed. The pixel load instruction and pixel load enable instruction may be used to read a writable output buffer and minimize flushing of Fragment Processing Pipeline , as described further herein.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 3","b":["103","150","130","150","155","155","165"]},"Rasterizer  includes a Pixel Load Unit , described further herein, and a Pixel Load Enable Register . Pixel Load Enable Register  stores one or more bits, each bit corresponding to an output buffer, such as a front color buffer, back color buffer, depth\/stencil buffer, texture buffer, and the like. In an alternate embodiment each bit may correspond to a type of output buffer, such as display buffers, texture buffers, shadow buffers, and the like. Pixel Load Enable Register  may have a default value and may be loaded by an application using the pixel load enable program instruction.","Fragment Shader  receives fragment data, sync bundles, and shader program instructions from Rasterizer . The fragment data is processed according to the shader program instructions. Address Unit  determines an address corresponding to a position associated with each fragment. The address may be determined using the position, a base address, offsets, and the like. Address Unit  outputs the address to Read Interface  which reads additional shader program instructions and output buffer data (depth values, texture map, height field, bump map, shadow map, jitter values, and the like) from Local Memory  or Host Memory , via Memory Controller . The output buffer data stored in graphics memory may be generated by Programmable Graphics Processor , by Host Processor , by another device, by a human, or the like.","In an embodiment including a Data Cache , Read Interface  determines if the additional shader program instructions or output buffer data are available in Data Cache . If the output buffer data is available in Data Cache , Read Interface  reads the output buffer data from Data Cache  rather than from Local Memory  or Host Memory , via Memory Controller . When a sync bundle is received output buffer data stored in Data Cache  is marked as invalid so that Read Interface  will read the output buffer data from Local Memory  or Host Memory , via Memory Controller  to receive the output buffer data that is current.","Memory Controller  outputs the output buffer data and the additional shader program instructions to Read Interface . Texture Unit  outputs the buffer data, processed fragment data, sync bundles, and the additional shader program instructions to a Fragment Processing Unit . Registers  within Fragment Processing Unit  are storage elements used to store data represented by a plurality of bits. Each Register  may be specified as a destination location by a PLD instruction and is loaded during processing of the PLD instruction. Fragment Processing Unit  processes the processed buffer data and processed fragment data as specified by the additional shader program instructions and outputs shaded fragment data, e.g., x, y, color, depth, configuration control, other parameters, and sync bundles to Raster Analyzer .","In some embodiments Fragment Processing Unit  is configured to process at least two fragments in parallel. Likewise, Read Interface  may also be configured to process at least two fragments in parallel. Raster Analyzer  optionally processes the shaded fragment data according to the configuration control. A Write Interface  within Raster Analyzer  writes the optionally processed shaded fragment data to an output buffer stored in Local Memory  or Host Memory , via Memory Controller . Write Interface  also outputs the sync bundles to Pixel Load Unit  within Rasterizer , as described further herein.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 4","b":["400","150","405","150","370","405","150","150","420","405","150","410","150","155"]},"In step  Rasterizer  determines if processing of the sync bundle is complete, i.e., the sync bundle output in step  has propagated through Fragment Processing Pipeline . Write Interface  is configured to output a sync bundle after data preceding the sync bundle has been output to Memory Controller . In an alternate embodiment, Write Interface  is configured to output a sync bundle after the data preceding the sync bundle has been output by Memory Controller  to graphics memory. If, in step  Rasterizer  determines processing of the sync bundle is not complete Rasterizer  remains in step . If, in step  Rasterizer  determines processing of the sync bundle is complete, in step  Rasterizer  rasterizes the primitive received in step . Outputting one sync bundle for each primitive prevents RAW conflicts caused by overlapping or adjacent primitives accessing the same position within an output buffer.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 5A","b":["155","155","150","155","160","155","155"]},"A Pixel Load Unit  receives a position associated with each fragment and pixel load enable instructions. Pixel Load Unit  performs pixel collision detection using the position, as described further herein. Pixel Load Unit  produces sync bundles that are output by Texture Unit  to Fragment Processing Unit . A sync bundle may contain a timestamp or other value to differentiate one sync bundle from another sync bundle. Pixel Load Unit  outputs the position associated a fragment to Address Unit .","Address Unit , Read Interface , optional Data Cache , Texture Unit , Fragment Processing Unit  including Registers , and Raster Analyzer  function as previously described in relation to . Write Interface  within Raster Analyzer  outputs the sync bundles to Pixel Load Unit .",{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 5B","b":["552","552","370","585","580","585","585","590","585","552","351","580","552","351","585","370","580","165"]},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 6","b":["160","610","552","370","370","370","620","585","580","585","580","580","580","580"]},"In step  Collision Detector  generates and outputs a sync bundle to Address Unit . In step  Collision Detector  determines if processing of the sync bundle is complete, i.e., if the sync bundle output in step  has been received and processed by Raster Analyzer , i.e., has been received by Collision Detector  from Raster Analyzer . If, in step  Collision Detector  determines processing of the sync bundle is not complete Collision Detector  remains in step . If, in step  Collision Detector  determines processing of the sync bundle is complete, in step  Collision Detector  is configured to track fragment positions. The pixel load instruction and pixel load enable may be used to read a writable output buffer and minimize idling of computation units within Fragment Processing Pipeline , as described further herein.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 7","FIG. 4"],"b":["705","160","710","585","552","552","710","585","552","351","160","765"]},"If, in step  Collision Detector  determines that pixel load enable is enabled, in step  Collision Detector  checks if a pixel collision exists. A pixel collision exists when a fragment associated with a position has been output by Pixel Load Unit  and if a sync bundle has been sent after outputting the fragment, the sync bundle has not yet been received from Raster Analyzer  by Pixel Load Unit . Collision Detector  reads Coverage Data Buffers . Because Coverage Data Buffers  were cleared to zero when a pixel load enable instruction was executed, Collision Detector  reads a zero from each Coverage Data Buffer . When Collision Detector  reads the writable (selected) Coverage Data Buffer , the bit read is set to a one, indicating that a fragment associated with the position has been output. In one embodiment the position is a pair of x,y coordinates, e.g. a destination pixel. In another embodiment the position is a pair of output buffer coordinates used to read texture data, a shadow depth value, or the like.","In step  Collision Detector  determines if a pixel collision exists, and, if not, proceeds to step . A pixel collision exists if the coverage data read from either Coverage Data Buffer  is a one. In step  Collision Detector  determines if a predetermined number of fragments (positions) have been output by Pixel Load Unit , and, if not, in step  Collision Detector  outputs the position to Address Unit  and increments Fragment Output Counter . In an alternate embodiment Fragment Output Counter  is initialized to the predetermined number and Collision Detector  decrements the counter for each fragment output. In the alternate embodiment Collision Detector  determines the predetermined number of fragments have been output by Pixel Load Unit  when Fragment Output Counter  outputs a zero. The predetermined number may be fixed or loaded using a program instruction.","Following step , Texture Unit  outputs the fragment associated with the position to Fragment Processing Unit  and the fragment is shaded. Fragment Processing Pipeline  receives several other fragments and steps , , , , , and  are repeated. Collision Detector  increments Fragment Output Counter  each time step  is completed. Fragment Processing Pipeline  receives another fragment associated with the position and steps , , and  are repeated. In step  Collision Detector  determines if a pixel collision exists, and, if so, in step  Collision Detector  determines if the pixel collision is due to a read from the selected Coverage Data Buffer . If, in step  Collision Detector  determines the pixel collision is due to a read from the selected Coverage Data Buffer , in step  Collision Detector  outputs a sync bundle to Address Unit .","In step  Collision Detector  waits to receive the sync bundle from Raster Analyzer , remaining in step  until the sync is complete. In step , when Collision Detector  receives the sync bundle it clears selected Coverage Data Buffer , except for the bit indicating that a fragment associated with the position has been output, and proceeds to step  and outputs the position to Address Unit  and increments Fragment Output Counter . Fragment Processing Pipeline  receives another fragment associated another position and steps , , and  are repeated. In step  Collision Detector  determines if a pixel collision exists, and, if not, in step  Collision Detector  determines if the predetermined number of fragments (positions) have been output by Pixel Load Unit . If, in step  Collision Detector  determines the predetermined number of fragments (positions) have been output by Pixel Load Unit , in step  Collision Detector  determines if there is a pending sync, i.e., if a sync bundle output by Pixel Load Unit  has not yet been received from Raster Analyzer . A pending sync may result from the predetermined number being set to a number that is smaller than the number of pipeline stages in Fragment Processing Pipeline .","If, in step  there is a pending sync, in step  Collision Detector  waits for the pending sync to complete, clearing the non-selected Coverage Data Buffer  and proceeding to step  when the sync bundle is received by Pixel Load Unit  from Raster Analyzer . If, in step  there is not a pending sync, Collision Detector  proceeds to step . In step  Collision Detector  outputs a sync bundle, clears Fragment Output Counter , and \u201cswaps\u201d Coverage Data Buffers  so that the writable Coverage Data Buffer  is only readable (non-selected) and the readable Coverage Data Buffer  is writable and readable (selected). In step  Collision Detector  outputs the other position to Address Unit  and increments Fragment Output Counter .","Fragment Processing Pipeline  receives another fragment associated with the position and steps , , and  are repeated. In step  Collision Detector  determines if a pixel collision exists, and, if so, in step  Collision Detector  determines if the pixel collision is due to a read from the selected Coverage Data Buffer . A pixel collision may exist due to a read from the non-selected Coverage Data Buffer  when the sync bundle output in step  has not yet been received by Pixel Load Unit  from Raster Analyzer . If, in step  Collision Detector  determines the pixel collision is not due to a read from the selected Coverage Data Buffer , in step  Collision Detector  waits for the pending sync to be received by Pixel Load Unit  from Raster Analyzer  before clearing the non-selected Coverage Data Buffer  and proceeding to step . In step  Collision Detector  outputs the position to Address Unit  and increments Fragment Output Counter . Note that when the selected Coverage Data Buffer  was read in step  a one was stored for the position.","In this embodiment sync bundles are generated and output by Pixel Load Unit  when a pixel collision exists or when a predetermined number of fragments have been output to Address Unit . This embodiment ensures that data read from a writable output buffer is current while minimizing idling computation units within Fragment Processing Pipeline  to process sync bundles by only waiting for the sync bundles to be received by Pixel Load Unit  from Raster Analyzer  when a pixel collision exists. Several primitives may be processed without generating a sync bundle.","In some embodiments sync bundles are not generated and output by Pixel Load Unit . Instead, destination locations for write data are tracked and position conflicts, e.g., pixel collisions, are avoided by delaying source read requests.  is a block diagram of an exemplary embodiment of a portion of Pixel Load Unit  including subunits configured to detect position conflicts in accordance with one or more aspects of the present invention.","A Hash Unit  receives an Input  produces an Output . Input  may include a buffer identifier, a position (source location or destination location), a source read request, a destination write request, and a destination write confirmation. The source read request is asserted when a shader program instruction specifies a read. The destination write request is asserted when a shader program instruction specifies a write. The destination write confirmation is received from Write Interface  when a write is completed (write position confirmation). A Hash Function  within Hash Unit  receives a first portion of Input  and outputs an index. When the destination write request is asserted a second portion of Input  is stored in an entry in a Storage , where Storage  may be a register file, embedded RAM, or the like. When the destination write confirmation is received the entry corresponding to the index is cleared or otherwise marked as available.","When the source read request is asserted Storage  outputs the data stored in the entry corresponding to the index to a Compare . Compare  also receives the second portion of Input  and compares it to the data output by Storage . When the second portion of Input  is equal to the data output by Storage  Compare  outputs a signal indicating that a position conflict exists. When the second portion of Input  is not equal to the data output by Storage  Compare  outputs a signal indicating that a position conflict does not exist.","In a first embodiment the first portion of Input  is the position and the buffer identifier is the second portion of Input . In a second embodiment the first portion of Input  is the buffer identifier and the second portion of Input  is the position. In a third embodiment the first portion of Input  is the buffer identifier and the position and the second portion of Input  is a logic true. In the third embodiment Compare  is omitted and Output  is the output of Storage .",{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIGS. 9A","b":["9","9","155","105"]},"In step  Fragment Shader  receives a shader program instruction specifying a write to a first destination location. The first destination location may be within Registers  in Fragment Shader  or a location in graphics memory within a buffer. The first destination location may also include a buffer identifier. The buffer may include depth data, color data, stencil data, or the like. When optional Data Cache  is used, Data Cache  receives the destination location and invalidates any entry associated with the destination location. In one embodiment when processed shaded data is output to the destination location by Write Interface  Data Cache  receives and stores the processed shaded data in an entry associated with the destination location.","In step  Fragment Shader  receives a PLD instruction including a source location and a second destination location. In one embodiment the source location is the first destination location and the second destination location is Register . In another embodiment the source location is another location within the buffer. In yet another embodiment the source location is another location within another buffer.","In step  Pixel Load Unit  within Fragment Shader  determines if a write to the source location is pending, and, if so, Fragment Shader  remains in step , waiting until the write to the source location is complete, i.e. for the position conflict to be resolved. Execution of the PLD instruction eliminates the need for executing a flush instruction to drain Fragment Processing Pipeline  prior to reading the source location.","If in step  Pixel Load Unit  determines that a write to the source location is not pending, in step  Read Interface  outputs a read request for the source location to Memory Controller  and receives the data stored in the source location from Memory Controller . In an alternate embodiment Read Interface  reads the data stored in the source location from Data Cache . In step  Read Interface  outputs the data stored in the source location to Fragment Processing Unit  and Fragment Processing Unit  stores the data in the destination location, e.g. a location within Registers .",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 9B","FIG. 9A","FIG. 9A"],"b":["915","155","917","155","919","921","923","925"]},"In an embodiment the source location specified in the PLD instruction is the first destination location specified in the shader program instruction received in step . Execution of the PLD instruction in the embodiment permits reading the source location during processing of the additional shader program instructions rather than draining the Fragment Shader  after the write to the first destination location and before executing the source read. Steps , , , , and  are completed as previously described.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 9C","FIG. 9A","FIG. 9A","FIG. 9C"],"b":["915","919","921","923","925","927","155","155"]},{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 9D","FIG. 9A"],"b":["155","915","919","921","552","155","927","155","155","921"]},"In one embodiment of Fragment Shader , a subsequent program instruction is not executed in step  when the subsequent program instruction has a position conflict with the source location. In step  Pixel Load Unit  determines if a write to the source location is still pending, and, if not, Fragment Shader  completes steps  and  as previously described to complete execution of the PLD instruction.","Using a pixel load instruction and a pixel load enable instruction it is possible to directly read from a color buffer using the texture read interface without copying the color buffer to a texture buffer. The current invention involves systems and methods for processing graphics data using the pixel load instruction and pixel load enable instruction.","The invention has been described above with reference to specific embodiments. It will, however, be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense. The listing of steps in method claims do not imply performing the steps in any particular order, unless explicitly stated in the claim. Within the claims, element lettering (e.g., \u201ca)\u201d, \u201cb)\u201d, \u201ci)\u201d, \u201cii)\u201d, etc.) does not indicate any specific order for carrying out steps or other operations; the lettering is included to simplify referring to those elements."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE VARIOUS VIEWS OF THE DRAWINGS","p":["Accompanying drawing(s) show exemplary embodiment(s) in accordance with one or more aspects of the present invention; however, the accompanying drawing(s) should not be taken to limit the present invention to the embodiment(s) shown, but are for explanation and understanding only.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 5A","FIG. 1"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 5B","FIG. 5A"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 8","FIG. 5A"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 9A","b":["9","9","9"]}]},"DETDESC":[{},{}]}
