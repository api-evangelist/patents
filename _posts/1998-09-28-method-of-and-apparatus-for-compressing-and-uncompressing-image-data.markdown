---
title: Method of and apparatus for compressing and uncompressing image data
abstract: The present invention provides for a method of and apparatus for compressing and uncompressing image data. According to one embodiment of the present invention, the method of compressing a color cell comprises the steps of: defining at least four luminance levels of the color cell; generating a bitmask for the color cell, the bitmask having a plurality of entries each corresponding to a respective one of the pixels, each of the entries for storing data identifying one of the luminance levels associated with a corresponding one of the pixels; calculating a first average color of pixels associated with a first one of the luminance levels; calculating a second average color of pixels associated with a second one of the luminance levels; and storing the bitmask in association with the first average color and the second average color. In one embodiment, the color cell includes a matrix of 4x4 pixels, the bitmask includes 32-bits and each of the color values includes 16-bits such that a compression rate of 4-bits per pixel is achieved. The present invention is particularly applicable to compress texture data such that the texture data can be more efficiently cached and moved during texture mapping. In that embodiment, the present invention can also support the compression of luminance, intensity and alpha textures.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07058218&OS=07058218&RS=07058218
owner: Silicon Graphics, Inc.
number: 07058218
owner_city: Mountain View
owner_country: US
publication_date: 19980928
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE DISCLOSURE","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS","COMPUTER SYSTEM ENVIRONMENT OF THE PRESENT INVENTION","METHOD OF COMPRESSING IMAGE DATA ACCORDING TO ONE EMBODIMENT OF THE PRESENT INVENTION","METHOD OF RESTORING COMPRESSED IMAGE DATA ACCORDING TO ONE EMBODIMENT OF THE PRESENT INVENTION","METHOD OF COMPRESSING TEXTURE DATA ACCORDING TO ONE EMBODIMENT OF THE PRESENT INVENTION","METHOD OF RESTORING COMPRESSED TEXTURE DATA ACCORDING TO ONE EMBODIMENT OF THE PRESENT INVENTION","APPARATUS FOR UNCOMRPESSING TEXTURE DATA ACCORDING TO ONE EMBODIMENT OF THE PRESENT INVENTION","PROGRESSIVE COLOR CELL COMPRESSION","ADVANCED METHOD FOR SELECTING REPRESENTATIVE COLORS ACCORDING TO ONE EMBODIMENT OF THE PRESENT INVENTION"],"p":["This application includes a microfiche appendix.","The present invention relates to the field of computer graphics. More specifically, the present invention relates to a method of and apparatus for compressing and uncompressing image data in a computer system;","Computer graphics is used in a wide variety of applications, such as in business, science, animation, simulation, computer-aided design, process control, electronic publishing, gaming, medical diagnosis, etc. In those applications, three-dimensional (3D) objects are displayed on a computer screen by using a number of polygons to represent the three-dimensional objects. In order to portray a more realistic real-world representation, texture mapping is often applied. Texture mapping refers to techniques for using two-dimensional (2D) or three dimensional (3D) texture images, or texture maps, for adding surface details to areas or surfaces of these 3D graphical objects. For example, given a featureless solid cube and a texture map defining a wood grain pattern, texture mapping techniques may be used to map the wood grain pattern onto the cube. The resulting image is that of a cube that appears to be made of wood. In another example, vegetation and trees can be added by texture mapping to an otherwise barren terrain model in order to portray a landscape filled with vegetation and trees.","In computer systems having dedicated graphics hardware, images for use in texture mapping are typically stored in memory in the form of a collection of tiles. These tiles are addressed and managed as a virtually contiguous region of address space by a two-dimensional index (S,T). In other words, this memory management scheme treats a texture map as an array of small, contiguous tiles each including a matrix of texels. Thereby, memory management issues, such as caching, virtual-to-physical mapping, swapping, etc. are more easily executed.","In order to utilize computer resources more efficiently, computer graphics systems typically include a graphics co-processor for offloading processing burdens from the CPU of the computer system, and a texture memory for storing texture data. Moreover, in order to further accelerate the texture mapping process, a special cache memory, also known as a texture cache, may also be implemented in the computer graphics systems for providing faster access to and temporary storage of frequently used tiles of texture data. In these computer systems, the texture data is frequently transferred between these memories. The bandwidth for transferring texture data between these memories, thus, becomes a critical factor in determining the texture mapping performance of such systems. Additionally, the memories themselves are valuable resources. Therefore, it would be advantageous to store and transfer texture data in a compressed format.","The need for a method of compressing texture images also arises in computer systems without a dedicated texture cache memory. In those systems, texture images are rendered directly from the system memory. That method of rendering, however, places significant burdens on system memory bandwidth. In addition to passing texture data and other image data, the memory bus must also handle access to the system memory by the operating system and the application programs. Therefore, in order to alleviate this problem, it is would also be advantageous to store and transfer compressed texture data such that the burden on system memory bandwidth is minimized.","However, the conventional methods of compressing image data are not suitable for compressing texture images. For instance, these conventional methods introduce significant amounts of visual artifacts, such as color \u201cjaggies,\u201d in the image data. These visual artifacts, while hardly noticeable in non-3D applications, are magnified when conventionally compressed texture images are used in texture mapping. Further, conventional compression algorithms, such as the color cell compression (CCC) algorithm, make use of a color look-up table (LUT) for storing representative colors of the image. Because color LUTs can be quite large, and given the limited system memory bandwidth, the overall performance of the texture mapping process would be significantly impeded if conventional algorithms such as the CCC algorithm are used to compress texture data.","Other well known compression schemes such as the JPEG or MPEG compression schemes produce good quality compression but are mathematically complex and require considerable amounts of hardware to implement. This high hardware cost makes these schemes unsuitable for texture compression.","Therefore, what is needed is a method of and apparatus for compressing and uncompressing color images with minimal information loss. What is also needed is a method of and apparatus for compressing and uncompressing color images without color look-up tables. What is yet further needed is a method of and apparatus for compressing and uncompressing texture data to be used in texture mapping.","The present invention provides for a method of and apparatus for compressing and uncompressing image data. According to one embodiment of the present invention, the method of compressing a color cell comprises the steps of: defining at least four luminance levels of the color cell; generating at least two bitmasks for the color cell, generating a first base color representative of pixels associated with a first one of the luminance levels; generating a second base color representative of pixels associated with a second one of the luminance levels; and storing the bitmasks in association with the first base color and the second base color. According to the present embodiment, the bitmasks each includes a plurality of entries each corresponding to a respective one of the pixels. Further, each entry is for storing data that identifies the luminance levels associated with the pixels. The present invention is particularly applicable to compress texture data such that the texture data can be more efficiently cached and moved during texture mapping.","In accordance with the present embodiment, the step of defining the luminance levels includes the steps of: calculating a mean luminance value for all pixels within the color cell; calculating an upper-mean luminance value for pixels having luminance values higher than the mean luminance value; and calculating a lower-mean luminance value for pixels having luminance values lower than the mean luminance value. In the present embodiment, the mean luminance value, the upper-mean luminance value, and the lower-mean luminance value partition the plurality of pixels into four different luminance levels including a highest luminance level, a high luminance level, a low luminance level, and a lowest luminance level. According to one embodiment, the first base color is computed by averaging the color values of all the pixels associated with the highest luminance level, and the second average color is computed by averaging the color values of all the pixels associated with the lowest luminance level.","In one particular embodiment, the color cell includes a matrix of 4\u00d74 pixels, the bitmasks include thirty-two bits and each of the base colors includes sixteen bits such that a compression ratio of four bits per pixel is achieved. In that embodiment, the present invention can be modified to support the compression of luminance, intensity and alpha textures.","In furtherance of one embodiment of the present invention, the method of restoring compressed image data comprises the steps of reading at least two base colors from the compressed image data; generating at least two additional colors from the base colors; and reconstructing the color cell based on the bitmasks and the base colors and the additional colors. In one embodiment, the color cell is reconstructed by assigning each pixel one of the colors according to the pixel's luminance level.","Embodiments of the present invention include the above and further include a computer readable memory for storing compressed texture data which comprises at least two bitmasks each having a plurality of entries each corresponding to a texel of a texture map, each of the entries for storing data identifying one of at least four luminance levels associated with a corresponding one of the texels; a first color of texels associated with a first one of the luminance levels; and a second color of texels associated with a second one of the luminance levels, wherein the bitmasks, the first color value and the second color value are for being retrieved by a computer system to reconstruct the uncompressed color cell from the compressed texture data during texture-mapping.","Reference will now be made in detail to the present embodiments of the invention, examples of which are illustrated in the accompanying drawings. While the invention will be described in conjunction with the present embodiments, it will be understood that they are not intended to limit the invention to these embodiments. On the contrary, the invention is intended to cover alternatives, modifications and equivalents, which may be included within the spirit and scope of the invention as defined by the appended claims. Furthermore, in the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be obvious, however, to one skilled in the art, upon reading this disclosure, that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are not described in detail in order to avoid obscuring aspects of the present invention.","Unless specifically stated otherwise as apparent from the following discussions, it is appreciated that throughout the present invention, discussions utilizing terms such as \u201creceiving\u201d, \u201cdetermining\u201d, \u201cgenerating\u201d, \u201cassociating\u201d, \u201cassigning\u201d or the like, refer to the actions and processes of a computer system, or similar electronic computing device. The computer system or similar electronic device manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission, or display devices.","With reference to , portions of the present invention are comprised of computer-readable and computer executable instructions which reside, for example, in computer-usable media of a computer system.  illustrates an exemplary computer system  used as a part of a computer graphics system in accordance with one embodiment of the present invention. It is appreciated that system  of  is exemplary only and that the present invention can operate within a number of different computer systems including general purpose computer systems, embedded computer systems, and stand alone computer systems specially adapted for generating 3-D graphics.","Computer system  includes an address\/data bus  for communicating information, a central processor  coupled with bus  for processing information and instructions, a volatile memory  (e.g., random access memory RAM) coupled with the bus  for storing information and instructions for the central processor  and a non-volatile memory  (e.g., read only memory ROM) coupled with the bus  for storing static information and instructions for the processor . Computer system  also includes a data storage device  (\u201cdisk subsystem\u201d) such as a magnetic or optical disk and disk drive coupled with the bus  for storing information and instructions. Data storage device  can include one or more removable magnetic or optical storage media (e.g., diskettes, tapes) which are computer readable memories. Memory units of system  include ,  and . Computer system  can also include a graphics subsystem  (e.g., graphics adapter) coupled to the bus  for providing additional graphics processing power.","Computer system  can further include a communication device  (e.g., a modem, or a network interface card NIC) coupled to the bus  for interfacing with other computer systems. Also included in computer system  of  is an optional alphanumeric input device  including alphanumeric and function keys coupled to the bus  for communicating information and command selections to the central processor . Computer system  also includes an optional cursor control or directing device  coupled to the bus  for communicating user input information and command selections to the central processor . An optional display device  can also be coupled to the bus  for displaying information to the computer user. Display device  may be a liquid crystal device, other flat panel display, cathode ray tube, or other display device suitable for creating graphic images and alphanumeric characters recognizable to the user. Cursor control device  allows the computer user to dynamically signal the two dimensional movement of a visible symbol (cursor) on a display screen of display device . Many implementations of cursor control device  are known in the art including a trackball, mouse, touch pad, joystick or special keys on alphanumeric input device  capable of signaling movement of a given direction or manner of displacement. Alternatively, it will be appreciated that a cursor can be directed and\/or activated via input from alphanumeric input device  using special keys and key sequence commands. The present invention is also well suited to receiving inputs by other means such as, for example, voice commands.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 2","b":"300"},"At step , the luminance (Y) of each pixel of the cell is computed. In the present embodiment, the luminance value, Y, of a pixel is computed from its RGB values by summing the individual RGB values of that pixel. For example, the luminance value Y(i) of the i-th pixel of the color cell may be calculated by the formula:","\u2003()=0.299()+0.587()+0.114().","Then, at step , an average luminance value (Y) is computed by summing the luminance value of all the pixels and by dividing the sum with the total number of pixels, n, of the cell. Thereafter, an upper-average luminance value (Y) of the cell, and a lower-average luminance value (Y) are computed. In the present embodiment, Yrefers to the average luminance value of the pixels which have a higher luminance value than Y, and Yrefers to the average luminance value of the pixels which have a lower luminance value than Y. An exemplary subroutine for calculating Y, Y, and Yis given below in pseudocode.",{"@attributes":{"id":"p-0033","num":"0032"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"compute_luminance( ){"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"y_mean = mean(y[i])","for i = 0 to 15;"]},{"entry":[{},"y_upper = mean(y[i])","for all y[i] >= y_mean;"]},{"entry":[{},"y_lower = mean(y[i])","for all y[i] < y_mean;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"According to the present embodiment, the values Y, Y, and Y, define four different luminance levels (or ranges) including a highest luminance level corresponding to pixels having luminance values higher than Y, a high luminance level corresponding to pixels having luminance values between Yand Y, a low luminance level corresponding to pixels having luminance values between Yand Y, and a lowest luminance level corresponding to pixels having luminance values lower than Y. For example, it may be determined that five pixels of the cell are associated with the highest luminance level because the luminance values of those five pixels are above Y, and that three pixels are associated with the lowest luminance level because the luminance values of those three pixels are below Y, etc. According to the present embodiment, these four different luminance levels are used to determine four different representative colors of the color cell.","With reference still to , at step , luminance-encoded bitmasks are generated to represent the luminance level of each pixel of the color cell. In the present embodiment, the luminance-encoded bitmasks include two 4\u00d74 bitmasks: one MSB bitmask and one LSB bitmask. For example, according to the present embodiment, if a pixel has a luminance value larger than or equal to Y, the corresponding entry at the MSB bitmask is set to \u201c1.\u201d If the pixel has a luminance value smaller then Y, the corresponding entry at the MSB bitmask is set to \u201c0.\u201d Similarly, if the pixel has a luminance value larger than or equal to Y, the corresponding entries at the MSB bitmask and the LSB bitmask will be set to \u201c1.\u201d If the pixel has a luminance value smaller than Y, then the corresponding entries at the MSB bitmask and the LSB bitmask will be set to \u201c0\u201d Similarly, the LSB bitmask will be set to \u201c1\u201d if the luminance value of the corresponding pixel is higher than Yor Y, and will be set to 0\u201d if the luminance value of the corresponding pixel is lower than Yor Y. An exemplary subroutine for generating the bitmasks is given below in pseudocode.",{"@attributes":{"id":"p-0036","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"produce_luminance_encoded_bitmasks( ){"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003if (y[i] >= y_upper)","mask = 2\u2032b11; \/* highest luminance level *\/"]},{"entry":["\u2003else if (y[i] >= y_mean)","mask = 2\u2032b10; \/* high luminance level *\/"]},{"entry":["\u2003else if (y[i] >= y_lower)","mask = 2\u2032b01; \/* low luminance level *\/"]},{"entry":["\u2003else","mask = 2\u2032b00; \/* lowest luminance level *\/"]},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"At step , representative colors of the color cell are generated. In the present embodiment, one representative color, color_a, is generated for the pixels associated with the highest luminance level; and, another representative color, color_b, is generated for the pixels associated with the lowest luminance level. According to the present embodiment, representative colors color_a and color_b are generated by averaging the color values of the pixels for each of the luminance levels. Specifically, in the present embodiment, color_a is computed by averaging the color values of each pixel that has a luminance value larger than the upper-average luminance value Y, and color_b is computed by average the color values of each pixel that has a luminance value smaller than the lower-average luminance value Y. In the present embodiment, color_a and color_b each comprises 24 bits. However, in order to attain an even higher compression ratio, in the present embodiment, color_a and color_b are subsequently quantized to two RGB565 color values.","At step , the two RGB565 color values generated at step  are appended to the luminance-encoded bitmasks generated at , and the resultant encoded (or compressed) color cell is stored in a computer usable memory such as RAM  of computer system . In the present embodiment, the encoded color cell includes 64 bits (two 4\u00d74 luminance-encoded bitmasks, and two RGB565 color values). In this way, a compression ratio of 4-bits\/pixel is achieved. While the present invention has a lower compression ratio than conventional compression algorithms such as the CCC algorithm, the present invention has an advantage of higher image quality, and the present invention does not require a color look-up table. In addition, because compression and decompression is local to a 4\u00d74 matrix of pixels, compression and decompression can be made to be very fast.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 3","FIG. 2"],"b":"400"},"As illustrated in , at step , the first RGB565 color value and the second RGB565 color value of the compressed color cell are converted to two RGB8 color values color_a and color_b. This step can be easily carried out by bit-replication.","At step , two additional color values, color_a and color_b, are interpolated from color_a and color_b. Particularly, in the present embodiment, color_a and color_b are interpolated from color_a and color_b according to the following formulas:\n\ncolor_a=\u2154\u00d7color_a+ \/\u00d7color_b\n\ncolor_b=\u2153\u00d7color_a+ \/\u00d7color_b\n","At step , the color cell is reconstructed from the luminance-encoded bitmasks and the four color values. In the present embodiment, the bitmasks contain data identifying the luminance level of each of the pixels of the color cell. Thus, in the present embodiment, the color cell is reconstructed by assigning each pixel one of the representative colors, color_a, color_b, color_a, and color_b, according to the pixel's luminance level. According to the present invention, the reconstructed color cell closely resembles the uncompressed color cell despite the high data compression ratio.","The present invention may be applied to compress image data such as alpha-textures. Alpha-textures refer to image data having a fourth color value \u03b1 (in addition to RGB values) for creating images of transparent objects.  is a flow diagram  illustrating the method of compressing an alpha-texture color cell according to one embodiment of the present invention. In the present embodiment, alpha-texture data is divided into a matrix of color cells each including 4\u00d74 texels. Further, there are 24-bits of color values and 8-bits of alpha-values per texel. It should be appreciated that the number of texels per cell and the number of bits per texel are arbitrary, and the present invention may be applied to compress color cells of different sizes and having different number of bits per texel.","As illustrated in , at step , the RGB values of each texel of the color cell are compressed. In the present embodiment, the RGB values of each texel are compressed according to the method described in flow diagram  of  to generate luminance-encoded bitmasks and two RGB565 color values.","At step , an average alpha (\u03b1) of the cell is computed. In the present embodiment, \u03b1is computed by summing the alpha values of all the texels and by dividing the sum with the total number of texels of the cell. Thereafter, an upper-average alpha value (\u03b1) of the cell, and a lower-average alpha value (\u03b1) are computed. According to the present embodiment, \u03b1refers to the average alpha value of the texels which have a alpha value above \u03b1, and \u03b1refers to the average alpha value of the texels which have a lower alpha value than \u03b1. Further, in the present embodiment, the values \u03b1, \u03b1, and \u03b1, define four different alpha levels (or ranges) including a highest alpha level corresponding to texels having alpha values higher than \u03b1, a high alpha level corresponding to texels having alpha values between \u03b1and \u03b1, a low alpha level corresponding to texels having alpha values between \u03b1and \u03b1R, and a lowest alpha level corresponding to texels having alpha values lower than \u03b1.","With reference still to , at step , two alpha-encoded bitmasks are generated to represent the alpha level associated with each texel of the color cell. In the present embodiment, the alpha-encoded bitmasks include two 4\u00d74 bitmasks (one MSB bitmask and one LSB bitmask). For example, according to the present embodiment, if a pixel has an alpha value larger than or equal to \u03b1, the corresponding entry at the MSB bitmask is set to \u201c1.\u201d If the pixel has a luminance value smaller then \u03b1, the corresponding entry at the MSB bitmask is set to \u201c0.\u201d Similarly, any entry of the LSB bitmask will be set to \u201c1 \u201d if the luminance value of the corresponding pixel is higher than \u03b1or \u03b1, and will be set to \u201c0 \u201d if the luminance value of the corresponding pixel is lower than \u03b1or \u03b1.","At step , representative alphas of the color cell are generated. In the present embodiment, one representative alpha, alpha_a, is generated for the texels associated with the highest alpha level, and another representative alpha, alpha_b, is generated for the texels associated with the lowest alpha level. According to the present embodiment, alpha_a and alpha_b are generated by averaging the alpha values of all the texels within their respective alpha levels. Specifically, in the present embodiment, alpha_a is computed by averaging the alpha value of all the texels that have an alpha value above \u03b1, and alpha_b is computed by averaging the alpha values of all the texels that have an alpha value below \u03b1. In the present embodiment, alpha_a and alpha_b each comprises 8 bits.","At step , the two alpha values alpha_a and alpha_b generated at step  are appended to the alpha-encoded bitmasks. The resultant encoded (or compressed) color cell would therefore include two luminance-encoded bitmasks, two color values, two alpha-encoded bitmasks, and two alpha values. In the present embodiment, the encoded color cell includes 112 bits (32 bits of bitmasks for color compression, and two RGB565 color values, 32 bits of alpha-encoded bitmasks for alpha compression, and two 8-bit alpha values).","It should be appreciated that the present embodiment may be modified support luminance textures and intensity textures. Luminance and intensity textures include monochrome values that are defined by the OpenGL Specification, which is available from the present assignee, and which is incorporated herein by reference.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 5","FIG. 4"],"b":"600"},"As illustrated in , at step , the first RGB565 color and the second RGB565 color of the compressed color cell are first converted to two RGB8 color values color_a and color_b. Thereafter, two additional RGB8 color values color_a and color_b are interpolated from the color values color_a and color_b.","At step , two alpha values alpha_a and alpha_b are interpolated from the alpha values alpha_a and alpha_b present in the compressed color cell. Particularly, in the present embodiment, alpha_a and alpha_b are interpolated from alpha values alpha_a and alpha_b according to the following formulas:\n\nalpha_a1=\u2154\u00d7alpha_a+\u2153\u00d7alpha_b\n\nalpha_b1=\u2153\u00d7alpha_a+\u2154\u00d7alpha_b\n","At step , the color cell is reconstructed from the luminance-encoded bitmasks, four RGB8 color values, the alpha-encoded bitmasks, and four alpha values. In the present embodiment, the bitmasks contain data identifying the luminance level and the alpha level of each of the texels of the color cell. Thus, in the present embodiment, the color cell is reconstructed by assigning each texel one of the representative colors (color_a, color_b, color_a, and color_b) and one of the representative alphas (alpha_a, alpha_b, alpha_a, and alpha_b) according to the texel's luminance level and alpha level.","It should be appreciated that, the present embodiment may be modified to support luminance textures and intensity textures. Luminance textures and intensity textures are defined in the OpenGL specification, which is hereby incorporated by reference.","The present invention also provides for an apparatus that automatically and transparently uncompresses texture data contemporaneously with the texture-mapping process.  is a logical block diagram  illustrating portions of a graphics co-processor  that may be implemented in graphics subsystem  of computer system . As illustrated in , graphics co-processor  includes a decoder  for uncompressing compressed texture data, and a texture cache  for storing uncompressed texture data. Other portions of the graphics co-processor  are not illustrated in order to avoid obscuring aspects of the present invention. Also illustrated is system memory  of computer system  which stores compressed texture data and may comprise volatile memory , non-volatile memory , and data storage unit  of computer system .","Specifically, in the present embodiment, decoder  is configured for receiving and converting luminance-encoded bitmasks and color values, which may be generated by the compression method as illustrated in , into uncompressed color cells. Further, decoder  is configured for performing the conversion on the fly as texture data are transferred from the system memory  to the texture cache  on the fly. Hardware implementation and operations of the decoder  should be apparent to those of ordinary skill in the art upon reading the present disclosure. Therefore, implementation details are not described herein in detail to avoid obscuring aspects of the present invention. It should also be apparent to those of ordinary skill in the art that the present invention may be modified to uncompress alpha-textures, luminance-textures, intensity-textures, etc., transparently and automatically.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 7","b":"800"},"As illustrated in , at step , a color mean (cm) and a color variance of a color cell is computed. In the present embodiment, the color variance is approximated as a mean average error (MAE). Particularly, the following formula is used to approximate the MAE:\n\nMAE=sum (abs(c[i]\u2212cm))\/ N\n\nwhere N is the number of pixels in the color cell. The color mean (cm) is computed by averaging the color values of all the pixels in the color cell.\n","At step , a luminance mean (Y) is computed from the color mean. Particularly, in the presence embodiment, the luminance mean is computed from the color mean using well known methods and algorithms.","At step , the mean color value (c_upper) of all the pixels in the \u201cupper\u201d region (e.g., y[i]>=ym) and the mean color value for all the pixels in the \u201clower\u201d region (e.g., y[i]<ym) are computed based on the color mean (cm) and the MAE. Particularly, according to the present embodiment, the mean color values are computed using the following formulas:\n\nc_upper=cm+MAE\u00d7(N\/N)\n\nclower=cm+MAE\u00d7(N\/N)\n\nwhere N=number of pixels in the \u201cupper\u201d region, and where N=number of pixels in the \u201clower\u201d region.\n","At step , color variances for the \u201cupper\u201d and \u201clower\u201d regions are computed using c_upper and c_lower computed at step . Particularly, a mean average error for each of the \u201cupper\u201d and \u201clower\u201d regions are computed using the following formulas:\n\nMAE=sum (abs[i]\u2212c_upper)\n\nMAE=sum (abs[i]\u2212c_lower).\n","At step , the mean luminance value Yfor the \u201cupper\u201d region and the mean luminance value Yfor the \u201clower\u201d region are computed. In the present embodiment, the values Y, Y, and Y, define four different luminance levels (or ranges) including a highest luminance level corresponding to pixels having luminance values higher than Y, a high luminance level corresponding to pixels having luminance values between Yand Y, a low luminance level corresponding to pixels having luminance values between Yand Y, and a lowest luminance level corresponding to pixels having luminance values lower than Y. At step , luminance-encoded bitmasks are generated to represent the luminance level of each pixel of the color cell. In the present embodiment, the luminance-encoded bitmasks include two 4\u00d74 bitmasks (one MSB bitmask and one LSB bitmask). For example, according to the present embodiment, if a pixel has a luminance value larger than or equal to Y, the corresponding entry at the MSB bitmask is set to \u201c1.\u201d If the pixel has a luminance value smaller then Y, the corresponding entry at the MSB bitmask is set to \u201c0.\u201d Similarly, if the pixel has a luminance value larger than or equal to Y, the corresponding entries at the MSB bitmask and the LSB bitmask will be set to \u201c1.\u201d If the pixel has a luminance value smaller than Y, then the corresponding entries at the MSB bitmask and the LSB bitmask will be set to \u201c0.\u201d Similarly, an entry of the LSB bitmask will be set to \u201c1\u201d if the luminance value of the corresponding pixel is higher than Yor Y, and the entry will be set to \u201c0\u201d if the luminance value of the corresponding pixel is lower than Yor Y.","At step , the color mean value (cm) and three color variance values (MAE, MAE, and MAE) are appended to the luminance-encoded bitmasks. In the present embodiment, the luminance-encoded bitmasks include thirty-two bits, the color mean includes sixteen bits, and each color variance includes sixteen bits. In this way, a compression ratio of 4 bits per pixel is achieved.","One advantage of the progressive color cell compression method as described above is that image quality can be traded off with transmission speed, and the trade-off is user selectable. For example, the user may choose to transmit only the color mean value (cm) to represent the whole color cell when the transmission bandwidth is low. In another instance, the user may choose to send only the color mean value (cm), the MAE, and the MSB bitmask. In that event, the decoding algorithm will re-compute the average color for the \u201cupper\u201d region and the average color for the \u201clower\u201d region, and use the MSB bitmask to choose between them. The user may also choose to send all the data. In this case, the decoding algorithm will re-compute four color values based on the mean and three color MAEs. The bitmasks are then used to assign one of the four color values to each of the pixels for high bandwidth, high quality viewing.","According to one embodiment of the present invention, an even more accurate representation of the original color cell can be achieved by determining a vector that represents a best fit of all color values of the texels in the color cell in a multi-dimensional color space, and then choosing the four color values that lie on the vector as the representative colors of the cell. This method, although significantly more complicated than the interpolation method described above, produces compressed color cells that are superior in quality.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 8","b":["900","910"]},"At step , an energy weighing function is used to distribute four representative color values along the vector determined at step . According to the present embodiment, this step is performed as an iterative process that converges to a minimum energy solution.","At step , each of the sixteen texels of the color cell is compared to the four representative color values determined at step .","At step , two bitmasks are generated to store data identifying one of the representative color values that is closest to the corresponding texel. Each texel of the color cell is then assigned the mask value of the closest one of the representative colors.","At step , the four representative color values generated at step  are appended to the two bitmasks generated at step . The resultant encoded (or compressed) color cell would therefore include two bitmasks and two representative color values. The discarded representative color values are recovered using interpolation methods during uncompression.","An exemplary subroutine for finding the vector and the four representative color values that lie on the vector is given below in pseudocode.",{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Subroutine for Finding Representative Colors Using"},{"entry":"Co-variance Matrices and Energy Weighing Functions"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"main"},{"entry":"\u2003Readlmg"},{"entry":"\u2003- read in the texture to be compressed into memory"},{"entry":"\u2003Compresslmg"},{"entry":"\u2003\u2003- store image as a set of 4 \u00d7 4 tiles"},{"entry":"\u2003\u2003- for each tile call Quantize"},{"entry":"\u2003\u2003Quantize"},{"entry":"\u2003\u2003\u2003DoCollapse"},{"entry":"\u2003\u2003\u2003\u2003- compute a mean for r, g, and b"},{"entry":"\u2003\u2003\u2003\u2003- subtract means from each color component of each texel"},{"entry":"\u2003\u2003\u2003\u2003- find the best axis on which to assign our compressed colors"},{"entry":"\u2003\u2003\u2003\u2003findaxes"},{"entry":"\u2003\u2003\u2003\u2003\u2003-load a 3 \u00d7 3 matrix as follows:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Er{circumflex over (\u2009)}2 Egr Ebr"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Erg Eg{circumflex over (\u2009)}2 Ebg"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Erb Egb Eb{circumflex over (\u2009)}2"},{"entry":"\u2003\u2003\u2003\u2003\u2003- calculate the eigenvalues and normalize eigenvectors of the"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003above matrix using a call to EigenValues"},{"entry":"\u2003\u2003\u2003\u2003\u2003EigenValues"},{"entry":"\u2003\u2003\u2003\u2003\u2003- sort the eigenvectors into descending order"},{"entry":"\u2003\u2003\u2003\u2003\u2003EigenSort"},{"entry":"\u2003\u2003\u2003- generate the rotation matrix to move the color samples"},{"entry":"\u2003\u2003\u2003to align with the best axis"},{"entry":"\u2003\u2003\u2003FindRot"},{"entry":"\u2003\u2003\u2003- also generate the inverse rotation matrix"},{"entry":"\u2003\u2003\u2003FindRot"},{"entry":"\u2003\u2003\u2003- rotate the color samples so that they lie on the newly"},{"entry":"\u2003\u2003\u2003determined axis. Use a 3 \u00d7 3 matrix multiplication to do the"},{"entry":"\u2003\u2003\u2003rotation."},{"entry":"\u2003\u2003\u2003DoRotate"},{"entry":"\u2003\u2003\u2003- zero out the g and b components since we will only be"},{"entry":"\u2003\u2003\u2003optimizing position along the principle (now aligned with r axis)."},{"entry":"\u2003\u2003\u2003- find the min and max values of the 16 samples and assign"},{"entry":"\u2003\u2003\u2003them as the starting values of the search for the optimal"},{"entry":"\u2003\u2003\u2003compressed root values."},{"entry":"\u2003\u2003\u2003- call Remap recursively until it converges on the optimal two"},{"entry":"\u2003\u2003\u2003compressed root values."},{"entry":"\u2003\u2003\u2003Remap"},{"entry":"\u2003\u2003\u2003\u2003- generate the two intermediate root points"},{"entry":"\u2003\u2003\u2003\u2003\u2003r1 = .67 * r0 + .33 * r3;"},{"entry":"\u2003\u2003\u2003\u2003\u2003r2 = .33 * r0 + .67 * r3;"},{"entry":"\u2003\u2003\u2003- calculate signed error from each of the root points for each of the"},{"entry":"sample points."},{"entry":"\u2003\u2003\u2003- choose the root point that gives the minimum error for each"},{"entry":"sample point and"},{"entry":"\u2003\u2003\u2003keep a running total of the error for each root point."},{"entry":"\u2003\u2003\u2003- calculate the mean error for each root point"},{"entry":"\u2003\u2003\u2003- apply the mean error to modify the 2 root and 2 derived points"},{"entry":"\u2003\u2003\u2003- calculate new root points based on the errors determined above as"},{"entry":"follows:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003new_root_0 =","(r0 * (r0*3 + r1 + r2 + r3) +"]},{"entry":[{},"(r1 \u2212 (r2 \u2212 r1)) * (r1 + r2) +"]},{"entry":[{},"(r1 \u2212 (r3 \u2212 r1) * 0.5) * (r1 + r3) +"]},{"entry":[{},"(r2 \u2212 (r3 \u2212 r2) *2) * (r2 + r3))\/(3. *TILEAREA)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\u2003Similarly for new_root_3."},{"entry":"\u2003\u2003- calculate the mean standard error for the new root points"},{"entry":"\u2003\u2003- once the root colors have been optimized sort the 16 sample"},{"entry":"\u2003\u2003colors into the correct 1 of 4 bins."},{"entry":"\u2003BestColor"},{"entry":"\u2003\u2003- determine for each of the 16 samples which of the 4 root colors it is"},{"entry":"\u2003\u2003closest to."},{"entry":"\u2003\u2003- undo the rotation that made the color vector one dimensional by"},{"entry":"\u2003\u2003multiplying the root colors by the inverse matrix and adding the mean"},{"entry":"\u2003\u2003value per component back to the root colors."},{"entry":"\u2003\u2003- clamp the root colors components between 0 and 255"},{"entry":"\u2003\u2003DoRotate"},{"entry":"\u2003\u2003CompressPack"},{"entry":"\u2003\u2003- build up a mask of two bits for each of the texel samples."},{"entry":"\u2003\u2003- convert the RGB8 root colors into a RGB565 representation."},{"entry":"WriteCompimg"},{"entry":"\u2003- write out the compressed texture"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"It should be appreciated that the above method can be implemented using hardware and\/or software. If implemented in software, the above method can be implemented using common programming languages such as C, C++ or Java. An exemplary implementation of the subroutine above is included in Appendix A.","The present invention, a method and apparatus for compressing and uncompressing image data has thus been disclosed. Using the present invention, texture images may be moved around efficiently even when the bandwidth between the texture storage and the graphics rendering engine is limited. In this way, the efficiency of texture mapping is significantly increased. An even higher performance gain is attained in computer systems or electronic game systems where texture memory is limited. It should be appreciated that the present invention has been described with specific relevance to color cells having 4\u00d74 pixels. However, such specific reference should not be construed to limit the scope of the present invention. Rather, the scope of the present invention should be construed according to the below claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated in and form a part of this specification, illustrate embodiments of the present invention and, together with the description, serve to explain the principles of the invention.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
