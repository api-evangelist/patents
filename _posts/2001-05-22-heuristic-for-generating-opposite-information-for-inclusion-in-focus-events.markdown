---
title: Heuristic for generating opposite information for inclusion in focus events
abstract: A method for generating information for inclusion in focus events includes maintaining a list of components requesting focus in a selected application, determining whether a target of a first focus event matches a component at a head of the list, and if the target of the first focus event matches the component at the head of the list, marking the component at the head of the list for inclusion in an opposite field of a second focus event.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07007281&OS=07007281&RS=07007281
owner: Sun Microsystems, Inc.
number: 07007281
owner_city: Santa Clara
owner_country: US
publication_date: 20010522
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF INVENTION","SUMMARY OF INVENTION","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","The invention relates generally to windowing toolkits for computers.","2. Background Art","The basic functionality of a computer is dictated both by the hardware of the computer and by the type of operating system it uses. Various operating systems exist in the marketplace, including Solaris from Sun Microsystems, Inc., MacOS from Apple Computer, Inc., the \u201cWindows\u201d operating systems, e.g., Windows\u00ae 95\/98 and Windows NT\u00ae, from Microsoft Corporation, and Linux. A given combination of computer hardware, an operating system, and a windowing system will be referred to herein as a \u201cplatform.\u201d Prior to the popularity of the Internet, software developers wrote programs specifically designed to run on specific platforms. Thus, a program written for one platform could not be run on another. However, the advent of the Internet made cross-platform compatibility a necessity.","Prior art  illustrates a conceptual arrangement wherein a first computer  running the Solaris platform and a second computer  running the Windows\u00ae 98 platform are connected to a server  via the Internet . A resource provider using the server  might be any type of business, governmental, or educational institution. The resource provider has a need to provide its resources to both the user of the Solaris platform and the user of the Windows\u00ae 98 platform, but does not have the luxury of being able to custom-design its content for the individual platforms.","The Java\u2122 programming language was developed by Sun Microsystems to address this problem. The Java\u2122 programming language was designed to be simple for the programmer to use, yet to be able to run securely over a network and work on a wide range of platforms.","Prior art  illustrates how to create a Java\u2122 application. In order to create a Java\u2122 application, the developer first writes the application in human-readable Java\u2122 source code. As used herein, the term \u201capplication\u201d refers to both true Java\u2122 applications and Java\u2122 \u201capplets,\u201d which are essentially small applications usually embedded in a web page. In the example shown, the application \u201cProgram\u201d  is created as a human-readable text file. The name of this text file is given the required extension \u201c.java\u201d.","A Java\u2122 compiler , such as \u201cjavac\u201d available from Sun Microsystems, Inc., is used to compile the source code into a machine-readable binary file . The source text file  will contain Java\u2122 language commands, e.g., \u201cimport java.awt.Frame\u201d. A discussion of the Java\u2122 language itself is beyond the scope of this document. However, complete information regarding the Java\u2122 programming language is available from Sun Microsystems, both in print and via the Internet at java.sun.com. The resulting binary file  will automatically receive the same file name as the source text file , but will use \u201c.class\u201d as the trailing extension.","The Java\u2122 runtime environment incorporates a Java\u2122 \u201cvirtual machine\u201d (\u201cJVM\u201d)  to convert the \u201c.class\u201d byte codes into actual machine executions . The machine executions (like drawing windows, buttons, and user prompt fields) will occur in accordance to the application developer's code instructions. Because Sun Microsystems specifically designed the JVM to run on different platforms, a single set of \u201c.class\u201d byte codes will execute on any platform where a JVM has been installed. An Internet browser such as Netscape Navigator or Microsoft Internet Explorer that incorporates a JVM is called a \u201cJava\u2122-enabled\u201d browser.","The cross-platform architecture of the Java\u2122 programming language is illustrated in prior art , which shows how the Java\u2122 language enables cross-platform applications over the Internet. In the figure, the Solaris platform  and the Windows\u00ae 98 platform  are each provided with a Java\u2122 virtual machine (\u201cJVM\u201d) . The resource provider creates a Java\u2122 application using the Java\u2122 software development kit (\u201cSDK\u201d)  and makes the compiled Java\u2122 byte codes available on the server . Through standard Internet protocols, both the computer  and the computer  may obtain a copy of the same byte codes and, despite the difference in platforms, execute the byte codes through their respective JVMs.","Typical computer applications, including most Java\u2122 applications, provide graphical user interfaces, or GUIs. A GUI consists of graphical components, such as windows, buttons, and text fields displayed on the screen. The user interacts with an application by means of the GUI, clicking on the buttons or typing text into the text fields.","Platforms, including the Java\u2122 platform, provide the developer convenient means for writing the GUI portions of applications in the form of user interface toolkits. Such toolkits typically include a set of pre-built graphical components (buttons, text fields, etc.) that the developer uses to build applications. The toolkits may also provide mechanisms for other functions. One such function is keeping track of which component will receive keyboard input typed by the user. Typically, at any given time, keyboard input will be directed to one special component, called the \u201cfocused component\u201d or \u201cfocus owner\u201d. This component may be distinguished in appearance by a highlight or a blinking caret. The user may change which component is the focused component, typically by using the mouse to click on the desired new focus owner. Many user interface toolkits will interpret such mouse clicks and respond by resetting the focus owner to the clicked-on component.","Modem platforms provide facilities for multiple graphical applications to be running at the same time, and each application may present the user with multiple windows. Therefore, a typical display will show many windows simultaneously. One of these windows will usually be distinguished, typically with a darkened titlebar, as the \u201cactive window\u201d. The active window is the window with which the user is currently interacting. It will contain the focused component, if there is one.","Prior art  illustrates an exemplary display on a screen  including windows , , and . Each window includes a title bar  for displaying the title of the window and, if applicable, a menu bar  containing a number of pull down menu buttons defined by the developer. In this example, window  is the active window, as indicated by its darkened title bar. Windows  and  are inactive as indicated by their grayed out title bars. The text field  in window  is the focus owner, as indicated by the caret (which may be blinking, to further draw the user's attention). The window  includes a number of typical components, including \u201cradio buttons\u201d  which in this case allow the user to select a prefix, a text field  for entering a name, and an address field  for entering an address. Component  is a \u201cchooser\u201d that allows the user to choose a state. \u201cCheck boxes\u201d  allow the user to select one or all of the options that apply. Associated with these check boxes are additional radio buttons  and  that allow the user to select a desired means of transmission. If the \u201cQUOTE\u201d check box  is selected and the telephone radio button is selected, the window  appears allowing the user to enter telephone numbers. An additional text area  is associated with the \u201cOTHER\u201d check box . Finally, \u201cSUBMIT\u201d and \u201cRESET\u201d buttons  are provided to allow the user to either submit the form or to reset it.","The Java\u2122 platform provides the developer with two user interface toolkits that may be used to build applications: the Abstract Windowing Toolkit, abbreviated AWT, and Swing. The AWT has a unique architecture, in that it is built on top of each platform's native toolkit and uses each platform's native components. For example, an AWT text field consists of the native toolkit's text field component, together with additional data. The underlying native component, called the \u201cheavyweight peer,\u201d is used to provide much of the AWT component's functionality. For example, the AWT delegates the job of painting the component on the screen to the native toolkit. In this way, the AWT can be used to build applications that, on each platform, look and behave like the platform's native applications.","Swing, by contrast, contains no heavyweight peers. Instead, its components are \u201clightweight,\u201d that is, have no corresponding native components. In fact, the underlying native toolkit is unaware of Swing's components, so nearly all of the components' functionality must be provided by Swing.","When a user interacts with a computer by typing on the keyboard or clicking the mouse on different areas of the computer screen, the underlying native platform informs the appropriate application of the user's actions by means of native \u201cevents.\u201d These events are platform-specific and contain different information depending on the action that the user performed. For example, if the user typed a key on the keyboard, the underlying platform might generate a \u201ckey pressed\u201d event when the key was pressed and a \u201ckey released event\u201d when the key was released. The events will contain various information about the user action, such as which key was pressed and released or the state of the keyboard (e.g., the CAPS-LOCK key) during the user's actions.","As mentioned above, the events are generated by the underlying platform and are therefore platform-specific. Different platforms will generate different events in response to the same user actions, and the events themselves will contain different information depending on the platform that generated them. Another difference between platforms may be the way in which events are delivered to the appropriate application. On some systems, events might be placed on a queue, and it is the application's responsibility to dequeue the events and process them. On other systems, the application may register a special procedure, called an \u201cevent handler,\u201d with the underlying platform. This event handler will be called whenever the platform wishes to deliver an event to that application.","These platform differences in events and event delivery mechanisms are some of the reasons that, prior to the Java\u2122 platform's introduction, it was impossible for developers to write applications that worked on multiple platforms without customizing the application for each platform. The Java\u2122 user interface toolkits address this problem by providing a uniform event model for all platforms on which the Java\u2122 platform is implemented. The Java\u2122 implementation hides both the native delivery mechanism and the native events themselves from its applications by registering native handlers or dequeuing native events as appropriate. Then, based on the native events it receives, it generates the appropriate \u201cJava\u2122 events\u201d and delivers them to its applications via a mechanism of its own (typically by calling Java\u2122 event handlers registered by the Java\u2122 application.)","Because different platforms generate different native events, it follows that there is not a one-to-one mapping between native events and Java\u2122 events. Also, because native events on different platforms contain different information, in some cases platform-specific information may be omitted from a Java\u2122 event, while in other cases information not present in a native event may need to be computed for inclusion in a Java\u2122 event. It is the job of the Java\u2122 implementation on each platform to unify these differences so that Java\u2122 applications on different platforms receive the same sequence of Java\u2122 events when exposed to the same user actions.","One class of Java\u2122 events generated by the Java\u2122 implementation on each platform are focus events. A component becomes the focus owner when it receives a FocusGained event, and it ceases being the focus owner when it receives a FocusLost event. The Java\u2122 Standard Edition SDK, version 1.4 defines a new field in its focus events: the \u201copposite\u201d field. In a FocusLost event, the opposite field specifies the component that is gaining focus in conjunction with this FocusLost event, that is, it specifies where the focus is going next. In a FocusGained event, the opposite field specifies the component that is losing focus in conjunction with this FocusGained event, that is, it specifies where the focus is coming from. Some native platforms, such as those running the various Windows operating systems, provide the opposite components in their native focus events, and those components can then be included in the corresponding Java\u2122 events. However, the X windowing system, for example, does not provide this information, so Java\u2122 implementations on X-based platforms must compute the opposite components for inclusion in the Java\u2122 focus events.","Therefore, there is a need for a method for computing the information to include in opposite fields of Java\u2122 focus events.","In one aspect, the invention relates to a method for generating information for inclusion in focus events which comprises maintaining a list of components requesting focus in a selected application and determining whether a target of a first focus event matches a component at the head of the list. If the target of the first focus event matches the component at the head of the list, the method further comprises marking the component at the head of the list for inclusion in an opposite field of a second focus event.","In another aspect, the invention relates to a method for generating information for inclusion in focus events which comprises maintaining a list of components requesting focus in a selected application and determining whether a target of a first focus event matches a component at the head of the list. If the target of the first focus event matches the component at the head of the list, the method further comprises marking the component at the head of the list for inclusion in an opposite field of a second focus event and marking a component next to the component at the head of the list for inclusion in an opposite field of the first focus event.","In another aspect, the invention relates to a computer-readable medium having stored thereon a program which is executable by a processor. The program comprises instructions for maintaining a list of components requesting focus in a selected application. The program further includes determining an opposite field of a first focus event and an opposite field of a second focus event based on a target of the first focus event, a target of the second focus event, and the list of components requesting focus.","Other aspects and advantages of the invention will be apparent from the following description and the appended claims.","Specific embodiments of the invention will now be described in detail with reference to the accompanying drawings. Like elements in the various figures are denoted by the same reference numerals for consistency.","The invention described here may be implemented on virtually any type of computer regardless of the platform being used. For example, as shown in , a typical computer  will have a processor , associated memory , and numerous other elements and functionalities typical to today's computers (not shown). The computer  will have associated therewith input means such as a keyboard  and a mouse , although in an accessible environment these input means may take other forms. The computer  will also be associated with an output device such as a display , which may also take a different form in an accessible environment. Computer  is connected via a connection means  to the Internet . The computer  is configured to run a Java\u2122 virtual machine , implemented either in hardware or in software.","The present invention provides a method for computing the information to include in \u201copposite\u201d fields of Java\u2122 focus events. The method works perfectly for computing such information whenever focus is transferred between components within the same top-level window. When focus transfers outside of the window, the method may fail and report the opposite component incorrectly or as \u201cnull\u201d. However, it will recover and report opposite components correctly upon subsequent, intra-window transfers.","The method relies on two observations about the circumstances under which Java\u2122 focus events are generated due only to the operation of the Java\u2122 application in question. The key observation is that such events are generated only as a result of one of two causes: either a Java\u2122-level programmatic focus request, or a user button click on a focusable heavyweight component (resulting in a native focus request on that component). In each of these two cases, a pair of events is generated: a FocusLost event on the component that previously had focus, and a FocusGained event on the component requesting focus. Thus, our second observation is that, since application-caused Java\u2122 focus events are always generated in such \u201clost\/gained\u201d pairs, computing the opposite component for FocusGained events is easy: it is the component on which a FocusLost event has just been generated. If there is no such FocusLost event, then focus is coming from somewhere outside the scope of our application; in that case, we use \u201cnull\u201d as the opposite component.","On the other hand, in order to compute the opposite component for a FocusLost event, we would need to predict the future: we would need to know what FocusGained event will be generated next. We can't know this information for certain\u2014for example, the focus change may not be internal to the application and focus may be going to an unrelated, native application window. Recall, however, that each focus request will typically result in a FocusGained event being generated. Thus, if we keep a queue of all the focus requests, we can use it to guess the opposite component for FocusLost events. When generating a FocusLost event, we would look at the first request on the queue, use the component making the request as the opposite component in the FocusLost event, and dequeue the request.","In order to compute this information, a list of components that have issued either Java\u2122 or native-level focus requests, but have not yet received focus notification events, is maintained. Herein, this list of components is referred to as the Focus List.  shows a graphical representation of the Focus List, generally identified by reference numeral . Focus List  can have zero, one, or more list elements . Each list element has a \u201crequester\u201d member and a \u201cnext\u201d member. The \u201crequester\u201d member contains data that identifies a Java\u2122 component  that has at some point in time issued either a Java\u2122 or native-level focus request. The \u201cnext\u201d member contains the memory location of the next element in the list. Two pointers called \u201cFocus List Head\u201d and \u201cFocus List End\u201d are maintained. Focus List Head points to the top of Focus List , and Focus List End points to the end of Focus List .",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 7","FIG. 6","FIG. 6"],"b":["102","100","106","110","108"]},"As illustrated, the process involves checking whether Focus List End is null (ST), i.e., whether Focus List ( in ) is empty. If Focus List End is null, then memory allocation is made for a new list element (ST). At step ST, the new list element is added to the Focus List ( in ). Then, Focus List End is modified such that it points to the new list element. At step ST, the \u201crequestor\u201d member of the element pointed to by Focus List End is set to the component requesting focus, and the \u201cnext\u201d member of the element pointed to by Focus List End is set to null.","Returning to step ST, if Focus List End is not null, then the process involves checking whether the component requesting focus is the same as the \u201crequestor\u201d member of the element pointed to by Focus List End (ST). If the component requesting focus and the \u201crequestor\u201d member of the element pointed to by Focus List End are the same, then no action is required (ST). Otherwise, memory allocation is made for a new list element (ST). The \u201cnext\u201d member of the element pointed to by Focus List End is set to the new list element, and Focus List End is then adjusted to point to the new list element (ST). The \u201crequester\u201d member of the element pointed to by Focus List End is set to the component requesting focus, and the \u201cnext\u201d member of the element pointed to by Focus List End is set to null (ST).","As Java\u2122-level focus events are generated by the Java\u2122 platform, the opposite component involved in the focus transfer is computed.  shows how to compute the opposite component when a FocusLost event is being generated for the component that currently has the focus (ST). At this point, the process of determining the opposite component involves checking whether Focus List Head is null (ST). If Focus List Head is null, there are no elements in the Focus List ( in ), and the opposite component for the FocusLost event is set to null (ST), because no guess can be made as to where the focus is going (it is probably going out of the scope of this application). If Focus List Head is not null, the process involves determining whether the current focus owner matches the component at the head of the Focus List ( in ). If it does not, or if there are no components in the Focus List, then the FocusLost event also resulted from a focus request from outside of the current application, such as a user clicking on an unrelated window on the desktop. In this case, the opposite component for the FocusLost event is set to null. Then the Focus List ( in ) is cleared, because, once focus leaves the application, the queued up requests will be ignored and will not be resulting in focus events.","To clear the Focus List ( in ), the \u201cnext\u201d member of the element pointed to by Focus List Head is copied into a temporary variable (ST). The memory allocated to the list element pointed to by Focus List Head is then de-allocated (ST). After this, Focus List Head is modified to point to the list element identified in the temporary variable (ST). The process then checks whether Focus List Head is null (ST). If Focus List Head is not null, steps ST, ST, and ST are repeated until Focus List Head becomes null. When Focus List Head becomes null, the opposite component for the FocusLost event is set to null (ST).","Returning to step ST, if the \u201crequester\u201d member of the list element pointed to by Focus List Head is the same as the current focus owner, then the component identified by the \u201crequester\u201d member is saved as the opposite field for the next FocusGained event.  illustrates the process in detail. As shown, the \u201cnext\u201d member of the list element at the head of the Focus List ( in ) is copied into a temporary variable, and the \u201crequester\u201d member of the list element is copied into a variable called \u201cforGained\u201d (ST). Then the memory allocated to the element at the head of the Focus List ( in ) is de-allocated (ST). Focus List Head is then modified to point to the list element identified in the temporary variable (ST). The process continues with checking whether Focus List Head is null (ST). If Focus List Head is null, then Focus List End is set to null (ST), and the opposite component for the FocusLost event is set to null (ST). If Focus List Head is not null, then the opposite component for the FocusLost event is set to the \u201crequestor\u201d member of the list element pointed to by Focus List Head (ST).",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 9","FIG. 6"],"b":["156","158","159","160","100","162"]},"Returning to step ST, if the component at the head of the Focus List ( in ) does not match the new focus owner, then the FocusGained event is being generated on a component for which we are not expecting such an event. This may happen if, for example, focus had been transferred out of the scope of this application before all the focus events for the queued up requests had been generated, and is now being transferred back. This case requires the Focus List ( in ) to be cleared, because focus events corresponding to the requests on the list will not be generated. To clear the list, the \u201cnext\u201d member of the list element at the head of the Focus List ( in ) is copied into a \u201ctemporary\u201d variable (ST). Then, the memory allocated to this list element is de-allocated (ST). Focus List Head is modified to point to the list element identified by the temporary variable (ST). At step ST, the process further involves checking whether Focus List Head is null. If Focus List Head is not null, steps ST, ST, and ST are repeated until Focus List Head becomes null. When Focus List Head becomes null (ST), Focus List End is set to null (ST), and the opposite component for the FocusGained event is set to null (ST).","The invention may provide general advantages in that it provides a method for computing the information required for opposite fields of focus events. The invention is useful when the native platform or native windowing toolkit does not normally provide this information. As described above, a list of components that have issued focus requests is maintained. The list is then used to determine the opposite information when focus events are processed.","While the invention has been described with respect to a limited number of embodiments, those skilled in the art, having benefit of this disclosure, will appreciate that other embodiments can be devised which do not depart from the scope of the invention as disclosed herein. Accordingly, the scope of the invention should be limited only by the attached claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 8B","FIG. 8A"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
