---
title: Techniques for changing XML content in a relational database
abstract: Techniques are provided for changing data for an XML construct in an SQL/XML compliant database management system (DBMS). The DBMS allows instances of XML type to represent XML constructs, such as XML documents, XML elements, XML attributes, and fragments of XML documents. An SQL statement is received that includes an XML operator that operates on a particular component in an instance of XML type. During execution of the SQL statement, the XML operator is evaluated by modifying content for the component without modifying the entire instance. For example, an XML delete operator deletes the particular component from the instance. Other XML operators include an insert operator, an insert-before operator, an append-child operator, and an update operator. During execution, these operators may be rewritten to operate on existing SQL constructs, or evaluated by updating only some of the existing SQL constructs, or both.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07386567&OS=07386567&RS=07386567
owner: Oracle International Corporation
number: 07386567
owner_city: Redwood Shores
owner_country: US
publication_date: 20040930
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","Functional Overview","Structural Overview","New SQL\/XML Functions","Example Contents of XML Document","In-Memory Representation","DELETEXML Operator","INSERTXML Operator","INSERTXMLBEFORE Operator","APPENDCHILDXML Operator","UPDATEXML Operator","Storing the Modified XML Instance","Rewrite of SQL Statement with Operator","Dirty-Bit Optimization","Hardware Overview"],"p":["This application is a continuation of and claims priority to U.S. patent application Ser. No. 10\/428,445, filed May 1, 2003, now U.S. Pat. No. 6,836,778 entitled \u201cTechniques for Changing XML Content in a Relational Database\u201d, the contents of which are hereby incorporated by reference as if fully set forth herein.","This application is related to application Ser. No. 10\/259,278, filed Sep. 27, 2002, (hereinafter referenced as Murthy et al.) the entire contents of which are hereby incorporated by reference as if fully set forth herein.","The present invention relates to techniques for using eXtensible Markup Language (XML) data in a relational database system.","The World Wide Web (WWW) involves a network of servers on the Internet, each of which is associated with one or more Hypertext Markup Language (HTML) pages. The HTML pages are transferred between clients that make requests of servers and the servers using the Hypertext Transfer Protocol (HTTP). Resources available from servers on the Internet are located using a Universal Resource Locator (URL). The standards and protocols of the WWW are promulgated by the World Wide Web Consortium (W3C) through its servers at www.w3c.org, and are used on many private networks in addition to their use on the Internet.","The HTML standard is one application of a more general markup language standard called the Standard Generalized Markup Language (SGML). Recently, a subset of SGML that is more powerful and flexible than HTML has been defined and has gained popularity for transferring information over the Internet and other networks. The new standard, developed and promoted by W3C, is called the eXtensible Markup Language (XML). XML provides a common syntax for expressing structure in data. Structured data refers to data that is tagged for its content, meaning, or use. XML provides an expansion of the tagging that is done in HTML, which focuses on format or presentation. XML tags identify XML elements and attributes of XML elements. XML elements can be nested to form hierarchies of elements. As used hereinafter, the terms \u201celement\u201d and \u201cattribute\u201d retain their general meaning and are not limited to XML elements and XML attributes, unless otherwise clear from the context.","A set of syntax rules for XML elements shared by multiple XML documents is defined by an XML schema, itself an XML document. For example, the syntax rules indicate what elements can be used in a document, in what order they should appear, which elements can appear inside other elements, which elements have attributes, what those attributes are, and any restrictions on the type of data or number of occurrences of an element. XML allows documents to contain elements from several distinct XML schema by the use of namespaces. In particular, elements from other, independently created XML schema can be interleaved in one XML document.","Given the elements defined and used by XML, a document object model (DOM) is a tree structure formed to define how the information in a particular XML document is arranged. The DOM is navigated using an XPath expression that indicates a particular node or content in the hierarchy of elements and attributes in an XML document. XPath is a standard promulgated by W3C.","Relational databases predate, and developed independently of, the World Wide Web. Relational databases store data in various types of data containers that correspond to logical relationships within the data. As a consequence, relational databases support powerful search and update capabilities. Relational databases typically store data in tables of rows and columns where the values in all the columns of one row are related. For example, the values in one row of an employee table describe attributes of the same employee, such as her name, social security number, address, salary, telephone number and other information. Each attribute is stored in a different column. Some attributes, called collections, can have multiple entries. For example, the employee may be allowed to have multiple telephone numbers. Special structures are defined in some relational databases to store collections.","A relational database management system (DBMS) is a system that stores and retrieves data in a relational database. The relational DBMS processes requests to perform database functions such as creating and deleting tables, adding and deleting data in tables, and retrieving data from the tables in the database. A well-known standard language for expressing the database requests is the Structured Query Language (SQL).","Object-relational databases extend the power of relational databases. Object-relational databases allow the value in a column to be an object, which may include multiple other attributes. For example, the value in the address column may be an address object that itself has multiple attributes, such as a street address, a city, a state, a country, and a zip code or equivalent. An object type (also called an abstract data type ADT) defines the attributes of an object in an object relational database. SQL has been extended to allow the definition and use of objects and object types in object-relational databases. As used hereinafter, the term \u201cobject-relational database\u201d refers to a subset of relational databases that support object-relational constructs; and an object-relational construct is one example of a relational construct. The term \u201cSQL construct\u201d is used hereinafter to refer to relational constructs, such as tables, columns, and rows, and object-relational constructs such as ADT columns and tables and collections.","Because of the popularity of XML as a data exchange format that supports hierarchical relationships among XML elements, and because of the power of relational DBMSs to update and retrieve data, there is a demand for generating XML data output from relational databases and storing XML data into relational databases. In one approach, a database administrator can commission programming efforts to generate code in a procedural language that maps data in particular XML constructs to data in particular relational database constructs and back. Such programming efforts can be expensive.","In another approach, declarative statements, similar to SQL statements, can be employed to simply express the relationship between XML constructs and SQL constructs. General routines that convert the data according to declared relationships are written one time by a DBMS vendor and supplied to a database administrator. This saves the database administrator from developing procedural language programs to convert the data. To support this demand, an industry standard SQL to operate on XML documents has been developed. This standard is called SQL\/XML and documents relating to SQL\/XML are available at the time of this writing at www.sqlx.org. SQL\/XML provides declarative statements that can be used to simply express some conversions between hierarchical XML constructs and SQL constructs. For example XMLAgg is a SQL\/XML function that generates one XML construct from a set of XML elements generated from selected rows of a relational table. For convenience, hereinafter data that is used for an XML document or fragment thereof is called \u201cXML data,\u201d even if it is stored in SQL constructs.","While SQL\/XML statements provide powerful tools for many circumstances that arise in converting between XML constructs and SQL constructs, they do not simply accommodate all circumstances that arise. For example, conventional SQL\/XML statements do not support modifications to an XML document stored in the SQL DBMS. An XML document is ingested whole or is output whole by the SQL DBMS. A user of the DBMS can make modifications to the contents of the SQL constructs only if the user knows the SQL constructs in sufficient detail. However, a user who knows more readily the XML constructs (e.g., the XML document, XML elements, XML attributes, and fragments of the XML document), cannot use declarative statements that refer to those constructs to modify the document in the DBMS using conventional SQL\/XML commands. Such a user might generate the whole XML document from the database, update the document with an XML editor that works on the whole XML document, and then store the revised whole XML document back into the database managed by the SQL compliant DBMS, utilizing DBMS capability to generate needed SQL constructs for the revised XML document.","Based on the foregoing, there is a clear need for SQL compliant declarative statements that allow a user to express changes to the content of an XML construct managed in an SQL compliant DBMS in terms of the XML constructs.","One approach an SQL compliant DBMS can follow is to allow a user to declaratively specify a change to an XML construct in an XML document, and then to have the DBMS temporarily and internally generate the whole XML document from the database, update the document with an XML editor that works on the whole XML document, and then store the revised whole XML document back into the database, generating SQL constructs as needed to hold the new XML constructs. This approach is useful, for example, when the whole document is stored as a single large object (LOB), which is one SQL construct. However, if different XML constructs are stored in different SQL constructs, this approach involves generating XML data from multiple SQL constructs, editing the XML document, and then forming or filling again every SQL construct used to store XML data for the revised XML document. If the contents of some SQL constructs have not changed, computational resources consumed, in outputting data to the temporary XML document from such unchanged constructs and then storing the same data back into the same SQL construct, are wasted.","Based on the foregoing, there is a clear need for evaluating declarative statements that specify changes to content of an XML document without modifying SQL constructs that are not affected by the changes.","The approaches described in this section could be pursued, but are not necessarily approaches that have been previously conceived or pursued. Therefore, unless otherwise indicated herein, the approaches described in this section are not to be considered prior art to the claims in this application merely due to the presence of these approaches in this background section.","Techniques are described for changing XML data in a SQL compliant DBMS. In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.","Techniques are provided for changing data for an XML construct in a SQL\/XML compliant DBMS. XML constructs include XML documents, XML elements, XML attributes of XML elements, and fragments of XML documents that include multiple elements at the root level or otherwise do not meet all the requirements of an XML document, among others. The DBMS allows instances of XML type (also called XML instances, herein) to represent XML constructs and allows SQL constructs, such as rows, columns, tables, collections, and LOBs, to store data for XML constructs. In these techniques, an SQL statement is received that includes one or more XML modification operators that operate on a particular component of an instance of XML type. During execution of the SQL statement, the XML modification operator is evaluated by changing the component without changing the entire instance of XML type. For example, an XML delete operator deletes the particular component from the instance of XML type. Other XML operators include an insert operator, an insert-before operator, an append-child operator, and an update operator. In other embodiments, different, more or fewer operators are included. When applied in statements with data manipulation language (DML) operations to change stored data, these operators may be rewritten as SQL operations that operate on SQL constructs, or may be evaluated by updating only some of the SQL constructs, such as the SQL constructs that store data for the particular component, or both.","In one aspect of the invention, the techniques include receiving an SQL statement that includes an operator that operates on a component that is less than all of an instance of XML type. During execution of the SQL statement, the operator is evaluated by modifying content for the component without modifying all of the instance of XML type.","In one aspect of the invention, the techniques include receiving an SQL statement that includes a delete operator. The delete operator operates on a target component of an instance of XML type. During execution of the SQL statement, the delete operator is evaluated by deleting the target component from the instance of XML type.","In another aspect of the invention, an SQL statement is received that includes an insert operator. The insert operator operates on a target component, data that indicates a name, and an expression. The target component is in an instance of XML type, and represents a first XML construct. The data indicates the name of an element for the first XML construct. The expression is for a particular value for XML content. During execution of the SQL statement, the insert operator is evaluated by generating a second component that represents a second XML construct based on the expression. The second XML construct is a child XML element of the target XML construct and has an XML element name based on the data that indicates the name.","According to another aspect of the invention, an SQL statement is received that includes an insert-before operator. The insert-before operator operates on a target component and an expression. The target component is in an instance of XML type, and represents a first XML construct. The expression is for a particular value for XML content. During execution of the SQL statement, the insert-before operator is evaluated by generating a second component that represents a second XML construct based on the expression. The second XML construct is inserted before the first XML construct in the instance of XML type in XML document order.","According to another aspect of the invention, an SQL statement is received that includes an append-child operator. The append child operator operates on a target component and an expression. The target component is in an instance of XML type, and represents a first XML construct. During execution of the SQL statement, the append-child operator is evaluated by generating a second component that represents a second XML construct based on the expression. The second XML construct is a child of the first XML construct in the instance of XML type.","According to another aspect of the invention, an SQL statement is received that includes an update operator. The update operator operates on a component and an expression. The target component is in an instance of XML type, and represents a first XML construct. During execution of the SQL statement, the update operator is evaluated by generating a second component that represents a second XML construct based on the expression. The second XML construct replaces the first XML construct in the instance of XML type.","According to another aspect of the invention, a database modification statement is received to modify a target component in an instance of XML type. During execution of the database modification statement, the database modification statement is evaluated by determining a first portion of the instance of XML type. The first portion is affected by executing the database modification statement, and is less than the entire instance of XML type. The first portion is mapped to a first set of at least one SQL construct. The first set is updated without updating a second set of at least one SQL construct. The second set represents a second portion of the instance of XML type, which is not affected by executing the database modification statement.","According to another aspect of the invention, a database modification statement is received to modify a target component in an instance of XML type. The target component represents a first XML construct. The database modification statement is compiled by determining a particular set of one or more SQL constructs that are affected by the database modification statement. The database modification statement is rewritten as a set of one or more SQL operations that operate on the particular set of one or more SQL constructs. The database modification statement is evaluated by evaluating the set of one or more SQL operations on the particular set of one or more SQL constructs.","Embodiments are described in the following in the context of a commercial SQL\/XML database server, which uses object-relational constructs for storage of content for one or more XML constructs, which may represent an XML construct as an instance of XML type, and which responds to SQL statements with standard and non-standard XML functions that operate on XPath expressions identifying XML content to be changed. XPath expressions locate data in an XML document. SQL\/XML standard functions that operate on XPath expressions include EXTRACT, EXTRACTVALUE, AND EXISTSNODE, which are well known in the art. Such a commercial SQL\/XML DBMS is the Oracle 9i Database Server available from Oracle International Corporation of Redwood Shores, Calif. As used hereinafter, XML functions include non-standard functions with the described behavior as well as the standard functions promulgated by W3C.","However, the invention is not limited to this context, but may be applied in any context involving relational database constructs for storing XML data. For example, embodiments may be employed in an XML database that uses relational database constructs but not object-relational constructs. Embodiments may be employed in an SQL\/XML database that is accessed through an application programming interface (API) rather than being accessed as a server that responds to messages sent over a network. In some embodiments, the SQL statement may include data definition language (DDL) operations to change the relational database constructs used to store the XML or non-XML contents.","In some embodiments, another syntax different from XPath may be used to express locations of data within an XML instance; and XML operations different from the named XML functions may be used to combine or compare or change data located in an XML instance. For example, an object notation (in which levels in an object hierarchy are indicated by dots between object names) may be used to express an object-relational data item that corresponds to an XML element or attribute instead of XPath notation (in which levels in an XML hierarchy are indicated by slashes \u201c\/\u201d between element names); and the object notation may be used as an argument for an XML function.","Structures involved in embodiments of the invention include XML documents with XML constructs and SQL constructs.  is a block diagram that illustrates an example system  including an example XML document , an example associated XML schema , and example object-relational constructs that store XML document contents in an object-relational database managed by an object-relational database server .","XML document  is an instance of a particular XML document type, called hereinafter a \u201cPO\u201d XML document, which describes purchase orders used by an enterprise. For purposes of illustration it is assumed that an example PO document  includes an XML element  named \u201cpurchaseOrder.\u201d The purchaseOrder element  includes an XML attribute  named \u201corderDate\u201d and XML elements , named \u201cshipTo\u201d and \u201citemList,\u201d respectively. The orderDate attribute  holds data that indicates the date that the purchase order was generated by the enterprise. The shipTo element is described in the next paragraph. The itemList element holds data indicating the items purchased. In other embodiments, more or fewer XML attributes and XML elements are included in a purchaseOrder element. Ellipsis  indicates that other purchaseOrder elements may be included in the PO XML document. For purposes of illustration, it is assumed that the illustrated PO document includes just one purchaseOrder element.","The shipTo element includes XML attribute , named \u201ccountry,\u201d and two XML elements , . The country attribute holds data that indicates the country to which items purchased are to be shipped. The XML element is named \u201cname\u201d and holds data indicating the name of the person to whom items purchased are to be shipped. The XML element is named \u201cstreet\u201d and holds data indicating the street address to which the items purchased are to be shipped.","The PO type may be described in an XML schema document such as XML schema . For example, the XML schema  lists several XML constructs used in XML documents of type PO, which include elements purchaseOrder, ShipTo and itemList and attributes orderDate and country, among others. XML schema  indicates what type of information is stored in each of these elements and what attributes each element has. Information types may include, for example, character data, numeric data, and another element, among other types of information. For example, the XML schema  specifies that orderDate attribute  must hold date data.","Example XML database server  is an object-relational database server, which imports and exports XML documents, which represents XML constructs as XML instances, which stores contents for the XML constructs in one or more SQL constructs in database storage space , and which uses database memory .","The database storage space  includes mapping  and one or more other SQL constructs, such as table  and table  for collections, and rows and columns in those tables. In other embodiments, more or fewer SQL constructs are included. For example, some XML constructs may be stored in one or more large objects (LOBs).","XML Database Server  stores a mapping  between XML elements or attributes and one or more SQL constructs. In some embodiments, as described in Murthy et al., the mapping includes an XML schema with optional notations that indicated SQL construct properties. For example, elements of type shipTo are associated with a shipto column of object type in a PO table . The object attributes of the shipto object include a country column, a name column and a street column. Elements of type itemList are associated with column itemlist of collection type in table . Metadata associated with the itemlist column indicates that the collection is stored in a separate collection table  (also called a \u201cstore table\u201d). The itemlist column includes a value (e.g., a set identification) that is used to identify the associated rows in the collection table . Although the methods of Murthy et al. allow the column names to differ in any way from the element names, for simplicity in the illustrated embodiment, the column names in Table  are lowercase versions of the corresponding element or attribute names in PO type documents. The mapping  is used to convert between data in XML documents, like XML document , and data in one or more XML type object-relational constructs, such as rows in Table .","The database server memory  is used to hold data being operated upon by the server. The memory  may include volatile and persistent memory. In the illustrated embodiment, the XML database server  represents XML constructs as a tree model  in the memory  of the database server . The data structures used to represent the tree model in one embodiment are described in a later section.","According to various embodiments, new XML functions enhance the management of XML data in an SQL compliant DBMS by allowing pieces of an XML instance to be changed. For purposes of illustration, five new functions are described. They are called DELETEXML, INSERTXML, INSERTXMLBEFORE, APPENDCHILDXML, and UPDATEXML; but, in other embodiments, any or all of the functions may be given different names or take different forms and more or fewer or different operators may be implemented. For example, instead of a function call, in other embodiments the operations performed by these or other functions may be performed by a separate server in response to a messages sent by the DBMS. The example functions are described in more detail in following sections.","To illustrate the use of these functions in declarative SQL statements to manage XML data, it is assumed one purchase order stored in one row of PO table , and several rows in collection table , corresponds to the XML instance listed in Table 1.",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example XML instance stored in SQL\/XML compliant DBMS."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["line","XML instance"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1",". . ."]},{"entry":["2","<purchaseOrder orderDate=\u201c1999-10-20\u201d>"]},{"entry":["3","\u2003<shipTo country = \u201cUS\u201d>"]},{"entry":["4","\u2003\u2003<name> Alice Smith <\/name>"]},{"entry":["5","\u2003\u2003<street> 123 Maple Street <\/street>"]},{"entry":["6","\u2003<\/shipTo>"]},{"entry":["7","\u2003<itemList>"]},{"entry":["8","\u2003\u2003. . ."]},{"entry":["9","\u2003<\/itemList>"]},{"entry":["10","<\/purchaseOrder>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"As shown in Table 1, the XML element purchaseOrder begins on line 2 with the angle brackets \u201c<>\u201d marking an opening tag that includes the element name \u201cpurchaseOrder\u201d. Also included in the opening tag is the name of an attribute, named \u201corderDate,\u201d followed by the symbol \u201c=\u201d which, in turn, is followed by a value for the attribute within quotation marks. The XML element purchaseOrder ends on line 10 with the angle brackets \u201c<>\u201d enclosing the slash \u201c\/\u201d that indicates an ending tag, followed by the element name \u201cpurchaseOrder\u201d. The data on lines 2 through 10 represent the value of the purchaseOrder element. The value of the purchaseOrder element includes two child elements ShipTo, on lines 3 through 6, and itemList, on lines 7 through 9. The element shipTo includes the attribute country and the two child elements of shipTo, e.g., the element \u201cname\u201d on line 4 and the element \u201cstreet\u201d on line 5. The contents of the element itemList are not shown explicitly, but are represented by the ellipsis on line 8.","The data in XML document  and instance shown in Table 1 form a tree hierarchy.  is a block diagram that illustrates an example tree hierarchy  that represents the XML document . The tree  includes several nodes . Each node may have one or more child nodes descending from it. The top node, which is child of no other node, is the root node of the tree. A node with no child is a leaf node of the tree. Each node represents an XML construct, such as a document, document fragment, element or attribute. A node representing an attribute must be a leaf node. As shown in , the PO XML document  is the root node  of the tree hierarchy . The root node  has one child node  that represents the purchaseOrder element . The node  has three child nodes , ,  that represent the orderDate attribute , the shipTo element , and the itemList element , respectively. The node  has three child nodes , ,  that represent the country attribute , the street element , and the name element , respectively. The node  has one or more child nodes (not shown) that represent the various items that are ordered.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 2B","b":["130","280"]},"Each node is represented by a node data structure such as data structures , , and others represented by ellipsis , collectively referenced hereinafter as node data structure . A node data structure  includes a contents portion (such as contents portions , , collectively referenced hereinafter as contents portion ). The contents portion  includes data for the contents of an XML construct represented by the node. In many systems, the contents portion  includes the text representation of the contents, such as the text on line 2 of Table 1, either including or excluding the attribute name and value. Any method known in the art for representing the contents of an XML construct may be used.","A node data structure  includes a pointer set of zero or more pointers (such as pointer set , , collectively referenced hereinafter as pointer set ). The pointer set includes a list of pointers to the location in the tree model  of child nodes of the node represented by the data structure. For example, if the data structure represents node  for the shipTo element, and data structure represents node  for the country attribute, which is a child node of the shipTo node (see ), then the pointer set includes a pointer to the data structure , among pointers to other data structures representing the name and street XML elements.","A node data structure  includes a bit vector of zero or more bits (such as bit vectors , , collectively referenced hereinafter as bit vector ). Each bit vector includes one bit corresponding to each pointer in the pointer set  in the same node data structure . The bit vector  is used to indicate which child nodes are changed as a result of operations on the in-memory representation of an XML instance. In the illustrated embodiment, the bits in the bit vector are in the same order as the pointers in the pointer set; a bit value of 0 indicates a corresponding node of the tree has not been changed; and a bit value of 1 indicates the corresponding node has been changed. In other embodiments, the bit vector may include more or fewer bits. For example, in some embodiments the bit vector includes another bit to indicate whether the node represented by the same data structure is changed; while, in other embodiments, the bit vector includes only this one bit to indicate whether the node represented by the same data structure is changed.","In some embodiments the bit vector is omitted. In the illustrated embodiment, the bit vector is included for nodes represented by SQL constructs included in mapping , called schema-based mapping; and the bit vector is not included for nodes not stored in SQL constructs, called data object model (DOM) mapping. In DOM mapping, the tree hierarchy is deduced dynamically from an XML construct itself rather than from an XML schema describing a family of XML documents of a particular type. In the illustrated embodiment, a tree model for a DOM mapped construct does not include a bit vector. In other embodiments, a DOM mapping may include a bit vector. In the illustrated embodiment, a schema-based mapping is required to form multiple SQL constructs for storing data for an XML construct. In other embodiments, a schema-based mapping is not required.","The contents of the in-memory model are determined by the root XML element or elements represented by the instance of XML type that is operated upon. The instance of XML type may be originally stored in the database. Alternatively, the instance of XML type may be generated dynamically for temporary use from components in the database (including one or more instances of XML type stored in SQL constructs), or imported from a file that originates outside the database, or both. A schema-based instance of XML type has metadata stored in the mapping . The mapping  is based on an XML schema for the XML construct in the illustrated embodiment. That metadata is used for converting between the XML constructs in the XML instance and one or more SQL constructs. A non-schema-based instance of XML type has metadata about its corresponding XML constructs within the instance. Temporary instances of XML type are generated dynamically or read from external files and might not be stored in the database.","A DELETEXML function is useful for deleting an attribute or element in an XML instance managed by an SQL\/XML database server.  is a flow diagram that illustrates an overview of a method for deleting XML data from an XML instance managed by the DBMS, according to an embodiment. Although steps are shown in  and subsequent flow diagrams in a particular order, in other embodiments, the steps may be performed in a different order or overlapping in time.","In step  an SQL statement is received with a DELETEXML operator that operates on a target component of an XML instance. The target component can be expressed in any manner known in the art. For example, the target component can be identified by an XML instance that represents a root XML element or elements, and an XPath expression from the root XML elements, to a target XML construct that corresponds to the component.","In the illustrated embodiment, the DELETEXML operator is a DELETEXML function with two arguments, which correspond to \u201coperands\u201d of the operator. The first argument identifies an instance of XML type. The second argument is an expression that identifies a particular XML construct or set of XML constructs that constitute a component in the instance of XML type. For purposes of illustration, it is assumed that a particular instance of XML type, called POdoc, shown in Table 1, is generated by the XML database server  by selecting rows from the PO table  of XML type. In a subsequent SQL statement, the DELETEXML function is called to operate on a target XML construct in the XML instance. For example, the subsequent SQL statement includes the following function call (referenced as F1):\n\nDELETEXML(POdoc, \u201c\/purchaseOrder\/shipTo\u201d)\u2003\u2003(F1)\n\nwhich indicates the target XML construct, shipTo, is to be deleted. In the illustrated embodiment, the target XML construct is specified using an XPath expression \u201c\/purchaseOrder\/shipTo.\u201d\n","The function is to return a modified XML instance with the target XML construct deleted. For example, the function call F1 operating on the XML instance POdoc is to change the XML instance to the value as shown in Table 2\u2014with the shipTo element eliminated.",{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example modified XML instance generated by"},{"entry":"example function call F1."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["line","Modified XML instance"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["1",". . ."]},{"entry":["2","<purchaseOrder orderDate=\u201c1999-10-20\u201d>"]},{"entry":["3","\u2003<itemList>"]},{"entry":["4","\u2003\u2003. . ."]},{"entry":["5","\u2003<\/itemList>"]},{"entry":["6","<\/purchaseOrder>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In step  the SQL statement with the DELETEXML function is compiled and prepared for evaluation. Step  includes determining whether the SQL statement includes data manipulation language (DML) operations that indicate that the revised XML instance is to be stored in the database. If the revised XML instance is not to be stored in the database, then the function is not rewritten during compilation and control flows directly to step . Step  includes determining whether the XML instance in the first argument is schema-based or non-schema-based and determining whether the SQL statement with the DELETEXML function can be rewritten as SQL operations on SQL constructs without the DELETEXML function. If the statement can be so rewritten, control passes to step  to change the SQL constructs. If the statement cannot be so rewritten, control passes to step . Details for step  are similar to those described in a later section with reference to step in .","In step , the in-memory representation of the XML instance is generated. If the XML instance is non-schema based, then a data object model (DOM) data structure is used as the in-memory representation of the XML instance. In the DOM data structure, each node data structure representing an XML element has a list of children (such as pointer set ) that includes each attribute and each child element of the XML element. If the XML instance is schema-based, e.g., it is stored in one or more SQL constructs with metadata for the conversion in a mapping , then a schema-based data structure is used as the in-memory representation of the XML instance. A schema-based data structure representing an XML element includes, in addition to a list of child nodes (such as pointer set ), a bit vector equal in length to the number of its child nodes. The bit corresponding to a particular child indicates whether that child node has been modified.","In step , the compiled DELETXML function is evaluated. Step  includes modifying the in memory representation and then returning the revised XML instance. Modifying the in-memory representation includes traversing the in-memory tree model  to find a target node that corresponds to the target XML construct, based on the second argument of the function call. For the DELETEXML function, the target XML construct need not be a unique node, e.g., several sibling nodes may be indicated by the second argument of the function call. The target XML construct, and all its descendents, are eliminated as children of the parent of the target XML construct (the orphaned data structures  need not be erased or removed).","According to one embodiment of step , it is determined whether the target node is the root node of the XML instance. If so, an error is raised, which is to be handled by the database server; for example, an error message is sent to a database client. If the target node is not the root node, the target node is deleted as a child of the parent node. In the illustrated example, the pointer set in the node data structure for purchaseOrder node , which is the parent node of the deleted target node, shipTo node , is modified. For example, the pointer to the deleted child node is replaced with a null value.","During step  the bit vector in the node data structure for the parent node of the target node is also updated, if present. In the illustrated embodiment, if the XML instance is one already stored as an SQL construct of XML type, then the in-memory representation, tree model , includes in each node data structure  the bit vector  to indicate child nodes that are modified. In the illustrated example, the bit vector in the node data structure for purchaseOrder node , which is the parent node of the deleted target node, shipTo node , is modified so that the bit corresponding to the delete child node is set to \u201c1.\u201d","Step  represents a branch point in the program flow that is encountered if the modified XML instance is to be stored; if the modified XML instance is not to be stored, steps , ,  may be omitted. If the XML instance is not already stored as an SQL construct of XML type, then control passes to step to step  to store the modified XML instance based on the in-memory representation, generating a new mapping  and SQL constructs as necessary. If the XML instance is already stored as an SQL construct of XML type, then control passes to step . In the illustrated example, the XML instance POdoc is a newly generated instance, so control passes to step .","If the first argument in the function call were a purchaseOrder element stored in the PO table , then the bit vectors  would be included in each node data structure  and control would pass to step .","In step , an SQL construct that includes data for the target XML construct is changed to remove that data. In one embodiment, every column in the row representing the purchaseOrder element would be updated, including every column in one row of table  and several rows in the collection table  associated with the row in table .","In embodiments using dirty-bit optimization, described in more detail below with reference to , only SQL constructs associated with a node that has changed is updated. Thus fewer SQL constructs might be updated. For example, the mapping  is used to determine that the bit set to \u201c1\u201d is in a position that indicates the shipTo child element of the purchaseOrder element. Therefore, the database server knows that the shipTo element has been deleted from table . The mapping  also indicates that the shipTo element includes an attribute and two child elements stored as columns country, name, and street in table . In one embodiment, these three columns of the shipTo object in table  are set to null. In another embodiment, an \u201cobject present\u201d column corresponding to the shipTo object is set to null.","In step , the modified instance from the in-memory representation is stored. For example, the XML instance listed in Table 2 is stored. If it is to be stored as a schema-based instance, a schema-based mapping is generated and corresponding SQL constructs are generated and filled with the contents of the in-memory representation. In some embodiments, step  is omitted because the changed XML instance is used only temporarily\u2014in the form of the in-memory representation, and is not stored in the database.","AN INSERTXML function is useful for inserting an attribute or element in an XML instance managed by an SQL\/XML database server.  is a flow diagram that illustrates an overview of a method  for inserting an XML element into an XML instance managed by the DBMS, according to an embodiment.","In step  an SQL statement is received with an INSERTXML operator that operates on a target component of an XML instance. The target component can be expressed in any manner known in the art.","In the illustrated embodiment, the INSERTXML operator is an INSERTXML function with four arguments, which correspond to \u201coperands\u201d of the operator. The first argument identifies an XML instance. The second argument is an expression that identifies a target XML element (not an attribute) that constitutes a component in the XML instance. The third argument is data that indicates a name for a new element to be inserted in the XML instance as a child of the target element, and the fourth argument gives the contents for the new element. The third argument can be given in any form known in the art, such as a string of characters enclosed in single or double quotation marks, with or without a character set identifier. The contents for the element in the fourth argument can be any data that is converted to XML type, including an expression that generates such data, such as an XML generation function. In some embodiments, the expression can include a separate namespace that defines rules for the elements and attributes used in the forth argument","For example, after the POdoc instance is generated, as described above (for the DELETEXML operator), the INSERTXML function is called to operate on a target XML construct in POdoc. For example, a SQL statement includes the following function call (referenced as F2):\n\nINSERTXML(POdoc, \u201c\/purchaseOrder\/itemList\u201d, \u201citem\u201d, XMLTYPE(\u2018<itemName>ink cartridge<\/itemName>\u2019))\u2003\u2003(F2)\n\nwhich indicates the target XML construct, itemList, is to have a child element named \u201citem\u201d with contents given by the last argument. In the illustrated embodiment, the target XML construct is specified using an XPath expression \u201c\/purchaseOrder\/itemList.\u201d The XMLTYPE function in the last argument converts to XML type the text string given between the single quotes inside the parentheses that follow the XMLTYPE function name. The XMLTYPE function parses the text to determine one or more nodes of a sub-tree represented by the value. If the text does not represent a valid XML element, then an error is raised.\n","The function is to return a modified instance with a new element as a child of the target XML. For example, the function call F2 operating on the POdoc shown in Table 1 is to produce a modified XML instance as shown in Table 3 with the new item element in line 10.",{"@attributes":{"id":"p-0082","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example modified XML instance generated by"},{"entry":"example function call F2."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["line","modified XML instance"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1",". . ."]},{"entry":["2","<purchaseOrder orderDate=\u201c1999-10-20\u201d>"]},{"entry":["3","\u2003<shipTo country = \u201cUS\u201d>"]},{"entry":["4","\u2003\u2003<name> Alice Smith <\/name>"]},{"entry":["5","\u2003\u2003<street> 123 Maple Street <\/street>"]},{"entry":["6","\u2003<\/shipTo>"]},{"entry":["7","\u2003<itemList>"]},{"entry":["8","\u2003\u2003. . ."]},{"entry":["9","\u2003\u2003<item>"]},{"entry":["10","\u2003\u2003\u2003<itemName>ink cartridge<\/itemName>"]},{"entry":["11","\u2003\u2003<\/item>"]},{"entry":["12","\u2003<\/itemList>"]},{"entry":["13","<\/purchaseOrder>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"In the illustrated embodiment, INSERTXML function is to make the new element the next child of the target XML element, if no other child in of the target XML element already has the name given in the third element. If another child of the target XML element already has the name given in the third element, the new child is to be placed in the instance following the last child with that name and before any other child elements with a different name. For example if the ellipsis in line 8 represents two child XML elements of itemList, a first one name \u201citem\u201d and a second named \u201ccost,\u201d then the new item element would be inserted between those two XML elements.","In step  the SQL statement with the INSERTXML function is compiled and prepared for evaluation. Step  includes determining whether the SQL statement includes data manipulation language (DML) operations that indicate that the revised XML instance is to be stored in the database. If the revised XML instance is not to be stored in the database, then the function is not rewritten during compilation and control flows directly to step . Step  includes determining whether the XML instance in the first argument is schema-based or non-schema-based and determining whether the SQL statement with the INSERTXML function can be rewritten as SQL operations on SQL constructs without the INSERTXML function. If the statement can be so rewritten, control passes to step  to change the SQL constructs. If the statement cannot be so rewritten, control passes to step . Details for step  are similar to those described in a later section with reference to step in .","In step , the in-memory representation of the XML instance is generated. The process for preparing the in-memory representation is the same as the same process described above (for the DELETEXML function).","In step , the compiled INSERTXML function is evaluated. Step  includes modifying the in memory representation and then returning the revised XML instance. Modifying the in-memory representation includes traversing the in-memory tree model  to find a target node that corresponds to the target XML construct, based on the second argument of the function call. For the INSERTXML function, the target XML construct is required to be a unique node and an XML element. The new XML element is added as a child element of the target XML element.","According to one embodiment of step , it is determined whether the target node is an XML attribute. If so, an error is raised, which is to be handled by the database server; for example, an error message is sent to a database client. If the target node is an element, rather than an attribute, the new node is inserted as a child of the target node. A new node data structure, e.g., node data structure , is formed for the new element. If necessary, additional node data structures are generated based on the sub-tree of nodes contained in the fourth argument and pointers are added to the pointer set of the node data structure of the parent node. For example, another node data structure is formed for the sub element itemName and a pointer to the node data structure for the element itemName is added to the pointer set in node data structure . At least, if there is no error, the pointer set in the node data structure for itemList node , which is the target node, is modified to add a pointer to the node data structure for the new item element.","During step  the bit vector in the node data structure for the target node is also updated, if present. In the illustrated embodiment, if the XML instance is one already stored as an SQL construct of XML type, then the in-memory representation, tree model , includes in each node data structure  the bit vector  to indicate child nodes that are modified. In the illustrated example, the bit vector in the node data structure for the itemList node , which is the target node, is modified so that the bit corresponding to the new XML element is set to \u201c1.\u201d","Step , represents a branch point in the program flow that is encountered if the modified XML instance is to be stored; if the modified XML instance is not to be stored, steps , ,  may be omitted. If the XML instance is not already stored as an SQL construct of XML type, then control passes to step  to store the modified XML instance based on the in-memory representation. If the XML instance is already stored as an SQL construct of XML type, then control passes to step . In the illustrated example, the XML instance POdoc is a newly generated instance, so control passes to step .","If the first argument in the function call were a purchaseOrder element stored in the PO table , then the bit vectors  would be included in each node data structure  and control would pass to step .","In step , an SQL construct that includes data for the target XML construct is changed to add data for the new child node. In one embodiment, every column in the row representing the purchaseOrder element would be updated, including every column in one row of table  and several rows in the collection table  associated with the row in table .","In embodiments using dirty-bit optimization, described in more detail below with reference to , only SQL constructs associated with a node that has changed is updated. Thus fewer SQL constructs might be updated. For example, the mapping  is used to determine that the bit set to \u201c1\u201d is in a position that indicates an item in the itemList element. The metadata indicates that the itemList element is stored as a collection of items in store table . Therefore, the database server knows that the store table  must be changed to include the item indicated by the bit set to \u201c1.\u201d Since the marked bit is past the last extant item in the collection table for the purchaseOrder instance, a new row representing the new item is added to the store table . The new row includes a setid, which corresponds to a value stored in the itemList column of PO table , and the value for an itemName column of the collection table. If itemName is not already a column of collection table , then a new collection table is generated that includes an itemName column, and the new item is added to the new collection table. In one embodiment, all the other items in the itemList are transferred to the new table.","In step , the modified instance from the in-memory representation is stored. For example, the XML instance listed in Table 3 is stored. If it is to be stored as a schema-based instance, a schema-based mapping is generated and corresponding SQL constructs are generated and filled with the contents of the in-memory representation. In some embodiments, step  is omitted because the changed XML instance is used only temporarily\u2014in the form of the in-memory representation.","An INSERTXMLBEFORE function is useful for inserting an attribute or element in an XML instance managed by an SQL\/XML database server.  is a flow diagram that illustrates an overview of a method  for inserting XML data before a particular XML construct in an XML instance managed by the DBMS, according to an embodiment.","In step  an SQL statement is received with an INSERTXMLBEFORE operator that operates on a target component of an XML instance. The target component can be expressed in any manner known in the art.","In the illustrated embodiment, the INSERTXMLBEFORE operator is an INSERTXMLBEFORE function with three arguments, which correspond to \u201coperands\u201d of the operator. The first argument identifies an XML instance. The second argument is an expression that identifies a target XML construct that constitutes a component in the XML instance. The third argument gives the data for a new XML construct, including any tags. The data in the third argument can be any data that is converted to XML type, including an expression that generates such data, as described above.","For example, after the POdoc instance of Table 1 is generated, the INSERTXMLBEFORE function is called to operate on a target XML construct in POdoc. For example, a SQL statement includes the following function call (referenced as F3):\n\nINSERTXMLBEFORE(POdoc, \u201c\/purchaseOrder\/shipTo\u201d, XMLTYPE(\u2018<cust>ABC Corp.<\/cust>\u2019) )\u2003\u2003(F3)\n\nwhich indicates the target XML construct, shipTo, is to have an XML construct defined by the contents given by the last argument inserted before it in XML document order. In the illustrated embodiment, the target XML construct is specified using an XPath expression \u201c\/purchaseOrder\/shipTo.\u201d The XMLTYPE function in the last argument converts to XML type the text string given between the single quotes inside the parentheses that follow the XMLTYPE function name. The XMLTYPE function parses the text to determine whether the text represents an attribute or an element including any sub elements.\n","The function is to return a modified instance with a new XML construct before the target XML construct. For example, the function call F3 operating on the POdoc shown in Table 1 is to produce a modified XML instance as shown in Table 4 with the new cust element in line 3.",{"@attributes":{"id":"p-0099","num":"0098"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example modified XML instance generated by"},{"entry":"example function call F3."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["line","modified XML instance"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1",". . ."]},{"entry":["2","<purchaseOrder orderDate=\u201c1999-10-20\u201d>"]},{"entry":["3","\u2003<cust>ABC Corp.<\/cust>"]},{"entry":["4","\u2003<shipTo country = \u201cUS\u201d>"]},{"entry":["5","\u2003\u2003<name> Alice Smith <\/name>"]},{"entry":["6","\u2003\u2003<street> 123 Maple Street <\/street>"]},{"entry":["7","\u2003<\/shipTo>"]},{"entry":["8","\u2003<itemList>"]},{"entry":["9","\u2003\u2003. . ."]},{"entry":["10","\u2003<\/itemList>"]},{"entry":["11","<\/purchaseOrder>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{},{}],"in-line-formulae":[{},{}]},{"@attributes":{"id":"p-0100","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example modified XML instance generated by"},{"entry":"example function call F4."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["line","modified XML instance"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1",". . ."]},{"entry":["2","<purchaseOrder num=\u201c7890\u201d orderDate=\u201c1999-10-20\u201d>"]},{"entry":["3","\u2003<shipTo country = \u201cUS\u201d>"]},{"entry":["4","\u2003\u2003<name> Alice Smith <\/name>"]},{"entry":["5","\u2003\u2003<street> 123 Maple Street <\/street>"]},{"entry":["6","\u2003<\/shipTo>"]},{"entry":["7","\u2003<itemList>"]},{"entry":["8","\u2003\u2003. . ."]},{"entry":["9","<\/itemList>"]},{"entry":["10","<\/purchaseOrder>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In step  the SQL statement with the INSERTXMLBEFORE function is compiled and prepared for evaluation. Step  includes determining whether the SQL statement includes data manipulation language (DML) operations that indicate that the revised XML instance is to be stored in the database. If the revised XML instance is not to be stored in the database, then the function is not rewritten during compilation and control flows directly to step . Step  includes determining whether the XML instance in the first argument is schema-based or non-schema-based and determining whether the SQL statement with the INSERTXMLBEFORE function can be rewritten as SQL operations on SQL constructs without the INSERTXMLBEFORE function. If the statement can be so rewritten, control passes to step  to change the SQL constructs. If the statement cannot be so rewritten, control passes to step . Details for step  are similar to those described in a later section with reference to step in .","In step , the in-memory representation of the XML instance is generated. The process for preparing the in-memory representation is the same as the same process described above (for the DELETEXML function).","In step , the compiled INSERTXMLBEFORE function is evaluated. Step  includes modifying the in memory representation and then returning the revised XML instance. Modifying the in-memory representation includes traversing the in-memory tree model  to find a target node that corresponds to the target XML construct, based on the second argument of the function call. For the INSERTXMLBEFORE function, the target XML construct is required to be a unique node. The new XML construct is added before the target construct as a sibling of the target construct.","According to one embodiment of step , it is determined whether the target node has a parent node. If not, an error is raised.","If the target node has a parent node, then it is determined whether the target node represents an XML attribute or an XML element. A node that represents an element that holds only text, and no other elements, is called a text node. If the target node represents neither an XML attribute nor an XML element, then an error is raised.","If the target node represents an XML element or is a text node, then the XML type value indicated by the third argument is used to generate a child XML element of the parent node that occurs before the target node in XML document order. If the XML type value does not include element tags or is otherwise improper for representing an XML element, then an error is raised. If an error is not raised, then a new node data structure  is formed for the new node, and a pointer to the new node data structure is added to the pointer set  of the node data structure representing the parent of the target node.","If the target node represents an XML attribute, then the XML type value indicated by the third argument is used as an attribute of the parent node that occurs before the target node in XML document order. If the XML type value does not include attribute name or equal sign or is otherwise improper for representing an XML attribute, then an error is raised. If an error is not raised, then a new node data structure  is formed for the new node, and a pointer to the new node data structure is added to the pointer set  of the node data structure representing the parent of the target node.","During step  the bit vector in the node data structure for the parent node of the target node is also updated, if present.","Step  represents a branch point in the program flow that is encountered if the modified XML instance is to be stored; if the modified XML instance is not to be stored, steps , ,  may be omitted. If the XML instance is not already stored as an SQL construct of XML type, then control passes to step  to store the modified XML instance based on the in-memory representation. If the XML instance is already stored as an SQL construct of XML type, then control passes to step . In the illustrated example, the XML instance POdoc is a newly generated instance, so control passes to step .","If the first argument in the function call were a purchaseOrder element stored in the PO table , then the bit vectors  would be included in each node data structure  and control would pass to step .","In step , an SQL construct that includes data for the target XML construct is changed to add data for the new sibling node of the XML construct. In one embodiment, every column in the row representing the purchaseOrder element would be updated, including every column in one row of table  and several rows in the collection table  associated with the row in table .","In embodiments using dirty-bit optimization, described in more detail below with reference to , only SQL constructs associated with a node that has changed is updated. Thus fewer SQL constructs might be updated. For example, the pointer set is used to determine that the bit set to \u201c1\u201d in the purchaseOrder element indicates the new XML construct is a new XML element named \u201ccust\u201d (for function call F3) or a new attribute named \u201cnum\u201d (for Function call F4). If the mapping  does not include the new attribute or element for the XML element purchaseOrder, then the new attribute or elements are added to the mapping and new columns are added to PO table ; or a new table is generated with columns that correspond to the new attribute or element. If the mapping  does include SQL constructs associated with the inserted attribute or element, the value in the associated SQL construct is changed from null to a value included within the third argument.","In step , the modified instance from the in-memory representation is stored. For example, the modified XML instance listed in Table 4 or Table 5 is stored. If it is to be stored as a schema-based instance, a schema-based mapping is generated and corresponding SQL constructs are generated and filled with the contents of the in-memory representation. In some embodiments, step  is omitted because the changed XML instance is used only temporarily\u2014in the form of the in-memory representation.","An APPENDCHILDXML function is useful for inserting an XML element as a child of another XML element in an XML instance managed by an SQL\/XML database server.  is a flow diagram that illustrates an overview of a method  for inserting XML data as a child element of a XML element in an XML instance managed by the DBMS, according to an embodiment.","In step  an SQL statement is received with an APPENDCHILDXML operator that operates on a target component of an XML instance. The target component can be expressed in any manner known in the art.","In the illustrated embodiment, the APPENDCHILDXML operator is an APPENDCHILDXML function with three arguments, which correspond to \u201coperands\u201d of the operator. The first argument identifies an XML instance The second argument is an expression that identifies a target XML construct that constitutes a component in the XML instance. The third argument gives the data for a new XML construct, including any tags. The data in the third argument can be any data that is converted to XML type, including an expression that generates such data, as described above.","For example, after the POdoc instance of Table 1 is generated, the APPENDCHILDXML function is called to operate on a target XML construct in POdoc. For example, a SQL statement includes the following function call (referenced as F5):\n\nAPPENDCHILDXML (POdoc, \u201c\/purchaseOrder\/shipTo\u201d, XMLTYPE(\u2018<city>Springfield<\/city>\u2019) )\u2003\u2003(F5)\n\nwhich indicates the target XML construct, shipTo, is to have an XML construct appended as a last child XML construct with contents given by the last argument. In the illustrated embodiment, the target XML construct is specified using the XPath expression \u201c\/purchaseOrder\/shipTo.\u201d\n","The function is to return a modified instance with a new XML element appended as a last child of the target XML element. For example, the function call F5 operating on the POdoc shown in Table 1 is to produce a modified XML instance as shown in Table 6 with the new city element in line 6.",{"@attributes":{"id":"p-0119","num":"0118"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 6"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example modified XML instance generated by"},{"entry":"example function call F5."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["line","Modified XML instance"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1",". . ."]},{"entry":["2","<purchaseOrder orderDate=\u201c1999-10-20\u201d>"]},{"entry":["3","\u2003<shipTo country = \u201cUS\u201d>"]},{"entry":["4","\u2003\u2003<name> Alice Smith <\/name>"]},{"entry":["5","\u2003\u2003<street> 123 Maple Street <\/street>"]},{"entry":["6","\u2003\u2003<city>Springfield<\/city>"]},{"entry":["7","\u2003<\/shipTo>"]},{"entry":["8","\u2003<itemList>"]},{"entry":["9","\u2003\u2003. . ."]},{"entry":["10","\u2003<\/itemList>"]},{"entry":["11","<\/purchaseOrder>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In step  the SQL statement with the APPENDCHILDXML function is compiled and prepared for evaluation. Step  includes determining whether the SQL statement includes data manipulation language (DML) operations that indicate that the revised XML instance is to be stored in the database. If the revised XML instance is not to be stored in the database, then the function is not rewritten during compilation and control flows directly to step . Step  includes determining whether the XML instance in the first argument is schema-based or non-schema-based and determining whether the SQL statement with the APPENDCHILDXML function can be rewritten as SQL operations on SQL constructs without the APPENDCHILDXML function. If the statement can be so rewritten, control passes to step  to change the SQL constructs. If the statement cannot be so rewritten, control passes to step . Details for step  are similar to those described in more detail in a later section with reference to step in .","In step , the in-memory representation of the XML instance is generated. The process for preparing the in-memory representation is the same as the same process described above (for the DELETEXML function).","In step , the compiled APPENDCHILDXML function is evaluated. Step  includes modifying the in memory representation and then returning the revised XML instance. Modifying the in-memory representation includes traversing the in-memory tree model  to find a target node that corresponds to the target XML construct, based on the second argument of the function call. For the APPENDCHILDXML function, the target XML construct is required to be a unique node.","According to one embodiment of step , it is determined whether both the target node is an XML element and the third argument expresses an XML element. If not, an error is raised.","If both represent XML elements, then the XML type value indicated by the third argument is used to generate a child XML element of the target node. A new node data structure  is formed for a new node representing the new XML element, and a pointer to the new node data structure is added to the pointer set  of the node data structure representing the target node.","During step  the bit vector in the node data structure for the target node is also updated, if present.","Step  represents a branch point that is encountered if the modified XML instance is to be stored; if the modified XML instance is not to be stored, steps , ,  may be omitted. If the modified XML instance is not already stored as an SQL construct of XML type, then control passes to step  to store the modified XML instance based on the in-memory representation. If the XML instance is already stored as an SQL construct of XML type, then control passes to step . In the illustrated example, the XML instance POdoc is a newly generated instance, so control passes to step .","If the first argument in the function call were a purchaseOrder element stored in the PO table , then the bit vectors  would be included in each node data structure  and control would pass to step .","In step , an SQL construct that includes data for the target XML construct is changed to add data for the child node of the XML construct. In one embodiment, every column in the row representing the purchaseOrder element would be updated, including every column in one row of table  and several rows in the collection table  associated with the row in table .","In embodiments using dirty-bit optimization, described in more detail below with reference to , only SQL constructs associated with a node that has changed is updated. Thus fewer SQL constructs might be updated. For example, the pointer set is used to determine that the bit set to \u201c1\u201d in the shipTo element indicates the new XML construct is a new XML element named \u201ccity.\u201d If the mapping  does not include the new city element for the XML element shipTo, then the new element is added to the mapping and new columns are added to PO table ; or a new table is generated with columns that correspond to the new element. If the mapping  does include SQL constructs associated with the inserted element, the value in the associated SQL construct is changed from null to a value included within the third argument.","In step , the modified instance from the in-memory representation is stored. For example, the modified XML instance listed in Table 6 is stored. If it is to be stored as a schema-based instance, a schema-based mapping is generated and corresponding SQL constructs are generated and filled with the contents of the in-memory representation. In some embodiments, step  is omitted because the changed XML instance is used only temporarily\u2014in the form of the in-memory representation.","An UPDATEXML function is useful for replacing an element that already resides in an XML instance managed by an SQL\/XML database server.  is a flow diagram that illustrates an overview of a method  for updating an XML construct in an XML instance managed by the DBMS, according to an embodiment.","In step  an SQL statement is received with an UPDATEXML operator that operates on a target component of an XML instance. The target component can be expressed in any manner known in the art.","In the illustrated embodiment, the UPDATEXML operator is an UPDATEXML function with three arguments, which correspond to \u201coperands\u201d of the operator. The first argument identifies an XML instance. The second argument is an expression that identifies a target XML construct that constitutes the component in the XML instance. The third argument gives the data for a new XML construct, including any tags. The data in the third argument can be any data that is converted to XML type, including an expression that generates such data, as described above.","For example, after the POdoc instance of Table 1 is generated, the UPDATEXML function is called to operate on a target XML construct in POdoc. For example, a SQL statement includes the following function call (referenced as F5):\n\nUPDATEXML (POdoc, \u201c\/purchaseOrder\/shipTo\u201d, XMLTYPE (\u2018<shipTo country=\u201cBrazil\u201d> <name>Pele<\/name><\/shipTo>\u2019) )\u2003\u2003(F6)\n\nwhich indicates the target XML construct, shipTo, is to be replaced by an XML construct given by the last argument. In the illustrated embodiment, the target XML construct is specified using the XPath expression \u201c\/purchaseOrder\/shipTo.\u201d\n","The function is to return a modified instance with a new XML construct in place of the target XML construct. For example, the function call F6 operating on the POdoc shown in Table 1 is to produce a modified XML instance as shown in Table 7 with the replacement construct on lines 3 through 5.",{"@attributes":{"id":"p-0136","num":"0135"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 7"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example modified XML instance generated by"},{"entry":"example function call F6."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["line","modified XML instance"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["1",". . ."]},{"entry":["2","<purchaseOrder orderDate=\u201c1999-10-20\u201d>"]},{"entry":["3","\u2003<shipTo country = \u201cBrazil\u201d>"]},{"entry":["4","\u2003\u2003<name>Pele<\/name>"]},{"entry":["5","\u2003<\/shipTo>"]},{"entry":["6","\u2003<itemList>"]},{"entry":["7","\u2003\u2003. . ."]},{"entry":["8","\u2003<\/itemList>"]},{"entry":["9","<\/purchaseOrder>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In step  the SQL statement with the UPDATEXML function is compiled and prepared for evaluation. Step  includes determining whether the SQL statement includes data manipulation language (DML) operations that indicate that the revised XML instance is to be stored in the database. If the revised XML instance is not to be stored in the database, then the function is not rewritten during compilation and control flows directly to step . Step  includes determining whether the XML instance in the first argument is schema-based or non-schema-based and determining whether the SQL statement with the UPDATEXML function can be rewritten as SQL operations on SQL constructs without the UPDATEXML function. If the statement can be so rewritten, control passes to step  to change the SQL constructs. If the statement cannot be so rewritten, control passes to step . Step  is described in more detail in a later section with reference to .","In step , the compiled UPDATEXML function is evaluated. Step  includes modifying the in memory representation and then returning the revised XML instance. Modifying the in-memory representation includes the step of generating the in-memory representation of the XML instance and traversing the in-memory tree model  to find a target node that corresponds to the target XML construct, based on the second argument of the function call. For the UPDATEXML function, the target XML construct is required to be a unique node.","According to one embodiment of step  the following steps are performed. If the target node does not have a parent, the entire XML instance is replaced by the XML type value provided as the third argument. If the target node has a parent node, the type of the target node is determined.","If the target node represents an XML element (including a text node), then it is determined whether the XML type value in the third argument is an XML element (including a text node). If so, then the XML type value is added as a child of a parent node of the target node in place of the target node. For example, a pointer to the node data structure of the target node, in the pointer set of the node data structure of the parent node, is replaced by a pointer to a new node data structure for a root node within the XML type value. If it is determined above that the XML type value in the third argument is an XML attribute, then an error is raised.","If the target node represents an XML attribute, then it is determined whether the XML type value in the third argument is an XML attribute. If not, then an error is raised. If the XML type value in the third argument is an XML attribute, then the XML type value is added as a child of a parent node of the target node in place of the target node. For example, a pointer to the node data structure of the target node is replaced by a pointer to a new node data structure for the attribute determined from the XML type value.","During step  the bit vector in the node data structure for the parent node of the target node is also updated, if present, to indicate the new child node is a modified child node.","Step , represents a branch point in the program flow that is encountered if the modified XML instance is to be stored; if the modified XML instance is not to be stored, steps , ,  may be omitted. If the XML instance is not already stored as an SQL construct of XML type, then control passes to step  to return the modified XML instance based on the in-memory representation. If the XML instance is already stored as an SQL construct of XML type, then control passes to step . In the illustrated example, the XML instance POdoc is a newly generated instance, so control passes to step .","If the first argument in the function call were a purchaseOrder element stored in the PO table , then the bit vectors  would be included in each node data structure  and control would pass to step .","In step , an SQL construct that includes data for the target XML construct is changed to add data for the child node of the XML construct. In one embodiment, every column in the row representing the purchaseOrder element would be updated, including every column in one row of table  and several rows in the collection table  associated with the row in table .","In embodiments using dirty-bit optimization, described in more detail below with reference to , only SQL constructs associated with a node that has changed is updated. Thus fewer SQL constructs might be updated. For example, the pointer set is used to determine that the bit set to \u201c1\u201d in the purchaseOrder element indicates the modified XML construct is the shipTo element. The mapping  includes the shipTo element with a country attribute and a name element as a child element of the purchaseOrder element, so no new columns need be added to PO table ; and no new table need be generated. The value in the associated SQL construct is changed from former values to the new values; if a new value is missing of any child of the new node, the column is filled with a null value. For example, the contents of the country column is set to Brazil, the name column is set to Pele and the street column is set to null.","In step , the modified instance from the in-memory representation is stored. For example, the modified XML instance listed in Table 7 is stored. If it is to be stored as a schema-based instance, a schema-based mapping is generated and corresponding SQL constructs are generated and filled with the contents of the in-memory representation. In some embodiments, step  is omitted because the changed XML instance is used only temporarily\u2014in the form of the in-memory representation.","In some embodiments, storing results from evaluating the operators described above involves manifesting the old instance in memory, updating the in-memory representation to return a modified instance, and then generating new SQL constructs to store the modified instance, as in steps , , ,  and . However, when at least a portion of the instance being updated is already stored object relationally using a mapping , such as the schema-based mapping, evaluations are made more efficient by updating directly some or all of the SQL constructs that already exist.","In one approach, designated the statement \u201crewrite\u201d approach, the SQL constructs are updated without first manifesting the old instance in memory. In another approach, designated herein the \u201cdirty-bit optimization\u201d approach, the old instance is manifest in memory, but only the SQL constructs that represent changed XML constructs are updated.",{"@attributes":{"id":"p-0150","num":"0149"},"figref":["FIG. 7B","FIG. 7A","FIG. 7A"],"b":["710","720","740","710","720","740"],"i":["a","a","a "]},"In this embodiment, an XML modification function with an XML construct argument is rewritten under some circumstances as one or more SQL operations on SQL constructs. For purposes of illustration, it is assumed that an SQL statement (S1) listed below is received by the database server . The SQL statement S1 includes the DML operation UPDATE to change the data stored in the database, so S1 is considered for rewriting during compilation to eliminate the included UPDATEXML function.\n\nUPDATE po SET value (po)=UPDATEXML(value(po), \u2018\/purchaseOrder\/@orderDate\u2019,\u20182002-01-02\u2019) WHERE EXTRACTVALUE(value(po),\u2018purchaseOrder\/shipTo\/name\u2019)=\u2018Alice Smith\u2019\u2003\u2003(S1)\n\nThe SQL\/XML standard function EXTRACTVALUE, as is well known, provides text contained at the XML construct identified by the XPath expression. Because the construct to be updated, attribute orderDate, is already stored in column orderdate in table po , it would be desirable to rewrite this statement to update that column directly, without first generating an in-memory representation of a purchaseOrder element and traversing that element to the orderDate node. A desired example rewrite is given as SQL statement (S2):\n\nUPDATE po SET po.XMLData.\u201corderdate\u201d=TO_DATE(\u20182002-01-02\u2019,\u2018SYYYY-MM-DD\u2019) WHERE po.XMLData.\u201cname\u201d=\u2018Alice Smith\u2019\u2003\u2003(S2)\n\nIn this example, the XMLData is a special column name for a column of XML type for which metadata appears in the XML schema-based mapping in the Oracle 9i Database. Note that SQL statement S2 is more efficient than statement S1, because it does not require the generation or traversal of an in-memory representation of an XML instance, nor does it require the generation of new SQL constructs for a new mapping or table or column to store the new updated XML instance.\n","In step , it is determined whether the conditions permit the SQL statement to be rewritten. For example, an SQL statement involving the DELETXML, INSERTXML, INSERTXMLBEFORE, APPENDCHILDXML, or UPDATEXML function is rewritten if the following conditions are satisfied.","1. The first argument is an XML type that has been stored object-relationally, e.g., the first argument is an XML construct that is already stored with a mapping in an SQL construct. For example, the first argument is an XMLType, such as an XMLType column or a row of an XMLType table, in the Oracle 9i Database using an XML schema mapping.","2. The first argument is the same as the construct being updated in the SET clause (the left hand side, LHS, of the = sign in the SET clause, is the construct being updated). In the above example, this condition is satisfied because value(po) (a row in the XMLType table po) is the first argument of the UPDATEXML function and is the LHS of the SET clause.","3. For the DELETEXML function, it is possible to determine at compile time, using the mapping , a unique column or set of columns, or a set of collection elements, indicated by the second argument (e.g., the XPath expression).","4. For the INSERTXML, INSERTXMLBEFORE, APPENDCHILD functions, it is possible to determine at compile time, using the mapping  and the second argument (e.g., the XPath expression), a unique column that is being updated.","5. For the UPDATEXML function, it is possible to determine at compile time, using the mapping , a unique column or a unique collection element, indicated by the second argument (e.g., the XPath expression).","It may not be possible to determine SQL constructs to be modified at compile time. For example, the XPath may include one or more components that are determined dynamically based on contents in one or more SQL constructs or computations performed.","In step , a particular set of SQL constructs that are to be modified by the functions is determined. For example, the unique column or collection element to be modified by the UPDATEXML function is determined while step  is performed to determine whether the unique column or collection element can be determined.","In step , the SQL statement is rewritten without the XML modification operator. In one embodiment of step , it is determined whether the construct being modified is a unique column. If so, the LHS of the SET clause is replaced with the unique column. For example, the LHS of S1, above, is replaced by the orderdate column in the LHS of S2. It is then determined whether the operator is the DELETXML function. If so, the right hand side (RHS, after the \u201c=\u201d sign) of the SET clause is replaced by \u201cnull.\u201d If the operator is not the DELETEXML function, then the RHS is replaced with the last argument, the expression for the contents of the XML construct, with appropriate casting. For example, the RHS with the UPDATEXML function of S1, above, is replaced by \u20182002-01-02\u2019 in the RHS of S2 along with the TO_DATE function call to convert to date data required by the orderdate column.","In this embodiment of step , it is determined whether the construct being modified is a collection element. If so, then it is determined which operator operates on the construct being modified. If the operator is the DELETEXML operator, then the SQL statement is changed to an SQL DELETE statement on the table where the collection is stored, e.g., store table . An SQL WHERE clause is added to identify the rows of the store table being modified. If the operator is the UPDATEXML function, then the table being modified is changed to the store table and a WHERE clause is added to identify the row of the store table where the change is to occur. This row occupies the LHS of the SET clause. The RHS of the SET clause is replaced with the last argument with appropriate casting.","Control then passes to the evaluation step, where the SQL operations on the SQL constructs are evaluated. For example, in the rewritten UPDATEXML function, the rewritten SQL statement S2 is evaluated in step , during step for changing SQL constructs that represent changed XML constructs. Step , such as step , is skipped. An in-memory representation is not generated or updated.","In this embodiment, an XML modification function with an XML instance component argument that cannot be rewritten is evaluated using an in-memory representation and, under some circumstances, certain SQL constructs are updated rather than updating all SQL constructs for the new, modified instance. For purposes of illustration, it is assumed that an SQL statement (S3) listed below is received by the database server .",{"@attributes":{"id":"p-0164","num":"0163"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UPDATE po"]},{"entry":[{},"SET value (po) ="]},{"entry":[{},"\u2003DELETEXML ("]},{"entry":[{},"\u2003\u2003UPDATEXML(value(po),"]},{"entry":[{},"\u2003\u2003\u2003\u2019\/purchaseOrder\/itemList\/item[2]\/shipDate\u2019,"]},{"entry":[{},"\u2003\u2003\u2003\u20192002-01-02\u2019),"]},{"entry":[{},"\u2003\u2003\u201c\/purchaseOrder\/shipTo)\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(S3)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The statement S3 is directed to updating each purchaseOrder element in the po table so that the ship date (element name \u201cshipDate\u201d) of the second line item (element name \u201clineItem\u201d) in the itemList has the specified value, and to then deleting the shipTo element in the updated purchaseOrder element. It is assumed, for purposes of illustration, that the mapping  includes metadata that indicates that the itemList includes a collection of child elements called \u201citem,\u201d and that each item element includes an \u201citemName\u201d child element and a \u201cshipDate\u201d child element and that the collection is stored in a store table  called \u201cpo_items.\u201d Therefore, the po_items table  includes a setid column for a set identification that identifies rows of the collection table that belong to a particular set associated with a particular purchaseOrder element, an index column for indicating a particular position in the list of items, an itemname column for an itemName element value and a shipdate column for a shipDate element value. Statement S3 is equivalent to the following set of statements, called S4 and S5, if only the affected columns were updated with SQL operators.\n\nUPDATE po SET value(p).shipTo=null where rowid=:1;\u2003\u2003(S4)\n\nUPDATE po_items i SET value(i).shipDate=\u20182002-01-02\u2019 WHERE i.index=2 and setid=:1;\u2003\u2003(S5)\n","It would be desirable for the po table  to be updated to null the value of the shipTo column and that the store table  be updated to change the shipdate column of the second item of the setid associated with each row of the po table, as described in statements S4 and S5. Without dirty-bit optimization, however, statement S3 would be evaluated by updating every column of every row in both the op table and the collection table.","In the illustrated embodiment, it is possible to employ dirty-bit optimization under the following conditions, which are similar to some of the conditions for compile time rewrites.","1. The first argument is an XML type that has been stored object-relationally, e.g., the first argument is an XML construct that is already stored with a mapping in an SQL construct. For example, each purchaseOrder element is stored object relationally in a row of the XML type table po.","2. The first argument is the same as the construct being updated in the SET clause In the above example, this condition is satisfied because value(po) (a row in the XMLType table po) is the first argument of the UPDATEXML function and the updated value(po) is the first argument in the DELETEXML function and value(po) is in the LHS of the SET clause of statement S3.","In step , the in-memory representation is generated for the next purchaseOrder element in the po table . Because the purchaseOrder element is stored in an SQL construct of XML Type (a row in an XMLType table) it is schema-based and a bit vector is included in the in-memory representation.","In step , the nodes affected by the evaluation of the operation are changed, and corresponding bits in the bit vector are marked as \u201cdirty\u201d because they have been modified in the in-memory representation, but not yet stored in any SQL construct. Control passes through step  to step  of step because the purchaseOrder element is stored object relationally, as indicated above.","In step , the nodes that are affected by the update are determined. In the illustrated embodiment, step  is performed based on the dirty bits stored in the bit vector  of the node data structure  of the parent node of the XML construct that has changed.","In step , the nodes affected are mapped to SQL constructs that are affected, often a subset of the SQL constructs that store data for the whole XML instance. In one embodiment, if a dirty bit is set for an abstract data type (ADT) such as an object, or for a collection that is not stored in a store table, then contents are generated only for that ADT or collection. This ADT or collection may be deep inside the SQL construct for the instance so that not all contents of the instance are generated. In the illustrated example, the dirty bit is set for the shipTo element, so only the (null) contents for the shipTo element are generated, not all the contents for the purchaseOrder element.","If a dirty bit is set for a collection, or an element of a collection, stored in a separate store table, the setid of the collection is identified from the parent element (e.g., the itemList element on the purchaseOrder row of the po table) and the store table is identified from the metadata in the mapping . When the whole collection is updated, then contents are generated for all rows in the store table that match the setid. When a particular element of the collection is updated, then contents are generated for only one row in the store table.","In step , the contents generated for the node indicated by the dirty bit are inserted into the SQL construct associated with that node. For example, the null contents for the shipTo element are inserted into the shipto ADT column that includes columns country, name, street. The date 2002-01-02 is inserted into shipdate column of the po_items table on a row with a setid that matches the setid in the itemList column of the po table, and with a value in the index column of 2.","Step  is analogous to steps , , ,  for the other modification functions. Step  is analogous to steps , , ,  for the other modification functions. Steps analogous to steps , , ,  in step are performed in steps , , ,  for the other modification functions.","Using dirty-bit optimization, less than all the SQL constructs that represent an XML document are updated, increasing efficiency in evaluating an SQL statement that modifies the contents of an XML instance managed by a SQL DBMS.",{"@attributes":{"id":"p-0178","num":"0177"},"figref":"FIG. 8","b":["800","800","802","804","802","800","806","802","804","806","804","800","808","802","804","810","802"]},"Computer system  may be coupled via bus  to a display , such as a cathode ray tube (CRT), for displaying information to a computer user. An input device , including alphanumeric and other keys, is coupled to bus  for communicating information and command selections to processor . Another type of user input device is cursor control , such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to processor  and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the device to specify positions in a plane.","The invention is related to the use of computer system  for implementing the techniques described herein. According to one embodiment of the invention, those techniques are performed by computer system  in response to processor  executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory  from another computer-readable medium, such as storage device . Execution of the sequences of instructions contained in main memory  causes processor  to perform the process steps described herein. In alternative embodiments, hard-wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus, embodiments of the invention are not limited to any specific combination of hardware circuitry and software.","The term \u201ccomputer-readable medium\u201d as used herein refers to any medium that participates in providing instructions to processor  for execution. Such a medium may take many forms, including but not limited to, non-volatile media, volatile media, and transmission media. Non-volatile media includes, for example, optical or magnetic disks, such as storage device . Volatile media includes dynamic memory, such as main memory . Transmission media includes coaxial cables, copper wire and fiber optics, including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves, such as those generated during radio-wave and infra-red data communications.","Common forms of computer-readable media include, for example, a floppy disk, a flexible disk, hard disk, magnetic tape, or any other magnetic medium, a CD-ROM, any other optical medium, punchcards, papertape, any other physical medium with patterns of holes, a RAM, a PROM, and EPROM, a FLASH-EPROM, any other memory chip or cartridge, a carrier wave as described hereinafter, or any other medium from which a computer can read.","Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor  for execution. For example, the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system  can receive the data on the telephone line and use an infra-red transmitter to convert the data to an infra-red signal. An infra-red detector can receive the data carried in the infra-red signal and appropriate circuitry can place the data on bus . Bus  carries the data to main memory , from which processor  retrieves and executes the instructions. The instructions received by main memory  may optionally be stored on storage device  either before or after execution by processor .","Computer system  also includes a communication interface  coupled to bus . Communication interface  provides a two-way data communication coupling to a network link  that is connected to a local network . For example, communication interface  may be an integrated services digital network (ISDN) card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example, communication interface  may be a local area network (LAN) card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation, communication interface  sends and receives electrical, electromagnetic or optical signals that carry digital data streams representing various types of information.","Network link  typically provides data communication through one or more networks to other data devices. For example, network link  may provide a connection through local network  to a host computer  or to data equipment operated by an Internet Service Provider (ISP) . ISP  in turn provides data communication services through the world wide packet data communication network now commonly referred to as the \u201cInternet\u201d . Local network  and Internet  both use electrical, electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link  and through communication interface , which carry the digital data to and from computer system , are exemplary forms of carrier waves transporting the information.","Computer system  can send messages and receive data, including program code, through the network(s), network link  and communication interface . In the Internet example, a server  might transmit a requested code for an application program through Internet , ISP , local network  and communication interface .","The received code may be executed by processor  as it is received, and\/or stored in storage device , or other non-volatile storage for later execution. In this manner, computer system  may obtain application code in the form of a carrier wave.","In the foregoing specification, the invention has been described with reference to specific embodiments thereof. It will, however, be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements and in which:",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 7B","FIG. 7A"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
