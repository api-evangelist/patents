---
title: Method and system for modifying properties of graphical user interface components
abstract: A method, computer program product, and data processing system for modifying attributes of GUI components without invasive code modification are disclosed. In a preferred embodiment, a set of attributes for GUI components is loaded into memory from persistent storage, such as a file. A root container component forming the root of a hierarchy of components defined by a containment relation is identified and passed as a parameter to a routine that traverses the hierarchy so as to visit each GUI component. As each GUI component is visited, if one or more attributes from the aforementioned set of attributes are found to be applicable to the visited GUI component, the GUI component's attributes are modified to comport with the set of attributes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07865844&OS=07865844&RS=07865844
owner: International Business Machines Corporation
number: 07865844
owner_city: Armonk
owner_country: US
publication_date: 20090119
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application is a continuation of application Ser. No. 10\/392,806, filed Mar. 19, 2003, status allowed.","1. Technical Field","The present invention is related generally to software that provides a graphical user interface.","Specifically, the present invention is directed toward providing a means of modifying the properties of graphical user interface components without resorting to extensive changes in source code.","2. Description of Related Art","Many computer software products today utilize a graphical user interface or GUI (typically pronounced like \u201cgooey\u201d). A GUI is simply a visual means of human-computer interaction that utilizes pictures or other visual representations besides text or characters.","Most GUIs make use of visual controls that are displayed on the user's display and actuated by user input in order to provide input to the software associated with the GUI. In a typical GUI, a pointing device, such as a mouse, is used to move a cursor around a display and actuate visual controls. A GUI will typically also make use static display components, such as icons or text, for the display of information.","Many GUIs are what is known as a \u201cwindowing\u201d interface, because they arrange information visually on a display in the form of panels or \u201cwindows\u201d superimposed on a background called a \u201cdesktop.\u201d Typically, a window will contain a number of visual controls and static display component to facilitate user interaction.","Windows, visual controls, and static display components are what are known as GUI components, because they are the building blocks that make up the GUI. Some GUI components, such as windows, are known as \u201ccontainer components\u201d (or simply \u201ccontainers\u201d), because they may contain other components. Because a container component is itself a component, a container may also contain another container.","Container components include windows, but may also include other components, which may be visible or invisible. Some GUIs make use of invisible container components to group other components together in some visual arrangement or non-visual relationship (e.g., mutually exclusive checkboxes).","Many modern programming language implementations have built-in features for producing GUIs, usually either by providing an interface to services provided by system-level software or by including standard libraries of GUI code. The JAVA\u2122 programming language, for example, is an object-oriented programming language that includes standard application programming interfaces (APIs) for defining GUIs. Two APIs that are currently part of the JAVA\u2122 programming language standard are the Abstract Windowing Toolkit (AWT) API and the Swing API. In the JAVA\u2122 programming language, as is typical of object-oriented GUI APIs, each type of GUI component is defined as a class.","In an object-oriented programming language, a class is a definition of a data type that includes a collection of data, called member variables, and a set of operations that may be performed on the data, called methods (or alternatively, member functions). An actual collection of data in the data type defined by a class is called an object. In object-oriented programming (OOP) parlance, an object is said to be an \u201cinstance\u201d of its class, because it is an actual item of data that is defined in accordance with the class. The run-time process of generating an object in an object-oriented programming language is called \u201cinstantiation,\u201d and an object that exists at run-time is said to be \u201cinstantiated.\u201d","Object-oriented programming languages also typically provide for what is known as \u201cinheritance.\u201d Using inheritance, a new class (called a \u201cdescendant\u201d class) can be defined in terms of one or more existing classes (called \u201cbase\u201d classes) so that the descendant class inherits one or more of the member variables or methods of the base class. As a general rule in object-oriented languages, an object of a descendant class can be treated as being an instance of the base class. This ability to treat objects from descendant classes as if they were instances of base classes is called \u201cpolymorphism.\u201d","In an object-oriented GUI API, such as those provided by the JAVA\u2122 programming language, GUI components are instantiated as objects, and relationships are established between the instantiated objects in order to define the placement and behavior of GUI components with respect to each other. For example, a \u201ccontainment relation\u201d is a relationship between GUI components that relates a container component to the components contained by that container component. In an object-oriented GUI API, for example, container classes may define methods that establish a containment relation by making the container contain some other component.","A typical GUI component has one or more attributes that define particular properties of the component. For example, a \u201cbutton\u201d component in a typical GUI will have attributes that define the size of the button on the display, the text or graphics displayed on the face of the button, the background color of the button, a keyboard shortcut associated with the button, and the like. In general, the portion of program code (e.g., function, method, subroutine, procedure, etc.) that instantiates a GUI component will also contain a number of lines of code that set the attributes for that component to desired values.","Sometimes, the general look or GUI content of an entire computer program needs to be modified. In cases such as these, different attributes for the GUI components will need to be set. For example, it may be necessary to enlarge all of the GUI components and their text if a program is being adapted to be used by users with poor eyesight. As another example, if a program is being adapted for users speaking different languages, the text, character set, and component sizes may need to be modified. If the code that sets attributes for each component is buried within the source code for the program along with the code for instantiating the components, this means that an exhaustive search and careful modification of the of the source code is necessary in order to effect this sort of large-scale or global change in GUI display or behavior.","As another example, it is sometimes necessary to adapt a program to execute in multiple display modes. For example, it may be necessary to use different colors at different times of the day. In such cases, global changes to an existing GUI display at run-time will be necessary.","GUI component attributes for a single component are difficult to modify, as well, because the code for setting attributes for that component may be buried within many lines of code or even spread out across a large program.","Thus, a need exists for a means to effect large-scale or global changes to attributes of GUI components without invasive program code modification.","The present invention provides a method, computer program product, and data processing system for modifying attributes of GUI components without invasive code modification. In a preferred embodiment, a set of attributes for GUI components is loaded into memory from persistent storage, such as a file. A root container component forming the root of a hierarchy of components defined by a containment relation is identified and passed as a parameter to a routine that traverses the hierarchy so as to visit each GUI component. As each GUI component is visited, if one or more attributes from the aforementioned set of attributes are found to be applicable to the visited GUI component, the GUI component's attributes are modified to comport with the set of attributes.","With reference now to the figures and in particular with reference to , a pictorial representation of a data processing system in which the present invention may be implemented is depicted in accordance with a preferred embodiment of the present invention. A computer  is depicted which includes system unit , video display terminal , keyboard , storage devices , which may include floppy drives and other types of permanent and removable storage media, and mouse . Additional input devices may be included with personal computer , such as, for example, a joystick, touchpad, touch screen, trackball, microphone, and the like. Computer  can be implemented using any suitable computer, such as an IBM eServer computer or IntelliStation computer, which are products of International Business Machines Corporation, located in Armonk, N.Y. Although the depicted representation shows a computer, other embodiments of the present invention may be implemented in other types of data processing systems, such as a network computer. Computer  also preferably includes a graphical user interface (GUI) that may be implemented by means of systems software residing in computer readable media in operation within computer .","With reference now to , a block diagram of a data processing system is shown in which the present invention may be implemented. Data processing system  is an example of a computer, such as computer  in , in which code or instructions implementing the processes of the present invention may be located. Data processing system  employs a peripheral component interconnect (PCI) local bus architecture. Although the depicted example employs a PCI bus, other bus architectures such as Accelerated Graphics Port (AGP) and Industry Standard Architecture (ISA) may be used. Processor  and main memory  are connected to PCI local bus  through PCI bridge . PCI bridge  also may include an integrated memory controller and cache memory for processor . Additional connections to PCT local bus  may be made through direct component interconnection or through add-in boards. In the depicted example, local area network (LAN) adapter , small computer system interface SCSI host bus adapter , and expansion bus interface  are connected to PCI local bus  by direct component connection. In contrast, audio adapter , graphics adapter , and audio\/video adapter  are connected to PCI local bus  by add-in boards inserted into expansion slots. Expansion bus interface  provides a connection for a keyboard and mouse adapter , modem , and additional memory . SCSI host bus adapter  provides a connection for hard disk drive , tape drive , and CD-ROM drive . Typical PCI local bus implementations will support three or four PCI expansion slots or add-in connectors.","An operating system runs on processor  and is used to coordinate and provide control of various components within data processing system  in . The operating system may be a commercially available operating system such as Windows XP, which is available from Microsoft Corporation. An interpreter, a virtual machine, or other run-time platform, such as a JAVA\u2122 Virtual Machine, may run in conjunction with the operating system and provides calls to the operating system from programs in the JAVA\u2122 programming language or other applications executing on data processing system . Instructions for the operating system, the run-time platform, and applications or programs are located on storage devices, such as hard disk drive , and may be loaded into main memory  for execution by processor .","Those of ordinary skill in the art will appreciate that the hardware in  may vary depending on the implementation. Other internal hardware or peripheral devices, such as flash read-only memory (ROM), equivalent nonvolatile memory, or optical disk drives and the like, may be used in addition to or in place of the hardware depicted in . Also, the processes of the present invention may be applied to a multiprocessor data processing system.","For example, data processing system , if optionally configured as a network computer, may not include SCSI host bus adapter , hard disk drive , tape drive , and CD-ROM . In that case, the computer, to be properly called a client computer, includes some type of network communication interface, such as LAN adapter , modem , or the like. As another example, data processing system  may be a stand-alone system configured to be bootable without relying on some type of network communication interface, whether or not data processing system  comprises some type of network communication interface. As a further example, data processing system  may be a personal digital assistant (PDA), which is configured with ROM and\/or flash ROM to provide non-volatile memory for storing operating system files and\/or user-generated data.","The depicted example in  and above-described examples are not meant to imply architectural limitations. For example, data processing system  also may be a notebook computer or hand held computer in addition to taking the form of a PDA. Data processing system  also may be a kiosk or a Web appliance.","The processes of the present invention are performed by processor  using computer implemented instructions, which may be located in a memory such as, for example, main memory , memory , or in one or more peripheral devices -.","The present invention provides a method, computer program product, and data processing system for modifying attributes of GUI components without invasive code modification. According to a preferred embodiment of the present invention, a set of GUI component attributes are loaded from persistent storage in a markup language, and the set of GUI component attributes are recursively applied to a set of instantiated GUI components in a run-time environment.","These terms are defined as follows: A \u201cset\u201d is an aggregation of zero or more items. A \u201cGUI component\u201d is a constituent element of a graphical user interface (GUI). An \u201cattribute\u201d of a GUI component is information that defines a property of the component; some examples of attributes include, but are not limited to, display attributes defining the appearance of a GUI component, behavior attributes defining the behavior of a GUI component, and informational attributes that define miscellaneous information to be associated with the component. \u201cPersistent storage\u201d is a storage system or medium for storing data in which the data is stored in a way that preserves the data during periods of time in which an item of computer software that uses the data is not executing. A \u201cmarkup language\u201d is a human-readable language for expressing data in which textual data is given a computer-discernable semantics by the annotation of the textual data with computer readable tags.","To \u201cinstantiate\u201d a GUI component means to create a representation (an \u201cinstance\u201d) of a particular GUI component in a data processing system, usually in the memory of the data processing system. The concept of instantiating a component can be roughly described as \u201cmaking\u201d the component. Thus, a computer program that has code that defines the operation, behavior, and appearance of a \u201cbutton\u201d GUI component will not have \u201cinstantiated\u201d a \u201cbutton\u201d until a representation of a particular \u201cbutton\u201d is created. In the context of GUI components that are defined as classes (e.g., in an object-oriented programming language), this representation will generally be an object that is an instance of the class. For the purposes of the this specification and the accompanying claims, however, representations of a particular GUI component in a data processing system that are not objects, in the object-oriented sense, are also said to be \u201cinstantiated.\u201d","A \u201crun-time environment,\u201d for the purposes of this specification and the accompanying claims, is a process, thread, memory space, virtual machine, data storage, or other entity in a data processing system, in which the process, thread, memory space, virtual machine, data storage or other entity is associated with computer software under execution. A data processing system performs an action \u201crecursively\u201d when the action is performed by a function, method, procedure, or other form of routine that re-invokes itself in a self-referential manner (e.g., a function that contains a function call to itself).","Turning now to , a diagram of a file in eXtensible Markup Language (XML) representing a set of attributes for GUI components in accordance with a preferred embodiment of the present invention is provided. XML is a standard for a markup language that was developed by the World Wide Web Consortium (W3C). XML is called eXtensible Markup Language, because it allows for the creation of user-defined tags. For example, the tags employed in the file depicted in  are defined to represent GUI components and their attributes. The file depicted in  is, in a preferred embodiment, stored in some kind of persistent storage, such as on disk, or in a database. One of ordinary skill in the art will recognize that any of a number of different storage formats and media may be employed to store GUI component attribute information in accordance with the teachings of the present invention.","In a preferred embodiment, a set of attributes, such as are stored in the file depicted in , will be loaded into the memory space of a run-time environment. Then, an attribute application routine, such as that depicted in pseudo-code form in , is executed to apply the set of attributes to instantiated GUI components in the run-time environment. This allows global or at least wide-spread changes to GUI attributes to be made in a single line of code (i.e., a call to the attribute application routine), thus preventing major code revisions. It also allows display attribute information to be decoupled from the program code itself (i.e., by use of a file or database, such as depicted in ), so that once the small amount of code needed to call the attribute application routine is inserted in a program, attributes may be redefined without resorting to code changes at all.","Turning now to the specifics of , GUI component attribute information in this preferred format is surrounded by begin and end tags . Begin and end tags  identify that the information contained within begin and end tags  refer to GUI component attributes (also called properties). In many markup languages, such as the XML markup language that is depicted in , data is arranged in a hierarchical format. In the XML example in , begin and end tags  represent a highest level in the hierarchy of information provided in the file depicted in . Each level in the hierarchy is represented by tags that surround information at lower levels in the hierarchy. For example, tags  and tags  denote two sets of information residing at the next lowest level in the hierarchy from begin and end tags .","Tags  represents the default attributes for a \u201cbutton\u201d GUI component. At the next lowest level from tags  are tags  and tags . Tags  and tags  denote different display modes, namely a day mode and a night mode. The run-time environment making use of the set of attributes provided in  may specify that the run-time environment is operating in a particular display mode. For example, during the day, the run-time environment may operate in a \u201cday mode,\u201d while the run-time environment may operate in a \u201cnight mode\u201d for easier viewing at night. Tags  represent that the information contained within tags  corresponds to attributes of a button to be applied when the run-time environment is operating in day mode. Likewise, tags  denote that the information contained within tags  corresponds to attributes to be applied to a button GUI component when the run-time environment is operating in night mode.","The information contained within tags  corresponds to the individual attribute to be applied to a button GUI component in day mode. Line , for example, specifies a background color for a button GUI component to be applied in day mode. Tags  designate that the attribute of background color is specified. Text , which is surrounded by tags , is the actual specified background color. Note that text  is not a tag, but is merely textual data. In a markup language such as XML, tags are generally used to provide structure to the data, but the data itself may be specified as raw text, as is the case with text . Line  similarly specifies a foreground color attribute by surrounding textual data with tags. Tags  are included in this example to show that individual attributes may include their own sub hierarchy of sub-attributes. Tags  denote that the information contained within tags  specifies the font to be applied to a button GUI component in day mode. A specific font, however, is generally specified using more than one item of information. Line , which is contained within tags , specifies a font name, while line  specifies a type of font, such as bold face or italics. Each of these sub-attributes is specified by surrounding textual data with tags that impart a meaning and structure to the data. For example, line  includes tags  that specify that the information contained within tags  is the name of font to be used. Text , which is contained within tags , is the actual designation of a particular font name.","The information contained within tags , just examined, specifies default attributes to be applied to button GUI components in either of a day mode and a night mode. Tags  also specify a set of GUI attributes to be applied to a button GUI component, but tags  correspond to attributes to be applied to a specifically named button GUI component. A tag attribute  is included within the first of tags  to specify that tags  correspond to GUI component attributes to be applied to a specifically named button GUI component. In the example presented in , tag attribute  is used to designate that the name of the specific button GUI component to which the attributes contained within tags  correspond is \u201cOK.\u201d Allowing specific GUI components to be named within the set of attributes allows exceptions to be made to the default GUI component attribute settings for particular components. For example, it may be useful to establish global or default settings for button GUI components or other GUI components, while at the same time specifying that certain GUI components have different attributes, such as in the case of an \u201cOK\u201d or \u201cAccept\u201d button, where it may be desirable to make the button more conspicuous on the user's display.","A preferred embodiment of the present invention applies a set of attributes, such as are depicted in , to some or all of the instantiated GUI components associated with a run-time environment.  concern how a set of GUI attributes, once loaded into memory, may be applied to a set of GUI components containing all or some of the instantiated components in a run-time environment. A preferred embodiment of the present invention accomplishes this application of GUI component attributes over a set of GUI components by exploiting the containment relation between container components and GUI components contained within container components. In an object-oriented programming language or other programming environments supporting object or object models, the relation between GUI components and their containers is easily expressed in terms of classes.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 4","FIG. 4","FIG. 4","FIG. 4"],"b":["400","402","404","400","402","400","406","406","402","400","408","402","400","402","400","402","408"]},"One of ordinary skill in the art will recognize that because of polymorphism, an instance of container class  may contain any instance of a GUI component class that is descended from component class . This means that an instance of container class  may also contain another instance of container class , as container class  is descended from component class . Thus, a graphical user interface patterned after the object model provided in  will utilize GUI components arranged in a hierarchical structure according to a containment relation that relates container components to components contained within the container components. Such a hierarchy is depicted in .",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 5","FIG. 5"],"b":["500","502","504","502","506","500","500","500","500"],"i":"Introduction to Algorithms Second Edition"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIGS. 6A and 6B","FIGS. 6A and 6B","FIG. 6B","FIG. 6A","FIG. 3"]},"Turning now to , line  defines a method  for applying GUI attributes to GUI components. Line  specifies that a root container, called \u201ccontainer\u201d (here italicized to distinguish the identifier name from the generic term \u201ccontainer), is passed in as an argument to method . Throughout this discussion, we will refer to the object passed into method  as \u201ccontainer,\u201d since that is the name of the parameter that refers to that object. It should be noted, however, that, strictly speaking, \u201ccontainer\u201d is a parameter that only refers to an actual object and that actual object has its own object name that existed from when the object was instantiated. That object name will generally he distinct from the name \u201ccontainer.\u201d In this discussion, it will be specifically noted when container is used to refer to the parameter only, rather than to the object referred to by the container parameter.","It should also be noted that, although it is not depicted in , method  may be written so as to allow a \u201cmode\u201d parameter to be passed in to allow only those attributes pertaining to a particular display mode, specified by the \u201cmode\u201d parameter, to be applied to instantiated GUI components. Another way in which a display mode can be specified is to set a \u201cmode\u201d variable that can be accessed by the routines and sub-routines that will apply attributes to instantiated GUI components, such as method  and the method called on line , for example.","Execution of method  begins with statement , which specifies that if container is a null pointer \u201ci.e., container does not refer to an actual container\u201d, method  should be exited immediately to avoid triggering an error condition or exception.","Next, properties are set for container. \u201cif\u201d statement  sets out instructions to be followed in the case that container refers to a JPanel. \u201cif\u201d statement  specifies that statement  should be executed if container refers to a container that is specifically named in the set of GUI component attributes to be applied (e.g., as in ). \u201cif\u201d statement  makes use of an object called \u201cnamed\u201d to determine whether the object name of container (i.e., the name given at the time of instantiation to the object referred to by the parameter container) is among the names of specifically named GUI components from the set of attributes to be applied. A method called \u201cgetName\u201d that is associated with the class Container (as in the \u201cjava.awt.Container\u201d class in the JAVA\u2122 programming language) is used to retrieve container's name. Statement , which is called if container refers to a container that is specifically named in the set of attributes to be applied (e.g., such as the button named \u201cOK\u201d in ), calls a method that takes container and container's object name as arguments and assigns attributes from the set of attributes to container based on the specified attributes in the set of attributes that correspond to the container's object name. In this object-oriented preferred embodiment, the actual setting of GUI component attributes is accomplished by calling methods that belong to the objects that represent the GUI components. For example, the method called in statement  will execute methods of container in order to set the attributes of container to values specified in the loaded set of attributes.","\u201celse\u201d statement  executes statement  to apply the default attributes to container in the event that container is not a specifically named container in the set of attributes to be applied. In like fashion, additional \u201cif\u201d statements, such as \u201cif\u201d statement , maybe used to apply appropriate attributes to the container according to the type of container (e.g., panel, window, dialog box, etc.).","Assignment statement  uses the \u201cgetComponents\u201d method of container to obtain an array of components that are contained by container. \u201cif\u201d statement  then specifies that if container contains no components, method  should terminate immediately, as no further processing on container is necessary. Otherwise, loop statement  sets up a loop that iterates over the array of components contained within container. A series of if statements are used to determine the type of component that is current component in the loop and whether the current component is a specifically named component in the set of attributes, such that specific attributes for that component should be applied from the set of attributes.","For example, \u201cit\u201d statement  specifies a set of instructions to be executed if the current component is an instance of a JButton, a JAVA\u2122 Swing GUI component If the current GUI component is an instance of a JButton, \u201cif\u201d statement  determines whether the current component is a specifically named JButton in the set of attributes. If the current component is a specifically named JButton in the set of attributes, statement  provides a call to a method to apply attributes to the current component that correspond to the object name of the current component. Otherwise, \u201celse\u201d statement  specifies that statement  is to be executed to apply default JButton attributes to the current component.","After either statement  or statement  is executed, \u201ccontinue\u201d statement  is executed to advance the loop to the next component contained by the container. \u201cif\u201d statement , which continues into , sets out a similar set of instructions to be followed in the case that the current component is an instance of a JLabel component, another JAVA\u2122 Swing GUI component. Likewise, for each additional non-container component type, a similar set of instructions is provided to allow appropriate attributes to be applied with respect to the type of the current component considered in the loop and, if applicable, the object name of the current component. This is represented by comment line .","\u201cif\u201d statement  is the last statement to be executed at each iteration of the loop defined by loop statement . \u201cit\u201d statement  specifies that if the current component is an instance of the container class (i.e., the current component is itself a container), method  is to be called recursively with the current component passed as an argument to method . The recursive call performed as part of \u201cif\u201d statement  causes method  to implement a depth-first search.","It should be noted at this point that although method  performs a depth-first traversal recursively, method  need not be implemented as a recursive method. For example, method  could be implemented iteratively, by employing an appropriate data structure, such as a stack or queue, to keep a running record of components that have been discovered, but have yet to be examined. One of ordinary skill in the art will recognize that, in general, a recursive method or function such as method , can usually be implemented in an iterative (i.e., non-recursive) form, as this is a general principle of computer science.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 7","b":["700","702","700","702","704"]},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 8","b":["800","802","802","804","802","806","808","812","808","810","808","812","820","808"]},"Referring now to an iteration of the loop as it begins in block , if the current component is itself a container (block : yes), a recursive call is made to the attribute application routine with the current component being the root container (block ). After the recursive call in block  is completed, the process cycles back to block  to continue the loop. If the current component is not a container (block : no), execution continues to block .","If the current component is a specifically named component in the set of attributes (block : yes), attributes are applied to the current component based on the components name (block ). Otherwise, (block : no), default attributes are applied to the current component based on the components type (block ). Following execution of either block  or block , the process cycles to block  to continue the loop.","It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions or other functional descriptive material and in a variety of other forms and that the present invention is equally applicable regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable-type media, such as a floppy disk, a hard disk drive, a RAM, CD-ROMS, DVD-ROMs, and transmission-type media, such as digital and analog communications links, wired or wireless communications links using transmission forms, such as, for example, radio frequency and light wave transmissions. The computer readable media may take the form of coded formats that are decoded for actual use in a particular data processing system. Functional descriptive material is information that imparts functionality to a machine. Functional descriptive material includes, but is not limited to, computer programs, instructions, rules, facts, definitions of computable functions, objects, and data structures.","The description of the present invention has been presented for purposes of illustration and description, and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention, the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated."],"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objectives and advantages thereof, will best he understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 6A-6B"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
