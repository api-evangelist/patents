---
title: Measuring network jitter on application packet flows
abstract: A method is described for measuring the jitter experienced by an application's network traffic. The measurement is based solely on packets sent or received by the application itself. The method does not alter the application's packets, in particular, it does not add a timestamp to the packets before they are sent. Instead, it creates a table that stores unique identifiers of the application's packets along with the time the packets are sent. On the receiving computer, a similar table is created that stores the unique packet identifiers along with the time the packets are received. Records of sent packets are associated with records of received packets so that the time a packet was sent can be compared to the time the same packet was received. The resulting data are processed to calculate network jitter and packet loss ratios.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06928473&OS=06928473&RS=06928473
owner: Microsoft Corporation
number: 06928473
owner_city: Redmond
owner_country: US
publication_date: 20000926
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","Overview of a General-Purpose Computer","Measuring Latency Variation (Jitter)","Clock Skew and Other Hardware Anomalies","Another Method for Measuring Jitter"],"p":["The present invention relates generally to computer networks, and, more particularly, to measuring variations in the latency of transmissions over computer networks.","Traffic flowing from an application running on one computer to an application running on another computer might pass through several network elements such as operating system queues, network adapter cards, LANs, routers, and the like. Each element transmits data at a finite rate so each element has the potential to slow the passage of the traffic. Congestion occurs whenever the rate at which data are sent to a network element exceeds the rate at which the network element transmits the data. Network elements may cope with congestion by queuing data until the congestion subsides or by discarding data to alleviate the congestion.","As a result of the methods of handling congestion, applications face variations in the time needed to transport data (network latency) and in the amount of data lost in transmission. Applications differ from one another in how tolerant they are of these variations. Real-time video and audio applications, for example, cannot tolerate large variations in either latency or in data loss.","Some networks issue Quality of Service (QoS) guarantees concerning their ability to support the specific traffic requirements of applications. QoS guarantees are implemented in a network by allocating scarce resources to application traffic flows in a manner that meets the applications' traffic requirements. For example, a congested network element might queue the traffic of applications that are tolerant of latency while transmitting latency-sensitive traffic without delay. When the congestion clears, the queued traffic may be sent.","While the benefits of QoS guarantees are generally acknowledged, those benefits are difficult to measure accurately. For example, some existing tools attempt to measure latency by transmitting a large amount of data and then determining how much time passes until the data are received. This technique gives, at best, a very coarse measurement of latency, averaged over the entire period of transmission. Measurement techniques such as \u201cpinging\u201d the receiver are more accurate, but merely provide average, round-trip latency information. In reality, the latency may be substantially different in the two directions, and that difference may be significant to an application that streams video or audio.","Another problem with measuring latency stems from differences in the clocks on the sending and receiving computers. Measurements based on the difference between the time of transmission as measured on the sending computer and the time of reception as measured on the receiving computer depend upon a careful synchronization of the two clocks. Complex latency measurement tools exist, often relying on radios, satellite receivers, or modems to synchronize the clocks of the sender and receiver, but these tools are often expensive and serve only to bound the problem, not to eliminate it.","The invention described in U.S. patent application Ser. No. 09\/537,995, \u201cMethod and System for Accurately Calculating Latency Variation on an End-to-End Path in a Network,\u201d filed on Mar. 29, 2000, advances the art of QoS measurement by focusing on variations in latency (jitter) rather than on latency itself. The invention generates a predetermined number of packets on a sending computer. The packets are timestamped with the sender's local time and then sent over the network to a receiver. When a packet arrives at the receiver, it is similarly timestamped with the receiver's local time. The difference in the timestamps for each packet is recorded. These records provide only a rough measurement of latency because the clocks are not synchronized, but the variation among the records is an accurate measurement of network jitter. Measurements can be run with and without QoS mechanisms in place to see how well those mechanisms even out transport variations.","For some applications, however, the invention described in Ser. No. 09\/537,995 is not adequate because it relies on a traffic flow generated by the measurement tool itself. Introducing that traffic flow into the network may distort the characteristics of network traffic so much that the resulting jitter measurements do not accurately indicate the conditions faced by an application. Also, the patterns of traffic generated by certain applications may be very complex and may not be well modeled by a tool that sends fixed-size packets at a fixed rate. What is desired is a tool that measures network jitter using packets generated by an application rather than packets generated by the tool itself.","The above problems and shortcomings, and others, are addressed by the present invention, which can be understood by referring to the specification, drawings, and claims. In accordance with one aspect of the invention, a method is described for measuring the jitter experienced by an application running on a computer, the measurement based solely on the packets sent or received by the application itself. The method introduces no packets of its own into the packet flow.","The jitter measurement method does not alter the application's packets, in particular, it does not add a timestamp to the packets before they are sent. Instead, it creates a table that stores unique identifiers of the application's packets along with the time the packets are sent. On the receiving computer, a similar table is created that stores the unique packet identifiers along with the time the packets are received. Again because the jitter measurement method does not alter the application's packets, the unique packet identifier is based on information already present in the application's packets.","Records of sent packets are associated with records of received packets so that the time a packet was sent can be compared to the time the same packet was received. In the case of IP networks, the unique packet identifier rolls over back to zero after every 64k packets sent by the computer so some processing is necessary before the association can be made. That processing is useful in resolving the problems of lost packets and of packets received in an order different from the one in which they were sent. The processing also helps to lessen the burden of searching for associated packet records.","Once the send and receive times are associated in accordance with the teachings of the present invention, the resulting information can be sent to the jitter measurement tool described in U.S. patent application Ser. No. 091537,995, \u201cMethod and System for Accurately Calculating Latency Variation on an End-to-End Path in a Network.\u201d That tool calculates the network jitter and the packet loss ratio which can then be reported to the user.","The following description is based on possible embodiments of the invention and should not be taken as limiting the invention in any way. The first section presents an exemplary hardware and operating environment in which the present invention may be practiced. The next two sections describe network jitter and present one way to measure jitter. These two sections are based on U.S. patent application Ser. No. 09\/537,995, \u201cMethod and System for Accurately Calculating Latency Variation on an End-to-End Path in a Network.\u201d The final section builds on the previous sections, describing aspects of the present invention as another method for measuring network jitter.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 1","b":["100","100","100","100"]},"The invention is operational with numerous other general-purpose or special-purpose computing system environments or configurations. Examples of well-known computing systems, environments, and configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, and distributed computing environments that include any of the above systems or devices.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc., that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general-purpose computing device in the form of a computer . Components of the computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory  to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include the Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus, also known as Mezzanine bus.","The computer  typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by the computer  and include volatile\/nonvolatile and removable\/non-removable media. By way of example, and not limitation, computer-readable media may include computer storage media and communications media. Computer storage media include volatile\/nonvolatile and removable\/non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules, or other data. Computer storage media include, but are not limited to, random-access memory (RAM), read-only memory (ROM), EEPROM, flash memory, or other memory technology, CD-ROM, digital versatile disks (DVD), or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage, or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by the computer . Communications media typically embody computer-readable instructions, data structures, program modules, or other data in a modulated data signal such as a carrier wave or other transport mechanism and include any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communications media include wired media such as a wired network and a direct-wired connection and wireless media such as acoustic, RF, and infrared media. Combinations of the any of the above should also be included within the scope of computer-readable media.","The system memory  includes computer storage media in the form of volatile and nonvolatile memory such as ROM  and RAM . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within the computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and program modules that are immediately accessible to or presently being operated on by processing unit . By way of example, and not limitation,  illustrates an operating system , application programs , other program modules , and program data . Often, the operating system  offers services to application programs  by way of one or more application programming interfaces (APIs) (not shown). Because the operating system  incorporates these services, developers of application programs  need not redevelop code to use the services. Examples of APIs provided by operating systems such as Microsoft's \u201cWINDOWS\u201d are well-known in the art.","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media By way of example only,  illustrates a hard disk drive  that reads from and writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from and writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from and writes to a removable, nonvolatile optical disk  such as a CD ROM. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, DVDs, digital video tape, solid state RAM, and solid state ROM. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer-readable instructions, data structures, program modules, and other data for the computer . In , for example, hard disk drive  is illustrated as storing an operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from the operating system , application programs , other program modules , and program data . The operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies.","A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball, or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, and scanner. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port, or a Universal Serial Bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device, or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in FIG. . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or via another appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in a remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","In the description that follows, the invention will be described with reference to acts and symbolic representations of operations that are performed by one or more computers, unless indicated otherwise. As such, it will be understood that such acts and operations, which are at times referred to as being computer-executed, include the manipulation by the processing unit of the computer of electrical signals representing data in a structured form. This manipulation transforms the data or maintains them at locations in the memory system of the computer, which reconfigures or otherwise alters the operation of the computer in a manner well understood by those skilled in the art. The data structures where data are maintained are physical locations of the memory that have particular properties defined by the format of the data. However, while the invention is being described in the foregoing context, it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operations described hereinafter may also be implemented in hardware.","The present invention is directed to measuring latency variation on networks, including production networks and controlled networks that may be artificially congested. Note that as described below, the actual latency between sender and receiver is not measured, but rather the variable delay component, which is considered indicative of queuing delays and network congestion effects, may be determined on a per-packet basis. Moreover, the measurement may be conducted on devices in the network under test that are providing quality of service (QoS) through any number of QoS mechanisms, or may be conducted on devices that are not providing quality of service at all. As will be understood, this enables the benefits of QoS to be quantified in a manner relative to non-QoS systems.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 2","FIG. 2"],"b":["60","62","64","60","66","66","68","68"],"sub":["p ","p ","l ","m ","l ","n "]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 3","FIG. 3"],"b":["70","62","64","70","70","60","2","70","62","64","72","74","72","74","72"],"sub":["c ","c ","c ","c "]},"A measurement tool may be used to measure, on a per-packet basis, end-to-end network integrity and service quality for the verification of QoS. To this end, the measurement tool on a sender  sends a sequence of test packets through its network to the corresponding receiver , and then reports on the queuing delay experienced by each packet. Packets are marked with a sequence number at the sender such that packets that do not arrive at the respective receiver are recorded as dropped packets. The sequence numbers are thus unique, at least per session.","As generally represented in , the measurement tool comprises a session portion in a sender , including a user-mode test application  along with a kernel-mode timestamp component , and a session portion in a receiver  including a user-mode test application  along with a kernel-mode timestamp component . The network  shown in  may be a production network or a controlled network, or possibly some hybrid of both.","To run the session, a measurement tool session is invoked on both a sending host  and a receiving host  via the applications  and . By default, the measurement tool invokes network QoS and is useful for evaluating QoS mechanisms, and various parameters are adjustable. For example, the measurement tool can be varied to simulate traffic flows for a range of user selectable packet sizes, and can simulate traffic flows shaped to a range of token bucket parameters.","Upon invocation, the measurement tool uses the GQoS application programming interface (API), which is part of Winsock2, to invoke QoS from local traffic control and from the network . One QoS signaling protocol is RSVP (Resource Reservation Protocol), which works over TCP\/IP. RSVP applications can use RSVP messages to request quality of service from the network and to indicate QoS requirements to the network and to peer applications. As currently defined, RSVP uses Integrated Services (Intserv) semantics to convey its QoS requirements to the network.","RSVP messages follow the path of the traffic for which resources are being requested, whereby messages arrive at the devices whose resources will be utilized by a successful reservation, i.e., by admission of a flow. This provides admission control based on the current resources available in the affected devices, that is, RSVP-aware devices understand the applicability of RSVP requests to their specific media, and are able to accept or reject the messages based on their resources and ability to support the requests. Standard RSVP messages typically carry a quantitative description of the relevant QoS traffic in parameters referred to as token-bucket parameters (in Intserv semantics). RSVP is well-documented and is not described in detail herein for purposes of simplicity.","In The measurement tool sender application  begins by causing an RSVP PATH message to be sent by the sender  towards the receiver  and waits until a response is received from the measurement tool receiver application . When received, the measurement tool receiver , which is awaiting an RSVP PATH message from the sender , responds by transmitting an RSVP RESV message back to the sender application .","Receipt of the RESV message at the sender application  triggers the measurement phase of the measurement tool application . To this end, the sender begins submitting one or more buffers (e.g., the buffer  of ) to kernel-mode components  for transmission. Such components  typically include a sockets driver , a TCP\/IP driver , and a packet scheduler . The kernel paces the transmission of traffic according to the token bucket parameters and service type selected by the user via the measurement tool application  (e.g., entered by a user via a command line).","As packets are transmitted, the timestamp component  associates a sequence number and a sender-relative (local) time (e.g., to a precision of 100 nanoseconds) with each packet. More particularly, as represented in , a typical packet includes some header information  and a data section . The timestamp component  modifies the packet by writing a sequence number (\u201cS\u201d in FIG. ), e.g., into a data field  and by writing the send timestamp (shown in  as the simplified whole number ten (10), but in actuality the current system tickcount) at one predetermined offset, e.g., in a send time data field . The timestamp component  is installed below the other kernel-mode components , which, as will be understood, eliminates from consideration any transmission delay caused by higher components, thereby providing a more accurate time of actual send. If the timestamp component is not installed, the measurement tool may use a user mode timestamp component (e.g., in the test application ), however, this is less accurate than having the kernel-mode component . Further, note that in one alternative, instead of actually stamping the packets, the sender can associate the timestamps with each packet locally, such as in a file or the like, and then later send the file to the receiver , from which the receiver application  can match the timestamp information with received packets (e.g., by sequence number).","When each packet is received at the receiver , the receiver timestamp component  associates the packet with the local time therein. Thus, as shown in , when received, the receiving host  stamps the packet at a different data offset, e.g., at a received timestamp field , with the receiver's local timestamp (shown in  as the simplified whole number thirteen (13)). The stamped packet is then passed through other kernel drivers  up to the receiving measurement tool peer application , e.g., via a buffer  (FIG. ). Again, the receiver timestamp component  is preferably installed below the other receiver kernel-mode components  to eliminate from consideration any transmission delay caused by higher components and thereby provide a more accurate (local) time of actual receipt. Also, as with the sender timestamp, the receiver timestamp component  can associate the timestamps with each packet in another way, such as by writing the local receiver timestamp in a file, and then later matching the timestamp information in the file to each appropriate received packet.","As represented in , the receiving measurement tool application  adds each received packet to a log  of all received packets, including the packet sequence number, the time sent, and the time received. The test terminates on the sending side when the sender  has sent a predetermined number of packets (a default number of packets is 2048, however the default number may be overridden, e.g., via a command line that runs the measurement tool). The sender  and receiver  may negotiate this number.","Following transmission of the last packet, the sender  sends a terminating sequence of (e.g., ten) \u2018termination\u2019 packets. The test terminates on the receiving side upon receipt of a termination packet or upon receipt of the required number of packets. Note that, on particularly congested links, the receiver  may never receive the required number of packets and the termination packets may be dropped. In this case, the receiver application  may be terminated by some other mechanism, e.g., a \u2018DONE\u2019 message received via a TCP control channel, or may be terminated manually.","Upon termination, the receiver application  parses and processes the log  of received packets. Note that after collecting the raw packet data , the receiver application  may perform this parsing\/processing, and other post-processing operations described below, or alternatively, some or all of these actions may be performed by separate components (as logically represented in FIG. ). In any event, parsing and processing preferably provide summary statistics, for example, the total number of packets received and the sequence number of each dropped packet, and these statistics are maintained in one or more files of packet information . Also preferably maintained in the file or files  is detailed information for each packet including a send time and receive time, which may be normalized, the latency (difference between sent and received time), which also may be normalized, the packet size, and the sequence number. Normalization is described below.","In this manner, the measurement tool generates detailed result logs and is able to report very precise delay variations, on the order of microseconds or better.","After the packets have been transmitted and received (that is, those not dropped), a second phase of the measurement tool may process the list of sent and received times to perform normalization. A clock correction mechanism  may first be employed to correct for certain hardware anomalies, described below, in which event corrected packet data  are used. A normalizer process  is then employed to normalize the data as desired.","To normalize, the lowest sent timestamp (which should be the first) is located, along with the lowest difference between sent time and received time across all pairs of timestamps, i.e., the lowest latency. These values are recorded. The lowest send time is then subtracted from other send times. Note that in the examples described herein, simplified (whole number) timestamps are used, and the received timestamps are always later than sender timestamps (although straightforward logic is implemented to allow for the case in which the receiver's timestamps are actually earlier than the sender's timestamps).","By way of example, consider the following table of timestamps, also shown in the table 1281 of FIG. :",{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Time Sent","Time Received","Latency"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["10","13","3"]},{"entry":["11","19","8"]},{"entry":["12","18","6"]},{"entry":[".",".","."]},{"entry":[".",".","."]},{"entry":[".",".","."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Upon parsing these records, it is determined that the lowest send time is ten (10) and the lowest latency is three (3). The lowest send time of ten is then subtracted from all sent timestamps, which has the effect of normalizing the first packet's send timestamp to zero and each following packet's timestamp to the difference between the time that the first packet was sent and the time the following packet was sent. After the first normalizing step, the table looks as follows (as also shown in table 1282 of FIG. ):",{"@attributes":{"id":"p-0068","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Time Sent","Time Received","Latency"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","13","3"]},{"entry":["1","19","8"]},{"entry":["2","18","6"]},{"entry":[".",".","."]},{"entry":[".",".","."]},{"entry":[".",".","."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"During the next normalizing step, the lowest send time is subtracted from all received time stamps, yielding the following results (as also shown in table 1283 of FIG. ):",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Time Sent","Time Received","Latency"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","3","3"]},{"entry":["1","9","8"]},{"entry":["2","8","6"]},{"entry":[".",".","."]},{"entry":[".",".","."]},{"entry":[".",".","."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"In a last normalizing step, the lowest latency is subtracted from the received time stamps and each latency is updated to reflect the difference between the normalized send and receive timestamp pairs. Note that this corresponds to subtracting the lowest latency from each latency. This yields the following results (as also shown in table 1284 of FIG. ):",{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Time Sent","Time Received","Latency"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","0","0"]},{"entry":["1","6","5"]},{"entry":["2","5","3"]},{"entry":[".",".","."]},{"entry":[".",".","."]},{"entry":[".",".","."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Note that the first packet shows a latency of zero; however, this does not mean that the transmission delay is zero. Rather, it means that this packet's delay represents the best case or fixed delay that occurs between sender and receiver. Normalized latencies that are greater than zero indicate the amount of delay beyond the fixed delay or beyond the minimum delay. As such, these latencies represent the variable delay component that results from queuing and congestion, which, as can be readily appreciated, is ordinarily more interesting than the fixed delay component from the perspective of network a congestion analysis.","As is understood from the above, no attempt is made to determine the actual latency between sender and receiver; only relative latency, i.e., the variable delay component, is determined, which is indicative of queuing delays and network congestion effects. Note that this approach will not always yield valid results, as it is based on the assumption that there is one latency that is indicative of the fixed delay component of the network. This can be accomplished by a calibration phase if the network under test is a controlled (isolated) network. More particularly, if the network is controlled exclusively by the tester, then the lowest latency can (and should) be calibrated. To this end, during the calibration phase, no noise should be generated on the network. This assures that queues in network devices will be empty and that the minimal latency logged will indeed be indicative of the fixed delay component of the network. Noise is introduced following the calibration phase.","Alternatively, if a large enough number of packets is sent during a test run, then it is statistically very likely (even in production networks) that at least one of the packets will end up in a very short (or zero length) queue and will not be subjected to congestion delay. The minimum delay used in the calculation will be the delay experienced by this \u201cbest case\u201d packet. This assumption fails on a heavily congested network in which queues never drop to zero length, however.","Once the various sets of information have been normalized, analysis is simplified, and the data may be manipulated as desired to determine, for example, what happened to each packet on the network, the benefits of QoS, and so forth. For example, the various latencies may be plotted against the send times, for tests with and without QoS enabled. Note that once the raw packet data  are logged, the manipulation and analysis of the data need not be performed at the receiver and can be performed at any time or by some other process, as indicated in  by the dashed line separating the post-packet collection components  through .","Two examples of sample data for test trials measured via the present invention are shown in . Both trials were run across an isolated network consisting of two RSVP-capable routers connected by a 128 Kbps serial line. Each router was also equipped with an Ethernet interface. The sender was connected to one of the router's Ethernet interfaces, and the receiver was connected to the other. In addition, the sending port of a \u2018Smartbits\u2019 noise generator was connected to the same Ethernet network as the sender. The receiving port of the noise generator was connected to the same Ethernet network as the receiver. The noise generator was programmed to send 100 Kbps of noise traffic from its sending port to its receiving port such that the traffic generated by the noise generator would compete with the traffic generated by the test session for resources on the 128 Kbps link. The noise generator was programmed to generate a mix of packet sizes that simulated the typical load on a real corporate WAN link. The test session was invoked in a manner intended to simulate a telephony traffic flow. The parameters were set to result in a test traffic flow of 64-byte packets sent at a rate of 24 Kbps.","The purpose of the test was to examine the utility of RSVP in protecting the signal flow on a WAN link driven to near saturation. To this end, the first trial (which resulted, in ) was run without RSVP enabled on the routers. The second trial (which resulted in ) was run with RSVP enabled on the routers. In both cases, RSVP signaling was used between the sender and receiver. The X-axis represents the packet sequence number, while the Y-axis represents the normalized latency in units of 100 nanoseconds.","Note that  are not drawn to the same scale, as the y-axis of  ranges from zero to 1.8 seconds, while the y-axis of  ranges from zero to 0.12 seconds (indeed, the entire display of  would approximately fit below the halfway point of the 2,000,000 label of FIG. ). As can be appreciated, the measurement tool provides detailed information that quantifies the benefits of QoS.","As mentioned above, the raw latency data may be subject to hardware problems, which, if left uncorrected, would adversely influence the results. One such problem results from a \u201cbug\u201d in a commonly used timer chip, wherein the HAL timer in a machine jumps forward in certain scenarios. As represented in the simplified graph of latencies against sent times of , the bug that causes jumps in a clock can lead to jumps in the relative latencies that do not accurately reflect the true latency differences. Indeed, the detailed information provided by the measurement tool application was originally responsible for detecting this bug (subsequently diagnosed as an incorrectly set bit) in the particular timer chip. The detection and correction of the timer jump problem are described below with respect to , in which the jumps are detected and subtracted, leading to the simplified graph of latencies versus sent times of FIG. .","Another hardware-related problem is clock skew, in which crystal oscillator-based personal computer clocks are often subject to deviation from their nominal frequency. The deviation is on the order of several parts per million, and, as a result, clock skew measured between two contemporary personal computers may be on the order of ten microseconds per second.","As a consequence of clock skew, send timestamps and receive timestamps are generated based on clocks running at slightly different speeds. This leads to a result as generally represented in the simplified graph of , wherein the later in time that a packet is received, the greater (if the receiver clock is losing time with respect to the sender clock) the corresponding raw relative latency will be. Conversely, if the receiver's clock is gaining on the sender's clock, the later a packet is received in a session the shorter the relative latency will appear to be, resulting in a negatively-sloped line (not shown). When measuring queuing delays on the order of milliseconds over a period of seconds or minutes, the skew between the sending oscillator's rate and the receiving oscillator's rate is negligible. However, when measuring queuing delays that are much lower (such as on a high speed LAN) or when measuring delays over a long period of time, the clock skew may become significant.","To compensate for the clock skew, the timestamps are first normalized by factoring out the increase or decrease in slope over time. This step is based on the assumption that the clock skew is constant, while queuing delay is variable. In order to normalize for the effects of clock skew, the latency reports are fitted to a constant slope line. There are multiple possible statistical methods for this clock skew normalization. In one method, the sum of squared error as the goodness of fit measure is fit to a straight line (which makes an implicit assumption that latency is normally distributed). Another method uses absolute deviation as the goodness of fit measure (wherein the assumption is that latency is more like a double exponential about the mean). As can be readily appreciated, other statistical methods provide acceptable results. Once the slope is determined, any constant variation in latency is removed from the resulting timestamps, which, if then plotted, would generally result in the simplified, essentially zero-slope graph of FIG. . Note that this slope normalization should be performed after correction for any timer jumps, otherwise timer jumps would affect the slope.","Turning to an explanation of the operation of the present invention with particular reference to the flow diagrams of , a session operates as generally represented in step , by transmitting timestamped packets, stamping those packets on receipt, and then logging the information in those packets as described above. At step , the packets are arranged by sequence number (which should generally correspond to time sent). When transmission and receipt are complete, some time later at step  the post-collection process begins by continuing to step  of  to check for timer jumps. Of course, timer jump checking need not be performed for sessions wherein it is known that neither the sender nor the receiver includes a faulty timer chip.","Step  determines the amount of timer jump. This is accomplished in a Windows\u00ae 2000\/Windows NT\u00ae system from the operating system kernel by calling an API known as the QueryPerformanceCounterFrequency API. At step  the interpacket gaps on both the sender and receiver are determined. Also, note that latencies which are at least a fixed number of standard deviations away from the mean are referred to as \u201ctimer jumps.\u201d Step  selects the first latency to begin walking through the latencies to look for timer jumps.","Step  checks to determine if any \u201ctimer jump\u201d points are unpaired, that is, a suspected timer jump point in the set of sending timestamps is not matched with an equally suspect point in the set of receiving timestamps. If not, step  branches ahead to step , which selects the next latency at step  (or branches to  if there are no more) to repeat the test on the next latency.","If the suspected timer jump point is unpaired, step  instead branches to step  wherein it is determined whether the potential \u201ctimer jump\u201d unpaired point is solitary (that is, it is not surrounded by other suspect points). If so, this indicates a likely timer jump, otherwise it is likely an isolated incident. Via the last test at step , if a point is found that meets the above criteria, it is labeled as a timer jump point and added it to a list of timer jump points. When the points have been evaluated, step  branches to step  of FIG. .","Step  begins walking through the timer jump point list built in FIG. . If any point is listed, the point is selected at step  and checked to see if the suspect timer jump point is approximately equal to the amount of timer jump returned via the QueryPerformanceCounterFrequency API. If not, this suspect point is discarded at step , otherwise step  branches to step  wherein the jump amount is subtracted from the point and from all points after it (since once the timer jumps it counts further ticks relative to the jump amount). Step  repeats the process until the timer-jump list is exhausted. As can be understood, by correcting for timer jumps, the \u201cstepped\u201d latencies represented in the simplified graph of  are thus brought back into alignment as generally represented in the simplified graph of FIG. .","Returning to step  of , the slope is calculated using an appropriate statistical mechanism as described above, and the calculated slope is then used to correct the latencies for clocks skew. For example, the raw received times can be appropriately raised or lowered based on a factor determined from the calculated slope. At step , the lowest latency is determined from the corrected values, essentially providing a truly-lowest latency value. Note that if the lowest send time has not yet been determined, it also may be determined at step . At step , the lowest latency is used to normalize the other latencies as described above, and, if necessary, the lowest send timestamp may be used to normalize the send and receive times as also described above. At this time, the per-packet information may be analyzed in a straightforward manner.","As can be seen from the foregoing detailed description, the measurement tool application accurately calculates latency variations on an end-to-end path in a network. The tool provides high resolution, per-packet reporting, is capable of measuring latency in one direction on networks including production and controlled networks, and does not require synchronization of system clocks.","The method described above is of limited utility for some applications because it relies on traffic generated by the measurement tool itself. Introducing that traffic into the network may distort the characteristics of network traffic so much that the resulting jitter measurements do not accurately indicate the conditions faced by an application. Also, the patterns of traffic generated by certain applications may be very complex and may not be well modeled by a tool that sends fixed-size packets at a fixed rate. The present invention, in brief, builds on the framework provided above but measures jitter using packets generated by applications themselves.","This is made difficult by the fact that the present invention cannot introduce a timestamp into a packet generated by an application. Instead, during a QoS jitter test, a table is created on the sender that correlates sent packets with the time that they are transmitted, as measured by the sender's clock. The receiver generates a similar table, correlating the received packets with the time they were received, as measured by the receiver's clock. The difficulty arises when the data in the two tables are merged (by sending one table to the other computer, or sending both tables to a third computer). The difficulty lies in associating a sent packet (with its transmission timestamp) with the same packet as received (with its reception timestamp). Once that association is made, the differences in the timestamps are recorded. The records produced can then be processed in a manner similar to that shown in the rightmost column of , items  through , and described in the flow diagram of .","Collecting Data",{"@attributes":{"id":"p-0093","num":"0092"},"figref":["FIG. 18","FIG. 4"],"b":["76","1800","62","135","135","64"]},"When the user chooses to monitor traffic flows, the jitter management tool  tells the local timestamp component  which traffic flows it should begin to monitor. For IP networks, traffic flows are uniquely identified by a quintuple of information discussed in the next section. For non-IP networks, an analogous unique traffic flow identifier can be developed. The information about which traffic flows to monitor is also sent to the jitter management tool running on the remote computer , in one embodiment by the Winsock API, and from there passed down to the receiver timestamp component .","In operation, the application  submits buffers  to kernel-mode components  for transmission. When the data in the buffers are packetized, the sender timestamp component  intercepts the packets and associates a packet identifier (described in detail below) and a sender-relative timestamp with each packet. The sender timestamp component does not alter the packet by writing the timestamp into it. Rather, it records the timestamp and the packet identifier as a packet record in the sender timestamp buffer . The packet is then delivered to the receiver computer .","The sender timestamp component  is shown installed below the other kernel-mode components  so that its timestamps do not reflect latency caused by those higher-level components. This gives the measurement tool a more accurate picture of latency and jitter as produced by the network itself. The sender timestamp component may also reside in user-mode space, but it would then provide less-accurate measurements of the network.","When the packets are received, the receiver timestamp component  records the local time and the packet identifier in the receiver timestamp buffer . The packets are then passed up the stack through the other kernel-mode components  to the receiving application . As is the sender timestamp component , the receiver timestamp component is shown installed below the other receiver kernel-mode components to eliminate from the measurements any delays caused by those higher-level components.","Associating Sent Packet Records with Received Packet Records","To generate useful information from the timestamp data, an association is made between the time a packet is sent (data collected on the sender computer ) and the time the same packet is received (data collected on the receiver computer ). Making the association is not straightforward because the present invention does not alter the application packets to uniquely mark them. Instead, according to one aspect of the present invention, the packet timestamps are stored with a (mostly) unique packet identifier. This packet identifier can then be used to associate the sent and received times of the packets.",{"@attributes":{"id":"p-0099","num":"0098"},"figref":"FIG. 19","b":["1801","1802","1901","1902","1903","1904","1905"]},"A packet may be identified by combining the packet flow identification quintuple with the IP Identification field (IP ID) . The IP protocol specifies that this 16-bit field be part of the header of every IP packet. A computer increments the IP ID for each IP packet it sends, regardless of which packet flow carries the packet. Because 16 bits can code for only 64k different numbers, the IP ID is not completely unique and rolls over for every 64k packets transmitted by the sending computer. For non-IP networks, a different unique identifier can be identified to serve the purpose of the IP ID.","The jitter measurement tool  matches a packet identifier sextuple (packet flow identifier quintuple plus IP ID) from the sender with an identical sextuple on the receiver. However, there are a few complications. Sent packets may have been lost on the network and thus may have no corresponding received packet record. Packets may not have been received in the same order in which they were sent. Finally, the IP ID is not unique because of its rollover after every 64k packets sent. To deal with these complications, one implementation of the method of the present invention imposes a sliding window on the 64k range of possible IP IDs and processes packets within that window.","This implementation is illustrated in .  is a data structure diagram showing the packet records stored in the sender timestamp buffer  following an illustrative jitter measurement test. The packet records have been simplified from their full form as shown in FIG. . Jitter measurement is performed within one packet flow so the packet flow identifier quintuple, items  through  in , has been omitted for clarity. In this jitter test, the sender computer  sent the packets as identified in the IP ID column . The IP ID rolled over in the middle of the test.  is a data structure diagram that shows the packet records from this test as they are recorded in the receiver timestamp buffer . The packets were not received in the order sent and some packets were lost.","The association between the sent packet records in FIG. A and the received packet records in  may be formed through the following three-step procedure. First, the received packet records are sorted into the order in which the packets were sent. This example will show the received packet records being sorted within the receiver timestamp buffer , but implementation considerations may call for the packet records to be moved elsewhere before processing, particularly if some of the packet records are to be processed while the test is still in progress.  shows the 64k range of possible IP IDs. The IP IDs are given in hexadecimal notation, running from 0 (0\u00d70000) to 64k \u22121 (0\u00d7FFFF). A sliding window  is imposed onto the range, the window starting with the IP ID of the first packet in the receiver timestamp buffer . The sliding window should be significantly smaller than the range of possible IP IDs while being large enough to hold the IP IDs of several received packets. Here, the sliding window is chosen to cover half the range of possible IP IDs. It starts at 0\u00d70000 and ranges to 0\u00d78000. Packets with IP IDs within the range demarcated by the sliding window are sorted. Because the window in  does not span the IP ID rollover at 0\u00d7FFFF, sorting is done by simply putting lower-valued IP IDs before higher-valued ones. The result of this sort is the receiver timestamp buffer shown in FIG. C. Note that the last three IP IDs in the receiver timestamp buffer are outside the range of the sliding window in FIG. A and so are not sorted.","Once the IP IDs within the range of the sliding window  are sorted, the window slides through half its range as shown in  B. The sorting is repeated, but in the present case, there are no IP IDs within the range of the sliding window so nothing changes. The window sliding and sorting continues with no result until the window reaches the position shown in FIG. C. Here, the window ranges from 0\u00d78000 to 0\u00d7FFFF, which range includes the final three entries in the receiver timestamp buffer . Those entries are sorted resulting in the receiver timestamp buffer shown in FIG. D.","The window  slides once more and, as shown in , ranges from 0\u00d7C000 to 0\u00d74000, wrapping around the rollover point at 0\u00d7FFFF. Sorting in this window is slightly different from the previous cases because all IP IDs in the 0\u00d70000 -0\u00d74000 range are sorted to come after all IP IDs in the 0\u00d7C000 -0\u00d7FFFF range. This sorting accounts for the rollover in IP IDs and results in the receiver timestamp buffer  shown in FIG. E. With the next window slide, the window returns to its original position and the sliding and sorting step is complete. A comparison of  shows that this step has correctly sorted the received packet records into the order in which the packets were sent.","The second step of associating sent with received packet records logically begins by bringing together the packet records in the two timestamp buffers  and . This may be done physically by transmitting the records in one buffer to the other computer or by transmitting the records in both buffers to a third computer. It may also be done virtually by letting the jitter measurement tool access the packet records wherever they are located. The records in the two timestamp buffers may be brought together after the jitter test has run its course or during the test to provide ongoing results.","The receiver timestamp buffer  is searched for a packet record matching the first packet record in the sender timestamp buffer . A match is found if the packet identifier sextuple (packet flow identifier quintuple plus IP ID) is the same in both packet records. If no match is found for the first sent packet record, then that packet was probably lost in transmission. In that case, the search resumes with the second sent packet record and proceeds until a match is found. The processing burden of the search is lessened by the fact that the received packet records have already been sorted into the order in which the packets were sent, that is, the order of monotonically increasing IP IDs (modulo the 64k rollover). If a match is not found within the window in the receiver timestamp buffer that contains the sent packet record, then the sent packet is assumed to have been lost in transmission.","The final step of association begins once a match has been found for a sent packet record. The receiver timestamp buffer  is searched for a match for each sent packet record that follows the first matched packet record. In this manner, each sent packet record is either matched to a received packet record or marked as lost in transmission. When the association is complete, the results are as shown in FIG. . Packet send times are associated with their receive times and lost packets are noted.","The three steps just described are illustrative only and are not intended to limit the scope of the present invention. The steps may be reordered, combined, eliminated, or replaced by other processing means. The final result of the processing, however accomplished, is the association between sent and received times for the packets.","Sending the Processed Timestamp Data to the Previously Described Jitter Analysis Tool","The result of the above processing is a data file, illustrated in , similar in content to the packet log  of FIG. . That data file can then be further processed using the same techniques described in the above sections in relation to analyzing jitter using packets generated by the jitter measurement tool itself. Specifically, the processing may proceed through the steps portrayed as items  through  of FIG.  and detailed in the flow diagram of . Just as above, clock skew and timer jumps can be corrected. Jitter and packet loss ratios are calculated and presented to the user.","In view of the many possible embodiments to which the principles of this invention may be applied, it should be recognized that the embodiments described herein with respect to the drawing figures are meant to be illustrative only and should not be taken as limiting the scope of invention. The invention may also be practiced on non-\u201cWINDOWS\u201d machines and on any kind of network, including wireless networks. Therefore, the invention as described herein contemplates all such embodiments as may come within the scope of the following claims and equivalents thereof."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["While the appended claims set forth the features of the present invention with particularity, the invention, together with its objects and advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings of which:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIGS. 6 through 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 16 and 17"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 20A"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIGS. 20B through 20E"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIGS. 21A through 21D"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 22"}]},"DETDESC":[{},{}]}
