---
title: Natural language querying with cascaded conditional random fields
abstract: A natural language query tool comprising cascaded conditional random fields (CRFs) (e.g., a linear-chain CRF and a skip-chain CRF applied sequentially) processes natural language input to produce output that can be used in database searches. For example, cascaded CRFs extract entities from natural language input that correspond to column names or column values in a database, and identify relationships between the extracted entities. A search engine can execute queries based on output from the cascaded CRFs over an inverted index of a database, which can be based on one or more materialized views of the database. Results can be sorted (e.g., according to relevance scores) and presented in a user interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09280535&OS=09280535&RS=09280535
owner: Infosys Limited
number: 09280535
owner_city: Bangalore
owner_country: IN
publication_date: 20110526
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","I. Introduction","II. Natural Language Query Tools with CRF-Based Machine Learning Models","A. Overview","B. Exemplary Systems","C. Exemplary User Interface with Query Results","D. Exemplary Techniques","E. Detailed Example","F. Exemplary Equations and Implementation Details","G. Experimental Results","III. Exemplary Computing Environment","IV. Exemplary Implementation Environment","V. Extensions and Alternatives"],"p":["Databases are useful for storing, retrieving, and organizing large amounts of information. However, database queries are typically required to be compliant with particular rules specified by the underlying database. Such requirements pose challenges to widespread adoption of database technology, especially where specialized training is required to allow ordinary users to use a database. Natural language queries are sometimes used to attempt to bridge the communication gap between users and databases.","Disclosed herein are representative embodiments of methods, apparatus, and systems for querying databases with natural language sentences using cascaded conditional random fields (CRFs). The disclosed methods, apparatus, and systems should not be construed as limiting in any way. Instead, the present disclosure is directed toward all novel and nonobvious features and aspects of the various disclosed embodiments, alone and in various combinations and subcombinations with one another. Furthermore, any features or aspects of the disclosed embodiments can be used in various combinations and subcombinations with one another. The disclosed methods, apparatus, and systems are not limited to any specific aspect or feature or combination thereof, nor do the disclosed embodiments require that any specific advantage be present or problem be solved.","In examples described herein, a natural language query tool comprising cascaded CRFs (e.g., a linear-chain CRF and a skip-chain CRF applied sequentially) processes natural language input to produce output that can be used in database searches. For example, cascaded CRFs extract entities from natural language input that correspond to column names or column values in a database, and identify relationships between the extracted entities. The natural language query tool can then form a search string based on entity information (e.g., column value information). A database query can then be executed (e.g., by a search engine). For example, a search engine can execute a query based on a search string over an inverted index of a database, which can be based on one or more materialized views of the database. When results are received, the results can be sorted (e.g., according to relevance scores) and presented in a user interface, potentially along with other information (such as suggestions for corrections or modifications to a natural language query). Described tools and techniques can be used in a wide variety of applications to provide a natural language interface for extracting data from databases.","The foregoing and other objects, features, and advantages will become more apparent from the following detailed description, which proceeds with reference to the accompanying figures.","Techniques and tools for retrieving information from data sources via natural language queries are described. For example, embodiments of described natural language query tools use multi-level conditional random fields (CRFs), referred to as cascaded CRFs. CRFs provide a probabilistic framework for labeling and segmenting sequential data, such as natural language text. In described examples, a first-level CRF is trained to identify (or extract) entities based on keywords or phrases in natural language input, such as sentences. A second-level CRF finds relationships among entities extracted in the first-level CRF. Unlike traditional CRFs, described cascaded CRFs can identify semantic relationships between entities to allow efficient labeling of natural language queries and provide high-quality search results.","The disclosed methods, apparatus, and systems should not be construed as limiting in any way. Instead, the present disclosure is directed toward all novel and nonobvious features and aspects of the various disclosed embodiments, alone and in various combinations and subcombinations with one another. Furthermore, any features or aspects of the disclosed embodiments can be used in various combinations and subcombinations with one another. The disclosed methods, apparatus, and systems are not limited to any specific aspect or feature or combination thereof, nor do the disclosed embodiments require that any one or more specific advantages be present or problems be solved.","Although the operations of some of the disclosed methods are described in a particular, sequential order for convenient presentation, it should be understood that this manner of description encompasses rearrangement, unless a particular ordering is required by specific language set forth below. For example, operations described sequentially may in some cases be rearranged or performed concurrently. Moreover, for the sake of simplicity, the attached figures may not show the various ways in which the disclosed methods, apparatus, and systems can be used in conjunction with other methods, apparatus, and systems.","The disclosed methods can be implemented using computer-executable instructions stored on one or more computer-readable media (e.g., non-transitory computer-readable media, such as one or more optical media discs, volatile memory components (e.g., DRAM or SRAM), or nonvolatile memory or storage components (e.g., hard drives)) and executed on a computer (e.g., any commercially available computer or a computer embedded in a device, such as a laptop computer, desktop computer, net book, web book, tablet computing device, smart phone, or other mobile computing device). Any of the intermediate or final data created and used during implementation of the disclosed methods or systems can also be stored on one or more computer-readable media (e.g., non-transitory computer-readable media) and are considered to be within the scope of this disclosure.","For clarity, only certain selected aspects of the software-based embodiments are described. Other details that are well known in the art are omitted. For example, it should be understood that the software-based embodiments are not limited to any specific computer language or program. Likewise, embodiments of the disclosed technology are not limited to any particular computer or type of hardware. Exemplary computing environments suitable for performing any of the disclosed software-based methods are introduced below.","The disclosed methods can also be implemented using specialized computing hardware that is configured to perform any of the disclosed methods. For example, the disclosed methods can be implemented by an integrated circuit (e.g., an application specific integrated circuit (ASIC), or programmable logic device (PLD), such as a field programmable gate array (FPGA)) specially designed to implement any of the disclosed methods (e.g., dedicated hardware configured to perform any of the disclosed embodiments).","Natural language search problems involve determining a set of labels to answer a query efficiently for a given set of search terms or keywords provided as input. The approaches to natural language search problems can be broadly classified as template-based approaches, rule\/grammar-based approaches, and machine learning approaches.","Template-based approaches typically aim to transform template elements into corresponding functional elements in a formal query language. In a typical template-based approach, a user interface (e.g., a menu-driven \u201cwizard\u201d or other user interface) prompts a user to enter information for required fields and progressively builds a corresponding query in a formal query language (e.g., SQL, sometimes referred to as Structured Query Language). However, such interfaces can become too cumbersome for large scale systems with a large grammar size and high complexity.","Rule-based approaches range from word-based regular expressions to complex grammars which use part-of-speech (POS) tagging to form rules. Queries can be directed to a particular domain or application, such as a geographic information system (GIS), or to more general database tables. In a rule-based approach that uses POS tagging, precise meanings of natural language sentences and phrases can be difficult to discern. For example, adjectives used in phrasing a sentence can be subjective (e.g., \u201csmart worker,\u201d \u201cgood shoes,\u201d \u201ccostly decorations\u201d). To allow meaningful inferences, such terms can be explicitly defined by a user and complex rules can be developed to help a system understand their meaning, but such efforts can add significant time and cost.","Grammar-based approaches are largely rules-driven. A given user's query typically is matched against a predefined set of rules, and search keywords can be translated to equivalent SQL queries based on the set of rules. But, as the language style or construct changes, it can become increasingly challenging to maintain the rules in a grammar-based approach. In addition, query translation becomes computationally expensive when evaluation is carried out over a larger set of rules.","A direct application of such approaches leads to a number of issues. It is difficult to capture semantic relationships hidden in search keywords, leading to reduced accuracy of search results. Search terms tend to be treated independently and given equal weight without considering functional dependencies that may exist between keywords. Rich sources of metadata available in the form of data constraints and data relationships are often disregarded. Additionally, such approaches tend to focus on simple query types (e.g., \u201cretrieve records of people whose job title has president in it\u201d; \u201cshow records with job titles for clerk and programmer\u201d). However, in a typical enterprise scenario, the queries can be more complex in nature. The natural language queries in an enterprise can include range queries (\u201cgive all records with max salary above $20000\u201d), logical queries, queries with more than one type (e.g., range-logical queries such as \u201cdisplay records with job title as accountant AND min salary equal to $8200\u201d), or other types of queries. Furthermore, names assigned to tables in a database may intentionally or unintentionally coincide with those given to columns in the same table or other tables. Therefore, many tools that use lexicon look-up (mainly used in rule-based approaches) fail to distinguish between column names, table names, and table contents (or values).","Machine learning approaches learn patterns from training data and can be useful in predicting data patterns, including previously unknown patterns that template-based and rules-based approaches might not be able to discover. Some statistical and machine learning natural language search techniques include statistical inference, semantic classification trees, inductive logic programming, variable Markov models and maximum entropy Markov models.","Some graph-based approaches consider all keywords in an input query and search for a closely connected set of nodes in a database that matches all keywords in the query. However, many machine learning approaches fail to consider database metadata, and fail to discover relationships among entities in a database to be searched.","Exemplary natural language query tools with conditional random field (CRF) based machine learning models are described in this section.","A CRF is a graph-based machine learning model in which hidden entities or states can be discovered using a set of observed states. For example, in the natural language search domain, observed states can be keywords, and hidden states to be discovered can be represented with tags such as part-of-speech (POS) tags, noun phrase tags, or other domain-specific tags. CRFs can use conditional probabilities to label output sequences from a given set of input (e.g., a sequence of keywords). CRF approaches can produce more accurate search results compared to, for example, Markov models.","Exemplary natural language query tools use cascaded CRFs (e.g., two CRFs applied sequentially) to extract entities from input natural language queries and accurately determine relationships between the extracted entities. As used herein, \u201cnatural language query\u201d refers to any natural language input, such as a questions or sentence, that can be used to perform a query on a data source. As used herein, \u201centity\u201d refers to a term that can be extracted and labeled (e.g., with a column name label or a column value label) in a natural language query. As used herein, \u201ccolumn\u201d refers to a set of data values (individually referred to as \u201ccolumn values\u201d) of a particular type in a database table, where each column value is associated with a database record (or \u201crow\u201d). \u201cColumns\u201d and \u201crows\u201d are not restricted to any particular orientation. For example, a column or row can be presented in a horizontal orientation, a vertical orientation, or some other orientation when displayed to a user. \u201cColumn name\u201d refers to an identifier for a column. As used herein, \u201ccolumn name label\u201d and column value label\u201d refer to labels or tags that identify terms as potentially being a match (e.g., an exact match or an approximate match) for actual column names or column values, respectively, in a database. As used herein, \u201cterm\u201d in the context of natural language queries refers to words or other elements in the natural language queries.","A first-level CRF in a series of cascaded CRFs can extract entities of interest from terms in natural language input (e.g., text input generated by a user via a user interface, speech input, or some other form of natural language input), and a second-level CRF can disambiguate meaning by identifying relationships which may exist between the entities extracted by the first-level CRF. More CRFs can be added to capture more complex relationships. Text indexing techniques and database constraints can be used to identify hidden semantic relationships present in the data. Result scoring schemes can be used to provide high quality search results.","Embodiments of the described natural language query tools can be used when querying structured data sources (e.g., relational databases, XML data sources, CSV data sources, or other structured data sources). For example, some embodiments of the described natural language query tools can be used to query structured data sources available over the Internet, such as databases associated with forms on web pages, HTML tables on web pages, web services, photo-sharing and video-sharing sites, collaborative annotation services (e.g., services that allow users to annotate web pages and share their annotations), or other data repositories. Some embodiments of the described natural language query tools also can be used when querying unstructured data sources.","Some embodiments of the described natural language query tools provide advantages over systems that simply convert natural language queries to SQL statements. For example, some embodiments of the described natural language query tools can identify semantic relationships that implicitly exist in natural language queries, allowing such tools to distinguish between same-valued or similarly-valued terms in a query that could represent values for entities in more than one place (e.g., in multiple columns of a table, or in multiple tables) in a database.","In contrast to template-based approaches, where users select options and specify parameters to build a database query, embodiments of the described natural language query tools allow free-form query input and do not require knowledge of underlying databases or query languages, allowing queries on data sources whose characteristics (e.g., metadata, schema) are not completely known or are subject to change. Embodiments of the described natural language query tools can be useful for applications such as querying dynamic web-based databases, in which tables are frequently added, modified, or deleted. Embodiments of the described natural language query tools also can provide a fast search interface for more static databases that are not updated as frequently. Embodiments of the described natural language query tools can be used in place of template-based systems in e-commerce applications that convert input into SQL statements, where changes to input fields or addition of new input fields would require changes to the e-commerce application. Embodiments of the described natural language query tools can omit translation into SQL queries with the use of inverted indexes. Inverted indexes can be used, for example, to list database records associated with different entities for fast retrieval. Embodiments of the described natural language query tools can be used in a data federation system that integrates multiple data systems into a federated database.","Embodiments of the described natural language query tools can be used by a variety of enterprises, such as e-commerce project developers, database vendors, web service providers, search engine providers, or text analytics tool providers. Described CRF-based machine learning models can be applied to several application scenarios (e.g., semantic search engines, geographic information system (GIS) applications, or human resources (HR) applications) to provide a natural language interface for extracting information using free-form text from large databases. Embodiments of the described natural language query tools can be used by users that wish to access data from a data source but have not been trained in a formal query language. For example, embodiments of the described natural language query tools can be used in a solution-finder for automotive problems hosted by an automotive company, an online sentiment-finder for products that customers are reviewing through context-based search engines, an interface at an automated information kiosk where users type or speak questions in free form, or a patent landscape analysis tool in which users enter short sentences that represent a problem statement.","CRFs in described CRF-based learning models can be trained to learn the process of extraction of entities from natural language input and identify relationships between entities, and can be adapted to changes in querying patterns by retraining the classifiers (e.g., with updated training data). Described CRF-based machine learning models use cascaded CRFs, which can learn sequential patterns and allow capturing of semantics which are inherent in a query (e.g., automatically) based on patterns learned during training.","Embodiments of the described natural language query tools can enable faster retrieval of results. For example, embodiments of the described natural language query tools can reduce search query retrieval time by using value-based indexing, which can be used to produce inverted indexes. As another example, a materialized view can help provide faster responses for frequently used queries. Materialized views are tools used in some database management systems, in which query results from a main database are cached in separate tables for later retrieval.","Described CRF-based machine learning models can be used in embodiments of the described natural language query tools to identify patterns in different types of queries, such as simple keyword matching queries, or more complex queries such as join queries, aggregate queries, range queries, range-join queries, or range-aggregate queries.","Embodiments of the described natural language query tools can provide qualified answers, which can be beneficial in situations such as approximate searching, where there is ambiguity or only partial information with respect to search criteria. Responses can be presented in ranked form using a scoring function. The scoring function can take into account factors such as keyword similarities and relationships extracted by CRFs. To support terms in natural language queries that do not exactly match with actual table and column names, embodiments of the described natural language query tools can use semantic similarity techniques (e.g., using synonyms, hypernyms, or hyponyms) to find matches and\/or relations that exist among the terms.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 1","b":["100","105","120","105","110","110","110","105","110","120","130","130","105","105","130"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 2","FIG. 2","FIG. 2"],"b":["200","200"]},"In the example shown in , as an offline activity, CRF training data  are used by CRF training routines  to train cascaded CRFs  in a natural language processing component . Cascaded CRFs  comprise a linear-chain CRF  that is used to extract entity information (e.g., possible column names and column values) from natural language input , and a skip-chain CRF  that is used to extract relationship information (e.g., mapping information that connects entities extracted by linear-chain CRF ). CRF training routines  can be used to train linear-chain CRF  and skip-chain CRF  on a training dataset having entity labels and relationship labels (e.g., with relationship labels hidden while training the entity-extracting machine learning model, and with entity labels hidden while training the relationship-extracting machine learning model). CRFs can be trained on the same training data set in a pipeline manner, thus reducing overall training data size.","Once trained, as a runtime activity, natural language processing component  receives (e.g., via a user interface designed to accept natural language input from a user) and processes natural language input . In particular, natural language input  is processed by linear-chain CRF  to identify likely column names (ColName) and column values (ColVal). Skip-chain CRF  generates mapping information that maps ColName and ColVal nodes together as a skip edge. As used herein, \u201cskip edge\u201d refers to an edge in a graph generated by a skip-chain CRF. As used herein, \u201cgraph\u201d refers to a data structure comprising nodes that are linked by edges (e.g., skip edges), indicating a pair-wise relationship between the nodes. Mapping information generated by skip-chain CRF  can include, for example, Start and End labels, Source and Target labels, or some other form of mapping information.","In the example shown in , as an offline activity an indexer  performs an indexing technique on materialized views  of a database to be searched, which produces an index  (e.g., an inverted index). Materialized views  include cached results from prior searches, and can be used to allow faster retrieval of results (e.g., for frequently searched queries). A database can be indexed using any suitable indexer, which may also provide a search interface (e.g., a programmatic interface) for the content that is indexed. For example, the indexer  can include a database crawler that scans each record in a database, as well as an inverted index generator that generates a search index.","Database metadata  includes information from the database to be searched (e.g., table names, column names, and\/or column values). As a runtime activity, database metadata  can be used by natural language processing component  to form a database query (e.g., in the form of a search string). For example, natural language processing component  can compare database metadata  with output from cascaded CRFs  (e.g., ColName and ColVal labels) to form a database query. Database metadata  also can be used for other purposes, such as to refine identification of likely column names or column values in natural language input .","As a runtime activity, a search engine  can accept a search string from natural language processing component  and execute a search over index . For example, search engine  can retrieve matching results (e.g., database records) based on keywords in the search string. Materialized views  can be updated with records retrieved in response to searches. Search engine  also can assign a default score (e.g., a percentage, an integer, or some other numeric or non-numeric indicator of relevance) for the respective results. The search results and default scores (if any) are sent to scoring aggregator , which consolidates the search results (e.g., for presentation to a user) and assigns scores or adjusts scores if default scores are provided. For example, the scoring aggregator can include a score retriever that obtains the default scores for the respective search results, and a score crediting system that gives additional credit to search results that match the entities or relationships extracted by the CRFs and provides varying weight to the nature of the matches (e.g., providing full weight to full-word matches, and less weight to approximate matches as measured by functions such as edit distance, longest common substring, WordNet matching, or stemmed matching). Suggestions and spell-checking can be performed in spell-checker\/suggestion component . For example, spell-checker\/suggestion component  can use the Metaphone phonetic algorithm to suggest similar sounding, alternative words, and can use correlation matrix memories (CMM) for distance-based comparison of terms.","In the example shown in , as a runtime activity, search results are presented in results viewer . For example, results viewer  can present sorted, qualified results (e.g., sorted by relevance). For sorting purposes, result viewer  can include a results sorter that sorts qualified results (e.g., in descending order of relevance) according to scores obtained from the scoring aggregator. Alternatively, results can be unsorted, or can be sorted at some other location in the system (e.g., in scoring aggregator ).",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 3","FIG. 3"],"b":"300"},"In the example shown in , a linear-chain CRF  in cascaded CRFs  is used to extract entity information from natural language input , and a skip-chain CRF  is used to extract relationship information (e.g., mapping information that connects entities extracted by linear-chain CRF ). For example, parts of speech (POS) tags are assigned to natural language input  by a POS tagger (not shown), which is then processed by linear-chain CRF  to identify likely column names (e.g., using ColName labels) and column values (e.g., using ColVal labels). POS tags can be useful given the observation that column names and column values are often nouns. Skip-chain CRF  generates mapping information that maps ColName and ColVal nodes together as a skip edge. Mapping information generated by skip-chain CRF  can include, for example, Start and End labels, Source and Target labels, or some other form of mapping information. The system  uses the output from linear-chain CRF  and skip-chain CRF  to determine a query type (e.g., range query, logical query, etc.) in a query type identifier . For example, query type identifier  uses heuristics to determine query type. Such heuristics can involve, for example, looking for words or phrases in natural language input  that indicate a range query or a logical query.","In the example shown in , query formulator  formulates a query to be performed on a database. In addition to information relating to query type, extracted entity information, and extracted mapping information, query formulator can use semantic analyzer , syntactic analyzer , and named entity recognition (NER) algorithms  to process the natural language input and formulate a query. Database metadata from materialized views  can be used by query formulator  to formulate the query. For example, natural language processing component query formulator  can compare database metadata with output from cascaded CRFs  (e.g., ColName and ColVal labels) to formulate a query. Alternatively, the natural language input  can be processed to formulate a query in some other way.","In the example shown in , a search engine  can accept a formulated query as input and execute a search over index  (e.g., an inverted index) created by indexer  based on materialized views . For example, search engine  can retrieve matching results (e.g., database records) based on keywords in the query. Materialized views  can be updated with records retrieved in response to searches. Search engine  also can assign a default score (e.g., a percentage, an integer, or some other numeric or non-numeric indicator of relevance) for the respective search results. The search results and default scores (if any) are sent to scoring aggregator , which consolidates the search results (e.g., for presentation to a user). For example, the scoring aggregator can include a score retriever that obtains the default scores for the respective search results, and a score crediting system that gives additional credit to search results that satisfy relationships described by the mapping information. Suggestions and spell-checking can be performed in spell-checker\/suggestion component .","In the example shown in , search results are presented in results viewer . For example, results viewer  can present sorted, qualified results. Results viewer  can include a results sorter that sorts qualified results (e.g., in descending order of relevance) according to scores obtained from the scoring aggregator . Alternatively, results can be unsorted, sorted in some other way, or sorted at some other location in the system (e.g., in scoring aggregator ).","In practice, exemplary systems described herein such as systems ,  and  can include additional system components, additional relationships between system components, and the like. The relationships shown between modules within exemplary systems described herein such as system  indicate general flows of information in the respective system; other relationships are not shown for the sake of simplicity. Depending on the implementation and the type of processing desired, modules of the system can be added, omitted, split into multiple modules, combined with other modules, and\/or replaced with like modules. Generally, the technologies described herein are generic to different operating systems or hardware and can be applied in any variety of environments to take advantage of the described features.","This section describes exemplary approaches to user interaction. Any of the described approaches can be used in a natural language query processing system, such as system ,  or .  shows an exemplary graphical user interface (GUI)  that can be used to enter a natural language query and receive ordered search results from a database  which has three tables , , . GUI  includes a query area  for entering a natural language query and a results area  in which ordered search results are shown, in descending order of relevance scores. Results area  includes 5 records from table  (\u201cJOBS\u201d). In the example shown in , the query shown in query area  is \u201cGive me all managers with SA_MAN in ID.\u201d A suggestions area  provides feedback on the query. In the example shown in , the suggestion area  includes a suggestion that the user might have been looking for information about \u201cJOB_ID\u201d because, while the string \u201cID\u201d does not match any column names in tables , , , there is a column called \u201cJOB_ID\u201d in each record in the search results. Alternatively, a user interface can have more or fewer features, or different combinations of features.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 5","FIG. 1","FIG. 2","FIG. 3"],"b":["500","100","200","300","500"]},"At , the system receives natural language input. For example, the system receives natural language text input from a user via a user interface. Alternatively, the system receives other natural language input, or receives the input in some other way. For example, natural language input can be received in the form of text sentences from a document, where the text sentences are used as a natural language query. At , the system processes the natural language input in a first CRF (e.g., a linear-chain CRF) to obtain a first output comprising a column value label and a column name label associated with entities extracted from terms in the natural language input. For example, the system extracts (or identifies) a first entity and a second entity from the natural language input, labels the first entity as a column value, and labels the second entity as a column name. At , the system processes the natural language input and the first output in a second CRF (e.g., a skip-chain CRF) to obtain second output comprising information that represents at least one relationship between the entity associated with the column value label and the entity associated with the column name label. The extracted entity associated with the column name label can correspond to (either exactly or approximately) a column in a database table, and the extracted entity associated with the column value label can correspond to (either exactly or approximately) a value in a column of the database table. The relationship can be represented as an edge between two nodes (e.g., a node associated with the column name label, and a node associated with the column value label) in a graph data structure. The information that represents the relationship can include a tag associated with one of the two nodes and a tag associated the other of the two nodes. Where the second CRF is a skip-chain CRF, the edge can be a skip-edge. Alternatively, processing of natural language input with the CRFs can result in other output (e.g., information other than column name labels and column values, such as table name information or other information relevant to a particular database).",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 6","FIG. 1","FIG. 2","FIG. 3"],"b":["600","100","200","300","600"]},"At , the system receives natural language input. At , the system processes the natural language input using cascaded CRFs comprising a linear-chain CRF and a skip-chain CRF. For example, the cascaded CRFs produce output comprising entity information (e.g., column value labels, column name labels, or other entity information) and relationship information (e.g., \u201cStart\u201d tags, \u201cEnd\u201d tags, or other relationship information). At , the system forms a database query based on the output from the cascaded CRF. For example, the system forms a search string based at least on the entity information. The database query can then be executed (e.g., by a search engine). For example, a search engine executes the query over an inverted index of a database, which can be based on one or more materialized views of the database. When results are received, the results can be sorted (e.g., according to relevance scores) and presented in a user interface, potentially along with other information (such as suggestions for corrections to a user's natural language query).",{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 7","FIG. 1","FIG. 200","FIG. 3"],"b":["700","100","200","300","700"]},"At , the system receives natural language input comprising plural terms via a user interface (e.g., a graphical user interface such as user interface  in ). At , the system assigns a part-of-speech tag to each of plural terms in natural language input. For example, the system tags nouns in the natural language input with noun tags. At , the system processes the natural language input in a linear-chain CRF to obtain a first output comprising a column value label and a column name label associated with terms in the natural language input. For example, the system can identify a term as a potential column name or column value, and label the identified term with a ColName label or a ColVal label. At , the system processes the natural language input along with the first output in a skip-chain CRF to obtain a second output comprising relationship information that links the term associated with the column value label and the term associated with the column name label. At , the system forms a search string based at least in part on the first output. For example, terms labeled as column values in the first output can be concatenated to form a search string. At , the system sends the search string to a search engine. The search engine can be any suitable general or special-purpose search engine, such as the Apache Lucene search engine, available from the Apache Software Foundation at http:\/\/lucene.apache.org. At , the system receives database search results from the search engine based at least in part on the search string. At , the system puts the database search results into order (e.g., based on respective relevance scores of the search results). At , the system presents the ordered database search results in the user interface.","Other steps not shown in exemplary techniques , ,  also can be performed prior to, subsequent to, or concurrently with exemplary techniques , , . For example, training steps and database indexing steps can be performed prior to processing natural language input with cascaded CRFs or performing a search over a database.","Names assigned to tables in a database may intentionally or unintentionally coincide with those given to columns in the same table or other tables. Therefore, many tools that use lexicon look-up (e.g., rule-based approaches) fail to distinguish between column names, table names, and table contents (or values).","This section describes an exemplary technique that uses machine learning models to help distinguish between column names, table names, and table contents, among other potential benefits. This exemplary technique takes a natural language query (also referred to as an \u201cinstance\u201d) as input, and produces a set of query results as output. The output set of query results can be referred to as \u201cmatched query results\u201d or \u201csearch results.\u201d Matches need not be exact, and may instead be approximate. This exemplary technique can be used, for example, in a database management system having a natural language search interface. A system such as the system  shown in , the system  shown in , the system  shown in , or other system can perform this exemplary technique.","This exemplary technique can be described as having two stages. The first stage involves offline activities, such as training and deploying CRF-based machine learning models, which can then be used in the second stage. The second stage involves runtime activities, such as accepting natural language input (e.g., from a user entering a query) and providing results in response to the input using models that were trained and deployed in the first stage. The two stages need not be performed together, and can be performed by one or more computing devices.","This exemplary technique uses a CRF model in which two CRFs are applied sequentially to a sequence of words in a user query from which functional relationships can be extracted. In this exemplary technique, a first CRF identifies (or extracts) entities as column name and column value entities based on context, and a second CRF identifies relationships between the extracted entities.","A CRF model can be built using sample data for which its corresponding formal language query is known. Formal languages such as SQL, Prolog, and XML can be used to find and tag functional relationships among entities appearing in natural language queries for training a CRF model. In this exemplary technique, a first CRF (CrfS) is trained to learn the natural language style (e.g., pattern and context) of referring to column names and column values. For example, CrfS is trained to label each instance with state labels to identify column names (ColName) and column values (ColVal) from a natural language query. A third state label (Other) is used to label words that are not ColName or ColVal. The second CRF (CrfS) is trained to take as input the instance (that is, the natural language query) along with its label sequence (output from CrfS), predict two nodes which can be connected using a skip-edge, and label the nodes with \u201cStart\u201d (or \u201cSource\u201d) and End (or \u201cTarget\u201d) tags.","A CRF model can use clique templates to find subsets of nodes (or states) satisfying a given constraint (e.g., terms in a natural language query that represent a probable column name and a corresponding column value) that can be connected with an edge to form a clique. Such edges can be used to capture relations among terms in natural langue input. Unlike other \u201ctemplate-based\u201d approaches to database queries, this exemplary technique uses clique templates to represent a set of relationship signatures, which the CRF is trained to learn and use in order to label nodes. Exemplary clique templates include bi-gram clique templates, skip-chain clique templates, and mapping label clique templates. Bi-gram clique templates capture relationships between the same type of nodes (e.g., either observed states or hidden states) present consecutively in the sequence. Skip-chain clique templates capture relationships between states that are functionally related but are \u201cfar apart\u201d (e.g., not consecutive) in the state sequence. Mapping label clique templates are used to capture relationships between multiple labeling schema (e.g., between ColVal\/ColName\/Oth labels and Start\/End labels) if available at observed states in a sequence.","In this exemplary technique, CrfS is a linear-chain CRF that captures sequence information with a bi-gram clique template available, for example, in the Mallet package. See McCallum, \u201cMALLET: A Machine Learning for Language Toolkit,\u201d available at http:\/\/mallet.cs.umass.edu. In this context, bigrams are groups of two letters that are used for statistical analysis of text. Bi-grams can be used to help provide a conditional probability of a word occurring in text. In this exemplary technique, CrfS is a skip-chain CRF that uses a skip-chain clique template along with a bi-gram clique template, and skip edges connect ColName state labels with a corresponding ColVal state label.","Consider the following scenario for training a linear-chain CRF on a geographic information database. For the natural language query \u201cGive me the cities in Virginia,\u201d a formal query can be written in a query language that corresponds to the geographic information database (e.g., \u201cfor $c in document (\u201cgeobase.xml\u201d)\/\/city where $c\/state=\u201cVirginia\u201d return <result> {$c\/text( )}<\/result>\u201d), and part-of-speech (POS) tags and labels can then be assigned to words in the natural language query (e.g., \u201cgive VB|OTHER; me PRP|OTHER; the DT|OTHER; cities NNS|SV:ColName; in IN|OTHER; Virginia NNP|DM:ColVal\u201d). Or, consider the following scenario for training a CRF on a jobs information database. For the natural language query \u201cWhat jobs are there for web developer who knows \u2018C++\u2019?\u201d a formal query can be written in a query language that corresponds to the jobs information database (e.g., \u201cfor $j in document (\u201cjobsdata.xml\u201d)\/\/job where $j\/title=\u201cweb developer\u201d and $j\/language=\u201cCPP\u201d return $j\u201d). POS tags and labels can then be assigned to words in the natural language query (e.g., \u201cwhat WP|OTHER; jobs NNS|SV:ColName; are VBP|OTHER; there EX|OTHER; for IN|OTHER; web NN|OTHER; developer NN|LCS:web developer; who WP|OTHER; know VB|OTHER; C NN|OTHER; +SYM|OTHER; +SYM|OTHER; ?.|OTHER\u201d).","Embodiments of the described technologies can use vector representation of an instance (e.g., a document, text sentence, or user query) to be classified. Such vectors can be referred to as feature vectors, and can be presented by the equation F=[f, f, . . . ], where fis a feature that addresses a particular criterion to aid classification algorithms in distinguishing instances belonging to different classes. Many different functional routines can be used for computing values of particular feature vectors with respect to a current instance under consideration. Therefore, F also can be defined as F=[f(x), f(x), . . . ], where x is a current instance of a natural language query as a state sequence for which the feature vector is being computed. Several feature types can be used to represent a single instance. One common feature type is bag-of-words, where each word appearing in a text becomes a Boolean feature that indicates presence or absence of the word in a current instance. Thus, a bag-of-words model represents a text as an unordered collection of words. Other feature types include domain-specific features and part-of-speech (POS) features.","In this exemplary technique, CrfS uses conventional bag-of-words features along with POS tags, while CrfS uses tags predicted by CrfS along with the features used for CrfS. By using skip-edges, the model in CrfS aims to find additional edges connecting ColName and ColVal nodes. The skip-edge does not impose any constraints on the order of the tags for the nodes it is connecting: the skip-edge indicates a possible relationship between the nodes, but does not specify an ordering of the nodes. The Start node can be either a column name node or a column value node, and the End node can be either a column name node or a column value node. States that are not Start or End states can be labeled as Other.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 8","FIG. 8","FIG. 1","FIG. 2","FIG. 3","FIG. 8","FIG. 9","FIG. 8","FIG. 8","FIG. 8","FIG. 8","FIG. 8","FIG. 8"],"b":["802","802","100","200","300","802","804","806","804","804","802","806","820","822","820","822","810","810","830","802","832","802"]},{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 9","FIG. 8","FIG. 9","FIG. 1","FIG. 2","FIG. 3","FIG. 9","FIG. 9","FIG. 9","FIG. 9","FIG. 9","FIG. 9","FIG. 9","FIG. 9","FIGS. 8 and 9"],"b":["902","802","902","100","200","300","902","904","906","904","902","906","920","922","910","930","902","932","902"]},"In this exemplary technique, error minimization also can be performed. Because there are more likely to be fewer skip-chain labels (e.g., \u201cStart\u201d and \u201cEnd\u201d labels) as compared to linear-chain labels (e.g., ColName and ColVal labels), an error minimization function can treat skip-chain labeling with less importance compared to linear-chain labeling.","As explained above, this exemplary technique can be divided into offline activities and runtime activities. Offline activities include indexing the database to be searched and building CRF Models using training data. Runtime activities include using CRF models to tag a natural language query representing a functional relationship among entities. These functional relationships are used to credit and alter scores of search hits from the index, which match these relationships.","In this exemplary technique, at runtime, words labeled as column value (ColVal) in the output of CrfS are concatenated to form a search string (e.g., individual words separated by spaces) according to a bag-of-words model. That is, words labeled as column values can be concatenated in the search string without regard to sentence syntax or semantics. This search string is queried over an index of the database to retrieve search hits. Search hits and corresponding default scores are obtained from a full-text search engine (e.g., Apache Lucene or any other suitable search engine) based on string comparison. Among these search hits, the instances whose column values match with those identified using CrfS are credited with an additional CrfS parametric score depending on the nature of the match. Scores for entities whose column names and column value pairs match the pairs in the output from CrfS (which tries to label the possible pairs with tags Start and End) are credited even more, moving such hits nearer the top in a sorted search list. While searching for matched entities during these two steps, different weights are assigned for matching instances based on a match type. For example, in decreasing order of assigned weights, possible match types include full-word match, stemmed match, substring match, LCS (longest common sub-string) match, WordNet-based match, and n-gram character match. Scores obtained for search hits can be used in sorting to obtain ordered search results considering the functional relationships (i.e. the potential relationship between ColName and ColVal entities after application of CrfS).","In addition to simple queries (e.g., term matching), this exemplary technique can accommodate other query types, such as logical queries, range queries and join queries. This exemplary technique also can accommodate queries that have more than one query type (e.g., range-join queries) and nested queries. Further training of the machine learning models can be performed (e.g., with training data specific to the desired type of query, such as a range query), or domain-specific heuristic rules can be used. Heuristic rules can be used, for example, in cases where the availability of CRF training data is limited for desired query types.","For example, to identify and formulate range queries, heuristic rules or a classifier such as a support vector machine (SVM) can be used to capture patterns present in natural language queries such as \u201csalary greater than $8000\u201d or \u201cemployer ID less than 2000.\u201d An exemplary heuristic rule would be to look for a pattern such as \u201c<ColVal Entity><Range Query Indicator><Numeric Value>,\u201d where <Range Query Indicator> can be a word or phrase such as \u201cabove,\u201d \u201cbelow,\u201d \u201cnot more than,\u201d \u201cless than,\u201d \u201cgreater than,\u201d \u201cfewer than,\u201d \u201cequal to,\u201d \u201cequals,\u201d or other such terms than can be used for quantitative comparisons.","As another example, to identify and formulate logical queries, an exemplary heuristic rule would be to look for logical operators (also referred to as logical connectives), (e.g., words such as \u201cAND,\u201d \u201cOR,\u201d or \u201cALSO\u201d) in the natural language input. A processing step to flatten logical queries (e.g., reformulating queries such as \u201cshow all records with job title as accountant AND min salary equal to 8200\u201d into sub-queries such as \u201cshow all records with job title as accountant\u201d and \u201cshow all records with min salary equal to 8200\u201d) can be used. After flattening, the sub-queries can be treated as independent queries and results can be merged depending on the logical operator (e.g., \u201cAND\u201d) connecting the sub-queries.","As another example, to identify and formulate join queries, relevant database tables can be identified in the natural language input, and materialized views can be created from the respective tables in the database. These materialized views then can be used for performing the join query.","This section describes Equations 1-13 shown in  and exemplary implementation details shown in . The equations relate to embodiments of described natural language query tools with cascaded CRFs, and can be used to describe, for example, aspects of the exemplary technique described above. For example, the equations described in this section describe conditional probabilities and accuracy for CrfS and CrfS. The exemplary implementation details (e.g., techniques  and , shown in , respectively) relate to techniques that can be performed by embodiments of described natural language query tools with cascaded CRFs. Alternatively, a natural language query tool can use CRFs that operate according to other models.","CRFs can use conditional probabilities to estimate a probable hidden state sequence {y, y, . . . y} from an observed state sequence {x, x, . . . x}. More formally, if P(y, x) is the joint probability of a hidden label sequence with respect to an observed state sequence, the conditional probability P(y|x) can be represented as shown in Equation 1 in , where the denominator is a normalization constant that measures joint probability of an observed state sequence with respect to all possible hidden state sequences. The conditional probability can be estimated during training where a set of training data is chosen (e.g., using cross-validation techniques) for learning the parameters of Equation 1.","A user query can be represented as an undirected graph model, with observed states corresponding directly to search key words of the user query. The graph can be augmented with labels using the CRF model. Edges can be created using clique templates which model the process of finding subsets of nodes satisfying a given constraint that can be connected to form a clique, c. For example, nodes that represent a probable column name and a corresponding column value pair can be connected with an edge. A clique template is a set of factors and their corresponding parameters which help in creating a graph out of available data instances. If \u03a6denotes potential functions applicable to elements at position t in a state sequence, and if ydenotes an imaginary initial state to capture start state probabilities, the clique template for a linear-chain CRF can be expressed as shown in Equation 2.","Based on matching criteria, clique templates can be divided into two categories: local clique templates and global clique templates. Local clique templates are those in which the number of hidden states in the clique is one. Local clique templates can be used to capture the relationship between entities observed in the input query and the label. Global clique templates are those in which the number of hidden states in the clique are greater than one. Global clique templates capture the relationship between multiple entities from the input query, which can be far apart in the sequence. If C is a set of clique templates, and \u03a6denotes the factors corresponding to clique template C, the conditional probability in Equation 1 in terms of clique templates can be written as shown in Equation 3, where, yand xare the states within the sequence to which the clique templates are applicable. Z(x), which can be referred to as a partition function, is the sum of scores of all the possible hidden state sequences for the observed state sequence x.","If \u03b8represents the set of parameters associated with the clique C(vector of \u03bb), K represents the total number of templates, and vector |f| represents features, then \u03a6which indicates a clique factor applicable for clique Ccan be expressed as shown in Equation 4. Parameters \u03b8can be learned using inference algorithms during training. Equation 5 is a modified version of Equation 4 to represent clique factors between labeling sequences, land l.","Clique factors are functions which represent a clique template. For example, to represent a linear-chain template according to the exemplary technique described above, clique factors which capture the ordered sequence of labels (e.g., Oth, ColVal and ColName labels) can be used. Values of clique factors (e.g., values of the functions obtained at positions in the graph) can be combined (e.g., by multiplying them) to obtain a conditional probability value. For example, for CrfS, the conditional probability (P(y|x)) can be calculated as shown in Equation 3 (with the linear-chain clique factors C shown in Equation 2), and also can be written as shown in Equation 6, where Z(x) is a normalization constant which varies from one observed state sequence (x) to the other, as shown in Equation 7. Equation 6 also can be referred to as a linear-chain inference function.","If T is the length of the sequence, \u03a6 and \u03c8 are clique factors for linear-chain and skip-chain CRFs, and yrepresents an imaginary start state, the conditional probability (P(y|x)) for CrfS can be stated as shown in Equation 8, where \u03a6(y, y, x) gives the start state probabilities. In Equation 8, the clique factors corresponding to linear-chain are given as \u03a6, while the clique factors corresponding to skip-chain are given by the product terms with subscripts u and v (e.g., \u03c8). The individual factors can in turn be computed as shown in Equations 9 and 10.","In Equation 9, \u03bbcorresponds to linear-chain (CrfS) parameters learned over training data, and fcorresponds to the potential inferred from state t\u22121 to state t at time stamp t. In Equation 10, \u03bbcorresponds to skip-chain (CrfS) parameters, and the potential f(y, y, x, u, v) has significant value only when state u is either ColName or ColVal and v represents its corresponding ColVal or ColName, respectively. If P(y|x) and P(y|x) represent linear-chain and skip-chain conditional probabilities, respectively, obtained for input state sequence x, the combined accuracy P(y|x) of the cascaded CRF model in the exemplary technique described above can be written as shown in Equation 11. Equation 11 combines both linear-chain (P) and skip-chain (P) functions, and can be referred to as a cascaded CRF inference function.","In Equation 12, IndexerScoredenotes a search result score obtained for a particular search hit. For example, in a system that uses the Apache Lucene search engine, IndexerScorecan represent a score provided by the Lucene scoring formula. However, other scoring formulas (e.g., scoring formulas used by other search engines) also can be used. The altered score which includes credit for a match in the functional relationship in that search hit can be represented as shown in Equation 12, where Wrepresents a weight (also referred to as a reward weight) for a result (e.g., a database record, or row) that matches entity information produced by CrfS (e.g., a term with a ColVal label matches a column value in the result, or a term with a ColName label matches a column name in the result), and where Wrepresents a weight for a result that matches relationship information produced by CrfS (e.g., a term with a ColVal label mapped to a term with a ColName label matches a column value in the result from a corresponding column).",{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 11","b":["1100","1100","1","1","2","3","4","5","2","6","7","8","9","10","13"],"sub":["S1 ","S2 ","S1 ","S2 "]},{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 12","b":["1200","1200","1","1100","2","3","4","8","10","5","6","7","9","13"],"sub":["CrfS1 ","CrfS2 "]},"The accuracy of a CRF model built with training data represented as set {x} can be represented as shown in Equation 13, where {circumflex over (x)}is a bag-of-words representation with ColName and ColVal extracted and terms labeled Start and End, and where J({circumflex over (x)}, I) represents the similarity measure of the words in {circumflex over (x)} with meta information I from the database (e.g., actual names given to tables and columns).","A naming convention that is followed in naming columns and tables of the database can have an effect on the final accuracy. From Equation 13 it can be inferred that as similarity among column names and table names increases, the accuracy of that particular database decreases. In the exemplary technique, the scores that can be used for sorting results based on relevance to a natural language query (x) can be a product of accuracies obtained in CrfS, CrfS, and the similarity of words in x labeled as ColName and ColVal with the actual column names and values from the database. The final term in the product in Equation 13 penalizes poor database naming conventions, which can make differentiating column names, table names and their values nearly impossible. For example, consider a naming convention for columns which host employee names and their respective departments. A database that names these columns \u201cEmployee Name\u201d and \u201cEmployee Dept Name,\u201d respectively, can lead to less accurate results compared to a database that names these columns \u201cEmployee Name\u201d and \u201cDepartment,\u201d respectively. Hence, the normalization constant can be important during database design time. A database with a lower value in the denominator in Equation 13 will yield more accurate (or confident) results. Because the CRF model in the exemplary technique described above is built using part-of-speech (POS) as one of the features, and because column names and column values are often nouns, it can be helpful to choose nouns for naming tables and columns in a database. This helps in obtaining good accuracy.","This section describes experimental results relating to aspects of the exemplary technique described above. Two datasets (JobQuery and GeoQuery, available from the University of Texas) are used for experimentation. These datasets contain natural language queries along with equivalent formal query language statements. From the formal language in these instances, column names and column values are identified for use in manual labeling. The code base was written in Java using application programming interfaces (APIs) including the Mallet API from the Mallet package and another API to obtain POS tags for input terms. In these exemplary experiments, cascaded CRFs are used to capture relationships without differentiating the order of tags (e.g., Start and End tags) that appear as end points of the entities for which a skip edge is created. The databases used in these exemplary experiments is indexed using Apache Lucene.","The exemplary experiments described in this section were conducted by varying parameters such as training dataset, testing dataset, labeling, and templates used, and using a 5-fold cross validation technique. Table 1 shows names of CRFs used in experiments described in this section, with their corresponding meanings.",{"@attributes":{"id":"p-0102","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Names of CRFs used in experiments, with corresponding meanings."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"Training","Testing",{},{}]},{"entry":[{},"CRF Name","data","data","Stage","Template"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]},{"entry":[{},"TATAS2B","All","All","S2","Bi-gram"]},{"entry":[{},"TATAS2S","All","All","S2","Skip-chain"]},{"entry":[{},"TGTGS2B","GeoQuery","GeoQuery","S2","Bi-gram"]},{"entry":[{},"TGTGS2S","GeoQuery","GeoQuery","S2","Skip-chain"]},{"entry":[{},"TJTJS2B","JobQuery","JobQuery","S2","Bi-gram"]},{"entry":[{},"TJTJS2S","JobQuery","JobQuery","S2","Skip-chain"]},{"entry":[{},"TATAS2BM","All","All","S2","Bi-gram,"]},{"entry":[{},{},{},{},{},"Mapping"]},{"entry":[{},"TATAS2BMS","All","All","S2","Bi-gram,"]},{"entry":[{},{},{},{},{},"Mapping,"]},{"entry":[{},{},{},{},{},"Skip-chain"]},{"entry":[{},"TATAS2B","All","All","S2","Bi-gram"]},{"entry":[{},"TATAS2S","All","All","S2","Skip-chain"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]}]}}]}}},"In Table 1, \u201cTraining Data\u201d and \u201cTesting Data\u201d indicate whether the JobQuery dataset, the GeoQuery dataset, or both datasets (\u201cAll\u201d) are used during training and testing, respectively. \u201cStage\u201d indicates that all the CRFs in the table are used in stage S, which involves labeling with Start, End and Other tags. \u201cTemplate\u201d indicates the template that is used for labeling (e.g., bi-gram, skip-chain, or mapping). Implicitly, skip-chain templates can include hi-gram templates.","Tables 2 and 3, below, show results of two sets of experiments. In Tables 2 and 3, \u201cP\u201d indicates a precision score (a fraction of results that are relevant to the search), \u201cR\u201d indicates a recall score (a fraction of relevant results that were successfully retrieved), and \u201cFM\u201d indicates the F-measure, which combines precision and recall scores using a harmonic mean that gives equal weights to precision and recall.","A first set of experiments compared a skip-chain CRF with a near-chain CRF. Results of the first set of experiments are shown in Table 2,",{"@attributes":{"id":"p-0106","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Results from experiments comparing skip-chain CRF with linear-chain"},{"entry":"CRF."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"49pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CRF",{},{},{},"Training","Testing"]},{"entry":["Name","P","R","FM","Time (sec)","Time (sec)"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"6","colwidth":"49pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["TATAS2B",".889",".743",".810","214","7"]},{"entry":["TATAS2S",".917",".763",".833","366","7"]},{"entry":["TGTGS2B",".951",".817",".879","94","3"]},{"entry":["TGTGS2S",".960",".817",".883","101","3"]},{"entry":["TJTJS2B",".798",".634",".707","113","4"]},{"entry":["TJTJS2S",".827",".723",".771","220","5"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},"In the first set of experiments, the CRF versions use tagged training data for CrfS in place of tagged data that would otherwise come from CrfS: ColName and ColVal entities are identified in the training data with a formal database language equivalent of natural language queries corresponding to the instances in the dataset. The first set of experiments use the GeoQuery dataset, the JobQuery dataset, and a combination of both datasets.  shows a chart  of the results shown in Table 2. The solid bars in  (numbered , , and ) indicate the linear-chain versions and the patterned bars (numbered ,  and ) indicate the skip-chain versions. The sets of bars (, ), (, ), and (, ) give the experimental results for the combined GeoQuery and JobQuery datasets, the GeoQuery dataset alone, and the JobQuery dataset alone, respectively. The skip-chain version provides better quality results than its respective linear chain version. The precision is found to be over 79 percent for all of the test cases studied in the examples shown in Table 2. However, recall is found to be low for a few test cases, signifying higher false negatives. Table 2 also shows running times as well as the quality of search results. The skip-chain versions are observed to take more training and testing time than the linear-chain versions.","A second set of experiments compared cascaded CRFs with dynamic CRFs (DCRF). DCRFs are another form of CRF that can be used to label natural language input. Results of the second set of experiments are shown in Table 3.",{"@attributes":{"id":"p-0109","num":"0108"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Results from experiments comparing cascaded CRFs with"},{"entry":"dynamic CRF (DCRF)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},{},{},"Training","Testing"]},{"entry":["Type","CRF Name","P","R","FM","Time (sec)","Time (sec)"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["DCRF","TATAS2BM",".885",".688",".775","1681","42"]},{"entry":["DCRF","TATAS2BMS",".887",".684",".773","2047","51"]},{"entry":["CCRF","TATAS2B",".897",".632",".741","228","7"]},{"entry":["CCRF","TATAS2S",".901",".733",".808","301","7"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]}}]}}},"In the second set of experiments, training and testing of the cascaded CRFs and the DCRF were repeated with linear-chain (bi-gram template) and skip-chain clique templates for CrfS and a second layer of the DCRF, respectively. For cascaded CRFs, linear-chain CrfS is used for labeling ColName and ColVal, which is given as input to CrfS. The performance of the skip-chain version of the cascaded CRFs over DCRF is also found to be better both on running times as well as quality of search results. As shown in Table 3, capturing additional functional relationships with the help of skip-edges results in improved accuracy. In Table 3, it can be noted that by adding skip edges to DCRF, we observe an increase in precision (with slight decrease in recall). The increase in precision is observed to be quite small due to the limited availability of skip edges compared to linear chain edges for the studied datasets. More can be performed on other datasets to assess usefulness of skip chains for DCRF.  shows a chart  of the results shown in Table 3. Bars labeled  and  show cascaded CRF results, and bars labeled  and  show DCRF results.","A third set of experiments assessed the effect of training dataset size on accuracy of search results. Increasing training data size can lead to higher training time; training data size can be adjusted to improve results. Results of the third set of experiments are shown in charts  and  in . Charts  and  show effects on accuracy of training data size (e.g., fraction of training data) with respect to the GeoQuery dataset and JobQuery dataset, respectively (e.g., the effect of training data size on precision, recall and F-measure). The trend in charts  and  shows that good performance is obtained with nearly 60 percent and 35 percent of training data for GeoQuery and JobQuery datasets, respectively.","A fourth set of experiments compared ordered search results retrieved using the Lucene index with ordered scores obtained after taking into consideration the CRF scores, as shown in Table 4, below.",{"@attributes":{"id":"p-0113","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Comparison of Lucene scores with CRF-based scores"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CRF-based",{},{},{}]},{"entry":["Lucene score","score","Job Id","Job Title","Department"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0.07179135","0.19599556","SA ACCOUNT","Accountant","Sales"]},{"entry":["0.08040842","0.19185546","SA MAN","Manager","Sales"]},{"entry":["0.20925795","0.10462897","AC MGR","Accounting","Accounts"]},{"entry":[{},{},{},"Manager"]},{"entry":["0.07179135","0.0878743","FI ACCOUNT","Accountant","Finance"]},{"entry":["0.06497328","0.068382315","AC","Public","Accounts"]},{"entry":[{},{},"ACCOUNT","Accountant"]},{"entry":["0.03965569","0.019827846","FI MGR","Finance","Finance"]},{"entry":[{},{},{},"Manager"]},{"entry":["0.03965569","0.019827846","ST MAN","Stock","Stocks"]},{"entry":[{},{},{},"Manager"]},{"entry":["0.03965569","0.019827846","PU MAN","Purchasing","Purchase"]},{"entry":[{},{},{},"Manager"]},{"entry":["0.03965569","0.019827846","MK MAN","Marketing","Marketing"]},{"entry":[{},{},{},"Manager"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"In Table 4, in calculating the CRF-based scores, the CRFs used for CrfS and CrfS are linear-chain and skip-chain CRFs, respectively. The underlying relational database on which the experiments are carried out is a sample employee database available from Oracle Corporation. The sample employee database has three tables (Departments, Employees and Jobs). A sample query (\u201clist all search results for accountants and managers from sales department\u201d) is executed on the Jobs table. As shown in Table 4, Lucene gave a maximum score for the record with Job Title=\u201cAccounting Manager\u201d because there is some matching with words like \u201caccountants\u201d and \u201cmanagers\u201d in the sample query. The CRF-based scores reflect the interpretation by the CRF-based model that the search is for accountants and managers who are working in the sales department. In the CRF-based scores, the records with Department=\u201cSales\u201d are given extra credit over other matches. \u201cManager\u201d and \u201cAccountant\u201d in the sales department are scored by the CRF-based model as the top two results.","In order to evaluate ranking efficiency, the order of results generated by an exemplary cascaded CRF model described herein was compared with a manually tagged evaluation dataset for a defined set of natural language queries. The manually tagged evaluation dataset has 20 natural language questions each in evaluation datasets for simple queries, logical queries and range queries, with corresponding desired result orders. Spearman's rank correlation coefficient is used to give a correlation between a manually assigned ranking order and the ranking order predicted by the exemplary cascaded CRF.  shows a chart  with the X-axis showing three points corresponding to range, logical and simple queries, and with Spearman's rank correlation coefficient score on the Y-axis.",{"@attributes":{"id":"p-0116","num":"0115"},"figref":"FIG. 18","b":["1800","1800"]},"With reference to , the computing environment  includes at least one processing unit  coupled to memory . In , this basic configuration  is included within a dashed line. The processing unit  executes computer-executable instructions. In a multi-processing system, multiple processing units execute computer-executable instructions to increase processing power. The memory  may be non-transitory memory, such as volatile memory (e.g., registers, cache, RAM), non-volatile memory (e.g., ROM, EEPROM, flash memory, etc.), or some combination of the two. The memory  can store software  implementing any of the technologies described herein.","A computing environment may have additional features. For example, the computing environment  includes storage , one or more input devices , one or more output devices , and one or more communication connections . An interconnection mechanism (not shown) such as a bus, controller, or network interconnects the components of the computing environment . Typically, operating system software (not shown) provides an operating environment for other software executing in the computing environment , and coordinates activities of the components of the computing environment .","The storage  may be removable or non-removable, and includes magnetic disks, magnetic tapes or cassettes, CD-ROMs, CD-RWs, DVDs, or any other non-transitory computer-readable media which can be used to store information and which can be accessed within the computing environment . The storage  can store software  containing instructions for any of the technologies described herein.","The input device(s)  may be a touch input device such as a keyboard, touchscreen, mouse, pen, or trackball, a voice input device, a scanning device, or another device that provides input to the computing environment . The output device(s)  may be a display, printer, speaker, CD- or DVD-writer, or another device that provides output from the computing environment . Some input\/output devices, such as a touchscreen, may include both input and output functionality.","The communication connection(s)  enable communication over a communication mechanism to another computing entity. The communication mechanism conveys information such as computer-executable instructions, audio\/video or other information, or other data. By way of example, and not limitation, communication mechanisms include wired or wireless techniques implemented with an electrical, optical, RF, infrared, acoustic, or other carrier.","The techniques herein can be described in the general context of computer-executable instructions, such as those included in program modules, being executed in a computing environment on a target real or virtual processor. Generally, program modules include routines, programs, libraries, objects, classes, components, data structures, etc., that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or split between program modules as desired in various embodiments. Computer-executable instructions for program modules may be executed within a local or distributed computing environment.","Any of the storing actions described herein can be implemented by storing in one or more computer-readable media (e.g., non-transitory computer-readable storage media or other tangible media). Any of the things described as stored can be stored in one or more computer-readable media (e.g., computer-readable storage media or other tangible media).","Any of the methods described herein can be implemented by computer-executable instructions in (e.g., encoded on) one or more computer-readable media (e.g., non-transitory computer-readable storage media or other tangible media). Such instructions can cause a computer to perform the method. The technologies described herein can be implemented in a variety of programming languages.","Any of the methods described herein can be implemented by computer-executable instructions stored in one or more non-transitory computer-readable storage devices (e.g., memory, CD-ROM, CD-RW, DVD, or the like). Such instructions can cause a computer to perform the method.",{"@attributes":{"id":"p-0126","num":"0125"},"figref":"FIG. 19","b":"1900"},"In example environment , various types of services (e.g., computing services , which can include any of the methods described herein) are provided by a cloud . For example, the cloud  can comprise a collection of computing devices, which may be located centrally or distributed, that provide cloud-based services to various types of users and devices connected via a network such as the Internet. The cloud computing environment  can be used in different ways to accomplish computing tasks. For example, with reference to the described techniques and tools, some tasks, such as processing user input and presenting a user interface, can be performed on a local computing device, while other tasks, such as storage of data to be used in subsequent processing, can be performed elsewhere in the cloud.","In example environment , the cloud  provides services for connected devices with a variety of screen capabilities A-N. Connected device A represents a device with a mid-sized screen. For example, connected device A could be a personal computer such as desktop computer, laptop, notebook, netbook, or the like. Connected device  represents a device with a small-sized screen. For example, connected device B could be a mobile phone, smart phone, personal digital assistant, tablet computer, and the like. Connected device N represents a device with a large screen. For example, connected device N could be a television (e.g., a smart television) or another device connected to a television or projector screen (e.g., a set-top box or gaming console).","A variety of services can be provided by the cloud  through one or more service providers (not shown). For example, the cloud  can provide services related to mobile computing to one or more of the various connected devices A-N. Cloud services can be customized to the screen size, display capability, or other functionality of the particular connected device (e.g., connected devices A-N). For example, cloud services can be customized for mobile devices by taking into account the screen size, input devices, and communication bandwidth limitations typically associated with mobile devices.","Various alternatives to the examples described herein are possible. For example, techniques described with reference to flowchart diagrams can be altered by changing the ordering of stages shown in the flowcharts, by repeating or omitting certain stages, etc. As another example, some stages of described exemplary techniques can be modified. For example, in a natural language query tool that uses a cascaded CRF-based machine learning model, individual CRFs in the cascaded CRF model can be implemented as skip-chain, linear-chain or other varieties of CRFs.","The various examples described herein can be used in combination or independently. Technology described herein can be used in a computer system with software, hardware, or a combination of software and hardware.","Having described and illustrated the principles of our invention with reference to described embodiments, it will be recognized that the described embodiments can be modified in arrangement and detail without departing from such principles. It should be understood that the programs, processes, or methods described herein are not related or limited to any particular type of computing environment, unless indicated otherwise. Various types of general purpose or specialized computing environments may be used with or perform operations in accordance with the teachings described herein. Elements of the described embodiments shown in software may be implemented in hardware and vice versa.","In view of the many possible embodiments to which the principles of our invention may be applied, we claim as our invention all such embodiments as may come within the scope and spirit of the following claims and equivalents thereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 5","FIG. 6","FIG. 7"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 8","FIG. 9"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 11","FIG. 12"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 19"}]},"DETDESC":[{},{}]}
