---
title: Preservation of intent of a volume creator with a logical volume
abstract: A method, system, and computer program product for preserving the intent of a logical volume creator with the logical volume. The creator of a logical volume defines certain characteristics of that logical volume. In response to the user's requirements, the system explores the possibilities for providing the characteristics in the existing storage environment. The system then implements the logical volume and stores the intent, along with a corresponding set of rules for configuring the logical volume, with the logical volume. As a result, volume management operations like resizing the volume and evacuating data from the volume use the rules to preserve the intent of the creator. By ensuring that the logical volume consistently conforms to rules fulfilling the original intent, a consistent level of availability of the logical volume can be achieved to fulfill contractual availability requirements for storage service level agreements.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07143259&OS=07143259&RS=07143259
owner: Veritas Operating Corporation
number: 07143259
owner_city: Mountain View
owner_country: US
publication_date: 20021220
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","INTRODUCTION","OTHER EMBODIMENTS "],"p":["This application relates to co-pending application Ser. No. 10\/327,380, filed on same day herewith, entitled \u201cDevelopment Of A Detailed Logical Volume Configuration From High-Level User Requirements\u201d and naming Chirag Deepak Dalal, Vaijayanti Rakshit Bharadwaj, Pradip Madhukar Kulkarni, Ronald S. Karr, and John A. Colgrove as inventors, the application being incorporated herein by reference in its entirety.","This application relates to co-pending application Ser. No. 10\/325,418, filed on same day herewith, entitled \u201cAdaptive Implementation Of Requested Capabilities For A Logical Volume\u201d and naming Chirag Deepak Dalal, Vaijayanti Rakshit Bharadwaj, Pradip Madhukar Kulkarni, and Ronald S. Karr as inventors, the application being incorporated herein by reference in its entirety.","This application relates to co-pending application Ser. No. 10\/327,558, filed on same day herewith, entitled \u201cLanguage For Expressing Storage Allocation Requirements\u201d and naming Chirag Deepak Dalal, Vaijayanti Rakshit Bharadwaj, Pradip Madhukar Kulkarni, and Ronald S. Karr as inventors, the application being incorporated herein by reference in its entirety.","This application relates to co-pending application Ser. No. 10\/327,535, filed on same day herewith, entitled \u201cIntermediate Descriptions of Intent for Storage Allocation\u201d and naming Chirag Deepak Dalal, Vaijayanti Rakshit Bharadwaj, Pradip Madhukar Kulkarni, Ronald S. Karr, and John A. Colgrove as inventors, the application being incorporated herein by reference in its entirety.","As businesses increasingly rely on computers for their daily operations, managing the vast amount of business information generated and processed has become a significant challenge. Most large businesses have a wide variety of application programs managing large volumes of data stored on many different types of storage devices across various types of networks and operating system platforms. These storage devices can include tapes, disks, optical disks, and other types of storage devices and often include a variety of products produced by many different vendors. Each product typically is incompatible with the products of other vendors.","Historically, in storage environments, physical interfaces from host computer systems to storage consisted of parallel Small Computer Systems Interface (SCSI) channels supporting a small number of SCSI devices. Whether a host could access a particular storage device depended upon whether a physical connection from the host to the SCSI device existed. Allocating storage for a particular application program was relatively simple.","Today, storage area networks (SANs) including hundreds of storage devices can be used to provide storage for hosts. SAN is a term that has been adopted by the storage industry to refer to a network of multiple servers and connected storage devices. A SAN can be supported by an underlying fibre channel network using fibre channel protocol and fibre channel switches making up a SAN fabric. Alternatively, a SAN can be supported by other types of networks and protocols, such as an Internet Protocol (IP) network using Internet SCSI (iSCSI) protocol. A fibre channel network is used as an example herein, although one of skill in the art will recognize that a storage area network can be implemented using other underlying networks and protocols.","Fibre channel is the name used to refer to the assembly of physical interconnect hardware and the fibre channel protocol. The basic connection to a fibre channel device is made by two serial cables, one carrying in-bound data and the other carrying out-bound data. Despite the name, fibre channel can run over fiber optic or twin-axial copper cable. Fibre channel includes a communications protocol that was designed to accommodate both network-related messaging (such as Internet Protocol (IP) traffic) and device-channel messaging (such as SCSI). True fibre-channel storage devices on a SAN are compatible with fibre channel protocol. Other devices on a SAN use SCSI protocol when communicating with a SCSI-to-fibre bridge.","Fibre channel technology offers a variety of topologies and capabilities for interconnecting storage devices, subsystems, and server systems. A variety of interconnect entities, such as switches, hubs, and bridges, can be used to interconnect these components. These varying topologies and capabilities allow storage area networks to be designed and implemented that range from simple to complex configurations. Accompanying this flexibility, however, is the complexity of managing a very large number of devices and allocating storage for numerous application programs sharing these storage devices. Performing a seemingly simple allocation of storage for an application program becomes much more complex when multiple vendors and protocols are involved.","Different types of interconnect entities allow fibre channel networks to be built of varying scale. In smaller SAN environments, fibre channel arbitrated loop topologies employ hub and bridge products. As SANs increase in size and complexity to address flexibility and availability, fibre channel switches may be introduced. One or more fibre channel switches can be referred to as a SAN fabric.",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1","b":["110","112","110","122","112"]},"Fibre channel switch  can be considered to represent the SAN fabric for the fibre channel network  corresponding to the SAN. At startup time, typically every host or device on a fibre channel network logs on, providing an identity and a startup address. A fibre channel switch, such as switch , catalogs the names of all visible devices and hosts and can direct messages between any two points in the fibre channel network . For example, some switches can connect up to 2devices in a cross-point switched configuration. The benefit of this topology is that many devices can communicate at the same time and the media can be shared. Redundant fabric for high-availability environments is constructed by connecting multiple switches, such as switch , to multiple hosts, such as host .","Storage devices have become increasingly sophisticated, providing such capabilities as allowing input and output to be scheduled through multiple paths to a given disk within a disk array. Such disk arrays are referred to herein as multi-path arrays. Storage array  is a multi-path array of multiple storage devices, of which storage device  is an example. Storage array  is connected to fibre channel network  via array port .","Storage device  is referred to as a logical unit, which has a Logical Unit Number (LUN) -LUN. In applications that deal with multiple paths to a single storage device, paths (such as paths A and B between array port  and storage device ) may also be considered to have their own LUNs (not shown), although the term LUN as used herein refers to a LUN associated with a storage device. Having access to a storage device identified by a LUN is commonly described as having access to the LUN. Having multiple paths assures that storage device  is accessible if one of the paths A or B fails.","Often, vendors of storage devices provide their own application programming interfaces (APIs) and\/or command line utilities for using the specialized features of their own storage devices, such as multiple paths to a storage device, but these APIs and command line utilities are not compatible from vendor to vendor. Allocating storage devices for use by a particular application program can be a difficult task when the storage is to be provided by multiple storage devices via a SAN, and each possible storage device has its own specialized features.","One approach to making storage devices easier to use and configure is to create an abstraction that enables a user to view storage in terms of logical storage devices, rather than in terms of the physical devices themselves. For example, physical devices providing similar functionality can be grouped into a single logical storage device that provides the capacity of the combined physical storage devices. Such logical storage devices are referred to herein as \u201clogical volumes,\u201d because disk volumes typically provide the underlying physical storage.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},"A logical volume is a virtual disk device that can be comprised of one or more physical disks. A logical volume appears to file systems, databases, and other application programs as a physical disk, although the logical volume does not have the limitations of a physical disk. In this example, two physical disks A and B, having respective device names A-N and B-N, are configured to provide two logical volumes A and B, having respective names vol and vol.","A logical volume can be composed of other virtual objects, such as logical disks, subdisks, and plexes. As mentioned above, at least one logical disk is created to correspond to each physical disk, and a disk group is made up of logical disks. Disk group  includes two logical disks A and B, with respective disk names disk and disk, each of which corresponds to one of physical disks A and B. A disk group and its components can be moved as a unit from one host machine to another. A logical volume is typically created within a disk group.","A subdisk is a set of contiguous disk blocks and is the smallest addressable unit on a physical disk. A logical disk can be divided into one or more subdisks, with each subdisk representing a specific portion of a logical disk. Each specific portion of the logical disk is mapped to a specific region of a physical disk. Logical disk space that is not part of a subdisk is free space. Logical disk A includes two subdisks A- and A-, respectively named disk- and disk-, and logical volume B includes one subdisk B-, named disk -.","A plex includes one or more subdisks located on one or more physical disks. A logical volume includes one or more plexes, with each plex holding one copy of the data in the logical volume. Logical volume A includes plex A, named vol-, and the two subdisks mentioned previously as part of logical disk A, subdisks A- and A-. Logical volume B includes one plex B, named vol-, and subdisk B-.","None of the associations described above between virtual objects making up logical volumes are permanent; the relationships between virtual objects can be changed. For example, individual disks can be added on-line to increase plex capacity, and individual volumes can be increased or decreased in size without affecting the data stored within.","Data can be organized on a set of subdisks to form a plex (a copy of the data) by concatenating the data, striping the data, mirroring the data, or striping the data with parity. Each of these organizational schemes is discussed briefly below. With concatenated storage, several subdisks can be concatenated to form a plex, as shown above for plex A, including subdisks A- and A-. The capacity of the plex is the sum of the capacities of the subdisks making up the plex. The subdisks forming concatenated storage can be from the same logical disk, but more typically are from several different logical\/physical disks.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3","b":["310","1","2","3","1","2","3","310","310","311","312","313"]},"With striped storage, data are distributed in small portions called \u201cstripe units,\u201d such as stripe units su through su. Each column has one or more stripe units on each subdisk. A stripe includes the set of stripe units at the same positions across all columns. In , stripe units ,  and  make up stripe , and stripe units ,  and  make up stripe . Thus, if n subdisks make up the striped storage, each stripe contains n stripe units. If each stripe unit has a size of m blocks, then each stripe contains m*n blocks.","Mirrored storage replicates data over two or more plexes of the same size. A logical block number i of a volume maps to the same block number i on each mirrored plex. Mirrored storage with two mirrors corresponds to RAID- storage (explained in further detail below). Mirrored storage capacity does not scale\u2014the total storage capacity of a mirrored volume is equal to the storage capacity of one plex.","Another type of storage uses RAID (redundant array of independent disks; originally redundant array of inexpensive disks). RAID storage is a way of storing the same data in different places (thus, redundantly) on multiple hard disks. By placing data on multiple disks, I\/O operations can overlap in a balanced way, improving performance. Since multiple disks increase the mean time between failure (MTBF), storing data redundantly also increases fault-tolerance.","A RAID appears to the operating system to be a single logical hard disk. RAID employs the technique of striping, which involves partitioning each drive's storage space into units ranging from a sector (512 bytes) up to several megabytes. The stripes of all the disks are interleaved and addressed in order. Striped storage, as described above, is also referred to as RAID- storage, which is explained in further detail below.","In a single-user system where large records, such as medical or other scientific images, are stored, the stripes are typically set up to be small (such as 512 bytes) so that a single record spans all disks and can be accessed quickly by reading all disks at the same time. In a multi-user system, better performance requires establishing a stripe wide enough to hold the typical or maximum size record. This configuration allows overlapped disk I\/O across drives.","Several types of RAID storage are described below. RAID- storage has striping but no redundancy of data. RAID- storage offers the best performance but no fault-tolerance.","RAID- storage is also known as disk mirroring and consists of at least two drives that duplicate the storage of data. There is no striping. Read performance is improved since either disk can be read at the same time. Write performance is the same as for single disk storage. RAID- storage provides the best performance and the best fault-tolerance in a multi-user system.","RAID- storage uses striping and dedicates one subdisk to storing parity information. Embedded error checking information is used to detect errors. Data recovery is accomplished by calculating the exclusive OR (XOR) of the information recorded on the other subdisks. Since an I\/O operation addresses all subdisks at the same time, input\/output operations cannot overlap with RAID- storage. For this reason, RAID- storage works well for single-user systems with data stored in long data records. In RAID-, a stripe spans n subdisks; each stripe stores data on n\u22121 subdisks and parity on the remaining subdisk. A stripe is read or written in its entirety.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 4","b":["3","410","4","1","4","2","4","3","410","4","0","4","11"],"sub":["4n-0 ","4-4","4-0 ","4-3 ","4-4 ","4-0 ","4-2"]},"RAID- storage includes a rotating parity array, thus allowing all read and write operations to be overlapped. RAID- stores parity information but not redundant data (because parity information can be used to reconstruct data). RAID- typically requires at least three and usually five disks for the array. RAID- storage works well for multi-user systems in which performance is not critical or which do few write operations. RAID- differs from RAID- in that the parity is distributed over different subdisks for different stripes, and a stripe can be read or written partially.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 5","b":["5","510","5","1","5","2","5","3","510","5","0","5","11"],"sub":["5-0 ","5-4","4-0 ","4-4 ","5-2","5-3","5-4 ","5-0 ","5-2"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 6","b":["1","620","620","610","620","620"]},"Plex A includes subdisks dthrough d, and plex B includes subdisks dthrough d. Plex A contains one copy of data blocks - through -, an B contains a mirror copy of data blocks - through -. Each plex includes two stripes; plex A includes stripes -A and -A, and plex B includes stripes -B and -B.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 7","b":["0","720","720","720","7","0","7","4","720","720","7","0","7","7"],"sub":["7-00 ","7-10","7-00 ","7-10 "]},"Plexes A through D are aggregated using striping to form a single volume . Stripe - is mirrored as stripe -, and stripe - is mirrored as stripe -. The logical view of volume  is that data blocks - through \u2014 are stored sequentially. Each plex provides reliability, and striping of plexes provides higher capacity and performance.","As described above,  illustrate the mirrored-stripe and striped-mirror storage, respectively. Though the two levels of aggregation are shown within a volume manager, intelligent disk arrays can be used to provide one of the two levels of aggregation. For example, striped mirrors can be set up by having the volume manager perform striping over logical disks exported by disk arrays that mirror the logical disks internally.","For both mirrored stripes and striped mirrors, storage cost is doubled due to two-way mirroring. Mirrored stripes and striped mirrors are equivalent until there is a disk failure. If a disk fails in mirrored-stripe storage, one whole plex fails; for example, if disk dfails, plex A is unusable. After the failure is repaired, the entire failed plex A is rebuilt by copying from the good plex B. Further, mirrored-stripe storage is vulnerable to a second disk failure in the good plex, here plex B, until the failed mirror, here mirror A, is rebuilt.","On the other hand, if a disk fails in striped-mirror storage, no plex is failed. For example, if disk dfails, the data in data blocks - and - are still available from mirrored disk d. After the disk dis repaired, only data of that one disk dneed to be rebuilt from the other disk d. Striped-mirror storage is also vulnerable to a second disk failure, but the chances are n times less (where n=the number of columns) because striped-mirrors are vulnerable only with respect to one particular disk (the mirror of the first failed disk; in this example, d). Thus, striped mirrors are preferable over mirrored stripes.","Configuring a logical volume is a complex task when all of these tradeoffs between performance, reliability, and cost are taken into account. Furthermore, as mentioned above, different vendors provide different tools for configuring logical volumes, and a storage administrator in a heterogeneous storage environment must be familiar with the various features and interfaces to establish and maintain a storage environment with the desired capabilities. Furthermore, a storage administrator must keep track of how particular volumes are implemented so that subsequent reconfigurations of a logical volume do not render the logical volume unsuitable for the purpose for which the logical volume was created.","A solution is needed that enables the intent of a logical volume creator to be stored with the logical volume so that the intent can be consistently followed when the logical volume is reconfigured. Preferably, a corresponding set of rules for configuring the logical volume are also stored either along with or as part of the intent. Volume management operations such as resizing the volume and evacuating data from the volume do not change the logical volume so that the logical volume remains suitable to fulfill the original purpose for which the logical volume was created.","The present invention provides a method, system, and computer program product for preserving the intent of a logical volume creator with the logical volume. The creator of a logical volume defines certain characteristics of that logical volume, such as a number of copies of data to be maintained, a level of performance required of the logical volume, or a requirement that one or more snapshots of the logical volume can be preserved representing the data at different points in time. In response to the user's requirements, the system explores the possibilities for providing the characteristics in the existing storage environment. The system then implements the logical volume and stores the intent, along with a corresponding set of rules for configuring the logical volume, with the logical volume. As a result, volume management operations like resizing the volume and evacuating data from the volume use the rules to preserve the intent of the creator. By ensuring that the logical volume consistently conforms to rules fulfilling the original intent, a consistent level of availability of the logical volume can be achieved to fulfill contractual availability requirements for storage service level agreements.","The use of the same reference symbols in different drawings indicates similar or identical items.","For a thorough understanding of the subject invention, refer to the following Detailed Description, including the appended Claims, in connection with the above-described Drawings. Although the present invention is described in connection with several embodiments, the invention is not intended to be limited to the specific forms set forth herein. On the contrary, it is intended to cover such alternatives, modifications, and equivalents as can be reasonably included within the scope of the invention as defined by the appended Claims.","In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the invention. It will be apparent, however, to one skilled in the art that the invention can be practiced without these specific details.","References in the specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the invention. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification are not necessarily all referring to the same embodiment, nor are separate or alternative embodiments mutually exclusive of other embodiments. Moreover, various features are described which may be exhibited by some embodiments and not by others. Similarly, various requirements are described which may be requirements for some embodiments but not other embodiments.","Today, with the proliferation of intelligent disk arrays, the storage devices available in a disk array provide many features. Through SANs, hosts now have access to hundreds of thousands of storage devices having a variety of properties. Because of these factors, configuring logical volumes in a given environment is no longer a trivial problem. The present invention provides a method, system, and computer program product for preserving the intent of a logical volume creator with the logical volume. The creator of a logical volume defines certain characteristics of that logical volume, such as a number of copies of data to be maintained, a level of performance required of the logical volume, or a requirement that one or more snapshots of the logical volume can be preserved representing the data at different points in time. In response to the user's requirements, the system explores the possibilities for providing the characteristics in the existing storage environment. The system then implements the logical volume and stores the intent, along with a corresponding set of rules for configuring the logical volume, with the logical volume. As a result, volume management operations like resizing the volume and evacuating data from the volume use the rules to preserve the intent of the creator. By ensuring that the logical volume consistently conforms to rules fulfilling the original intent, a consistent level of availability of the logical volume can be achieved to fulfill contractual availability requirements for storage service level agreements.",{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 8","b":"810"},"In \u201cObtain Available Storage Information\u201d step , information is gathered about the available storage for implementing the user requirements. This information can be gathered from storage devices directly attached to the host running the system software, via a network from other hosts directly attached to other storage devices, and from servers on a storage area network.","In \u201cProduce Logical Volume Configuration to Meet User Requirements using Storage Information\u201d step , the available storage information is searched for storage suitable for providing the specified user requirements. From the available storage, a logical volume configuration is determined that can be used to implement the user requirements using the available storage devices.","In \u201cExecute Commands to Implement Logical Volume Configuration in Hardware and\/or Software\u201d step , the logical volume configuration is used to determine a series of commands to implement the logical volume. The series of commands is executed to configure available storage devices to provide a logical volume to meet the user requirements.","In one embodiment of the invention, the following functionality is supported:\n\n","The user specifies one or more of these functions, along with functional requirements to be met by the storage implementing the function, and the steps of  are followed to configure the hardware and\/or software to provide the logical volume meeting the user's functional requirements. Each of the steps of  is discussed in further detail below. In the examples that follow, creating a logical volume is used as an example of operation of the present invention. However, one of ordinary skill in the art will appreciate that the above functions can be also be performed using the system, methods, language and computer program product described herein.","A configuration for a logical volume can be specified using rules, templates, capabilities, and\/or user templates, also referred to herein as application-specific templates.  shows the relationship between templates, rules, capabilities, and a logical volume in accordance with one embodiment of the present invention. Rules  are included within templates , because templates are a collection of rules. Rules and templates implement capabilities , and logical volume  can be configured to provide those capabilities . Logical volume  may be implemented using one or more physical storage devices, some of which may already possess physical characteristics, such as striping, that enable the device to provide certain capabilities, such as high performance, inherently. Logical volume  can have one or more capabilities implemented by one or more templates and\/or rules. To ensure that logical volume  meets user requirements, a combination of physical characteristics of some storage devices and software configuration of other storage devices using rules can be used to provide all capabilities meeting the user requirements. Rules, templates, capabilities, and user templates are described in further detail below.","Architecture",{"@attributes":{"id":"p-0093","num":"0101"},"figref":"FIG. 10","b":["1000","1000","1010","1000","1010","1000","1002"]},"Allocation coordinator  obtains data from configuration database , which includes data about templates, capabilities, rules, and policy database , which contains information about storage environment policies. An example of a policy is a specification of a stripe unit width for creating columns in a striped virtual object; for example, columns of a striped volume may be configured having a default stripe unit width of 128K. Allocation coordinator  also obtains information about the available storage environment from storage information collector . As shown, storage information collector  collects information from hosts for storage devices, such as host  for storage device , storage array , and storage area network . Information about available storage may be provided in the form of storage objects. Storage information collector  may be considered to correspond to a storage information-obtaining module, means, and instructions.","Allocation coordinator  communicates with a language processor . Language processor  interprets input in the form of the allocation specification language and input describing available storage information. Both allocation coordinator  and language processor  communicate with allocation engine , which accepts input in the form of an allocation language specification and provides output to command processor . In one embodiment, allocation engine  provides output in the form of a logical volume configuration specified as a virtual object hierarchy, which is explained in further detail below.","By automatically producing a logical volume configuration, allocation engine  can be considered to be a producing module, means, and instructions. Allocation engine  can also be considered to be a selecting module, means, and instructions because allocation engine  selects the hardware to be configured to produce the logical configuration. In addition, allocation engine  can be considered to be a configuration module, means, and instructions as well as a reconfiguration module, means, and instructions because allocation engine  ensures that a logical volume conforms to a logical volume configuration both at the time of initial configuration and for each subsequent reconfiguration. Ensuring that a logical volume conforms to the logical volume configuration's rules consistently enables the logical volume to be consistently available. For example, the logical volume can be configured to meet a 99.99% level of availability if the appropriate capabilities and rules are used. Allocation engine  can be considered an availability-providing module, means or instructions.","Command processor  accepts input from allocation engine  and produces commands that, when executed, create logical volume  on physical storage device(s) . As shown in this example, physical storage devices  are accessible via storage area network , although it is not necessary for operation of the invention that the storage devices used to implement the logical volume are accessible via a storage area network. For example, storage devices such as device  could be configured to provide the logical volume.","In one embodiment, command processor  obtains input in the form of a logical volume configuration specified as a virtual object hierarchy and produces commands as output. In this embodiment, command processor  can also operate in reverse; command processor  can produce a virtual object hierarchy as output using inputs in the form of a specification of intent (not shown) and the virtual objects (not shown) that make up logical volume  previously created by the commands. This modular design, in combination with abstractions like virtual objects and storage objects, makes the entire architecture flexible.","Command processor  executes the commands to configure physical storage devices to conform to a logical volume configuration. As such, command processor  can be considered to be an executing module, means, and instructions.","The functions performed by allocation engine  are computationally expensive. The functionality of the system described above can be implemented in various system configurations. For example, a separate computer system may be designated to perform the functionality of allocation engine . In such a configuration, allocation engine  resides on a host different from the host for command processor . An allocation proxy also can run on the host where command processor  is running to provide the logical volume configuration in the form of a virtual object hierarchy to the remote command processor .","A user may specify the desired configuration for a logical volume by using a user interface in one of several forms. For example, the user interface may be in the form of a graphical user interface, a set of selection menus, a command line interface, or, in the case of a software module user, an application programming interface or method of inter-process communication. One embodiment allows the user to specify user requirements as a high-level description of at least one characteristic of the logical volume, such as \u201csurvive failure of one path to a disk.\u201d","These user requirements can be translated into a \u201ccapability specification\u201d including one or more capabilities of the logical volume. Capabilities can be specified directly as a part of user requirements or determined to be necessary by allocation engine  to meet user requirements. Therefore, allocation engine  can be considered to be a capability-requiring module, means, and instructions. In addition, capabilities not specified as part of user requirements nevertheless can be required by the storage allocator, for example, to maintain storage policies in the storage environment. For example, a policy to limit a logical volume to contain no more than 100,000 database records can result in a requirement that a certain capability, such as storing the data on different disks, be provided. Furthermore, capabilities not specified as a user requirement may also be required by a template used to provide another capability.","One embodiment can also allow the user to select from a list of capabilities with which physical devices can be configured and\/or selected to provide the logical volume. Another embodiment allows the user to select from a set of user templates preconfigured as suitable for storing application-specific data, such as database tables. In addition, one embodiment allows the user to specify rules to configure the logical volume and to save those rules as a user template that can be used later.","The user interface described above may be considered to be a requesting module, means, and instructions to enable a user to request that a logical volume be configured according to user requirements. The user interface may be considered to be a capability-obtaining module, means or instructions to enable the user to request capabilities for a logical volume; a template-obtaining module that enables the user to specify a user template to be used to configure the logical volume; and\/or a rule-obtaining module to enable the user to specify a rule to be used to configure the logical volume.",{"@attributes":{"id":"p-0105","num":"0113"},"figref":["FIG. 11","FIG. 10"],"b":["11","1","1102","1102","1002","1010","1102","1102","11","2","1104","1105","1004","1010","11","3","1106","1106","1010","1010","1000","1000","1010","1000"]},"In action ., storage information collector  produces available storage information  and provides it to allocation coordinator . In action ., allocation coordinator provides available storage information  to allocation engine . In action ., allocation coordinator  provides volume parameters A to allocation engine , and in action ., allocation coordinator  provides user requirements B to language processor . In action ., allocation coordinator provides templates  and rules  to language processor . In action ., language processor  produces and provides intent  and capability specification  to allocation engine . Intent  captures information such as user requirements B, including high-level descriptions of characteristics requested of the logical volume (i.e., \u201cprovide high performance\u201d) and\/or rules or capabilities used to configure the logical volume for an intended use. In one embodiment, capability specification  is provided in the form of text describing capabilities and variable values either specified by the user or required by a template to implement capabilities satisfying the user requirements. In action ., allocation coordinator  provides policies  to allocation engine .","In action ., allocation engine  processes inputs available storage information , intent , capability specification , policies , and volume parameters A to produce capabilities implementation information . Capabilities implementation information  includes a selection of rules chosen to implement a logical volume based upon available storage information . Allocation engine  uses capabilities implementation information  and available storage information  to produce logical volume configuration . In action ., allocation engine  provides intent , capability specification , logical volume configuration , capabilities implementation information , and volume parameters A to allocation coordinator .","In action ., allocation coordinator  provides volume parameters A, capability specification , intent , capabilities implementation information , and logical volume configuration  to command processor . In action ., command processor  produces and executes the commands to configure logical volume  according to the user requirements . In action ., command processor  provides intent , capability specification , and capabilities implementation information  to be stored with logical volume  on physical storage device(s) . By associating the volume creator's intent  with logical volume , command processor  can be considered to be an associating module, means, and instructions.","The example system described in  implements each of the steps previously described with regard to . Each of these steps is described in further detail below.","Obtaining User Requirements","In one embodiment, user requirements can be specified as a high-level specification of characteristics desired of the logical volume, such as \u201cSurvive failure of two disks.\u201d The term \u2018user\u2019 is used herein to indicate either a person or a software module that uses the storage allocator of the present invention. In another embodiment, the user can specify capabilities for a logical volume, such as Reliable, High Performance, Snapshot-capable, and so on. The system can then determine the best rules and\/or templates to provide the requested capabilities, thereby allowing flexibility in implementing a set of capabilities. Capabilities can have parameters for which the user may enter values, thereby allowing further customization of the allocated storage. In another embodiment, the user can select from a set of application-specific templates, also referred to as user templates, which are pre-configured to meet the needs of a particular type of application, such as a database management system.",{"@attributes":{"id":"p-0111","num":"0119"},"figref":"FIGS. 12 through 20"},{"@attributes":{"id":"p-0112","num":"0120"},"figref":["FIG. 12","FIG. 13"],"b":["1210","1212","1220","1212","1230","1212","1212","1212"]},{"@attributes":{"id":"p-0113","num":"0121"},"figref":["FIG. 13","FIG. 12","FIG. 12"],"b":["1210","1212","1310","1320"]},"In this example, the following functions can be selected, as shown in pop-up window :\n\n",{"@attributes":{"id":"p-0115","num":"0135"},"figref":"FIG. 14","b":["1410","1412","1414","1416","1418","1420"]},{"@attributes":{"id":"p-0116","num":"0136"},"figref":["FIG. 15","FIG. 14"],"b":["1510","1520"]},{"@attributes":{"id":"p-0117","num":"0137"},"figref":"FIG. 16","b":["1610","1612","1614"]},{"@attributes":{"id":"p-0118","num":"0138"},"figref":"FIG. 17","b":["1710","1720"]},{"@attributes":{"id":"p-0119","num":"0139"},"figref":["FIG. 18","FIG. 18"],"b":["1820","1818","1810","1812","1814","1816","1820","1822"]},{"@attributes":{"id":"p-0120","num":"0140"},"figref":"FIG. 19","b":["1910","1920"]},{"@attributes":{"id":"p-0121","num":"0141"},"figref":"FIG. 20","b":["2010","2020","2030","2040","2050","1"]},"The foregoing  enable the user to specify requested characteristics, select capabilities, specify a user template to be used, or select a rule to configure a logical volume. The following sections describe a language that is used to specify rules and templates that are used to implement capabilities. Discussion of rules and templates is followed by a further discussion of capabilities and user templates.","Rules","Rules are the lowest level of the allocation specification language and are used to specify how a volume is to be created. One or more rules can be used to implement a capability. Two examples of types of rules are storage selection rules and storage layout rules. Storage selection rules select physical devices that can be used to implement a logical volume, and storage layout rules determine the layout of physical devices to implement the logical volume.","A rule can include one or more clauses, with each clause having a keyword. Each keyword is typically specified along with one or more attributes and\/or attribute values, where each attribute corresponds to an attribute of a storage device and each attribute value corresponds to the value of the attribute of the storage device.","When more than one attribute\/value pair is specified in a clause, an operator can be used to indicate the relationship between the attribute\/value pairs that must be met for the clause to be satisfied. For example, an anyof( ) operator can be used to indicate that if any one of the attribute\/value pairs is satisfied, the clause is satisfied; in effect, the anyof( ) operator performs an OR operation of the attribute\/value pairs. An eachof( ) operator can be used to indicate that all of the attribute\/value pairs must be met for the clause to be satisfied; in effect, the eachof( ) operator performs an AND operation of the attribute\/value pairs. Other examples of operators include a oneof( ) operator and a noneof( ) operator.","A set of rules specifying user requirements for a logical volume can result in the need to \u201cmerge\u201d the rules specified. For example, a set of rules implementing one capability may specify two mirrors, and another set of rules implementing another capability may specify two mirrors also. Rather than use four mirrors to implement the logical volume, a determination can be made whether only two mirrors can provide both capabilities. If so, only two mirrors can be included as part of the logical volume configuration.","Detailed syntax for rules according to one embodiment of the invention is provided in Appendix A.","Storage Selection Rules","Examples of keywords that are used in storage selection rules include select, confineto, exclude, separateby, strong separateby, multipath, and affinity.","The select keyword is used to select storage devices for creation of a virtual object such as a volume, mirror, or column. In one embodiment, the select keyword can be used to specify a set of logical unit numbers (LUNs) for storage devices that can be used to implement the virtual object.","An example of a clause including the select keyword is provided below:\n\n","The confineto keyword restricts physical devices that can be used to implement a particular virtual object, such as a volume or mirror. An example of a clause including the confineto keyword is provided below:\n\n","The exclude keyword is used to exclude a set of storage devices, identified by LUNs, from being used to implement a virtual object. The separateby keyword is used to describe separation between virtual objects and is typically used to avoid a single point of failure for greater reliability. For example, a separateby \u201cController\u201d clause can be used to specify that virtual objects, such as mirrors of a volume, should not share a controller.","The strong separateby keyword disallows sharing of attribute values between virtual objects. For example, a \u2018strong separateby \u201cSpindles\u201d places virtual objects, such as mirrors of a volume, on independent sets of spindles. In contrast, the affinity keyword expresses attraction between virtual objects such that virtual objects share as many attribute values as possible. For example, an \u2018affinity \u201cEnclosure\u201d\u2019 clause results in virtual objects, such as mirrors, using as few enclosures as possible.","The multipath keyword specifies tolerance of the virtual object to the failure of a specified number of one or more specified components. For example, a \u2018multipath 2 \u201cController\u201d, 2 \u201cSwitch\u201d\u2019 clause indicates that the virtual object should tolerate the failure of one path through a controller and a switch.","Storage Layout Rules","Examples of storage layout keywords include redundancy, parity, stripe, mirror, build mirror, and mirror group keywords. The redundancy keyword can be used both at the rule level and within a sub-clause. When used as a rule, the redundancy keyword describes the effective fault tolerance of the volume in terms of device failures. For a software-mirrored volume, redundancy indicates the number of mirrors the volume is expected to have. For a hardware-mirrored volume, redundancy indicates the number of underlying storage devices (LUNs) that should exist.","When used in a sub-clause, the redundancy keyword can be used, for example, to specify different types of separation within a virtual object. Consider the following sub-clause:\n\n","The parity keyword enables the user to specify whether a capability such as redundancy is parity-based and, in one embodiment, has associated values of true, false, and don't care. Parity-based redundancy is implemented using a RAID- layout. Parity can be implemented in hardware or software.","Keywords and keyword phrases including mirror, build mirror, mirror group, stripe, and redundancy are used in sub-clauses to, for example, more specifically configure one or more mirrors or columns of a volume. The mirror keyword is used to describe one or more mirrors of a logical volume. Rules specified within a mirror sub-clause apply to the corresponding mirror virtual object.","The stripe keyword indicates whether the virtual object of interest is to be striped and has associated values of true and false. Striping can also be implemented in hardware or software.","A mirror group sub-clause is used to group mirrors in a volume. Mirrors can be grouped when the mirrors share common attributes or when different groups of mirrors should be separated. Merging of rules involving mirrors typically occurs within a mirror group. A build mirror sub-clause forces a mirror to be created; these mirrors are not subject to merging.","Templates","A template is a meaningful collection of rules. Volumes can be created specifying templates instead of specifying individual rules. The rules in a template specify one or more capabilities, or features, of a logical volume. For example, a template can have rules such that the logical volume created using those rules tolerates failures of M controllers and has N copies of data. In this example, the user can enter the values of M and N, thus allowing end-user customization of specifications. A logical volume is configured to meet the user requirements to tolerate failure of M controllers and retain N copies of data. A user can name templates to be used for the creation of logical volumes, or the user can specify rules.","A template may provide a given capability by including rules providing the given capability, or by \u201crequiring\u201d a capability. When a template requires a capability but does not include rules providing the capability, the template obtains the rules needed to provide the required capability from another template that does include the rules providing the required capability. The requires keyword enables any template that provides the given capability to be used, therefore allowing flexibility in implementation of capabilities. A template that requires a given capability and provides the given capability by virtue of requiring the given capability, without specifying which template from which the rules are to be obtained, is said to indirectly \u201cinherit\u201d the capability. A template that requires a given capability and provides the given capability by virtue of requiring the given capability and specifying which template from which the rules are to be obtained is said to directly \u201cinherit\u201d the capability. Indirect inheritance is more flexible than direct inheritance, because indirect inheritance enables the best template for providing the template to be selected.","A given template can \u201cextend\u201d one or more other templates. When a template B extends a template A, B provides all capabilities that A provides, B requires all capabilities that A requires, B inherits all capabilities that A provides, and B has access to all the rules of A. The derived template (B in this example) has an \u201cis a\u201d relationship with the base template (A in this example). A derived template can be used wherever the corresponding base template can be used.","In one embodiment of the invention, preferably a template providing only the desired capability is selected to provide the desired capability. By following this preference, unrelated capabilities are not given to a volume and the intent of the person making the original allocation is more easily preserved. If several capabilities are desired, a template providing more than one of the desired capabilities is preferable to a template providing only one of the desired capabilities.","In one embodiment, the user can specify capabilities for a logical volume, instead of providing a name of one or more templates that create the volume with the desired capability. For example, a user can specify Reliable, High-Performance, Snapshot-capable, or other capabilities. Capabilities can have parameters for which the user may enter values, thereby allowing end-user customization of templates, as described above.","Capabilities","Since a template provides one or more capabilities, suitable templates can be selected by the system, depending on the capabilities requested by the user, allowing flexibility in implementing a given capability.","In the allocation language, a capability is defined by providing a name describing the capability provided, a description, a list of capabilities that the given capability extends, and a variable list. In this embodiment, the name of the capability can be a string having any value descriptive of the capability, such as \u201cReliable\u201d.","In one embodiment, a capability being defined can be derived from another capability, thereby extending the base capability. An extends keyword can be used to indicate that a given capability extends from a base capability for which the capability name is given. A derived capability inherits variables from its base capabilities, and thus preferably does not have variables with the same name as the variables for the base capability. If a capability inherits from multiple base capabilities, variable names of the base capabilities are preferably different.","In defining a capability, a list of variables can be provided in a \u201cvariables block,\u201d beginning with a var keyword. Values for these variables are provided by the user when a capability is requested. In one embodiment, each variable has a name, a type, a default value, and a description. An example of several capability definitions is provided below:",{"@attributes":{"id":"p-0150","num":"0175"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"capability Reliable {"},{"entry":"\u2003description \u201cProvides Reliable Storage\u201d"},{"entry":"\u2003descriptionID {26C0647D-182E-47f2-8FB6-2B3D0F62E961}, 1"},{"entry":"var NMIR:int {"},{"entry":"\u2003defaultvalue 2"},{"entry":"\u2003description \u201cNumber of software mirrors\u201d"},{"entry":"\u2003descriptionID {26C0647D-182E-47f2-8FB6-2B3D0F62E961}, 2"},{"entry":"}"},{"entry":"};"},{"entry":"capability HardwareVendorReliable {"},{"entry":"\u2003description \u201cProvides Hardware Reliable Storage\u201d"},{"entry":"\u2003descriptionID {26C0647D-182E-47f2-8FB6-2B3D0F62E961}, 2"},{"entry":"\u2003extends Reliable"},{"entry":"\u2003var VENDOR: string {"},{"entry":"\u2003\u2003defaultvalue \u201cABC\u201d"},{"entry":"\u2003\u2003description \u201cVendor Name\u201d"},{"entry":"\u2003\u2003descriptionID {26C0647D-182E-47f2-8FB6-2B3D0F62E961}, 2"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The HardwareVendorReliable capability extends the Reliable capability by specifying a particular value for the hardware's Vendor attribute. Any storage device provided by Vendor \u201cABC\u201d can be considered to inherently include the Reliable capability.","User Templates","A user template is a higher abstraction over capabilities, further simplifying specification of logical volume characteristics. A storage administrator can group capabilities based upon the way a particular application uses a volume having those capabilities is used. For example, an administrator can provide a user template specifically configured for a particular application or intended use.","By indicating an intended use of the logical volume, the user provides an \u201cintermediate description of intent\u201d for the logical volume. This intermediate description of intent is used to determine an intent of the volume creator to be stored with the logical volume, where the stored intent includes further information about how the logical volume was implemented. For example, the stored intent may include rules, capabilities, and variable values used to configure the logical volume.","For this reason, the term \u2018application-specific template\u2019 is used interchangeably with the term \u2018user template\u2019 herein. For example, a volume intended for storing a database table may have capabilities Reliable, with a certain number of data copies, and High Performance, where the database is confined to storage on a certain type of high performance storage device. This set of capabilities, along with the rules, can be saved as a user template called Database_Table. A user template is thus a collection of capabilities (with or without parameter values specified), templates, and rules. For example, the user template Database_Table can have capabilities, such as Reliable (NDISKS=2) and High Performance (NCOLS=15), as well as rules, such as \u2018confine to \u201cVendor\u201d=\u201cXYZ.\u201d\u2019 A user can specify that the storage to be allocated is intended for use as, for example, database table storage. The intended use can be associated with an appropriate application-specific template, or the name of the user template can be specified by the user. The user does not need to specify rules, templates, capabilities, or variable values, and a logical volume will be created according to the user template specified.","The user can use various types of specifications, from low-level specifications using rules to high-level specifications including user templates. Also, the user can specify micro-level characteristics, such as particular storage devices where each part of the logical volume should be stored, or macro-level specifications, where the user specifies only a desired characteristic or intended use of the logical volume, allowing the system to decide the best layout for the logical volume. User templates are the easiest to use, but give the user less control over volume creation. Rules are more difficult to use, but give the user complete control over volume creation. Once the user requirements are obtained, available storage information is obtained and compared to the user requirements.","Obtaining Available Storage Information","Available storage includes both physical storage devices accessible to the host and logical volumes that have already been allocated. Physical devices not used in a logical volume are identified by Logical Unit Numbers (LUNs), and logical volumes are identified by a volume name given to the logical volume upon creation. The present invention provides available storage information for logical volumes in the same way as for LUNs, such that a logical volume is indistinguishable from a LUN when viewed from the perspective of the functional requirements, or capabilities, the storage provides. Physical devices and logical volumes are collectively referred to herein as storage devices.","Storage devices have attributes such as Unique Identifier, Size, Available Size, Controller, Enclosure, Vendor, Model, Serial Number, Columns, Mirrors, and so on. In addition to these attributes, storage devices can optionally have capabilities, such as Reliability. The present invention allows capabilities to be specified not only for logical volumes, but also for physical storage devices. For example, a Striping capability can be associated with a hardware device that is striped. A logical volume can include hardware devices providing certain capabilities and virtual objects providing other capabilities.","When a user requests storage having certain capabilities, the present invention determines whether those capabilities exist on the available storage devices. If a particular storage device has Striping capability, whether in hardware or configured using software, that particular storage device can be used to fulfill a user requirement, such as High Performance, that can be implemented using striping. If the amount of available storage on the storage device is insufficient to meet the user's functional requirements, multiple storage devices having the required capability can be used.","Produce Logical Volume Configuration to Meet User Requirements Using Storage Information","The allocation engine of the present invention, such as allocation engine  of , takes as input the allocation request, in the form of user requirements. The allocation engine also uses a configuration database, such as configuration database , which includes rules, templates, and capabilities. The allocation engine obtains available storage information for the network environment and selects the appropriate storage to meet the rules defined in the templates that satisfy the user's functional requirements. The allocation engine arranges the selected storage in a logical volume configuration. The arrangements are hierarchical in nature with virtual objects, such as volumes, mirrors, and columns, forming the nodes of the hierarchy. Types of virtual objects can include volumes, mirrors, columns, volume groups, mirror groups, and groups. In one embodiment, virtual objects also include co-volumes, unnamed groups, and groups of groups.",{"@attributes":{"id":"p-0160","num":"0185"},"figref":["FIG. 21","FIG. 21","FIG. 21"]},"In , at \u201cAvailable Hardware (HW) has Capability\u201d decision point , a determination is made whether one or more hardware devices can provide the requested capability. If so, control proceeds to \u201cAvailable Hardware has Sufficient Capacity\u201d decision point  to determine whether any of the hardware devices identified in the previous step have sufficient capacity to provide the size of the logical volume requested by the user. If so, control then proceeds to \u201cSelect Hardware Device(s) to Satisfy Capacity\u201d step  to select from the hardware devices having both the capability and the capacity requested. A set of one or more hardware devices can be selected. The term \u2018set,\u2019 as used herein with respect to storage devices, refers to a set including one or more storage devices. Control then proceeds to \u201cConstruct Logical Volume Configuration\u201d step , where a logical volume configuration is constructed to provide the requested capabilities of the logical volume using the selected hardware.","At \u201cAvailable Hardware has Sufficient Capacity\u201d decision point , if no hardware device with the capability has sufficient capacity to satisfy the user's functional requirement, control proceeds to \u201cRecord Amount of Hardware Capacity Available\u201d step . In \u201cRecord Amount of Hardware Capacity Available\u201d step , the capacity available for each hardware device having the capability is recorded for future reference. This capacity information may be used if the requested capability and capacity can only be provided by using a combination of existing hardware having the capability and software-configured hardware. Control then proceeds to \u201cSearch for Template Providing Capability\u201d step .","At \u201cAvailable Hardware has Capability\u201d decision point , if none of the hardware devices can provide the requested capability, control proceeds to \u201cSearch for Templates Providing Capability\u201d step . A configuration database, such as configuration database  of , is searched for templates that provide the requested capability. Control proceeds to \u201cTemplate Found\u201d decision point . If no template is found, control proceeds to \u201cError\u2014Unable to Allocate\u201d step , and an error message is returned to the user indicating that sufficient resources are unavailable to configure the requested logical volume. If a template is found at \u201cTemplate Found\u201d decision point , control proceeds to \u201cSearch for Template Providing Only the Desired Capability\u201d step . In \u201cSearch for Template Providing Only the Desired Capability\u201d step , a search is made for a template providing only the desired capability to avoid providing unnecessary capabilities. Control proceeds to \u201cFound\u201d decision point . If one or more templates is found having only the desired capability, control proceeds to \u201cSelect One Template Having Only the Desired Capability\u201d step . Control then proceeds to \u201cSelect Hardware Device(s) to Satisfy Capacity\u201d step  and then to \u201cConstruct Logical Volume Configuration\u201d step , where the logical volume configuration is constructed using the selected hardware.","If at \u201cFound\u201d decision point , no template is found having only the desired capability, control proceeds to \u201cDetermine Best Template to Provide Desired Capability\u201d step . In \u201cDetermine Best Template to Provide Desired Capability\u201d step , a template is selected having as few capabilities as possible in addition to the desired capability. Control then proceeds to \u201cIs Sufficient Hardware Capacity Available for Software Configuration\u201d decision point . Preferably, in making this determination, hardware that already has the capability built in is excluded. If sufficient hardware capacity is available, control proceeds to \u201cSelect Hardware Device(s) to Satisfy Capacity\u201d step  and then to \u201cConstruct Logical Volume Configuration\u201d step , where the logical volume configuration is constructed using the selected hardware.","If at \u201cIs Sufficient Hardware Capacity Available for Software Configuration\u201d decision point , insufficient hardware capacity is available for software configuration, control proceeds to \u201cRecord Amount of Configurable Capacity\u201d step  to record the amount of hardware capacity that can be configured by software to have the desired capability. Control then proceeds to \u201cCan Hardware and Software-Configured Hardware Together Meet Desired Capacity\u201d decision point . The hardware capacity information recorded at \u201cRecord Amount of Hardware Capacity Available\u201d step  is used in conjunction with capacity information determined at \u201cRecord Amount of Configurable Capacity\u201d step  to make this decision.","If hardware and software-configured hardware can be combined to meet the desired capacity, control proceeds to \u201cSelect Hardware Device(s) to Satisfy Capacity\u201d step  and then to \u201cConstruct Logical Volume Configuration\u201d step , where the logical volume configuration is constructed using the selected hardware. If hardware and software-configured hardware cannot be combined to meet the desired capacity, control proceeds to \u201cError\u2014Unable to Allocate\u201d step , and an error message is returned to the user indicating that sufficient resources are unavailable to configure the requested logical volume.","As described above, a user can select more than one capability for a logical volume. With user requirements combining capabilities, the steps illustrated in  describe the relevant method of determining the logical volume configuration, but each individual step becomes more complicated. For example, a given hardware device may provide some, but not all, of the requested capabilities and\/or capacity. In addition, a given template or set of templates may provide different combinations of capabilities that work better in some environments than in others. Rules and\/or user-configurable variables can be provided to select appropriate combinations of hardware and software configurations to best meet the user's functional requirements.","Consider an example wherein a configuration database, such as configuration database , includes the following templates (designated by the variable t) and capabilities (designated by the variable c):\n\n","Also consider that the user has requested a volume having capabilities c, c and c. The allocation engine, such as allocation engine can determine that the most preferable template combination to provide these requested capabilities is the combination of templates t and t, and that the second-best template combination is the combination of templates t, t, and t. Note that templates t and t introduce capabilities not requested for the logical volume, respectively, capabilities c and c. To preserve the intent of the original requester as closely as possible, templates t and t should be avoided if possible.","As described above, allocating storage for a logical volume requires a careful balance of the capabilities requested, the performance of the devices configured to provide the capability, reliability of the configurations, and cost. These considerations are taken into account by the allocation engine and are discussed in further detail below.","Storage Selection Considerations","Each of the different types of storage configurations described above has different strengths and weaknesses. The allocation engine of the present invention balances these factors when selecting storage to be used to meet the user's functional requirements for a logical volume.","Concatenated Storage","Concatenated storage bandwidth and I\/O rate may attain maximum values that equal the sum of the values of the disks that make up the plex. Notice that this summation is over disks and not subdisks because bandwidth is determined by physical data transfer rate of a hard disk, and so is I\/O rate. Therefore, concatenating subdisks belonging to the same hard disk in a plex does not increase plex bandwidth.","Bandwidth is sensitive to access patterns. Realized bandwidth may be less than the maximum value if hot spots develop. Hot spots are disks that are accessed more frequently compared to an even distribution of accesses over all available disks. Concatenated storage is likely to develop hot spots. For example, take a volume that contains a four-way concatenated plex. Suppose further that the volume is occupied by a dozen database tables. Each table, laid out on contiguous blocks, is likely to be mapped over one subdisk. If a single database table is accessed very heavily (though uniformly), these access will go to one subdisk rather than being spread out over all subdisks.","Concatenated storage created from n similar disks has approximately n times poorer net reliability than a single disk. If each disk has a Mean Time Between Failure (MTBF) of 100,000 hours, a ten-way concatenated plex has only one-tenth the MTBF, or 10,000 hours.","Striped Storage","Like concatenated storage, striped storage has capacity, maximum bandwidth, and maximum I\/O rate that is the sum of the corresponding values of its constituent disks (not subdisks). Moreover, just like concatenated storage, striped storage reliability is n times less than one disk when there are n disks. However, since striping distributes the blocks more finely over all subdisks\u2014in chunks of stripe units rather than chunks equal to a full subdisk size\u2014hot spots are less likely to develop. For example, if a volume using four subdisks is occupied by a dozen database tables, the stripe size will be much smaller than a table. A heavily (but uniformly) accessed table will result in all subdisks being accessed evenly, so no hotspot will develop.","A small stripe unit size helps to distribute accesses more evenly over all subdisks. Small stripe sizes have a possible drawback, however; disk bandwidth decreases for small I\/O sizes. This limitation can be overcome in some cases by volume managers that support \u201cscatter-gather I\/O.\u201d An I\/O request that covers several stripes would normally be broken up into multiple requests, one request per stripe unit. With scatter-gather I\/O, all requests to one subdisk can be combined into a single contiguous I\/O to the subdisk, although the data is placed in several non-contiguous regions in memory. Data being written to disk is gathered from regions of memory, while data being read from disk is scattered to regions of memory.","Optimum stripe unit size must be determined on a case-by-case basis, taking into account access patterns presented by the applications that will use striped storage. On the one hand, too small a stripe unit size will cause small sized disk I\/O, decreasing performance. On the other hand, too large a stripe unit size may cause uneven distribution of I\/O, thereby not being able to use full bandwidth of all the disks.","Mirrored Storage","Bandwidth and I\/O rate of mirrored storage depend on the direction of data flow. Performance for mirrored storage read operations is additive\u2014mirrored storage that uses n plexes will give n times the bandwidth and I\/O rate of a single plex for read requests. However, the performance for write requests does not scale with number of plexes. Write bandwidth and I\/O rate is a bit less than that of a single plex. Each logical write must be translated to n physical writes to each of the n mirrors. All n writes can be issued concurrently, and all will finish in about the same time. However, since each request is not likely to finish at exactly the same time (because each disk does not receive identical I\/O requests\u2014each disk gets a different set of read requests), one logical write will take somewhat longer than a physical write. Therefore, average write performance is somewhat less than that of a single subdisk. If write requests cannot be issued in parallel, but happen one after the other, write performance will be n times worse than that of a single mirror.","Read performance does improve with an increasing number of mirrors because a read I\/O need be issued only to a single plex, since each plex stores the same data.","Mirrored storage is less useful in terms of capacity or performance. Its forte is increased reliability, whereas striped or concatenated storage gives decreased reliability. Mirrored storage gives improved reliability because it uses storage redundancy. Since there are one or more duplicate copies of every block of data, a single disk failure will still keep data available.","Mirrored data will become unavailable only when all mirrors fail. The chance of even two disks failing at about the same time is extremely small provided enough care is taken to ensure that disks will fail in an independent fashion (for example, do not put both mirrored disks on a single fallible power supply).","In case a disk fails, the disk can be hot-swapped (manually replaced on-line with a new working disk). Alternatively, a hot standby disk can be deployed. A hot standby disk (also called hot spare) is placed in a spare slot in the disk array but is not activated until needed. In either case, all data blocks must be copied from the surviving mirror on to the new disk in a mirror rebuild operation.","Mirrored storage is vulnerable to a second disk failure before the mirror rebuild finishes. Disk replacement must be performed manually by a system administrator, while a hot standby disk can be automatically brought into use by the volume manager. Once a replacement is allocated, the volume manager can execute a mirror rebuild. The volume, though it remains available, runs slower when the mirror is being rebuilt in the background.","Mirrors are also vulnerable to a host computer crash while a logical write to a mirror is in progress. One logical write request results in multiple physical write requests, one for each mirror. If some, but not all, physical writes finish, the mirrors become inconsistent in the region that was being written. Additional techniques must be used to make the multiple physical writes atomic.","RAID- and RAID- Storage","RAID- storage capacity equals n\u22121 subdisks, since one subdisk capacity is used for storing parity data. RAID- storage works well for read requests. Bandwidth and I\/O rate of an n-way RAID- storage is equivalent to (n\u22121)-way striped storage. Write request behavior is more complicated. The minimum unit of I\/O for RAID- is equal to one stripe. If a write request spans one stripe exactly, performance is least impacted. The only overhead is computing contents of one parity block and writing it, thus n I\/Os are required instead of n\u22121 I\/Os for an equivalent (n\u22121)-way striped storage. A small write request must be handled as a read-modify-write sequence for the whole stripe, requiring 2n input\/output operations.","RAID- storage provides protection against one disk failure. As in mirrored storage, a new disk must be brought in and its data rebuilt. However, rebuilding data is costlier than for mirrors because it requires reading all n\u22121 surviving disks.","RAID- storage capacity equals n\u22121 subdisks, since one subdisk capacity is used up for storing parity data. RAID- storage works well for read requests. Bandwidth and I\/O rate of an n-way RAID- storage is equivalent to n-way striped storage. The multiplication factor is n\u2014rather than n\u22121 as in the case of RAID-\u2014because the parity blocks are distributed over all disks. Therefore, all n disks contain useful data as well, and all can be used to contribute to total performance. RAID- works the same as RAID- when write requests span one or more full stripes. For small write requests, however, RAID- uses four disk I\/Os:\n\n","Latency doubles since the reads can be done in parallel, but the writes can be started only after the read requests finish and parity is computed. Note that the two writes must be performed atomically. Therefore, I\/O requests to a single stripe are serialized even though they are to non-overlapping regions. The application will not ensure this, since it is required to serialize I\/O only to overlapping regions. In addition, writes are logged in a transaction to make them atomic in case the server or storage devices fail.","RAID- storage provides protection against one disk failure. As with mirrored storage, a new disk must be brought in and its data rebuilt. As with RAID- storage, all n\u22121 surviving disks must be read completely to rebuild the new disk.","Due to the overhead involved with RAID, RAID storage is best implemented in intelligent disk arrays that can use special parity computation hardware and non-volatile caches to hide RAID write latencies from the host computer. As is the case with mirrored storage, RAID storage is also vulnerable with respect to host computer crashes while write requests are being made to disks. A single logical request can result in two to n physical write requests; parity is always updated. If some writes succeed and some do not, the stripe becomes inconsistent. Additional techniques can be used to make these physical write requests atomic.","After taking into account all of these storage selection criteria, the allocation engine of the present invention arranges the storage objects selected into a logical volume configuration. As described above, the logical volume configuration constructed is provided in the form of a virtual object hierarchy to a command processor, such as command processor . The command processor then determines commands that will configure the physical storage devices to form the logical volume. A more detailed explanation of logical volume configurations follows the discussion below of the last step of the flowchart of .","Execute Commands to Implement Logical Volume Configuration in Hardware and\/or Software","A command processor, such as command processor , takes a logical volume configuration in the form of a virtual object hierarchy as input and uses appropriate commands to create the volume. These commands are dependent upon the particular operating environment and storage devices in use. These commands are often provided by various interfaces to the storage devices.","Examples of commands used to implement a logical volume in one embodiment of the invention are given below. For example, the following commands create subdisks to store the logical volume.\n\n","The following commands create plexes within the logical volume:\n\n","The following commands associate the subdisks with the plexes:\n\n","The logical volume is then created using the following command:\n\n","The plexes are then associated with the volume:\n\n","Making the above application programming interface calls creates a logical volume. As mentioned previously, the rules, templates and capabilities are stored along with the volume as intent of allocation. Administrative operations on the volume (data relocation, disk evacuation, increase or decrease the size of the volume, and so on) can preserve this intent by ensuring that, when the logical volume is reconfigured, the rules, templates, and capabilities are used to reconfigure the logical volume so that the logical volume continues to conform to the intent of allocation.","Example Allocation of Storage","Assume that a user wishes to allocate a 10 GB volume named \u201cvol1\u201d that is reliable and provides high performance. Also assume that a configuration database of rules, templates, and capabilities, such as configuration database  of , includes the following:",{"@attributes":{"id":"p-0200","num":"0249"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"capability DiskReliability {"]},{"entry":[{},"\u2003var NDISKS: int {"]},{"entry":[{},"\u2003\u2003description \u201cSurvive failure of NDISKS-1 disks\u201d"]},{"entry":[{},"\u2003\u2003defaultvalue 2"]},{"entry":[{},"\u2003}"]},{"entry":[{},"};"]},{"entry":[{},"volume_template DiskReliabilityThroughMirroring {"]},{"entry":[{},"\u2003provides DiskReliability"]},{"entry":[{},"\u2003rules {"]},{"entry":[{},"\u2003\u2003mirror NDISKS"]},{"entry":[{},"\u2003}"]},{"entry":[{},"};"]},{"entry":[{},"capability PathReliability {"]},{"entry":[{},"\u2003var NPATHS: int {"]},{"entry":[{},"\u2003\u2003description \u201cSurvive failure of NPATHS-1 paths\u201d"]},{"entry":[{},"\u2003\u2003defaultvalue 3"]},{"entry":[{},"\u2003}"]},{"entry":[{},"};"]},{"entry":[{},"volume_template PathReliabilityThroughMirroring {"]},{"entry":[{},"\u2003provides PathReliability"]},{"entry":[{},"\u2003rules {"]},{"entry":[{},"\u2003\u2003mirror NPATHS2 {"]},{"entry":[{},"\u2003\u2003\u2003separateby \u201cController\u201d"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"};"]},{"entry":[{},"volume_template PathReliabilityThroughMultipathing {"]},{"entry":[{},"\u2003provides PathReliability"]},{"entry":[{},"\u2003rules {"]},{"entry":[{},"\u2003\u2003multipath NPATHS \u201cController\u201d"]},{"entry":[{},"\u2003}"]},{"entry":[{},"};"]},{"entry":[{},"capability HighPerformance {"]},{"entry":[{},"\u2003var NCOLS: int {"]},{"entry":[{},"\u2003\u2003description \u201cDisperse the data across NCOLS disks\u201d"]},{"entry":[{},"\u2003\u2003defaultvalue 15"]},{"entry":[{},"\u2003}"]},{"entry":[{},"};"]},{"entry":[{},"volume_template HighPerformanceThroughStriping {"]},{"entry":[{},"\u2003provides HighPerformance"]},{"entry":[{},"\u2003rules {"]},{"entry":[{},"\u2003\u2003stripe NCOLS"]},{"entry":[{},"\u2003}"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In the above entries in the configuration database, configuring a reliable logical volume can be accomplished in two ways. The PathReliability capability is defined as being able to tolerate faults on the path from the host to storage. The amount of tolerance can be specified by the user (through the use of the NPATHS variable in the PathReliability capability). Each of the PathReliabilityThroughMirroring and the PathReliabilityThroughMultipathing templates provides a different way to implement a path-reliable logical volume. The PathReliabilityThroughMultipathing template implements path reliability as a volume constructed from hardware having the specified number of paths (specified using the NPATHS variable) to a storage device. The PathReliabilityThroughMirroring template implements path reliability by storing copies of data on disks on paths for different controllers, so that if one path fails, a mirrored copy of the data is available via another path for a different controller.","The DiskReliabilityThroughMirroring template tolerates disk failure by using two or more data mirrors (with a default value of two). Mirrors are stored on different disks, so that if the disk for one mirror fails, a second copy of the data is available on another disk.","The \u201cHigh Performance\u201d capability requested by the user for volume \u201cvol1\u201d can be provided by the HighPerformanceThroughStriping template. One of skill in the art will recognize that other ways to achieve high performance are possible, and that the HighPerformanceThroughStriping template is an example only. When requesting the Performance capability, the user can specify, for example, whether a High or Medium level of performance is desired, as previously shown in . The HighPerformanceThroughStriping provides a default value of fifteen (15) disks (referred to as the number of columns, NCOLS) over which the data are dispersed. In one embodiment, a user may specify a number of columns other than the default value.",{"@attributes":{"id":"p-0204","num":"0253"},"figref":"FIG. 22","b":["2210","2220","2260","2250","2270","2282"]},"From user requirements , capability specification  is produced specifying that the storage allocated must provide path reliability and meet high performance standards. In the embodiment shown available storage information  is examined, and rules to implement capability specification  are selected and provided as capabilities implementation information .","Available storage information  indicates that the storage environment in which the logical volume is to be configured includes the following: A striped disk array, Disk Array , has ten columns (disks) across which data can be dispersed and one path to each disk; Disk Array  has two paths to each storage device and includes fifteen disks; and Disk Array  includes three disks with one path to each disk. To meet user requirements , Disk Array  alone is not suitable for implementing the logical volume because the high performance criteria of  columns cannot be provided and the each disk is not accessible via multiple paths. Disk Array  provides the path reliability sought by including multiple paths and 15 disks available for striping, but Disk Array  is not pre-configured as striped. Disk Array  does not support multiple paths or stripes and includes  disks. The best choice for implementing the required logical volume is Disk Array , assuming that Disk Array  has the requested 10 GB of storage available. Striping can be added via a software configuration, whereas multiple paths are provided by the hardware of Disk Array .","In this example, the PathReliabilityThroughMultipathing template is used, resulting in a multipath rule and a stripe rule, as shown in capabilities implementation information . Logical volume configuration  is produced using the rules of capability implementation information  and available storage information .","When logical volume configuration  is determined, the intent  of the user is preserved, to be stored in physical storage device(s)  along with the logical volume  as part of \u201cData Stored with Logical Volume\u201d . Intent  can include user requirements  (taken from user requirements ) as well as rules and templates selected and variable values used  to implement the logical volume . Intent  is preserved for reuse in the event that the logical volume's configuration is changed, for example, by adding additional storage devices, resizing the volume, or evacuating data from the volume. Rules stored within intent  are used to reconfigure logical volume  such that logical volume  continues to conform to the rules. By consistently conforming to the rules, consistent performance and availability can be guaranteed, for example, to fulfill contractual availability requirements of storage service level agreements.","To implement the logical volume using Disk Array , a logical volume configuration, such as virtual object hierarchy , is produced. Virtual object hierarchy  includes a volume level and three columns (one for each stripe) and corresponds to commands that will be issued to configure the hardware selected, here Disk Array . Virtual object hierarchy  does not include a representation of multiple paths, as multiple paths are provided by Disk Array  and are not configured by software.","Virtual object hierarchy  is used to produce commands  to configure a logical volume having the logical volume configuration . These commands are executed to configure a logical volume from one or more physical storage devices. In this example, commands to create 15 subdisks are first issued, with each command indicating an identifier for a respective disk (d through d) within Disk Array  to be used. The 15 columns are then created, and each subdisk is associated with a respective column.","A plex is then created using a stripe_unit_width of 128K bytes, such that data for each column is written to the plex in units of 128K bytes. Each of the 15 columns is associated with the plex because data from all 15 columns are needed to provide a complete copy of the data. A logical volume is created and the plex is associated with the logical volume.","The logical volume configuration  and resulting logical volume  created thus meets user requirements . Logical volume  survives failure of one path to disk because two different paths exist to each disk upon which a column is stored, by virtue of the multiple paths within Disk Array . Logical volume  provides high performance because the input\/output of the data is spread across 15 columns.","After the logical volume is created, intent , capability specification , and capabilities implementation information  are stored along with logical volume  as \u201cData Stored with Logical Volume\u201d .",{"@attributes":{"id":"p-0214","num":"0263"},"figref":["FIG. 23","FIG. 22"],"b":["2210","2220","2360","2350","2370","2382","2210","2220","2330"]},"The rules of capability implementation information  are selected by examining available storage information . Available storage information  differs from available storage information  in . Available storage information  indicates that the storage environment in which the logical volume is to be configured includes the following: a striped disk array, Disk Array A, has ten columns (disks) across which data can be dispersed, one path to each disk, and a controller C; Disk Array B includes fifteen disks, a controller C, and one path to each disk; and Disk Array C includes three disks, one path to each disk, and a controller C; and Disk Array D has one path to each of 15 disks and a controller C.","None of the storage devices available provides multiple paths, so path reliability is implemented by using a different storage device for each set of mirrors. To meet user requirements , Disk Array A alone is not suitable, unless configured using software, because Disk Array A does not provide either 15 columns or mirroring. Disk Array B has 15 disks available for striping and one controller, but is not striped. Disk Array C includes only three disks, not sufficient for providing the 30 disks that are needed. Disk Array D provides a second controller and another 15 disks. The combination of disk arrays B and D is selected to implement the logical volume, and logical volume configuration  is produced. Mirrored stripes are addedusing software configuration.","After the examination of available storage information , rules are selected to implement the capabilities specified and provided as capabilities implementation information . In this example, path reliability is implemented using the PathReliabilityThroughMirroring template because no arrays with multiple paths are available. Note that capabilities implementation information  includes rules for configuring mirrored stripes (mirrors within stripes), where each stripe has two mirrors and each mirror is on a separate controller. This configuration will require only two different controllers, because one set of mirrors will be placed under the control of one controller, and the other set of mirrors will be placed under control of the other controller. An alternative capabilities implementation information  may reverse the order of the rules to produced striped mirrors (stripes within mirrors). Such an implementation would also require two controllers, one for each mirror copy of data.","When logical volume configuration  is determined, the intent  of the user is preserved, to be stored in physical storage device(s)  along with the logical volume  as part of \u201cData Stored with Logical Volume\u201d . Intent  can include user requirements  (taken from user requirements ) as well as rules and templates selected and variable values used  to implement the logical volume .","To implement the logical volume by configuring available hardware using software, a logical volume configuration, such as virtual object hierarchy , is produced. Virtual object hierarchy  includes a volume level, three columns (one for each stripe), and 30 mirrors.","Virtual object hierarchy  is used to produce commands  to configure logical volume  in this format. These commands  are executed to configure a logical volume from one or more physical storage devices. In this example, commands to create a subdisk for each mirror are first issued. Thirty mirrors are then created (two mirrors for each column) and associated with the subdisks. Fifteen columns are created, and, and two mirrors are associated with each column. This configuration enables each portion of data in a column to be accessible via two different paths, because the two mirrors for each column are associated with different controllers.","A plex is then created to combine the 15 columns containing portions of the data into one copy of the data. Note that each column includes two mirrors of the respective column's portion of the data, so that the data for each column is accessible via two paths. Each of the fifteen columns is associated with the plex, logical volume  is created, and the plex is associated with the logical volume. Intent , capability specification , and capabilities implementation information  are stored along with logical volume  as \u201cData Stored with Logical Volume\u201d .","One of skill in the art that the particular formats of logical volume configurations  of  of  as virtual object hierarchies are only examples and are not intended to be limiting. Further information about logical volume configurations as virtual object hierarchies is provided below.","Logical Volume Configurations as Virtual Object Hierchies","A logical volume configuration is expressed as a hierarchy of virtual objects, such as volumes, mirrors, and columns. A volume can be made up of co-volumes. One co-volume can be created for storing data, and a separate co-volume can be created for each type of log that is to be contained in the volume. The data co-volume can have a concatenated data layout, a striped data layout, a mirrored data layout, a mirrored-stripe data layout, or a striped-mirror data layout. Each of these types of data layouts is described in further detail below.","A concatenated data layout has no compound rules in the rules; i.e., each rule is comprised of keyword clauses but no other rules. An example of a virtual object hierarchy for a concatenated data layout is shown in , with volume  and data co-volume . The PathReliabilityThroughMultipathing template provided as an example above produces a concatenated data layout hierarchy.","A striped data layout has only stripe rules in the rules:",{"@attributes":{"id":"p-0226","num":"0275"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rules {"]},{"entry":[{},"\u2003\u2003stripe <from> - <to> {"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"figref":"FIG. 25","b":["2510","2520","2530","2530","2530"],"i":["a","b","c. "]},"A mirrored data layout has only mirror-related rules. An example of rules specifying a mirrored data layout is given below:",{"@attributes":{"id":"p-0228","num":"0277"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rules {"]},{"entry":[{},"\u2003\u2003mirrorgroup A {"]},{"entry":[{},"\u2003\u2003mirror 2 {"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003mirror 1 {"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},"mirrorgroup B {"]},{"entry":[{},"\u2003\u2003mirror 1 {"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003mirror 2 {"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"An example of a mirrored data layout is shown in . Mirrored volume  includes data co-volume . A mirrored data layout such as mirrored volume  can include mirror groups, such as mirror groups and , and multiple mirror rules within each mirror group. A mirror group node is created for each mirror group rule; in the example, mirror group corresponds to the mirrorgroup A rule above, and mirror group corresponds to mirrorgroup B above. An unnamed group node is created within a mirror group rule for each mirror rule. Unnamed group node corresponds to the mirror  rule within mirrorgroupA, and unnamed group node corresponds to the mirror  rule within mirrorgroupA. Similarly, unnamed group node corresponds to the mirror  rule within mirrorgroupB, and unnamed group node corresponds to the mirror  rule within mirrogroupB.","Mirror nodes are created beneath the unnamed group nodes; in this example, unnamed group includes mirrors and created by the mirror  rule within mirrorgroupA; unnamed group includes mirror created by the mirror  rule within mirrorgroupA; unnamed group includes mirror created by the mirror  rule within mirrorgroupB; and unnamed group includes mirrors and created by the mirror  rule within mirrorgroupB. The number of mirror nodes created depends on the number of mirrors that are created by the mirror rule.","The DiskReliabilityThroughMirroring template provided as an example above produces a mirrored data layout hierarchy.","In a mirrored-stripe layout, each column is mirrored; i.e., each column has multiple copies of data. Such a layout can be formed by having mirror-related rules within a stripe rule. The mirror group layer in a mirrored data layout is shown beneath the column nodes, as shown in . An example of a rule producing the mirrored-stripe layout of  is given below:",{"@attributes":{"id":"p-0233","num":"0282"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rules {"]},{"entry":[{},"\u2003\u2003stripe 4 {"]},{"entry":[{},"\u2003\u2003mirrorgroup A {"]},{"entry":[{},"\u2003\u2003\u2003\u2003mirror 2 {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003mirror 1 {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},"\u2003\u2003mirrorgroup B {"]},{"entry":[{},"\u2003\u2003\u2003\u2003mirror 1 {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003mirror 2 {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},"..."]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In , volume  has data co-volume , which is a striped volume including  columns , , and , as indicated by the stripe  rule above. Each stripe includes two mirror groups, corresponding to the mirrorgroup A and mirrorgroup B rules above. In the example, column has two mirror groups and . An unnamed group node is created within a mirror group rule for each mirror rule. Unnamed group node corresponds to the mirror  rule within mirrorgroupA, and unnamed group node corresponds to the mirror  rule within mirrorgroupA. Similarly, unnamed group node corresponds to the mirror  rule within mirrorgroupB, and unnamed group node corresponds to the mirror  rule within mirrorgroupB. Mirror nodes are created beneath the unnamed group nodes; in this example, unnamed group includes mirrors and created by the mirror  rule within mirrorgroupA; unnamed group includes mirror created by the mirror  rule within mirrorgroupA; unnamed group includes mirror created by the mirror  rule within mirrorgroupB; and unnamed group includes mirrors and created by the mirror  rule within mirrorgroupB.  provides another example of a logical volume configuration  as a mirrored-stripe layout.","In a striped-mirror layout, each mirror includes striped data. Stripe rules within mirror rules result in a striped-mirror layout. The column layer of the hierarchy is created beneath the mirror layer.",{"@attributes":{"id":"p-0236","num":"0285"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rules {"]},{"entry":[{},"\u2003\u2003mirror 2 {"]},{"entry":[{},"\u2003\u2003\u2003\u2003stripe 4 {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"An example of a striped-mirror layout is shown in . Volume  includes data co-volume . One mirror group  includes one unnamed group  and two mirrors and , which correspond to the mirror  rule above. Each mirror has four stripes: mirror has columns , , , and , and mirror has columns , , , and ","Logical volume configurations are further complicated by such volume characteristics as logs. A log rule can include a numerical range that indicates the number of logs to be created from the specified rules. Each log created is a mirror of the other logs. As noted above, logs are tracked in a separate co-volume from the data. The log co-volume can be either mirrored or striped.","A mirrored log layout may include only basic rules within the log rule. For each log co-volume, a single mirror group node is created. An unnamed group node is created within a mirror group rule for each log rule. Log nodes are created beneath the unnamed group nodes. The number of log nodes created is determined by the number of mirrors of logs created by the log rule. An example of rules specifying a mirrored log layout is given below:",{"@attributes":{"id":"p-0240","num":"0289"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rules {"]},{"entry":[{},"\u2003\u2003log 2 {"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003log 3 {"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In this example, the first log rule creates two mirrors, and the second log rule creates three mirrors. An example of a mirrored log is shown in . Volume  includes a log co-volume  and a mirror group  for the logs. Each log rule results in creation of an unnamed group. Unnamed group corresponds to the log  rule above, and unnamed group corresponds to the log  rule above. Unnamed group includes two logs and , created by the log  rule. Unnamed group includes three logs, , , and , created by the log  rule.","A log can be striped if stripe rules exist within the log rules. An example of rules specifying a striped log is given below:",{"@attributes":{"id":"p-0243","num":"0292"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"rules {"]},{"entry":[{},"\u2003\u2003log 2 {"]},{"entry":[{},"stripe 4 {"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"}"]},{"entry":[{},"..."]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In this example, two logs are created, with each log having four columns. An example of a mirrored log is shown in . Volume  includes a log co-volume , a mirror group , and an unnamed group . Two logs and are created by the log  rule above. Each of the two logs includes four stripes, with log having columns through , and log having columns through ","It will be apparent to one skilled in the art that the virtual object hierarchies described above allow many logical volume configurations to be implemented to provide a variety of capabilities.","Advantages of the present invention are many. The present invention provides an extensible architecture that can easily be expanded to accommodate new types of storage technologies. Users can specify functional requirements or an intended use for a logical volume without being familiar with the various application programming interfaces and\/or command line interfaces used to configure the physical hardware. The user's requirements and\/or intended use are associated with capabilities to be provided by the logical volume. The intent of the user originally allocating the logical volume is stored along with the logical volume, and subsequent reconfigurations of the logical volume can use the stored intent to ensure that the reconfiguration preserves the original intent. Specific rules, templates, and\/or variable values used to implement the logical volume are also stored with the logical volume.","Using the present invention, new features of devices provided by intelligent disk arrays and by storage area networks are supported and incorporated into storage configurations more easily. If available hardware is configured to meet the functional requirements of a logical volume, the hardware is used; if not, storage allocator software can be used to configure other available hardware to meet the user's functional requirements. The storage allocator can be used at a very low level, by administrators intimately familiar with the features of available storage devices, to provide a high level of control over how logical volumes are configured. In addition, the storage allocator provides great flexibility and can also be used by users without detailed technical knowledge.","The language provided includes rules corresponding to a set of one or more commands to configure a set of one or more storage devices to provide requested capabilities of a logical volume. The language supports direct inheritance of a capability, where a template specifies another template that contains rules to be used to provide a given capability. The language also supports indirect inheritance of a capability, where a template requires a capability but does not provide an implementation of the capability. In addition, the language is processed to \u201cmerge\u201d rules by selecting a single storage device that conforms to more than one rule when possible. Merging rules enables a minimum number of storage devices to be used to meet a given logical volume configuration and set of capabilities.","The following section describes an example computer system and network environment in which the present invention may be implemented.","An Example Computing and Network Environment",{"@attributes":{"id":"p-0250","num":"0299"},"figref":"FIG. 31","b":["3110","31710","3112","3110","3114","3117","3118","3120","3122","3124","3126","3128","3130","3132","3133","3134","3137","3138","3135","3190","3135","3139","3140","3142","3146","3112","3128","3147","3112","3130","3148","3112"]},"Bus  allows data communication between central processor  and system memory , which may include read-only memory (ROM) or flash memory (neither shown), and random access memory (RAM) (not shown), as previously noted. The RAM is generally the main memory into which the operating system and application programs are loaded and typically affords at least  megabytes of memory space. The ROM or flash memory may contain, among other code, the Basic Input-Output system (BIOS) which controls basic hardware operation such as the interaction with peripheral components. Applications resident with computer system  are generally stored on and accessed via a computer readable medium, such as a hard disk drive (e.g., fixed disk ), an optical drive (e.g., optical drive ), floppy disk unit  or other storage medium. Additionally, applications may be in the form of electronic signals modulated in accordance with the application and data communication technology when accessed via network modem  or interface .","Storage interface , as with the other storage interfaces of computer system , may connect to a standard computer readable medium for storage and\/or retrieval of information, such as a fixed disk drive . Fixed disk drive  may be a part of computer system  or may be separate and accessed through other interface systems. Modem  may provide a direct connection to a remote server via a telephone link or to the Internet via an internet service provider (ISP). Network interface  may provide a direct connection to a remote server via a direct network link to the Internet via a POP (point of presence). Network interface  may provide such connection using wireless techniques, including digital cellular telephone connection, Cellular Digital Packet Data (CDPD) connection, digital satellite data connection or the like.","Many other devices or subsystems (not shown) may be connected in a similar manner (e.g., bar code readers, document scanners, digital cameras and so on). Conversely, it is not necessary for all of the devices shown in  to be present to practice the present invention. The devices and subsystems may be interconnected in different ways from that shown in . The operation of a computer system such as that shown in  is readily known in the art and is not discussed in detail in this application. Code to implement the present invention may be stored in computer-readable storage media such as one or more of system memory , fixed disk , optical disk , or floppy disk . Additionally, computer system  may be any kind of computing device, and so includes personal data assistants (PDAs), network appliance, X-window terminal or other such computing devices. The operating system provided on computer system  may be MS-DOS\u00ae, MS-WINDOWS\u00ae, OS\/2\u00ae, UNIX\u00ae, Linux\u00ae, or another known operating system. Computer system  also supports a number of Internet access tools, including, for example, an HTTP-compliant web browser having a JavaScript interpreter, such as Netscape Navigator\u00ae, Microsoft Explorer\u00ae, and the like.","Moreover, regarding the signals described herein, those skilled in the art will recognize that a signal may be directly transmitted from a first block to a second block, or a signal may be modified (e.g., amplified, attenuated, delayed, latched, buffered, inverted, filtered, or otherwise modified) between the blocks. Although the signals of the above described embodiment are characterized as transmitted from one block to the next, other embodiments of the present invention may include modified signals in place of such directly transmitted signals as long as the informational and\/or functional aspect of the signal is transmitted between blocks. To some extent, a signal input at a second block may be conceptualized as a second signal derived from a first signal output from a first block due to physical limitations of the circuitry involved (e.g., there will inevitably be some attenuation and delay). Therefore, as used herein, a second signal derived from a first signal includes the first signal or any modifications to the first signal, whether due to circuit limitations or due to passage through other circuit elements which do not change the informational and\/or final functional aspect of the first signal.","The foregoing described embodiment wherein the different components are contained within different other components (e.g., the various elements shown as components of computer system ). It is to be understood that such depicted architectures are merely examples, and that, in fact, many other architectures can be implemented which achieve the same functionality. In an abstract, but still definite sense, any arrangement of components to achieve the same functionality is effectively \u201cassociated\u201d such that the desired functionality is achieved. Hence, any two components herein combined to achieve a particular functionality can be seen as \u201cassociated with\u201d each other such that the desired functionality is achieved, irrespective of architectures or intermediate components. Likewise, any two components so associated can also be viewed as being \u201coperably connected,\u201d or \u201coperably coupled,\u201d to each other to achieve the desired functionality.",{"@attributes":{"id":"p-0256","num":"0305"},"figref":"FIG. 32","b":["3200","3210","3220","3230","3240","3240","3110","3250","3240","3260","1","3240","3260","1","3240","3240","3270","3270","3280","1","3240","3240","3210","3220","3230","3250","3290","3270"]},"With reference to computer system , modem , network interface  or some other method can be used to provide connectivity from each of client computer systems ,  and  to network . Client systems ,  and  are able to access information on storage server A or B using, for example, a web browser or other client software (not shown). Such a client allows client systems ,  and  to access data hosted by storage server A or B or one of storage devices A()-(N), B()-(N), ()-(N) or intelligent storage array .  depicts the use of a network such as the Internet for exchanging data, but the present invention is not limited to the Internet or any particular network-based environment.","The present invention is well adapted to attain the advantages mentioned as well as others inherent therein. While the present invention has been depicted, described, and is defined by reference to particular embodiments of the invention, such references do not imply a limitation on the invention, and no such limitation is to be inferred. The invention is capable of considerable modification, alteration, and equivalents in form and function, as will occur to those ordinarily skilled in the pertinent arts. The depicted and described embodiments are examples only, and are not exhaustive of the scope of the invention.","The foregoing described embodiments include components contained within other components. It is to be understood that such architectures are merely examples, and that, in fact, many other architectures can be implemented which achieve the same functionality. In an abstract but still definite sense, any arrangement of components to achieve the same functionality is effectively \u201cassociated\u201d such that the desired functionality is achieved. Hence, any two components herein combined to achieve a particular functionality can be seen as \u201cassociated with\u201d each other such that the desired functionality is achieved, irrespective of architectures or intermediate components. Likewise, any two components so associated can also be viewed as being \u201coperably connected,\u201d or \u201coperably coupled,\u201d to each other to achieve the desired functionality.","The foregoing detailed description has set forth various embodiments of the present invention via the use of block diagrams, flowcharts, and examples. It will be understood by those within the art that each block diagram component, flowchart step, operation and\/or component illustrated by the use of examples can be implemented, individually and\/or collectively, by a wide range of hardware, software, firmware, or any combination thereof.","The present invention has been described in the context of fully functional computer systems; however, those skilled in the art will appreciate that the present invention is capable of being distributed as a program product in a variety of forms, and that the present invention applies equally regardless of the particular type of signal bearing media used to actually carry out the distribution. Examples of signal bearing media include recordable media such as floppy disks and CD-ROM, transmission type media such as digital and analog communications links, as well as media storage and distribution systems developed in the future.","The above-discussed embodiments may be implemented by software modules that perform certain tasks. The software modules discussed herein may include script, batch, or other executable files. The software modules may be stored on a machine-readable or computer-readable storage medium such as a disk drive. Storage devices used for storing software modules in accordance with an embodiment of the invention may be magnetic floppy disks, hard disks, or optical discs such as CD-ROMs or CD-Rs, for example. A storage device used for storing firmware or hardware modules in accordance with an embodiment of the invention may also include a semiconductor-based memory, which may be permanently, removably, or remotely coupled to a microprocessor\/memory system. Thus, the modules may be stored within a computer system memory to configure the computer system to perform the functions of the module. Other new and various types of computer-readable storage media may be used to store the modules discussed herein.","The above description is intended to be illustrative of the invention and should not be taken to be limiting. Other embodiments are possible. Those skilled in the art will readily implement the steps necessary to provide the structures and the methods disclosed herein, and will understand that the process parameters and sequence of steps are given by way of example only and can be varied to achieve the desired structure as well as modifications that are within the scope of the invention. Variations and modifications of the embodiments disclosed herein can be made based on the description set forth herein, without departing from the scope of the invention. Consequently, the invention is intended to be limited only by the scope of the appended claims, giving full cognizance to equivalents in all respects."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention may be better understood, and its numerous objects, features and advantages made apparent to those skilled in the art by referencing the accompanying drawings.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 4","b":"3"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 5","b":"5"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 6","b":"1"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 7","b":"0"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 11","FIG. 10"]},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIGS. 12 through 20"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 13","FIG. 12"]},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 32"}]},"DETDESC":[{},{}]}
