---
title: Dynamically adapting between pessimistic and optimistic notifications to replicated objects
abstract: An adaptive view mechanism can dynamically adapt to changing conditions and provide the benefits of both optimistic and pessimistic notifications. This can, for example, provide a consistent and jitter-free GUI to display the state of distributed replicated data objects in the presence of concurrency control conflicts and losses. In a Model-View-Controller architecture of building distributed collaborative applications where model objects are replicated at distributed sites, adaptive views can dynamically switch between behaving like pessimistic views and like optimistic views. When the number of concurrent updates is low, the adaptive views can be made to operate in an optimistic mode—providing good responsiveness to users. However, during those periods of heavy activity, when the number of concurrent updates becomes high, the adaptive view can be made to operate in a pessimistic manner—providing more reliable response to users. For each adaptive view, a programmer can specify a policy object that can monitor the prevailing conflict rate and loss rate as if the adaptive view were behaving optimistically. Using these rates, the policy object can apply arbitrary application logic or thresholds to determine whether it is beneficial for the adaptive view to behave optimistically or pessimistically. The policy object can then request the adaptive view to dynamically adapt its behavior to the appropriate manner. In general however, the dynamic switching can be based on any application specific request to switch modes. Distributed sites that have replicated copies of the same model object can view the replica heterogeneously, that is, pessimistically, optimistically, or adaptively, according to the user's requirements.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06952829&OS=06952829&RS=06952829
owner: International Business Machines Corporation
number: 06952829
owner_city: Armonk
owner_country: US
publication_date: 19980629
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present invention relates to the responsiveness of user interfaces in distributed groupware applications. In particular the invention relates to a method for providing applications that synchronize data with other remote applications and at each site view data either pessimistically, optimistically, or adaptively by dynamically switching modes.","Synchronous distributed groupware applications are being increasingly being deployed on high-latency wide-area networks such as the Internet. For such groupware applications, the major drawback of high-latency networks is the potential decrease in responsiveness. Many synchronous groupware systems available today allow end-users to share state by making distributed copies of the shared state, and keeping the copies consistent via some consistency protocol. When a user updates his copy of the shared state, all users see the update after the consistency protocol runs and, after a certain delay, has consistently updated the replicated copies. In some groupware applications, this delay may be tolerable for users other than the one who initiates the update. However, for the initiator of the update, the delay may become intolerable, since graphical user interface (GUI) gestures will no longer provide adequate visual feedback relative to regular single-user applications.","A solution that is widely employed to solve the general problem of responsiveness in groupware is optimistic execution of updates to distributed shared state. See e.g., Schuckmann, C., Kirchner, L., Schummer, J., and Haake, J. M. (1996) \u201cDesigning Object-oriented Synchronous groupware with COAST.\u201d In Proceedings of Computer Supported Collaborative Work CSCW, 1996 [\u201cCOAST\u201d]; and Karsenty, A. and Beaudouin-Lafon, M (1993) \u201cAn Algorithm for","Distributed Groupware Applications.\u201d Proceedings of IEEE Int'l Conference on Distributed Computing Systems ICDCS '93 [\u201cORESTE\u201d]. See also patent application Ser. No. 08\/863,782 entitled \u201cSYSTEM AND METHOD FOR PROVIDING COLLABORATIVE REPLICATED OBJECTS FOR SYNCHRONOUS DISTRIBUTED GROUPWARE APPLICATIONS,\u201d [\u201cDECAF\u201d] by Banavar et al., filed May 27, 1997 now U.S. Pat. No. 6,425,016. The present invention is commonly assigned with this patent application, which is hereby incorporated herein by reference in its entirety.","Optimistic execution is based on assumptions about the current state of the system. Subsequently, if any assumption turns out to be invalid due to concurrent operations, the conflict is resolved using any of a number of techniques: such as rollback [DECAF]; transformation (see e.g., Ellis, C. A. and Gibbs, S. J. (1989) \u201cConcurrency Control in Groupware Systems,\u201d Proceedings of ACM Conference on the Management of Data SIGMOD '89); or masking [ORESTE]. For groupware applications where shared state is directly visible to end-users, optimistic execution does indeed increase responsiveness, since updates may be exposed to users as soon as they are optimistically applied. Thus, a system that supports optimistic execution is very useful for supporting interactive, transient state within groupware applications.","However, a groupware system that supports optimistic execution alone has limitations. For one thing, external persistent actions such as printing or saving to file should not be performed based on optimistic state. Even for interactive transient state, optimism introduces the possibility of irregular GUI behavior when optimistic assumptions turn out to be invalid, which often causes confusion to end-users. This irregular GUI behavior most commonly takes the form of lost updates (since more \u201crecent\u201d updates have been exposed) or jitter in an application's GUI (as updates are retried and reapplied). Thus, it is important for groupware systems to support both optimistic and some form of pessimistic execution to allow the application programmer to pick and choose what is appropriate to each case.","The aforementioned DECAF application framework for groupware supports both optimistic and pessimistic notifications of updates to distributed replicated state. DECAF extends the so called","Model-View-Controller (MVC) architecture for applications. Framework provided model objects, which hold the application state, are replicatable across distributed sites, and the DECAF system automatically keeps replicas consistent with each other. Controllers, or GUI event handlers, can initiate programmer defined atomic actions on multiple model objects. Programmer defined view objects can be attached to model objects at each site to get notifications of both local and remote updates to the replicated model objects. At the time of attachment of model objects, each view object can be specified to be either optimistic or pessimistic, which determines when the system will notify the view objects. A pessimistic view is guaranteed to get all update notifications in order, and is able to take consistent snapshots of attached model objects. An optimistic view trades off complete accuracy for the performance benefit of immediately notifying updates.","In DECAF, the programmer must statically decide, per view object, whether the view object should be notified optimistically or pessimistically\u2014this decision holds good throughout the application's life. In other words, the DECAF programmer must trade off between view responsiveness and complete view accuracy at application design time. An optimistic view's behavior is justifiable only under conditions of a low rate of concurrent updates, and thus low probability for concurrency control conflicts. Such an assumption of low conflict rate is valid for some groupware usage scenarios where, for example, users practice social protocols such as turn taking. However, if this assumption cannot be made for scenarios in which a groupware application is to be deployed, it is better to use only pessimistic views.","Observe that the rate of concurrent updates to replicated model objects, and thus the conflict rate, are inherently dynamic variables that vary within and across usage scenarios. In many scenarios, concurrent updates may be bursty by nature. Long periods of time with low rates of concurrent updates may be followed by short periods of time with high rates of concurrent updates. In these situations, programmers of systems such as must make a difficult decision between optimistic and pessimistic views.","For example, consider a hypothetical collaborative spreadsheet application used by commodity traders to aid in their analysis of a commodity market. Usually, the traders are collaborating over a low-latency LAN, analyzing different commodities in a controlled environment. These factors, which reduce the number of concurrent updates in the system, will prompt a DECAF programmer to choose optimistic views to obtain a highly responsive spreadsheet application. However, breaking news stories or market events can occasionally cause the traders to frantically focus on a small number of commodities. The result is a large number of concurrent updates, causing the spreadsheet to recalculate repeatedly. At these times, the behavior of the application is not only distracting, but also confusing to the traders. This hampers the ability of the traders to execute trades in a timely manner.","Thus a need exists for a mechanism that can dynamically adapt to changing concurrency conditions and provide the benefits of both optimistic and pessimistic notifications. The present invention meets this need.","Accordingly, the present invention describes a mechanism known as adaptive views that can dynamically adapt to changing conditions and provide the benefits of both optimistic and pessimistic notifications. For example, the present invention includes features that provide a consistent and jitter-free GUI to display the state of distributed replicated data objects in the presence of concurrency control conflicts and losses.","In one embodiment, such as a Model-View-Controller architecture of building distributed collaborative applications where model objects are replicated at distributed sites, adaptive views can dynamically switch between behaving like pessimistic views and like optimistic views. When the number of concurrent updates is low, the adaptive views can be made to operate in an optimistic mode\u2014providing good responsiveness to users. However, during those periods of heavy activity, when the number of concurrent updates becomes high, the adaptive view can be made to operate in a pessimistic manner\u2014providing more reliable response to users.","In a system including a plurality of distributed sites, wherein each site is adapted to run at least one application and application state information is maintained at a plurality of local and remote sites, a method having features of the present invention comprises the steps of: receiving a request for an update to said state information at a local site; generating an update to the state information maintained at the local site, in response to the request for an update to the state information; generating a notification of the update to the application; and dynamically switching between an optimistic notification mode and a pessimistic notification mode.","In a preferred embodiment, for each adaptive view, a programmer can specify a policy object that can monitor the prevailing conflict rate and loss rate as if the adaptive view were behaving optimistically. Using these rates, the policy object can apply arbitrary application logic to determine whether it is beneficial for the adaptive view to behave optimistically or pessimistically. The policy object can then request the adaptive view to behave in the appropriate manner. In general however, the dynamically switching can be based on any application specific request to switch modes.","An example of a conflict rate-based method further comprises the steps of: specifying a threshold conflict rate; measuring and comparing a current conflict rate with the threshold value; and said step of dynamically switching being responsive to said comparing step. The conflict rate can be defined as a weighted function of a ratio of lost updates and aborted updates to updates initiated.","Distributed sites that have replicated copies of the same model object can advantageously view the replica heterogeneously, that is, pessimistically, optimistically, or adaptively, according to the user's requirements.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 1A","b":["101","100","130","160"]},"At the application level , pessimistic view objects , optimistic view objects , adaptive view objects , policy objects , and transaction objects  are provided for the user. The three types of view objects respond to notifications that data has changed locally. The purpose of all three types of view objects is to compute some function (e.g., a graphical rendering) of some or all of the model objects  bound to them. The three types differ in when each receives notifications that data has changed: optimistic view objects  receive notifications as soon as the data has changed locally; pessimistic view objects  receive notifications only when the distributed sites have agreed there are no conflicts among them in the changes to the data. According to the present invention, adaptive view objects  may receive notifications as an optimistic view object would or a pessimistic view object would and may dynamically switch between the two notification behaviors. Policy objects monitor the conflict rates in the changes to data. When the local application responds to events initiated by the end user at that site, transaction objects  are created for reading and\/or updating of data. The mechanism for interacting with the view objects, policy objects, and transaction objects in the application layer is a Collaboration Manager , which is incorporated into the framework level  at each site.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 1B","b":"1"},"Referring now to , the Collaboration Manager  serves as an object factory, creating  the other objects at the framework level. It establishes  and maintains replica relationships among local model objects and model objects at remote sites. It also serves as a message router, routing incoming messages to the appropriate object at the local site and addressing outgoing messages to appropriate objects at remote sites. Finally it controls the execution of the transaction objects (, ). The Collaboration Manager responds to requests from applications to create model object instances , to invoke transactions , and to establish replica relationships .","The Model objects  hold application state. All model objects preferably allow reading and updating of this state, as well as attaching  view objects  which receive notifications of changes to the state. Model objects  are preferably provided for both simple data types (e.g., integer, floating point, string) and composite objects (e.g., tables and vectors). The Model objects respond to application requests to read  and\/or update  their state and to attach view objects . Model objects generate notifications  to view objects  when their state changes.","Referring again to , the framework level  additionally comprises a set of pessimistic , optimistic , and adaptive  view proxy objects, each created by a model object in response to the first application request to attach a view object to a model object. There is one view proxy object per view object at the application level, and its type corresponds to that of the application view object. View proxy objects - are not visible to the application, as they do not directly support application requests. However, they do deliver update notifications to view objects - by creating and scheduling ViewTI objects when model objects change. As noted above for the three types of application level view objects, the corresponding types of view proxy objects differ from each other in when they deliver notifications of changes to attached model objects to their associated view objects. In doing so, the different types of view proxy objects maintain different guarantees to the application level view objects. The guarantees to pessimistic view objects are outlined below in the explanation for , while those to optimistic view object in the explanation for FIG. A. The inventive adaptive view proxy objects provides the method, explained below in , for one view object to behave like a pessimistic view at some times, like an optimistic view at others, and to dynamically switch between the two notification modes while maintaining each view's guarantees. In addition, together with the inventive policy object, the present invention describes a method in  for an application to monitor the conflict rate in updates to model objects and dynamically switch between pessimistic and optimistic modes based on changes in that conflict rate.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 2","b":["200","210","220"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 3","b":["153","150","310","123","153","320"]},"The Collaboration Manager generates updates (step ) to the model objects. When a model object is updated, the Model Object notifies (step ) all View Proxy objects , , and  which have been associated with the Model Object via the AttachView .",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 4","b":["400","410","420","430"]},{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 5","FIG. 6A","FIGS. 6B","FIGS. 6A","FIGS. 6A and 7A"],"b":["500","510","520","7","11","530","6","7","7","11","540"]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 6A","b":["610","620","500"]},"The commit status field of the ViewTI is recorded as PENDING . If the ViewTI is the last ViewTI is the last ViewTI in the sorted list, record the straggler field as FALSE, otherwise record the straggler field as TRUE (step ). For each guess generated in , the Pessimistic View Proxy requests a guess confirmation from the Collaboration Manager (step ).",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 6B","b":["110","660","660"]},"If the Guess Confirmation reply is a confirm and all guesses for the ViewTI have been confirmed (step ), record the commit status in the ViewTI as COMMITTED. When all guesses are confirmed, it means that the values of all model objects at the ViewTI's VT are now consistent. In this manner, a pessimistic view is guaranteed to get a consistent state snapshot of all attached model objects upon notification. All Update notifications, which may be delivered, are now delivered to the View object (step ). Using the sorted list of ViewTI objects, if the first ViewTI object after the last notified VT is COMMITTED, deliver an update notification to the View Object for this ViewTI. If the next ViewTI is also COMMITTED, deliver an update notification to the View Object for this ViewTI. Repeat this process until there are no more ViewTIs or the next ViewTI is not COMMITTED. In this manner, a pessimistic view is guaranteed to get notifications of all updates to attached model objects, in monotonic order of applied updates. The VT of the latest ViewTI for which an Update notification was delivered to the View object is recorded in the last notified VT field of the Pessimistic View Proxy (step ).","If the guess confirmation was a deny, check the type of guess which has been denied (step ). There are two types of guesses: (1) update committed (UC) guesses are confirmed if an updating transaction commits, and (2) read latest (RL) guesses are confirmed if there are no intervening updates between the ViewTI's VT and an earlier VT at which an update was made. Guesses are denied if these conditions are not satisfied. Collaboration Managers at all the collaborating sites communicate with each other to confirm or deny guess confirmation requests. If the type of guess which was denied is UC (Update Committed), the commit status of the ViewTI is recorded as ABORTED (step ). If the type of guess which was denied is not a UC guess, the list of guesses is revised (step ). For each revised guess, the Pessimistic View Proxy requests confirmation from the Collaboration Manager (step ).",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 7A","b":["710","715","720","725","730"]},"If the ViewTI VT is greater than the last notified VT, deliver an update notification to the optimistic view (step ). In this manner, an optimistic view is always notified of the latest value as soon as possible. Then, record the last notified VT field of the Optimistic View Proxy as the VT of the ViewTI (step ). Next, in either case of the ViewTI VT greater than or less than the last notified VT check, request guess confirmation from the Collaboration Manager (step ).",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 7B","b":["143","750","760","765"]},"If in step  the guess confirmation is a \u201cdeny\u201d, check the type of the guess which has been denied (step ). If the type of the denied guess was UC, the commit status of the ViewTI is recorded as ABORTED (step ). Next, if the VT of this ViewTI is the last notified VT (step ), using the sorted list of ViewTI objects, locate the previous un-aborted ViewTI object and deliver an update to the Optimistic view object. In this manner, an optimistic view is given a superseding notification if an earlier update notification turned out to be inconsistent. Furthermore, if the commit status of the previous ViewTI object is COMMITTED, deliver a commit notification to the Optimistic View object. In this manner, it is guaranteed that commit notifications are always delivered in monotonic order of applied updates. Record the last notified VT of the Optimistic View Object to be the VT of the previous ViewTI object (step ).","If the type of the denied guess was not UC, revise the list of guesses for the ViewTI (step ). Next, request confirmation of each revised guess from the Collaboration Manager (step ).","According to the present invention,  depicts an example of additional interfaces among the application level  (policy object  and adaptive view object ) and the framework level  (adaptive view proxy object ) that allow an application to dynamically switch the adaptive view object between optimistic and pessimistic notification modes. As part of an application's request to attach (, ) an adaptive view object  to a model object , the application sets: an initial notification mode  for the adaptive view object, as either OPTIMISTIC or PESSIMISTIC; and a monitoring interval . The monitoring interval determines how frequently the adaptive view proxy object  notifies the policy object of the conflict parameters  ( depicts an example of a procedure for calculating the conflict parameters by an Adaptive View proxy). The policy object may compute an application specific conflict rate from the the conflict parameters and request the adaptive view proxy to switch notification mode  by the method depicted in FIG. C. In general, the switch request  can be invoked directly from an application or based on any policy. The adaptive view proxy  determines when the adaptive view object  may begin operating in the newly requested notification mode and sends a switch notification  to the adaptive view object  (an example of a method for maintaining the guarantees of the previous notification mode before switching to the new mode is depicted in , A, B, and C).",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 8B","FIGS. 11A"],"b":["840","400","845","855","860","850","865","870","11","11","875","823"]},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 8C","b":["100","880","885","9"]},{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 9A","FIGS. 6A and 6B","FIG. 7A","FIGS. 11A"],"b":["910","840","850","920","930","7","925","11","11"]},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 9B","b":["940","945","950"]},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 9C","b":["960","965","970","975"]},{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 10","b":["1010","1020","1030","1040","1050","1060","1070"]},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 11A","b":["1110","1113","1116","1120"]},"If the ViewTI at the last notified VT is not committed, the barrierVT field of the Adaptive View Proxy is set to the last notified VT value (step ). This barrierVT defines a point in virtual time after which the Adaptive View Proxy will behave in a pessimistic fashion and prior to which the Adaptive View will behave in an optimistic fashion. In other words, the stronger guarantees of a pessimistic view, such as monotonicity and losslessness of updates, are ensured after the BarrierVT. The current mode of the Adaptive View Proxy is then set to SWITCH (step ).",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 11B","b":["1130","1135","1140","7","1145","6"]},{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 11C","b":["1150","1153"]},"If the update VT is less than the barrier VT and the guess confirmation is a guess denied (step ), perform processing for an optimistic view (for example as depicted in FIG. B. If the update VT is not less than the barrier VT and the guess confirmation is a guess denied (step ), perform processing for a pessimistic view (for example as depicted in FIG. B).","In either case, if the guess was not denied and all guesses for the ViewTI corresponding to the update VT have been confirmed, set the commit status of the ViewTI to COMMITTED (step ). In this manner, the system guarantees that,the pessimistic view gets a notification of a consistent snapshot of attached model objects. Note that if all guesses are not confirmed, no further processing is required.","Next, the ViewTI VT is compared to the last notified VT of the Adaptive View proxy (step ). If the ViewTI VT equals the last notified VT, a commit notification is delivered to the Adaptive View (step ), the current mode is recorded as PESSIMISTIC (step ), and a switch notification is delivered to the Adaptive View (step ).","If the ViewTI VT immediately follows the last notified VT, the current mode is recorded as PESSIMISTIC (step ), a switch notification is delivered to the Adaptive View (step ), and all update notifications for committed ViewTIs which can be delivered are delivered to the Adaptive View, in sequential order of VTs (step ). In this manner, the monotonicity and losslessness guarantees are maintained. This process is identical to the process for step  in FIG. B.","If the ViewTI does not equal and does not immediately follow the last notified VT, no further processing is required (step ).","Next, in either case when the ViewTI equals or immediately follows the last notified VT, the VT of the latest ViewTI is recorded as the last notified VT field in the Adaptive View proxy (step ).",{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 12","b":["1290","153","1240","150","1210","1220","1230","1250","1260","1270"]},"A preferred embodiment of the present invention includes features implemented as software tangibly embodied on a computer program product or program storage device for execution on a processor (not shown) provided with the computing devices , ,  and . For example, software implemented in a popular object-oriented computer executable code such as JAVA provides portability across different platforms. Those skilled in the art will appreciate that other procedure-oriented and object-oriented (OO) programming environments, such as C and Smalltalk can also be employed.","Those skilled in the art will also appreciate that methods of the present invention may be implemented as software for execution on a computer or other processor-based device. The software may be embodied on a magnetic, electrical, optical, or other persistent program and\/or data storage device, including but not limited to: magnetic disks; DASD; bubble memory; tape; optical disks such as CD-ROMs; and other persistent (also called nonvolatile) storage devices such as core, ROM, PROM, flash memory, or battery backed RAM. Those skilled in the art will appreciate that within the spirit and scope of the present invention, one or more of the components instantiated in the memory of the computing devices , ,  and  could be accessed and maintained directly via disk (not shown), the network , another site, or could be distributed or replicated across a plurality of sites.","The invention, as it has been depicted by way of the preferred embodiment, provides the user with a collaboration system in which changes are propagated automatically and consistently in an adaptive manner. One having skill in the relevant art will recognize that equivalents, modifications and improvements may be made without departing from the spirit and scope of the invention as set forth in the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention will now be described in greater detail with reference to the appended drawings wherein:",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 8B"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 8C"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 9B"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 9C"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 11A"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 11B"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 11C"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
