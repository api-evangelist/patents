---
title: High volume earth observation image processing
abstract: The present invention is related to the processing of data, and more particularly to a method of and system for processing large volumes of Earth observation imagery data. A system for processing a large volume of Earth observation imaging data is described, comprising a computer including a visual display and a user interface, a plurality of servers, an image database storing said Earth observation imaging data as a plurality of separate image data files, and a network for interconnecting the computer, plurality of servers and image database. The plurality of servers is operable to process the separate data files in a distributed manner, at least one of the plurality of servers is operable to process the separate data files in a multiprocessing environment and at least one of the plurality of servers is operable to collate the processed separate data files into a single imaging result.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08768104&OS=08768104&RS=08768104
owner: PCI Geomatics Enterprises Inc.
number: 08768104
owner_city: 
owner_country: CA
publication_date: 20090107
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND TO THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EXEMPLARY EMBODIMENTS OF THE PRESENT INVENTION"],"p":["The present invention is related to the processing of data, and more particularly to a method of and system for processing large volumes of Earth observation imagery data.","Earth observation imagery data has been collected and analysed for decades and is an essential part of many natural resource management, geological and mineral exploration, agricultural management, environmental monitoring and aerial mapping systems, to name just a few applications. Whether the data is obtained from satellite, airborne sensing or other systems, and whether it consists of all or a combination of photogrammetry, hyperspectral, multitemporal, optical, thermal and microwave (and other similar systems) data, the problem with analysis is much the same: large volumes of data must be processed quickly and accurately, without distortion.","For example, remote sensing has been a central tool for environmental management and monitoring at local, regional and global scales. The need to monitor the habitat of endangered species, predict flood patterns, and evaluate the health of coral reef environments, has never been more acute. To address the increasingly complex web of influences on our ecosystems, today's environmental stakeholders are demanding current information, new analysis techniques and support for new sensors. These systems often need to integrate datasets from a variety of sources and apply best-practice analytical approaches, including for example: data fusion, spectral and spatial analysis, classification, thematic mapping, and integration with Geographic Information Systems (GIS).","There is therefore a need for an improved method of and system for processing large volumes of Earth observation imagery data with efficiency, accuracy, and the ability to integrate several different data systems together.","It is an object of the invention to provide an improved method of and system for processing large volumes of Earth observation imagery data which obviates or mitigates at least one of the disadvantages described above.","An architectural solution is described, for processing large volumes of Earth observation data (especially imagery) involving a number of data and computationally intensive processing steps. Processing requests can be made via a number of mechanisms including Open GIS Consortium (OGC) Web Processing Service requests or scheduled jobs and the results distributed via a number of mechanisms such as storage in a database accessible to other applications, forwarding as e-mail attachments or OGC compliant Web Coverage Servers. OGC establishes standards for the formatting of inputs, outputs and storage of data, allowing interoperability of various systems, but of course, any standard or proprietary formatting could be used.","The architecture mixes grid (distributed) computing and multiprocessing to achieve a dynamic, flexible system for high throughput using any number of compute servers. The system allows both Windows and Linux based compute servers to be mixed together and can be implemented easily within a typical networked environment without modification; that is, many grid or distributed systems have modified operating systems and\/or hardware and are dedicated to a small number of specific tasks, while the system described herein can operate on a generic computer or server with a simple client. Servers can differ in capability (speed or number of CPUs) and advantage can be taken of specialized processing hardware (e.g., Cell processors or Graphic Processing Units) that may be available on some servers to further improve throughput. A job control system is used to allow multiple jobs to be run simultaneously with the system automatically performing load balancing using distributed processing (between servers) and multiprocessing (within servers). This is enabled in part by the overall architecture of the system\u2014the system provides a list of jobs to be performed, and compute servers take the initiative to request jobs when they have capacity, rather than having a central control system which attempts to distribute jobs in an even way.","To deal with the high volume of data throughput required the architecture makes use of a Virtual Parallel File System distributed over the compute servers or a Database Management System (DBMS) that accepts remote connections or web services connected to archives of Earth Observation data.","Processing jobs scripts are implemented in a suitable computer language such as, but not limited to, Python, JAVA, C# or C++ which chain together processing modules (PCI Pluggable Functions) which perform the actual work. Whether the job is compiled ahead of time (e.g., C++) or interpreted at run time (e.g., Python) is dependent on the language chosen. In the preferred embodiment a variety of different scripting languages are used. In some cases, a particular scripting language might simply be more convenient or appropriate. Often, one of the primary considerations in selecting a suitable language is compatibility with related software that the job communicates with. For example, if a job needs to communicate with a third-party application written in C++, the simplest approach is likely to write the job in C++. It is an advantage of the system architecture that various scripting languages are easily accommodated.","The processing modules have a standardized application interface and the types of parameters are limited. This allows the application programming interface (API) to the processing modules and related programmer documentation to be automatically generated for different computer languages and programming environments. That is, a translator or \u201cinterface generator\u201d is written for each language. From the standard API, one simply runs the appropriate interface generator to translate the API and documentation to the particulars and syntax of a desired language. A new computer language is accommodated by implementing a new interface generator allowing the same module to be called from processing jobs written in different languages (e.g., Python, JAVA, C# or C++).","Where desirable, individual processing modules may be written to detect and take advantage of available specialized hardware on the compute servers such as multiple CPUs, a Graphical Processing Units (GPUs) or Cell processors to increase performance.","As processing jobs are run, the inputs and actions for each processing step are archived in the Central Job Database. This record becomes an audit history (meta data) for derived results and is optionally delivered with the final results, typically in XML form adhering to the ISO 19139 standards or via an OGC Catalogue Service. This meta data allows each user to check how each product was derived and to allow identification of results that need to be regenerated should any of the original input data be modified in the future (for example\u2014if a more accurate elevation model becomes available) or one of the processing steps is implemented more accurately.","Two processing examples, image correction\/mosaicing and image feature extraction, are described in the context of the architecture.","This summary of the invention does not necessarily describe all features of the invention.","The present invention will be further illustrated by way of the following examples.","Parallel Architecture Framework","A processing software architecture is used which combines two levels of parallelism: distributed processing of individual images on individual compute servers, while on each individual compute server processing modules making use of available hardware to quickly process the image. The processing on individual compute servers could include parallelism if a multi-core processor is available, use of a Graphics Processing Unit (GPU) or Cell Broadband Engine processor if available. A detailed description of how processing modules make use of available hardware on a particular compute server is provided in the section titled \u201cProcessing Modules\u201d.","The processing architecture is designed to work in a heterogeneous network (e.g., using both Windows and Linux servers) without modification to the operating systems. As noted above, this is in contrast to many existing systems which are inflexible and dedicated to a limited number of processing tasks. A small job control application is installed on each compute server  which monitors the pending job requests and initiates jobs on that compute server . The job control application can be configured, for example, to utilize only a portion of the available resources on the compute server  or only utilize the compute server  at particular times. This allows processing to proceed on existing networks of computers with minimal modification and the processing architecture can co-exist with other applications. A database, for example Oracle or PostgreSQL, may be used as the central communication and co-ordination mechanism for all job control applications running on compute servers  in the network. As each independently running job control application initiates a job, accepts the completion of a job, detects failure of a job or collects meta data on a job, this information is updated in the Central Job Database . At any point the Central Job Database  can be queried to obtain information on the status of a particular job and its audit history.","The architecture allows multiple (and\/or different) processing jobs to be run simultaneously. On each compute server  a small configuration file tells each job control application how many jobs can be run on that compute server . For example, if a particular compute server  has four CPUs then three jobs could be run simultaneously, while another compute server  having only one CPU may be configured to run two jobs simultaneously. This allows every compute server  to potentially have a different number of CPUs with the job control application automatically preventing the compute server  from overloading. Because compute servers  are prevented from overloading this leads to implicit load balancing between compute servers . Within a particular compute server  the jobs are automatically load balanced between CPUs using the existing symmetric multiprocessing capability that is part of the Windows or Linux OS. Additionally, the small configuration file provides information on when the compute server  is allowed to accept jobs. For example, users' desktop computers may be used as compute servers  between 8 pm and 5 am, after regular office hours. The job control application checks periodically to see whether the small configuration file has been modified and if so, re-reads it, to obtain updated configuration information. This allows dynamic reconfiguration of the job control applications and thus dynamic reconfiguration of the overall distributed computing environment. The configuration file for each compute server  is provided by the system manager at the time the compute server  is added to the system based on the capabilities of the particular compute server .",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 1","b":["215","105","110","115","210","125","210","215","130"]},"When a job is to be run (a script for example), it is typically launched as a separate process on the compute server , and the running job count will be incremented by one . The Central Job Database  is then updated on the job being initiated and running , and control returns to the beginning of the routine .","Each job is launched as a separate process on a given compute server , so there could be several jobs running at the same time on a single server. When each job script is initiated  it calls processing modules which access image data and related data, taking advantage of any multi-processing capabilities of the operating system . Queries are also performed to determine whether a Graphics Processing Unit (GPU), multiple cores, and\/or Cell processor is available. As the job is run, processed image data is stored in the image database (or VPFS) . Processing history data and\/or metadata is also sent to the Central Job Database to update the job status.","The compute server  will recognize that this job has been complete when the \u201crunning jobs done?\u201d query is made at step , so the compute server  is free to request additional jobs.","Since transparent access to databases and data files is inherent in the operation of most networks, compute servers  can be located on anywhere on a network, either locally (e.g., intranet) or the Internet. For example, processing can be performed simultaneously on a local network of compute servers , along with remote compute servers  that are rented from one or more third parties.","Data Management and Optimization","A major problem in processing large amounts of imagery is data throughput and management of the location of images to minimize network traffic. The processing architecture preferably uses either a database for data storage and management, or a parallel virtual file system (PVFS) which makes local file systems on each compute server appear to be one global file system.","If a PFVS is used then each compute server  can be part of the PVFS. The random distribution of data on the PFVS helps to balance the overall network traffic and disk access. While this approach does not guarantee minimal network traffic it does, on average, provide good performance and removes the complexity of trying to directly optimize data access, thus making it much easier to develop processes for creating new products.","A Central Job Database  is used to hold information relating to the running and tracking of jobs status and history and is accessed by all the compute servers . The Central Job Database  is typically implemented using any relational database that provides record locking to manage concurrent access, for example PostgreSQL or Oracle. A custom or proprietary database could also be used though it would be a great deal of work to develop such a system. The Central Job Database  is typically independent of any database used to hold imagery data.","Job Description","Jobs may be written as scripts, in languages such as Python, JAVA, C# or C++, which call a sequence of processing modules (PMs) to take input data (e.g., images), process it, and create new output products. Since there are many different processing modules available many different kinds of jobs can be created.","As shown in the block diagram of , a request to run a particular job  is put in a queue in a Central Job Database . When a compute server  becomes available (and there may be several on the network as show in ), its job control application  queries the Central Job Database  for a new job to run. The job control application , with an associated configuration file, schedules jobs for the particular compute server to run. Each compute server  may be configured with different numbers of CPU cores and add on acceleration hardware such as a GPU or Cell Processor. Those jobs access image data from the image database , a VPFS or by remote access via the web. When the jobs have been processed, the processed data is returned to the same image database . The compute servers  will also send status, history and metadata information back to the Central Job Database .","A script for a job may indicate that parts of the processing can be independently performed using other jobs. For example: a job to ortho-correct one hundred images and then mosaic them together could initiate one hundred small jobs, each of which ortho-corrects a single image. When these are all completed, the original job mosaics them all together. The original job can initiate these \u2018sub\u2019 jobs by directly inserting new job requests into the queue in the Central Job Database  and then monitoring the Central Job Database  until all the requested jobs are complete. Since there may be many compute servers  in a cluster, this mechanism allows the sub-jobs to be spread automatically over the entire cluster as compute servers  become available.","Processing Modules","The actual processing of data is accomplished by processing modules typically written in C or C++. A system may consist of many processing modules such as modules to filter images, collect image ground control points, perform image classification or ortho-correct an image. By scripting together different processing modules a wide variety of outputs can be created. A short list of exemplary processing modules is provided in the Table 1\u2014List of Processing Modules. These represent typical modules to process images in the areas of: geometric (and ortho) correction, classification, segmentation, SAR and Polarimetric SAR processing, filtering, elevation processing and watershed analysis. Of course, many other processing modules are known and\/or could be used or developed. The invention is not limited by the nature of the processing modules themselves. There are three desirable attributes for processing modules within the context of the system architecture:","1) a consistent application interface which is available in a variety of computer languages (such as Python, JAVA or C++);","2) the ability of a processing module to automatically take advantage of the available hardware of the compute server on which it is run; and","3) availability in both Windows and Linux.","A module that has these attributes means that a script written for a particular processing job (e.g., in Python) could be run on either a Linux or Windows system and processing would automatically take best advantage of underlying hardware. For example, a cluster of compute servers  may include both Linux and Windows servers, each with a different number of CPU cores, some even having extra hardware accelerators such as GPUs or Cell processors. When processing images in parallel across this cluster, the same script could be used on all compute servers  and automatic use would be made of the available hardware.","Individual processing modules may use different strategies in using the underlying hardware to improve performance. For example: a numerically floating point intensive routine may first check for a GPU and if this is not available then fall back on using parallelism using multiple CPUs if available. Another processing module may check for, and use, a Cell processor if available and fall back to a single CPU otherwise single parallelism may not be inherent in the algorithm. Depending on the algorithm being implemented in a particular processing module, different hardware optimization strategies are employed. It is a straightforward matter to include lines of code in a processing module to perform these checks and take advantage of the efficiencies that the underlying hardware provides.","Processing modules are written such that they can transparently accept a variety of data input sources including: local files, network files, databases, passed memory data structures or data from standardized web services. For example: a job script performing ortho correction may have a processing module that can obtain elevation data from a local file and should that not be available falls back to utilizing a web service providing elevation data for the entire planet (albeit perhaps with lower quality and slower access).","Service Oriented Architecture","The system is preferably implemented using a Service Oriented Architecture (SOA). That is, the requester of a processing job to be run does not need to know anything about the underlying architecture of the system, the distributed processing or computer languages used to implement jobs and processing modules. Requests for processing jobs are also preferably accepted via standard protocols, such as Open GIS Consortium Web Processing Services or SOAP.","Requests for processing can either be by setting parameters to existing job scripts held in the Central Job Database  or the requester can directly submit custom scripts (which utilize processing modules available on the system) which will be run by the system. Scripts can be generated in any manner, such as being written using a GUI or wizard, customized, pre-existing, transmitted by email, etc.","Thus to summarize, scripts are generated in some manner at step  of , and queued  in the Central Job Database . Processing jobs can then be executed  on compute servers , via scripts calling processing modules. These processing modules access image and related data from the local image database , VPFS or remote access via the Web, and return processed data for storage . The compute servers  also update the Central Job Database  on the work that has been done by transmitting corresponding metadata.","The output data may then be displayed, transferred\/stored in other memory devices, and\/or undergo additional processing.","Processing Examples Using the Software Architecture","Image Ortho-Correction and Mosaicing","In this example one thousand satellite images need to be ortho-corrected to precise Earth co-ordinates and then mosaiced (stitched) together into a single, large, seamless image covering a very large area. While image ortho-correction is a known technique the overall example is novel in performing the ortho-correction in parallel on a heterogeneous network of compute servers (possibly employing multiple cores or specialized hardware) along with the acquisition of Ground Control Points (GCPs) and Tie Points (TPs) from multiple sources, and the method of computing the colour balancing and cutlines.","The block diagram of  presents an exemplary system for affecting this process, while  presents an exemplary flow diagram.","The process begins with the collection of Earth image data from some source , such as from a local source or from an Earth Observation data vendor archive, accessed via the web. These images are generally stored in data files whose sizes are kept down to a point that is practical for a typical computer. As a result, it is common to require a large number of separate files to perform an analysis. All of these images are then copied to a database such as Oracle 10g or a PVFS.","The images are distributed over the available compute servers to acquire ground control (GCPs) and tie-points (TPs) between overlapping images . Ground control points can be obtained from multiple sources such as existing ortho-corrected imagery, image chip databases or geocoded features represented by vectors (such as roads or lake polygons), using known techniques. Sources can be either local to the network or accessed via standardized web services from data vendors. Tie-points are obtained by matching points on overlapping images again, using known techniques. The GCPs from multiple sources are merged together to optimize them for accuracy and distribution over the image. Acquired GCPs and TPs for each image are stored in a central location such as in the Image Database .","All the GCPs and TPs are simultaneously used in a block model calculation to create an optimized correction model for each image, using a known technique. A large single calculation (again, a known calculation) is then performed on all of block models, with the result being an optimized model for each image. The optimized models both correct to ground co-ordinates and minimize errors between overlapping images. Because it is a large, single calculation, it is more efficient to compute them all together, on a single compute server. The GCPs and TPs are used as inputs to the optimized correction model and then are no longer used.","The images are then ortho-corrected using a known algorithm , except that the task is distributed over all the available compute servers . Ortho-correction is the correction of terrain-induced distortion.","Within each compute server  the original image is requested from the image database or PVFS and the ortho-correction is speeded up by utilizing any multiple cores or specialized processors (such as the Cell processor or GPU) that are available on that particular compute server . To reduce data overhead, information (such as digital elevation data or DEMs) which are of reasonable size and do not change from processing job to processing job, are stored locally on each compute server . The resulting ortho-corrected image is stored in the image database or PVFS.","From the ortho-corrected images the cutline and colour balancing is computed . This is typically performed on a single compute server  as shown in , because all the information from all the images needs to be considered simultaneously. Colour balancing may use a number of steps, for example, as shown in the flow chart of :","1) radiometric normalization  which attempts to remove most of the differences between images using known physical properties, such as sensor calibration and top of atmospheric radiance corrections based on sun intensity;","2) remaining colour differences are removed by gathering statistical differences  between images in overlapping areas, eliminating anomalies (such as clouds and shadows) via statistical methods (such as Thiel-Sen robust regression); and then","3) performing a block adjustment using these statistics to minimize colour differences .","The resulting colour balanced data is then returned to the image database or PVFS .","Cutlines (i.e., the actual seam lines between images) are computed to minimize apparent differences by following natural features in the image (such as rivers or roads). Techniques are known for performing these computations. The colour balancing results and cut lines are stored in the image database or PVFS so operations in following steps can use them.","And finally, the generation of mosaic tiles, based on cutlines, colour balancing and ortho-corrected images, is distributed across all compute servers . Techniques are known for performing these computations. Resulting tiles are stored in the image database, PVFS or directly in the final delivery location or media.","Image Feature Extraction","In this example a single image is classified (interpreted) by using a number of different methods in parallel and the results are merged into a single final result as shown in . The processing architecture described in this document allows many different classifiers to be simultaneously run in a reasonable length of time, allowing novel computing intensive approaches to be taken.","As with the process of , described hereinabove, the process begins with the collection of Earth image data from some source , such as from a local source or from an Earth Observation data vendor archive, accessed via the web. These images are collected and stored in a number of data files in the image database .","A different classification method is then initiated  on each compute server . Candidate classification methods could include: Maximum likelihood classification, Neural Networks, Minimum distance, KNN, or K-Means or others depending on specific circumstances or the knowledge of the implementor. While each classification method runs on a different compute server  each compute server  may have multiple cores which can run portions of the classification in parallel. Each classification method may utilize different sets of ancillary data obtained as part of its classification process, either obtained locally or via the web. The results of each classification are stored in the image database  or PVFS.","Once all the classification methods are complete a single interpretation is created using a \u2018voting\u2019 system and knowledge rules to create a final result . The flow chart of  presents an exemplary method of performing this \u2018voting\u2019 process. When the various classification methods have been completed , the system uses knowledge rules to limit the classifiers to those which are most relevant to the current analysis, or gives greater weight to more significant classifiers . This step may be performed before or after the voting step depending on the nature of the knowledge rules. Of course, several knowledge rules may be applied, some before, and some after the voting step. For example, if there is previous knowledge that a particular classifier has extremely high accuracy for a particular class (e.g., water) then when that result is obtained for a particular pixel it may over-rule the result from the voting system (i.e. the knowledge rule being applied after the voting step). As another example, other knowledge rules can be applied such as agricultural crops may only exist in known farm boundaries in which case the voting may be restricted to methods known to be good for agricultural crops (i.e. the knowledge rule being applied before the voting step).","The voting system then compares the result from each classifier, for each image pixel, and picks the result which was most common . By using several different interpretation methods (none of which is best in all circumstances) it is possible to create a result which is better than any single method based on a weighted consensus between many methods.","The optimal result is then stored  in the image database  and possibly displayed or output in some manner , for example on a personal computer having a visual display and user interface.","Conclusions","The present invention has been described with regard to one or more embodiments. However, it will be apparent to persons skilled in the art that a number of variations and modifications can be made without departing from the scope of the invention as defined in the claims. For example:","1) the grid of compute servers could be made up systems running operating systems such as UNIX (using SUN, SGI or IBM processors) instead of Windows or Linux on an Intel based processor;","2) high speed storage could be implemented via other methods such as solid state devices (e.g., based on RAM or Flash RAM) or Storage Area Network devices instead of a Virtual Parallel File System or a Database;","3) while black and white or colour imagery data is most commonly used the scope of the invention includes any raster data sets including: multispectral imagery, hyperspectral imagery, Synthetic Aperture Radar imagery, Polarimetric Radar imager, and spatial Raster GIS information; and\n\n4) Earth observation imagery sources can include those collected from space or airborne sensors.\n","The method steps of the invention may be embodied in sets of executable machine code stored in a variety of formats such as object code or source code. Such code is described generically herein as programming code, or a computer program for simplification. Clearly, the executable machine code or portions of the code may be integrated with the code of other programs, implemented as subroutines, plug-ins, add-ons, software agents, by external program calls, in firmware or by other techniques as known in the art.","The embodiments of the invention may be executed by a computer processor or similar device programmed in the manner of method steps, or may be executed by an electronic system which is provided with means for executing these steps. Similarly, an electronic memory medium such computer diskettes, CD-Roms, Random Access Memory (RAM), Read Only Memory (ROM) or similar computer software storage media known in the art, may be programmed to execute such method steps. As well, electronic signals representing these method steps may also be transmitted via a communication network.","All citations are hereby incorporated by reference.",{"@attributes":{"id":"p-0068","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["NAME","DESCRIPTION"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["adem","Airphoto Automatic DEM Extraction"]},{"entry":["aepipro","Airphoto Epipolor Projection"]},{"entry":["ARI","Image Channel Arithmetic"]},{"entry":["ATCOR3","Atmospheric Correction using Elevation Data"]},{"entry":["ATCOR3_T","Surface Temperature using Elevation Data"]},{"entry":["autochip","Automatic Chip Matching for GCP collection"]},{"entry":["avg","Unsupervised Texture Segmentation"]},{"entry":["cdeosat","CD EOSAT Fast Format"]},{"entry":["cdirss","CD IRS Super Structure Format"]},{"entry":["Cdland7","CD LANDSAT 7 Format"]},{"entry":["cdlandb","CD TM Brazilian Format"]},{"entry":["cdsar","CD ERS\/PALSAR\/RADARSAT LGSOWG Format"]},{"entry":["cdsat","CD ERS\/RADARSAT CCT Format"]},{"entry":["cdspot","CD SPOTIMAGE SPOT Format"]},{"entry":["chipext","Chip Extraction"]},{"entry":["chipmat","Chip Match"]},{"entry":["CIM","Create Image Database File"]},{"entry":["CLS","Cluster Definition Classification"]},{"entry":["context","Contextual Classification"]},{"entry":["CONTOUR","Contour Generation from DEM"]},{"entry":["CSG","Classifier Signature Generator"]},{"entry":["DECORR","Decorrelation Stretch"]},{"entry":["DIM","Delete Image Database File"]},{"entry":["DRAIN","Drainage Basin from Elevation Data"]},{"entry":["endmemb","Find a Set of Endmember Spectra"]},{"entry":["EXPORT2KML","Export to Google Earth KML or KMZ"]},{"entry":["FAV","Averaging (Mean) Filter"]},{"entry":["FED","Edge Detection Filter (up to 33 \u00d7 33)"]},{"entry":["fefrost","Enhanced Frost Filtering"]},{"entry":["felee","Enhanced Lee Adaptive Filtering"]},{"entry":["FERODEH","Erode Holes Filter (up to 1001 \u00d7 1001)"]},{"entry":["FEXPORT","Export To Foreign File"]},{"entry":["FFREQ","Frequency Domain Image Filter"]},{"entry":["ffrost","Frost Adaptive Filtering"]},{"entry":["fftmpoly","Extract GCPs by image-polygon matching."]},{"entry":["fftmvec","Extract GCPs by image-vector matching."]},{"entry":["FGA","Gaussian Filter (up to 33 \u00d7 33)"]},{"entry":["fgamma","Gamma Map Filtering"]},{"entry":["FIMPORT","Import Foreign File"]},{"entry":["fkuan","Kuan Filtering"]},{"entry":["fle","Lee Adaptive Filtering"]},{"entry":["FME","Median Filter (up to 7 \u00d7 7)"]},{"entry":["FMO","Mode Filter (up to 7 \u00d7 7)"]},{"entry":["FPAR","Fraction of Absorbed Photosynthetically Radiation"]},{"entry":["FPR","Programmable Filter (up to 33 \u00d7 33)"]},{"entry":["FPRE","Prewitt Edge Filter (up to 33 \u00d7 33)"]},{"entry":["FRD2P","Reduction to Pole Filter"]},{"entry":["FSHARP","Sharpening Filter (up to 33 \u00d7 33)"]},{"entry":["FSOBEL","Sobel Edge Filter (up to 33 \u00d7 33)"]},{"entry":["Fspec","SAR Speckle Filtering"]},{"entry":["FTF","Frequency Transforms Forward"]},{"entry":["FTI","Frequency Transforms Inverse"]},{"entry":["Fusion","Data Fusion of Two Input Images"]},{"entry":["fuz","Unsupervised Fuzzy Clustering"]},{"entry":["FUZCLUS","Fuzzy K-Means Clustering"]},{"entry":["GCII","Image to Image GCP Collection"]},{"entry":["GCIM","Image to Map GCP Collection"]},{"entry":["GCIT","Image to Terminal GCP Collection"]},{"entry":["GCIV","Image to Vector GCP Collection"]},{"entry":["gcpelevGCP","Elevations from a DEM"]},{"entry":["gcppro GCP","Transformed by Projection"]},{"entry":["gcprefn GCP","Refinement"]},{"entry":["genclut","Generate a Spectral Line Curvature Correction LUT"]},{"entry":["genrlut","Generate an At-Sensor Radiance LUT"]},{"entry":["GRDINT","Vector Grid Interpolation"]},{"entry":["GRDPNT","Point Coverage Gridding"]},{"entry":["GRDPOL","Polygon Coverage Gridding"]},{"entry":["HIS","Histogramming Database Image"]},{"entry":["histex","Histogram-based Texture Measures"]},{"entry":["HMM","Histogram Migrating-Means Clustering"]},{"entry":["HOM","Homogeneous Area Classification"]},{"entry":["HSG","Histogram Signature Generation"]},{"entry":["i2sp","Output Band Vectors as Image Spectra."]},{"entry":["idint","Inverse Distance Interpolation"]},{"entry":["IHS","RGB to IHS Conversion"]},{"entry":["IIIBIT","Database Image Transfer Under Bitmap"]},{"entry":["Imerge","Merge Image Files"]},{"entry":["IND","Index Analysis"]},{"entry":["IPG","Image Polygon Growing"]},{"entry":["ISOCLUS","Isodata Clustering"]},{"entry":["KCLUS","K-Means Clustering"]},{"entry":["KNN","K-Nearest Neigbour Classification"]},{"entry":["KRIGING","Point Interpolation Using Kriging"]},{"entry":["LAI","Leaf Area Index Model"]},{"entry":["LRP","Image Line Replacement"]},{"entry":["LUT","Image Enhancement via Lookup Table"]},{"entry":["mal","Mallat Wavelet Transformation"]},{"entry":["MASKING","Calculate Haze and Cloud Mask"]},{"entry":["MAT","Matrix Analysis"]},{"entry":["MATCH","Histogram Matching LUT"]},{"entry":["METASET","Set a Metadata Value"]},{"entry":["MINDIS","Minimum Distance Classifier"]},{"entry":["MLC","Maximum Likelihood Classifier"]},{"entry":["Mnfnr","Max. Noise Fraction Based Noise Removal"]},{"entry":["MODEL","Modelling Program"]},{"entry":["MOSAIC","Image Mosaicking"]},{"entry":["MTE","Martin-Taylor Transformation"]},{"entry":["NDVI","Compute NDVI from AVHRR Data"]},{"entry":["NGCLUS2","N-bit Narendra-Goldberg Clustering"]},{"entry":["nnclass","Neural Network Classification"]},{"entry":["nnint","Natural Neigbour Interpolation"]},{"entry":["Nntrain","Neural Network Training"]},{"entry":["ORARASLOAD","Export Raster To ORACLE DATABASE"]},{"entry":["ORAVECLOAD","Export vectors To ORACLE DATABASE"]},{"entry":["ortho","Orthorectification"]},{"entry":["OVL","Overlay Analysis"]},{"entry":["PCA","Principal Component Analysis"]},{"entry":["Pansharp","Pan sharpen an Image"]},{"entry":["PRX","Proximity Analysis"]},{"entry":["Psboxcar","POLSAR Boxcar Filter"]},{"entry":["Pscc","Corr. Coeff. for Two POLSAR Elements"]},{"entry":["psclopot","Cloude-Pottier Classification"]},{"entry":["pseaba","Entropy, A-angle, B-angle, and Anisotropy"]},{"entry":["psfredur","Freeman-Durden Unsup. Classification"]},{"entry":["PSG","Perspective Scene Generation"]},{"entry":["Psinang","Incident Angle Map"]},{"entry":["Psinten","POLSAR Element Intensity"]},{"entry":["psintrat","Intensity Ratio of Two POLSAR Elements"]},{"entry":["pspedht","Polarization Response Pedestal Height"]},{"entry":["Psphdiff","Phase Difference of POLSAR Elements"]},{"entry":["Pspoldis","Polarimetric Discriminators"]},{"entry":["pspolfil","POLSAR Speckle Filter"]},{"entry":["pspolsyn","General POLSAR Backscatter Synthesis"]},{"entry":["Pspolsync","Contrast Maximized Backscat. Synthesis"]},{"entry":["pspolsynr","Target Maximized Backscatter Synthesis"]},{"entry":["pssscm","Symmetric Scattering Charact. Method"]},{"entry":["psswis","Supervised Wishart Classification"]},{"entry":["Pstotpow","Total Power"]},{"entry":["psuswis","Unsupervised Wishart Classification"]},{"entry":["psvanzyl","Unsupervised van Zyl Classification"]},{"entry":["pswhite","Whitening Filter Target Detection"]},{"entry":["Pyramid","Build Image Overview Pyramids"]},{"entry":["rbfint","Radial Basis Function Interpolation"]},{"entry":["regpro","Image Registration and Projection"]},{"entry":["REL","Shaded Relief from Elevation Data"]},{"entry":["rsdem","Radarsat Automatic DEM Extract"]},{"entry":["rstr","SAR Image Contrast Stretch"]},{"entry":["Rtcsigm","SAR Backscatter with Terrain Correction"]},{"entry":["RTV","Raster to Vector Conversion"]},{"entry":["sam","Spectral Angle Mapper"]},{"entry":["Sarbeta","Generate Radar Brightness"]},{"entry":["Sarclass","Classify Segmented SAR Image"]},{"entry":["sarincd","SAR Incidence Angle Estimation"]},{"entry":["sarseg","Segment Single Channel SAR image"]},{"entry":["sarsigm","Generate Radar Backscatter"]},{"entry":["sartex","SAR-specific Texture Measures"]},{"entry":["SAVI","Soil Adjust Vegetation Index"]},{"entry":["sdem","Satellite Automatic DEM Extract"]},{"entry":["SEED","Automatic Watershed Seed Starter"]},{"entry":["Sepipro","Satellite Epipolor Projection"]},{"entry":["shftcw","Shift Centre Wavelength Values"]},{"entry":["SHRINK","Shrink Areas in Theme Channel"]},{"entry":["sieve","Sieve Filter (Class Merging)"]},{"entry":["SIGJPL","Display Polarization Signature"]},{"entry":["SIGMERG","Classifier Signature Merging"]},{"entry":["SIGSEP","Classifier Signature Separability"]},{"entry":["slc2img","Convert SLC to Image"]},{"entry":["slccor","Apply a Spectral Line Curvature Correction LUT"]},{"entry":["SLP","Slope of Elevation Data"]},{"entry":["smodel","Satellite Model Calculation"]},{"entry":["smspec","Smooth Spectra"]},{"entry":["smodel","Satellite Model Calculation"]},{"entry":["smspec","Smooth Spectra"]},{"entry":["solarzaz","Solar-zenith and Solar-azimuth Calculator"]},{"entry":["sortho","Satellite Image Orthorecification"]},{"entry":["sp2rt","Convert a Spectrum to a Rad. Trans."]},{"entry":["spadd","Spectrum Record Addition"]},{"entry":["spbanal","Spectral Band Analysis"]},{"entry":["spconv","High to Low Resolution Spectral Convolution"]},{"entry":["spconvf","High-to-Low Filter Convolution of Spectrum"]},{"entry":["spconvg","High-to-Low Gaussian Convolution of Spectrum"]},{"entry":["spconvp","Convolve Spectra With Response Profiles"]},{"entry":["spfit","Fit Spectrum to Reference Spectrum"]},{"entry":["Spfunc","Spectral Algabraic and Trig Functions"]},{"entry":["sphull","Create Segmented Upper Hull Continuum"]},{"entry":["spimari","Spectrum Image Arithmetic Operations"]},{"entry":["spmod","Spectrum Library Record Modification"]},{"entry":["spnorm","Spectrum Normalization"]},{"entry":["Spunmix","Spectral Linear Unmixing"]},{"entry":["srortho","Satellite Radar Image Ortho."]},{"entry":["srtogr","Slant Range to Ground Range Conversion"]},{"entry":["SST","Sea Surface Temperature from AVHRR Data"]},{"entry":["strpcor","Stripe Correction"]},{"entry":["SYNTH","Synthesize Arbitrary Polarization Image"]},{"entry":["tex","Texture Analysis"]},{"entry":["THR","Thresholding Image to Bitmap"]},{"entry":["VDEMINT","Grid DEM from Vector Layers"]},{"entry":["VECREG","Vector Registration (Warping)"]},{"entry":["video","Digital\/Video Camera Parameters"]},{"entry":["WTRSHED","Watersheds from Elevation Data"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing and other features and advantages of the invention will be apparent from the following, more particular description of exemplary embodiments of the invention, as illustrated in the accompanying drawings. In the drawings, like reference numbers generally indicate identical, functionally similar, and\/or structurally similar elements. A preferred exemplary embodiment is discussed below in the detailed description of the following drawings:",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
