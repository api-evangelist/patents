---
title: Method and apparatus for hardware acceleration of clipping and graphical fill in display systems
abstract: Embodiments of the present invention are directed to a method and apparatus for hardware acceleration of clipping and graphical fill in display systems. In one embodiment, all display data is presented to the display system. The display system uses its hardware to clip the undesired data, if necessary, and display the desired data. If a sufficient amount of display data has the same value, the display system uses its hardware to fill the appropriate areas using the shared value. In one embodiment, the display system has one or more accelerating registers. In one embodiment, one or more accelerating registers are fill registers. As display data is read from memory, some of the information's color data is classified by the fill registers. In another embodiment, one or more accelerating registers are clipping registers. As display data arrives from each source, the information's display location is classified by the clipping registers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07002599&OS=07002599&RS=07002599
owner: Sun Microsystems, Inc.
number: 07002599
owner_city: Santa Clara
owner_country: US
publication_date: 20020726
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["1. Field of the Invention","The present invention relates to the field of computer displays, and in particular to a method and apparatus for hardware acceleration of clipping and graphical fill in display systems.","Sun, Sun Microsystems, the Sun logo, Solaris and Java are trademarks or registered trademarks of Sun Microsystems, Inc. in the United States and other countries.","2. Background Art","In a computer system, a computer may receive data to present to the user using a display device (e.g., a monitor) from multiple sources. For example, a video window with streaming video may be supplied by one source, and a text window may be supplied by another source. The source may be located at the computer attached to the display device, or it may be located at another computer. Typically, in a thin client architecture, no display information source is located at the terminal attached to the display device.","In some instances, the regions of display for two sources may overlap. Display data for the covered portions of the video window must be discarded, or clipped, rather than displayed. In other instances, large regions of the display data contain the same value. For example, a text window with a white background and little or no text, has large regions where the display data value is white. In prior art solutions, software systems are used to clip unneeded display data and to fill same-valued regions. However, software clipping and filling is slow and inefficient. This problem can be better understood with a discussion of display systems in a multi-tier application architecture.","Multi-Tier Application Architecture","In the multi-tier application architecture, a client communicates requests to a server for data, software and services, for example, and the server responds to the requests. The server's response may entail communication with a database management system for the storage and retrieval of data.","The multi-tier architecture includes at least a database tier that includes a database server, an application tier that includes an application server and application logic (i.e., software application programs, functions, etc.), and a client tier. The data base server responds to application requests received from the client. The application server forwards data requests to the database server.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1","b":["100","110","110"]},"Further application functionality is provided by application logic managed by application server  in application tier . The apportionment of application functionality between client tier  and application tier  is dependent upon whether a \u201cthin client\u201d or \u201cthick client\u201d topology is desired. In a thin client topology, the client tier (i.e., the end user's computer) is used primarily to display output and obtain input, while the computing takes place in other tiers (i.e., away from the thin client). A thick client topology, on the other hand, uses a more conventional general purpose computer having processing, memory, and data storage abilities. Database tier  contains the data that is accessed by the application logic in application tier . Database server  manages the data, its structure and the operations that can be performed on the data and\/or its structure.","Application server  can include applications such as a corporation's scheduling, accounting, personnel and payroll applications, for example. Application server  manages requests for the applications that are stored therein. Application server  can also manage the storage and dissemination of production versions of application logic. Database server  manages the database(s) that manage data for applications. Database server  responds to requests to access the scheduling, accounting, personnel and payroll application's data, for example.","Connection  is used to transmit data between client tier  and application tier , and may also be used to transfer the application logic to client tier . The client tier can communicate with the application tier via, for example, a Remote Method Invocator (RMI) application programming interface (API) available from Sun Microsystems\u2122. The RMI API provides the ability to invoke methods, or software modules, that reside on another computer system. Parameters are packaged and unpackaged for transmittal to and from the client tier. Connection  between application server  and database server  represents the transmission of requests for data and the responses to such requests from applications that reside in application server .","Elements of the client tier, application tier and database tier (e.g., client , application server  and database server ) may execute within a single computer. However, in a typical system, elements of the client tier, application tier and database tier may execute within separate computers interconnected over a network such as a LAN (local area network) or WAN (wide area network).","Display Systems","Display systems in the multi-tier application architecture are used to arrange display information for presentation to a user on a display device (e.g., a monitor). Typically, a display system comprises a display memory and a display controller in the client tier . The display memory is typically dynamic random access memory (DRAM) and contains pixel color information for each pixel of the display device. The display controller updates the data in the display memory and retrieves data from the display memory to send to the display device.","Frequently, the desired display areas of two display data sources overlap. For example, video data may be transmitted to a client terminal from two different data sources in a thin client architecture and the windows displaying the video data may be overlapping. Since both windows cannot write to the display memory for the overlapping pixels, the video information for the overlapping area of the rear window must be clipped. Furthermore, any portions of the video window which is off the screen must be clipped.","Clipping is typically performed by software. The software saves the desired display data and discards the rest. Then, only the desired display data is passed on to the display system for eventual display. In some systems, the clipping software runs on a different computer from the computer (of the client tier ) directly attached to the display system.","Typically, thousands, millions or even billions of color value possibilities are available for storage in each display memory location. Frequently, however, the same value is found in many locations. For example, displaying a graphic of a stop sign results in a large number of the display memory locations storing the same value for red. Individually reading and writing each display memory location having the same value is inefficient. In some computer systems, software is used to quickly fill display memory locations with the same value.","Clipping in Thin Client Architectures","In some prior art thin client architecture systems, display data is clipped using software before it is transmitted to the client terminal. However, this approach is difficult and inefficient to coordinate when display data is transmitted from separate source locations. The approach encounters additions problems when display data is being multicast to many client terminals. The clipping may be different for each client terminal receiving the display data, so it is inefficient for the data source to perform clipping before transmitting the data to each client terminal.","Embodiments of the present invention are directed to a method and apparatus for hardware acceleration of clipping and graphical fill in display systems. In one embodiment of the present invention, all display data is presented to the display system. The display system uses its hardware to clip the undesired data, if necessary, and display the desired data. Additionally, if a sufficient amount of display data has the same value, the display system uses its hardware to fill the appropriate areas using the shared value.","In one embodiment, the display system has one or more accelerating registers. In one embodiment, one or more accelerating registers are fill registers. As display data is read from memory, some of the information's color data is classified by the fill registers. Pixels which have the same value as a value stored in a fill register are read from the fill register rather than from display memory.","In another embodiment, one or more accelerating registers are clipping registers. As display data arrives from each source, the information's display location is classified by the clipping registers. Only pixels which are calculated to be visible by the clipping registers is written to memory for later display.","In one embodiment, the display system has an extra amount of memory, termed \u201cfeature memory.\u201d In one embodiment, there is a corresponding data location in the feature memory for each pixel in the display memory. Different embodiments have a different number of bits of memory, n, for each data location in the feature memory. As a result, there are two to the nth power different available values which can be stored in each data location. Some values correspond to fill registers containing shared color values. Other values correspond to display contexts. In one embodiment, there are three bits of memory for each data location, resulting in eight possible fill registers and display contexts combined.","In one embodiment, the feature memory is comprised of dynamic random access memory (DRAM).","In one embodiment, a display command is issued to the display system. The command originates from a server. The server is located away from the display system. The server and the display system communicate via a network. The network may comprise a LAN (local area network) or WAN (wide area network). In another embodiment, the display system is located within a thin client. The hardware for clipping and filling is located within the display system.","In one embodiment, commands issued to the display system contain an indicator to indicate either with which fill register the command is associated or within which display context the command should be executed. When a command contains display information for a pixel, the display context for the pixel stored in the feature memory is compared to the indicator of the command. If the display context is equal to the context indicator, the command is executed for the pixel. If the display context is not equal to the context indicator, the display information for the pixel is clipped. In some instances, the entire command may be clipped, and the display memory remains unchanged.","When a command is retrieving display information for a pixel, the value stored in the feature memory for the pixel is examined. In one embodiment, if the value for the pixel in feature memory is equal to a first value, the value stored for the pixel in display memory is retrieved. If the value for the pixel in feature memory is equal to a second value, the value stored in a fill register is retrieved.","In one embodiment, values in feature memory are dynamically allocated as either display context values or fill register values. In one embodiment, each location in feature memory has 3 bits. A maximum of 8 context values are available. Similarly, a maximum of 8 fill registers are available. The number allocated for each function is determined by a feature memory allocator.","The invention is a method and apparatus for hardware acceleration of clipping and graphical fill in display systems. In the following description, numerous specific details are set forth to provide a more thorough description of embodiments of the invention. It is apparent, however, to one skilled in the art, that the invention may be practiced without these specific details. In other instances, well known features have not been described in detail so as not to obscure the invention.","Hardware Clipping and Filling Acceleration","In one embodiment of the present invention, all display data is presented to the display system. The display system uses its hardware to clip the undesired data, if necessary, and display the desired data. Additionally, if a sufficient amount of display data has the same value, the display system uses its hardware to fill the appropriate areas using the shared value.","In one embodiment, a display command is issued to the display system. The command originates from a server. The server is located away from the display system. The server and the display system communicate via a network. The network may comprise a LAN (local area network) or WAN (wide area network). In another embodiment, the display system is located within a thin client. The hardware for clipping and filling is located within the display system.","Fill Registers","In one embodiment, the display system has one or more accelerating registers. In one embodiment, one or more accelerating registers are fill registers. As display data is read from memory, some of the information's color data is classified by the fill registers. Pixels which have the same value as a value stored in a fill register are read from the fill register rather than from display memory.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 2","b":["200","210","220","240","230","240"]},"At block , it is determined whether all desired pixels have been retrieved. If all desired pixels have been retrieved, at block , the process is complete. If not all desired pixels have been retrieved, the process repeats at step .","Clipping Registers","In another embodiment, one or more accelerating registers are clipping registers. As display data arrives from each source, the information's display location is classified by the clipping registers. Only pixels which are calculated to be visible by the clipping registers is written to memory for later display.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 3","b":["300","310","320","330"]},"Feature Memory","In one embodiment, the display system has an extra amount of memory, termed \u201cfeature memory.\u201d In one embodiment, there is a corresponding data location in the feature memory for each pixel in the display memory.","In one embodiment, the feature memory is comprised of dynamic random access memory (DRAM).",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 4","b":["400","410","420","430"]},"Different embodiments have a different number of bits of memory, n, for each data location in the feature memory. As a result, there are two to the nth power different available values which can be stored in each data location. Some values correspond to fill registers containing shared color values. Other values correspond to display contexts. In one embodiment, there are three bits of memory for each data location, resulting in eight possible fill registers and display contexts combined.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 5","b":["500","510","520","530","520","010","010","530","010","530"]},"Write Commands","Before a command writing data to the display memory is executed for pixel , it is determined whether the display context of a command is also . If the display context of the command is not , the command is not executed. For example, if two video windows overlap at pixel , both will send display data to the display system for pixel . However, the display data for pixel  should be clipped for at least one of the video windows. If another window also overlaps pixel , it may be the case that the display data for pixel  from both video windows should be clipped. Only one of the sets of display data that overlap at pixel  will have display context . Thus, only display data with a display context of  is written to the pixel and the competing display data is clipped.","In one embodiment, commands issued to the display system contain an indicator to indicate either with which fill register the command is associated or within which display context the command should be executed. When a command contains display information for a pixel, the display context for the pixel stored in the feature memory is compared to the context indicator of the command. If the display context is equal to the context indicator, the command is executed for the pixel. If the display context is not equal to the context indicator, the display information for the pixel is clipped. In some instances, the entire command may be clipped, and the display memory remains unchanged.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 6","b":["600","610","620"]},"At block , the display command is executed for pixels that have the same display context stored in their corresponding feature memory locations as the display context of the display command. At block , the display command is discarded for pixels that do not have the same display context stored in their corresponding feature memory locations as the display context of the display command.","Read Commands","In one embodiment, when a command is retrieving display information for a pixel, the value stored in the feature memory for the pixel is examined. If the value stored in the feature memory indicates that the pixel has a value equal to a shared value stored in a fill register, the value stored in a fill register is retrieved. Otherwise, the value stored for the pixel in display memory is retrieved.","For example, when a command reading data for pixel  is executed for pixel, it is determined whether the value stored in feature memory for pixel , , is associated with a fill register. If  is associated with a fill register, the value in the fill register is retrieved for the pixel. Otherwise, the value stored for pixel  in display memory is retrieved.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 7","b":["700","710","720","730"]},"Dynamic Allocation of Contexts and Fill Registers","In one embodiment, values in feature memory are dynamically allocated as either display context values or fill register values. In one embodiment, each location in feature memory has 3 bits. A maximum of 8 context values are available. Similarly, a maximum of 8 fill registers are available. The number of 3-bit code combinations allocated for each function is determined by a feature memory allocator.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 8","b":["800","810","800","810"]},"Typically, allocation of the n-bit code combinations depends upon the number of video streams from different sources and the number of different colored display sources containing large amounts of the same color (e.g., text windows with different background colors). For example, in a display system which is used to display a singe video stream and many text windows from the same source, it is desirable to maximize the number of fill registers. The 3-bit code for 0 (000) is allocated to represent reading data directly from display memory.","Similarly, the 3-bit codes for 1 through 7 (respectively, 001, 010, 100, 011, 110, 101, 111) are each associated with a different fill register. The most commonly occurring seven colors are stored in the seven fill registers. When a different color becomes more commonly occurring than a color stored in the fill registers, the color replaces the color in the fill registers. The values in the feature memory are updated to reflect the change in colors stored in the fill registers.","In one embodiment, algorithms are employed to increase the stability of the colors stored in the fill register. In an example embodiment, a color must be more commonly occurring than a color stored in the fill registers for a period of time before it replaces the color in the fill registers. In another example embodiment, a color must be more commonly occurring than some threshold value of colors stored in the fill registers.","As the display needs of display system change, the allocation of the n-bit code combinations can also change. In the example above of the display system used to display a singe video stream and many text windows from the same source, if the system is changed to display eight video streams, each from a different source, the 3-bit code combinations are reallocated. Each code combination is allocated to the display context of a different video stream. Thus, there are no longer any fill registers in use.","Similarly, if the display system above is used to display three video streams from different sources and several text windows from another source, the 3-bit code combinations are reallocated. 0 may indicate that data should be displayed directly from display data while 1 through 4 are associated with four different fill registers and 5 through 7 are associated with different display contexts.","Fill Registers as Part of Display Context","In one embodiment, more than one n-bit code combination is allocated to a display context. One of the n-bit code combinations allocated to the context is used to indicate that display data should be read directly from the display memory. Other n-bit code combinations allocated to the context indicate that display data should be read from certain fill registers rather than from the display memory. Also, write commands which have any of the n-bit code combinations allocated to the context are executed for pixels having the same context.","For example, in one embodiment, a display system is used to display data from four different sources. Two sources, Source  and Source , provide display data (e.g., text windows with different background colors) that have large numbers of pixels sharing the same colors. Two more sources, Source  and Source , provide display data in which not many pixels share the same color values.","The feature memory of the display system has 3 bits of memory for each data location. Values 0, 1 and 2 are all allocated to the display context for Source . Only write commands having a context indicator of 0, 1 or 2 will be executed for pixels that have a 0, 1 or 2 stored in their corresponding feature memory location. Additionally, value 0 indicates that display data should be read from the display memory directly, value 1 indicates that display data should be read from fill register  and value 2 indicates that display data should be read from fill register .","Similarly, values 3, 4 and 5 are all allocated to the display context for Source . Only write commands having a context indicator of 3, 4 or 5 will be executed for pixels that have a 3, 4 or 5 stored in their corresponding feature memory location. Additionally, value 3 indicates that display data should be read from the display memory directly, value 4 indicates that display data should be read from fill register  and value 5 indicates that display data should be read from fill register .","Value 6 is allocated to the display context for Source . Only write commands having context  will be executed for pixels that have 6 stored in their corresponding feature memory location. Additionally, when a pixel having a 6 stored in its corresponding feature memory location is read, the data is read directly from display memory.","Finally, value 7 is allocated to the display context for Source . Only write commands having context  will be executed for pixels that have 7 stored in their corresponding feature memory location. Additionally, when a pixel having a 7 stored in its corresponding feature memory location is read, the data is read directly from display memory.",{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 9","b":["900","910","920","930"]},"At block , the write command is executed for pixels for which the n-bit code stored in their corresponding feature memory locations is allocated to the same display context as the n-bit code of the display command. At block , the display command is discarded for pixels for which the n-bit code stored in their corresponding feature memory locations is not allocated to the same display context as the n-bit code of the display command.","Virtual Desktop System Architecture","One embodiment of the invention is used as part of a thin client architecture system.  shows an example of a thin client topology called a virtual desktop system architecture. The virtual desktop system architecture provides a re-partitioning of functionality between a central server installation  and end user hardware . Data and computational functionality are provided by data sources via a centralized processing arrangement. At the user end, all functionality is eliminated except that which generates output to the user (e.g., display and speakers), takes input from the user (e.g., mouse and keyboard) or other peripherals that the user may interact with (e.g., scanners, cameras, removable storage, etc.). All computing is done by the central data source and the computing is done independently of the destination of the data being generated. The output of the source is provided to a terminal, referred to here as a \u201cHuman Interface Device\u201d (HID). The HID is capable of receiving the data and displaying the data.","The functionality of the virtual desktop system is partitioned between a display and input device such as a remote system and associated display device, and data sources or services such as a host system interconnected to the remote system via a communication link. The display and input device is a human interface device (HID). The system is partitioned such that state and computation functions have been removed from the HID and reside on data sources or services. One or more services communicate with one or more HIDs through a communication link such as network. An example of such a system is illustrated in , wherein the system comprises computational service providers  communicating data through communication link  to HIDs .","The computational power and state maintenance are provided by the service providers or services. The services are not tied to a specific computer, but may be distributed over one or more traditional desktop systems such as described in connection with , or with traditional servers. One computer may have one or more services, or a service may be implemented by one or more computers. The service provides computation, state and data to HIDs and the service is under the control of a common authority or manager. In , the services are provided by computers , , and . In addition to the services, a central data source can provide data to the HIDs from an external source such as for example the Internet or world wide web. The data source can also be broadcast entities such as those that broadcast data (e.g., television and radio signals).","Examples of services include X11\/Unix services, archived or live audio or video services, Windows NT service, Java\u2122 program execution service and others. A service herein is a process that provides output data and response to user requests and input. The service handles communication with an HID currently used by a user to access the service. This includes taking the output from the computational service and converting it to a standard protocol for the HID. The data protocol conversion is handled by a middleware layer, such as the X server, the Microsoft Windows interface, video format transcoder, the OpenGL\u00ae interface, or a variant of the java.awt.graphics class within the service producer machine. The service machine handles the translation to and from a virtual desktop architecture wire protocol described further below.","Each service is provided by a computing device optimized for its performance. For example, an Enterprise class machine could be used to provide X11\/Unix service, a SunMediaCenter\u2122 could be used to provide video service, a Hydra based NT machine could provide applet program execution services.","The service providing computer system can connect directly to the HIDs through the interconnect fabric. It is also possible for the service producer to be a proxy for another device providing the computational service, such as a database computer in a three-tier architecture, where the proxy computer might only generate queries and execute user interface code.","The interconnect fabric can comprise any of multiple suitable communication paths for carrying data between the services and the HIDs. In one embodiment the interconnect fabric is a local area network implemented as an Ethernet network. Any other local network may also be utilized. The invention also contemplates the use of wide area networks, the Internet, the world wide web, and others. The interconnect fabric may be implemented with a physical medium such as a wire or fiber optic cable, or it may be implemented in a wireless environment.","The interconnect fabric provides actively managed, low-latency, high-bandwidth communication between the HID and the services being accessed. One embodiment contemplates a single-level, switched network, with cooperative (as opposed to completing) network traffic. Dedicated or shared communications interconnects maybe used in the present invention.","The HID is the means by which users access the computational services provided by the services.  illustrates HIDs ,  and . Each HID comprises a display , a keyboard , mouse , and audio speakers . The HID includes the electronics need to interface these devices to the interconnection fabric and to transmit to and receive data from the services.","A block diagram of an example embodiment of the HID is illustrated in . The components of the HID are coupled internally to a PCI bus . Network control block  communicates to the interconnect fabric, such as an Ethernet, through line . An audio codec  receives audio data on interface  and is coupled to network control block . USB data communication is provided on lines  to a USB controller . The HID further comprises a embedded processor  such as a Sparc2ep with coupled flash memory  and DRAM . The USB controller , the network control block  and the embedded processor  are all coupled to the PCI bus . A video controller , also coupled to the PCI bus , can include an ATI RagePro+ frame buffer controller which provides SVGA output on the line . NTSC data is provided in and out of the video controller through video decoder  and encoder  respectively. A smartcard interface  may also be coupled to the video controller .","Alternatively, the HID can comprise a single chip implementation as illustrated in . The single chip includes the necessary processing capability implemented via CPU  and graphics renderer . Chip memory  is provided, along with video controller\/interface . A internal bus (USB) controller  is provided to permit communication to a mouse, keyboard and other local devices attached to the HID. A sound controller  and interconnect interface  are also provided. The video interface shares memory  with the CPU  and graphics renderer . The software used in this embodiment may reside locally in on-volatile memory or it can be loaded through the interconnection interface when the device is powered.","Thus, a method and apparatus for hardware acceleration of clipping and graphical fill in display systems is described in conjunction with one or more specific embodiments. The invention is defined by the following claims and their full scope and equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["These and other features, aspects and advantages of the present invention will become better understood with regard to the following description, appended claims and accompanying drawings where:",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
