---
title: Queue-based spin lock with timeout
abstract: A queue-based spin lock with timeout allows a thread to obtain contention-free mutual exclusion in fair, FIFO order, or to abandon its attempt and time out. A thread may handshake with other threads to reclaim its queue node immediately (in the absence of preemption), or mark its queue node to allow reclamation by a successor thread.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06965961&OS=06965961&RS=06965961
owner: University of Rochester
number: 06965961
owner_city: Rochester
owner_country: US
publication_date: 20030303
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["REFERENCE TO RELATED APPLICATION","STATEMENT OF GOVERNMENT INTEREST","FIELD OF THE INVENTION","DESCRIPTION OF RELATED ART","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["The present application claims the benefit of U.S. Provisional Application No. 60\/361,063, filed Mar. 1, 2002, whose disclosure is hereby incorporated by reference in its entirety into the present disclosure.","The work leading to the present invention was supported in part by NSF grants EIA-0080124, CCR-9988361 and CCR-0204344 and by DARPA\/AFRL contract number F29601-00-K-0182. The government has certain rights in the invention.","The present invention is directed to a spin lock for use on shared-memory multi-processor computing devices and more particularly to a queue-based spin lock with timeout.","Large-scale databases and Internet transaction applications now demand parallel servers capable of running on machines with twenty to a hundred processors or more. On such machines, spin locks are widely used for mutual exclusion. Traditional testandset-based spin locks, however, are vulnerable to memory and interconnection contention and do not scale well to large machines.","Queue-based spin locks avoid contention by arranging for every waiting thread to spin on a separate, local flag in memory. The MCS lock of Mellor-Crummey and Scott (\u201cAlgorithms for Scalable Synchronization on Shared-Memory Multiprocessors\u201d, , Vol. 9, No. 1, April 1991, pp. 21\u201365) uses a queue linked from head to tail. It requires only O(L+T) space for L locks and T threads. Each thread spins on a node that it allocated itself, and that may therefore reside in local memory even on a non-cache-coherent machine. The CLH lock, developed independently by Craig (\u201cBuilding FIFO and priority-queueing spin locks from atomic swap,\u201d Technical Report TR 93-02-02, Department of Computer Science, University of Washington, February, 1993) and by Landin and Hagersten (\u201cQueue Locks on Cache Coherent Multiprocessors\u201d, 8th , Cancun, Mexico, April 1994, pp. 165\u2013171) uses a queue linked from tail to head. It also requires only O(L+T) space, but each thread spins on the node allocated by its predecessor, which will be local only on a cache-coherent machine.","Over the past ten years, queue-based spin locks\u2014the MCS lock in particular\u2014have been incorporated into a variety of academic and commercial operating systems, including Compaq's Tru64, IBM's K42 and multiprocessor Linux systems, the Alewife and Hurricane Systems, and parallel real-time software from Mercury Computer Systems.","Outside the operating system, non-scalable test-and-set locks have come to be widely used in commercially important applications, notably database systems such as Oracle's Parallel Server and IBM's DB2. Many of these applications depend critically on the ability of a thread that waits too long to time out and abandon its attempt to acquire a lock. Timeout-capable locks (\u201ctry locks\u201d) allow a real-time application to signal an error condition or pursue an alternative code path. In a database system, they provide a simple means of recovering from transaction deadlock or preemption in critical sections.","Unfortunately it is difficult to combine scalability and timeout. The problem is that while threads competing for a test-and-set lock are mutually anonymous, and can abandon their spins without anyone being the wiser, threads in a queue-based lock are linked into an explicit data structure. A timed-out thread must somehow introduce its neighbors in the queue to one another, even in cases where the neighbors may also be timing out. Craig proposed (\u201cBuilding FIFO and Priority-Queueing Spin Locks from Atomic Swap\u201d, Technical Report 93-02-02, University of Washington Computer Science Dept., February 1993) that a timed-out thread in a CLH lock mark its node as \u201cabandoned\u201d. When releasing a lock a thread would skip over (and reclaim) abandoned nodes. This approach can easily require non-linear space and non-constant time. Mercury Computer Systems' version of the MCS lock incorporates a timeout mechanism, but abandons fairness: threads that are willing to wait indefinitely bypass threads with bounded wait times.","The problem of preemption in critical sections has received considerable attention over the years. Alternative strategies include avoidance, recovery, and tolerance. The latter approach is appealing for commercial applications because it does not require modification of the kernel interface: if a thread Waits too long for a lock, it assumes that the lock holder has been preempted. It abandons its attempt, yields the processor to another thread (assuming there are plenty) and tries again at a later time. In database systems timeout serves the dual purpose of deadlock recovery and preemption tolerance.","It is the object of the present invention to overcome the above-noted problems of the prior art. Specifically, the invention aims to\n\n","Unfortunately, it does not appear to be possible to guarantee that space will be reclaimed in bounded time in multiprogrammed systems. The present disclosure therefore encompasses two variants of the invention.","In the first variant, a timed-out thread \u201chandshakes\u201d with its neighbors to reclaim its space before leaving the queue. Space needs are therefore linear (O(L+T)), but timeout may be indefinitely delayed on a multiprogrammed system, because a neighbor thread may be preempted, and thus unable to cooperate. In the second variant, timeout is non-blocking: a thread is guaranteed to leave the queue in a bounded number of its own time steps, whether neighbors are preempted or not. Space, however, may not be reclaimed until some successor is active. In theory unbounded space may be required, but experiments confirm that linear space can be expected in practice.","Two preferred embodiments of each lock variant will be disclosed, one based on the CLH lock and the other on the MCS lock. The variants with guaranteed linear space but blocking timeout are herein named the CLH try lock and the MCS try lock. The variants with non-blocking timeout are herein named the CLH-NB try lock and the MCS-NB try lock. In each pair the CLH embodiment is the simpler of the two, but relies on cache coherence. The MCS embodiments can be expected to scale better on non-cache-coherent machines.","In the original CLH and MCS locks, and in the CLH try and MCS try locks, space management for queue nodes is delegated to the callers of the acquire and release operations, and the queue node passed to MCSrelease or returned from CLHrelease is guaranteed to be available for immediate reuse once the release operation completes. No such guarantee seems possible for locks with non-blocking timeout. We therefore choose in the CLH-NB try and MCS-NB try locks to perform dynamic space allocation within the acquire and release operations. To allow the release operation to find the queue node allocated by the acquire operation, we arrange for acquire to write a reference to that node into an extra field (a head pointer) of the lock variable itself, once the lock is held. A serendipitous side effect of this strategy is that the CLH-NB try and MCS-NB try locks can employ a standard application programming interface (API), making them suitable for linking with binary-only commercial applications.","Two preferred embodiments of the invention will now be set forth in detail with reference to the drawings. Two variants of each embodiment are described: one with guaranteed linear space but blocking timeout, the other with non-blocking timeout but theoretically unbounded space.","The first preferred embodiment (variant with blocking timeout) is called the CLH try lock. It is based on the earlier CLH lock of Craig (\u201cBuilding FIFO and priority-queueing spin locks from atomic swap,\u201d Technical Report TR 93-02-02, Department of Computer Science, University of Washington, February, 1993) and of Landin and Hagersten (\u201cQueue locks on cache coherent microprocessors,\u201d 8, Cancun, Mexico, April, 1994, pp. 165\u2013171).","In the standard CLH lock, a thread leaves its queue node behind when releasing the lock. In its place, it takes the node abandoned by its predecessor. For a try lock, one would like to arrange for a thread that times out to leave with its own queue node. Otherwise, one might need O(P\u00d7L) queue nodes in the system as a whole, where P is the number of threads and L is the number of locks.","Suppose that thread B wishes to leave (time out) and is currently in the middle of the queue. As shown in , B's intended successor, C, is already spinning on B's queue node. Thus, B can simply mark the node as \u201cleaving.\u201d C can then dereference the node to find B's predecessor, A, and mark B's node as recycled, whereupon B can safely leave. There is no race between A and B because A never inspects B's queue node.","Complications arise in the situation of , in which the departing thread B is the last thread in the queue. In this case, B must attempt to modify the queue's tail pointer to refer to A's queue node rather than its own. We can naturally express that attempt with a compareandswap operation. If that operation fails, we know that another thread C has arrived. At this point we might hope to revert to the previous case of . However, it is unfortunately possible that C may successfully leave the queue after B's compareandswap, at which point B may wait indefinitely for a handshake that never occurs. We could protect against the indefinite wait by repeatedly checking the queue's tail pointer, but that would constitute spinning on a non-local location, something we want to avoid.","That problem can be solved by requiring C to handshake with B in a way that prevents B from trying to leave the queue while C is in the middle of leaving. In the middle-of-queue case, as shown in , B can leave the middle of the queue as soon as it receives confirmation from C that no pointer to its queue node remains. In the end-of-queue case, as shown in , B can leave the end of the queue once it has updated the tail pointer, Q, using compareandswap. The transitions from waiting to leaving and from waiting to available (not shown in figure) are also made with compareandswap, to avoid overwriting a transient flag.","Like the standard CLH lock, the CLH-try lock depends on cache coherence to avoid remote spinning. In the CLH-try lock, it is possible for two threads to end up spinning on the same location. In the fourth line of , if thread A calls CLHrelease, it will spin until the transient flag reverts to waiting. If a new thread C arrives at about the same time, it too will begin to spin on the flag in A's queue node. When B finally updates the flag, its write will terminate both spins.","The non-blocking variant of the first preferred embodiment is called the CLH-NB try lock. As in the CLH lock and the CLH try lock, a lock variable takes the form of a tail pointer for a singly linked list of queue nodes. A thread that wishes to acquire the lock allocates a node, swaps it into the tail pointer, and then spins on a flag in the node ahead of it in line, which was returned by the swap.","The CLH try lock has been modified in the CLH-NB try lock to allow non-blocking timeout, as will now be explained with reference to . In the CLH-NB try lock, individual queue nodes  contain only a single pointer . When nil, this pointer indicates that the thread spinning on the node must wait. When set to AVAILABLE (a value we assume to be different from any valid reference), the pointer indicates that the lock is available to the thread spinning on the node. When neither nil nor AVAILABLE, the pointer contains a reference to the previous node in the list, and indicates that the thread that allocated the node containing the pointer has timed out. Up until its decision to time out, a thread maintains its reference to the node on which it is spinning in a local variable, rather than its queue node (indicated in the figure by starting the tail of an arrow  in the empty space below a queue node ).","In the event of timeout, two principal cases arise, illustrated in . In , departing thread B is in the middle of the queue, spinning on the pointer in the node allocated by thread A. When B times out, it indicates its intent to leave by storing into its own queue node a reference to A's node. Thread C, which is spinning on B's node, notices this change. It updates its own local pointer to refer to A's node instead of B's, and then reclaims B's node.","Unfortunately, B cannot be certain that C exists. The case where it does not is illustrated in . After writing the reference to A's queue node into its own queue node, B performs a compareandswap on the queue tail pointer, in an attempt to change it from a reference to B's node into a reference to A's node. In the middle-of-the-queue case of , this operation will fail. In the end-of-the-queue case of , it succeeds, and B knows that it can reclaim its own queue node. In either case B can return as soon as it has attempted the compareandswap; it does not have to wait for C. If the compareandswap failed, B's queue node will not be available for reuse until it is reclaimed by C, or by some other, later thread, if C has also timed out.","The CLH-NB try lock includes one additional departure from the original CLH lock. By analogy to the end-of-queue case for timeout, we can eliminate the extra, \u201cdummy\u201d node in an unheld lock by performing a compareandswap in the release operation. This extra atomic operation increases the overhead of every critical section, but reduces by the size of a queue node the space required for an unheld lock.","Because reclaimed queue nodes may be reused, we must be careful to avoid the so-called ABA problem, in which a reference to a newly allocated node is mistaken for a reference to a previously reclaimed node. Specifically, once thread B writes a reference to X into node Y, B's successor may reclaim Y. If Y's space is recycled quickly and used for some new queue node Y\u2032, which is used in an attempt to acquire the same lock for which Y was used, B's compareandswap may succeed when it should not. We can avoid this possibility, in this particular case, by using a memory allocator in which a given block of storage is always allocated by the same thread. Then Y's space, which was allocated by B, will be reused only by B, and only after B has attempted the compareandswap in which the ABA problem arises.","The second preferred embodiment (variant with blocking timeout) is called the MCS try lock. It is based on the earlier MCS lock of Mellor-Crummey and Scott (\u201cAlgorithms for scalable synchronization on shared-memory multiprocessors,\u201d , Vol. 9, No. 1, pp. 21\u201365, February 1991).","As in the CLH lock, an MCS lock variable takes the form of a tail pointer for a list of queue nodes, but where the CLH queue is linked from tail to head, the bulk of the MCS queue is linked from head to tail. After swapping a reference to its own queue node into the tail pointer, a thread writes an additional reference to its node into the next pointer of its predecessor's node. It then proceeds to spin on its own node, rather than the predecessor's node. This \u201cbackward\u201d linking allows a thread to spin on a location that is guaranteed to be local even on a non-cache-coherent machine. Unfortunately, it also makes timeout significantly more complex.","To leave the queue, a thread B must update the successor pointer in the queue node of its predecessor A so that it points to B's successor C, rather than to B. If C later chooses to leave the queue as well, it will again need to update A's queue node, implying that B must tell it where A's queue node resides. Pointers to both predecessors and successors must therefore reside in the queue nodes in memory, where they can be read and written by neighboring threads. The MCS-try lock therefore employs a doubly linked queue.","As in the CLH-try lock, there are two principal cases to consider, depending on whether the departing thread B is currently in the middle of the queue, as illustrated in , or at the end of the queue, as illustrated in . While waiting to be granted the lock, a thread ordinarily spins on its predecessor pointer. In the middle-of-the-queue case, departing thread B first replaces the four pointers into and out of its queue node, respectively, with leavingother and leavingself flags (shown as LO and LS in the figures). It then updates C's predecessor pointer and relies on C to update A's successor pointer. In the end-of-the-queue case of , B \u201ctags\u201d A's nil successor pointer to indicate that additional changes are pending. Absent any race conditions, B eventually clears the tag using compareandswap.","Unfortunately, there are many potential races that have to be resolved. The thread at the head of the queue may choose to grant the lock to its successor while the successor is attempting to leave the queue. Two neighboring threads may decide to leave the queue at approximately the same time. A thread that is at the end of the queue in step  may discover in step  that it now has a successor. In general, the order of updates to pointers is chosen to ensure that (1) no thread ever returns from MCStryacquire until we are certain that no pointers to its queue node remain and (2) if two adjacent threads decide to leave concurrently, the one closer to the front of the queue leaves first.","The non-blocking variant of the second preferred embodiment, called the MCS-NB try lock, will be explained with reference to . Each node  in the queue includes a pointer  to a previous queue node, a pointer  to a next queue node, and a status flag , which are used in the manner explained below.","To release a standard MCS lock, a thread attempts to follow its next pointer and update the word on which its successor is spinning. If the pointer is still nil, the thread performs a compareandswap on the lock tail pointer, in an attempt to replace a pointer to its own node with a nil pointer. If that attempt fails, then some other thread must be in the process of linking itself into the queue. The releasing thread waits for its next pointer to be updated, then follows it and updates the successor's status flag. Like handshaking in the timeout code of the MCS try lock, we must eliminate the spin in release if we are to bound the time required by lock operations.","As in the original MCS lock, the backward (next) pointer in node Y of an MCS-NB try lock () allows the thread B that allocated Y to find the node on which a successor thread is spinning. When nil, Y's next pointer indicates that no successor node is known. Three additional values, assumed not to be the same as any valid reference, correspond to special states. When set to AVAILABLE, Y's next pointer indicates that the lock is currently available. When set to LEAVING, it indicates that B has timed out and, further, that no next pointer anywhere refers to Y. When set to TRANSIENT, Y's next pointer also indicates that B has timed out, but that in doing so B was unable to break the reference to Y from its predecessor node.","The status flag of a queue node has five possible values. Before linking its node into the queue, a thread initializes its status flag to waiting. Once the link-in operation is complete, the thread will spin waiting for the value to change. Three possible values\u2014available, leaving, and transient\u2014mirror the special values of node next pointers described in the previous paragraph. The final value\u2014recycled\u2014allows us to address race conditions in which two threads have references to a node that needs to be reclaimed. Whichever thread uses its pointer last will find the recycled flag, and know that it is responsible for reclamation.","When a thread C performs an initial swap on the tail pointer of a lock that is not currently available, it receives back a reference to the queue node Y allocated by C's predecessor, B. C swaps a reference to its own node, Z, into Y's next pointer. By using a swap, rather than an ordinary write (as in the original MCS lock), C can recognize the case in which B decides to release the lock or to leave the queue when C has already swapped itself into the tail of the queue, but before C has updated Y's next pointer. Among other things, this mechanism allows B to release the lock without waiting for C to complete its link-in operation.","If C's swap on Y's next pointer returns AVAILABLE, C knows that it has the lock. Moreover B's compareandswap on the lock tail pointer (which it performs in order to cover the case when it is the last thread in the queue) is guaranteed to fail, because C's original swap on the tail pointer removed the reference to Y. C therefore knows that B will neither update Z nor reclaim Y, so C reclaims Y, writes a reference to Z into the head pointer field of the lock, and returns successfully.","If the swap on Y's next pointer returns LEAVING, C knows that B has timed out. It also knows, for reasons similar to those in the preceding paragraph, that B will neither update Z nor reclaim Y. C updates its private precedessor pointer to contain the reference found in Y's predecessor pointer, instead of a reference to Y. C then reclaims Y and tries again to link itself into line.","Finally, if the swap on Y's next pointer returns TRANSIENT, C knows that B has timed out, but that B's predecessor, A, has a reference to Y, and is planning to use it. Whichever thread, A or C, accesses Y last will need to reclaim it. C swaps a recycled value into Y's status flag. If the return value of the swap is waiting, C knows that it has accessed Y before A, and that A will take responsibility for reclaiming it. If the return value of the swap is available, leaving, or transient, however, C knows that A has already accessed Y. C therefore reclaims Y. In either case, C updates its private predecessor pointer and tries to link itself into line again, as in the preceding paragraph. Seen from A's perspective, any time we update the status flag of a successor queue node we use a swap operation to do so, and reclaim the node if the return value is recycled.","Once successfully linked into the queue, thread C spins on the status flag in its own queue node, Z. If that word changes to available, C writes a reference to Z into the head pointer field of the lock, and returns successfully. If Z's status flag changes to leaving or transient, C resets it to waiting and then behaves as it would have in the preceding paragraphs, had it found LEAVING or TRANSIENT in the next pointer of its predecessor's queue node, Y.","If C times out in the algorithm's inner loop, spinning on Z's status flag, it first stores its private predecessor pointer into Z's predecessor pointer. It then attempts to erase the reference to Z found in Y's next pointer, using compareandswap. If that attempt succeeds, C swaps LEAVING into Z's next pointer and, if necessary, swaps leaving into the status flag of Z's successor node. As described above, C reclaims the successor node if the status flag was already set to recycled. Finally, if Z appears to have no successor, C attempts to link it out of the end of the queue with a compareandswap and, if that operation succeeds, reclaims Z.","If C fails to erase the reference to Z found in Y's next pointer, then it knows its predecessor B will try to update Z's status flag. It therefore swaps TRANSIENT into Z's next pointer and, if necessary, swaps transient into the status flag of Z's successor node, reclaiming that node if its status flag was already recycled. If Z appears to have no successor, then C must simply abandon it, to be reclaimed by some thread that calls the acquire operation at some point in the future.","If C times out in the algorithm's outer loop, while attempting to update a predecessor's next pointer, it mimics the case of timeout in the inner loop: it restores its predecessor's next pointer, sets Z's status to leaving or transient, as appropriate, and then takes the actions described in one of the preceding two paragraphs.","Unfortunately, in order to avoid any spins in timeout code, we must generally return from an unsuccessful CLH-NBacquire or MCS-NBacquire operation without having reclaimed our queue node (that task having been left to some successor thread). As a result, we lose the O(L+T) overall space bound of the CLH try lock and the MCS try lock, with L locks and T threads.","Perhaps the simplest pathological scenario occurs in either lock when the last thread in line is preempted. If the second-to-last thread then times out, its node may go unreclaimed for an arbitrarily long time. If the third-to-last thread subsequently times out its node may go unreclaimed as well, and so on.","Worst-case space needs are in fact unbounded, with as few as three active threads in the CLH-NB try lock (). Suppose initially that threads A, B, and C are waiting for the lock. Suppose then that B and C decide to leave at approximately the same time and stop spinning on nodes X and Y. B then writes a reference to X into Y, but C is preempted before it can write a reference to Y into Z. B's compareandswap on the lock tail pointer will fail, because Z is in the way, and B will return from acquire without having reclaimed Y. If B requests the lock again it will get into line with a new queue node; call it Y\u2032. Suppose that B then times out again, decides to leave the queue, and stops spinning on Z. Only now, let us suppose, does C wake up again and write a reference to Y into Z. C's compareandswap on the lock tail pointer will fail because Y\u2032 is in the way, and C will return from acquire without having reclaimed Z. This scenario can, in principle, repeat indefinitely. A similar scenario exists for the MCS-NB try lock.","Ideally, one might hope to design a queue-based spin lock with non-blocking timeout and an O(L+T) space bound, but it appears that no such lock is possible. Imagine a lock on which N threads are waiting (). Suppose now that N\u20142 of these threads\u2014all but the first and the last\u2014decide to leave at essentially the same time. Imagine further that the last thread in line has been preempted, and that the first thread, which has the lock, is in a very long critical section. The departing threads would all like to complete their timeout operations in a bounded number of their own local time steps. In order to reclaim space while maintaining the integrity of the queue, we must arrange to introduce the remaining threads (the first and the last) to each other. But because the queue embodies only local knowledge, we must perform O(N) work in order to make this introduction. While a hypothetical highly clever algorithm might be able to perform this work in O(log N) time using a parallel prefix-like strategy, it seems clear we cannot do it in constant time.","It would be easy, of course, to obtain an O(L\u00d7T) overall space bound, by remembering the last queue node used by thread T in its attempt to acquire lock L. The next time T tried to acquire L it could check to see if the node were still in L's queue, in which case T could resume waiting where it was when it last timed out. This mechanism would have significant time cost, however, and seems unwarranted in practice.","Performance results will now be disclosed.","In a first set of performance tests, the test-and-testandset (TATAS), CLH, CLH-NUMA, MCS, CLH try, and MCS try locks were implemented using the swap and compareandswap operations available in the Sparc V9 instruction set. (The CLH-NUMA lock was described by Craig in the above-cited Univ. of Washington technical report. It uses an extra level of indirection to ensure that spins are local even on a non-cache-coherent machine.) Initial testing and single-processor results employed a 336 MHz Sun Ultra 4500. Scalability tests were conducted on a 56-processor Sun Wildfire machine (not to be confused with the Compaq product of the same name) with 250 MHz processors. Architecturally, the Wildfire machine consists of four banks of up to 16 processors, each connected by a central crossbar. Backoff constants for the TATAS lock were tuned separately for each machine.","The tests employed a microbenchmark consisting of a tight loop containing a single acquire\/release pair. Aside from counting the number of iterations and the number of successful acquires (these may be different in the case of a try lock), the loop does no useful work. Machines used for tests were otherwise unloaded.","One can obtain an estimate of lock overhead in the absence of contention by running the microbenchmark on a single processor, and then subtracting the loop overhead. Results on the Ultra 4500 are as follows:",{"@attributes":{"id":"p-0081","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"right"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE I"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"TATAS","137","ns"]},{"entry":[{},"MCS","172","ns"]},{"entry":[{},"CLH","137","ns"]},{"entry":[{},"CLH-NUMA","262","ns"]},{"entry":[{},"MCS-try","256","ns"]},{"entry":[{},"CLH-try","274","ns"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"In an attempt to avoid perturbation due to other activity on the machine, minima were measured over a series of several runs. As one might expect, none of the more complex locks is able to improve on the time of the TATAS lock, though the CLH lock ties it. The extra 35 ns overhead in the MCS lock is due primarily to the compareandswap in MCSrelease. The CLH-try and MCS-try locks pay and additional penalty for the extra argument to their acquire operations and, in the case of CLH-try, the compareandswap in CLHrelease. Neither of the try locks calls the Sun high-resolution timer if it is able to acquire the lock immediately. Each call to the timer consumes an additional 250 ns.","One can obtain an estimate of the time required to pass a lock from one processor to another by running the microbenchmark on a large collection of processors. This passing time is not the same as total lock overhead; as discussed in the above-cited paper by Magnussen, Landin, and Hagersten, queue-based locks tend toward heavily pipelined execution, in which the initial cost of entering the queue and the final cost of leaving it are overlapped with the critical sections of other processors.",{"@attributes":{"id":"p-0084","num":"0088"},"figref":"FIGS. 4A and 4B"},"Among the non-try locks (), CLH-NUMA has a noticeably greater passing time (3.1 \u03bcs) than either MCS or CLH. The passing times for MCS and CLH are just about the same, at 2.4 \u03bcs and 2.5 \u03bcs respectively. Both MCS and CLH are faster than either of their try lock counterparts, though at 2.7 \u03bcs, CLH-try beats out the CLH-NUMA lock. At 3.2 \u03bcs, MCS-try has the slowest passing time.","While the TATAS lock appears to be passing much faster than any of the other locks, this result is somewhat misleading. The queued locks are all fair: requests are granted in the order they were made. The TATAS lock, by contrast, is not fair: since the most recent owner of a lock has the advantage of cache locality, it tends to outrace its peers and acquire the lock repeatedly. (This effect would be reduced in a more realistic benchmark, with work outside the critical section.) In our experiments successive acquisitions of a queued lock with high patience occurred on different processors more than 99% of the time; successive acquisitions of a TATAS lock occurred on the same processor about 99% of the time. This unfairness has ramifications for timeout: even with 150 \u03bcs patience (long enough for every processor, on average, to acquire and release the lock 10 times), TATAS still fails to acquire the lock some 4% of the time.",{"@attributes":{"id":"p-0087","num":"0091"},"figref":["FIG. 4C","FIG. 4D"]},"For higher processor counts, or for lower patience levels, the chance of a processor getting a lock is primarily a function of the number of processors that are in the queue ahead of it minus the number of those that time out and leave the queue before obtaining the lock. As is evident in , this chance drops off sharply with insufficient patience. The average time per iteration also drops, because giving up an attempt to acquire a lock is cheaper than waiting to acquire it.","The tradeoff between MCS-try and plain MCS is as expected: At the cost of higher average iteration time (per attempt), the plain MCS lock always manages to successfully acquire the lock. At the cost of greater complexity, the MCS-try lock provides the option of timing out. The same tradeoff holds between the CLH and CLH-try locks.","The tradeoffs between MCS-try or CLH-try and TATAS are more interesting. While the iteration time is consistently higher for the queue-based locks (), the acquisition (success) rate depends critically on the ratio between patience and the level of competition for the lock. When patience is high, relative to competition, the queue-based locks are successful all of the time. Once the expected wait time exceeds the timeout interval in the queue-based locks, however, the TATAS lock displays a higher acquisition rate. As will be described below, TATAS is not able to maintain this advantage once we exceed the number of processors in a single bank of the Wildfire machine.","Generally speaking, the results for larger numbers of processors are comparable to those seen within a single bank of the machine. Although crossing the interconnect between banks introduces a fair amount of noise into the timing results (see ), the MCS-try and CLH-try locks continue to have very similar iteration times, with MCS-try coming out somewhat slower than CLH-try.","The influence of the interconnect is particularly evident in the MCS-try iteration time in : an additional bank of processors, requiring additional traversals of the interconnect, comes into play between 16 and 20 processors, and again between 28 and 32 processors. A third transition point, between 40 and 44 processors, is not visible in the figure.",{"@attributes":{"id":"p-0093","num":"0097"},"figref":["FIGS. 4G and 4H","FIG. 4G","FIG. 4H","FIG. 4G"]},"In a second set of performance tests, eight different lock algorithms have been implemented, again using the swap and compareandswap operations available in the Sparc V9 instruction set: TAS-B, TAS-B try, CLH, CLH try, CLH-NB try, MCS, MCS try, and MCS-NB try. (The TAS-B try lock in this set of experiments is identical to the TATAS lock in the previous set.) The second set of experiments again employs a microbenchmark consisting of a tight loop containing a single acquire\/release pair. In addition, this microbenchmark includes optional timed \u201cbusywork\u201d inside and outside the critical section.","Acquire and release operations are implemented as inline subroutines wherever feasible. Specifically: for CLH and MCS both acquire and release are inlined. For TASB, TAS-B try, and CLH try, inlining is used for release and the \u201cfast path\u201d of acquire (with an embedded call to a true subroutine if the lock is not immediately available). For MCS try inlining is used for the fast path of both acquire and release. For CLH-NB try and MCS-NB try the need for dynamic memory allocation forces both acquire and release to be implemented as true subroutines.","Performance results were collected on an otherwise unloaded 64-processor Sun Enterprise 10000 multiprocessor, with 466 MHz Ultrasparc 2 processors. Assignment of threads to processors was left to the operating system. Code was compiled with the \u2212O3 level of optimization in gcc version 2.8.1, but was not otherwise hand-tuned. Architecturally, the Enterprise 10000 is a cache-coherent non-uniform memory access (CC-NUMA) machine. As shown in , such a server  has 16 system boards , each of which contains 4 processors  and a portion  of the global memory. Coherence is implemented via snooping on 4 independent global address buses . Data is transferred over a separate 16\u00d716 crossbar . The server  also can access a storage medium  on which the code to implement the try lock can be supplied.","As in the first set of experiments, one can obtain an estimate of lock overhead in the absence of contention by running the microbenchmark on a single processor, with no critical or non-critical \u201cbusywork\u201d, and then subtracting out the loop overhead. Results appear in table II below. The first column gives measured processor cycles on the Enterprise 10000. In an attempt to avoid perturbation due to kernel activity, minima are reported over a series of 8 runs. The remaining columns indicate the number of atomic operations (swaps and compareandswaps), shared-memory reads, and shared-memory writes found in the fast path of each algorithm. The times for the CLH-NB and MCS-NB try locks include dynamic allocation and deallocation of queue nodes.",{"@attributes":{"id":"p-0098","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE II"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"cycles","atomic ops","reads","writes"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"TAS-B","19","1","0","1"]},{"entry":[{},"TAS-B try","19","1","0","1"]},{"entry":[{},"CLH","35","1","3","4"]},{"entry":[{},"CLH try","67","2","3","3"]},{"entry":[{},"CLH-NB try","75","2","3","4"]},{"entry":[{},"MCS","59","2","2","1"]},{"entry":[{},"MCS try","59","2","2","1"]},{"entry":[{},"MCS-NB try","91","3","3","4"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]}]}}]}}},"As one might expect, none of the queue-based locks is able to match the time of the TAS-B lock. The closest competitor, the original CLH lock, takes nearly twice as long. Atomic operations are the single largest contributor to overhead. The CLH-NB try and MCS-NB try locks, which are not inlined, also pay a significant penalty for subroutine linkage.","The importance of single-processor overhead can be expected to vary from application to application. It may be significant in a database system that makes heavy use of locks, so long as most threads inspect independent data, keeping lock contention low. For large scientific applications, on the other hand, single-processor overhead\u2014lock overhead in general\u2014is dwarfed by waiting time at contended locks, and is therefore not a significant concern.","By running the microbenchmark on a large collection of processors one can again obtain an estimate of the time required to pass a lock from one thread to another. Because the initial cost of entering the queue and the final cost of leaving it are overlapped with the critical sections of other processors one should subtract from the resulting iteration times only the critical section \u201cbusywork\u201d, not the loop overhead or other non-critical work.",{"@attributes":{"id":"p-0102","num":"0106"},"figref":"FIGS. 5A and 5B"},"Below about 20 processors the TAS-B locks appear to outperform all competitors, but this appearance is somewhat misleading. The queued locks are all fair: requests are granted in the order they were made. The TAS-B lock, by contrast, is not fair: since the most recent owner of a lock has the advantage of cache locality, it tends to outrace its peers and acquire the lock repeatedly. At 20 processors, in fact, the TAS-B locks are \u201chanded off\u201d from one processor to another only about 30% of the time, despite the fact that each thread performs 440 ns of busywork between its critical sections. Not until more than 36 processors are active does the handoff rate rise above 50%. System designers considering the use of a TAS-B lock may need to consider whether this unfairness is acceptable in the event of severe contention.","In an attempt to assess the benefits and cost of non-blocking timeout, results were also collected on a preemptively scheduled system with more threads than processors. Specifically, the microbenchmark was run with 8\u201316 threads on an 8-processor Sun Enterprise 4500, a symmetric multiprocessor with 336 MHz processors and separate split-transaction buses for addresses (snooping) and data. With increasing numbers of threads comes an increasing chance of preemption, not only in the critical section, but also while waiting in the queue. Under these circumstances one would expect the CLH-NB and MCS-NB try locks to outperform the handshake-based CLH and MCS try locks. The obtained results confirm this expectation.",{"@attributes":{"id":"p-0105","num":"0109"},"figref":["FIGS. 6A and 6B","FIG. 6A"],"sub":["s","s "]},"As the number of threads exceeds the number of processors, the success rate plummets, due primarily to preemption of threads in their critical sections. The difference between blocking and non-blocking timeout then becomes sharply visible. The CLH-NB and MCS-NB try locks are able to bound the amount of time that a thread spends waiting for an unavailable lock; the CLH and MCS try locks cannot.","One can model iteration time in this experiment in two related ways. First, successful acquire operations introduce critical sections, which exclude one another in time. Total wall clock time should therefore equal the number of successful acquire operations times the average cost (passing time, critical section busywork, and time spent preempted) of a single critical section. Let Tbe lock passing time, Tbe critical section busywork, t again be the number of threads, and i again be the number of iterations executed by each thread. Now measure s, the acquire operation success rate, and T, the total wall clock time. One can estimate T, the average time per critical section spent preempted, via the following equations:",{"@attributes":{"id":"p-0108","num":"0112"},"br":{},"in-line-formulae":[{},{}],"i":["T","=sti","T"],"sub":["s","a","c","x"],"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["T","x"]},"mo":"=","mrow":{"mfrac":{"msub":{"mi":["T","s"]},"mi":"sti"},"mo":"-","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["T","a"]},{"mi":["T","c"]}],"mo":"+"}}}}}}},"Note that Tcan be estimated based on experiments with ample patience and a dedicated thread per processor.","Second, failed acquire operations and the busy-waiting prior to successful acquire operations occur more-or-less in parallel. Total wall clock time should therefore equal the total number of unsuccessful acquire operations times the average cost (loop overhead, patience, and timeout [handshake] time) of a single failed acquire, plus the total number of successful acquire operations times the average wait time, all divided by the number of processors not busy on the critical path (i.e. one fewer than the total number of processors).","Let m be the number of processors in the machine, Tbe patience, and Tbe loop overhead. If we let Trepresent the average lock wait time, then we can estimate T, the time required for timeout (including handshaking if necessary) via the following equations: \n\n\nThis calculation exploits the fact that T\u2267T. Tcan be estimated based on single-processor experiments.\n",{"@attributes":{"id":"p-0112","num":"0116"},"figref":["FIGS. 7A and 7B","FIGS. 6A and 6B","FIG. 7B"],"sub":["x ","h","x "]},"The times given in  are significantly larger than the \u201ctimes\u201d given in . By dividing wall clock time (T) by the total number of acquire attempts (ti),  effectively pretends that all those operations happen sequentially. The calculations behind  recognize that much of the work occurs in parallel.","As part of the experiments reported in the previous section, space management routines were instrumented to remember the maximum number of queue nodes ever extant at one time. Across the sixteen measured runs, encompassing six million acquire\/release pairs, the maximum number of allocated queue nodes was 84, or roughly 5 per thread. The CLH-NB and MCS-NB try locks appear to be roughly comparable in the number of nodes they require.","Given that the experiment was deliberately designed to induce an unreasonably high level of lock contention, and to maximize the chance of inopportune preemption, the relatively modest maximum number of queue nodes is reassuring: space overhead would not appear to be an obstacle to the use of non-blocking timeout in any realistic setting.","Taken together, the two sets of experiments confirm that it is possible, given standard atomic operations, to construct queue-based locks in which a thread can time out and abandon its attempt to acquire the lock. For each of the two preferred embodiments of the present invention, the variant with blocking timeout guarantees immediate reclamation of abandoned queue nodes, but requires that a departing thread obtain the cooperation of its neighbors. The variants with non-blocking timeout can safely be used in the presence of preemption (assuming, of course, that the processor can be put to other use while waiting for the preempted lock holder to be rescheduled).","The price of non-blocking timeout is an unbounded worst-case requirement for space. Large amounts of space appear unlikely to be required in practice, however, and experimental results confirm this expectation.","Results obtained on a 64-processor Sun Enterprise 10000 indicate that traditional test-and-testandset (TATAS) locks, which support timeout trivially, do not scale to large machines, even when designed to back off in the presence of contention. Technological trends would appear to be making queue-based locks increasingly important, and a timeout mechanism significantly increases the scope of their applicability. On a single processor, without contention, the CLH-NB try lock takes about twice as long as the original (no timeout) CLH lock, which in turn takes about twice as long as a conventional TATAS lock (with or without timeout). The significance of this single-processor overhead is unclear: unless threads all access different locks, a lock that sees little contention is probably lightly used, and its overhead is unlikely to have a significant impact on overall program run time.","With 64 processors attempting to acquire the lock simultaneously, however, experiments reveal cases in which attempts to acquire a TATAS lock (with backoff) took more than six times as long as attempts to acquire a CLH-NB try lock, while failing (timing out) more than 22 times as often (82% of the time, v. 3.7% for the CLH-NB try lock). While one of course attempts in any parallel program to avoid high lock contention, pathological cases do indeed arise in practice, particularly in transaction processing systems, and graceful performance degradation in these cases is of significant concern to customers.","For small-scale multiprocessors, TATAS with backoff continues to be the preferred lock algorithm. Queue-based locks, however, are attractive for larger machines, or for cases in which fairness and regularity of timing are particularly important. The CLH lock, both with and without timeout, has better overall performance than the MCS lock on cache-coherent machines. The CLH-NB try lock is also substantially simpler than the MCS-NB try lock. The relative performance of the queue-based locks would be expected to reverse, however, on a non-cache-coherent machine, even if the CLH-NB try lock were modified to ensure local-only spinning, using an extra level of indirection in the manner suggested by Craig for the original CLH lock.","The present inventor has presented papers disclosing the present invention: \u201cScalable Queue-Based Spin Locks with Timeout,\u201d at the 8ACM Conference on Principles and Practice of Parallel Programming, Jun. 18, 2001, Snowbird, Utah; and \u201cNon-Blocking Timeout in Scalable Queue-based Spin Locks,\u201d at the 21ACM Annual Symposium on Principles of Distributed Computing, Monterey, Calif., Jul. 22, 2002. The disclosures of both of those papers are hereby incorporated by reference in their entireties into the present disclosure.","While two preferred embodiments, with variants, have been set forth in detail, those skilled in the art who have reviewed the present disclosure will readily appreciate that other embodiments can be realized within the scope of the invention. For example, the present invention is not limited to any particular hardware, nor is it limited to any particular operating system or programming language. Similarly, on a non-cache-coherent machine, the CLH try and CLH-NB try locks could easily be modified to spin only on local variables, using an extra level of indirection. Therefore, the present invention should be construed as limited only by the appended claims."],"GOVINT":[{},{}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Two preferred embodiments of the invention (one based on the CLH lock, the other based on the MCS lock), each with two variants (one with guaranteed linear space but blocking timeout, the other with non-blocking timeout but theoretically unbounded space) will be set forth in detail with reference to the drawings, in which:",{"@attributes":{"id":"p-0017","num":"0021"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0018","num":"0022"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0019","num":"0023"},"figref":"FIG. 1C"},{"@attributes":{"id":"p-0020","num":"0024"},"figref":"FIG. 1D"},{"@attributes":{"id":"p-0021","num":"0025"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0022","num":"0026"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0023","num":"0027"},"figref":"FIG. 2C"},{"@attributes":{"id":"p-0024","num":"0028"},"figref":"FIG. 2D"},{"@attributes":{"id":"p-0025","num":"0029"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0026","num":"0030"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0027","num":"0031"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0028","num":"0032"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0029","num":"0033"},"figref":"FIG. 4C"},{"@attributes":{"id":"p-0030","num":"0034"},"figref":"FIG. 4D"},{"@attributes":{"id":"p-0031","num":"0035"},"figref":"FIG. 4E"},{"@attributes":{"id":"p-0032","num":"0036"},"figref":"FIG. 4F"},{"@attributes":{"id":"p-0033","num":"0037"},"figref":"FIG. 4G"},{"@attributes":{"id":"p-0034","num":"0038"},"figref":"FIG. 4H"},{"@attributes":{"id":"p-0035","num":"0039"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0036","num":"0040"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0037","num":"0041"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0038","num":"0042"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0039","num":"0043"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0040","num":"0044"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0041","num":"0045"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
