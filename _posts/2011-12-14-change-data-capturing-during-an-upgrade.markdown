---
title: Change data capturing during an upgrade
abstract: In one general aspect, a computer system can include instructions stored on a non-transitory computer-readable storage medium. The computer system can include a logging table generator configured to generate a logging table corresponding with an original table targeted for an upgrade, and a control table generator configured to generate a control table configured to store a version identifier for changes logged in the logging table. The computer system can include a change recorder configured to receive an indicator of a change to a record of the original table during execution of at least a portion of the upgrade of the original table, and a key recorder configured to store in the logging table a primary key identifying the record of the original table and the version identifier stored in the control table.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09213728&OS=09213728&RS=09213728
owner: SAP SE
number: 09213728
owner_city: Walldorf
owner_country: DE
publication_date: 20111214
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This description relates to upgrading an original system to a target system.","Many known techniques for adjusting database objects within an original system can cause an undesirable level of downtime within the original system. For example, using many of these known techniques, all of the database objects of an original system may be unavailable to users while the database objects are being adjusted, and thus the upgrading of the system may necessarily be implemented during a downtime of the entire original system. The duration and impact of the downtime of the original system and\/or unavailability of the database objects targeted for upgrade aggravated by known computationally expensive and\/or time-consuming algorithms employed during modification of the database objects of the original system into an upgraded form. Thus, a need exists for systems, methods, and apparatus to address the shortfalls of present technology and to provide other new and innovative features.","In one general aspect, a computer system can include instructions stored on a non-transitory computer-readable storage medium. The computer system can include a logging table generator configured to generate a logging table corresponding with an original table targeted for an upgrade, and a control table generator configured to generate a control table configured to store a version identifier for changes logged in the logging table. The computer system can include a change recorder configured to receive an indicator of a change to a record of the original table during execution of at least a portion of the upgrade of the original table, and a key recorder configured to store in the logging table a primary key identifying the record of the original table and the version identifier stored in the control table.","In another general aspect, a non-transitory computer-readable storage medium can store code representing instructions that when executed are configured to cause a processor to perform a process. The code can include code to generate a logging table corresponding with an original table targeted for an upgrade, and to generate a control table configured to store a version identifier for changes logged in the logging table. The code can also include code to receive an indicator of a change to a record of the original table during execution of at least a portion of the upgrade of the original table, and to store in the logging table a primary key identifying the record of the original table and the version identifier stored in the control table.","In yet another general aspect, a method can include executing instructions recorded on a non-transitory computer-readable storage media using at least one processor. The method can include generating a logging table corresponding with an original table targeted for an upgrade, and generating a control table configured to store a version identifier for changes logged in the logging table. The method can include receiving an indicator of a change to a record of the original table during execution of at least a portion of the upgrade of the original table, and storing in the logging table a primary key identifying the record of the original table and the version identifier stored in the control table.","The details of one or more implementations are set forth in the accompanying drawings and the description below. Other features will be apparent from the description and drawings, and from the claims.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 1","FIG. 1"],"b":["170","17","12","15","10","10","12","15","17","10","12","15","17","12","17","170"]},"In some embodiments, the upgrade can include a software and\/or a hardware upgrade to one or more portions of the original system , an upgrade to a format, a logical structure, data etc. of at least a portion of the original system , and\/or so forth. In some embodiments, the original system  can be a stand-alone device and\/or module, a server, a network, a data center, a software and\/or hardware system, a virtual system, a system (e.g., an SAP system) defined based on Advanced Business Application Programming (ABAP), and\/or so forth. In some embodiments, the target system  can be a physically different system from the original system , or can be an upgraded version of the original system  that is included in the hardware (e.g., same hardware) of the original system .","As shown in , the original table  (e.g., the source table) can be related to, or can include, program data and\/or user data. For example, the original table  can include data defined by an owner of the original system . For example, the original table  can include user-specific data such as business data, financial data, and\/or so forth. In some embodiments, the data stored within the original table  can be referred to as customer data. In some embodiments, the original table  can be referred to as a customer database. The original table  can include, or can be, for example, data (e.g., configuration data) associated with a program of the original system . In some embodiments, the data stored within the original table  can be referred to as system data. If the original system  is an ABAP-based system, the original table  can be ABAP repository tables. In some embodiments, the original table  can include, or can be, more than one table or database. Although not shown in , the original table  can be associated with executable files. In some embodiments, the executable files can define at least a portion of the kernel associated with an operating system of the original system .","The system upgrade module  can be configured to facilitate upgrading of the original system  to the target system  so that downtime of the original system  can be maintained at a relatively low level (e.g., reduced, minimized) during an upgrade process. In other words, the system upgrade module  can be configured to facilitate upgrading of the original system  to the target system  so that uptime of the original system  can be maintained at a relatively high level (e.g., increased, minimized) during an upgrade process. The terms up\/upstate and down\/downstate will be used to describe a functional state of a system (e.g., the target system , the original system ), while the terms uptime and downtime will be used to describe the accessibility of the system by one or more users (while in a functional state). Thus, a system may be functional, but not accessible (e.g., accessible in a typical operational mode) by a typical user (e.g., a non-admin user) when the system is up. In other words, the system can be in downtime, and may not be accessible by a typical user, even though the system is up (e.g., in an upstate). The system, however, will be functional and accessible by a typical user during uptime. For example, when the original system  is in a downstate during downtime of the original system , data from the original table  of the original system  may not be accessed by a user of the original system . Instead, the original table  may be locked so that data cannot be retrieved from and\/or stored to the original table .","The system upgrade module  can be configured to record (e.g., log, store) changes to the original system  while upgrading of the original system  to the target system  is in process so that an uptime of the original system  can be maintained at a relatively high level. Because portions of the original system  can be in uptime during an upgrade process to the target system , changes to the original system  may continually be occurring during the upgrading to the target system . The portions of the original system  can be in uptime so that a typical user may continue to access the original system  rather than locking the entire original system  during the upgrade process. The changes to the original system  that are recorded during the upgrade process can later be transferred (e.g., transferred during a later portion of the upgrade process) to the target system .","For example, after a portion of data stored in the original table  has been migrated during an upgrade process into the target table  (which can be structurally upgraded from the original table ), subsequent changes to the portion of the data stored in the original table  may occur, or may be triggered, by a user accessing the data in the original table . The subsequent changes can be recorded (e.g., logged, stored) by the system upgrade module  and later transferred into the target table . Only the subsequent changes may be recorded and transferred so that all of the data that was previously migrated may not need to be re-migrated into the target table  because of the subsequent changes. This recording and transfer process (which can be at least a portion of a change recording process or as a change data capturing process) can be iteratively performed during the upgrade process until the upgrade process is completed. By so doing, users may continue to access and use the original table  in uptime while other processing to implement the upgrade process can be performed, and any changes to the original table  that occur during the upgrade process may not be missed (or may be minimized) and can eventually be transferred into the target table .","In some embodiments, upgrading to the target system  can be performed via a shadow system (not shown). The shadow system can be an environment within which certain operations of an upgrade process can be performed so that the original system  can operate in an active mode (e.g., remain in an upstate\/uptime, continue in a normal operational environment) during the upgrade process. Specifically, the shadow system can include one or more portions (e.g., databases, executable files) that correspond with portions (e.g., databases, executable files) of the original system . The portions of the shadow system that correspond with the portions of the original system  can be referred to as corresponding portions. In some embodiments, the portions of the shadow system that correspond with the portions of the original system  can be upgraded versions (e.g., modified versions) or exact copies of the portions of the original system . Portions of the upgrade process of the original system  can be performed on the corresponding portion(s) of the shadow system while the original system  operates in an active mode. The corresponding portions of the shadow system, after being upgraded, can later be copied into (and replace portions of) the original system .","By performing certain portions of the upgrade process on the shadow system rather than directly on the original system , the downtime of the original system  can be lower than if certain portions of the upgrade process are performed directly on the original system . In some embodiments, the downtime of the original system  during an upgrade process can be minimized by performing certain portions of the upgrade process in the shadow system. In some embodiments, the shadow system can be referred to as a shadow system because portions of the shadow system can mirror (or shadow) certain portions of the original system . In some embodiments, the downtime of the original system  during an upgrade process can be minimized by performing certain portions of the upgrade process in the shadow system.","In some embodiments, a shadow system can be defined specifically for use during the upgrade process. Specifically, the shadow system can be a temporary system created for use during upgrade of the original system . After the original system  has been upgraded, the shadow system and\/or logs (e.g., change recording logs) associated with the shadow system can be dismantled and\/or expunged.","Any changes that occur to the original system  while portions of the upgrade process are performed on the shadow system can be recorded (e.g., logged) and later transferred into the shadow system. In some embodiments, the changes that occurred in the original system  or portions of that great process are performed on the shadow system can be iteratively recorded and transferred into the shadow system. More details related to a shadow system implementation are discussed in connection with, for example, .","As shown in , the system upgrade module  includes an upgrade module . The upgrade module  can be configured to perform various parts of an upgrade process. For example, the upgrade module  can be configured to identify whether or not portions of the original system  (e.g., original table  of the original system ) are to be upgraded. The upgrade module  can be configured to define one or more portions of the target system  and\/or a temporary system (e.g., a shadow system) (or portions thereof). In some embodiments, the upgrade module  can be configured to replicate, or initially transfer, data included in the original table  to the target table . The upgrade module  can be configured to modify one or more portions (e.g., a data portion, a structure portion) of the original system  and\/or target system  based on one or more customizations implemented within the original system . In some embodiments, the upgrade module  can be configured to dismantle (e.g., remove, disabled) one or more temporary systems (e.g., a shadow system) used during an upgrade process. The upgrade module  can be configured to handle an upgrade of one or more executable files (not shown) associated with the original system .","The upgrade module  can include a downtime execution module  configured to manage a downstate and\/or an upstate of the original system , the target system  and\/or a temporary system (e.g., a shadow system) during an upgrade process. During downtime, the original system  may be in a downstate or an upstate, and during the uptime, the original system  will be in an upstate.","In some embodiments, the downtime execution module  can be configured to suspend one or more batch jobs of the original system  when (e.g., before) a downtime of the original system  is initiated. In some embodiments, the downtime execution module  can be configured to log-off one or more user from the original system  before a downtime of the original system  is initiated.","As shown in , the system upgrade module  includes a change table generator  and a change recorder . The change table generator  is configured to generate (e.g., produce, define) one or more tables associated with the change recording process. The change recorder  is configured to record changes to the original table  into the tables generated by the change table generator .","Specifically, the change table generator  includes a logging table generator . The logging table generator  is configured to generate a logging table  where changes to at least a portion of the original system  (e.g., changes to the original table ) can be recorded. In this embodiment, the logging table  is stored in a memory  associated with the system upgrade module . For example, if a change to a record in the original table  occurs (e.g., is triggered), an indicator (e.g., a key (also can be referred to as a primary key) or other type of pointer) of the record can be recorded in the logging table . In some embodiments, a record can be referred to as an entry. The indicator stored in logging table  can function as an indicator that the change to the record, which should later be transferred to the target table , has occurred during the upgrade process. In other words, changes to one or more records included in the original table  can be identified within the logging table  using one or more indicators.","In some embodiments, various information (e.g., metadata) about the change to the record (e.g., entry) can be recorded in the logging table . For example, a date\/time stamp of the change to the record, information about the specifics of the change to the record, and\/or so forth can be recorded in logging table .","As shown in , the change recorder  includes a key recorder . The key recorder  can be configured to receive an indicator that a change to a record in the original table  has occurred. In response to the indicator of the change to the record, the key recorder  can be configured to record (e.g., log, store), in the logging table , a key (e.g., a copy of a key) related to the record that has changed. In some embodiments, the key can be a primary key uniquely identifying each record in the original table . Accordingly, the recording of the key (or copy thereof) in the logging table  can function as an indicator that the change to the record has occurred.","As a specific example, a record stored in the original table  can be associated with a key. As part of a first portion of an upgrade process, the logging table  can be generated by the logging table generator , and the record stored in the original table  can be migrated to the target table . During a second portion of the upgrade process, the record stored in the original table  can be modified (e.g., changed) by a user accessing the original table . In response to a modification to the record, a trigger (e.g., a database trigger generated by the original system  (e.g., the original table )) indicating that a modification to the record has occurred can be received by the key recorder , and the key recorder  can be configured to store the key (or a copy of the key) in the logging table . The key stored in logging table  can function as an indicator that the change to the record has occurred during the second portion of the upgrade process.","In some embodiments, because only an indicator of (e.g., a pointer to) a change to a record of the original table  is stored in logging table , a history of changes to the record of the original table  may not be stored in logging table . The indicator can point to a record (e.g., a location of a record) of the original table  that has changed without including specifics of a manner in which data within the record has changed. Accordingly, after the indicator of the change to the record of the original table  has been stored in the logging table , previous changes to the record of the original table  may not be recorded. Said differently, after the indicator of the change to the record of the original table  has been stored in the logging table , prior changes, which are subsequently overwritten with subsequent changes, may not be recalled because the specifics of the priori change may not be recorded. In other words, the indicator can be associated with multiple changes to the record of the original table  that can occur serially over a time period. Accordingly, only the last change (or the most recent change) to the record of the original table  may be retrieved from the original table .","As shown in , the control table generator  is configured to generate (e.g., define, produce) a control table . In this embodiment, the control table  is stored in a memory  of the system upgrade module . The control table  is configured to store a version identifier associated with a set (e.g., a batch, a group) of changes to records of the original table .","For example, a first set of changes to records of the original table  triggered during a first portion (e.g., a first time period) of an upgrade process can be associated with a first version identifier stored in the control table . A second set of changes to records of the original table  triggered during a second portion (e.g., a second time period) of an upgrade process can be associated with a second version identifier stored in the control table. In some embodiments, a version identifier can be referred to as a batch identifier or as a set identifier.","As shown in , the change recorder  includes a version generator . The version generator  is configured to define and store a version identifier in the control table . In some embodiments, the version generator  can be configured to increment (and replace) a version identifier stored in the control table . Although the control table  in this embodiment includes only one version identifier (e.g., one active version identifier), in some embodiments, multiple version identifiers (some of which may not be active) can be stored in the control table  by the version generator . In some embodiments, the version generator  can be configured to toggle a version identifier between different values (e.g., different version identifier values). In some embodiments, the version generator  can be configured to sequentially change (e.g., sequentially increase, sequentially decrease, monotonically change) a version identifier (e.g., a value of a version identifier).","In some embodiments, the version generator  can be configured to modify a version identifier stored in the control table  in response to a set of changes to records of the original table  being transferred to the target table . For example, as part of a first portion of an upgrade process, the logging table  and the control table  can be generated, and the original table  can be migrated to the target table . The version generator  can be configured to store a first version identifier (e.g., a version identifier having a first value) in the control table . During a second portion of the upgrade process, a set of records stored in the original table  can each be changed (e.g., can be changed serially and\/or in parallel) by a user accessing the original table . In response to the changes to the set of records, the key recorder  can be configured to store keys (or copies of the keys) in the logging table  associated with the set of records, and the set of records can be associated with the first version identifier stored in the control table  by the version generator . In response to the changes to the set of records being transferred (based on the keys stored in the logging table ) to the target table , a second version identifier (e.g., a version identifier having a second value) can be stored in the control table  by the version generator . Subsequent changes to records in the original table  can be associated with the second version identifier.","As shown in , the system upgrade module  includes a change transfer module . The change transfer module  can be configured to transfer changes to records included in the original table  and identified within the logging table  to the target table . In some embodiments, the change transfer module  can be configured to transfer one or more changes (e.g., a set of changes, a batch of changes) to records included in the original table to the target table . In some embodiments, the change transfer module  can be configured to transfer one or more changes based on a version identifier. For example, the change transfer module  can be configured to transfer a first set of changes identified within the logging table  and associated with a first version identifier to the target table  during a first portion of an upgrade process, and can be configured to transfer a second set of changes identified within the logging table  and associated with a second version identifier to the target table  during a second portion of the upgrade process.","In some embodiments, the change recorder  and the change transfer module  can be configured to iteratively perform recording and transferring, respectively, while the original system  is an uptime until the upgrade process is completed or nearly completed. In some embodiments, final changes to the original system  can be transferred by the change transfer module  while the original system  is locked in downtime. In some embodiments, the downtime execution module  can be configured to change the original system  from uptime to downtime.","If the original system  includes more than one original table (e.g., original table ), change recording may be activated (e.g., enabled) or deactivated (e.g., disabled) for all, or less than all of the original tables included in the original system . For example, in some embodiments, change recording can be activated for only original tables included in the original system  that are targeted for upgrade. In some embodiments, change recording may be activated for a subset of the original tables included in the original system  that are targeted for upgrade. In some embodiments, change recording may be activated for only original tables included in the original system  that have one or more characteristics, such as being greater than a specified size, including a particular type of data, being subject to a particular type of upgrade, and\/or so forth.","In some embodiments, change recording (e.g., a change recording process) can be activated for one or more original tables included in the original system  for a specified period of time. For example, change recording can be activated for the original table  during a first portion of an upgrade process, and can be deactivated for the original table  during a second portion of an upgrade process.","The tables described herein can be defined based on a structure, and the structure can include data. In other words, the tables described herein can have a structural component and a data component. The structural component can be associated with the data component, and vice versa. The structure of a table (such as the original table ) can be defined by rows and\/or columns. The data stored in the table can be divided into fields by the structure of the table. For example, a field of a table can be at an intersection of a row of the table and at a column of the table, and can include a portion of data. In some embodiments, the one or more of the table described herein can be, for example, MaxDB, an Oracle database, a DB2 database, and\/or so forth. In some embodiments, the tables discussed herein can be referred to as repositories.","The system upgrade module  can be, or can be included within, for example, a client device and\/or a server device. In some embodiments, the system upgrade module  can be, or can be included within, for example, a wired device and\/or a wireless device (e.g., wi-fi enabled device) and can be, for example, a computing entity (e.g., a personal computing device), a mobile phone, a personal digital assistant (PDA) and\/or so forth. The system upgrade module  can be configured to operate based on one or more platforms (e.g., one or more similar or different platforms) that can include one or more types of hardware, software, firmware, operating systems, runtime libraries, and\/or so forth. In some embodiments, the system upgrade module  can be defined using ABAP and\/or can be related to a NetWeaver platform.","In some embodiments, the memory  can be implemented as more than one memory component (e.g., more than one random-access memory (RAM) component or disk drive memory) associated with the system upgrade module . In some embodiments, the memory  can be, or can include, a non-local memory (e.g., a memory not physically included within the system upgrade module ) within a network (not shown). For example, the memory  can be, or can include, a memory shared by multiple system upgrade modules (not shown) within a network. In some embodiments, the memory  can be included in the system upgrade module , the original system  and\/or the target system .","Although not shown, the system upgrade module  can be configured to operate within an environment that includes an operating system. In some embodiments, the operating system can be configured to facilitate the functions of the system upgrade module .","In some embodiments, one or more portions of the components shown in the system upgrade module  in  can be, or can include, a hardware-based module (e.g., a digital signal processor (DSP), a field programmable gate array (FPGA), a memory), a firmware module, and\/or a software-based module (e.g., a module of computer code, a set of computer-readable instructions that can be executed at a computer). For example, in some embodiments, one or more portions of the system upgrade module  can be, or can include, a software module configured for execution by at least one processor (not shown). In some embodiments, the functionality of the components can be included in different modules and\/or components than those shown in . For example, although not shown, the functionality of the change table generator  can be included in a different module than the change table generator , or divided into several different modules (not shown).","In some embodiments, the system upgrade module , the original system , and\/or the target system  can be included within a network that can include multiple devices (e.g., multiple client devices, multiple server devices). For example, the network can be, or can include, a local area network (LAN), a wide area network (WAN), and\/or so forth. The network can be, or can include, a wireless network and\/or wireless network implemented using, for example, gateway devices, bridges, switches, and\/or so forth. The network can include one or more segments and\/or can be have portions based on various protocols such as Internet Protocol (IP) and\/or a proprietary protocol. The network can include at least a portion of the Internet. Also, although not shown in , the system upgrade module  can be configured to function within various types of network environments. In some embodiments, the system upgrade module  can represent, or can be included within, a cluster of modules\/devices. In such an embodiment, the functionality and processing of the system upgrade module  can be distributed to several modules\/devices of the cluster of modules\/devices.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 2","FIG. 1"],"b":"170"},"A logging table corresponding with an original table targeted for an upgrade can be generated (block ). In some embodiments, the logging table generator  shown in  can be configured to generate the logging table corresponding with the original table targeted for the upgrade. In some embodiments, the original table can be identified for the upgrade by the upgrade module  shown in . In some embodiments, the logging table can be generated during an upgrade process.","A control table configured to store a version identifier for changes logged in the logging table can be generated (block ). In some embodiments, the control table generator  shown in  can be configured to generate the control table configured to store the version identifier for changes logged in the logging table. In some embodiments, the version identifier can be defined by the version generator  shown in . In some embodiments, the version identifier can be associated with a set of changes logged in logging table.","An indicator of a change to a record of the original table can be received during execution of at least a portion of the upgrade of the original table (block ). In some embodiments, the change recorder  shown in  can be configured to receive the indicator of the change to the record of the original table during execution of at least the portion of the upgrade of the original table. In some embodiments, the indicator the change to the record can be a database trigger produced by the original table and\/or an original system of the original table.","A primary key identifying the record of the original table and the version identifier stored in the control table can be stored in the logging table (block ). In some embodiments, the key recorder  shown in  can be configured to store in the logging table the primary key identifying the record of the original table and the version identifier stored in the control table. In some embodiments, the primary key can uniquely identify the record of the original table from other records of the original table, or from other original tables included in an original system.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 3","b":["310","320","330","310","205","320","330","310","310","320","330"]},"As shown in , the original table  includes several records  (e.g., entries) including data D through DN. In this embodiment, each of the records  includes a key represented as keys K through KN. In some embodiments, the keys K through KN can also function as a data of the original table . In some embodiments, the data D through DN can include multiple fields. For example, data D can include multiple fields of data.","In some embodiments, one or more of the keys K through KN can be referred to as a primary key. The keys K through KN can each be used to identify (e.g., uniquely identify at least one of the records  of the original table . For example, the key K can be used to identify the record  associated with key K and data D.","In some embodiments, one or more of the keys K through KN can include data stored in the original table  that is unique and\/or that is generated by the original system  as, for example, a globally unique identifier (GUID). In some embodiments, one of the keys can include, or can be, multiple fields of data within the original table  associated with one of the records  of the original table . For example, the key K can include multiple fields of data.","The logging table  is configured to store one or more of the keys K through KN of records  of the original table  that have been changed during an upgrade process. In this embodiment, key K and key K are stored in logging table  because the records associated with each of these keys has been changed during an upgrade process.","As shown in , each of the keys K and K are associated with a version identifier V. In this embodiment, the version identifier V is stored in the control table . In some embodiments, the version identifier V can be used to identify a batch or set of changes occurring during a specified time period to records  of the original table  during an upgrade process. In some embodiments, the version identifier V can be used to identify a packet (e.g., a data packet) including a change to one or more of the records .","In this embodiment, each of the keys stored in the logging table  is associated with an identifier of an operation. Specifically, key K is associated with operation identifier O, and key K is associated with operation identifier O. In some embodiments, the operation identifiers can identify a database operation such as a modification, deletion, a replacement, and\/or so forth.","As shown in , the logging table  corresponds with the original table . In some embodiments, the logging table  can be the only logging table corresponding with the original table . In other words, a one-to-one correspondence between logging tables and original tables can be implemented. In some embodiments, logging table  can be associated with multiple original tables (e.g., original table ), or the original table  can be associated with multiple logging tables (e.g., logging table ).","In some embodiments, a logging table, such as logging table , may be generated only for original tables that are targeted for upgrade. Accordingly, logging tables may not be generated for original tables that are not targeted for upgrade.","As shown in , the control table  includes a single entry, which is the version identifier V. In some embodiments, the control table  may only include a single entry corresponding with a version identifier. In some embodiments, if the version identifier is updated within the control table , the version identifier can be replaced (e.g., replaced with a version identifier having a different value). In some embodiments, the control table  can correspond with one or more logging tables (e.g., logging table ) and\/or with one or more original tables (e.g., original table ). In other words, only a single instance of the control table  can exist so that the version identifier V is global for all or many logging tables (e.g., logging table ).","Although not shown in , the logging table  can be indexed so that one or more of the changes logged in logging table  can be readily searched and\/or accessed. In some embodiments, the logging table  can be indexed using unique indices and\/or non-unique indices. In some embodiments, the use of unique indices and\/or non-unique indices for logging table  can be contingent on a number of fields (e.g., a combined number of fields) associated with entries (e.g., each entry, each record) of the logging table .","For example, in some embodiments, if a number of fields (e.g., a combined number of fields) associated with the key and the version identifier stored in logging table  is less than a threshold value (e.g., less than 16 fields, less than 10 fields, less than 32 fields), the logging table  can be indexed using unique indices (or non-unique indices). In some embodiments, if a number of fields associated with the key and the version identifier stored in logging table  is equal to a threshold value (e.g., equal to 16 fields), the logging table  can be indexed using two non-unique indices (or unique indices)\u2014one non-unique set of indices for the keys and one non-unique set of indices for the version identifiers. If the number of fields associated with the key and the version identifier stored in logging table  is greater than the threshold value, the non-unique set of indices can include, for example, a number of fields (e.g., a number of fields that are database management system specific).",{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIG. 4A","FIG. 1"],"b":"170"},"As shown in , after an upgrade process related to an original system has been started (block ), tables for change recording can be generated and a version identifier can be set (e.g., defined) (block ). Specifically, a logging table can be generated for each original table targeted for upgrading, and a control table can be generated for all (or a portion) of the logging tables. In some embodiments, the tables for change recording can be generated via an application programming interface.","After the tables for change recording have been generated and the version identifier has been set (block ), change recording can be started (block ). In other words, change recording can be switched on. In some embodiments, change recording can be started during certain portions of an upgrade process such as before an initial transfer of data from the original database to the target database. In other words, initial transfer of data can be triggered after change recording has been started (block ). In some embodiments, when the change recording is started, profile parameters associated with a database interface (DBI) can be defined.","As shown in , changes can be recorded (block ), and recorded changes can be transferred (block ). In some embodiments, the recorded changes can be transferred periodically, randomly, based on a schedule, in response to a certain number of changes being recorded, based on transitions of the upgrade process, and\/or so forth. For example, changes can be recorded after a specified period of time has passed. In some embodiments, various after import methods (AIMs) and\/or execution of programs after import (XPRAs) can be performed after recorded changes have been transferred. In some embodiments, an AIM can be a method (e.g., an executable program) configured to modify one or more tables so that the table(s) are compatible with, for example, a system upgrade. In some embodiments, an AIM can be configured to produce runtime information, and\/or can be configured to generate code that can produce runtime information. Similar to an AIM, an XPRA can be a method (e.g., an executable program) configured to modify one or more of the tables so that the table(s) are compatible with, for example, a system upgrade. In some embodiments, an XPRA may not be configured to produce runtime information.","In some embodiments, a wait period can be implemented between starting change recording (block ) and recording of changes (block ). The wait period can be implemented until one or more operations are completed so that change recording can be activated on all affected tables (e.g., all tables targeted for upgrades) in a desirable fashion. For example, in some embodiments, such as database interface embodiments, the wait period can be implemented until array inserts have been completed.","Also, in some embodiments, an initial data transfer can be performed between starting change recording (block ) and recording of changes (block ). In some embodiments, the initial data transfer can be a transfer of data from an original table into, for example, a shadow table with or without a common interface. In some embodiments, after the initial data transfer, an original table may have a consistent state with a target table so that the various after import methods (AIMs) and\/or execution of programs after import (XPRAs) can be performed.","As shown in , changes can be recorded (block ) and recorded changes can be transferred (block ) iteratively until change recording has been completed (block ). Also as shown in , with each iteration of change recording and transferring of changes, the version identifier is updated (block ) (if change recording has not been completed). In some embodiments, the version identifier can be changed (e.g., toggled) between two or more different version identifiers (e.g., different alley use).","For example, during a first iteration of change recording (or a portion thereof), changes to one or more original tables of the original system that are associated with a version identifier having a first value can be transferred to, for example, one or more target tables. After the first iteration of change recording (or the portion thereof), the version identifier can be updated to a second value. During a second iteration (after the first iteration) of change recording (or the portion thereof), changes to one or more original tables of the original system that are associated with the version identifier having the second value can be transferred to, for example, one or more target tables. After the second iteration of change recording (or the portion thereof), the version identifier can be changed back to the first value. During a third iteration of change recording (or the portion thereof), changes to one or more original tables of the original system can be associated with the version identifier having the first value. Each iteration of change recording can similarly be performed as the version identifier is toggled between the first value and the second value. The change recording and transfer of recorded changes can be performed by processes executing in parallel. More details related to change recording and transferring of recorded changes based on parallel processes are described below.","In some embodiments, a version identifier can be associated with a partition of a logging table. Specifically, a version identifier having a first value can be associated with a first partition of a logging table and a version identifier having a second value can be associated with a first partition of a logging table. In some embodiments, the version identifiers can be associated with different batches or packets including changes to records. In some embodiments, collisions between different batches or packets of changes to records can be avoided (e.g., substantially avoided) by assigning different version identifiers to different partitions of the logging table.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIGS. 5A and 5B","FIGS. 5A and 5B"],"b":["400","400","400"]},"As shown in , changes (e.g., changes identified using keys associated with records) can be recorded to partition A, which is associated with the first version identifier, while changes can be transferred (in parallel) from partition B, which is associated with the second version identifier. While changes are being transferred from partition B, the partition B can be locked so that information may not be written to the partition B. As shown in , changes can be recorded to partition B, which is associated with the first version identifier, while changes can be transferred (in parallel) from partition A, which is associated with the second version identifier. While changes are being transferred from partition A, the partition A can be locked so that information may not be written to the partition A.","In some embodiments, change recording can alternate between  and . For example, a first set of changes can be recorded to partition A during a first time period in association with a first version identifier (which can be stored in a control table during the first time period), and the first set of changes recorded to partition A can be transferred during a second time period in associated with a second version identifier (which can be stored in the control table during the second time period). During the first time period, a second set of changes previously recorded to partition B can be transferred from partition B while the first set of changes are being recorded to partition A. During the second time period, a third set of changes can be recorded to partition B in association with the first version identifier (which can be stored in the control table during the third time period) while the first set of changes are being transferred from partition A. The third set of changes recorded to partition A during the second time period can be transferred from the partition A from the third time period. Accordingly, changes can be alternately (and cyclically) recorded to each of the partitions of the logging table , and the changes can be associated with a version identifier that is stored in a control table. In some embodiments, a wait time period can be implemented between changing of a version identifier (e.g., changing a current version identifier to a subsequent version identifier) (or commencing recording\/transferring of changes to\/from a partition of the logging table ) so that an operation that was started with a version identifier can be completed before the version identifier is changed.","Referring back to , in some embodiments, a system (e.g., the original system, a logging table) can be locked (and changed into downtime or a downstate) before or after a final iteration of changes are recorded (block ) and the recorded changes are transferred (block ). In some embodiments, before the final transfer is initiated, all users can be logged off from the original system. The users may be logged off so that final changes to the original system can be transferred to a target system (and\/or a shadow system) without intervening changes disrupting the final transfer of changes.","In some embodiments, before the final transfer is initiated, batch jobs scheduled for execution within the original system can be suspended. In some embodiments, batch jobs may be permanently suspended or may be temporarily suspended. In some embodiments, the batch jobs can include processing of data within an original table. After the final transfer, functionality associated with transfer of data from the original system to a target system (and\/or a shadow system) can be turned off (e.g., disabled, deactivated).","In some embodiments, one or more iterations of recording changes (block ) and\/or transfer of recorded changes (block ) can be manually triggered by a user and\/or an administrator. In some embodiments, deletions and\/or modifications (which are different types of changes) can be recorded separately (during block ) and\/or transferred separately (during block ). In some embodiments, deletions can be recorded and\/or transferred before modifications are recorded and\/or transferred, and vice versa.","As shown in , change recording can be stopped (block ) after change recording has been completed (block ). In some embodiments, change recording can be stopped after all changes have been recorded (block ) and transferred (block ). After change recording has been stopped, an upgrade process can be ended (block ).","In some embodiments, recording of changes and transferring of recorded changes can be associated with processes that operate in parallel and\/or operate as independent processes. For example, a process of recording of changes can be continually executed in parallel with a process of transferring of recorded changes until all recorded changes have been transferred.  is a diagram that illustrates processes for recording of changes and transferring of recorded changes being executed in parallel. As shown in , change recording  is shown (on the left side of the flowchart) as operating in parallel with version identifier updating , transfer of recorded changes , and determining whether or not change recording has been completed  (on the right side of the flowchart). These parallel processes are illustrated as both being triggered to start when change recording is started (block ) and as both being triggered to stop when change recording is stopped (block ).","Even though processes associated with change recording and transferring of recorded changes are executing in parallel, changes can be recorded and recorded changes can be transferred, during several iterations. Specifically, during a first iteration, changes can be recorded and associated with a version identifier while changes that were previously recorded and associated with a prior version identifier can be transferred. During a second iteration, changes that were recorded and associated with the version identifier during the first iteration can be transferred while new changes can be recorded and associated with a subsequent version identifier.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":["FIG. 6","FIG. 6"],"b":["640","650","610","620","630","640","650","610","640","610","650"],"sub":["ORIGINAL","LOG","CONTROL"]},"The modification view  can include references (e.g., links, pointers) to records (e.g., rows) of the original table  which have been modified during an upgrade process. In some embodiments, the modification view  can be generated using an operation having the following form:","SELECT A.KEYS, A.DATA FROM TA, TB WHERE A.KEYS=B.KEYS AND B.OPERATION=\u2018M\u2019 AND B.VERSION=(SELECT VERSION\u22121 FROM T).","The deletions view  can include, for example, keys associated with (e.g., identifying) the records (e.g., rows) of the original table  which have been deleted during an upgrade process. In some embodiments, the deletions view  can be generated using an operation having the following form:","SELECT KEYS FROM TWHERE OPERATION=\u2018D\u2019 AND VERSION=(SELECT VERSION\u22121 FROM T).","In some embodiments, the access views can be used to hide the details of concrete change data recording implementations (e.g., implementations related to a system upgrade module such as system upgrade module ) from a consumer and to simplify the processing of changes.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":["FIG. 7","FIG. 7","FIG. 7"],"b":["770","710","720","770","742","750","770","744","746","732","734","742","744","746"]},"In some embodiments, at least some portions of the target table  can be generated (e.g., updated during a change recording process) based on modification view  and\/or the deletions view . In some embodiments, at least some portions of the target table  can be generated (e.g., updated during a change recording process) based on the original table , the logging table  and\/or the control table .",{"@attributes":{"id":"p-0093","num":"0092"},"figref":["FIG. 8","FIG. 8","FIG. 8"],"b":["890","892","830","892","870","820","830","870","842","860","890","892","830","810"]},"The productive system  and the shadow system  operate based on different schema for separation of database access. Specifically, the productive system  operates based on an original schema, and the shadow system  operates based on a shadow schema (also can be referred to as a target schema). In some embodiments, the tables (e.g., objects) can be located (e.g., physically located) in the productive system  (and operate based on the original schema), and the tables included in the shadow system  can have references (e.g., aliases) to the tables in the productive system . For example, an alias target table , which includes references to the target table , operates within the shadow system .","As shown in , the shadow system  and the productive system  can be configured to operate within a common set of hardware (e.g., a common set of servers, a common network) of the database environment , but can be operating within different partitions represented by the dashed line. In some embodiments, the shadow system  and productive system  may not be operating in different partitions and\/or may not be operating based on different platforms. Although not shown, in some embodiments, portions of the shadow system  and\/or portions of the and productive system  can be defined so that they operate within different sets of hardware and\/or in different environments. In some embodiments, the shadow system  can be implemented as a virtual system (e.g., as a virtual machine).","As shown in , the system upgrade module  can be configured to implement a change recording process using a logging table  and a control table , which are on the productive system . As shown in , a modification view  and a deletions view  can be generated based on the original table , the logging table , and\/or the control table . In this embodiment, the modification view  and the deletions view  operate within the shadow system . In some embodiments, the modification view  and the deletions view  can reference (e.g., can be aliased to) the tables (e.g., the original table , the logging table , the control table ) in the productive system .","In some embodiments, at least some portions of the target table  can be generated (e.g., updated during a change recording process) based on modification view  and\/or the deletions view . In some embodiments, at least some portions of the target table  can be generated (e.g., updated during a change recording process) based on the original table , the logging table  and\/or the control table .","As shown in , some of the tables related to a change recording process operate within the productive system  and some of the tables operate within the shadow system . In this embodiment, the logging table  and\/or the control table  can operate within the productive system  based on the original schema so that they can be accessed by, for example, a database interface (DBI). The access views\u2014modification view  and deletions view \u2014can be generated in the shadow system  so that the data transfer can be realized in the shadow system . In some embodiments, the system configuration shown in  can reduce the processing load (e.g., resource load) on the productive system , which is intended for productive use by one or more users.",{"@attributes":{"id":"p-0099","num":"0098"},"figref":["FIG. 9","FIG. 9"],"b":["970","910","930","920","990","970","942","930","950","990","930","990"]},"In some embodiments, at least some portions of the target table  can be generated (e.g., updated during a change recording process) based on a modification view  and\/or a deletions view . In some embodiments, at least some portions of the target table  can be generated (e.g., updated during a change recording process) based on the original table , a logging table  and\/or a control table .","In some embodiments, the remote system configuration can be used in Lifecycle Management (LM) scenarios (in a software engineering context) including database and\/or unicode migrations. In some embodiments, such a setup can be used in Integrated Upgrade and Unicode Conversion (IUUC) or Incremental Migration (IMIG) scenarios (which can be associated with LM procedures) to take advantage of DBI-based change data capturing implementations.","Implementations of the various techniques described herein may be implemented in digital electronic circuitry, or in computer hardware, firmware, software, or in combinations of them. Implementations may be implemented as a computer program product (e.g., a computer program tangibly embodied in an information carrier, a machine-readable storage device, a computer-readable medium, a tangible computer-readable medium), for processing by, or to control the operation of, data processing apparatus (e.g., a programmable processor, a computer, or multiple computers). In some implementations, a tangible computer-readable storage medium can be configured to store instructions that when executed cause a processor to perform a process. A computer program, such as the computer program(s) described above, can be written in any form of programming language, including compiled or interpreted languages, and can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program can be deployed to be processed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.","Method steps may be performed by one or more programmable processors executing a computer program to perform functions by operating on input data and generating output. Method steps also may be performed by, and an apparatus may be implemented as, special purpose logic circuitry (e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit)).","Processors suitable for the processing of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. Elements of a computer may include at least one processor for executing instructions and one or more memory devices for storing instructions and data. Generally, a computer also may include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data (e.g., magnetic, magneto-optical disks, or optical disks). Information carriers suitable for embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices (e.g., EPROM, EEPROM, and flash memory devices); magnetic disks (e.g., internal hard disks or removable disks); magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory may be supplemented by, or incorporated in special purpose logic circuitry.","To provide for interaction with a user, implementations may be implemented on a computer having a display device (e.g., a cathode ray tube (CRT), a light emitting diode (LED), or liquid crystal display (LCD) display device) for displaying information to the user and a keyboard and a pointing device (e.g., a mouse or a trackball) by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback (e.g., visual feedback, auditory feedback, or tactile feedback); and input from the user can be received in any form, including acoustic, speech, or tactile input.","Implementations may be implemented in a computing system that includes a back-end component (e.g., as a data server), or that includes a middleware component (e.g., an application server), or that includes a front-end component (e.g., a client computer having a graphical user interface or a Web browser) through which a user can interact with an implementation, or any combination of such back-end, middleware, or front-end components. Components may be interconnected by any form or medium of digital data communication (e.g., a communication network). Examples of communication networks include a local area network (LAN) and a wide area network (WAN) (e.g., the Internet).","While certain features of the described implementations have been illustrated as described herein, many modifications, substitutions, changes and equivalents will now occur to those skilled in the art. It is, therefore, to be understood that the appended claims are intended to cover all such modifications and changes as fall within the scope of the implementations. It should be understood that they have been presented by way of example only, not limitation, and various changes in form and details may be made. Any portion of the apparatus and\/or methods described herein may be combined in any combination, except mutually exclusive combinations. The implementations described herein can include various combinations and\/or sub-combinations of the functions, components and\/or features of the different implementations described."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIGS. 4A and 4B"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 5A and 5B"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
