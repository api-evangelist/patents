---
title: Cross-domain solution (CDS) collaborate-access-browse (CAB) and assured file transfer (AFT)
abstract: Systems and methods for providing a cross-domain, remote terminal secure browse capability are disclosed. The Collaborate-Access-Browse (CAB) Cross-Domain Solution (CDS) enables high-side users to browse low-side material with the same privileges as any other low-side user. The Assured File Transfer (AFT) CDS allows the high-side user to initiate file transfers from the low side to the high side so the browser-found data can be manipulated on the high side if needed. AFT provides for a bi-directional file exchange. High-side users can also initiate a file exchange from their high side to the low side, assuming the file contains only the appropriately classified information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08769127&OS=08769127&RS=08769127
owner: Northrop Grumman Systems Corporation
number: 08769127
owner_city: Falls Church
owner_country: US
publication_date: 20070212
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application claims priority from U.S. Provisional Patent Application Ser. No. 60\/771,901, filed Feb. 10, 2006, and from U.S. Provisional Patent Application Ser. No. 60\/897,246, filed Jan. 25, 2007, both of the disclosures of which is hereby incorporated by reference in their entirety.","1. Field of the Invention","The invention relates generally to a secure, cross-domain information exchange capability. The Collaborate-Access-Browse (CAB) Cross-Domain Solution (CDS) component enables high-side users to browse low-side material with the same privileges as any other low-side user. The Assured File Transfer (AFT) CDS allows the high-side user to initiate file transfers from the low side to the high side so the browser-found data can be manipulated on the high side if needed. AFT provides for a bi-directional file exchange. High-side users can also initiate a file exchange from their high side to the low side, assuming the file contains only the appropriately classified information.","2. Description of Related Art","In the late 1990s, the Joint Chiefs of Staff (JCS) procured a Cross-Domain Solution (CDS) to permit users on the Joint Staff Integrated Network-Top Secret (JSIN-T) to communicate with users on the Joint Staff Integrated Network-Secret (JSIN-S). This component-based solution, termed CyberShield, provided JCS with operational functionality to permit connectivity. In early 2005, the CyberShield device became inoperative. Other component-based solutions that have been identified as possible replacements have failed to provide the needed security functionality for the overall system. The JCS challenged the National Security Agency (NSA) with providing a solution to furnish the applicable security while not impinging on current business practices (e.g., unrestricted browsing using HTTP and sharing files between domains).","Systems and methods for providing a cross-domain, remote terminal secure browse capability are disclosed. In one embodiment, the Collaborate-Access-Browse (CAB) Cross-Domain Solution (CDS) component enables high-side users to browse low-side material with the same privileges as any other low-side user. In one embodiment, a second component, the Assured File Transfer (AFT) CDS allows the high-side user to initiate file transfers from the low side to the high side so the browser-found data can be manipulated on the high side if needed. AFT provides for a bi-directional file exchange. High-side users can also initiate a file exchange from their high side to the low side, assuming the file contains only the appropriately classified information.","One embodiment includes a cross-domain information exchange system comprising a client, a translator, a guard associated with the client and the translator, and a terminal server associated with the translator. The guard is configured to communicate with the client and the translator over a first protocol and the translator is configured to communicate with the terminal server over a second protocol. The first protocol is a Virtual Desktop Protocol (VDP) that is configured to provide remote, securable virtualization of a graphical user desktop to the client and the second protocol may be a commercially available standard desktop protocol.","Another embodiment is a cross-domain file exchange system comprising a first client, a second client and a guard associated with the first client and second client. The guard is configured to provide secure bi-directional file transfer between the first client and second client.","As will be realized, this invention is capable of other and different embodiments, and its details are capable of modification in various obvious respects, all without departing from this invention. Accordingly, the drawings and descriptions are to be regarded as illustrative in nature and not as restrictive.","This section provides a high-level description of the CAB Browse system, identifying what functionality is provided to users. It provides an overview of the major components of the CAB Browse system: the high-side Client, the Guard, the Translator, the Terminal Server and the Virtual Desktop Protocol (VDP). Descriptions of the individual components that make up the CAB system are covered in their respective sections below.","In this embodiment,  shows an example of a high-level functional view of the CAB system. CAB is a cross-domain solution that reflects the need for communications among different security level domains. For example, as the number of joint coalition efforts in which the US participates continues in increase, the number of different classification levels and networks to which users need access continue to grow. CAB, as the leading CDS solution, offers technology that is directed at addressing the needs of U.S. warfighters and the Intelligence community.","In this embodiment, a CDS solution preferably requires that content, services and applications of a lower clearance domain be available to users on a domain of a higher security clearance (high-side users). This need is in conflict with present system designs, whose security features were designed to make sharing of information across domains virtually impossible. While unidirectional communication from lower to higher domain networks is possible, a CDS solution should address the bi-directional communications needs of today's environment. Careful control of cross-domain communications should ensure that only appropriate content is exchanged.","In this embodiment, accomplishing this requires a set of mechanisms to ensure that high-side users are protected from low-side threats and malicious intent. Not only must the system protect the high-side users, but it should also make certain that of higher-level domain's information does not unintentionally reach the low-side domain","Referring to , at the highest level of one embodiment, CAB may consist of five primary system components:\n\n","In this embodiment, the CAB Client may be designed to run as an application or applet on an existing high-side workstation. Using this Client, and no additional hardware or network infrastructure, each user can obtain access to a low-side CAB Terminal Server session. Once a high-side user has authenticated through the Guard and established a session, they can access all low-side applications, resources and services that have been configured for use on the Terminal Server. It is the role of the CAB Client to present the virtual low-side session in a manner that closely resembles a native low-side session, and supports intuitive and responsive interaction with that session.","In this embodiment, in order to virtualize the low-side session, the Client is responsible for:\n\n","In this embodiment, at the same time, the CAB Client preferably implements methods to isolate the high-side desktop environment from the Client process, i.e., sandboxing technology. For example, the CAB Client preferably does not have write access to the high-side workstation hard drive, and preferably does not receive inadvertent mouse and keyboard events intended for other high-side applications.","In one embodiment, the CAB Browse Guard is preferably a cross-domain high-assurance device designed to enforce secure communications between a high-side CAB Client and a low-side Translator\/Terminal Server. The Guard may be designed to communicate only over the VDP protocol, and may not accept communications over any other. The Guard can receive new VDP connections preferably only from the high-side network, preventing any unsolicited communications from the low side.","In this embodiment, the primary steps taken by the Guard to ensure secure communications can preferably include:\n\n","In this embodiment, the CAB Translator is responsible for proxying and converting between the commercial desktop protocol and the VDP protocol. Because of the differences between the two protocols, proper translation preferably consists of more than simple semantic and format substitutions. The Translator can incorporate the required logic to behave as a commercial desktop protocol Client when speaking to other commercial desktop protocol components (i.e., the Terminal Server) and may behave as a VDP server when speaking to other VDP components (i.e., the CAB Browse Guard).","In this embodiment, the CAB Terminal Server component preferably provides a low-side multi-user platform on which all of the low-side presences will physically reside. It may consist of a commercial off-the-shelf (COTS) platform that supports remote thin-client connections.","The Terminal Server platform is preferably connected to the low-side network. This means that the Terminal Server can be configured\u2014without any CAB-specific training- to support any applications, resources and protocols natively available on that network.","In this embodiment, because native commercial terminal server protocols are not suitable for high assurance, cross-domain communications, the Virtual Desktop Protocol (VDP) may be used. VDP\u2014developed to meet the needs of CAB\u2014may be is an application-level protocol for remote, securable virtualization of a graphical user desktop on to a distant computer Client. VDP is a more secure replacement for standard commercial remote desktop protocols. VDP may be designed to be a very lightweight, yet extensible protocol, without most of the risks inherent in the more complex remote desktop protocols. Because the VDP protocol preferably provides no channels for risky activities such as file sharing and portable code execution, it can be easily secured through simple protocol enforcement and anomaly detection. The simplicity of the VDP protocol may also support real-time content inspection for such purposes as dirty word searches.","In this embodiment, the VDP may be comprised primarily of a small set of pre-defined data channels each handling specific tightly formatted message types. Messages may generally be transmitted using fixed-format messages, with some support for Type, Length, Value (TLV) encoding to ensure a common exchange format that is well formed, flexible and extensible. The concept of virtual channels may also be integrated into VDP to ensure that custom channels can be later defined and plugged into the protocol as it matures and grows based on foreseen and unforeseen new requirements and features.","Next, each of the components will be described in more detail.","CAB Client","In this embodiment, the CAB Client may be an application that is resident on a high-side user's workstation that provides access to a session on a low-side CAB Terminal Server. In a preferred embodiment, the main functionality of the CAB Client is to provide the high-side user with ability to interact with all of the low-side Terminal Server applications as seamlessly as possible. The Client preferably supports all native functionality provided by those low-side applications.","In this embodiment, the Client may accomplish this by only displaying graphical duplications of low-side applications. The Client itself does not run any direct applications on the Terminal Server (all interaction is transmitted to the Guard using VDP). Instead, the screen graphics of the low-side session may be transmitted to the high-side monitor and are interpreted and displayed by the Client.","In this embodiment, another function that the Client may provide is a final layer of defense in protecting the high-side computer. While, the Guard and Translator provide the majority of the security functionality of CAB, the Client may be a final stopgap for high-side users from low-side threats.","In this embodiment, in providing all of these functions, the Client preferably has a minimal amount of impact on the high-side platform in the areas of performance, configuration and maintenance.","An example of a high-level architecture of one embodiment of the CAB Client is shown in .  shows a more detailed example of the CAB Client architecture in this embodiment.","In this embodiment, fundamental features desired for the CAB Client were support for user-friendly interfaces, strong security and low development, and deployment overhead. CAB preferably uses Java as the Client's development platform. Java offers a rich set of development features that are beneficial in using it for Client development.","First, there is Java's platform independence. Java runs on all relevant operating systems, including Windows, MacOS, UNIX and Linux. While one embodiment of the Client may be targeted at the Windows platform, using Java means that other embodiments can support other platforms with minimal porting. The pervasive nature of Java adoption also supports the goal of minimizing deployment issues. Most workstations already have some version of a Java Virtual Machine (JVM) loaded, thus maximizing technical acceptance and minimizing technical difficulties.","Second, Java offers many advanced Graphical User Interface (GUI) components and graphical capabilities. For example, the Swing toolkit, a GUI component kit used in the development of windowing components, is a core Java API. Swing is one of the most comprehensive GUI frameworks available and it comes packaged with the Java Development Kit (JDK). Swing provides a complete set of GUI components ranging from buttons and text fields to tables, trees and styled text editors. Swing also maintains a clean separation between the GUI components and model objects that are viewed on screen. The Swing components do not rely on the native graphical elements (called widgets) of the operating system; instead, Swing components are painted using graphic primitives such as lines, rectangles and text. The painting is delegated to a look and feel plug-in that can imitate the operating system's native look and feel. Java GUIs can look the same on all operating systems or they can emulate the native look.","Security was also a component in the selection of Java. Java was designed with security in mind, with security checking built into the libraries and virtual machine. While trust is placed in the high-side user, the Java sandbox restricts code from performing many activities that allow access to sensitive areas of the computer. Java security relies on three prongs of defense to perform load- and run-time checks to restrict file-system and network access as well as access to browser internals. A more complete discussion on security will be presented in later sections.","In addition to the above, Java has many inherent functions that lends it to being used as the Client's foundation language. Such functions include automatic memory management and strong typecasting.","In this embodiment, one decision that has ramifications on the development of the Client is the choice of the Java Development Kit (JDK). JDK is the software package that enables a programmer to make use of the Java language. All known versions of JDK contain compilers, interpreters, and a host of class libraries called packages. Packages are essentially directories of subprograms (called classes) that are grouped according to their functionality.","For one embodiment of CAB development, JDK 1.5.0 (also known as JDK 5.0) was chosen. JDK 1.5 is a feature release of the Java platform and was released in November 2004. It contains many bug fixes and additional features and enhancements in many functional areas.","The decision to select Java makes support for various operating systems and hardware platforms much easier than any other programming technology. However, as with any other application, there are differences in the way programs behave among varieties of even the same operating system. Thus, in various, non-limiting embodiments, the Client may be supported and tested against the following high-side user operating systems: Windows XP (SP1) or higher, Windows 2000, MacOS, UNIX and Linux.","In this embodiment, the CAB client software may be partitioned into two libraries. The common library contains software of a general purpose that may be used in multiple applications, such as in both the client GUI and the administration GUI(s). The client library contains software specific to the CAB Client, such as code supporting the specification of client preferences.","In this embodiment, within each library, the software is further divided into packages of related components. For example, all of the custom software that manages client security may reside in the security package.","Examples of the main packages in both libraries are shown in , and are described in subsequent sections. The arrows in  show the use of one package by another. For example, the \u201cui package\u201d uses software from both the Client and the common libraries' components packages.","In this embodiment, within each main package may be sub-packages, which may be grouped according to functionality. Some reallocation of the various packages and the classes within them may occur during implementation.","In this embodiment, the Client package may contain sub-packages and classes whose functionalities are specific to the client application. An exemplary embodiment is shown in .","In this embodiment, descriptions of each of the sub-packages contained in the main Client package are shown below:",{"@attributes":{"id":"p-0084","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Client Package And Subpackages"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Package","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["ui","This package contains the main class of the Collaboration and"]},{"entry":[{},"Browse client, which can be run from the command line via the Java"]},{"entry":[{},"command and provides controlled access from a high-side user to a"]},{"entry":[{},"low-side system."]},{"entry":["ui.actions","Provides actions for the CAB client. Actions are implementations of"]},{"entry":[{},"javax.swing.Action (created by extending javax.swing.AbstractAction)"]},{"entry":[{},"that encapsulate the attributes of actionable display elements"]},{"entry":[{},"(such as UI buttons) and the processing performed as a result of"]},{"entry":[{},"clicking those elements. Actions in this package implement the"]},{"entry":[{},"following pattern: If an action in this package requires data from"]},{"entry":[{},"the initiating component, the action should define an Initiator interface"]},{"entry":[{},"that the initiating component can use to provide that data."]},{"entry":["ui.components","Provides custom UI components for the CAB client. These"]},{"entry":[{},"components group related elements, such as configuration settings,"]},{"entry":[{},"which can then be assembled into pages, which are in turn defined in"]},{"entry":[{},"package client.ui.pages."]},{"entry":["ui.pages","Provides custom display pages for the CAB client. These pages are"]},{"entry":[{},"largely assembled from components in package client.ui.components."]},{"entry":["Security","Provides classes for supporting CAB security by plugging in to the"]},{"entry":[{},"Java Authentication and Authorization Service (JAAS). JAAS"]},{"entry":[{},"provides a framework for implementing custom login mechanisms,"]},{"entry":[{},"security policies, et al."]},{"entry":["memory","Provides memory management for the CAB application. Display"]},{"entry":[{},"elements such as fonts are cached on the Client the first time they are"]},{"entry":[{},"received from the server and for efficiency, subsequent requests from"]},{"entry":[{},"the server reference the cached elements."]},{"entry":["env","Provides classes for accessing attributes of the CAB client"]},{"entry":[{},"application's environment, such as to which guard the application is"]},{"entry":[{},"making requests and what are the preferences in effect for that guard."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, descriptions of the classes and interfaces contained in main Client package are given in the table below:",{"@attributes":{"id":"p-0086","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Classes of the Client Package"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Class\/Interface","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["CABClient","The CAB client application class."]},{"entry":["ChangePasswordAction.Initiator","Interface for a class which initiates the"]},{"entry":[{},"ChangePasswordAction action, such as a UI component"]},{"entry":[{},"containing a button to which this action is an"]},{"entry":[{},"ActionListener."]},{"entry":["GetHelpAction.Initiator","Interface for a class which initiates the GetHelpAction"]},{"entry":[{},"action, such as a UI component containing a button to"]},{"entry":[{},"which this action is an ActionListener."]},{"entry":["SendCABTextAction.Initiator","Interface for a class which initiates the"]},{"entry":[{},"SendCABTextAction action, such as a UI component"]},{"entry":[{},"containing a button to which this action is an"]},{"entry":[{},"ActionListener."]},{"entry":["ChangePasswordAction","Implementation of javax.swing.Action that responds to user"]},{"entry":[{},"requests to change their password."]},{"entry":["GetAboutAction","Implementation of javax.swing.Action that responds to user"]},{"entry":[{},"request for information about the CAB client."]},{"entry":["GetHelpAction","Implementation of javax.swing.Action that responds to user"]},{"entry":[{},"requests for help."]},{"entry":["SendCABTextAction","Implementation of javax.swing.Action that sends a text"]},{"entry":[{},"string (as opposed to individual keystrokes) to the Guard."]},{"entry":["CABMenuBar","The menu bar for the main CAB Client window."]},{"entry":["ColorDepthSelector","UI component for choosing the color depth for the CAB"]},{"entry":[{},"Client."]},{"entry":["DimensionRenderer","Renders a java.awt.Dimension to the screen."]},{"entry":["RemoteDesktopTextInput","Provides a field for entering text and a button for"]},{"entry":[{},"requesting that the text be sent to the VDP server."]},{"entry":["ScreenDimensionsSelector","Display component for selecting the screen dimensions."]},{"entry":["StatusIndicator","Indicator of the status of the connection to the Guard."]},{"entry":["CabTextKeyAdapter","Manages key input on the remote desktop frame when"]},{"entry":[{},"CAB-style text input is enabled."]},{"entry":["ClientKeyAdapter","Responds to key events when the remote desktop has focus."]},{"entry":["ClientMouseAdapter","Class for handling mouse events when the"]},{"entry":[{},"RemoteDesktopPage has focus."]},{"entry":["ClientWindowAdapter","Repaints the remote desktop if the client window is"]},{"entry":[{},"reactivated, and cleans up when the window is closed."]},{"entry":["OptionsDialog","Display component for selecting display options."]},{"entry":["RemoteDesktopPage","The window that displays the remote desktop."]},{"entry":["CABPolicy","Implements the security policy for the CAB Client."]},{"entry":["CACCallbackHandler","Implementation of a"]},{"entry":[{},"javax.security.auth.callback.CallbackHandler to interact"]},{"entry":[{},"with a CAC card to get user credentials for login."]},{"entry":["GuardLoginModule","Implementation of javax.security.auth.spi.LoginModule,"]},{"entry":[{},"which delegates authentication of a user to a CAB Guard."]},{"entry":["LoginConfiguration","Concrete implementation of"]},{"entry":[{},"javax.security.auth.login.Configuration that improves"]},{"entry":[{},"security by defining the login configuration in code instead"]},{"entry":[{},"of in a JAAS configuration file."]},{"entry":["BitmapCache","A cache of bitmaps received from the Guard."]},{"entry":["CABRuntime","Provides access to dynamic attributes of the CAB"]},{"entry":[{},"environment."]},{"entry":["GuardPreferences","Extension of java.util.pref.Preferences that provides access"]},{"entry":[{},"to user preferences retrieved from the Guard."]},{"entry":["GuardPreferencesFactory","Implementation of java.util.prefs.PreferencesFactory that"]},{"entry":[{},"supports the use of the guard as the store for user"]},{"entry":[{},"preferences."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Shown in , for example, the Common package may contain sub-packages and classes whose functionality are not specific to the client application, and so may eventually be used by other applications.","In this embodiment, descriptions of each sub-package contained in the main Client package are shown below:",{"@attributes":{"id":"p-0089","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Client Common Package and Subpackages"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Package","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["guard","Contains classes that provide an abstract representation of interfaces"]},{"entry":[{},"with the Guard. The Guard class represents the Guard itself,"]},{"entry":[{},"whereas the GuardLogHandler and LoggerFactory classes plug into"]},{"entry":[{},"the java.util.logging framework to provide a mechanism to send log"]},{"entry":[{},"messages to the Guard."]},{"entry":["net.vdp","Provides classes for a Java protocol handler supporting VDP."]},{"entry":["net.vdp.messages","Classes representing the messages exchanged between the CAB"]},{"entry":[{},"Client and VDP server. All request messages contain constructors"]},{"entry":[{},"and\/or mutators that allow the message elements, such as username"]},{"entry":[{},"and password in a login request, to be set. All request messages also"]},{"entry":[{},"implement the IRequestMessage interface to provide a toBytes"]},{"entry":[{},"method that expresses the message as a byte array in the format"]},{"entry":[{},"used by the VDP protocol for that request type. All response"]},{"entry":[{},"messages contain a constructor that takes a byte array in the format"]},{"entry":[{},"sent by the VDP server, and provide accessors for accessing the"]},{"entry":[{},"message elements."]},{"entry":["ui","Provides user interface classes of general value (i.e., that are not"]},{"entry":[{},"specific to a particular application, such as the CAB Client, but may"]},{"entry":[{},"be used by multiple UI applications)."]},{"entry":["ui.components","Classes that provide abstractions on top of the Java AWT\/Swing"]},{"entry":[{},"classes."]},{"entry":["ui.swing","Provides classes that wrap Swing components to standardize display"]},{"entry":[{},"attributes such as text fonts."]},{"entry":["ui.util","Provides utility classes for constructing user interfaces."]},{"entry":["util","Provides general utility classes."]},{"entry":["resource","Provides classes for accessing resources, including support for"]},{"entry":[{},"localized\/internationalized resources such as text strings in"]},{"entry":[{},"java.util.ResourceBundles. In order to accommodate the possibility"]},{"entry":[{},"that the storage location (such as flat file, database, or remote"]},{"entry":[{},"server) for resources may change (if not now, possibly in the"]},{"entry":[{},"future), we use a factory ResourceAccessorFactory to create a"]},{"entry":[{},"concrete class (implementing the ResourceAccessor interface) for"]},{"entry":[{},"the storage mechanism in use. For example, resource definitions for"]},{"entry":[{},"the CAB Client initially exist as properties files, so the"]},{"entry":[{},"ResourceAccessorFactory will instantiate a PropertiesAccessor"]},{"entry":[{},"object, which implements ResourceAccessor, for accessing those"]},{"entry":[{},"resource definitions. However, if the future resource definitions"]},{"entry":[{},"were to reside on the Guard, a GuardResourceAccessor class, which"]},{"entry":[{},"would also implement ResourceAccessor, could be created for"]},{"entry":[{},"accessing those resources, and ResourceAccessorFactory would be"]},{"entry":[{},"configured to create and provide a GuardResourceAccessor object."]},{"entry":["exceptions","Defines custom exceptions for the Collaboration and Browse"]},{"entry":[{},"software."]},{"entry":["memory","Provides memory management for the CAB application"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, descriptions of the classes and interfaces contained in the Common package are given in the table below:",{"@attributes":{"id":"p-0091","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Classes of the Client Common Package"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Classes\/Interface","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Guard","A Collaboration and Browse guard."]},{"entry":["GuardLogHandler","Sends log entries to the Guard."]},{"entry":["LoggerFactory","Singleton factory that provides java.util.Logger instances to"]},{"entry":[{},"support logging and auditing for the Collaboration and"]},{"entry":[{},"Browse software."]},{"entry":["ConnectionStatistics","Statistics about a VDP connection."]},{"entry":["Handler","Extension of java.net.URLStreamHandler that provides"]},{"entry":[{},"connections to Virtual Desktop Protocol servers."]},{"entry":["HandlerFactory","Implementation of java.net.URLStreamHandlerFactory that"]},{"entry":[{},"allows access to a VDP protocol handler without requiring"]},{"entry":[{},"that the java.protocol.handler.pkgs system property be"]},{"entry":[{},"modified."]},{"entry":["VDPConfiguration","The configuration supported by the VDP server."]},{"entry":["VDPConnection","Extension of java.net.URLConnection for a connection to the"]},{"entry":[{},"VDP server."]},{"entry":["VDPPreferences","VDP settings for the user"]},{"entry":["IRequestMessage","Interface for any message to be sent to a VDP server."]},{"entry":["LoginRequest","A request to log in to a guard."]},{"entry":["LoginResponse","The response to a VDP login."]},{"entry":["LogMessage","A log message to send to the guard."]},{"entry":["SetOptionsRequest","Sends a request to set user-selectable VDP options."]},{"entry":["VDPPreferences","The VDP settings for the user."]},{"entry":["KeyLayout","Key layouts for various languages."]},{"entry":["CompactSpringGrid","A JPanel that is laid out as a spring grid of 2 columns by n"]},{"entry":[{},"rows, with column one being a label for a component and"]},{"entry":[{},"column 2 being the component."]},{"entry":["ListSelector","UI component for displaying a list of selections in a"]},{"entry":[{},"scrollable JList."]},{"entry":["NamedRenderer","Displays to a cell an object that implements Named."]},{"entry":["ProgressScreen","UI containing a busy indicator (with message) and a Cancel"]},{"entry":[{},"button to display, and an action to perform during the display"]},{"entry":[{},"(and the completion of which results in the end of the"]},{"entry":[{},"display)."]},{"entry":["StandardDialog","This class implements a standard data entry dialog with \u201cOk\u201d"]},{"entry":[{},"and \u201cCancel\u201d buttons."]},{"entry":["CABButton","JButton wrapper that standardizes various attributes such as"]},{"entry":[{},"label font."]},{"entry":["CABComboBox","JComboBox wrapper that standardizes display attributes such"]},{"entry":[{},"as text font."]},{"entry":["CABLabel","JLabel wrapper that standardizes display attributes such as"]},{"entry":[{},"text font."]},{"entry":["CABList","Wrapper for a javax.swing.JList which standardizes display"]},{"entry":[{},"attributes such as text font."]},{"entry":["CABOptionPane","JOptionPane wrapper that standardizes display attributes"]},{"entry":[{},"such as text font."]},{"entry":["CABPasswordField","Wrapper for JPasswordField to standardize attributes such as"]},{"entry":[{},"fonts."]},{"entry":["CABProgressBar","Wrapper for JProgressBar to standardize attributes for"]},{"entry":[{},"display."]},{"entry":["CABTextField","JTextField wrapper that standardizes display attributes such"]},{"entry":[{},"as text font."]},{"entry":["BorderUtilities","Utility methods for working with Swing borders."]},{"entry":["FrameUtilities","Utility methods for working with frames."]},{"entry":["GeneralUtilities","Miscellaneous UI utility methods;"]},{"entry":["ImageUtilities","Utility methods for working with images."]},{"entry":["SpringUtilities","A 1.4 file that provides utility methods for creating form- or"]},{"entry":[{},"grid-style layouts with SpringLayout."]},{"entry":["ValidationUtilities","Utility methods for validating user input."]},{"entry":["Named","Interface for any UI component that has a name that can be"]},{"entry":[{},"rendered to a display."]},{"entry":["Debug","Utility methods supporting debugging."]},{"entry":["Debug.StackFrameText","Provides access to the components of the string describing"]},{"entry":[{},"the stack frame."]},{"entry":["FileUtilities","Utility methods for manipulating files."]},{"entry":["ResourceAccessor","Interface for classes that provide access to resources such as"]},{"entry":[{},"property files."]},{"entry":["AbstractResourceAccessor","Abstract class providing access to resources such as property"]},{"entry":[{},"files."]},{"entry":["PropertiesAccessor","Configuration settings defined in properties files."]},{"entry":["ResourceAccessorFactory","Provider of an AbstractResourceAccessor appropriate to the"]},{"entry":[{},"storage mechanism in use for resources."]},{"entry":["InvalidValueException","Exception indicating that an invalid value was used."]},{"entry":["NotFoundException","Exception indicating that something was not found."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The following sections describe relationships among the classes. Complete descriptions of all class interrelationships are not presented, but would be readily apparent to one of skill in the art.",{"@attributes":{"id":"p-0093","num":"0108"},"figref":"FIGS. 8 and 9"},"In this embodiment, the CABClient class may contain the main method that is used to run the application. It orchestrates the display of the initial screens that allow the user to select the Guard to connect to and the display options to use (a screen to enter username and password is displayed as a result of using the JAAS framework as discussed in a subsequent section. Once the user is authenticated, the RemoteDesktopPage is instantiated and assumes responsibility for all interaction with the user.","In one embodiment, the RemoteDesktopPage () presents a screen containing the following elements:\n\n","Security Architecture","Java's security model is one of the language's architectural features that make it an appropriate technology for the CAB Client, as disclosed in one embodiment. Java provides a customizable \u201csandbox\u201d in which each Java program runs. A Java program must operate only inside its sandbox. An application can do many things within the boundaries of its sandbox, but it cannot take any action outside those boundaries. The sandbox can prohibit many activities. Examples of prohibited actions include:\n\n","To make sure the sandbox has no leaks, Java's security model involves every aspect of its architecture. The fundamental components responsible for Java's security are:\n\n","Security Policy","In this embodiment, a security policy defines restrictions such as what system resources an application can access. The Java API may enforce the custom security policy by asking the security manager for permission to take any action before it does something that potentially is unsafe. For each potentially unsafe action, there is a method in the security manager that defines whether that action is allowed by the sandbox. The implementation of these methods is what defines the custom security policy of the application.","In this embodiment, the main objective of the CAB Client security policy may be to prevent the following events:\n\n","In this embodiment, the java.security.Policy class may support a security policy that can be specified via a configuration file. Placing this policy in a file raises the possibility that if the file system is compromised then the policy can be compromised. For one embodiment of CAB, this may be avoided by implementing a security policy in a custom extension of java.security.Policy. This may also provide extensibility in that a custom security policy class may also loaded the policy from a trusted source, such as from the Guard.","Authentication","In this embodiment, in addition to utilizing the features inherent of the Java security architecture, CAB may also leverage other built-in mechanisms that Java provides for authenticating users.","JAAS is a pluggable framework that allows, among other things, the specification of a customized authentication mechanism. JAAS authentication may be performed in a pluggable fashion. This permits Java applications to remain independent from underlying authentication technologies. New or updated authentication mechanisms can be plugged in without requiring modifications to the Client application itself. JAAS authorization extends the existing Java security architecture that uses a security policy to specify what access rights are granted to executing code.","In this embodiment, since authentication of the CAB high-side user occurs at the Guard, we can effectively leverage JAAS in the Client implementation.","JAAS may also allow for flexible support of potential high-side user's Common Access Cards (CAC).","In this embodiment, there are three elements in the use of JAAS:\n\n",{"@attributes":{"id":"p-0109","num":"0153"},"figref":"FIG. 10"},"GUI Design","In this embodiment, a goal of the GUI design is to make the CAB Client application as familiar to the user as possible, employing the techniques of other windows-based applications. This familiarity aids the user in successful use of the application and decreases learning time.","An exemplary embodiment for the CAB Client screen design, after a user has successfully logged in, is shown in . The larger inner frame of the Client is the remote desktop running on the low-side Terminal Server. The intention is to minimize any other frames around this inner frame to maximize the screen size of the remote desktop. The parameters of the Remote Desktop frame (such as screen resolution, color depth) may be user-selectable during the login process.","In one embodiment, the Client's lower frame is where an optional text entry box would be displayed if this option is enabled by the Guard during Client startup. The intent of the text box is act as a typing area for all user interactions. Anything typed, or cut and pasted, appears in the text box and allows the user to visually review the content before it is sent to the Guard for inspection. This is a measure to prevent inadvertent disclosure. The user sends the text by using the send button next to the text box.","Also on the lower frame may be a connection health monitor\/indicator. In one embodiment, while there is an active connection to the Guard, the indicator light is green. If connectivity to the guard is disconnected, the indicator is red. For more detailed information, a user can click on the indicator to pop open another window that contains more statistics.","The upper frame of the Client may show the classification banner of that Client session. The text and the banner color are configurable items received from the Guard during the start-up process.","In this embodiment, located on top of the classification banner may be the main Client menus. The main menu can house most functions that can be performed by the user. The first Client menu is the Session menu, shown, for example, in .","In one embodiment, the three options for this menu are Disconnect, Reconnect and Logout. If the user selects Disconnect, only the Client is closed, but the session remains open. If Reconnect is selected, a disconnected session can be resumed. This supports the requirement for a user to use the same session at a different workstation. If the user selects Logout, the user is logged out from both the high and low side and the session; the session is completed and torn down.","In this embodiment, the second Client menu addresses the functionality of changing passwords and is shown, for example, in . The user can change both high side and low-side passwords. When the user wants to change the guard password, the user selects the first menu. This changes the password on the Guard. Because the Guard supports password aging, this same mechanism is used when a user is requested to update a password. In either case, the Guard will determine if the password is accepted or denied and send a notification back to the Client. This menu option is only valid when Guard passwords are used, not when a directory service or PKI is being used on the high side. For those cases, to change their password, the user would change it through the directory service and the menu will either be grayed out or not shown.","In this embodiment, the second function of the password menu may be used if the user wants to notify the Guard of a change in the Terminal Server password. Since users may update their password directly on the Terminal Server (if policy allows), it is the responsibility of the high-side user to inform the Guard that the Terminal Server password has changed. The function of the \u201cchange low-side password\u201d button is to push the new Terminal Server password to the Guard by having the user enter the Terminal Server password again. This enables a single high to low sign-on capability. If the user does not push the update to the Guard, the user will still be able to log into the Terminal Server (through the regular Windows login screen on the Terminal Server). However, it will not be automatic after logging on to the high side.","In this embodiment, an example of a third menu, Configuration, is shown in . Configuration displays the current configuration settings for display, sound and video. Many of these options are set as Guard configuration items and may not be user-definable.","In one embodiment, the last menu present is Help, shown in . The CAB Client Help can shows various help topics associated with the CAB Client. The About CAB Client may show the software version of the Client.","In one embodiment, another feature is the mechanism in which the users apply Windows key combinations to the Terminal Server session. For instance, if a user wishes to display the task manager in the remote session, pressing ALT-CTRL-DEL in the Client application, or anywhere else for that matter, only brings up the Task Manager on the local host.","Configuration and Deployment","In one embodiment, each Client application may be installed in the Java Archive (JAR) file format. This enables the bundling of multiple files into a single archive file. The JAR file can contain all of the class files and auxiliary resources associated with the Client application. The JAR file format provides many benefits:\n\n","Client Distribution","In this embodiment, for high-side administrators, there may be two scenarios for distributing the Client: manually or automatically. In the manual case, the high-side administrator would have to install the Client on each high-side workstation. This leads to long installation and is prone to the wrong version being used.","In this embodiment, in the automatic situation the admin, can push out the Client with an application management system such as Microsoft SMS.","In this embodiment, the Client application can also be written as an applet. Changing the Client to an applet allows the Client to be included in an HTML page (located on the Guard). When a high-side user uses a Java technology-enabled browser to view a page that contains the Client applet, the applet's code is transferred to the high-side user's system and is executed by the browser's JVM. This eliminates the need for distribution and assures that high-side users get the most current copy every time the program is used. In order for the Client applet to work, browser support is needed from the Guard.","In this embodiment, the installation of the Client on a high-side workstation may be accomplished using an installer. The installer may include the proper version of the JRE.","Configuration","In this embodiment, the CAB Client software may access site-specific configuration data needed by the Client, such as text for a login banner and the network addresses of the CAB Guards from files with specified format and with a known filename that resides in a known location for each user.","In this embodiment, this file may be configurable by an administrator and will be part of the configuration process.","Guard Component","In one embodiment, the primary purpose of the CAB Browse Guard is to enforce the security policy of the CAB system, and to securely pass valid VDP data between domains. The Guard is located at the boundary point between the high-side domain and the low-side domain. When a user on the high side wants to browse to resources on a low-side domain, the Guard creates a connection between the high-side user and the CAB Translator on the low side. The result is a connection to the low-side Terminal Server where the user can run applications (e.g., Web browser) on the low side and view the output in the high-side domain.  shows a functional view of the Guard Component.","In this embodiment, because the Guard preferably only passes well-formed VDP messages, and preferably only after strictly enforcing the format and content of each message, the data reaching the high-side Client should be free of any high-threat content. The only content preferably passing upward through the Guard is a graphical representation of the low-side desktop. Mobile code and malicious content are preferably not sent to the high side.","In this embodiment, the only data preferably transferred from the high side to the low side of the Guard preferably consists of well-formed keyboard events and mouse events. The Guard performs \u201cdirty word\u201d searches upon all entered text. In addition, the Guard can be configured to allow certain words or phrases based upon a \u201cclean word\u201d list. This content-checking capability greatly reduces the inadvertent leaking of sensitive data into the low-side domain.","Guard Component Architecture","In this embodiment, an example of the CAB Guard architecture is illustrated in . The Guard may include many interconnected major subcomponents and subsystems such as:\n\n","Each of these subsystems and subcomponents will be addressed below following the same organizational structure used above.","Operating System and Platform-Related Considerations","In this embodiment, as in most software systems, the Operating System is responsible for interfacing with system hardware and resources, and controls access to objects and resources running within the system. In high-assurance and security-centric devices and environments, such as the CAB Guard and Translator, the Operating System may become a component in securing the flow of information while maintaining the separation of sensitive data. The CAB system may make use of the SELinux Operating System, with its Mandatory Access Controls, to enforce process and data separation and least privilege concepts.","In this embodiment, the CAB system's SELinux platform may be based on a custom installation of Red Hat Enterprise Linux 4 Advanced Server (RHEL 4 AS) with SELinux in order to secure each component of the system. The inclusion of SELinux into RHEL 4 AS allows the operating system to have fine-grained control over every component in the system allowing the operating system to grant least privilege to every component in the system. The Operating System used by CAB may contain only a subset of the standard packages, as required specifically for CAB. This minimalist install eliminates excess code and possible exploits in the system.","Performance-Related Design Considerations","In this embodiment, Guard subcomponents may be designed to be thread-safe with minimal contention. Because real-world performance bottlenecks are often not understood until code is tested, the design makes heavy use of loose coupling, or reducing the degree to which subcomponents depend on one another. Loose coupling facilitates performance tuning by enabling new, better implementations of components and Interprocess Communications (IPCs) to be introduced. Loose coupling is a common best practice during system and component design.","Safety, Security, and Privacy Design Considerations","In this embodiment, the Guard component may be responsible for enforcing the extensive set of cross-domain security requirements applied to the CAB system. All subcomponents of the Guard may be designed with these requirements in mind. It is not possible to present a concise discussion of security considerations; this entire component has been designed specifically to meet a broad set of security requirements. Instead, security considerations are discussed throughout this document. In the simplest form, the highest-level security goals for the Guard are:\n\n","In this embodiment, these overall security goals may be met by a combination of the Guard operating system and the Guard applications, each of which has a set of security requirements and a security policy. Some aspects of security are enforced by both the operating system and the applications, while other aspects are enforced only by one.","In this embodiment, the guard-application security goals, which may be primarily enforced through the correct functioning and configuration of the guard applications, are preferably that:\n\n","In this embodiment, the guard applications' security goals can be enforced by the guard applications; while the operating system security policy indirectly supports the goals by ensuring that data flows through the system only in the permitted manner.","Subcomponents","The following sections describe the various subcomponents of the CAB Guard. As will be shown later, many of these same subcomponents are shared with the CAB Translator.  presents an example of an organized view of one embodiment of the CAB Guard subcomponents, identifying which subcomponents are shared with the Translator.","As stated above, the operating system may play a role in security data flows in any cross-domain solution. Additionally, the cross-domain data flow operations are preferably built upon a foundation of supporting services. This section addresses many of those services and the Guard subcomponents that provide them.\n\n","System Initialization Subcomponent","In this embodiment, the System Initialization subcomponent (also referred to as the CABInit process) may work with the system monitoring subcomponents (heartbeat monitor, performance monitor, and shutdown monitor) to establish, maintain and monitor the state of the Guard and Translator system components. The System Initialization subcomponent may consist of system integrity checks, file integrity checks and the startup sequence.","In this embodiment, this subcomponent may be primarily responsible for verifying that the system is in a trusted state at startup. During the boot sequence, the System Initialization subcomponent may perform a series tests, including:\n\n","In this embodiment, once the tests have verified that the Guard or Translator is in a trusted state, the CABInit process may start all Guard-specific processes. In one embodiment, once all processes required by the system are launched, the System Initialization subcomponent is no longer required; the CABInit process exits, leaving the monitoring subcomponents to monitor system health.","Design Decisions and Considerations","In one embodiment, the Initialization subcomponent is charged with verifying that the system is in a trusted state before activating the CAB components. If the system detects an anomaly such as a file that fails an integrity check, the system preferably immediately aborts initialization. Initialization halts all processing and then either puts the system into a maintenance mode or completely shuts the system off by powering it down. Because an anomaly of this sort should never happen while the system is booting, there is no attempt to automatically repair or recover the process or file. Such recoveries preferably are done manually by an administrator.","Performance-Related Design Considerations","In this embodiment, preferably, the operating system and environment subcomponents are designed to be as efficient as possible. However, security is a greater concern and many of the elements only run during startup and shutdown, making performance less critical. The file integrity check, for example, verifies that critical system files have not been tampered with by computing a cryptographic checksum\u2014a somewhat resource-expensive operation. Because the file integrity check only runs at startup, performance is not a critical concern.","Security and Privacy Design Considerations","In this embodiment, establishing and verifying a secure, known system state is a goal of the System Initialization subcomponent. Because the initialization process may include the invocation and coordination of most of the CAB subcomponents, it is very powerful. The principle of minimality dictates that the most powerful components should preferably be the smallest. Therefore, initialization has been decomposed into several pieces to mitigate the risk of complexity. In one embodiment, the decomposition consists of creating multiple small initialization elements and assigning each one the absolute minimum of privileges needed and by limiting communication with other components using the underlying SELinux security policy. For example, the file integrity checks preferably need to read files spanning multiple security domains, and therefore execute in a separate domain from the CABInit process from which they are invoked. In one embodiment, the domain in which the CABInit process executes does not require all of the privileges required by the file integrity checks; instead the integrity checks perform domain transfers upon execution, and complete their execution with the appropriate privileges.","Subcomponent Details","In one embodiment, the CABInit process subcomponent is the first CAB subcomponent to start during system boot. Its tasks include verifying integrity by checking the signatures of all CAB-related files in the system, verifying that\/dev contains only the device files needed for CAB, and verifying that only necessary processes are running in the system. If any of the verification tasks return a failure error code or detect an anomaly, then CABInit preferably notifies Audit (if available, otherwise, it logs to a file) and shuts the system down. Once the integrity checks have verified that the system is in a trusted state, it is safe to start up the remainder of the CAB processes. Each CAB process may be executed by CABInit, thereby causing a SELinux domain transition allowing each process to transition into its domain. In one embodiment, when all CAB processes have been started successfully, the CABInit process uses the common Wire Protocol to send the shutdown monitor all of the process IDs of the processes it has initialized. Once CABInit has delivered the process IDs, it has completed all of its responsibilities and exits leaving the heartbeat monitor, performance monitor and shutdown monitor to monitor system health.","In one embodiment, the file integrity verification mechanism used by CAB is supplied by the open-source file integrity tool Samhain. Additional integrity checks performed by CABInit may be developed to meet the very specific needs of CAB.","In one embodiment, CABInit initializes the Guard processes in the following order:","1. Samhain and other Integrity Checks","2. Heartbeat Monitor","3. Audit Subsystem","4. Shutdown Monitor","5. Performance Monitor","6. High-Side Listener","7. Low-Side Listener","8. High-Side VDP Router","9. Low-Side VDP Router","10. High-Side VDP Authentication","11. Low-Side VDP Authentication","12. High\/Low User Mapper","13. VDP Preferences","14. Dirty Word Search Filter","15. Keyboard Filter","16. Mouse Filter","17. Image Filter.","In this embodiment, as an implementation point, because the CABInit child processes preferably remain functioning after their parent process exits, each CAB process preferably becomes a process group leader. This may be achieved by calling the setsid( ) function after CABInit has forked the new process, but before that process calls execv( ). The setsid( ) function makes the calling process into a process group leader and ends the parent-child relationship with the CABInit process, allowing it to become autonomous.","Operating System","In this embodiment, the operating system may interface with system hardware and control objects and resources running in the system. For example, in a self-protected environment, such as the CAB Guard, the operating system may be a component in securing the flow of information and maintaining the separation of sensitive data. In one embodiment, the CAB Guard and Translator are based on a custom installation of Red Hat Enterprise Linux 4 Advanced Server (RHEL 4 AS), with SELinux enforcement enabled. The inclusion of SELinux into RHEL 4 AS enables the operating system to have fine-grained control over every subcomponent within the system and permits the operating system to enforce least privilege. The operating system used by CAB may contain only the subset of standard packages that are required for CAB-specific functions, thereby eliminating excess code and greatly reducing the potential for system exploits.","In this embodiment, the Linux iptables firewall may be a CAB operating system subcomponent. It secures the CAB network interfaces, providing the first line of defense against unauthorized use. Linux iptables may use the Netfilter framework inside the Linux kernel to determine which packets are allowed into the system based on their source and target addresses, ports and network protocol. The iptables configuration may limit inbound and outbound connections to those needed for CAB subcomponents.","Design Decisions and Considerations","In this embodiment, security is an important aspect of the operating system subcomponent because the operating system allocates and controls resources. A failure in the operating system could violate the integrity of the CAB security model, resulting in contamination or unauthorized disclosure of data. Because the CAB system can processes highly sensitive data, when unexpected behavior occurs, the system may enter a maintenance mode so that the system can be verified. Once an administrator has corrected any problems and verified system integrity, CAB can resume production mode.","Installation Considerations","In one embodiment, the CAB system employs a custom installation of RHEL 4 AS having only the packages required for CAB. The installation process uses a modified Red Hat Kickstart script. After the system has been installed, a hardening script executes. The script addresses the specific Guard and Translator needs.","Firewall Selection","In one embodiment, Linux iptables serves as CAB's software firewall because it is a secure and configurable tool, tightly integrated into the Linux kernel. Enabling iptables requires no kernel or system modifications. Only the rules must be configured, and those rules can be readily optimized specifically for CAB.","Interface-Related Design Considerations","In one embodiment, in order to function correctly, the CAB components depend on services provided by the operating system, such as domain separation and control over data flows. In addition, CAB may use the operating system's boot and initialization procedure to start the CAB Initialization process, which in turn starts the various Translator or Guard components. When the CAB system shuts down or transitions into maintenance mode the CAB shutdown process preferably invokes the operating system's power management subsystem to enable the machine to physically turn off or reboot.","Performance-Related Design Considerations","In this embodiment, a customized version of RHEL 4 AS built specifically for an embodiment of CAB is a stripped down version containing the minimum set of packages and processes. In addition to providing security, it improves performance. The CAB operating system may also use a standard SELinux kernel, performance-tuned for the CAB system.","Safety, Security, and Privacy Design Considerations","In one embodiment, RHEL 4 AS with SELinux may be the primary mechanism for enforcing separation of system objects into protected domains, thereby providing safety, security and privacy. Objects in one domain can only access objects in another domain if those are explicitly permitted to do so. Therefore, information cannot be transferred between domains except through well-known mechanisms specified in the system's policy.","Flexibility, Availability, and Maintainability Design Considerations","In this embodiment, the CAB operating system is designed for high availability. Excluding scheduled maintenance time, a properly configured and maintained CAB system should preferably sustain uptimes in excess of 99.95%.","In this embodiment, in order for the system to be maintainable there preferably is a mechanism for installing and updating the packages on the system. For example, RHEL 4 AS uses the RPM package management system for maintaining groups of files on the system. RPM on the CAB system can preferably only be accessed by a system administrator in the CAB maintenance mode policy.","Directory Layout","In this embodiment, to facilitate system administration, CAB may use the standard Linux directory structure. Configuration files, executables, and log files are stored in intuitive locations within the\/etc,\/usr, and\/var directories.","Configuration Files","In one embodiment, CAB configurations files are in\/etc\/cab. This methodology follows the UNIX convention of placing configuration files in the\/etc directory. Inside the \/etc\/cab directory are the subdirectories \u201cactive\u201d and \u201cstaging.\u201d","Executable Files","In one embodiment, CAB executable files that do not perform administrative tasks are located in\/usr\/cab\/bin. This includes all Guard and Translator binary components.","Administrative Executables","In one embodiment, CAB administration executable files are in\/usr\/cab\/sbin (e.g., any applications that modify or commit changes to configuration files).","Libraries and Headers","In one embodiment, CAB libraries files are in\/usr\/cab\/lib, and all CAB header files are in\/usr\/cab\/include. Source and header files may only be available on development CAB systems and may not be included in any production systems.","Temporary Files","In this embodiment, CAB temporary files may be in the\/var\/cab\/tmp directory. Each CAB application may have a separate subdirectory accessible only to its domain.","Firewall Configuration","In one embodiment, the CAB firewall restricts incoming traffic and outgoing traffic to allow only VDP traffic and time-synchronization where appropriate. In one embodiment, the Guard firewall rules support Client VDP traffic, Translator VDP traffic and high-side-trusted Network Time Protocol. In another embodiment of the CAB Guard, which includes client-certificate support, it may have access to a high-side Certificate Authority (CA) certificate revocation lists (CRL). Preferably, all other traffic is implicitly blocked. Exemplary Guard rules are presented below:",{"@attributes":{"id":"p-0217","num":"0310"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Guard Firewall Rules"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Interface","Direction","Protocol","IP Addresses","Notes"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["High","Inbound TCP","VDP TLS","Individual Client IP","Prescribed by site policy;"]},{"entry":[{},{},{},"addresses or networks","single IP address more"]},{"entry":[{},{},{},{},"restrictive but harder to"]},{"entry":[{},{},{},{},"maintain"]},{"entry":["High","Inbound\/Outbound","Network Time","Single NTP server","Necessary for time"]},{"entry":[{},"UDP","Protocol (NTP)",{},"synchronization;"]},{"entry":[{},{},{},{},"recommended deployment on"]},{"entry":[{},{},{},{},"secure switched network"]},{"entry":["High","Outbound TCP","TLS","Certificate Authority","Future - for support of"]},{"entry":[{},{},{},{},"certificate revocation lists"]},{"entry":[{},{},{},{},"(CRL)"]},{"entry":["Low","Outbound TCP","VDP TLS","Only available translators","Likely direct connections"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"SELinux Security Policy","In one embodiment, the CAB system enables secure transfer of information between separate domains of differing classifications. Any failure in the security of the system could expose sensitive data to an adversary, or inadvertently allow a valid user to gain increased privileges. The SELinux operating system security policy may be an element in preventing security failures and providing a secure data flow. The security policy may limit the damages caused by the possible failure of any one of the components by following the principle of least privilege to separate and contain each process into an individual domain with only the privileges that it requires to perform its task.","In this embodiment, the operating system security policy enforces a set of security goals that protect the operating system and guard applications. These security goals may be distinct from the application security considerations discussed above. The security policy, at the highest level, provides basic protection for the system, hardens the CAB application environment, and supports the security policy of the guard applications. It may be constrained by the overall system requirements for both security and functionality. In one embodiment, exemplary operating system security goals (OS-1 through OS-6) are that:\n\n","In this embodiment, such exemplary security goals support overall CAB security requirements and the security policy of the guard applications. These security goals will be met primarily through a custom SELinux policy. The SELinux policy may consist, conceptually, of two components: the base policy and application policy. The base policy may provide policy covering the operating system and associated resources and services. The application policy may provide policy covering the CAB-specific applications and services. These two components are combined to create the overall SELinux policy for the system. The following paragraphs will describe how the operating system security goals will be met by the operating system security policy. In one embodiment, in addition to the SELinux policy, best practices for Linux security configuration will be used, including a standard Linux discretionary access control policy, iptables firewall configuration, and other common security features of Linux.","OS Security Goal 1","In this embodiment, the first exemplary operating system security goal is a security meta-goal, stating that all operating system security goals should be met by operating system security mechanisms. The SELinux policy will attempt to enforce all of the subsequent security goals without relying on the correct functioning of user-space applications. This greatly reduces the trust placed in the applications, potentially simplifying application code. Additionally, this provides a stronger enforcement of the security goals and removes the need to consider application code when evaluating the system for the operating system security policy. The application code is still security-critical and should be evaluated in terms of the application security policy and overall system security.","OS Security Goal 2","In this embodiment, the separation of the high-side and low-side networks should be maintained by the Guard except through the appropriate guard applications. This goal directly supports the overall security requirements of CAB. The SELinux policy will prevent the flow of information between the two networks except as allowed through OS-3. SELinux provides effective, fine-grained control over the overt flow of information through the system, allowing a policy to be created that controls what applications can communicate with the network interface and how information can flow between applications.","OS Security Goal 3","In this embodiment, in order to enforce the guard-application security policy, it is preferably that information flowing between the high-side and low-side networks pass through the correct guard applications in the correct order. The combination of this security goal and OS-2 allows the SELinux policy to guarantee that no information can flow between the two networks that has not passed through the guard applications, allowing the guard applications to correctly enforce the transfer security policy. The SELinux policy language is uniquely suited to enforce this type of security goal.","OS Security Goal 4","In this embodiment, in addition to supporting the security policy of the guard application, the operating system security policy may provide appropriate assurance for the overall security of the system. This may be accomplished primarily through the creation of a strict least-privilege SELinux policy for all components of the system including the guard applications. A least-privilege policy provides assurance that the security goals of the system will be met, even in the event of application errors or compromise. In particular, a least-privilege policy may limit the potential damage from a compromise, including reducing or removing the possibility of privilege escalation. A carefully crafted least-privilege policy may limit an application to only those actions required to function correctly, regardless of whether the application is correctly functioning or has been compromised.","OS Security Goal 5","In this embodiment, system administration, by definition, requires additional privileges beyond those needed for normal operation. The creation of secure administrative functions is, therefore, challenging. The operating system security policy may separate the administrative functions into a set of appropriate roles, which each have the minimum privileges required. The SELinux policy language has support for role-based access control (RBAC). Though different from other RBAC mechanisms, the SELinux RBAC policy may allow the creation of the administrative roles and strongly limit them to the minimum privilege required. Additionally, SELinux policies can include runtime configuration, allowing the creation of two policy configurations: production and maintenance. Transition between these configurations can be securely controlled. In the production configuration, used during normal operation, many or all of the administrative functions may be disabled. In contrast, the maintenance configuration may disable network access and the guard applications, preventing the flow of information through the system, but allow access to administrative functions.","OS Security Goal 6","In this embodiment, the final exemplary operating system security goal is self-protection. In order to effectively enforce the other security goals, the system preferably should protect itself from both tampering and bypass. The SELinux policy may protect important operating system resources, including the SELinux policy, the kernel image and boot loader, configuration files, kernel configuration interfaces and raw device files.","Design Decisions and Considerations","In one embodiment, because the CAB system uses SELinux and its strong mandatory access control (MAC) mechanism, the security policy is written in the SELinux policy language. There may be two major modes for the CAB security policy: a production mode and a maintenance mode. When the system is in production mode, it inspects traffic, and allows valid traffic to cross domains. When the system is in maintenance mode, there are administrative components operating with special privilege. Because some administrative components could compromise system robustness and policy and because a remote attacker would want to use these components to bypass security mechanisms, it is important that powerful components are out of reach during live system operation. During production mode, all CAB traffic-related components are preferably operational, but most administrative tools are preferably disabled.","In this embodiment, likewise, when CAB is in administrative mode, an administrator might need to modify configuration that can only be reading during production mode. Moreover, the administrator has no need for network traffic to flow across the network interfaces or for traffic-related components to execute. To accomplish this separation the CAB Guard and CAB Translator may each have two partitioned policies, each configured specifically for the tasks necessary to perform in either production or maintenance mode.","In this embodiment, the SELinux Security Policy is not a piece of software\u2014it is a configuration that defines how the SELinux operating system protects the CAB Guard and Translator components. The policy is a manifestation of the architectural design of the system; subcomponents can preferably communicate only with those subcomponents necessary for to perform their function. Subcomponents may rarely be granted read and write operations to individual resources. Subcomponents may rarely have bi-directional communication with other subcomponents\u2014and those that do may be minimal and among the most trusted.","Interface-Related Design Considerations","In this embodiment, the Security Policy may use SELinux policy Booleans to enable the Initialization component to enable or disable core communications capabilities, such as access to the network interface cards. In one embodiment, the Security Policy enforces one-way IPC channels between processes by defining unique types for each IPC. For example, the domain sending the IPC message only has write; the domain receiving the IPC message has only read.","Flexibility, Availability, and Maintainability Design Considerations","In this embodiment, the CAB Guard and Translator components may each contain two separate security policies, one for maintenance mode and one for production mode. The production policy has two states, enabled and disabled, controlled by the value of an SELinux Boolean. When the Boolean is TRUE, the network interfaces may be permitted to send and receive data. This virtual switch allows the CAB system to complete the startup of all CAB processes and to verify that the system is ready to handle sessions before traffic can flow through the system.","In this embodiment, when the SELinux operating system first boots up, it may load the production policy with the Boolean set to the default value, FALSE. The maintenance policy, on the other hand, preferably does not permit the network Boolean to be TRUE, thereby disabling the operational system startup. This allows that the system can be administered in the absence of any cross-domain traffic or traffic-passing processes. The following table shows available states in an exemplary security policy:",{"@attributes":{"id":"p-0243","num":"0342"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Security Policy - Available States"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Network Boolean = False","Network Boolean = True"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Production","Enables CAB subcomponents to","Enables traffic during normal run-"]},{"entry":["Mode","initialize in a secure state. Network","time operations. This state allows"]},{"entry":[{},"activity is disabled, preventing any","CAB subcomponents to"]},{"entry":[{},"outside dataflow before all","interoperate, and allows selected"]},{"entry":[{},"subcomponents are confirmed","subcomponents to access the"]},{"entry":[{},"operational. Most maintenance","network. Most maintenance"]},{"entry":[{},"operations are prevented.","operations are prevented."]},{"entry":["Maintenance","The Network Boolean is always false","Not applicable. Network activity"]},{"entry":["Mode","in Maintenance Mode. Most of the","cannot be enabled."]},{"entry":[{},"CAB subcomponents cannot operate.",{}]},{"entry":[{},"Only those subcomponents required",{}]},{"entry":[{},"for maintenance and forensics are",{}]},{"entry":[{},"permitted. Network activity is",{}]},{"entry":[{},"disabled."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Subcomponent Details","In one embodiment, a set of primary security domains for the Guard and the Translator have been identified. Those primary security domains within the Guard include:\n\n","In one embodiment, at some point during the SELinux boot cycle the policy is loaded by the kernel. From that point on, policy is enforced. The system then continues with the startup process, including a set of integrity checks and the startup of each CAB-specific process. If at any point an error is detected, the system may transition into maintenance mode for the administrator's inspection. After all of the CAB processes have started, the SELinux Boolean for networking is switched to TRUE, and the system is ready for sessions to be processed through the system. When the system is ready to shut down or enter maintenance mode, either as the result of an error or an administrator's initiation, the system transitions the security policy accordingly.","Heartbeat Monitor","In this embodiment, the Heartbeat Monitor, along with the Performance Monitor, may be responsible for ensuring that processes on the CAB system are functioning properly and have the resources required to function effectively.","In one embodiment, the Heartbeat Monitor is the first process started by the CAB Initialization Process because it needs to be available when each of the other CAB processes starts running. The heartbeat monitor may be capable of receiving three types of messages:\n\n","In this embodiment, once a message is received, the heartbeat monitor can update a table that records the state of processes. The table may consist of two fields, a field for the current state of the process and a field for the last time it was updated. Periodically, the heartbeat monitor can check its table to preferably make sure that every running process has an entry in the table with a recent timestamp. Once a process starts up, it preferably notifies the heartbeat monitor that the process is running and that it should start expecting to receive heartbeats periodically. While the system is running, the heartbeat monitor preferably monitors the table, and if a process has a timestamp that exceeds the defined heartbeat period, it may be assumed that the process is no longer able to function. In the case where a process chooses to exit cleanly, the process preferably sends a shutdown message that notifies the heartbeat monitor that the process is explicitly exiting and that it should no longer expect to receive heartbeats. If however, a heartbeat is received after the process has sent a shutdown message, then that may be an indication that something has gone wrong and the process was unable to shutdown. Not receiving a heartbeat in a reasonable time period and receiving a heartbeat from a process that should have shutdown may be events that will result in the system being shut down.","Design Decisions and Considerations","Performance-Related Design Considerations","In one embodiment, the heartbeat monitor process can use IPC, via the shared Wire Protocol, to receive the heartbeat from the CAB processes. The IPC used by the heartbeat monitor preferably limits blocking so that performance hits resulting from sending and receiving heartbeats will have minimal impact on overall system performance.","Subcomponent Details","In one embodiment, after the basic CAB processes are up and running and the system is ready to start accepting connections, it is the heartbeat monitor's job to notify audit that the system is ready. Audit will create a record in the audit log and based on the policy notify the shutdown monitor to change the Boolean value and allow access to the network interfaces.","In this embodiment, the heartbeat monitor can consist of two threads in addition to the CAB control threads. The first thread may block on an IPC mechanism and wait for messages to process. Once a message is received, the thread may update the state table with the information conveyed in the message. The IPC method used for the heartbeat may be wrapped within the common Wire Protocol. Monitored process are able to send messages without needing to block and wait for the heartbeat monitor to process the message. The second thread may be responsible for monitoring the state table and ensuring that all processes contain heartbeat entries that are current. If a problem is detected, this thread may be responsible for notifying the audit subsystem of an error resulting in the shutdown of the system.","In one embodiment, the heartbeat monitor starts up and enters the running state where it receives messages from processes announcing that they have started up. Once processes have started up, the system waits to receive heartbeats. If a heartbeat is not received within the specified time, the message is overdue and a message is sent to audit. Once audit is notified, the heartbeat monitor waits for a message from the Shutdown Monitor instructing the process to shutdown. The heartbeat monitor then transitions to shutdown and exits. Otherwise, when the shutdown monitor receives a shutdown message, the heartbeat monitor transitions from the receiveHeartbeat state to the shutdown state and exits.","Interfaces","In one embodiment, the heartbeat monitor may be used by the Guard and Translator system components. In each case, the heartbeat monitor can receive data from numerous processes on the system via the shared Wire Protocol. The first message sent to the heartbeat monitor may be a message containing the process id and the process type. This may be one-way communication channel, where the heartbeat monitor will only receive data.","In this embodiment, in addition to receiving heartbeat messages, the heartbeat monitor can also interface with the Audit and Shutdown subcomponents. The table below identifies each heartbeat monitor interface in one exemplary embodiment:",{"@attributes":{"id":"p-0261","num":"0370"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Heartbeat Monitor - Interfaces"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Subcomponent","Interface Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Audit","This subcomponent sends audit messages directly to the Audit"]},{"entry":[{},"subcomponent, using the common Wire Protocol. This is one-way"]},{"entry":[{},"communication."]},{"entry":["Shutdown","Upon execution, this subcomponent registers with the Shutdown Process,"]},{"entry":["Process","using the common Wire Protocol. Once registered, the heartbeat monitor"]},{"entry":[{},"listens (using the Shutdown Thread and a blocking read) for shutdown"]},{"entry":[{},"commands from the shutdown process. This is one-way communication."]},{"entry":["All Monitored","Upon execution, each monitored process uses the common Wire Protocol"]},{"entry":["Processes","to provide regular heartbeat messages to the heartbeat monitor. This is"]},{"entry":[{},"one-way communication."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Performance Monitor","In this embodiment, the purpose of the performance monitor process in one embodiment is to monitor system performance and to verify that the system remains within operating parameters. If a system component runs out of resources and is unable to run properly, the system preferably shuts down. If the performance monitor detects a problem, it may notify Audit, which can generate an audit record, and Audit may inform the shutdown monitor that it needs to shut down the system.","In this embodiment, the Performance Monitor may be executed as part of the Initialization Process, and enters its running state. The performance monitor may be divided into two threads. One thread may receive performance statistics from processes and store them in a table, while another thread may periodically process information provided by other processes along with information it collects from the system. The data may then be compared to a threshold. If the system is running above the system limits, audit may be notified of a failure and the system preferably shuts down. Under normal conditions, where no thresholds are exceeded, the Performance Monitor may continue to execute until it receives a shutdown message from the Shutdown Monitor.","Design Decisions and Considerations","Performance-Related Design Considerations","In this embodiment, the Performance Monitor process may use IPCs, by means of the shared Wire Protocol, to receive the performance messages from CAB processes. The IPCs used by the monitor preferably limits blocking so that performance hits resulting from sending and receiving messages will have minimal impact on overall system performance.","Subcomponent Details","In one embodiment, the performance monitor obtains its information from system utilities and from session data sent to it by the audit event dispatcher. The system and kernel facilities used by the top and ps command line utilities may be used to report most of the system's information. The performance monitor may query for system statistics that include CPU utilization, real and virtual memory utilization, the number of processes and their state, and load averages. The kernel network interface ioctls may be used to report on information such as the number of packets sent and received, the number of errors, and the number of dropped packets over the high and low interfaces.","In this embodiment, information about sessions may be received from the Audit Event Dispatcher. When session-specific Audit events occur (such as a user beginning a new session, etc.), the Audit Event Manager may be alerted and information about that event may be passed to the performance monitor. In one embodiment, it is the monitor's responsibility to store information about each event so that it can derive statistics such as the number of sessions currently on the system, the total number of sessions, and which users are associated with which session. The performance monitor may contain various variables and data structures to maintain these statistics. There may be a variable that represents the current number of sessions. This number may be incremented each time a new session event is received and decremented each time a session end event is received. Another variable may contain the total number of sessions since startup. This variable may be incremented each time a new session event is received.","In one embodiment, these statistics may periodically be written to file for later analysis. The file format may consist of a series of numbers in csv format, for example, with one line representing one period of time. The numbers may represent statistics from CPU utilization to the number of sessions. Information about the current mapping of users to sessions is intended for administrative purposes and may not need to be exported to the file.","In one embodiment, the Performance Monitor may contain three threads in addition the CAB control threads like the heartbeat monitor. One thread may receive data from the Audit Event Dispatcher and update the statistic variables, while the second thread may periodically write the data in the variables to the data file. The third thread may wait for requests for information from the administration tools that require information about users, and which sessions are associated with those users.","Interfaces","In this embodiment, the Performance Monitor may be used by the Guard and Translator system components. In both cases, the Performance Monitor may receive data from many of the other processes within the system component. The processes may use the shared Wire Protocol to connect to the Performance Monitor and begin sending messages containing performance data. Each message may have a type associated with it identifying what type of performance data the message contains. In the case of sessions, the message may contain a session id and a session event and session statistics. The session event may specify if a new session has started up or shut down. In some cases, the session statistics may remain blank, such as in the case when a session starts up. In other cases, such as when a session shuts down, the session statistics may contain information about the session such as bytes of information passed, or length of the session. This is preferably a one-way communication channel through which the Performance Monitor will receive data.","In this embodiment, in addition to receiving performance messages, the Performance Monitor may also interface with the Audit and Shutdown subcomponents. The table below identifies each Performance Monitor interface in one exemplary embodiment:",{"@attributes":{"id":"p-0276","num":"0385"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Performance Monitor - Interfaces"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Subcomponent","Interface Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Audit","The Audit subcomponent relays performance data to the performance"]},{"entry":["(receiving","monitor, using the common Wire Protocol. This is one-way"]},{"entry":["performance","communication, over an IPC independent from that used to send Audit"]},{"entry":["data)","data. Through this interface, monitored processes communicate indirectly"]},{"entry":[{},"with Performance Monitor, with Audit as the intercessor."]},{"entry":["Audit (sending","This subcomponent sends audit messages directly to the Audit"]},{"entry":["Audit data)","subcomponent, using the common Wire Protocol. This is one-way"]},{"entry":[{},"communication."]},{"entry":["Heartbeat","Upon execution, this subcomponent utilizes the common Wire Protocol to"]},{"entry":["Monitor","provide regular heartbeat messages to the heartbeat monitor. This is one-"]},{"entry":[{},"way communication."]},{"entry":["Shutdown","Upon execution, this subcomponent registers with the Shutdown Process,"]},{"entry":["Process","using the common Wire Protocol. Once registered, the heartbeat monitor"]},{"entry":[{},"listens for shutdown commands from the shutdown process. This is one-"]},{"entry":[{},"way communication."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Shutdown Monitor","In one embodiment, the Shutdown Monitor is responsible for making changes to the state of the system. It may constantly wait for a state change event, arriving through the common Wire Protocol, and then responds to it.","In this embodiment, the state change message may contain a number signifying to what state the system should transition.","In this embodiment, the Shutdown Monitor may initiate transitions to one of four system states:\n\n","In one embodiment, the Production policy state grants privileges to the CAB components allowing them to run while the policy restricts the abilities of maintenance and configuration utilities. Certain configuration tasks cannot and should not be run while the system is processing sessions and this policy ensures this. The Production policy also may have two states controlled by a SELinux Boolean, which determine when to activate networking.","In this embodiment, the Network Boolean may be an SELinux-related policy switch that either permits (TRUE state) or denies (FALSE state) network connectivity for the system. The default value for the Network Boolean is FALSE, which allows for the CAB processes to start up safely before allowing connections. In one embodiment, only after the system has verified that it is ready to receive connections does the Boolean value get changed and network connectivity is permitted.","In one embodiment, the Maintenance policy state may be designed to allow privileges that are required for performing maintenance on the system. The system may transition into Maintenance mode when initiated by an authorized administrator, or when directed by policy in response to specific error conditions. The Shutdown Monitor may receive messages instructing it to transition into maintenance mode from the Audit subsystem or the administrator's shutdown utility.","In one embodiment, the Power Off policy state shuts the system down completely without transitioning into maintenance mode. When a severe error occurs, the Audit Subsystem preferably sends a message to the Shutdown Monitor instructing it to power the system off. The administrative shutdown command can also send a power-off message to the Shutdown Monitor when an administrator would like to completely shut down the system.","In one embodiment, if the system is transitioning into maintenance mode or powering off, the Shutdown Monitor preferably sends messages indicating to each process that they are to shut down and the monitor will send them though each processes' IPC connection to the Shutdown Monitor.","In one embodiment, the initialization phase starts out by initializing variables and verifying that the system has adequate resources to start up the process.","In this embodiment, after initialization, two threads may be created. The first thread receives a list of process IDs from CABInit that the monitor needs to notify in the event of a shutdown. Certain processes associated with sessions may start up and shut down while the system is running. In order for these processes to work with the Shutdown Monitor, a process ID preferably will have to be added and removed from the Shutdown Monitor while the system is running. If another process in the system creates processes, it is the responsibility of that process to make sure that Shutdown is told what processes it needs to shut down. Likewise, when a process shuts down, Audit notifies the shutdown monitor and based on the message, the shutdown monitor either removes the ID of that process, or shuts down the system.","In one embodiment, the processes that require shutdown notification may be placed into a notification table (or \u201cprocess vector\u201d). The order in which the processes are shut down is not critical; however, the audit subsystem preferably needs to be shut down last so that it can continue to receive audit events as long as possible. Note that the security policy's Network Boolean is set to FALSE before shutdown commences, preferably ensuring that no data enters or exits the system during shutdown.","In this embodiment, the second thread that may be created after initialization is a thread that waits for state change messages. If a \u201cshutdown\u201d or \u201cchange to maintenance mode\u201d message is received, the monitor preferably sets the Network Boolean, notifies the Audit Process that the Boolean has been changed, and then proceeds to notify all processes in the notification table to shut down.","In this embodiment, if the state change message simply requests a change of the Network Boolean, the change may be made, Audit is notified and it continues waiting for messages.","In one embodiment, once the processes have been notified, the system shuts down the system by transitioning into maintenance mode or running\/sbin\/init and powering the system off.","Design Decisions and Considerations","Implementation Decisions","In this embodiment, for processes to be able to interact with the Shutdown Monitor, each process will preferably have been linked to a library that contains special functions for setting up the mechanisms that interface with the initialization subsystem. The library may contain functions that a program will call while it is starting up. The functions will create and control threads and setup IPC communication between the process and the Shutdown Monitor. The shutdown control thread establishes an IPC channel with the Shutdown Monitor, and blocks on read waiting for a message from the Shutdown Manager informing the process that it needs to shut down. When such a message is received, the process may call a shutdown function, which will clean up the Shutdown Monitor thread allowing the process to then return normally.","Subcomponent Details","In this embodiment, changing the Network Boolean value is straightforward. In one embodiment, the process can open the appropriate Boolean file in the\/selinux partition and set the value to 1 or 0 depending on the context. The shutdown process may run in a domain that allows write access to the Boolean file.","In this embodiment, transitioning to maintenance mode and powering off may be more complicated. In one embodiment, first it sets the network interface Boolean to FALSE so that no data can move through the session as components are shutting down. If the Boolean is not set to FALSE, it may result in partially processed data going through the system and interface. Second, the Shutdown Monitor preferably sends a message to every process in the system informing them that the system is shutting down and that they must terminate.","In this embodiment, the shutdown monitor may be aware of every process because it preferably receives a list of process IDs from any process that execs new processes. As stated in the Initialization section, the CABInit process may send all of the process IDs of the processes it has created to the shutdown monitor before exiting. If another process in the system creates processes, it can be the responsibility of that process to make sure that shutdown is told what processes it needs to shutdown.","In one embodiment, after the CAB processes have terminated, the system may either transition into maintenance mode or continue the shutdown process to turn off the system. If the system is transitioning into maintenance mode, it may first wait for all of the CAB processes to terminate. The shutdown monitor may then execute the load_policy command which will load the maintenance policy on to the system. If the system is shutting down, the shutdown monitor may execute\/sbin\/init and switch to runlevel 0 instead of calling the load_policy command.","Interfaces","In this embodiment, the Shutdown Monitor may be used by both the Guard and Translator system components. In both cases, the Monitor can accept an IPC connection from, and send data to, many of the other processes within the system component. Each process can utilize the shared Wire Protocol to connect to the Shutdown Monitor and begin listening for a shutdown message. This preferably is a one-way communication channel, where the Shutdown Monitor preferably only sends data. The processes monitored by the Shutdown Monitor may include:\n\n","In this embodiment, in addition to sending shutdown messages to monitored processes, the Shutdown Monitor may also interface with the Audit and Heartbeat Monitor subcomponents. The table below identifies Shutdown Monitor interface in one exemplary embodiment:",{"@attributes":{"id":"p-0303","num":"0431"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Shutdown Monitor - Interfaces"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Subcomponent","Interface Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Audit (receiving","Shutdown Monitor receives shutdown messages from the Audit subsystem, via"]},{"entry":["shutdown","the common Wire Protocol. More specifically, the Audit Event Manager"]},{"entry":["messages)","determines when a shutdown should be initiated, and sends the appropriate"]},{"entry":[{},"shutdown event to the Shutdown Monitor. This is one-way communication."]},{"entry":["All Monitored","Upon execution, each monitored subcomponent registers with the Shutdown"]},{"entry":["Processes","Process, using the common Wire Protocol. Once registered, Shutdown Monitor"]},{"entry":[{},"is able to send shutdown commands to the subcomponents. This is one-way"]},{"entry":[{},"communication."]},{"entry":["Audit (sending","This subcomponent sends audit messages directly to the Audit subcomponent,"]},{"entry":["audit messages)","using the common Wire Protocol. This is one-way communication."]},{"entry":["Heartbeat Monitor","Upon execution, this subcomponent uses the common Wire Protocol to provide"]},{"entry":[{},"regular heartbeat messages to the heartbeat monitor. This is one-way"]},{"entry":[{},"communication."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Wire Protocol\/IPC Mechanisms","In one embodiment, a Wire Protocol may define the format of messages passed via interprocess communication. Major RPC systems (e.g., CORBA, DEC RPC, Java RMI, and COM) define a wire protocol. The CAB system may use a wire protocol to define the binary message format for IPC calls between components, so that each component writer need not define a new message format for passing traffic or control messages. A good wire protocol implementation for CAB has the properties listed in the table below (additional desirable properties less important to CAB are language and platform neutrality).",{"@attributes":{"id":"p-0306","num":"0434"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Wire Protocol - Desired Implementation Properties"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Property","Notes"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Transport-independence","Enable transport design decisions based on other criteria,"]},{"entry":[{},"such as performance and security"]},{"entry":["Lightweight","Do not perform unnecessary operations, such as conversion"]},{"entry":[{},"to a neutral format, when calls remain resident on the same"]},{"entry":[{},"hardware"]},{"entry":["Code generation support","Minimize development effort"]},{"entry":["Synchronous\/asynchronous","Support one-way calls to disable mutual dependencies"]},{"entry":["calls","between sender and receiver"]},{"entry":["Robust","Ensure that data and semantic errors are detectable"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, the CAB CDS system also prefers tightly controlled interaction between system components, and assured one-way IPC paths. Therefore, the transport used by the wire protocol preferably is one-way and securable via SELinux security policy. Many RPC systems include a global registry application, i.e., an intermediary, and often require two-way communication. A global registry may conflict with the design goals of one-way communications and minimal coordination between subcomponents. Another aspect of the wire protocol implementation in one embodiment is that it provides automatic encoding and decoding of message data, or \u201cmarshalling.\u201d","Design Decisions and Considerations","In one embodiment, the wire protocol framework may include an Interface Definition Language (IDL) and an IDL compiler. The IDL compiler produces client proxy code and server-side stub code that the developer can customize. The client proxy code may perform marshalling and sends the one-way, asynchronous message to the server. The server-side framework receives the message, unmarshalls all parameters, and makes a call to the server-side function implementation.","Details of IDL and Marshalling (Encoding and Decoding)","In this embodiment, marshalling consists of representing data in a format independent of the address space, network and system where it originates. In one embodiment, address-space independence is preferred\u2014each process preferably has a separate, private address space to ensure one-way data flows.","In this embodiment, the marshalling process defines the way in which those higher-level data objects are encoded by the sender (client) application and decoded by the receiver (server) application. A developer may complete several to use IPC:\n\n","In this embodiment, IDL may consist of definitions for interfaces, procedure calls and structured data. The interfaces group procedure calls in to a logical, uniquely identifiable container. Each procedure call may consist of a list of parameters and a return value. Each parameter has a data flow direction (in, out, or in\/out) and generic type, such as integer, floating point, or text string, or structure data type. There might also be additional modifiers, such as \u201cone-way,\u201d to indicate one-way call semantics. Structured data groups multiple data elements into one entity (such as a \u201cC struct\u201d).","In one embodiment, although CAB uses an RPC framework defined in several standards, such as CORBA's IIOP, OSF DCE, RMI, and COM, it may not include classic RPC return-value semantics. In classic RPC, calls are synchronous and can include return values and output parameters. CAB subsystems may not use return values or output parameters because of one-way data security restraints. Instead, CAB IDL may define strictly one-way data flow using the IDL procedure keyword \u201cone-way,\u201d \u201cvoid\u201d return values, and only \u201cin\u201d parameter modifiers. To enforce run-time one-way communication, the SELinux Policy may require that IPCs are unidirectional. Taken together, data flow from a client application to the servicing application (server) may travel in one direction, and there is preferably not a response data flow.","In one embodiment, once the IDL compiler generates the proxy and stub code and the developer has implemented the server-side code, the application can be built. The actual binding between client and server preferably occurs at runtime. In one embodiment, in a directory readable by the client, the server creates an IPC file writable only to that client, as defined by the SELinux Security Policy. The wire protocol library provides a function for the client application to obtain write-access to the IPC and a function for the server application to create and obtain read-access to the same IPC. The IPC file name and path may be configured in the CAB configuration directory.","In this embodiment, at run-time, the wire protocol library may perform the copying of marshalled data to the transport on the client side, and copying and unmarshalling the data in the server's address space.","Interfaces","In one embodiment, the CAB Wire Protocol implementation interfaces directly with the selected IPC\/RPC transport. UNIX-style domain sockets may be the candidate IPC because they have a high throughput and because the SELinux policy language defines fine-grained control over them.","Preferably, almost every subcomponent and element within the CAB Guard and Translator uses the Wire Protocol.","Audit and Event Management Subcomponents","This section covers the full-time audit functions and the on-demand \u201cflight recording\u201d capabilities of CAB. In one embodiment, the Audit and Event Management subcomponents define the audit interface, security event management processing, event management policy, audit data recording and analysis, and system forensic capability.","Audit Subcomponent","In this embodiment, the Audit subcomponent supports diagnostic logging and security event auditing. In one embodiment, it primarily consists of a client interface element, various persistent repositories, and a central server element for aggregating and correlating all Guard events. (The Translator may implement the same Audit subcomponent, configured to properly handle Translator events.) The elements of Audit may be broken into multiple packages.","In this embodiment, diagnostic logging is preferred to develop CAB components. It also can provide wellness metrics not captured by security requirements, but necessary for overall system maintenance. Diagnostic logging may be tightly associated with an application's security domain, as generally, a holistic system view is not necessary.","In this embodiment, security event auditing, on the other hand, preferably provides a complete picture of system security events, as observed by all system components. Event auditing satisfies security requirements for a secured, tamperproof record of security-relevant system events. In one embodiment, there is no requirement for event correlation.","Design Decisions and Considerations","Interface-Related Design Considerations","In this embodiment, there are several considerations for the Audit interface:\n\n","In this embodiment, to simplify client usage, the core auditing interface may offer three levels of data abstraction: data element, generic event record, and specialized event record. Orthogonal concerns such as event destination may be separated from the data interface.","In this embodiment, the Audit interface may be designed to cooperate with other common system components, such as session management and common processing. Audit clients do not need to carry out synchronization of data, as the client interface may provide synchronization under the covers.","Performance-Related Design Considerations","In this embodiment, all Audit elements may be designed to be thread-safe with minimal contention. Because real-world performance bottlenecks are often not understood until code is tested, the design makes use of loose coupling. Loose coupling facilitates performance tuning by enabling new, better implementations of components and IPCs to be introduced.","Database Design Decisions","In one embodiment of the Audit subcomponent, it uses a simple text-oriented output file, with custom-delimited fields. To support future analysis and visualization, the Audit Store employs data normalization. One embodiment supports normalization and indexing by using strong typing and unique identifiers of events.","Security and Privacy Design Considerations","One embodiment of the Audit subcomponent is designed for partitioned security domains. The primary security issues include:\n\n","In this embodiment, some design principles to meet these security issues include least privilege and minimality. The audit server's audit store writer may operate in a security domain that enables it to write persistent data to disk with an \u201caudit data type.\u201d The Log and Forensic administrators are permitted to read the persistent data having \u201caudit data type.\u201d In one embodiment, a separate \u201caudit configuration\u201d type identifies configuration files modifiable solely by a Policy Administrator.","Flexibility, Availability, and Maintainability Design Considerations","In this embodiment, the Audit subcomponent may be instrumental in system maintainability. Security event and diagnostic data support developers and administrators who need to understand the system function.","In this embodiment, the Audit subcomponent may be flexible. It may support in-process and inter-process aggregated logging. The design also supports future development by enabling different persistent stores and transports to be incorporated without affecting the overall implementation.","In this embodiment, the Audit subcomponent may have implications for system availability. Audit trails are preferably tamperproof and guaranteed to occur for security-relevant events. Therefore, the Audit component may become a bottleneck that can affect availability or a target for a denial-of-service attack. Audit components may be designed to be contention-free as much as possible so that multiple clients can simultaneously record their events asynchronously.","Subcomponent Details","The following sections describe the elements of the Audit subcomponent.","Audit Data","In this embodiment, the Audit Data element may provide the essential data model for Audit events and the operations to manipulate it. In one embodiment, the data model consists of data types, core kinds of data present in Audit records, and the taxonomy of events. The operations may consist of functions for manipulating fields, accessing common fields, and working with field types. It depends on session data defined in the Common::Session package and the safe, portable common types defined in the Common::Types package. The core objects are AuditField and AuditRecord. Helper objects include AuditRecordWrapper and AuditRecordlterator.","In this embodiment, an Audit Record may be essentially a container of multiple fields, some always present, some frequently used, and some specific to the component generating the record. The table below presents examples of the varying level of commonality. The Container and Wrapper interfaces facilitate levels of commonality of fields while supporting software reuse.",{"@attributes":{"id":"p-0347","num":"0492"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Audit Event Fields - Commonality"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Commonality","Example"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Always","process ID, component ID, timestamp, status code"]},{"entry":["Frequently","session ID, inspection success value"]},{"entry":"Used"},{"entry":["Specific","Dirty Word Search matching word, Authenticator user"]},{"entry":[{},"name"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Audit Client","In one embodiment, the AuditClient package may provide the core client capabilities for any system application or component to provide diagnostic logging and event auditing. Both diagnostic logging and event auditing require the capture of different types of values and persistence. Diagnostic logging may be provided only on development systems, and may not be included on production systems. Diagnostic logging need only be local to a specific application\u2014however, a consolidated log could be useful for diagnosing cross-process issues. Security-event auditing should be consolidated to provide a system-wide view of security-related issues. In one embodiment, these crosscutting concerns are addressed by a single client interface, following the Proxy and Bridge patterns, that allows different event categorization (i.e., diagnostic vs. security) and modular destination (i.e., local file vs. audit server via IPC).","In this embodiment, the AuditClient may implement an abstract interface that defines the behavior of any Guard component that needs user session state. In one embodiment, it may consist of the following operations:\n\n","In this embodiment, the AuditClient may also rely on an IAuditDestination interface, implemented as a logging capability or security-event destination.","Record Wrappers","In this embodiment, writing code to generate logging and auditing events may be repetitive. The code also can appear as noise because it appears so frequently. Record Wrappers may address both concerns, and are preferably used by the CAB Audit subcomponent.","Audit Format","In this embodiment, audit events written to unstructured text files may have a format independent of the destination to which they are written. One embodiment of the Guard can support binary or XML format. To separate format from structure, the Audit Format element may delegate formatting to encoders. One embodiment of the Guard supports ASCII, with a custom delimiter. The delimiter may be configured as a comma, for compatibility with Comma Separated-Value (CSV) format files. The ASCIIEncoder encodes the multiple types, encoding binary data types in Base-64 (MIME) format.","Event Destinations","In this embodiment, system events are preferably logged locally in their domain to facilitate early development, to a centralized repository for one embodiment, and to multiple guards in other embodiments. In order to support multiple destinations, there may be a single destination interface to be realized through local and inter-process destinations. The Destinations component may define the interface for writing an audit destination in the IAuditDestination interface.","One embodiment of the Guard need only provide text-based persistence of Audit data. Other embodiments may feature audit reduction and analysis, and therefore, a more structured persistent store may be implemented. The TextPersistentStore supports server persistence for auditing and client-side-only persistence for logging.","In this embodiment, in order to support session administration, the Audit Repository process also may maintain the live session list, including user name, session ID, priority, logon time, and other relevant data. The format may be in XML, to enable access from administrative utilities, using the CAB Configuration File capabilities.","Audit Repository\/Audit Persistence","In this embodiment, the Audit Repository may be the CAB process that writes audit messages to the persistent audit data store. Audit messages may be received from the Event Manager.","Event Manager\/Event Dispatch","In one embodiment, the Event Manager is the CAB process that receives audit messages from Audit Clients throughout the system. Once an audit message is received, it is the responsibility of the Event Manager to perform Event Dispatch.","In this embodiment, the Event Dispatch function provides a policy-driven capability to respond to security-relevant events. When an Audit Client (any CAB process with audit capabilities) detects an auditable event, it may send the event to the Event Manager, without regard for how that event should be treated. The Event Manager may perform Event Dispatch by applying its Event Policies to the new event and determining which actions should occur. The table below identifies the types of actions that may occur in one exemplary embodiment:",{"@attributes":{"id":"p-0365","num":"0516"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Audit Event Action Objects"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Action Object","Purpose","Service"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["LogoutAction","Terminate the active session.","High-Side VDP"]},{"entry":[{},{},"Sender"]},{"entry":["GuardShutdownAction","Shutdown the Guard.","Shutdown"]},{"entry":["ConsoleAlertAction","Display an alert for","Console Alert"]},{"entry":[{},"administrator."]},{"entry":["MetricAction","Capture a performance metric.","Performance"]},{"entry":[{},{},"Monitor"]},{"entry":["AccountLockoutAction","Lock a user's account.","Authentication"]},{"entry":["AuditAction","Record an event persistently.","Audit"]},{"entry":[{},{},"Repository"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, the Audit Event Manager may constitute the server element in the audit client to audit server relationship. Audit clients can include any CAB process that uses the Audit Client libraries to send audit messages to the Event Manager.","Audit Alerts","In this embodiment, the Alert element may provide an interface for generating alerts to an administrator. One embodiment provides a console-based alerter. Another embodiment may define additional alerts, such as those to pop-up windows, alarms, etc.","Administration","In this embodiment, initial administration of the Audit subcomponent may consist of specifying parameters in appropriate configuration files.","Flight Recorder Subcomponent","In one embodiment, the Flight Recorder subcomponent records user sessions when a user performs a suspicious action, or at other times as specified by the policy. When a suspicious event occurs, the Audit Event Manager notifies the interface listener to begin sending copies of session packets to the Flight Recorder. An Administrator will then have the opportunity to watch the session live (shadowing) or replay the session later. In one embodiment of the CAB system, there may be no built-in shadow or replay mechanism. In another embodiment, these features may be present.","Design Decisions and Considerations","Decision to Develop or Reuse","In this embodiment, because VDP is a completely new protocol, there is currently no software package that knows how to record VDP sessions and play them back. As a result, the Flight Recorder is newly developed. The Flight Recorder may use the VDP library to interpret VDP packets.","Interface-Related Design Considerations","In one embodiment of the CAB system, Flight Recorder may only interact with the Interface Listener and Audit subsystems. When a security event warrants flight recording, the Listener receives a message from the Audit Event Dispatch subcomponent indicating that a session must be recorded. The Interface Listener sends all packets associated with a session to the Flight Recorder to be recorded.","In this embodiment, when a packet with a matching session ID enters the Interface Listener, a copy of the packet is sent to the Flight Recorder. The Flight Recorder writes the packet into its data store. In another embodiment, an administrative interface enables the Forensic Administrator to replay the session directly on the Guard.","Performance-Related Design Considerations","In this embodiment, the Guard may not be able to record all user sessions while maintaining acceptable performance. Therefore, in one embodiment, the Flight Recorder is intended to record a session when an event has triggered the recording of data. The main performance concern is that every packet of a graphics-intensive session is preferably recorded to disk. The Flight Recorder may use tunable memory buffers to store packets and then periodically write the buffers to the data store to prevent overwhelming the disk with write requests.","Safety, Security, and Privacy Design Considerations","In this embodiment, the Flight Recorder and Session Data Store may be isolated in individual security domains so that other processes are prevented from accessing the recorded session data. In one embodiment, the Flight Recorder process may write to the Session Data Store, and the forthcoming playback and offloading tools may read the session data. In one embodiment, additional backup and cleanup functions receive appropriate access.","Subcomponent Details","In one embodiment, once the Flight Recorder starts up, it waits for session packets from the High-Side Listener. Once a packet is received, the Flight Recorder processes it and goes back to waiting for another packet. The Flight Recorder receives both inbound and outbound messages from the High-Side Listener. If the wait for packets is interrupted or the receive fails, the Flight Recorder enters an error state and shuts down. During healthy operation, the Flight Recorder waits for a system shutdown event.","Flight Recorder Timing","In one embodiment, the Flight Recorder includes a timestamp with each recorded packet. Timing may be a part of the Flight Recorder, because without a concept of when packets were received, the session playback function would not include the natural pauses, and the entire session would pass in a matter of seconds.","The Data Store","In this embodiment, the Flight Recorder may store recorded sessions into the \/var\/cab\/flightrecorder directory. Inside of this directory, each session may be contained in an individual file. Each file's name may consist of the session id, date, and time that the recording of the session began allowing the administrator to quickly locate the correct session for replay. In order to maintain performance and prevent lost packets, the Flight Recorder may buffer all writes using a tunable memory buffer. If the buffer cannot handle the packet flow, an event may be logged so that the Guard can make a policy-driven response.","Interfaces","In this embodiment, within the Guard system component, the Flight Recorder may interface with several other subcomponents. The table below provides a description of these interfaces in one exemplary embodiment:",{"@attributes":{"id":"p-0391","num":"0542"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Flight Recorder - Internal Guard Interfaces"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Subcomponent","Interface Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["High-Side","When initialized, Flight Recorder connects to the High-Side Listener (via"]},{"entry":["Listener","the common Wire Protocol). While recording is active, the Listener sends"]},{"entry":[{},"a copy of inbound and outbound VDP traffic to Flight Recorder. This is"]},{"entry":[{},"one-way communication."]},{"entry":["Hard Disk","This subcomponent writes directly to the hard disk, creating and"]},{"entry":["(write)","appending to session-specific recorder files."]},{"entry":["Initialization","Initialization Process launches this subcomponent, using an \u2018exec\u2019 call."]},{"entry":["Process","No communications are established between this subcomponent and the"]},{"entry":[{},"Initialization Process."]},{"entry":["Heartbeat","Upon execution, this subcomponent uses the common Wire Protocol to"]},{"entry":["Monitor","provide regular heartbeat messages to the heartbeat monitor. This is one-"]},{"entry":[{},"way communication."]},{"entry":["Shutdown","Upon execution, this subcomponent registers with the Shutdown Process,"]},{"entry":["Process","using the common Wire Protocol. Once registered, the heartbeat monitor"]},{"entry":[{},"listens for shutdown commands from the shutdown process. This is one-"]},{"entry":[{},"way communication."]},{"entry":["Audit","This subcomponent sends audit messages directly to the Audit"]},{"entry":["Subsystem","subcomponent, using the common Wire Protocol. This is one-way"]},{"entry":["(sending","communication."]},{"entry":"audits)"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Authentication Subsystem","This section describes the CAB authentication subcomponents, with an emphasis on the Guard. In this embodiment, there may be two aspects of authentication: user-to-Guard and user-to-Terminal Server (through the Translator). User-to-Guard authentication can occur in two phases: TLS authentication (performed during the TLS handshake) and user authentication (performed after the TLS handshake). These two phases are handled by two separate groups of components.","In this embodiment, the Guard may provide a certificate that the Client uses to authenticate the Guard. In one embodiment, the Guard may not perform TLS Client authentication, i.e., the Guard does not require a client certificate. In another embodiment, CAB may be configurable to preferably require the user to supply a valid certificate, such as from a Comman Access Card (CAC) or certificate held in a client workstation.","In one embodiment, the Guard user authentication subsystem may consist of three subcomponents: the High-Side Authentication subcomponent, the Low-Side Authentication subcomponent, and the High\/Low Authentication Mapper. The High-Side Authentication subcomponent authenticates the Client user to the Guard via a user ID and password pair. Additional authentication mechanisms may be included in other embodiments. The High\/Low Authentication Mapper may map the high-side user ID to the low-side user ID presented to the Terminal Server (through the Translator). The Low-side Authentication subcomponent manages and passes the low-side password necessary to authenticate to the Terminal Server on behalf of the Client user.","In one embodiment, in order to perform the complete low-side authentication, the Guard maintains low-side Client user credentials and settings. The settings include screen resolution, color depth, keyboard layout, and any other settings presented during normal Terminal Server authentication. The Guard also can maintain password and connection statistics (e.g., last successful login and password expiration).","Design Decisions and Considerations","Component Design Decisions","In this embodiment, user authentication to the Guard is preferably to ensure that only authorized users can use the CAB system. Furthermore, confidentiality services are preferable to protect session traffic from eavesdropping. In order to address these issues, one embodiment of CAB uses a two-phase authentication process.","In one embodiment of CAB, TLS provides confidentiality services for session traffic and authentication of the Guard for the Client user (i.e., that the Guard \u201cis who it says it is.\u201d). In another embodiment, the Guard may support the use of TLS to authenticate the Client users, via certificates. The encryption algorithms for confidentiality and authentication services may be implemented through dedicated cryptographic accelerator cards on the Guard and Translator.","In this embodiment, in addition to TLS handshaking, one embodiment of CAB preferably has the high-side user provide a user ID and password to complete the authentication process. In other embodiments, CAB may include other user authentication techniques, such as the use of biometric data. In one embodiment that does not use PKI, user IDs and passwords are preferably used to authenticate Client users to the Guard. In other embodiments, the use of passwords may not be necessary.","Interface-Related Design Considerations","In this embodiment, the Authentication subsystem may communicate with other components via one-way, asynchronous IPC, keeping with the overall Security Policy.","In this embodiment, the Authentication subsystem may use Commercial off-the-shelf (COTS) APIs to communicate with the crypto accelerator cards. The decision on which API to use depends on what is provided with the crypto card selected for CAB. The crypto card API used may, for example, either be one supplied by the accelerator card vendor or RSA's PKCS # (also known as Cryptoki).","Performance-Related Design Considerations","Operations involving asymmetric cryptography are very computationally-intensive, and performing such computations in software may put an excessive burden on the Guard and Translator CPUs. Furthermore, symmetric cryptography may be used for connections into and out of the Guard and Translator. In this embodiment, given the volume of data being encrypted, it is preferable to have optimized hardware perform the cryptography. As is common practice in high-load network servers, CAB may be designed to take advantage of specialized cryptographic hardware.","Database Design Considerations","In this embodiment, the Authentication subsystem may maintain certificates, user IDs, passwords, user settings, and user preferences. Because of the sensitivity of the data in question, it is preferably to store the data securely and efficiently.","In this embodiment, user passwords may be encrypted to protect them from compromise. For example, strong password requirements stipulate that passwords may not be reused over certain periods of time and that a new password must be sufficiently different from previous passwords (e.g., a rule might be \u201cno more than four characters are the same from a previous password\u201d). These stronger rules require that new passwords be compared in plain text form, and therefore, it is not possible to use of one-way cryptographic hashes. Therefore, the Guard preferably uses encryption and has an encryption key. In order to have secure key management, the Guard preferably maintains a password decryption key, which is preferably loaded on to the Guard at boot time.","In this embodiment, session encryption occurring at both the high- and low-side interfaces is transient, and therefore need not be persisted in a cryptographic database.","Safety, Security, and Privacy Design Considerations","In this embodiment, because the Guard and Translator authentication components control access to the system and manage highly sensitive data, they are preferably in tightly controlled security domains. The SELinux Security Policy may provide domain separation and control over the direction of data flows between components.","In this embodiment, separate cryptographic operations may take place at the high-side and low-side interfaces, each interface transmitting data at a different level of security. For this reason, the Guard preferably has one cryptographic accelerator card for each security level. To protect the sensitivity of data, these cards are preferably certified to the FIPS140-2 standard.","One embodiment of CAB supports at a minimum 1024-bit RSA for key exchange and digital signatures, SHA-256 for hashing, and AES for confidentiality (128 bit blocks in CBC mode). Another embodiment may be \u201cSuite B\u201d compliant.","In this embodiment, because TLS supports virtual connections, it is possible for the Guard and Translator to have one TLS network connection for multiple virtual user sessions.","Flexibility, Availability, and Maintainability Design Considerations","In this embodiment, the Authentication subcomponent may generate \u201cheartbeat\u201d signals at regular intervals, as defined by the heartbeat monitor subsystem. In one embodiment, if any subcomponent of the authentication subsystem were to terminate, the heartbeat signals would cease, thereby indicating a serious problem to the heartbeat monitor. Likewise, if any authentication subcomponent detects a condition rendering it unable to continue processing, it would shut down immediately, triggering the heartbeat monitor to initiate system shutdown.","4.2.3.2 Subsystem Details","In this embodiment,  shows an example of the Authentication subsystem and its interactions within the Guard. The arrows in the figure represent the data pathways used for authentication-related messages and events.","High-Side TLS Authentication Subcomponent","In one embodiment, the High-Side TLS Authentication subcomponent comprises the code performing the TLS authentication for the high-side Client connection (via the TLS handshake). In one embodiment, this subcomponent may simply maintain access to the Guard's certificate, as no Client certificates may be supported. In another embodiment, this subcomponent may become an active process, maintaining Client certificates and authenticating Client TLS authentication requests.","High-Side Interface Listener Subcomponent","In one embodiment, the High-Side Interface Listener subcomponent implements the TLS protocol on the high-side network interface. It performs TLS handshakes, encrypts and decrypts VDP packets, and creates cryptographically strong unique session identifiers for each connection.","High-Side User Authentication Subcomponent","In one embodiment, the High-Side User Authentication subcomponent processes VDP authentication packets. It may receive packets from the high-side VDP router, verifies user IDs and passwords, and sends responses to the high-side VDP forwarder for transmission to the Client. After a user's credentials are authenticated, it transmits available session settings (e.g., available screen resolutions and color depths) to the Client and awaits an acceptable response. In order to read user settings and update data such as last logon time, it preferably has bi-directional communications with the User Preferences subcomponent, which maintains preferences and policy settings.","In one embodiment, once the negotiation of settings has been completed and the other Guard components are ready to process session traffic, the High-Side User Authentication subcomponent notifies the High\/Low User Mapper, which initiates the low-side authentication process by sending a low-side user ID number to the High\/Low User Mapper.","In this embodiment, if the client user wishes to change the low-side password stored on the Guard, this subcomponent may send a message containing the user ID number and the new low-side password to the High\/Low User Mapper.","High-Side User Preferences Subcomponent","In one embodiment, the High-Side User Preferences subcomponent supports the High-Side User Authentication subsystem by providing a persistent store of client user preferences and settings. Settings can include screen resolution, color depth, keyboard layout, language, and any other VDP-specific preferences. In addition, this subcomponent may store the classification string and banner color associated with the low-side Terminal Server, which is displayed in the client window.","In this embodiment, the High-Side User Preferences subcomponent may also manage the \u201cprofiles\u201d associated with users. A profile represents a grouping of preferences and policy settings to associate with a class of users. It can define the permissible preference values, such as screen resolution, color depth, and keyboard type; the priority of the user's session; and the policy for security-relevant events, such as how to respond to a dirty word entered by the user (e.g., \u201cenable flight recorder\u201d or \u201clock account\u201d).","In one embodiment, when a user initiates a session, there is a negotiation over preferences. If no preferences are associated with a given user, the default values are used. The preferences are sent back to the Client, which either accepts them or sends back its new preferences. If the Client's chosen preferences are consistent with the profile assigned to the user, the process of low-side authentication may begin.","High\/Low User Mapper Subcomponent","In one embodiment, the High\/Low User Mapper subcomponent maintains the non-attributable relationship between high-side and low-side user identities. It maps the high-side user IDs to low-side user IDs, using, for example, a lookup table. For each high-side user ID number, there may be a one-to-one mapping to a distinct low-side user ID number. The Mapper, therefore enables high and low Authentication subcomponents to translate from high-side to low-side user identity, while remaining unaware of the user IDs themselves.","In one embodiment, the Mapper receives authentication-related messages from the High-Side User Authentication subcomponent, and sends authentication-related messages to the Low-Side User Authentication subcomponent.","Low-Side User Authentication Subcomponent","In one embodiment, the Low-Side User Authentication subcomponent performs authentication with the Terminal Server by way of the Translator. It receives messages from the High\/Low User Mapper, and forwards VDP messages through the Low-Side VDP Forwarder subsystem.","In one embodiment, when the High\/Low User Mapper sends an authentication message, the Low-Side User Authentication subcomponent begins the process of low-side authentication by sending a VDP message containing the low-side user ID and password to the Low-Side VDP Forwarder. This VDP Forwarder sends the message to the Low-Side Interface Listener, which in turn 1) initiates a TLS connection with the Translator and 2) sends the VDP authentication message to the Terminal Server.","In this embodiment, while the Low-Side User Authentication subcomponent is similar to the High-Side User Authentication subcomponent, it differs in that its authentication with the low-side Terminal can fail without terminating all session communication (in fact, terminal service COTS protocols do not always provide sufficient notification). If the password is not valid, the client user simply sees a login dialog, which requires a second, manual authentication via standard VDP keyboard events.","Low-Side TLS Authentication Subcomponent","In one embodiment, the Low-Side TLS Authentication subcomponent provides the authentication support for the Low-Side Interface Listener. It is analogous to the high-side interface Listener. It communicates bi-directionally with the Low-Side Interface Listener, maintaining the Guard low-side certificate supplied in the TLS handshake. Every low-side session will have a separate TLS connection with the Translator.","Low-Side Interface Listener Subcomponent","In one embodiment, the Low-Side Interface Listener subcomponent implements the TLS protocol on the low-side network interface. It performs TLS handshakes, encrypts and decrypts VDP packets, and initiates new network sessions with the Translator.","Cryptographic Accelerator","In one embodiment, the CAB system uses TLS to provide confidentiality, integrity, non-repudiation, and authentication services between high-side Clients and the Guard, and between the Guard and the Translator. Under the expected network loads the Guard is responsible for communicating across a large number of encrypted links. Given that asymmetric cryptography is computationally expensive and that numerous symmetric cryptographic operations would further burden the Guard CPU(s), the CAB Guard may employ specially designed cryptographic accelerator cards to free up core Guard processing for VDP protocol inspection.","In this embodiment, the Guard may have separate Interface Listener processes on the high side and low side interfaces because each process must have its own cryptographic accelerator. Additionally, the differing security domains of the connected networks make it preferably that no single process is permitted to communicate with both interfaces.","In this embodiment, cryptographic accelerator cards perform the cryptographic portions of TLS authentication. In order to determine which accelerator best meets the needs of the Guard, the following exemplary criteria can be used for evaluation:\n\n","The following table shows exemplary cryptographic accelerators:",{"@attributes":{"id":"p-0447","num":"0603"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Authentication Subsystem - Candidate Cryptographic Accelerator Cards"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Card","Vendor","Features","Notes"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["ProtectServer","Eracom","RSA (4096-bit), DSA, DH, AES,","Tamper-resistant"]},{"entry":["Orange",{},"3DES, IDEA, CAST-128, RC2,","FIPS 140-1 level 3"]},{"entry":[{},{},"RC4, RNG, HMAC","Linux support"]},{"entry":["nForce PCI","nCipher","RSA\/DSA (1024-bit, maybe","FIPS 140-2 level 2"]},{"entry":["1600",{},"more?), DH, 3DES, CAST,","Linux support"]},{"entry":[{},{},"AES-Rijndael, ARC4","Suite B supported with"]},{"entry":[{},{},{},"firmware update"]},{"entry":["S2010 PCI-X","Corrent","RSA (1024-bit), DH, HMAC,","OpenSSL support"]},{"entry":["accelerator",{},"RNG, 3DES, AES","PCI-X slot required"]},{"entry":[{},{},{},"Linux support"]},{"entry":["Nitrox XL","Cavium","RSA\/DSA (1024-bit), DH, RNG,","OpenSSL supported"]},{"entry":["NPB","Networks","3DES, AES","w\/Cavium's TurboSSL"]},{"entry":["Accelerator",{},{},"mods"]},{"entry":["(CN1230-",{},{},"Linux support"]},{"entry":"350-NBP)"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Data Sequence Diagrams","In this embodiment, the TLS protocol and VDP authentication may both have complicated handshakes. This section presents the interactions between the Guard subsystems and the operations in the TLS protocol.","In this embodiment, the TLS protocol may allow for either the creation of new TLS sessions or the resumption of old sessions. During session creation, both sides can exchange keys, perform mutual authentication, and negotiate the cipher suite (encryption and hashing algorithms) that both sides use to protect communications. Client authentication in TLS may be optional, and one embodiment of CAB may not support Client TLS authentication to the Guard.","In one embodiment, the Client may not supply a certificate to the Guard, as no PKI infrastructure may exist for verifying the certificate. In another embodiment, however, the Client can use its certificate to authenticate to the Guard.  shows a TLS Handshake protocol sequence.","In one embodiment, Client authentication would take place after the Client sends its certificate to the Guard. The Guard would first check to see that the Client's certificate was properly signed by a valid certificate authority. Next, the Client would sign a hash of all TLS handshake messages sent up to that point, and then send that signature to the Guard. Using the certificate supplied by the Client, the Guard would verify the signature. If the signature fails verification, the Guard would not proceed with the connection, and a message is logged to the audit subsystem.","In this embodiment, TLS supports session resumption, which would permit the Client to reconnect to the Guard using a previously used session ID. If the Guard supports this capability, it is recommended that session IDs have a short life span, so as to limit the time period in which a session may be resumed.  presents the TLS Handshake session resumption sequence.","An example of the overall process of authenticating a Client user for one embodiment is presented in . There may be two parts to Client authentication: TLS and user. For one embodiment, the Guard utilizes the user's ID and password for authentication. Other embodiments may use other authentication mechanisms, such as PKI and biometric data, for example.","Interfaces","In this embodiment, the Authentication Subsystem may consists of multiple subcomponents that communicate internally and externally. Examples of subcomponents and their message flow are presented in the table below:",{"@attributes":{"id":"p-0457","num":"0613"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Authentication Process - Interfaces"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Subcomponent","Messages From","Message To"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["High-Side TLS","High-Side Interface","High-Side Interface Listener"]},{"entry":["Authentication","Listener"]},{"entry":["Low-Side TLS","Low-Side Interface","Low-Side Interface Listener"]},{"entry":["Authentication","Listener"]},{"entry":["High-Side User","User Preferences,","User Preferences (reply), High-"]},{"entry":["Authentication","High-Side","Side VDP Forwarder, High\/Low"]},{"entry":[{},"VDP Router","User Mapper"]},{"entry":["Low-Side User","High\/Low User","Low-Side VDP Forwarder"]},{"entry":["Authentication","Mapper"]},{"entry":["High\/Low User","High-Side User","Low-Side User Authentication"]},{"entry":["Mapper","Authentication"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, the multi-step authentication process may consist of multiple message flows internal to the Guard. Once a high-side user has authenticated to the Guard, messages may be sent to each of the Guard components to notify them that the user has successfully authenticated.","In one embodiment, for complete authentication, it is preferably that a user's desired preferences are compatible with the user's assigned profile. Once the high-side user has valid selected settings (screen resolution, color depth, etc.), the High-Side User Authentication subcomponent stores these preferences in the User Preferences subcomponent for subsequent logons. Next, the High-Side User Authentication subsystem sends a \u201cnew session established\u201d message with the user preferences to the High-Side VDP Forwarder, which, in turn forwards the message on to the High-Side Interface Listener.","In one embodiment, the High-side Interface Listener sends a VDP session-initiated message to the Client, which waits for final VDP traffic from the Translator (by way of the Guard). The Listener also forwards the \u201cnew session established\u201d message to the High-Side VDP Router, and then on to each of the inspection engines (Dirty Word Search, Keyboard Filter, and Mouse Filter). The message continues to the Low-Side VDP Forwarder, Low-Side Interface Listener, then to the Low-Side inspection engines (Image). Once all subcomponents are ready for the new session, as communicated by the round-robin IPC internal to the Guard, the final stage of session initialization occurs.","In one embodiment, the High-Side Authentication subcomponent sends a message to the High\/Low Mapper. The Mapper forwards a message to the Low-Side Authentication subcomponent, which crafts a VDP packet consisting of the low-side user ID and password. The VDP packet is forwarded to the Low-Side VDP Forwarder. The Forwarder sends the packet to the Low-Side Interface Listener, which initiates the TLS connection with the Translator.","Inspection and Filter Subcomponents","Common Inspection Engine Framework","In one embodiment, the CAB Guard employs a small set of individual filter subcomponents, each designed to inspect a specific type of VDP content: mouse events, keyboard events, and image-related content. While each filter specializes in its intended content, they share a set of core functionality. To provide efficient development, system-wide interoperability, each filter may use the Common Inspection Engine Framework. Common operations such as threading, audit event generation, and heartbeat monitoring are handled by the framework.","Design Decisions and Considerations","Interface-Related Design Considerations","In this embodiment, the Common Inspection Framework may provide the shell for inspection functions. In one embodiment, it receives control and data messages from the VDP Router and sends control and data messages to the VDP Forwarder. It hides these and other details from the inspection engine algorithms, permitting the inspection developer to focus on the inspection algorithms.","Performance-Related Design Considerations","In this embodiment, the Common Inspection Framework may provide a high-performance invocation mechanism for inspection algorithms. It maintains dedicated reader and writer threads to reduce IO latency between external subsystems and a pool of worker threads through which actual inspection occurs. Because performance characteristics are difficult to deduce during design, the interface is flexible to hide threading details from inspection functions. By using thread pools, there is opportunity to tune the inspection engines based on empirical analysis.","Security and Privacy Related Design Considerations","In this embodiment, the Common Inspection Framework may be designed to enable each inspection engine to operate in a separate process, supporting the principle of minimality. It uses the Session Management elements to maintain session separation. When an inspection function indicates there is at least one inspection violation (a function could observe multiple violations), the framework can block the violating traffic, if policy dictates for that session. It may also generate an audit event for each violation.","Flexibility, Availability, and Maintainability Design Considerations","In this embodiment, the Common Inspection Framework may be designed to be flexible. It provides a rich and straightforward interface for inspection engines, so that new inspection engines can tap the auditing, threading, and session management capabilities already developed.","Subcomponent Details","IInspectionEngine","In one embodiment, IInspectionEngine defines the interface that inspection engines must implement in order to be invoked by the Common Inspection Framework.","InspectionMgr","In this embodiment, the InspectionMgr may coordinate the Common Inspection Framework activity. It maintains and reads data and control traffic from the VDP Router invokes the inspection engine, via IInspectionEngine, logs events, and blocks or forwards traffic to the VDP Forwarder.","Administration","In this embodiment, the Common Inspection Framework may be administered via configuration files. The configuration parameters include thread pool tuning parameters, engine name, and the identifiers for the VDP Router and Forwarder (to specify high or low).","Dirty Word Search Filter","In one embodiment, the Dirty Word Search (DWS) component inspects character-oriented input to identify words that should not be disseminated from high to low to domains. The Dirty Word Search is like other inspection components in that it preferably uses some kind of overall user session state to validate a specific keyboard event. It may plug into the overall Inspection Engine Framework. Issues such as threading, event generation, and heartbeat monitoring may be handled by the framework.","One embodiment of Dirty Word Search performs a na\u00efve inspection of session characters, using a modified Aho-Corasick text matching algorithm. If a dirty word is detected, then the packet can be discarded. Because actual packet discarding is a policy-driven aspect, the Dirty Word Search does not actually drop a packet, per se; it merely signals that an event has occurred.","Design Decisions and Considerations","Decision to Develop or Reuse","In this embodiment, the Dirty Word Search component can reuse the Inspection, Session Management, Process\/Threading Framework, and Transaction Processing components developed for the Guard. Its design may reuse elements of research-validated keyword-matching algorithms based on the seminal Aho-Corasick paper.","Component Design Decisions","In one embodiment, the Dirty Word Search component reflects object-oriented analysis and design methodology on a procedural C programming language platform. An object-oriented approach facilitates reuse and future-proofs. The State Machine and Flyweight design patterns may be employed.","Interface-Related Design Considerations","In this embodiment, the Dirty Word Search component may have minimal interface-related concerns. Because it is an inspection component, it may behave similarly to other inspection components, to facilitate administration and development. The Dirty Word Search component, by way of the Inspection Engine, generates Audit messages that comply with the Audit format, uses configuration files that comply with the Configuration File component and implements the necessary interfaces to work in the Inspection Engine framework.","Performance-Related Design Considerations","In this embodiment, the Dirty Word Search component may be designed so that it has no discernable impact on user response time. Therefore, it may use an efficient optimization of the Aho-Corasick multiple-pattern-matching algorithm, optimized for single-octet languages.","One embodiment could support full Unicode UTF-32, quad-octet encodings by using a pattern matching algorithm akin to those used in anti-virus scanners. Dictionary representation is separated from session state to allow that multiple user sessions could share the same dictionary. Because real-world performance bottlenecks are often not understood until code is tested, the design can make use of loose-coupling, including the separation of the algorithm from overall inspection engine. Loose coupling facilitates performance tuning by enabling new, better implementations of components to be introduced.","Safety, Security, and Privacy Design Considerations","In one embodiment, the Dirty Word Search component carries out a single-context per-character inspection method\u2014multiple character strings are treated as successive single-character events. As with other Guard applications, the Dirty Word Search may execute in a separate domain. It may have one-way input for character events, one-way decision output to indicate success or failure, and IPC interfaces with various supporting system components, such as the Audit and Initialization components. Exemplary security issues may include:\n\n","Flexibility, Availability, and Maintainability Design Considerations","One embodiment of the Dirty Word Search component preferably supports multiple languages, each with its own search algorithm. Unicode enables the representation of any widespread written language, represented by up to four bytes. Efficient Aho-Corasick implementations rely on constant-time lookup of node transitions, which in Unicode could potentially include 2possibilities. Because the original Aho-Corasick design calls for single-character nodes, its tree structure is preferably modified because of scalability problems. Instead a \u201ctrie\u201d structure may be used. A trie does not represent every transition with a new node. Rather, multiple transitions can point to the same node, reducing memory footprint.","In this embodiment, to support multiple algorithms, the algorithm may be implemented as a separable module, upgradeable at system patch time.","Subcomponent Details","In this embodiment, highlights of the assumptions of the Dirty Word Search, separate from the core implementation of the Aho-Corasick algorithm variant: can include:\n\n","In this embodiment, given these assumptions, there are states to distinguish between a dirty word's detection and session termination.","RuntimeDictionary","In one embodiment, the RuntimeDictionary is a state machine representation of all dirty and clean words in the dictionary. States are represented by a CharacterState object. Because a single Unicode character could be one of 2values, it is not feasible to store all transitions in a 2-element array. Therefore, a word may be represented as a sequence of bytes. The two bytes indicate transitions to other states; subsequent bytes are preferably matched from a linked list.","CharacterNode","In this embodiment, a CharacterNode can represent a state of the RuntimeDictionary. It contains the first byte of the Unicode representation, transitions to other CharacterNode states, and a flag indicating a dirty word match.","SessionCharacterProcessor","In this embodiment, the SessionCharacterProcessor object may store the state needed to capture character-oriented entry of words and processes characters. A purpose is to invoke state transitions in the RuntimeDictionary. It maintains a stack of characters entered by the user, to access previous state when a backspace is pressed and a reference to the CharacterState used in the search algorithm state machine.","DictionaryReader","In this embodiment, the DictionaryReader may use the Configuration component to read and update the RuntimeDictionary.","DirtyWordSearchEngine","In this embodiment, the DirtyWordSearchEngine may be a simple function that extracts the character or string data from part of the VDP packet and passes it to the SessionCharacterProcessor for evaluation.","SubstitutionCode","In this embodiment, a SubstitutionCode uniquely substitutes for another character, such as \u201c3\u201d for \u201ce,\u201d or identifies a command, such as backspace or left-cursor movement.","Administration","In this embodiment, Administration of this component may be accomplished through the system's configuration files. The Guard Policy Administrator\u2014or possibly a more specific Dirty Word Search Policy Administrator\u2014creates and modifies policies governing the behavior of components on the Guard, including the Dirty Word Search Filter. The Policy Administrator, therefore, controls the policy-specific configuration items, such as the dirty word and clean word lists. The Policy Administrator can also control auditing behavior and resource allocation related to the filter, and can determine the responses of the filter to suspicious events. The capabilities of Policy Administrator may be tightly controlled, and should be assumed by a properly trained individual.","Interfaces","In this embodiment, within the Guard system component, the Dirty Word Search Filter process will interface with several other subcomponents. The table below provides a description of some exemplary interfaces:",{"@attributes":{"id":"p-0518","num":"0681"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"DWS Filter - Internal Guard Interfaces"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Subcomponent","Interface Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["High-Side VDP","This subcomponent receives information from the High-Side VDP"]},{"entry":["Router","Router, via the common Wire Protocol. The bulk of the data received"]},{"entry":[{},"consists of VDP character events; however, configuration and session"]},{"entry":[{},"setup information is also received over the same channel. This is one-way"]},{"entry":[{},"communication."]},{"entry":["Low-Side VDP","This subcomponent sends information to the Low-Side VDP Forwarder,"]},{"entry":["Forwarder","via the common Wire Protocol. The bulk of the data sent consists of VDP"]},{"entry":[{},"character events; however, configuration and session setup information is"]},{"entry":[{},"also sent over the same channel. This is one-way communication."]},{"entry":["Initialization","The Initialization Process launches this subcomponent, using an \u2018exec\u2019"]},{"entry":["Process","call. No communications are established between this subcomponent and"]},{"entry":[{},"the Initialization Process."]},{"entry":["Configuration","This subcomponent reads configuration information from the"]},{"entry":[{},"Administration and Configuration subcomponent, using the interfaces"]},{"entry":[{},"provided by the Administration and Configuration subcomponent. This is"]},{"entry":[{},"one-way communication."]},{"entry":["Heartbeat","Upon execution, this subcomponent utilizes the common Wire Protocol to"]},{"entry":["Monitor","provide regular heartbeat messages to the heartbeat monitor. This is one-"]},{"entry":[{},"way communication."]},{"entry":["Shutdown","Upon execution, this subcomponent registers with the Shutdown Process,"]},{"entry":["Process","using the common Wire Protocol. Once registered, the heartbeat monitor"]},{"entry":[{},"listens for shutdown commands from the shutdown process. This is one-"]},{"entry":[{},"way communication."]},{"entry":["Audit","This subcomponent sends audit messages directly to the Audit"]},{"entry":[{},"subcomponent, using the common Wire Protocol. This is one-way"]},{"entry":[{},"communication."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Keyboard Filter","In one embodiment, the Keyboard Filter inspects VDP keyboard data to ensure that keystroke messages are consistent with the acceptable use of a keyboard by a client application. It is preferably to distinguish its behavior from that of the Dirty Word Search component, which processes text character events\u2014a higher level of abstraction.","In this embodiment, the Keyboard Filter may be like other inspection components in that it preferably uses some kind of overall user session state to validate specific events. To provide this, the Keyboard Filter can plug into the Common Inspection Engine Framework. Like other Inspection and Filter components, the Keyboard Filter can employ individual session states for each user.","One embodiment of Keyboard Filter performs token bucket rate limiting. If an average or burst threshold is reached, the token, a keystroke, is discarded. In the context of keyboard inspection, discarding means the generation of a security event and potential packet discarding. Because actual packet discarding is a policy-driven aspect, the Keyboard Inspector does not actually drop a packet, per se; it merely creates an error object that the Inspection Engine Manager processes. The Inspection Engine Manager, in turn signals that an event has occurred.","In this embodiment, an exemplary Keyboard Inspector workflow for keyboard inspection may be as follows:\n\n","Design Decisions and Considerations","Decision to Develop or Reuse","In this embodiment, the Keyboard Filter may reuse the Inspection, Session Management, Process\/Threading Framework, and Transaction Processing components developed for the Guard. Its design may reuse the token bucket rate limiter algorithm.","Component Design Decisions","In this embodiment, the Keyboard Filter may reflect object-oriented analysis and design methodology. An object-oriented approach facilitates reuse and future-proofs many design decisions that cannot be determined during the initial design activities. The Flyweight design pattern may be employed.","Interface-Related Design Considerations","In this embodiment, the Keyboard Filter may have minimal interface-related concerns. Because it is an inspection component, it may behave similarly to other inspection components to facilitate administration and development. In one embodiment, the Keyboard Filter, by way of the Inspection Engine, generates Audit messages that comply with the Audit format, uses configuration files that comply with the Configuration File component, and implements the necessary interfaces to work in the Inspection Engine framework.","Performance-Related Design Considerations","In this embodiment, the Keyboard Filter component may be designed so that it has no discernable impact on user response time. It may provide administrator-tunable rate limits. Because real-world performance bottlenecks are often not understood until code is tested, the design can make use of loose coupling, including the separation of the algorithm from the overall inspection engine. Loose coupling facilitates performance tuning by enabling new, better implementations of components and to be introduced.","Database Design Considerations","In this embodiment, this component may have no database design considerations. The keyboard layout may be simple enough to be defined in a static file.","Safety, Security, and Privacy Design Considerations","In one embodiment, the Keyboard Filter component carries out a single-keystroke inspection method\u2014multiple keystrokes in a message are represented as multiple invocations of the algorithm. In one embodiment, keyboard switching within a session may not be supported in the Keyboard Filter. As with other Guard applications, the Keyboard Filter may execute in a separate domain. It may have a one-way input for scan code events, one-way decision output to indicate success or failure, and IPC interfaces with various supporting system components, such as the Audit and Initialization components. Exemplary security issues include:\n\n","Flexibility, Availability, and Maintainability Design Considerations","In one embodiment, the Keyboard Filter preferably supports multiple keyboards. It is preferably extensible to support additional inspection algorithms with minimal impact to design.","Subcomponent Details","KeyPress","In one embodiment, the Keypress object stores the keyboard scan code and timestamp. In one embodiment, the Keyboard Inspector preferably only identifies typing-rate anomalies. Therefore, it need only have a queue of timestamps. However, for diagnostic purposes, it is useful to have the scan code as well, such as logging the first keystroke that occurred in an anomaly.","KeyboardState","In one embodiment, the KeyboardState object maintains the state necessary to conduct keystroke anomaly detection, including the active keyboard and the queue of Keypress objects.","KeyboardConfig","In one embodiment, a KeyboardConfig maintains the keyboard configuration parameters. Because multiple sessions might use the same kind of keyboard, the read-only KeyboardConfig is shared across sessions","KeyboardReader","In one embodiment, the KeyboardReader uses the Configuration component to read and update the RuntimeDictionary.","KeyboardInspector","In one embodiment, the KeyboardInspector is a simple function that extracts the scan code from the VDP packet and passes it to the KeyboardConfig for evaluation.","Administration","In this embodiment, administration of this component can be accomplished through the system's configuration files. The Guard Policy Administrator\u2014or possibly a more specific Keyboard Policy Administrator\u2014creates and modifies policies governing the behavior of components on the Guard, including the Keyboard Filter. The Policy Administrator, therefore, controls the policy-specific configuration items, such as the keyboard layout, scan codes, and permissible typing rate in one embodiment. The Policy Administrator can also control auditing behavior and resource allocation related to the filter, and can determine the responses of the filter to suspicious events. The capabilities of Policy Administrator may be tightly controlled, and should only be assumed by a properly trained individual.","Interfaces","In this embodiment, within the Guard system component, the Keyboard Filter process may interface with several other subcomponents. The table below provides a description of exemplary interfaces:",{"@attributes":{"id":"p-0554","num":"0724"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Keyboard Filter - Internal Guard Interfaces"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Subcomponent","Interface Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["High-Side VDP","This subcomponent receives information from the High-Side VDP"]},{"entry":["Router","Router, via the common Wire Protocol. The bulk of the data received"]},{"entry":[{},"consists of VDP keyboard events; however, configuration and session"]},{"entry":[{},"setup information is also received over the same channel. This is one-way"]},{"entry":[{},"communication."]},{"entry":["Low-Side VDP","This subcomponent sends information to the Low-Side VDP Forwarder,"]},{"entry":["Forwarder","via the common Wire Protocol. The bulk of the data sent consists of VDP"]},{"entry":[{},"keyboard events; however, configuration and session setup information is"]},{"entry":[{},"also sent over the same channel. This is one-way communication."]},{"entry":["Initialization","The Initialization Process launches this subcomponent, using an \u2018exec\u2019"]},{"entry":["Process","call. No communications are established between this subcomponent and"]},{"entry":[{},"the Initialization Process."]},{"entry":["Configuration","This subcomponent reads configuration information from the"]},{"entry":[{},"Administration and Configuration subcomponent, using the interfaces"]},{"entry":[{},"provided by the Administration and Configuration subcomponent. This is"]},{"entry":[{},"one-way communication."]},{"entry":["Heartbeat","Upon execution, this subcomponent utilizes the common Wire Protocol to"]},{"entry":["Monitor","provide regular heartbeat messages to the heartbeat monitor. This is one-"]},{"entry":[{},"way communication."]},{"entry":["Shutdown","Upon execution, this subcomponent registers with the Shutdown Process,"]},{"entry":["Process","using the common Wire Protocol. Once registered, the heartbeat monitor"]},{"entry":[{},"listens for shutdown commands from the shutdown process. This is one-"]},{"entry":[{},"way communication."]},{"entry":["Audit","This subcomponent sends audit messages directly to the Audit"]},{"entry":[{},"subcomponent, using the common Wire Protocol. This is one-way"]},{"entry":[{},"communication."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Mouse Filter","In one embodiment, a purpose of the mouse filter subcomponent is to take mouse events associated with a given session and perform a set of inspections to verify that those events do not contain any anomalies that might adversely affect the Terminal Server or the Client. These inspections will be largely transparent to the Client user.","In this embodiment, the Mouse Filter may be like other filtering subcomponents in that it preferably uses some kind of overall user session state to validate specific events. To provide this, the Mouse Filter may plug into the Common Inspection Engine Framework.","Design Decisions and Considerations","Decision to Develop or Reuse","In this embodiment, much of the Mouse Filter's functionality may be virtually identical to that of other filter components (such as the image filter subcomponent, etc.). This will permit the reuse of certain features, such as the following:\n\n","In this embodiment, the Common Inspection Engine Framework may be employed as a wrapper for the Mouse Filter. The wrapper may handle those functions that are required by inspection engines, while leaving the Mouse Filter engine to focus on inspecting mouse events.","Component Design Decisions","In this embodiment, several factors affect the design of the Mouse Filter subcomponent, including:\n\n","Interface-Related Design Considerations","In this embodiment, the Mouse Filter subcomponent may employ CAB's common Wire Protocol and IPC mechanism for receiving data from the High-Side VDP router, and sending data on to the Low-Side VDP Packetizer. In addition, these IPC mechanisms may be used for transmitting control information, such as session IDs, packet IDs, and session state. The Mouse Filter subcomponent may also use the common IPC mechanism to communicate with the Audit subsystem. Utilizing SELinux enforcement of the IPC mechanisms canl ensure that the direction of data flows is strictly controlled, and that data can cross the domain boundary in a tightly controlled fashion.","Performance-Related Design Considerations","In this embodiment, the transmission of mouse events may consume very little bandwidth, compared to image or sound data, so performance may not be as large a concern as it is with image or sound data. On the other hand, a major portion of the user's experience is directly affected by how fast user input events are sent through the Guard and system. Thus, mouse input events are preferably processed as efficiently and quickly as possible to ensure that there is no lag between user input and the resulting visual response.","Database Design Considerations","In this embodiment, the Mouse Filter subcomponent may not require a database to store connection information. Instead, it may maintain a connection table containing relevant information about each connection (session ID, user ID, session state, screen size, etc.) in memory.","In this embodiment, the Mouse Filter subcomponent may require access to policy information in order to determine how to handle anomalies. Policy information may be obtained via the Administration and Configuration subcomponents. Based on policy settings, the Mouse Filter may block and\/or log certain types of anomalies. One embodiment of the filter may also need to identify patterns in mouse movements in order to detect side channel communications (e.g. the Ouija board scenario, etc.). The mouse inspection component may also provide fine-grained control over throughput, in order to give preference to certain users over others.","Safety, Security, and Privacy Design Considerations","In this embodiment, the Mouse Filter subcomponent may reside in its own security domain. SELinux may ensure that data can only be read in from the IPC shared with the high-side VDP Router. Similarly, data may only be written to the IPCs shared with the low-side VDP Packetizer and the Audit component. This may prevent data flows from moving in unintended directions, thereby tightly mediating the interactions between the high-side and low-side domains.","Flexibility, Availability, and Maintainability Design Considerations","In this embodiment, the Mouse Filter subcomponent may support availability by generating a \u201cheartbeat\u201d at regular intervals, allowing the Heartbeat Monitor subcomponent to monitor overall system health. If the Mouse Filter subcomponent dies or enters an illegal state, the heartbeat should cease, thereby indicating a serious problem to the heartbeat monitor.","Subcomponent Details","In this embodiment, the Mouse Filter subcomponent may consist primarily of a mouse filter engine, and the Common Inspection Engine Framework wrapper. The mouse filter engine may contain a pool of threads that will perform the actual inspection of mouse events, which should allow higher throughput. The wrapper will handle functions common to all filters (IPC communications, session data management, VDP library functions, etc.), and may be reusable. The wrapper may consist of a number of threads in order to perform its tasks. For example, the wrapper may include reader and writer threads for IPC communications, a heartbeat thread for system health monitoring, etc.","In this embodiment, VDP packets containing mouse event data may be forwarded on to the mouse filter engine, along with information about the connection (session ID, etc.). The mouse filter engine may be responsible for inspecting the following types of events:\n\n","In this embodiment, in order to perform these operations, the mouse filter engine may need to be able to parse VDP data to identify the mouse event to be inspected, and thus the type of inspection to be performed. The mouse filter engine may then analyze the event, and determine whether the data passes or fails inspection. Note that proper analysis of some events may depend on session-specific settings like screen size. In essence, the mouse filter engine will be checking for improper field lengths, invalid values, illegal coordinates, etc.","In this embodiment, in addition to format and data validation, the mouse filter engine may need to do basic anomaly detection. Anomalies that are preferably detected by the mouse filter engine include:\n\n","In this embodiment, if an event passes all checks, it may then be passed to the low-side VDP Forwarder. Otherwise, the Mouse Filter may notify the Audit subsystem of the failure, and then use the current policy to determine whether to pass the offending mouse event. The Audit subsystem may be responsible for coordinating additional actions, such as closing down the current session or locking out the user.","Administration","In this embodiment, the Guard Policy Administrator can create and modify policies governing the behavior of components on the Guard, including the Mouse Filter. The Policy Administrator can thereby control auditing behavior and resource allocation, and can also determine the responses of the filter to suspicious events. The role of Policy Administrator may have limited abilities, and should preferably only be assumed by a highly vetted individual.","Interfaces","In this embodiment, within the Guard system component, the Mouse Filter may interface with several other subcomponents. The table below shows examples of these interfaces:",{"@attributes":{"id":"p-0585","num":"0774"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Mouse Filter - Internal Guard Interfaces"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Subcomponent","Interface Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["High-Side VDP","This subcomponent receives information from the High-Side VDP"]},{"entry":["Router","Router, via the common Wire Protocol. The bulk of the data received"]},{"entry":[{},"consists of VDP mouse events; however, configuration and session setup"]},{"entry":[{},"information is also received over the same channel. This is one-way"]},{"entry":[{},"communication."]},{"entry":["Low-Side VDP","This subcomponent sends information to the Low-Side VDP Forwarder,"]},{"entry":["Forwarder","via the common Wire Protocol. The bulk of the data sent consists of VDP"]},{"entry":[{},"mouse events; however, configuration and session setup information is"]},{"entry":[{},"also sent over the same channel. This is one-way communication."]},{"entry":["Initialization","This Initialization Process launches this subcomponent, using an \u2018exec\u2019"]},{"entry":["Process","call. No communications are established between this subcomponent and"]},{"entry":[{},"the Initialization Process."]},{"entry":["Configuration","This subcomponent reads configuration information from the"]},{"entry":[{},"Administration and Configuration subcomponent, using the interfaces"]},{"entry":[{},"provided by the Administration and Configuration subcomponent. This is"]},{"entry":[{},"one-way communication."]},{"entry":["Heartbeat","Upon execution, this subcomponent utilizes the common Wire Protocol to"]},{"entry":["Monitor","provide regular heartbeat messages to the heartbeat monitor. This is one-"]},{"entry":[{},"way communication."]},{"entry":["Shutdown","Upon execution, this subcomponent registers with the Shutdown Process,"]},{"entry":["Process","using the common Wire Protocol. Once registered, the heartbeat monitor"]},{"entry":[{},"listens for shutdown commands from the shutdown process. This is one-"]},{"entry":[{},"way communication."]},{"entry":["Audit","This subcomponent sends audit messages directly to the Audit"]},{"entry":[{},"subcomponent, using the common Wire Protocol. This is one-way"]},{"entry":[{},"communication."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Image Filter","In this embodiment, this section describes the elements in the CAB Guard that inspect image data and image-related operations that are sent from the low-side CAB Terminal Server to the high-side CAB Client. When image data is transmitted from the low-side Terminal Server, it is the responsibility of the Guard to ensure that such image data is properly formed, and will not pose any threat to the high-side Client. In one embodiment, the image inspection methodology will consist primarily of message format verification and field validation, which together ensure that no malformed or dangerous image data traverses the Guard. Other embodiments may offer more complex inspections, such as checking for the existence of steganographic content.","In this embodiment, the Image Filter subcomponent may be like other filter subcomponent in that it preferably uses some kind of overall user session state to validate specific events. To provide this, the Image Filter may plug into the Common Inspection Engine Framework.","Design Decisions and Considerations","Decision to Develop or Reuse","In this embodiment, much of the Image Filter subcomponent's functionality may be virtually identical to that of other inspection components (such as the Mouse Inspection subcomponent, etc.). This may permit the reuse of certain features, such as the following:\n\n","In this embodiment, the Common Inspection Engine Framework may be utilized as a wrapper for the Image Filter. The wrapper may handle those functions that are required by inspection engines, while leaving the Image Filter engine to focus on inspecting mouse events.","Component Design Decisions","In this embodiment, several factors may affect the design of the Image Filter subcomponent, including:\n\n","Interface-Related Design Considerations","In this embodiment, the Image Filter subcomponent may employ CAB's common Wire Protocol and IPC mechanism for receiving data from the High-Side VDP router, and sending data on to the Low-Side VDP Packetizer. In addition, these IPC mechanisms may be used for transmitting control information, such as session IDs, packet IDs, and session state. The Image Filter subcomponent may also utilize the common IPC mechanism to communicate with the Audit subsystem. Utilizing SELinux enforcement of the IPC mechanisms may ensure that the direction of data flows is controlled, and that data can preferably only cross the domain boundary in a tightly controlled fashion.","Performance-Related Design Considerations","In this embodiment, performance may be a consideration for the Image Filter subcomponent, considering the quantities of data that it will be required to handle. For this reason, the Image Filter may require a variety of optimization techniques, including loop unrolling, inline assembly, efficient branching, caching, etc.","Database Design Considerations","In this embodiment, the Image Filter subcomponent may not require a database to store connection information. Instead, it may maintain a connection table containing relevant information about each connection (session ID, user ID, session state, client screen resolution and color depth, etc.) in memory.","In this embodiment, the Image Filter subcomponent may require access to policy information in order to determine how to handle anomalies. Policy information may be obtained via the Administration and Configuration subcomponents. Based on policy settings, the Image Filter may block and\/or log certain types of anomalies. One embodiment of the filter may also provide fine-grained control over throughput, in order to give preference to certain users over others.","Safety, Security, and Privacy Design Considerations","In this embodiment, the Image Filter subcomponent may reside in its own security domain. SELinux may ensure that data can only be read in from the IPC shared with the high-side VDP Router. Similarly, data may be written to the IPCs shared with the low-side VDP Packetizer and the Audit component. This may prevent data flows from moving in unintended directions, thereby tightly mediating the interactions between the high-side and low-side domains.","Flexibility, Availability, and Maintainability Design Considerations","In this embodiment, the Image Filter subcomponent may support availability by generating a \u201cheartbeat\u201d at regular intervals, allowing the Heartbeat Monitor subcomponent to monitor overall system health. If the Image Filter subcomponent dies or enters an illegal state, the heartbeat should preferably cease, thereby indicating a serious problem to the heartbeat monitor.","Subcomponent Details","In this embodiment, the Image Filter subcomponent may consist primarily of an image filter engine, and the Common Inspection Engine Framework wrapper. The image filter engine may contain a pool of threads that can perform the actual inspection of image data and operations, while the wrapper will handle functions common to all filters (IPC communications, session data management, VDP library functions, etc.). Note that the image filter engine may be replicated into a number of separate threads in order to increase throughput.","In this embodiment, VDP packets containing image data and operations may be forwarded on to the image filter engine, along with information about the connection (session ID, etc.) It may be preferable for the Image Filter subcomponent to maintain some state about sessions for the purposes of auditing and\/or blocking traffic associated with a given user or session. The image filter engine may be responsible for inspecting the following exemplary VDP drawing commands and operations:\n\n","In this embodiment, in addition to basic format and anomaly detection, the image filter engine preferably ensures that any packets it receives are valid for the current session's capabilities. Each user session may permit some subset of drawing commands, caching operations, and parameters (i.e., screen size). If any packets are received containing operations or parameters that are not supported by the capability set, the image filter preferably takes appropriate action. Actions may include dropping the packet and logging an audit event for the occurrence.","In this embodiment, in order to perform these operations, the image filter engine may need to be able to parse VDP data to identify the type of data to be inspected, and thus the type of inspection to be performed. The image filter engine may then inspect the data, and determine whether the data passes or fails inspection. The image filter engine may, for example, be checking for:\n\n","In this embodiment, if the data passes all checks, it may then be passed to the high-side VDP Forwarder. Otherwise, the Image Filter may notify the Audit subsystem of the failure, and then use the current policy to determine whether to pass the offending event. The Audit subsystem may be responsible for coordinating additional actions, such as closing down the current session or locking out the user.","Administration","In this embodiment, the Guard Policy Administrator can create and modify policies governing the behavior of components on the Guard, including the Image Filter. The Policy Administrator can thereby control auditing behavior and resource allocation, and can also determine the responses of the filter to suspicious events or data. The role of Policy Administrator may have limited abilities, and preferably should be assumed by a highly vetted individual.","Interfaces","In this embodiment, within the Guard system component, the Image Filter may interface with several other subcomponents. The table below shows examples of these interfaces:",{"@attributes":{"id":"p-0616","num":"0828"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Image Filter - Internal Guard Interfaces"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Subcomponent","Interface Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Low-Side VDP","This subcomponent receives information from the Low-Side VDP Router,"]},{"entry":["Router","via the common Wire Protocol. The bulk of the data received consists of"]},{"entry":[{},"VDP image data and operations; however, configuration and session setup"]},{"entry":[{},"information is also received over the same channel. This is one-way"]},{"entry":[{},"communication."]},{"entry":["High-Side VDP","This subcomponent sends information to the High-Side VDP Forwarder,"]},{"entry":["Forwarder","via the common Wire Protocol. The bulk of the data sent consists of VDP"]},{"entry":[{},"image data and operations; however, configuration and session setup"]},{"entry":[{},"information is also sent over the same channel. This is one-way"]},{"entry":[{},"communication."]},{"entry":["Initialization","Initialization Process launches this subcomponent, using an \u2018exec\u2019 call."]},{"entry":["Process","No communications are established between this subcomponent and the"]},{"entry":[{},"Initialization Process."]},{"entry":["Configuration","This subcomponent reads configuration information from the"]},{"entry":[{},"Administration and Configuration subcomponent, using the interfaces"]},{"entry":[{},"provided by the Administration and Configuration subcomponent. This is"]},{"entry":[{},"one-way communication."]},{"entry":["Heartbeat","Upon execution, this subcomponent utilizes the common Wire Protocol to"]},{"entry":["Monitor","provide regular heartbeat messages to the heartbeat monitor. This is one-"]},{"entry":[{},"way communication."]},{"entry":["Shutdown","Upon execution, this subcomponent registers with the Shutdown Process,"]},{"entry":["Process","using the common Wire Protocol. Once registered, the heartbeat monitor"]},{"entry":[{},"listens for shutdown commands from the shutdown process. This is one-"]},{"entry":[{},"way communication."]},{"entry":["Audit","This subcomponent sends audit messages directly to the Audit"]},{"entry":[{},"subcomponent, using the common Wire Protocol. This is one-way"]},{"entry":[{},"communication."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Sound Filter","In one embodiment, CAB supports audio content transferred from the low-side Terminal Server to the high-side Client.","In one embodiment, the Sound Filter preferably ensures that such data is properly formed, and will not pose any threat to the high-side Client. In one embodiment, the audio inspection methodology may consist primarily of message format verification and field validation, which together may ensure that no malformed or dangerous audio data traverses the Guard.","In this embodiment, the Sound Filter subcomponent may be like other filter subcomponent in that it preferably maintains some kind of overall user session state to validate specific events. To provide this, the Sound Filter may plug into the Common Inspection Engine Framework.","VDP Communications Subsystem","In this embodiment, the VDP Communications Subsystem performs Guard routing and forwarding functions. It may consist of three subcomponents: the VDP Router, VDP Forwarder, and Session Management interface.","In one embodiment, the VDP Router receives VDP packets from the Network Listener and routes them to the next location. The VDP Forwarder receives VDP packets from Guard components and forwards them to the Network Listener for network transmission. There may be high and low VDP Routers and Forwarders. The VDP Router and Forwarder may be designed to perform fast routing of data between Guard components, while maintaining session coherency, session prioritization and one-way data flow policy.","In this embodiment, the Session Management interface may define the common operations used for synchronizing session information across the VDP Router, VDP Forwarder and other Guard components.","Design Decisions and Considerations","Decision to Develop or Reuse","In one embodiment, the VDP Communications component reuses the Process\/Threading Framework, Wire Protocol, and Transaction Processing components developed for the Guard. It provides common interfaces so that other components can communicate with it.","Component Design Decisions","In one embodiment, the VDP Communications component reflects object-oriented analysis and design methodology on a procedural C programming language platform. An object-oriented approach may facilitate reuse and may future proof many design decisions that cannot be determined during the initial design activities. It may use the Bridge pattern to separate threading concerns and to support loose coupling with which it communicates with the components.","Interface-Related Design Considerations","In this embodiment, the VDP Communications Component may define interfaces for components in the inspection path. The interfaces may include sending and receiving from the Network Listener and inspection engines. In one embodiment, both packet flow and control interfaces may flow in a unidirectional manner, either strictly high-to-low or low-to-high, without direct feedback channels. The VDP Communications component may generate Audit messages that comply with the Audit format, uses configuration files that comply with the Configuration File component, and implements the necessary interfaces to work in the Inspection Engine framework.","Performance-Related Design Considerations","In this embodiment, the VDP Communications component may be designed so that it has no discernable impact on user response time with multiple simultaneous sessions. It may be designed so that different threading models can be employed. To reduce contention, lock-free algorithms may be employed for passing data across threads. Because real-world performance bottlenecks are often not understood until code is tested, the design may make heavy use of loose coupling, including the separation of IO from and packet verification and reordering processing. Loose coupling facilitates performance tuning by enabling new, better implementations of components to be introduced.","Safety, Security, and Privacy Design Considerations","In this embodiment, the VDP Communications Component may play a role in the one-way pipeline between Network Listeners of different levels. Packet data and control messages preferably flow in one direction. Exemplary flows are presented in the table below:",{"@attributes":{"id":"p-0636","num":"0848"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"VDP Communications Subcomponent Packet and Control Flow"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["VDP Communications Sub-",{},{}]},{"entry":["Component","Packet and Control from","Packet and Control to"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["High-Side VDP Router","High-Side Network Listener","Inspection Engines, High-"]},{"entry":[{},{},"Side Authenticator, Client"]},{"entry":[{},{},"Logger"]},{"entry":["Low-Side VDP Forwarder","Inspection Engines, Low-Side","Low-Side Network Listener"]},{"entry":[{},"Authenticator"]},{"entry":["Low-Side VDP Router","Low-Side Network Listener","Inspection Engines"]},{"entry":["High-Side VDP Forwarder","Inspection Engines, High-Side","High-Side Network Listener"]},{"entry":[{},"Authenticator, Event Manager"]},{"entry":["Session Management","Control from all session-","Control to all session-related"]},{"entry":[{},"related components","components."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Subcomponent Details","In this embodiment, the VDP Communications subsystem may consist of three subcomponents: the VDP Router, VDP Forwarder and Session Management interface.","VDP Router","In one embodiment, the VDP Router executes core VDP protocol verification and routes the packets to the next Guard component for processing. The VDP Router receives packets from the Network Listener, which has preferably ensured that the VDP header is valid and that the packet has been read from the network. The VDP Router may use the VDP Reference Implementation to perform validation functions, to execute VDP protocol state transitions and to identify the type of VDP packet received. If validation succeeds, then the VDP Router forwards the packet to the next Guard component based on packet type.","In one embodiment, there may be two running instances of the VDP Router: high-side (client-receive) and low-side (translator-send). The high-side router forwards packets to the VDP Authenticator, high-to-low inspection engines, and the VDP Logger. The low-side router forwards packets to the low-to-high inspection engines.","VDPRouterServer","In this embodiment, the VDPRouterServer may receive packet and control IPC messages from the Network Listener. It places all packets in a per-session queue for inspection by the VDPVerifier. It may be a very small component to minimize IO latency with the Network Listener.","VDPRouterSessionState","In one embodiment, the VDPRouterSessionState may consist of common user session state and an additional inbound packet queue. The packet queue may assure that packets are assigned per-user sequence numbers in order of arrival at the Guard.","VDPVerifier","In one embodiment, the VDPVerifier performs VDP protocol verification and packet prioritization, sequencing, and routing. It can extract packets from the per-session queues in priority order. Once extracted, it can use the VDP Reference implementation to verify the packet and determine the packet's type. If the packet is valid, it is assigned the next sequence number.","In one embodiment, the VDPVerifier maintains a mapping of packet type to destination processor, i.e., the next Guard component to receive the packet for processing. Destinations may be managed by a configuration file. The VDPVerifier may queue the packet into the appropriate destination, using the prioritization associated with the user's session state.","In this embodiment, because there may be two running instances of the VDP Router, with different target components, there may be different configuration files and security policies that dictate the flow of communication.","VDPPacketProcessorClient","In one embodiment, the VDPPacketProcessorClient makes the IPC call to the packet processor, sending higher priority packets first.","VDP Forwarder","In one embodiment, the VDP Forwarder receives packets from the inspection engines and forwards them to the Network Listener for transmission across the network. Because session inspection is spread across processes, it preferably reorders the packets before they are transmitted. It may use a sequence number generated by the VDP Router.","In this embodiment, there may be two running instances of the VDP Forwarder: low-side (translator-send) and high-side (client-receive). The low-side forwarder may send packets to the low-side Network Listener. The high-side forwarder may send packets to the high-side Network Listener.","VDPReordererServer","In one embodiment, the VDPReordererServer receives IPC messages from Guard components that can forward a packet. It places packets in a per-session priority queue for reassembly.","VDPReorderer","In one embodiment, the VDPReorderer reads packets in sequence-number-order from the session priority queue and places them in an outbound packet queue for forwarding to the Network Listener.","VDPForwarderClient","In one embodiment, the VDPForwarderClient reads packets from the outbound packet queue and sends an IPC to the Network Listener.","Session Management","In one embodiment, the Session Management component may consist of an encapsulated in-process service for managing sessions. It processes control messages, defines interfaces for specialized control messages (e.g., \u201cNotify Translator\u201d) and provides extensible session state management.","SessionState","In this embodiment, a SessionState object may maintain core shared session state and provides extensibility for applications that need to store additional, local state (e.g., the Dirty Word Search stores a list of keystrokes on a per-session basis). It provides synchronization capabilities so that applications can have safe access to data. SessionState may be accessed through the SessionTable.","SessionTable","In this embodiment, a SessionTable may provide guarded access to SessionState. It hides the storage details of data, so that application writers do not need to worry about coding to a specific data structure API.","SessionManager","In this embodiment, a SessionManager may provide the core session control functions. It can receive session control messages from an IPC provided by the application using it. It may support additional session control IPCs by providing an interface to the SessionTable. The Session Manager may be essentially a lightweight service that receives control messages via IPC, performs local operations (i.e., initially add or remove a session), and forwards the request if the message has been received for the first time.","INotifyTranslator","In this embodiment, an INotifyTranslator interface may define the message sent in final-stage session initiation. It may use the IPC provided by the application using it. Applications preferably implement this interface if they wish to send or receive final-stage session initiation control messages.","IConnectionReceived","In this embodiment, an IConnectionReceived interface may define the message sent in early-stage session initiation, before any VDP traffic has been forwarded by the High-side Listener. It may use the IPC provided by the application using it. Applications preferably implement this interface if they wish to send or receive early-stage session initiation control messages.","Administration and Configuration Subcomponent","In one embodiment, the Administration and Configuration subcomponent provides the administrative utilities, configuration files, system status reporting, and run-time interfaces for CAB administration. It provides a partitioned, policy-enforced environment for system administration. Each administrative role permits a high degree of control to the system's administrator's area of concern.","In one embodiment, the system administration functions may be command-line based. Administrators edit configuration files using a text editor and issue a commit command, which invokes the transactional configuration update. To support administration, the Administration and Configuration subcomponent provides diagnostic and performance reports.","Design Decisions and Considerations","Decision to Develop or Reuse","In this embodiment, the administration functions of CAB have been designed to minimize dependencies on proprietary software or concepts. In one embodiment, administration of the CAB system relies on standard SELinux system commands such as tar, bzip2, and cp to generate backups and export data. The configuration files can be readily edited with standard text editors like vi. The subcomponents that validate configuration data may be modular and reused through the system. The configuration file format, XML, for example, is a commonly accepted standard, simplifying administration and enabling integration with existing XML utilities.","In one embodiment, the performance monitor functions use data collected from the command line utilities top and ifconfig, data derived from files in the\/proc file system, and information provided by other CAB subcomponents. The Performance Monitor may be the primary source of CAB data. Additionally, the Audit subsystem can provide live session data.","Performance-Related Design Considerations","In this embodiment, the administrative and performance reporting functions may have very little impact on overall system performance. They are intended to provide live snapshot data. Periodically, the performance reporting functions contact system utilities, read from files in the\/proc file system, and aggregate data received from CAB components. Data processing may be performed as it is collected, and therefore can be minimal and spread out over time. In one embodiment, deeper analysis (e.g., audit reduction), which is more resource-intensive, should preferably be carried out off-line.","Database Design Considerations","In one embodiment, configuration data\u2014including user data\u2014resides in text-based XML files. In another embodiment, database functionality may be used instead of text-based XML files.","Safety, Security, and Privacy Design Considerations","In one embodiment, the administration and performance reporting functions can use the SELinux policy to provide security for the system. Security requirements dictate that administrative roles are preferably partitioned (e.g., policy and auditing roles are separate). The policy can confine the administrative roles, utilities, and configuration files into restricted domains, partitioning capabilities and isolating them from other parts of the system. The performance functionality may also be isolated.","Subcomponent Details","Administrative Roles","In one embodiment, the CAB Guard and Translator have partitioned administrative roles. The responsibilities for each role may be provisioned by the principal of least privilege. The table below presents examples of the roles. Both Guard and Translator may have User, Policy, and Log administrative roles. For example, the User administrator maintains all administrative roles. The Policy role configures the system, except for those functions having to do with auditing and diagnostics. The Log role monitors the system and takes non-policy corrective action. The Guard may also have Client and Forensic administrative roles. For example, the Client administrative role manages client user accounts and profiles. The Forensic administrative role can examine some system logs and view live and recorded sessions.",{"@attributes":{"id":"p-0689","num":"0901"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CAB Administrative Roles"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Role","Purpose","Actions","Notes","Systems"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["User","Administer","Add, lock, and suspend","Dominates other","Guard and"]},{"entry":[{},"administrators","administrators","administrative roles;","Translator"]},{"entry":[{},{},"Change administrator","some actions may only"]},{"entry":[{},{},"passwords","be carried out in"]},{"entry":[{},{},{},"maintenance mode"]},{"entry":["Client","Administer client","Add, lock, and remove",{},"Guard"]},{"entry":[{},"users","client users"]},{"entry":[{},{},"Define user profiles"]},{"entry":[{},{},"Assign user profiles"]},{"entry":["Policy","Configure Guard","Configure all Inspection","Cannot change Audit","Guard and"]},{"entry":[{},"operations and","Engine parameters","configuration","Translator"]},{"entry":[{},"policy","Configure system-wide"]},{"entry":[{},{},"session constraints"]},{"entry":[{},{},"(e.g., screen resolution)"]},{"entry":[{},{},"Backup system"]},{"entry":[{},{},"configuration"]},{"entry":["Log","Execute day-to-day","Configure the Audit and","Cannot change policy","Guard and"]},{"entry":[{},"operations and","Alert policies","or configuration,","Translator"]},{"entry":[{},"identify problems.","View Audit logs","except Audit and Alert"]},{"entry":[{},{},"Backup Audit logs"]},{"entry":[{},{},"View performance"]},{"entry":[{},{},"statistics"]},{"entry":[{},{},"Terminate user sessions"]},{"entry":[{},{},"Turn on the flight"]},{"entry":[{},{},"recorder for a live"]},{"entry":[{},{},"session"]},{"entry":["Forensic","Incident prevention","View live or recorded","May carry out Audit","Translator"]},{"entry":[{},"and analysis","sessions","duties, as needed for"]},{"entry":[{},{},"View some audit logs","analysis"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"Administrative Functions","The following sections describe the administrative utilities.","System Administrative Utilities","In this embodiment, core administrative capabilities can include commands to shut down the system, view active sessions and terminate sessions.","In one embodiment, the Shutdown command may be a command line that is invoked by the Log Administrator to terminate Guard communications and shut down processes. The command sends a shutdown event to the Audit Event Manager, which initiates the system shutdown by signaling the Shutdown Manager.","In one embodiment, the View Sessions command prints each active session, including high-side user name, numeric session identifier, session start time, session state (i.e., \u201cactive\u201d or \u201csuspended\u201d) and other data. The command may parse the live session's data file generated by the Audit subsystem. The tool's output can be filtered using standard Linux tools such as grep or sed.","In this embodiment, a Kill Session command may terminate a session. It may take one or more session IDs as parameters. The Kill Session may send a terminate session event to the Audit Event Manager, which signals the High-Side Interface Listener to terminate the session. View Sessions and Kill Sessions may work in tandem, much like the UNIX-style ps and kill commands.","In this embodiment, a Generate Password command may manage passwords. There may be versions to administer both types of users: administrative and client. Each version may access a different password configuration file. The SELinux Security Policy preferably ensures that each version can access its file and do so during the appropriate policy mode. In production mode, preferably only client user passwords are modified. In maintenance mode, preferably only administrative passwords are modified.","In one embodiment, both versions may use a system encryption key for encryption and decryption. Old passwords within a policy-driven reuse constraint are decrypted and compared with the new password in plaintext form. If the new password is sufficiently different, it is accepted. An encrypted version replaces the old password, and the just-replaced password is appended to the user's list of old password.","Configuration File Edit Utility","In this embodiment, configuration files may be edited through vi, arguably the most ubiquitous text editor in UNIX and Linux. Each administrative role has permission to view and edit specific files, enforced by the SELinux Security Policy. In one embodiment, administrators edit files in the\/etc\/cab\/config_admin directory, the offline editing directory. These edits do not affect the running CAB system processes.","In this embodiment, once files are ready to be incorporated in system operation, they may be committed by the Configuration File Commit utility.","Configuration File Commit Utility","In this embodiment, once an administrator has completed edits of one or more configuration files, the changes can take effect once they have been committed. The Configuration File Commit utility can verify the correctness of the modified files, posts the valid new versions and signals the relevant application to reload the configuration. The Configuration File Commit utility may perform the following exemplary tasks:\n\n","In this embodiment, if there are validation errors when the administrator uses the commit utility, the utility can report those errors to the administrator, and sends them to the Audit subsystem to be logged.","Configuration Files","In this embodiment, CAB configuration files may be text-based XML files. Schemas may define the elements, configuration types and attributes. The Configuration File subcomponent may not trust the schema definition included in the XML file because the definition could easily be removed or substituted with an inappropriate schema. Instead, the validation routines may be preconfigured to read specific XML schemas.","In this embodiment, an exemplary configuration file directory may be laid out as follows:",{"@attributes":{"id":"p-0708","num":"0932"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Configuration Files - Directory Structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Directory","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["\/etc\/cab","Contain all CAB configuration files."]},{"entry":["\/etc\/cab\/config_admin","Staging area for configuration files edited by administrators."]},{"entry":[{},"All files have types accessible only to the administrative roles"]},{"entry":[{},"(e.g., Policy Administrator or User Administrator) charged"]},{"entry":[{},"with their maintenance. This directory is readable only the"]},{"entry":[{},"administrator and Configuration File Commit Utility. The"]},{"entry":[{},"utility copies files from this directory to the config_runtime"]},{"entry":[{},"directory (described below)."]},{"entry":["\/etc\/cab\/config_runtime","Live configuration file area, The \u201cconfiguration commit\u201d"]},{"entry":[{},"procedure audits the changes made in the config_admin"]},{"entry":[{},"directory after an edit, and copies the files contained in"]},{"entry":[{},"config_admin to config_runtime."]},{"entry":["\/etc\/cab\/config_history","Contains history of all configuration files, with each file name"]},{"entry":[{},"having a timestamp that shows when it was moved."]},{"entry":["\/etc\/cab\/config_transaction","Contains transaction rollback logs for pending transactions. If"]},{"entry":[{},"any files are present during system initialization, then a"]},{"entry":[{},"transaction was not completed. Administrative action is"]},{"entry":[{},"necessary."]},{"entry":["\/etc\/cab\/data","This file contains all binary data files, such as encrypted"]},{"entry":[{},"passwords, data dictionaries, and images for future"]},{"entry":[{},"administrator GUI."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, exemplary initial definitions are described in the following subsections:","cab_guard_system.xml","In this embodiment, the Guard system-level configuration file contains global static boundary variables for the Guard processes and threads. This file defines the process defaults used during initialization.","cab_guard_policy.xml","In this embodiment, the Guard policy configuration file contains all data relating to policy and security decisions configured by the Policy Administrator.","cab_guard_hs_roles.xml","In this embodiment, the Guard Roles configuration file defines the roles for the client users. There are several types of roles that need to be defined include no-access, basic user, and priority user.","cab-guard_hs_users.xml","In this embodiment, the Guard user file contains the client user database.","cab_guard_hs_user_password.xml","In this embodiment, the Guard user password file contains the Client user passwords.","cab_guard_hs_ls_user_map.xml","In this embodiment, the Guard High\/Low Mapper configuration file contains the mapping between the high-side user identity and the low-side user identity.","cab_guard_ls_users.xml","In this embodiment, the Guard low-side user configuration file contains the details of low-side user accounts.","cab_guard_user_prefs.xml","In this embodiment, the Guard user preferences configuration file defines all user preferences that have been determined based on the client system setup, and allowed guard session capabilities.","cab_guard_capabilities.xml","In this embodiment, the Guard capabilities configuration file contains all available and allowable session capabilities with regard to browse and collaboration data moving through the system via the VDP protocol. It allows the Administrator to limit the session settings that can be provided to a high-side user.","cab_guard_dirty_word.xml","In this embodiment, the dirty word configuration file contains all the dirty words checked during text input from the user. It also contains Dirty Word Search Filter tuning parameters.","cab_guard_clean_word.xml","In this embodiment, the clean word configuration file contains all clean words checked during text input from the user.","cab_guard_audit.xml","In this embodiment, the audit configuration file contains all configurable data related to the Audit Component and associated processes.","cab_guard_keyboard_filter.xml","In this embodiment, the keyboard filter configurable data related to the Guard Keyboard Filter, which is the keyboard inspection process.","cab_guard_init.xml","In this embodiment, the initialization configuration file contains all configurable data needed to initialize the system.","cab_translator_system.xml","In this embodiment, the translator system-level configuration file, defines global static variables for the Translator processes and threads. The file is used to tune the Translator.","cab_translator_policy.xml","In this embodiment, the policy configuration file contains all data relating to policy and security decisions configured by the Translator Admin.","cab_translator_audit.xml","In this embodiment, the audit configuration file contains all configurable data related to the Audit subsystem.","cab_translator_init.xml","In this embodiment, this initialization configuration file contains all configurable data need for system initialization.","Configuration File API","In this embodiment, to support code reuse and development efficiency, Configuration may include a configuration file access library. It can provide a common access mechanism for all configuration parameters, and adds a layer of abstraction supporting future enhancements to the interface. Depending upon licensing and security concerns, the Gnome libxml2 library could be extended for CAB purposes.","User Interface","In this embodiment, the user interfaces for the administration and performance reporting functions may be simple command line executables. For configuration files and performance data stores, the Administrator can use standard Linux utilities such as vi, cat, and more. The administrative functions of CAB interact with a large number of system subcomponents and data sources. To allow for least privilege enforcement, the administrative functions and any data they interact with can be modularized and isolated into their own security domains.","In this embodiment, the Administration and Performance Component may have tight integration with the configuration file subsystem and interacts with the Initialization and Audit subsystems. It can sit at a layer above the configuration file and relies on schema validation to ensure valid data types and values. The Performance Monitor receives performance data from the Audit Event Manager, along with other locations described previously. If it determines that performance data exceed policy-driven thresholds, it can generate an Audit event which can be used to cause a policy-driven response. In most cases, system policy would probably indicate that shutdown is necessary. The table below illustrates examples of a high level analysis of the interfaces:",{"@attributes":{"id":"p-0751","num":"0975"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Administration and Configuration Functions - Interfaces"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Subcomponent","Interface Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["System","System utilities, such as vi, require write access to CAB configuration"]},{"entry":["Utilities (write)","files. To support the use of multiple process domains, these utilities may"]},{"entry":[{},"be placed in one of several wrappers that provide access only to a subset"]},{"entry":[{},"of configuration files."]},{"entry":["System","System utilities, such as cat and more, require read access to CAB"]},{"entry":["Utilities (read)","configuration and log files. To support the use of multiple process"]},{"entry":[{},"domains, these utilities may be placed in one of several wrappers that"]},{"entry":[{},"provide access only to a subset of configuration files."]},{"entry":["Configuration","Several administrative functions-specifically any function committing"]},{"entry":["File Validation","changes to configuration data-depends on this library. This library"]},{"entry":["Library","provides read and write interfaces to a variety of configuration files;"]},{"entry":[{},"access to those files is enforced by the SELinux Security Policy."]},{"entry":["Audit","Administrative functions and utilities send audit messages directly to the"]},{"entry":["Subsystem","Audit Subsystem, using the common Wire Protocol. The messages"]},{"entry":[{},"include \u201cbegin configuration transaction,\u201d \u201cconfiguration change error,\u201d"]},{"entry":[{},"and \u201cconfiguration change successful.\u201d This is one-way communication."]},{"entry":["Initialization","The Configuration File subcomponent creates transaction rollback log"]},{"entry":["Subcomponent","files in a well-known location. Once files have been committed, they are"]},{"entry":[{},"removed. If any files are present at system startup, the system halts so that"]},{"entry":[{},"an administrator can correct the problem."]},{"entry":["Shutdown","The Configuration File subcomponent sends events to the Audit"]},{"entry":["Subcomponent","Subsystem. The Audit Subsystem, in turn sends event to the Shutdown"]},{"entry":[{},"subcomponent, indicating that processes need to reread their configuration"]},{"entry":[{},"file. In exceptional cases, such as configuration file disk write failures, a"]},{"entry":[{},"fatal event could trigger system shutdown."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In one embodiment, the performance functions of CAB read from a large number of data sources throughout the system, and writes to a private data store. The data store may be text-based, in comma-separated-value format, so that it can be downloaded from the machine and analyzed using third-party programs. Examples are provided in the following table:",{"@attributes":{"id":"p-0753","num":"0977"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Performance Reporting Functions - Interfaces"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Subcomponent","Interface Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Audit","Performance reporting functions receive CAB performance-related and"]},{"entry":["(receiving","session-related data, in the form of messages from the Event Manager"]},{"entry":["performance","subcomponent of the Audit subsystem, via the common Wire Protocol."]},{"entry":["messages)","This is the only path for CAB processes to send performance data to the"]},{"entry":[{},"Performance Monitor. This is one-way communication."]},{"entry":["OS Data","Performance reporting functions read data from system-wide sources and"]},{"entry":["Sources","commands, such as top, ipconfig, and\/proc. Data is read from these"]},{"entry":[{},"sources, and not written, however, execute access is required for the"]},{"entry":[{},"command executables."]},{"entry":["Performance","Performance reporting functions requires a writable\/appendable private"]},{"entry":["Data Store","data store to store historical and consolidated data."]},{"entry":["Initialization","The Initialization Process launches the performance data gathering"]},{"entry":["Process","element(s) to support the performance reporting functions, using an \u2018exec\u2019"]},{"entry":[{},"call. No communications are established between these elements and the"]},{"entry":[{},"Initialization Process."]},{"entry":["Configuration","The performance gathering and reporting elements may read"]},{"entry":[{},"configuration information from the Administration and Configuration"]},{"entry":[{},"subcomponent, using the interfaces provided by the Administration and"]},{"entry":[{},"Configuration subcomponent. This is one-way communication."]},{"entry":["Heartbeat","Upon execution, the Performance Monitor subcomponent uses the"]},{"entry":["Monitor","common Wire Protocol to provide regular heartbeat messages to the"]},{"entry":[{},"heartbeat monitor. This is one-way communication."]},{"entry":["Shutdown","Upon execution, this subcomponent registers with the Shutdown Process,"]},{"entry":["Process","using the common Wire Protocol. Once registered, the heartbeat monitor"]},{"entry":[{},"listens for shutdown commands from the shutdown process. This is one-"]},{"entry":[{},"way communication."]},{"entry":["Audit (sending","Performance data gathering and reporting elements send audit messages"]},{"entry":["audit messages)","directly to the Audit Subsystem, using the common Wire Protocol. This is"]},{"entry":[{},"one-way communication."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Translator Component","In one embodiment, the main functionality of the CAB Browse Translator is to convert commercial thin-client protocols into the CAB-developed Virtual Desktop Protocol (VDP). VDP is preferred over existing commercial protocols because of its non-proprietary nature, which allows for more complete feature control, easier inspection, thorough feature reduction and mitigation of security risks posed by some commercial features.","In this embodiment, within the CAB system, the Translator preferably only performs conversion between protocols; it preferably does not perform the actual cross-domain functionality. That functionality may be done by the Guard.","In this embodiment, essentially, the Translator converts and relays images, mouse events, keyboard events, and\u2014in one embodiment\u2014audio data between the Guard and the commercial Terminal Server. By reducing the native COTS protocol to VDP, the risks posed by elements such as mobile code, file share access, and viruses can be mitigated. A high-level functional view of the Translator is shown in .",{"@attributes":{"id":"p-0758","num":"0982"},"figref":"FIG. 24","ul":{"@attributes":{"id":"ul0081","list-style":"none"},"li":{"@attributes":{"id":"ul0081-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0082","list-style":"none"},"li":["System Initialization (with some modifications as discussed below)","Operating System (SELinux)","SELinux Security Policy (with some modifications as discussed below)","Heartbeat Monitor","Performance Monitor","Shutdown Monitor (with some modifications as discussed below)","Wire Protocol\/IPC Mechanisms","Audit Subcomponent","Administration and Configuration."]}}}},"In this embodiment, in addition to those subcomponents shared with the Guard, the following subcomponents may be unique to the Translator:\n\n","The sections below will present these subcomponents in detail, and will further discuss design considerations and other minor differences between the Translator and the Guard.","General Design Decisions and Considerations","Terminal Server Support","In this embodiment, a design consideration for the Translator component is which brand(s) of terminal server products would be supported. A terminal server, a hardware platform running commercial off-the-shelf (COTS) software, provides the remote thin-client services on the low-side network, and hosts the low-side desktops to be accessed from the high-side client. Each manufacturer of terminal server products may use different thin-client protocols. Support for many of the different types of terminal server implementations is possible with the architecture.","For example, one embodiment of CAB interfaces with Microsoft's Windows Terminal Server, using the RDP protocol. Another embodiment of CAB interfaces with Citrix Corporation's MetaFrame Server, using the ICA protocol. These and similar protocols may be referred to generally as remote protocols.","Other embodiments can support additional types of terminal servers because the CAB architecture\u2014through the use of its Translator component\u2014is capable of supporting a large number of terminal server technologies.","(U) NOTE: The term \u201cTerminal Server\u201d has multiple meanings within this document. For clarification, the following notations are used\n\n","Operating System and Platform-Related Considerations","In one embodiment, the Translator can use the same hardened operating system and core system services as in the Guard. These core services can be engineered for use for both the Guard and Translator to satisfy a common set of requirements. Utilizing the same base operating system and core services that the Guard uses allows the Translator to:\n\n","Performance","In one embodiment, the Translator component can be architected primarily for performance. All traffic that is sent through the Translator preferably needs to enter and exit as fast as possible to ensure that the end-users' experience is not affected by the translation process.","In this embodiment, for this reason, Translator subcomponents can be designed to be thread-safe with minimal contention for the reasons described previously.","Subcomponents","In this embodiment, as stated above, the Translator can use the same SELinux build and many of the system services used in the Guard. Additionally, the Translator can employ unique Listener and VDP2RDP subcomponents to perform its specialized tasks.  shows services that can be utilized by the Translator.","Listener Process","In this embodiment, the Listener Process can be responsible for managing incoming\/outgoing connections to\/from the Guard. This includes the setup of the incoming TLS sessions and the actual TCP connection managed through the socket API. Upon receiving valid VDP connections, the translator process can be responsible for spawning a new translator process and passing the connection to that process for translation.","In this embodiment, the Listener process may comprise two primary threads, and a thread pool:\n\n","In one embodiment, the Main thread is responsible for the process initialization steps as well as managing the incoming TLS\/TCP connections from the Guard. The main thread may rely on, for example, the Berkley Socket API provided by the operating system to accept incoming connections. Once a connection is established, it can be handed off to a new thread from the bootstrap thread pool to begin the setup process. This newly spawned thread may be responsible for executing a new VDP translator process and handing off information that the new process needs to begin translating.","In this embodiment, the Main thread may also responsible for creating and managing a write-only channel with the audit subsystem. This channel can provide a process-wide logging capability. Since all threads in the system preferably need access to the audit subsystem, synchronization mechanisms are preferably present to ensure that all threads can efficiently log events without deadlock or starvation.","In this embodiment, the Heartbeat thread may be initiated by the Main thread at startup. Its function is to periodically receive a simple message from the Main thread that it is still working properly. The Main thread can establish a write-only IPC channel with the Heartbeat thread. The heartbeat interval may be received at startup from the configuration items read-in.","In this embodiment, when the Main thread has completed its startup operations, it transitions to the role of the Shutdown thread. The purpose of the Shutdown thread is to wait for control and shutdown events from the shutdown process. This thread will establish a read-only IPC channel with the shutdown process and wait for events. When this thread does receive an event to shut down it must gracefully start the termination of all running threads, clean up any state, and if necessary, notify the shutdown thread prior to closing.","In one embodiment, in addition to managing the incoming network connection, the Listener can also ensure that it has channels open with:\n\n","In this embodiment, at start up, the Listener process can read configuration items for itself or the individual VDP translators to be invoked for session handling. These configuration items can be read once from persisted storage and stored in memory for later look up and hand off to the VDP translator processes.","Subcomponent Details","In one embodiment, upon being executed by the Init process, the Listener process begins by using the configuration subcomponent to read in each of the configuration items related to the Listener and any COTS protocol translators that are later executed (e.g., VDP2RDP, VDP21CA).","In this embodiment, exemplary configuration items include:\n\n","In one embodiment, the Listener continues by establishing a communication link with the audit subcomponent to preferably ensure that future events can be properly logged to the audit subcomponent.","In one embodiment, the Listener continues by first connecting to the shutdown process and then the heartbeat process using an IPC channel defined by each process. If both connections were successful, the Listener spawns a new thread to handle the heartbeat communications. The Listener then spawns a second thread to handle TLS\/TCP listening operations. The Main thread then continues by waiting on the previously established channel with shutdown for shutdown events. The Heartbeat thread can be given a higher priority than the other threads in order to ensure that the Heartbeat thread is always responsive.","In one embodiment, the Listener thread begins by:\n\n","In one embodiment, when a new connection is accepted, the Listener thread retrieves a new thread from the local bootstrap thread pool and assigns it to the new connection. The Listener thread may be responsible for ensuring that the binding between this new thread and the connection are recorded for any future maintenance operations.","In one embodiment, once the new connection thread has been established, its first step is to wait for the first packet on the new connection and peek at it to determine which type of translator is required by the connection. Next, the thread will execute that the required VDP Translator (either RDP or ICA) process, setup an IPC new channel for communicating with this new process, and attempt to connect to the newly created translator process using IPC. When connecting to the translator process, the connection thread should use the filename specified in the configuration file for the translator type to which they are connecting, concatenated with the PID (process identifier) of the executed translator process. The executed process should take as its first parameter, the path and filename to use for this IPC channel.","In this embodiment, assuming the IPC channel between the connection thread and the executed translator was successful, the connection thread should send the translator the connection socket descriptor and any state needed to use that connection from within the VDP API connection component.","In this embodiment, following this, the connection thread preferably sends the configuration items specific to the translator process as defined by the previously read configuration state. Once completed, the connection thread should wait for a shutdown notification from the connected process. If the connected process fails before it can establish a connection with the audit subsystem, the process notifies the Connection thread via this IPC channel. If a failure response is returned, the connection thread should log the event and continue with the normal thread shutdown process. Shutting down the connection thread releases allocated resources, resets the managed state and adds itself back into the thread pool. The Listener thread and Listener process may have no knowledge of the previously executed translator process","In this embodiment, the Listening thread continues accepting connections until it is signaled by the main thread that shutdown should be initiated. Once shutdown is initiated, the Listener process should wait until the Listener thread and Heartbeat thread have terminated before gracefully closing.","Interfaces","In this embodiment, within the Translator component, the Listener Process may interface with several other subcomponents. The table below provides examples of these interfaces:",{"@attributes":{"id":"p-0796","num":"1060"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listener Process - Internal Translator Interfaces"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Subcomponent","Interface Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["High-side TCP Stack","The Listener process communicates with the High-side TCP stack"]},{"entry":[{},"for all incoming network operations from the Guard."]},{"entry":["VDP2RDP Process","The Listener Process launches each VDP2RDP Process, using an"]},{"entry":[{},"\u2018exec\u2019 call. An individual VDP2RDP Process is launched to"]},{"entry":[{},"support each active user session. The Listener Process then uses"]},{"entry":[{},"the shared Wire Protocol to pass configuration information to"]},{"entry":[{},"VDP2RDP. The following configuration information is passed:"]},{"entry":[{},"SocketDescriptor (for the individual session's incoming VDP"]},{"entry":[{},"connection), AllowedEncryption (to identify permitted encryption"]},{"entry":[{},"types when connecting to the RDP server), Keys (as required to"]},{"entry":[{},"perform TLS functions)."]},{"entry":["Initialization","The Initialization Process launches this subcomponent, using an"]},{"entry":[{},"\u2018exec\u2019 call. No communications are established between this"]},{"entry":[{},"subcomponent and the Initialization Process."]},{"entry":["Configuration","This subcomponent reads configuration information from the"]},{"entry":[{},"Administration and Configuration subcomponent, using the"]},{"entry":[{},"interfaces provided by the Administration and Configuration"]},{"entry":[{},"subcomponent. This is one-way communication."]},{"entry":["Encryption\/Decryption","Listener Process interacts with this subcomponent to perform TLS"]},{"entry":[{},"functions, using the interfaces provided by the subcomponent."]},{"entry":["Heartbeat Monitor","Upon execution, this subcomponent utilizes the common Wire"]},{"entry":[{},"Protocol to provide regular heartbeat messages to the heartbeat"]},{"entry":[{},"monitor. This is one-way communication."]},{"entry":["Shutdown Process","Upon execution, this subcomponent registers with the Shutdown"]},{"entry":[{},"Process, using the common Wire Protocol. Once registered, the"]},{"entry":[{},"heartbeat monitor listens for shutdown commands from the"]},{"entry":[{},"shutdown process. This is one-way communication."]},{"entry":["Audit","This subcomponent sends audit messages directly to the Audit"]},{"entry":[{},"subcomponent, using the common Wire Protocol. This is one-way"]},{"entry":[{},"communication."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"VDP2RDP Process","In this embodiment, another major process that is unique to the Translator is the VDP2RDP process. The VDP2RDP process may be responsible for handling the packet translation between the VDP and RDP protocols. In one embodiment, the translator system may be set up so that one VDP2RDP process is executed to handle one and only one user session.","In this embodiment, the VDP2RDP can manage the packet flow using two socket-based TCP connections: one with the Guard from the high-side interface and one with the Terminal Server from the low-side interface.","In this embodiment, the VDP2RDP process comprises four threads that are preferably always running:\n\n","In this embodiment, the architecture of the VDP2RDP process is shown as an example in .","In one embodiment, the Main thread is responsible for performing the startup operations as well as receiving shutdown operations once normal operations have commenced. Operations of the main thread may include:\n\n","In this embodiment, the Heartbeat thread may be started by the main thread to provide a periodic heartbeat with the heartbeat process. This thread can establish a write-only IPC channel with the Heartbeat thread and periodically send a simple message to the heartbeat process to notify the Heartbeat process that it is still working properly. The heartbeat thread should get the heartbeat interval from the configuration items sent to the VDP2RDP thread at startup.","In this embodiment, the Upstream thread may be responsible for handling RDP packets that are received from the low-side socket connection to the Terminal Server, translating them to VDP, and sending them out the high-side socket connection to the Guard.","In this embodiment, the Downstream thread may be responsible for handling VDP packets that are received from the high-side socket connection to the Guard, translating them to RDP, and sending them out the low-side socket connection to the Terminal Server.","In this embodiment, the VDP2RDP process preferably maintains connections with the following using IPC:\n\n","In one embodiment, at start up, the VDP2RDP process is preferably expected to set up an IPC channel with the executing thread in the Listener process using a command-line parameter identifying a file and the VDP2RDP processes PID. Once this channel is established, the process should wait for the configuration items needed by the process to run, and the socket descriptor for the incoming connection. Once the VDP2RDP process has everything it needs, it should begin the startup process and only close the channel with the Listener process once the audit subsystem connection has been successfully established.","Startup","In one embodiment, the VDP2RDP process is executed by the Listener process when a new high-side connection with the Guard is established for handling a new VDP user session. An exemplary first step in this process is to create a new IPC channel using the filename passed to it at runtime and its PID. Once the IPC channel has been created, the VDP2RDP may wait for the following items:\n\n","In one embodiment, once the VDP2RDP process has received all of the items it needs to run from the Listener process, it will attempt to connect to the audit subsystem using IPC. If the connection with the audit subsystem is successful, the VDP2RDP process can release the IPC channel created between itself and the Listener process because any future fatal startup options can be sent through the audit subsystem.","In this embodiment, the VDP2RDP process can continue by connecting to both the shutdown process and the heartbeat process using IPC. If both are successful, the VDP2RDP process will spawn a heartbeat thread to periodically notify the system that it still exists. Once this is complete the VDP2RDP process enters the connecting phase of its startup.","In this embodiment, the VDP2RDP process continues by attempting to make a socket connection to the Terminal Server and initiating the low-side login process. If this connection fails the VDP2RDP process will notify the connected Guard using VDP and start the shutdown process. If successful, the VDP2RDP process will spawn two threads, one for upstream traffic (Low to High) and another for downstream traffic (High to Low). Once both traffic threads have started, the VDP2RDP process has entered the running phase and normal operations begin.","In this embodiment, once in a running state, the main thread becomes the shutdown thread by waiting for shutdown events from the shutdown process. This way, when shutdown events do occur, it will be easier for the process to shut down the remaining three threads.","Subcomponent Elements","In one embodiment, the following elements may be utilized by the VDP2RDP process.\n\n","High-Side Network Interface","In one embodiment, the high-side network interface manages incoming network traffic from the Guard. This interface can employ a firewall so that only allowed ports and connecting IPs are used. Incoming connections are preferably required to authenticate and connect via TLS before any traffic can be received. VDP traffic can be received and sent over the previously established TLS connection with the Guard.","Low-side Network Interface","In one embodiment, the load side network interface is responsible for managing network traffic between the translator and the Terminal Server.","In this embodiment, the low-side interface can optionally support an SSL\/TLS crypto board if the Terminal Server supports or forces that all traffic be sent through a secure port. The option is completely up to the site administrator and can be configured by the guard. When the Terminal Server does require an SSL\/TLS, the same constraints apply to the set up of that connection. If SSL\/TLS is supported, prior to any VDP traffic being accepted or processed, the secure link is preferably established.","The low-side network interface may control traffic directly connected to the Terminal Server and therefore must understand the Remote Desktop Protocol (RDP). In one embodiment, the RDP may comprise four basic network layers:\n\n","RDP Translation Details","Information Sources","In this embodiment, there are two primary sources for public RDP knowledge upon which the translation assumptions have been based.","In this embodiment, the first source of information includes a collection of internationally recognized and standardized protocols. These protocols provide insight into the overhead, technology, and features involved with and provided by the Remote Desktop Protocol.","In this embodiment, the second information source available is an open source RDP client implementation called rdesktop. The rdesktop client provides an in-depth look into how the protocol works, how the packets are laid out, and the minimum protocol support needed to achieve basic functionality.","Protocol Specifics","In one embodiment, the Remote Desktop Protocol may be based on four documented standards:\n\n","As a result, one embodiment of the RDP protocol may be broken down into four distinct protocol layers that are derived directly from these standards:\n\n","Translation","In this embodiment, there may be two aspects of the RDP translation that preferably should be considered when implementing a VDP2RDP translator:\n\n","In this embodiment, a third aspect of translation involves the dropping of RDP packets that cannot, or should not, be processed or passed to the VDP side.","Control","In this embodiment, control packets provide a mechanism for controlling how the user session runs and operates from the client perspective. There may be essentially thee types of RDP control packets that VDP is interested in for the purpose of translation:\n\n","In this embodiment, configuration items the translator needs for login and capability negotiation can either be read in from local persistent configuration files or from the VDP connection request packet sent to the Translator from the Guard. The table below outlines examples of what configuration items the Guard will provide to the translator via the connection request message and which TLV type they are associated to.",{"@attributes":{"id":"p-0836","num":"1153"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Available VDP Configuration Items"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["TLV","Configuration Item"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Display Settings","Resolution (Width and Height)"]},{"entry":[{},"Color Depth (8, 15, 16, or 24 bit)"]},{"entry":["Language Settings","Key Layout"]},{"entry":["Login","Terminal Server Username"]},{"entry":[{},"Terminal Server Password"]},{"entry":["Remote Host","Terminal Server IP Address and Port"]},{"entry":[{},"Which translator to use (RDP\/ICA)"]},{"entry":["Cache Size","Cache Configuration:"]},{"entry":[{},"Bitmap Cache"]},{"entry":[{},"Font Cache"]},{"entry":[{},"Cursor Cache"]},{"entry":[{},"Palette Cache"]},{"entry":["Output Capabilities","Supported Drawing Operations"]},{"entry":["System Capabilities","Supported Clipboard Features"]},{"entry":[{},"Supported File Transfer Features"]},{"entry":[{},"Supported Audio Features"]},{"entry":[{},"Supported Video Features"]},{"entry":[{},"User pre-emption supported"]},{"entry":[{},"Timeout settings (idle, suspend, cache)"]},{"entry":[{},"User priority"]},{"entry":[{},"Availability of session performance"]},{"entry":["Security Settings","Low-side security setting (Translator \u21c4Terminal"]},{"entry":[{},"Server)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"RDP disconnect packet. In one embodiment, this packet may be sent either by the RDP client or server to notify it that they are terminating the session. The RDP disconnect packet provides a reason code that can be used by the translator to determine which VDP packet to send, either a Session Shutdown or Session Timeout message.","Direct Translation","In this embodiment, direct translation of RDP packets may be needed for user input coming from the client and visual output sent from the Terminal Server. The tables below outline example of the types of packets to be translated from VDP and RDP.",{"@attributes":{"id":"p-0840","num":"1157"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"VDP to RDP Packet Translation"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["VDP","RDP"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Packet","Type","Description","Packet(s)","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Keyboard","0x040001","User presses a","Keyboard Event","Standard keyboard press any"]},{"entry":["Press",{},"keyboard key","(Down)","release event. Includes either a"]},{"entry":["Keyboard","0x040002","User releases a","Keyboard Event","scancode or virtual key code for the"]},{"entry":["Release",{},"keyboard key","(Up)","key pressed."]},{"entry":["Key string","0x040003","User enters a","Multiple","Translated into multiple sequential"]},{"entry":[{},{},"captured string","Keyboard Events","RDP key events packaged into the"]},{"entry":[{},{},{},"(Down and Up)","same packet. One press and release"]},{"entry":[{},{},{},{},"event is needed for every character"]},{"entry":[{},{},{},{},"included in the string."]},{"entry":["Mouse Press","0x040004","User clicks a","Mouse Event","Standard mouse click and release"]},{"entry":[{},{},"mouse button","(Down)","event. Includes a flag for the button"]},{"entry":["Mouse","0x040005","User releases a","Mouse Event","pressed (1, 2, or 3) and the location"]},{"entry":["Release",{},"mouse button",{},"of the cursor."]},{"entry":["Mouse","0x040006","User moves the","Mouse Event","Standard mouse movement event."]},{"entry":["Move",{},"mouse","(Move)","Includes the new cursor location."]},{"entry":["Mouse","0x040007","User moves the","Mouse Event","RDP assigns the flags for button 4"]},{"entry":["Scroll Up",{},"mouse scroll","(Button4)","and 5 to the scroll up and down"]},{"entry":[{},{},"wheel up",{},"events. Thus, to scroll a standard"]},{"entry":["Mouse","0x040008","User moves the","Mouse Event","mouse down event needs to be sent"]},{"entry":["Scroll Down",{},"mouse scroll","(Button5)","using the flags for buttons 4 or 5,"]},{"entry":[{},{},"wheel down",{},"depending on the action (up or"]},{"entry":[{},{},{},{},"down)"]},{"entry":["Mouse","0x040009","User completed","Mouse Events","Client initiated single-click requires"]},{"entry":["Single-Click",{},"a single mouse","(Down and Up)","a mouse down and release event"]},{"entry":[{},{},"click",{},"separated by at least 150 ms. This"]},{"entry":[{},{},{},{},"is so the message is only"]},{"entry":[{},{},{},{},"interpreted as a single click"]},{"entry":["Mouse","0x04000A","User completed","Mouse Events","Requires two sets of mouse down"]},{"entry":["Double-",{},"a double","(Two quick","and release packaged together in"]},{"entry":["Click",{},"mouse click","Down and Up)","one packet so the Terminal Server"]},{"entry":[{},{},{},{},"will detect their closeness as a"]},{"entry":[{},{},{},{},"double-click"]},{"entry":["Mouse","0x04000B","User completed","Mouse Events","Requires three sets of mouse down"]},{"entry":[{},{},"a triple mouse","(Three quick","and release packaged together in"]},{"entry":["Triple-Click",{},"click","Down and Up)","one packet so the Terminal Server"]},{"entry":[{},{},{},{},"will detect their closeness as a"]},{"entry":[{},{},{},{},"triple-click"]},{"entry":["Mouse Drag","0x04000C","User-initiated","Mouse Event","A drag motion is simulated by"]},{"entry":[{},{},"dragging","(Down)","sending a RDP mouse down event"]},{"entry":["Mouse Drop","0x04000D","User completed","Mouse Event (Up)","and sending mouse move events"]},{"entry":[{},{},"a drop",{},"before the mouse release is sent."]},{"entry":[{},{},{},{},"The VDP Mouse drag only sends"]},{"entry":[{},{},{},{},"the RDP mouse down event. A"]},{"entry":[{},{},{},{},"subsequent VDP Mouse Drop"]},{"entry":[{},{},{},{},"event results in the mouse release"]},{"entry":[{},{},{},{},"for the previous down, potentially"]},{"entry":[{},{},{},{},"at a different mouse location."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"RDP to VDP examples:",{"@attributes":{"id":"p-0842","num":"1159"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"RDP to VDP Packet Translation"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["RDP","VDP"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Packet","Description","Packet(s)","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Disconnect","Sent by the client","Session","0x020001","Sent for Terminal Server initiated"]},{"entry":[{},"or server to close","Shutdown",{},"shutdowns while the session is"]},{"entry":[{},"a session",{},{},"running"]},{"entry":[{},{},"Session","0x020002","Sent when the Terminal Server"]},{"entry":[{},{},"Disconnect",{},"initiates a Disconnect because of a"]},{"entry":[{},{},{},{},"remote idle timeout"]},{"entry":[{},{},"Connection","0x030003","If the disconnect is sent as the"]},{"entry":[{},{},"Response",{},"result of a Terminal Server login"]},{"entry":[{},{},{},{},"request the error message is"]},{"entry":[{},{},{},{},"denoted in the connection"]},{"entry":[{},{},{},{},"response to the Guard"]},{"entry":["Palette","Sent to update the","Palette","0x050001","Close to a one-to-one mapping"]},{"entry":["Update","active palette for","Update",{},"between the two protocols. VDP"]},{"entry":[{},"future bitmap",{},{},"reduces a little bit of overhead."]},{"entry":[{},"updates"]},{"entry":["Bitmap","Sent to paint a","CIF Paint","0x050003","Depending upon the compression"]},{"entry":["Update","bitmap to the",{},{},"algorithm allowed by the Guard,"]},{"entry":[{},"screen",{},{},"the image must be decompressed,"]},{"entry":[{},"compressed or",{},{},"potentially re-compressed using a"]},{"entry":[{},"otherwise",{},{},"Guard sponsored algorithm."]},{"entry":[{},{},{},{},"Otherwise the translation is close"]},{"entry":[{},{},{},{},"to one-to-one."]},{"entry":["System","Sent to reset the","Cursor","0x050002","Cursor related RDP messages are"]},{"entry":["Pointer","state of the","Update",{},"all sent as a VDP cursor update"]},{"entry":[{},"current cursor",{},{},"image. The VDP update message"]},{"entry":[{},"pointer",{},{},"is for a monochrome (1 bit\/pixel"]},{"entry":["Color","Sent to update the",{},{},"color) which requires the"]},{"entry":["Pointer","current cursor",{},{},"translator to down sample the"]},{"entry":[{},"with a new cursor",{},{},"color pointers."]},{"entry":["Cache","Sent to cache a","Cursor","0x060001","The cursor sent as the same format"]},{"entry":["Pointer","cursor image in","Cache",{},"as the VDP cursor update packet"]},{"entry":[{},"the cursor cache",{},{},"with the addition of an index."]},{"entry":[{},{},{},{},"Neglecting the down-sampling"]},{"entry":[{},{},{},{},"needed to drop the color this"]},{"entry":[{},{},{},{},"packet is close to one-to-one with"]},{"entry":[{},{},{},{},"eth RDP packet."]},{"entry":["Raw Bitmap","Uncompressed","Bitmap","0x060003","VDP Bitmap Cache packet is very"]},{"entry":["Cache","bitmap sent","Cache",{},"close to its RDP counterpart,"]},{"entry":["Raw Bitmap","specifically to be",{},{},"minus a little overhead. Only"]},{"entry":["Cache v2","cached",{},{},"difference is the VDP version can"]},{"entry":["Bitmap","Compressed",{},{},"handle both compressed and"]},{"entry":["Cache","bitmap sent",{},{},"decompressed images."]},{"entry":["Bitmap","specifically to be",{},{},"Compressed images may need to"]},{"entry":["Cache 2","cached",{},{},"be decompressed and potentially"]},{"entry":[{},{},{},{},"re-compressed according to the"]},{"entry":[{},{},{},{},"algorithms allowed by the Guard."]},{"entry":["Font Cache","Sent to cache","Font Cache","0x060004","The VDP Font cache packet is"]},{"entry":[{},"multiple glyphs",{},{},"very similar to its RDP"]},{"entry":[{},"for a given font",{},{},"counterpart minus a little"]},{"entry":[{},{},{},{},"overhead. This translation may"]},{"entry":[{},{},{},{},"require the glyph pixel maps be"]},{"entry":[{},{},{},{},"adjusted slightly to fit the format"]},{"entry":[{},{},{},{},"defined by VDP"]},{"entry":["DestBlt","Destination","Clear","0x050004","Translates to the VDP Clear"]},{"entry":["Order","Block transfer",{},{},"packet which is used for general"]},{"entry":[{},"sent to clear and",{},{},"clearing operations of a"]},{"entry":[{},"area of the screen",{},{},"rectangular region of the screen"]},{"entry":["Rect Order","Sent to clear an",{},{},"using a sent color. Also used to"]},{"entry":[{},"area of the screen",{},{},"invert the region."]},{"entry":[{},"with a specified"]},{"entry":[{},"color"]},{"entry":["PatBlt","Sent to clear and","Pattern","0x050005","The VDP Pattern clear packet is"]},{"entry":["Order","area of the screen","Clear",{},"very similar to the RDP PatBlt"]},{"entry":[{},"with a specified",{},{},"packet. The VDP version is"]},{"entry":[{},"bruch",{},{},"slimmer but the translation is close"]},{"entry":[{},{},{},{},"to on-to-one"]},{"entry":["ScreenBlt","Sent to copy one","Screen","0x050006","The VDP Screen Copy packet is"]},{"entry":["Order","portion of the","Copy",{},"very similar to the RDP ScreenBlt"]},{"entry":[{},"screen to another",{},{},"packet. The VDP version is"]},{"entry":[{},{},{},{},"slimmer but the translation is close"]},{"entry":[{},{},{},{},"to on-to-one"]},{"entry":["DeskSave","Sent to save a","Screen","0x060002","The VDP Screen Cache packet is"]},{"entry":["Order","portion of the","Cache",{},"slightly different from the"]},{"entry":[{},"screen to a client",{},{},"DeskSave RDP packet in that its"]},{"entry":[{},"bitmap cache",{},{},"based on indexes. The RDP"]},{"entry":[{},{},{},{},"desksave operation is saved based"]},{"entry":[{},{},{},{},"on an offset into the desktop"]},{"entry":[{},{},{},{},"image and therefore translation"]},{"entry":[{},{},{},{},"will need to be done to map the"]},{"entry":[{},{},{},{},"two. The RDP Desksave packet is"]},{"entry":[{},{},{},{},"primarily used for saving"]},{"entry":[{},{},{},{},"commonly viewed areas of the"]},{"entry":[{},{},{},{},"Desktop, whereas the Screen"]},{"entry":[{},{},{},{},"Cache can be used to cache any"]},{"entry":[{},{},{},{},"section of the screen for later"]},{"entry":[{},{},{},{},"display"]},{"entry":["MemBlt","Sent to copy a","Cache","0x050007","The VDP Cache Copy packet is"]},{"entry":["Order","cached bitmap to","Copy",{},"very similar to the RDP MemBlt"]},{"entry":[{},"the screen",{},{},"packet. The VDP version is"]},{"entry":[{},{},{},{},"slimmer but the translation is close"]},{"entry":[{},{},{},{},"to on-to-one"]},{"entry":["TriBlt Order","Sent to do a","Pattern","0x050005","The RDP TriBlt packet is"]},{"entry":[{},"combination of","Clear and","and","translated into multiple sets of"]},{"entry":[{},"MemBlt and","Cache","0x050007","Pattern Clear and Cache Copy"]},{"entry":[{},"PatBlt commands","Copy",{},"packets packaged together for"]},{"entry":[{},{},{},{},"transit."]},{"entry":["Line Order","Sent to draw a","CIF Paint","0x050003","These are unsupported operations"]},{"entry":[{},"line to the screen",{},{},"that must be transmitted as bitmap"]},{"entry":["Polyline","Sent to draw a","CIF Paint","0x050003","updates. If these operation can not"]},{"entry":["Order","poly-line to the",{},{},"be turned off at startup then the"]},{"entry":[{},"screen",{},{},"translator will maintain a Virtual"]},{"entry":[{},{},{},{},"Frame Buffer to draw the"]},{"entry":[{},{},{},{},"operations in. The translator"]},{"entry":[{},{},{},{},"would then sent a CIF Paint"]},{"entry":[{},{},{},{},"message that contains the update."]},{"entry":["Text Order","Sent to draw text","Cached","0x050009","The VDP Cache text Draw packet"]},{"entry":[{},"from a cached","Text Draw",{},"is very similar to the RDP Text"]},{"entry":[{},"font",{},{},"order packet. The VDP version is"]},{"entry":[{},{},{},{},"slimmer but the translation is close"]},{"entry":[{},{},{},{},"to on-to-one"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, depending upon the session configuration as managed by the Guard at session startup (using the Capabilities, Connection Request, and Response packets), some of these input events, drawing operations, or caching requests may be disabled.","In this embodiment, if an input event is sent when that input option is disabled, the packet preferably should be considered invalid, but it is up to the Guard to decided what action should be taken (drop packet or shutdown the session). Examples of this are:\n\n","In this embodiment, if a drawing command or caching request is disabled the translator may try to have the RDP session disable that feature so no translator processing needs to be done to handle the missing feature. If this is not possible, the translator may have to use a Virtual Frame Buffer (VFB) to locally draw the requested operation and send the resulting change in the users display to the client as a bitmap update. This applies to the drawing commands and capabilities that can be disabled on a per user or profile basis.","Interfaces","In this embodiment, within the Translator component, the VDP2RDP Process may interface with several other subcomponents, as shown by the examples in the table below:",{"@attributes":{"id":"p-0848","num":"1171"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"VDP2RDP - Internal Translator Interfaces"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Subcomponent","Interface Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Listener Process","The Listener Process launches each VDP2RDP Process, using an"]},{"entry":[{},"\u2018exec\u2019 call. An individual VDP2RDP Process is launched to"]},{"entry":[{},"support each active user session. The Listener Process then uses"]},{"entry":[{},"the shared Wire Protocol to pass configuration information to"]},{"entry":[{},"VDP2RDP. The following configuration information is passed:"]},{"entry":[{},"SocketDescriptor (for the individual session's incoming VDP"]},{"entry":[{},"connection), AllowedEncryption (to identify permitted encryption"]},{"entry":[{},"types when connecting to the RDP server), Keys (as required to"]},{"entry":[{},"perform TLS functions)."]},{"entry":["Encryption\/Decryption","VDP2RDP Process interacts with this subcomponent to perform"]},{"entry":[{},"TLS functions, using the interfaces provided by the subcomponent."]},{"entry":["Heartbeat Monitor","Upon execution, this subcomponent uses the common Wire"]},{"entry":[{},"Protocol to provide regular heartbeat messages to the heartbeat"]},{"entry":[{},"monitor. This is one-way communication."]},{"entry":["Shutdown Process","Upon execution, this subcomponent registers with the Shutdown"]},{"entry":[{},"Process, using the common Wire Protocol. Once registered, the"]},{"entry":[{},"heartbeat monitor listens for shutdown commands from the"]},{"entry":[{},"shutdown process. This is one-way communication."]},{"entry":["Audit","This subcomponent sends audit messages directly to the Audit"]},{"entry":[{},"subcomponent, using the common Wire Protocol. This is one-way"]},{"entry":[{},"communication."]},{"entry":["Low-side TCP stack","The VDP2RDP process communicates with the low-side terminal"]},{"entry":[{},"server using the low-side TCP stack. All network traffic goes"]},{"entry":[{},"through this interface and may require an additional SSL\/TLS"]},{"entry":[{},"tunnel, which would require use of the encryption\/decryption"]},{"entry":[{},"subcomponent."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"System Initialization","In one embodiment, the CAB Translator component reuses the Initialization subcomponent from the Guard, but is modified to support a different initialization sequence. In one embodiment, for the Translator, the CABInit process initializes in the following order:\n\n","In this embodiment, note that VDP2RDP processes may be launched by the Listener as each new connection is made.","In this embodiment, the sequence shown above does not include the standard processes initialized as part of the SELinux boot. The Network Boolean (within the Security Policy) may not be enabled until all of the processes have successfully initialized. In complying with the core services design, the running Translator subcomponents preferably maintain links with the\u2014\n\n","Shutdown Monitor","In one embodiment, the CAB Translator component reuses the Shutdown Monitor subcomponent from the Guard; however, it is modified to shut down a different set of processes. For the Translator, the Shutdown Monitor may shut down the following:\n\n","Heartbeat Monitor","In one embodiment, the CAB Translator component reuses the Heartbeat Monitor subcomponent from the Guard, modified to monitor a different set of processes. For the Translator, the Heartbeat Monitor monitors the following:\n\n","SELinux Security Policy","In this embodiment, though the Translator may share the same base operating system as the Guard, the Security Policy is preferably modified to allow for the differences in processes and functionality. The security domains within the Translator may include:\n\n","Operating System","In one embodiment, the CAB Translator component reuses the base operating system install from the Guard component. Very few deviations may occur. Most notably, the firewall configuration may differ for the translator.","In one embodiment, the firewall rules support Guard VDP traffic, Terminal Server protocol traffic, and trusted Network Time Protocol. Examples of these rules are shown in the following table:",{"@attributes":{"id":"p-0862","num":"1210"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Translator Firewall Rules"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Interface","Direction","Protocol","IP Addresses","Notes"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Guard-","Inbound TCP","VDP TLS","Individual Guard IP","Prescribed by site"]},{"entry":["side",{},{},"addresses or","deployment"]},{"entry":[{},{},{},"networks, as"]},{"entry":[{},{},{},"prescribed by site"]},{"entry":[{},{},{},"policy"]},{"entry":[{},"Inbound\/Outbound","Network","Single NTP server","Necessary for time"]},{"entry":[{},"UDP","Time",{},"synchronization;"]},{"entry":[{},{},"Protocol",{},"recommended"]},{"entry":[{},{},"(NTP)",{},"deployment on secure"]},{"entry":[{},{},{},{},"switched network"]},{"entry":["Terminal-","Outbound TCP","Proprietary","Individual Terminal"]},{"entry":["Server-",{},"Terminal","Server IP addresses"]},{"entry":["Side",{},"Server","or networks, as"]},{"entry":[{},{},"TLS\/SSL","prescribed by site"]},{"entry":[{},{},{},"policy"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"Terminal Server Component","In this embodiment, the Terminal Server component may provide a low-side, multi-user platform on which the low-side presences can physically reside. In one embodiment, it may consist of a commercial off-the-shelf (COTS) platform that supports remote thin-client connections.","In this embodiment, the Terminal Server platform may be connected to the low-side network. This means that the Terminal Server can be configured, without any CAB-specific training, to support applications, resources and protocols natively available on that network. A functional view of the Terminal Server is shown in .","Design Decisions and Considerations","Terminal Server Products Supported","In this embodiment, CAB has been architected to support a variety of terminal server solutions. Because the native server protocol is translated to VDP, supporting additional protocols over time will require very few system changes outside of the Translator.","In this embodiment, there are over a dozen different terminal server solutions available; some are commercial products, some are open-sourced. While open-source solutions appear attractive from a cost perspective, their lack of technical support and limited reliability become major obstacles to ensuring system availability. Of the commercial products, Microsoft and Citrix Corporation dominate the thin-client market. Both offer features that meet the requirements needed of the terminal server functionality.","In one embodiment, Microsoft Windows Terminal Server, using the RDP protocol, may be supported. In another embodiment, Citrix Corporation's MetaFrame Server, using the ICA protocol may be supported. In yet other embodiments, support for other types of terminal servers may include, for example, VNC, Tarantella and X.","Platform Support Considerations","In one embodiment, Citrix is available on UNIX, Linux, and Mac. In another embodiment, Microsoft Windows Terminal Server is supported on Windows platforms, for example, Windows 2000 and 2003.","Scalability and Performance Considerations","In this embodiment, many issues contribute to scalability and performance. Some of the issues are listed below:\n\n","Component Architecture","In one embodiment, the CAB Terminal Server may consist almost entirely of Microsoft COTS products, thus the actual architecture of the Terminal Server is beyond the scope of this document. The CAB Terminal Server is presented here because it is a component of the overall CAB system. The CAB requirements that are solely met by the CAB Terminal Server component are preferably readily supported by any terminal server product chosen.","In this embodiment, while the CAB Terminal Server may be based on COTS products, proper configuration is preferable to ensure reliability and performance standards are met. In addition, low-side user accounts for CAB users may be maintained on the Terminal Server.","Virtual Desktop Protocol (VDP)","In this embodiment, the Virtual Desktop Protocol is a protocol for communications between CAB components. More specifically, VDP may be used for communications between the Client and Guard, and between the Guard and Translator. In one embodiment, VDP communications may coordinate among multiple load-balanced Guards and multiple load-balanced Translators.","In this embodiment, it is preferably that each CAB component implement VDP in the same fashion. This consistency allows for code reuse and helps to ensure compatibility between components. The subsections below describe the consistent implementation and provide further details to support the consistency.","Protocol Definition","Session Startup","In one embodiment, VDP assumes that the client application knows the network location (IP address\/port) and domain classification of the VDP server to which they are connecting. Thus, in this embodiment, VDP provides no negotiation regarding server discovery.","In one embodiment, VDP does not provide any inherent confidentiality or integrity mechanisms to protect the content of the packets transmitted. For this reason, the assumption is that VDP will be used from within a tunnel (SSL, TLS, IPSEC, L2TP and PPTP) that provides an adequate level of confidentiality and integrity.","In this embodiment, a VDP session may begin with the client connecting to the server using the Transmission Control Protocol (TCP). There may be no restrictions regarding the port number on which the server runs. Port assignment of the VDP server may be left up to the server itself.","In this embodiment, following a successful TCP connection, the authentication sequence preferably begins. This sequence begins with server sending an authentication capabilities packet that identifies the supported authentication methods available to the client. In one embodiment, VDP supports a simple form of user password authentication to identify the connecting user. In other embodiments, other known authentication methods may also be used.","In this embodiment, following successful authentication, the client preferably receives a capability packet including the allowed options for the current session and settings from the previous connection if they exist. The client preferably next sends a connection request packet that includes the options they wish to use during the session. Upon processing this request, the server will preferably first respond with a status message indicating whether the selected settings have been accepted or denied. If the selected settings are accepted, the server may be responsible for then establishing a connection with the remote desktop session and responding to the client with an indication of success or failure. Reasons for failure include an invalid user\/password or password expiration. In this case, it is up to the client to initiate a password change request before future authentication requests.","In this embodiment, following a successful connection response, normal user input traffic can commence.","User Input","In this embodiment, there may be two basic forms of user input supported by VDP: Keyboard and Mouse input.","Keyboard","In one embodiment, VDP supports the keys available, for example, on a standard 101-key keyboard plus the two Microsoft window keys and one context key (effectively a Microsoft 104-key keyboard).","In this embodiment, VDP may use a key encoding consistent with the scan codes defined, for example, in the Microsoft Windows operating system for 101\/104-key keyboard types.","In this embodiment, keyboard input may be transmitted in forms including:\n\n","Input Methods","In this embodiment, VDP may support types of text input methods including:\n\n","In this embodiment, buffered input may be the default input method for keyboard keys that have a visual representation. This input method may be provided so that text input will be controlled by the end-client and transmitted at one time for entry into the system.","In this embodiment, direct input allows the user to send each character as a sequence of key-press and key-release events. This input method provides a more realistic user experience by simulating the normal keyboard input method that would be used on a local machine. When direct input mode is enabled, the client can send every key defined on their keyboard using the key-press and key-release packets.","Key Layouts","In this embodiment, variable keyboard layouts are supported because they allow the user to orient their keyboard to the language to which they are accustomed. When typing on a Windows system in another language, it helps to have the keyboard laid out in a way that is more conducive or standardized to fit that language.","In one embodiment, the default keyboard layout used by VDP is QWERTY, also identified as \u201cen-us.\u201d The QWERTY keyboard gets its name from the first six top-level characters: \u201cQ,\u201d \u201cW,\u201d \u201cE,\u201d \u201cR,\u201d \u201cT,\u201d and \u201cY\u201d on a standard United States keyboard. The en-us keyboard layout is identified by the code 0x0409.","Another embodiment may support layouts or input methods that require text input in ways other than simply typing the keyboard (i.e., complex languages with thousands of character sets such as Japanese, Chinese or Korean).","Mouse","In one embodiment, VDP supports standard mouse input. Examples supported include those mouse with up to three buttons and a scroll wheel. It is preferable for mouse input use that there are at least two buttons.","In this embodiment, VDP may support two basic modes of mouse-click input:\n\n","In this embodiment, the raw mouse input mode may rely on the remote server for detection and handling of multiple click-and-drag based events. In this mode, the client will send press-and-release events for every mouse click that occurs. The remote server can then detect whether a double-click, triple-click, drag, or drop event occurred based on the frequency in which the event was received.","In this embodiment, in interpreted mouse input mode, it may be up to the client to detect when double-click, triple-click, and drag-based events occur. When detected, the client would send event-specific messages to the server instead of generic press-and-release events.","In one embodiment, interpreted mode has been provided for systems that regularly have inconsistent latency. In these situations, if the press-and-release events are not processed and sent to the remote desktop server in the speed in which they were received, the remote server may not detect quick key presses as double-clicks. Interpreted mode provides a way of bypassing this problem by leaving the detection up to the local client. By using the interpreted mode, the server can preferably guarantee that the respective click events would be packaged together so that the multiclick event is properly detected.","In this embodiment, in addition to the two different click-input modes, VDP may also support mouse movement and scroll wheel movement. For these two types of input, it may be up to the server to instruct the client if these types are currently enabled and the frequency in which they should be sent.","Server Output","In this embodiment, VDP Output messages sent from the remote server can be broken down into two basic categories:\n\n","In one embodiment, VDP has been designed so that the administrating server can configure the operations to support for each user session it manages. This includes both caching requests and drawing commands. At connection time the server may inform the client which operations it can expect based upon the configuration settings on the server (via the connection response message).","In this embodiment, a VDP session preferably supports these basic operations:\n\n","Drawing Commands","In this embodiment, drawing commands may include any operation that directly or indirectly affects the user's visual picture of the screen. This may include the following commands:\n\n","In this embodiment, the copy and clear-based drawing commands may use some form of bitwise operator to perform their operations.","Image Formats","In one embodiment, there may be five relevant binary image or image-related formats that are defined by or referenced by this specification:\n\n","Caching Requests","In this embodiment, caching requests include operations that involves storing image-related data in the client's memory for later retrieval and lookup. The caching feature enables the system to store commonly used data with the client for later lookup and usage. This prevents the server from having to send the same image to a client numerous times.","In this embodiment, the following caching requests may be available:\n\n","In one embodiment, when each of these commands is issued by the server, included is a cache index that tells the client where to store the data. The cache size in bytes and elements expected by the client is dictated by the administrating server via the capabilities packet using the \u201cCache Size\u201d Type Length Value (TLV) type.","Capabilities","In this embodiment, following a successful authentication process, the client may receive a capabilities packet that includes various capability fields, for example, color depth, drawing capability and key layout. The capability fields may define what options are available to that user's session and any information about that client's previous settings from the last connection.","Shutdown and Error Management","In this embodiment, VDP may provide two basic packets for shutting down a session:\n\n","Session Shutdown","In this embodiment, the session shutdown message may be sent whenever a node in the system that is aware of the current VDP session wishes the session be completely terminated. Accompanying the shutdown message may be a reason or status code that the sender can use to indicate to the end-client the reason for the shutdown. This reason could be both a fatal and non-fatal shutdown; there are no restrictions as to how this field is used. For example, the client can use the Session Shutdown packet to close the session completely or request that the session be suspended for later opening.","Session Timeout","In this embodiment, VDP may recognize different types of timeouts, including:\n\n","In this embodiment, the session timeout message may be sent to the end-client to indicate a system-enforced shutdown because of idle or suspend-based timeout. Included in this message may be specific details about the time that just expired and how long the session will be cached for later reconnection. When the client initiates a shutdown, the user can additionally receive a session timeout message indicating how long the connection will be cached on the remote desktop server in a suspended or cached state.","Protocol Structure","In this embodiment, Although not explicitly defined by each packet in this section, packets are preferably aligned to a 4-byte boundary. Any packet that does not already align to this boundary is preferably padded with zeros to ensure that the 4-byte boundary requirement is maintained.","Packet Header","In one embodiment, the packet header may be composed of five fields, as shown in the table below. Each packet described may start with the packet header defined below. The size and offset columns are represented in bytes.",{"@attributes":{"id":"p-0936","num":"1328"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"VDP Packet Header Layout"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Offset","Size","Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","4","Identifier","ascii","Unique number used to"]},{"entry":[{},{},{},{},"identify the VDP packet"]},{"entry":[{},{},{},{},"(0x56445000 = \u201cVDP\\0\u201d)"]},{"entry":["4","2","Version","uint16","Identifies what version of the"]},{"entry":[{},{},{},{},"protocol to use. The High"]},{"entry":[{},{},{},{},"order byte represents a major"]},{"entry":[{},{},{},{},"version and the low order byte"]},{"entry":[{},{},{},{},"represents a minor version"]},{"entry":[{},{},{},{},"(0x0100 = version 1 .0)"]},{"entry":["6","2","Packet","uint8","Primary packet type use to"]},{"entry":[{},{},"Type",{},"categorize the packet."]},{"entry":["8","2","Sub Packet","uint16","Secondary packet type."]},{"entry":[{},{},"Type"]},{"entry":["10","2","Payload","uint16","Length of the payload in four"]},{"entry":[{},{},{},{},"byte words (0x0100 = 16"]},{"entry":[{},{},"Length",{},"words * 4 bytes\/word ="]},{"entry":[{},{},{},{},"64 bytes). VDP packet can"]},{"entry":[{},{},{},{},"have a maximum length of"]},{"entry":[{},{},{},{},"65535 words or 266,122 bytes."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0937","num":"1329"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"chemistry":{"@attributes":{"id":"CHEM-US-00001","num":"00001"},"img":{"@attributes":{"id":"EMI-C00001","he":"23.79mm","wi":"43.35mm","file":"US08769127-20140701-C00001.TIF","alt":"embedded image","img-content":"table","img-format":"tif"}}}}},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In one embodiment, the CAB implementation additionally subdivides the packet-type field into the following logical fields (offsets are from within the packet type field above):",{"@attributes":{"id":"p-0939","num":"1331"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CAB Packet Type Field"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Bits",{}]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Offset","Size","Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["0","1","Upstream","bit","Indicates if the packet is going"]},{"entry":[{},{},{},{},"upstream or downstream. Setting"]},{"entry":[{},{},{},{},"the bit means that the packet"]},{"entry":[{},{},{},{},"should be moving upstream."]},{"entry":[{},{},{},{},"Otherwise, the packet should"]},{"entry":[{},{},{},{},"be moving downstream."]},{"entry":["1","7","Segment","uint","ID indicating on which segment"]},{"entry":[{},{},{},{},"in the cab architecture the packet is"]},{"entry":[{},{},{},{},"being transmitted."]},{"entry":["8","8","Type","uint8","Type code for the packet"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"In one embodiment, the CAB system refers to the terms Upstream and Downstream in the opposite way of conventional definitions. In the CAB system:\n\n","In this embodiment, the changes above result in the following exemplary packet header:",{"@attributes":{"id":"p-0942","num":"1336"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CAB VDP Header"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"chemistry":{"@attributes":{"id":"CHEM-US-00002","num":"00002"},"img":{"@attributes":{"id":"EMI-C00002","he":"25.74mm","wi":"70.78mm","file":"US08769127-20140701-C00002.TIF","alt":"embedded image","img-content":"table","img-format":"tif"}}}}},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Exemplary CAB Segment IDs:",{"@attributes":{"id":"p-0944","num":"1338"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CAB Segment IDs"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ID","Segment","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0x0001","Client",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00001","he":"2.12mm","wi":"2.79mm","file":"US08769127-20140701-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}},"Guard","Packets sent between the client and"]},{"entry":[{},{},{},{},"guard"]},{"entry":["0x0002","Guard",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00002","he":"2.12mm","wi":"2.79mm","file":"US08769127-20140701-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}},"Translator","Packets sent between the guard"]},{"entry":[{},{},{},{},"and the translator"]},{"entry":["0x0003","Guard",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00003","he":"2.12mm","wi":"2.79mm","file":"US08769127-20140701-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}},"Guard","Packets sent between two guards"]},{"entry":[{},{},{},{},"for Inter Guard Communication"]},{"entry":[{},{},{},{},"(IGC). This is used for load"]},{"entry":[{},{},{},{},"balancing and guard"]},{"entry":[{},{},{},{},"synchronization"]},{"entry":["0x0004","Client",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00004","he":"2.12mm","wi":"2.79mm","file":"US08769127-20140701-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}},"FTG","Packets sent between the client"]},{"entry":[{},{},{},{},"and the file transfer guard"]},{"entry":[{},{},{},{},"specifically for file transfers"]},{"entry":["0x0005","Translator",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00005","he":"2.12mm","wi":"2.79mm","file":"US08769127-20140701-P00001.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}},"FTG","Packets sent between the"]},{"entry":[{},{},{},{},"translator and the file transfer"]},{"entry":[{},{},{},{},"guard specifically for file transfers"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"Packet Types","In this embodiment, the packet type section may be used to identify valid packets supported in VDP, their corresponding packet type and subpacket type codes, as well as their physical make-up. This following table enumerates the exemplary packet types and subtypes. The length column in the table below is used to identify the preferably number of bytes needed for each packet (this does not include the 12 bytes required for the header).",{"@attributes":{"id":"p-0947","num":"1341"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"VDP Packet Types"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Type","Subtype","Length",{}]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ID","Name","ID","Name","(bytes)","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"6","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0x0001","Authentication","0x0001","User\/Password","76","Standard user password request"]},{"entry":[{},{},{},"Request"]},{"entry":[{},{},"0x0002","User\/Password","4","Standard user password"]},{"entry":[{},{},{},"response",{},"response"]},{"entry":[{},{},"0x0003","Change Password","140","Request to change the current"]},{"entry":[{},{},{},{},{},"password"]},{"entry":[{},{},"0x0004","Change Password","2","Password Change Response"]},{"entry":[{},{},{},"Response"]},{"entry":[{},{},"0x0005","Auth Capabilities","4","Describes the available"]},{"entry":[{},{},{},{},{},"authentication methods"]},{"entry":["0x0002","State","0x0001","Session","8","Sent to indicate a shutdown of"]},{"entry":[{},{},{},"Shutdown",{},"the session, forceful or"]},{"entry":[{},{},{},{},{},"otherwise"]},{"entry":[{},{},"0x0002","Session Timeout","14","Sent to indicate a timeout based"]},{"entry":[{},{},{},{},{},"shutdown"]},{"entry":[{},{},"0x0003","Client","518","Sent to the client to notify it of"]},{"entry":[{},{},{},"Notification",{},"some event"]},{"entry":["0x0003","Capabilities","0x0001","Capabilities","Var.","Sent to provide the client with a"]},{"entry":[{},{},{},{},{},"set of valid options for their"]},{"entry":[{},{},{},{},{},"current session"]},{"entry":[{},{},"0x0002","Connection","Var","Send by the client to initiate a"]},{"entry":[{},{},{},"Request",{},"connection with the server"]},{"entry":[{},{},"0x0003","Connection","Var","Sent by the server to confirm"]},{"entry":[{},{},{},"Response",{},"the connection response"]},{"entry":["0x0004","User Input","0x0001","Keyboard Press","4","User presses a keyboard key"]},{"entry":[{},{},"0x0002","Keyboard","4","User releases a keyboard key"]},{"entry":[{},{},{},"Release"]},{"entry":[{},{},"0x0003","Key string","Var.","User enters a captured string"]},{"entry":[{},{},"0x0004","Mouse Press","6","User clicks a mouse button"]},{"entry":[{},{},"0x0005","Mouse Release","6","User releases a mouse button"]},{"entry":[{},{},"0x0006","Mouse Move","4","User moves the mouse"]},{"entry":[{},{},"0x0007","Mouse Scroll Up","4","User moves the mouse scroll"]},{"entry":[{},{},{},{},{},"wheel up"]},{"entry":[{},{},"0x0008","Mouse Scroll","4","User moves the mouse scroll"]},{"entry":[{},{},{},"Down",{},"wheel down"]},{"entry":[{},{},"0x0009","Mouse Single-","6","User completed a single mouse"]},{"entry":[{},{},{},"Click",{},"click"]},{"entry":[{},{},"0x000A","Mouse Double-","6","User completed a double"]},{"entry":[{},{},{},"Click",{},"mouse click"]},{"entry":[{},{},"0x000B","Mouse Triple-","6","User completed a triple mouse"]},{"entry":[{},{},{},"Click",{},"click"]},{"entry":[{},{},"0x000C","Mouse Drag","6","User-initiated dragging"]},{"entry":[{},{},"0x000D","Mouse Drop","6","User completed a drop"]},{"entry":["0x0005","Drawing","0x0001","Palette Update","Var.","Contains a new palette to use"]},{"entry":[{},"Command",{},{},{},"for all future 8-bit images."]},{"entry":[{},{},"0x0002","Cursor Update","Var.","Contains a new cursor image"]},{"entry":[{},{},"0x0003","CIF Paint","Var.","Contains 1 . . . N new images to"]},{"entry":[{},{},{},{},{},"be drawn"]},{"entry":[{},{},"0x0004","Clear","12","Clears a region of the screen"]},{"entry":[{},{},{},{},{},"using a specified color or"]},{"entry":[{},{},{},{},{},"operation"]},{"entry":[{},{},"0x0005","Pattern Clear","29","Clears a region of the screen"]},{"entry":[{},{},{},{},{},"using a bitwise operation and"]},{"entry":[{},{},{},{},{},"patterned brush"]},{"entry":[{},{},"0x0006","Screen Copy","14","Copies one area of the screen to"]},{"entry":[{},{},{},{},{},"the other using a bitwise"]},{"entry":[{},{},{},{},{},"operation"]},{"entry":[{},{},"0x0007","Cache Copy","16","Copies a cached bitmap to the"]},{"entry":[{},{},{},{},{},"screen using a bitwise operation"]},{"entry":[{},{},"0x0008","Cached Cursor","2","Request to change the cursor"]},{"entry":[{},{},{},"Draw",{},"from cache"]},{"entry":[{},{},"0x0009","Cached Text","Var.","Request to draw text from"]},{"entry":[{},{},{},"Draw",{},"cache"]},{"entry":["0x0006","Cache","0x0001","Cursor Cache","Var.","Cursor to cache"]},{"entry":[{},"Request","0x0002","Screen Cache","10","Request to cache a section of"]},{"entry":[{},{},{},{},{},"the screen"]},{"entry":[{},{},"0x0003","Bitmap Cache","12","A bitmap to store in the cache"]},{"entry":[{},{},"0x0004","Font Cache","Var.","A array of font glyphs to cache"]},{"entry":["0x0007","Health","0x0001","Client Request","6","Request for health status"]},{"entry":[{},{},{},{},{},"information"]},{"entry":[{},{},"0x0002","Client Response","12","Health status information"]},{"entry":["0x0008","Audit\/log","0x0001","Remote Log","284","Send a log entry"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, the table below shows examples of the valid packets for each segment and the direction in which they are allowed.",{"@attributes":{"id":"p-0949","num":"1343"},"tables":{"@attributes":{"id":"TABLE-US-00037","num":"00037"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CAB Valid Segment ID and Packet Mappings"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Segment","Dir.","Type","Subtype"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["C G(1)","Down","Authentication (0x01)","User\/Password Request (0x0001)"]},{"entry":[{},{},"Authentication (0x01)","Change Password Request(0x0003)"]},{"entry":[{},{},"Capabilities (0x03)","Connection Request (0x0002)"]},{"entry":[{},{},"User Input (0x04)","All Subtypes (0x0001-0x000C)"]},{"entry":[{},{},"Health (0x07)","Health Client Request (0x0001)"]},{"entry":[{},{},"Audit\/Log (0x08)","Remote Log (0x0001)"]},{"entry":[{},"Up","Authentication (0x01)","User\/Password Response (0x0002)"]},{"entry":[{},{},"Authentication (0x01)","Change Password Response (0x0004)"]},{"entry":[{},{},"State (0x02)","Session Timeout (0x0002)"]},{"entry":[{},{},"State (0x02)","Client Notification (0x0003)"]},{"entry":[{},{},"Capabilities (0x03)","Capabilities (0x00001)"]},{"entry":[{},{},"Capabilities (0x03)","Connection Response (0x0003)"]},{"entry":[{},{},"Drawing Ops (0x05)","All Subtypes (0x0001-0x0009)"]},{"entry":[{},{},"Caching Ops (0x06)","All Subtypes (0x0001-0x0004)"]},{"entry":[{},{},"Health (0x07)","Health Client Response (0x0002)"]},{"entry":[{},"Both","State (0x02)","Session Shutdown (0x0001)"]},{"entry":["G T(2)","Down","Capabilities (0x03)","Connection Request (0x0002)"]},{"entry":[{},{},"User Input (0x04)","All Subtypes (0x0001-0x000C)"]},{"entry":[{},"Up","State (0x02)","Session Timeout (0x0002)"]},{"entry":[{},{},"Capabilities (0x03)","Connection Response (0x0003)"]},{"entry":[{},{},"Drawing Ops (0x05)","All Subtypes (0x0001-0x0009)"]},{"entry":[{},{},"Caching Ops (0x06)","All Subtypes (0x0001-0x0004)"]},{"entry":[{},"Both","State (0x02)","Session Shutdown (0x0001)"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Packet Details","Authentication Packets","In this embodiment, VDP Authentication packet sequences may be used to verify and accept valid users into the CAB system.","In this embodiment, the authentication process can often require multiple roundtrip packet exchanges between the client and server before the authentication is complete. Therefore, authentication packets preferably begin with a 2-byte sequence number that is used to identify the current authentication step in the process. This sequence number should preferably be increased before each step in the authentication sequence, with the first sequence starting at one.","In this embodiment, as an example, a client node may use the User\/Password Request Packet to initiate the authentication sequence. This may be the first packet to be sent by the client following a successful connection, assuming the User\/Password authentication method is chosen. An exemplary packet structure is shown below:",{"@attributes":{"id":"p-0955","num":"1349"},"tables":{"@attributes":{"id":"TABLE-US-00038","num":"00038"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"User\/Password Request Packet"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Offset","Size","Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","2","Sequence","uint16","Authentication Sequence Number (Value = 1)"]},{"entry":["2","2","Length","uint16","Length of the username string in bytes (2 * NumChars)"]},{"entry":["4","40","Username","unicode(20)","Unicode string identifying the user to log in as."]},{"entry":[{},{},{},{},"The field can contain up to 20 Unicode"]},{"entry":[{},{},{},{},"characters. Usernames shorter than the max"]},{"entry":[{},{},{},{},"length should be padded with zero's"]},{"entry":["44","32","Password","binary","The connecting user's password hashed using the"]},{"entry":[{},{},{},{},"SHA-256 algorithm. The purpose of using the"]},{"entry":[{},{},{},{},"hash is not for security, but to prevent others"]},{"entry":[{},{},{},{},"(such as an administrator) from seeing the user's"]},{"entry":[{},{},{},{},"plain text password."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"State Packets","In this embodiment, state packets may include anything that directly or indirectly affects the normal running state of the system after authentication and connection have been established.","In this embodiment, the packets in this section may have implementation-specific fields. The fields for each packet that apply may be as follows:\n\n","In this embodiment, for example, the session shutdown message may be sent to indicate that the end-host is shutting down the session. Included in this packet may be a code used to identify the reason for the shutdown.",{"@attributes":{"id":"p-0960","num":"1357"},"tables":{"@attributes":{"id":"TABLE-US-00039","num":"00039"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Session Shutdown Packet"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Offset","Size","Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["0","4","Timestamp","uint32","Time in seconds since"]},{"entry":[{},{},{},{},"(00:00:00), Jan. 1, 1970,"]},{"entry":[{},{},{},{},"coordinated universal time"]},{"entry":[{},{},{},{},"(UTC)."]},{"entry":["4","4","Reason","uint32","Reason for the shutdown"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"Capability Packets","In this embodiment, capability packets may be a special kind of packet that enables the user to convey the options with which they wish to run and the options that the server will allow them to run. In order to remain flexible and still provide an acceptable level of inspection, some of the packets in this type may rely on the TLV construct.","Type Length Value","In this embodiment, type length value is a simple construct that states that all of your message should be pre-pended with a type and a length where the type indicates what kind of data is to come; the length represents the size of that data.","In this embodiment, based on this information the TLVs used in VDP may have the following structure:",{"@attributes":{"id":"p-0966","num":"1363"},"tables":{"@attributes":{"id":"TABLE-US-00040","num":"00040"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"TLV Structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Offset","Size","Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["0","2","Type","uint16","A code that identifies the data"]},{"entry":[{},{},{},{},"content to follow"]},{"entry":["2","2","Length","uint16","Length of the data to follow in"]},{"entry":[{},{},{},{},"bytes words (0x0010 = 16"]},{"entry":[{},{},{},{},"words * 4 bytes\/word = 64"]},{"entry":[{},{},{},{},"bytes)"]},{"entry":["4","Length","Value","binary","The binary data that makes of the"]},{"entry":[{},{},{},{},"information defined by the type"]},{"entry":[{},{},{},{},"and length"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"In one embodiment, a TLV can have a maximum length of 65,534 words or 266,118 bytes. This leaves one word for the header of the TLV if the packet was at the maximum supported VDP packet size.","Valid TLV Types","In this embodiment, below is a table that enumerates exemplary valid TLV types supported by capability packets:",{"@attributes":{"id":"p-0970","num":"1367"},"tables":{"@attributes":{"id":"TABLE-US-00041","num":"00041"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Valid TLV Types"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Length",{},{}]},{"entry":["Type","(bytes)","Name","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0x0001","8","Display Settings","Settings specific to how the screen is displayed to the user"]},{"entry":["0x0002","2","Language Settings","Used to select any language specific input settings"]},{"entry":["0x0003","Var.","Login","Includes fields for remotely logging in such as username"]},{"entry":[{},{},{},"and password"]},{"entry":["0x0004","8","Remote Host","Identifies a remote server by IP address and port"]},{"entry":["0x0005","588","Domain","Identifies the current operating domain"]},{"entry":["0x0006","18","Cache Size","Identifies the size of the current drawing caches in"]},{"entry":[{},{},{},"elements and bytes."]},{"entry":["0x0007","8","Display Capabilities","Includes any fields that identify the acceptable display"]},{"entry":[{},{},{},"options for the current session"]},{"entry":["0x0008","12","Input Capabilities","Includes any fields that identify the acceptable input"]},{"entry":[{},{},{},"options for the current session"]},{"entry":["0x0009","4","Output Capabilities","Includes any fields that identify the acceptable output"]},{"entry":[{},{},{},"options for the current session"]},{"entry":["0x000A","16","System Capabilities","Includes any fields that identify the acceptable system"]},{"entry":[{},{},{},"options for the current session"]},{"entry":["0x000B","4","Client Identifier","Sent by the client to identify itself to the server"]},{"entry":["0x000C","4","Security Settings","Sent to specify any connection specific security settings"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, the table below outlines exemplary capability and settings that are preferably transmitted in the CAB architecture, the TLV to which they are assigned, and to which node that TLV should be sent.",{"@attributes":{"id":"p-0972","num":"1369"},"tables":{"@attributes":{"id":"TABLE-US-00042","num":"00042"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},{},"Sent to","Sent to"]},{"entry":["TLV","Capability\/Setting","client","translator"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Display Settings","Resolution (Width and Height)","X","X"]},{"entry":[{},"Color Depth (8, 15, 16, or 24 bit)"]},{"entry":["Display Capabilities","Maximum Resolution (Width and Height)","X"]},{"entry":[{},"Supported Color Depth"]},{"entry":["Language Settings","Key Layout","X","X"]},{"entry":["Login","Terminal Server Username",{},"X"]},{"entry":[{},"Terminal Server Password"]},{"entry":["Remote Host","Terminal Server IP Address and Port",{},"X"]},{"entry":[{},"Which translator to use (RDP\/ICA)"]},{"entry":["Domain","Low-side Domain Settings:","X"]},{"entry":[{},"Identifier (U, S, TS)"]},{"entry":[{},"Banner Text"]},{"entry":[{},"Color Parameters"]},{"entry":["Cache Size","Cache Configuration:","X","X"]},{"entry":[{},"Bitmap Cache"]},{"entry":[{},"Font Cache"]},{"entry":[{},"Cursor Cache"]},{"entry":[{},"Palette Cache"]},{"entry":["Input Capabilities","Supported Mouse Events","X"]},{"entry":[{},"Supported Key Layouts"]},{"entry":[{},"Mouse Movement Frequency"]},{"entry":[{},"Mouse Hover Setting"]},{"entry":["Output Capabilities","Supported Drawing Operations","X"]},{"entry":["System Capabilities","Supported Clipboard Features","X","X"]},{"entry":[{},"Supported File Transfer Features"]},{"entry":[{},"Supported Audio Features"]},{"entry":[{},"Supported Video Features"]},{"entry":[{},"User pre-emption supported"]},{"entry":[{},"Timeout settings (idle, suspend, cache)"]},{"entry":[{},"User priority"]},{"entry":[{},"Availability of session performance"]},{"entry":["Security Settings","Low-side security setting (Translator  Terminal",{},"X"]},{"entry":[{},"Server)"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"In this embodiment, the Login TLV, which may be used to pass basic authenticating fields onto a remote server, is shown below as an example:",{"@attributes":{"id":"p-0974","num":"1371"},"tables":{"@attributes":{"id":"TABLE-US-00043","num":"00043"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"315pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Login TLV Data"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Offset","Size","Name","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["0","64","Username","unicode(32)","Unicode string that identifies the user's"]},{"entry":[{},{},{},{},"account. Unused characters must be"]},{"entry":[{},{},{},{},"zeroed."]},{"entry":["68","\u20024","Password","uint32","Length of the password field in bytes (2 * NumChars)"]},{"entry":[{},{},"Length"]},{"entry":["72","Variable","Password","unicode(variable)","Unicode string that identifies the user's"]},{"entry":[{},{},{},{},"password in plaintext. Unused"]},{"entry":[{},{},{},{},"characters must be zeroed."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"Capabilities","In this embodiment, a capability packet may be sent by the authenticating server following the completion of a successful authenticating process to provide the client with its current session's capabilities. Also included may be the current user's last connection settings. Information may be provided via the TLV types that are defined above.","Allowed TLV Types","In one embodiment, the below table defines which TLV types are valid for use with the capabilities packet. In one embodiment, column three, labeled \u201cReq\u201d denotes TLV types that are \u201crequired\u201d (they are highly preferable). TLV types that do not have this columned selected can be sent, but it is not required.",{"@attributes":{"id":"p-0979","num":"1376"},"tables":{"@attributes":{"id":"TABLE-US-00044","num":"00044"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Allowed Capability Packet TLV Types"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Type","Name","Req.","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["0x0001","Display Settings",{},"Last login display settings. Upon connecting for the"]},{"entry":[{},{},{},"first time this TLV won't be included"]},{"entry":["0x0002","Language Settings",{},"Last login language settings, Upon connecting for the"]},{"entry":[{},{},{},"first time this TLV won't be included"]},{"entry":["0x0005","Domain","\u2022","Connecting Domain display requirements"]},{"entry":["0x0006","Cache Size","\u2022","Caching options available to the user"]},{"entry":["0x0007","Display Capabilities","\u2022","Display options available"]},{"entry":["0x0008","Input Capabilities","\u2022","Input options available to the user"]},{"entry":["0x0009","Output Capabilities","\u2022","Output options available to the user"]},{"entry":["0x000A","System Capabilities","\u2022","System options available to the user"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Connection Request","In this embodiment, the connection request may be sent by a client to initiate a connection to the server following a successful authentication process.","In this embodiment, the connection request may be used by both the client and guard to initiate a connection. This process begins with the client sending a connection request to the guard that includes its connection settings. The guard will then validate those options and if all the selected options are valid will send a connection response to the client indicating the settings were accepted. The guard will then initiate a similar connection request to the translator providing all the information needed for it to make the connection to the terminal server.","Connection Response","In this embodiment, the connection response message may be sent by a server in response to connection request message. This packet may optionally include some TLV types if necessary.","In this embodiment, upon successfully validating the clients connection request, the Guard preferably sends a connection response to the client indicating that its settings were accepted. The connection process will continue with the Guard initiating a connection request to the translator. The Guard should then wait for a connection response from the translator indicating the success or failure of the connection. The connection process will then complete when the Guard sends a connection response to the client indicating the final success or failure of the connection.","User Input Packets","In this embodiment, user input packets, like keyboard and mouse input, are preferably sent from the user's client in order to represent the current state of that user's keyboard and mouse.","In one embodiment, by default, the keyboard press-and-release events are preferably only used for control keys (keys with no visual character representation) unless direct input mode has been enabled. When direct input mode is enabled, all keys can be transmitted used keyboard press-and-release packets or using the key-string packet.","In this embodiment, the mouse move event should be sent by the user client based upon the frequency and hover settings defined in capability packet.","In this embodiment, several packet types in this section have the same structure and therefore are grouped with other types. The packets with the same structure that are grouped together are:\n\n","Key String","In this embodiment, the key-string packet may be used to send a large string of text at one time. This message is used by the text buffer to transmit large strings instead of one character at a time. The key-string packet is preferably not used to send sequences of scancodes (specifically ones that do not have visual representations) that do not conform to the text defined in the string field. For example, key-string packets with no Unicode text and multiple scancodes should be considered invalid.","In this embodiment, included with the packet is an array of scancodes that the remote server can use to decode the string. The scancode array may contain any scancode that maps to a visible character based on the current key layout and either of the two character modifiers (shift, alt gr). When modifier scancodes are used, the first occurrence of that scancode will signify that the key is being pressed and held, and the second occurrence indicates the release of that modifier key.","Implementation Details","CAB VDP (API)","In one embodiment, the VDP API used by the CAB system is an implementation of VDP as described above and in the VDP Protocol Specification, which is incorporated herein by reference. Both the Translator and the Guard may use this implementation as the default code-base for interfacing with and speaking the Virtual Desktop Protocol in order to maintain consistency across both nodes.","In this embodiment, exemplary goals of this implementation are:\n\n","In this embodiment, to accomplish these goals, the VDP API may provide a set of C functions that the Guard and Translator can use to:\n\n","In this embodiment, a purpose of this API is to provide an interface to the VDP protocol from a functional perspective. While this API may provide helper functions to validate the form of VDP packets, it may not be the responsibility of this API to verify the correctness of the values stored within the fields beyond the scope of its defined type. This means that it may be the responsibility of the host process to use the VDP API to scan for and detect any anomalies that do not fall within the scope field's defined type (i.e., uint8, int16, etc.).","Design Decisions and Considerations","Decision to Develop or Reuse","In one embodiment, the VDP protocol is a completely new development and requires no re-use of any existing design or product. The VDP implementation is preferably developed from scratch based on the protocol itself and the requirements of the project. Preferably, no re-use will be employed until later revisions of the protocol are undertaken.","Component Design Decisions","In one embodiment, this API is intended for use with the Red Hat Enterprise distribution (version 4) of Linux and therefore preferably relies on the Berkley Socket API implemented therein for TCP-based connections.","In one embodiment, system constraints may dictate that the C programming language is preferred to be used where possible to implement CAB software, which includes this API. Therefore, code can preferably be built and compiled using a compiler that adheres to the C99 (ISO\/IEC 9899:1999) programming language standard.","In this embodiment, this component may be organized in a way so that the core functionality of VDP is abstracted away from the user. This may ensure that the user does not have to make an excessive number of API calls and have an in-depth understanding of the sequencing required by the API for each VDP operation needed. Where possible, the implementation provides entry points into the core API in the form of callbacks, so that critical-use decisions can be answered directly by the host system.","Interface-Related Design Considerations","In this embodiment, the VDP API may be designed in such a way as to provide as much independence as possible from the context in which the API is used. For example, the host's code base should be able to use this library effectively in both thread-based and process-based execution environments. In situations where the host wants to provide a custom implementation of a feature, the API provides support for registering callbacks that will be invoked when a specific event is fired. This may ensure that the host has full control of the resources used on its system, but can still remain relatively naive about the protocol's internals.","In one embodiment, this API makes no attempt at managing or governing any buffers used for sending and receiving VDP-based packets. It may be up to the host code base to manage the allocation and de-allocation of the connection and packet buffers passed to the API. The VDP API may provide a group of headers and helper functions that are intended to help in interpreting the content of the fields within VDP.","In this embodiment, the VDP API is preferably signal-aware in order to ensure that blocking operations can be terminated gracefully and that VDP state is properly cleaned up when signals cause a forcible close of the component. Note however, that it may be the responsibility of the host to properly catch and handle signals and thus respond appropriately.","Performance-Related Design Considerations","In one embodiment, this API can be designed to accommodate two hundred active user sessions. In some cases, this requirement means that the host will need to maintain 400 active TCP connections (high-side and low-side) to facilitate the session's traffic flow through the host.","In this embodiment, IO-related functions within the API (such as read and write) may assume a blocking 10 model by default. The non-blocking model may also be supported, but may require a mode change or a flag to instruct the API to use the non-blocking mode.","In one embodiment, VDP fields may be stored in little-endian format. Guard and Translator components may be run on x86-based hardware and therefore keeping VDP fields in little-endian may improve system performance by removing any unnecessary byte swapping. This may affect the Java client because Java assumes network byte ordering, which conforms to BigEndian. Thus, the byte-swapping burden may be placed upon each client machine because they only have one connection to manage and can bear the extra clock cycles. The Guard and Translator, on the other hand, preferably handle a minimum of two hundred connections and therefore need to eliminate as much extra processing as possible.","Safety, Security, and Privacy Design Considerations","In one embodiment, the VDP API makes no attempt at managing the security of the connections that it maintains. It may be up to the host code base and operating system policy to ensure that socket operations are constrained to system call permissions needed by the recv, send, and setsockopt socket API calls. VDP traffic may be TCP-based and preferably may not rely on raw sockets.","In one embodiment, the VDP API may help manage the state of the packets sent through its interface. In this sense, it will provide security that ensures that packets are well formed, and that packets arrive and are sent in the right order.","In this embodiment, the VDP protocol may assume that it is tunneled through a secure stream-based protocol such as TLS or SSL to preferably ensure confidentiality, data integrity, and source integrity. However, the VDP implementation may assume it is wholly independent of the tunnel and\/or security mechanisms used to protect the protocol transport.","Subcomponent Details","In one embodiment, the VDP API may comprise two main elements: a Listener element and a Connection element.","In this embodiment, the Listener element may encapsulate all operations involved in managing a TCP socket that can listen for, and accept connections. The Connection element may encapsulate all operations involved in receiving and sending packets, verifying the correctness of packets, and ensuring that packets are sent during valid states.","State Diagrams","In this embodiment, the Listener component may have the following exemplary states:",{"@attributes":{"id":"p-1024","num":"1431"},"tables":{"@attributes":{"id":"TABLE-US-00045","num":"00045"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"VDP Listener Component States"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Unused","0","Indicates that the component is currently not in use, and that the"]},{"entry":[{},{},"Listener has not been created yet. This state is set to zero so that when"]},{"entry":[{},{},"a \u201cmemset\u201d operation is performed on the containing structure, the"]},{"entry":[{},{},"zeroing operation effectively resets the structure for use."]},{"entry":["Created","1","The Listener has been created using the \u201cvdpCreateListener\u201d function"]},{"entry":[{},{},"and all Listener-based callbacks have been assigned."]},{"entry":["Allocating","2","The Listener has invoked a callback and is waiting for the host to"]},{"entry":[{},{},"release a new connection structure for use by the next connection"]},{"entry":["Listening","3","The Listener has been started using the \u201cvdpStartListener\u201d function"]},{"entry":[{},{},"and is waiting for a remote connection to be made. The state occurs"]},{"entry":[{},{},"after the listen and accept socket calls while the process is blocked"]},{"entry":[{},{},"waiting for connections."]},{"entry":["Accepting","4","The Listener has accepted a connection and is waiting for the host to"]},{"entry":[{},{},"take control of the connection via a Listener invoked callback"]},{"entry":["Paused","5","The Listener has been paused via the \u201cvdpPauseListener\u201d function"]},{"entry":[{},{},"and is not accepting connections."]},{"entry":["Finished","6","The Listener has been terminated and is not accepting any"]},{"entry":[{},{},"connections. The memory used for the Listener can be released or"]},{"entry":[{},{},"zeroed for reuse"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, the Connection component may have the following exemplary states:",{"@attributes":{"id":"p-1026","num":"1433"},"tables":{"@attributes":{"id":"TABLE-US-00046","num":"00046"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"VDP Connection Component States"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","Value","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Unused","0","Indicates that the component is currently not in use and that the"]},{"entry":[{},{},"connection has not been created yet. This state is set to zero so that"]},{"entry":[{},{},"when a \u201cmemset\u201d operation is performed on the containing"]},{"entry":[{},{},"structure, the zeroing operation effectively resets the structure for"]},{"entry":[{},{},"use."]},{"entry":["Open","1","The connection has been allocated and associated with a remote"]},{"entry":[{},{},"VDP connection, but no packets have been received to initiate the"]},{"entry":[{},{},"authentication process."]},{"entry":["Authenticating","2","The connection has begun receiving authentication packets, but"]},{"entry":[{},{},"the authentication process has not completed yet."]},{"entry":["Connecting","3","The authentication process has completed successfully. The"]},{"entry":[{},{},"connection has begun the connection process."]},{"entry":["Connected","4","The connection process has completed successfully and normal"]},{"entry":[{},{},"traffic packet operations has begun (i.e., sending key and mouse"]},{"entry":[{},{},"input, receiving image output)"]},{"entry":["Suspended","5","The connection has been suspended to be resumed later. In this"]},{"entry":[{},{},"case, the Client-to-Guard connection should be terminated and the"]},{"entry":[{},{},"Guard-to-Translator connection should indicate the suspended"]},{"entry":[{},{},"state."]},{"entry":["ShuttingDown","6","The connection is being terminated but is still connected."]},{"entry":["Disconnected","7","The connection has been completely torn down and is ready to be"]},{"entry":[{},{},"cleared for reassignment."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Software Architecture","In one embodiment, the software architecture for the VDP API may be been designed to abstract away as much of VDP as possible while still providing the host control over critical resource-related operations such as memory allocation. To do this, the VDP API may employ the ability for the host to register custom callback functions.","In one embodiment, the two main elements of this architecture are:\n\n","Listener","In one embodiment, the Listener encapsulates operations involved in listening for and accepting connections. This includes the setup of a Listener socket, binding to a local address and the allocation delegation of new VDP connections. To do this the Listener preferably manages fields, such as:\n\n","Connection","In one embodiment, the connection component encapsulates operations for receiving and sending VDP packets. In addition to the simple send-and-receive operations, the connection component may also verify packets for correct form and order before passing them on to the host. To do this, fields such as the following are managed:\n\n","In one embodiment, the I\/O portion of this component may be separated from the connection so that the host can define the I\/O routines desired to be used for packet reception and transmission.","In this embodiment, this abstraction may allow the host to define callbacks for reading, writing and buffer allocation that causes the operations to be performed on a file descriptor instead of the socket descriptors used by the connection component. When a connection component is assigned, and before the \u201cConnection Established\u201d callback, the default I\/O routines and descriptors are set to the connection socket descriptor and socket recv\/send functions. The I\/O portion of this component (also called a ReaderWriter) may be responsible for managing the following fields:\n\n","Error Management","In one embodiment, the VDP API manages errors consistent with the way that Linux system calls manage and report errors to the calling thread. Traditionally, when errors occur on Linux, the system call will record an error code in the \u201cerrno\u201d global variable and then return an error via the system call return value that simply indicates success or failure. It is then up to the host thread that invoked the system call to look up the error using the \u201cerrno\u201d variable. This variable is automatically kept in thread local storage and each thread has an independent copy of the variable. The Linux system currently reserves positive integers for the errno field.","In keeping with this model, in one embodiment, VDP API functions record their errors in the \u201cerrno\u201d variable with a negative integer value. When a VDP API function returns, it similarly sets the error code in the \u201cerrno\u201d variable and returns only an indication of success or failure.","In this embodiment, callbacks may optionally return similar indications of success or failure on a case by case basis. Callbacks will generally want to return some failure indication when they need the calling component to take some action in response to the callback invocation. Callback actions for various return values will be described in later sections. If the callback in question returns a type of int32_t and does not otherwise declare something, then it can be assumed that the callback is returning only a success or failure code. Callback error codes stored in the \u201cerrno\u201d field should be kept logically separate from regular API errors codes.","In this embodiment, success may be denoted with the return of integer value \u201c1\u201d and failure is denoted with an integer value of \u201c0.\u201d This may be done so the NOT Boolean operator can be applied to the return value to determine if success or failure occurred.","Hardware Architecture","In one embodiment, the security mechanism selected for providing VDP security may directly affect the VDP API. Ideally, the VDP API should be transparent of any SSL\/TLS-based tunnel established between nodes. In the case, depending on the technology chosen, it may need to be integrated into the VDP API.","Interfaces","Structures","In one embodiment, exemplary structures used by this API may include:",{"@attributes":{"id":"p-1046","num":"1481"},"tables":{"@attributes":{"id":"TABLE-US-00047","num":"00047"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"VDP API Structures"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Listener","Encapsulates all of the fields needed by"]},{"entry":[{},"the Listener component"]},{"entry":["Connection","Encapsulates all of the fields needed by a VDP"]},{"entry":[{},"connection"]},{"entry":["ReaderWriter","Encapsulates all of the fields needed to perform a"]},{"entry":[{},"Read or Write on a file descriptor"]},{"entry":["ConnectionCallbacks","Encapsulates all of the callbacks invoked during"]},{"entry":[{},"the normal operations of a connection"]},{"entry":["ConnectionStats","Encapsulates all of the statistics maintained for a"]},{"entry":[{},"connection"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, the Listener structure may include:",{"@attributes":{"id":"p-1048","num":"1483"},"tables":{"@attributes":{"id":"TABLE-US-00048","num":"00048"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"VDP API Listener Structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field Name","Field Type","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["socket","Socket Descriptor","Holds the socket descriptor for the listening"]},{"entry":[{},{},"socket connection"]},{"entry":["address","struct sockaddr_in","Local address\/port that the Listener socket is"]},{"entry":[{},{},"bound to"]},{"entry":["state","VDPListenerStates","The current state of the Listener socket"]},{"entry":["allocateConnection","Callback","Invoked when a new connection structure is"]},{"entry":[{},{},"needed for a new incoming connection."]},{"entry":["connectionEstablished","Callback","Invokedwhen a new connection has been"]},{"entry":[{},{},"established"]},{"entry":["listenerError","Callback","Invokedwhen the listen( ) or accept( ) socket calls"]},{"entry":[{},{},"return an error"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, the Connection structure may include:",{"@attributes":{"id":"p-1050","num":"1485"},"tables":{"@attributes":{"id":"TABLE-US-00049","num":"00049"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"VDP API Connection Structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field Name","Field Type","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["header","VDPHeader","VDP header structure used when receiving packets"]},{"entry":[{},{},"to peek the packet header data before pulling it off"]},{"entry":[{},{},"the socket buffer."]},{"entry":["io","VDPReaderWriter","IO structure that contains all of the fields needed"]},{"entry":[{},{},"by vdpRead and vdpWrite to read and write VDP"]},{"entry":[{},{},"packets to and from an OS descriptor"]},{"entry":["remoteAddress","struct sockaddr_in","Socket address structure containing the address"]},{"entry":[{},{},"and port of the remote connecting client"]},{"entry":["state","VDPStates","The current state of the VDP connection"]},{"entry":["statistics","VDPConnectionStats","Structure containing all of the statistics of the"]},{"entry":[{},{},"connection object"]},{"entry":["callbacks","VDPConnectionCallbacks","Structure containing all of the callbacks used by"]},{"entry":[{},{},"the connection"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, the Reader Writer structure may include:",{"@attributes":{"id":"p-1052","num":"1487"},"tables":{"@attributes":{"id":"TABLE-US-00050","num":"00050"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"VDP API readerWriter Structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field Name","Field Type","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["descriptor","int32_t","Operating system descriptor to use for the IO operations. This"]},{"entry":[{},{},"could be a file, IPC, or socket descriptor."]},{"entry":["buffer","void*","The buffer to use for the destination of read operations or the"]},{"entry":[{},{},"source of the send operation"]},{"entry":["length","int32_t","The length in bytes of the buffer field in this structure"]},{"entry":["read","Callback","Invoked when a read operation needs to be performed"]},{"entry":["write","Callback","Invoked when a write operation needs to be performed"]},{"entry":["allocatePacket","Callback","Invoked when the connection component needs a new packet"]},{"entry":[{},{},"buffer for an incoming packet. The connection component will"]},{"entry":[{},{},"provide the size buffer that is needed for the packet."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, the ConnectionCallbacks structure may include:",{"@attributes":{"id":"p-1054","num":"1489"},"tables":{"@attributes":{"id":"TABLE-US-00051","num":"00051"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"VDP API ConnectionCallbacks Structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field Name","Field Type","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["stateChanged","int32_t","Invoked when the state of the connection"]},{"entry":[{},{},"has changed at any time"]},{"entry":["protocolError","void","Invoked when the connection received an"]},{"entry":[{},{},"invalid packet or an attempt was made to"]},{"entry":[{},{},"send an invalid packet"]},{"entry":["systemError","void","Invoked when a critical system call such"]},{"entry":[{},{},"as send or recv returns an error"]},{"entry":["packetRecieved","int32_t","Invoked when a valid packet has been"]},{"entry":[{},{},"received for processing"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, the ConnectionStats structure may include:",{"@attributes":{"id":"p-1056","num":"1491"},"tables":{"@attributes":{"id":"TABLE-US-00052","num":"00052"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"VDP API ConnectionStats Structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field Name","Field Type","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["connected","time_t","Timestamp for when the connection"]},{"entry":[{},{},"was made"]},{"entry":["inputPackets","uint32_t","Number of input packets received on the"]},{"entry":[{},{},"connection"]},{"entry":["outputPackets","uint32_t","Number of packets sent on the connection"]},{"entry":["ignoredPackets","uint32_t","Number of packets that were ignored or"]},{"entry":[{},{},"dropped"]},{"entry":["inputBytes","uint32_t","Number of bytes (from valid packets)"]},{"entry":[{},{},"received on the connection"]},{"entry":["outputBytes","uint32_t","Number of bytes (from valid packets)"]},{"entry":[{},{},"sent on the connection"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Functions","In this embodiment, there may be four basic function groups available to user of the VDP API:\n\n","In this embodiment, exemplary Listener functions may include:",{"@attributes":{"id":"p-1060","num":"1498"},"tables":{"@attributes":{"id":"TABLE-US-00053","num":"00053"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"VDP API Listener Functions"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Function Name","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["vdpCreateListener","Used to create a Listener component"]},{"entry":["vdpStartListener","Used to start a Listener component"]},{"entry":["vdpPauseListener","Used to pause a Listener component."]},{"entry":["vdpResumeListener","Used to resume a pause Listener component"]},{"entry":["vdpTerminateListener","Used to terminate a Listener component"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, exemplary Connection functions may include:",{"@attributes":{"id":"p-1062","num":"1500"},"tables":{"@attributes":{"id":"TABLE-US-00054","num":"00054"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"VDP API Connection Functions"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Function Name","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["vdpCreateConnection","Creates a client-based connection component"]},{"entry":["vdpRead","Reads a VDP packet from a I\/O descriptor"]},{"entry":["vdpWrite","Writes a VDP packet to a I\/o descriptor"]},{"entry":["vdpSendOOB","Sends a packet out-of-band"]},{"entry":["vdpReceivePackets","Main packet reception function. Blocks until"]},{"entry":[{},"the connection terminates."]},{"entry":["vdpValidatePacket","Validates a VDP packet for content, state,"]},{"entry":[{},"and correctness"]},{"entry":["vdpShutdownConnection","Shuts down a VDP connection"]},{"entry":["vdpCreateHeader","Creates a VDP header using a passed buffer"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, exemplary Helper functions may include:",{"@attributes":{"id":"p-1064","num":"1502"},"tables":{"@attributes":{"id":"TABLE-US-00055","num":"00055"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"(U)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Function Name","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["getInterfaceAddress","Returns the address of a passed interface name"]},{"entry":["getHostAddress","Returns the address of a passed hostname,"]},{"entry":[{},"local or otherwise"]},{"entry":["vdpPrintError","Generic function for printing VDP and system"]},{"entry":[{},"errors to stdout"]},{"entry":["vdpSetError","Sets \u201cerrno\u201d a VDP specific error code"]},{"entry":["vdpChangeIO","Used to change the fields assigned to a"]},{"entry":[{},"ReaderWriter Structure"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"In this embodiment, a purpose of the Assured File Transfer (AFT) Guard is to minimize risks introduced when a file passes between domains and to enforce the file transfer security policy of the site. The Guard may be located at the boundary point between the high-side domain and the low-side domain. When a user on either the high-side or a low-side wants to pass a file across domains, they may log into the Guard, upload their file and the Guard will either clean the document or reject it according to site policy,.","In this embodiment, during the content inspection process, if AFT finds content that is against site policy (i.e.: a specific file type not permitted) or if it can not determine the file type, the file may be rejected, and in the case of the high-side, the user is notified. Files that are permitted for submission may be checked by the AFT Clean processes.","In this embodiment, in the case of files submitted from high-to-low, the Clean processes within AFT can modify the submitted file to remove disallowed material. The modified file may then be presented back to the high-side user for review. If the high-side user determines the new file to be satisfactory, they can approve the file to continue processing. If they do not like the resulting file they can discontinue the process.","In one embodiment, AFT supports the option to include a Foreign Disclosure Officer (FDO) in the file transfer process. The FDO, for example, serves as the government release authority and many sites mandate a two-person release policy. Individuals may not disclose technical information without approval of the FDO. If configured to support an FDO review process, the FDO gets to review the modified file after it is approved by the high-side user. After reviewing the file, the FDO may either approve or disapprove of the transfer. If approved, the file is sent through a second part of the content examination process. If the file is disapproved by the FDO, the user will get notified and processing will terminate.","In this embodiment, if the high-side submitted file passes the final set of inspections (which may have a different security policy than the first set of inspection filters), the file may be sent to a low-side repository where it will be picked up by a registered low-side user.","In this embodiment, the AFT process to support low-side user submitted files may not be exactly the same process as from high-to-low. Low-side users are preferably not, at any point, given the chance to review after the first cleaning process. Files can be sent through both sets of inspection engines. If the files fail, the low-side user is notified that it failed but without reasons on why it failed. If the file is successful in passing the Guard filters, notification is sent to the high-side user whom the file is being sent to, where they can then log in a download the file unto their local computer.","General Functionality","In one embodiment, AFT provides user on both sides of the security boundary the ability to send and receive files to and from either designated users or user groups. To ensure the AFT is providing proper security checks and to maintain a record of security related activities, a robust audit system may be provided. In the transfer process described above, user and release authority actions may be recorded and stored in a fashion that preferably does not allow for user intervention.","In one embodiment of the AFT system, users do not push data into the other security domain, they transfer files into a protected repository where authorized users can retrieve them once they properly authenticate to the Guard. Transfers can be initiated by authorized users and can only send files to authorized users or user groups.","In this embodiment, files may be comprised of data in a number of formats. The AFT content inspection processes examine the files in a fashion dependant upon the file types. The AFT inspection processes may not address all known file types and those files that contain data in a format not addressed by an inspection process are preferably not transferred.","System Architecture","In this embodiment, a high-level functional diagram of AFT and examples of the various people that use AFT is shown in .","In this embodiment,  illustrates four types of interactive AFT users; high-side users submitting and retrieving files, Foreign Disclosure Officers approving file transfers, low-side users submitting and retrieving files and systems administrators.","In this embodiment, AFT interfaces may be web-based. This allows maximum interoperability with end user workstations. Each interface may be logically separated within AFT to provide security separation. The processes that perform the actual content inspection may also be logically separated between the directions of the file flows.","In this embodiment, system administration may be done via a directly attached console port. The system administrators configure user accounts, inspection filter settings and lists, audit accounts and perform periodic maintenance on the systems. For security reasons, it is preferably to not have support for remote administration.","In this embodiment,  shows more details of an example of the AFT low-level architecture. The Guard may include many interconnected components and subcomponents. Each box in  may be a separate process that is controlled by the operating system. Strict enforcement by the operating system may limit the actions of each process. This enforcement creates a defense in depth mechanism to anyone looking to subvert the system.","In this embodiment, to simplify discussion, the overall architecture has been broken down into four major components. The relationships of these components are shown, for example, in .","In this embodiment, the Platform Components describe the base functions of the AFT system. These may include:\n\n","In this embodiment, the next layer that utilizes the Platform Components are the Common Components. These components provide functions that support the initialization, communication and monitoring of the filtering processes. Processes that may be included as part of the Common Components are:\n\n","In this embodiment, Structural Components perform the operations necessary to support recursive file filtering. The processes that may be included in this section are:\n\n","In this embodiment, the Interface Component handles communications with end users, FDOs and system administrators. It may include:\n\n","In this embodiment, the processing and data storage requirements for AFT may be different from those in CAB. While CAB is concerned with low-latency, small-packet sessions, AFT is more concerned with large file processing and file duplication. The storage subsystem for AFT may be developed with future inter-guard communication.","Processor Support","In this embodiment, AFT may use the same central processing unit (CPU) architecture as CAB, for example, AMD64\/EM64T. AFT may also be based on a 64-bit kernel and where not constrained by third-party products, 64-bit applications. The primary advantage of 64-bit is the size of memory that is supported and the efficiency with which the memory can be accessed. 32-bit has a 4 GB limit after which memory segment registers are manipulated to address additional \u201cchunks\u201d of 4 GB.)","Network Interfaces","In this embodiment, the guard may need multiple network interfaces to support the user, security and availability requirements. These network interfaces may include to the:\n\n","Disk Storage Subsystem","In this embodiment, AFT preferably handles large files, which, in one embodiment, may be up to 512 M, handle files from a large number of users (e.g., up to 20,000 in one embodiment), and preferably retain the processed files for weeks. AFT may be preferably scalable to support up to 3,000 simultaneous users, which, in one embodiment, may dictate that multiple guards will be needed and each of the guards will need to access the retained data. Examples for the disk storage subsystem include Direct Attach Storage (DAS), Network Attached Storage (NAS), and Storage Attached Network (SAN). SAN has the advantages of being easily expanded, easily shared by multiple guards, and is simpler than NAS. Therefore, in one embodiment, the preferable storage subsystem for AFT may be a SAN device. The method by which the SAN is managed may be determined by the hardware vendor selected. RAID arrays normally provide a GUI interface for configuring and monitoring the array. The GUI may provide facilities to define virtual volumes, modify volume size, define RAID levels, view status, and perform recovery operations. Some RAID arrays also provide an e-mail notification facility.","Multi-tiered Storage Subsystem","In one embodiment, use of a multi-tiered storage subsystem allows the selection of a much less expensive SAN architecture without significant performance impact. The \u201cfast\u201d tier of the storage subsystem may be high-speed (e.g., SCSI) DAS that is not shared between guards. In general, DAS may be used for the file systems used by the filters and SAN may be used for file systems associated with the repositories (High-Side Out, Low-Side Out, User R&R, FDO R&R), configuration files, and system files that will be shared between guards. In Linux, a storage device may be used by defining a file system on the device and then mounting the file system. Applications access the file system by the name with which it was mounted and do not need to know on which device(s) the file system resides. Since the application is not aware of which device the file system resides or on which tier the device resides, the tier on which files reside is transparent to the applications. Movement of the data between tiers is accomplished automatically as files are copied from one directory to another.","Storage Capacities","In one embodiment, the directories used by the filter and verify processes are not used for long-term retention of data, but are used while the data is actively being worked on. These directories may be referred to as \u201cwork\u201d directories. Internal DAS (i.e.: hard drive) on each guard may be used for the \u201cwork\u201d directories. Since the data may be read\/written many times during processing in the clean and verify processes, these directories preferably have high throughput. Each guard preferably has a minimum 500 GB (effective capacity) of high-speed internal disk storage.","In one embodiment, a SAN with 6 TB to 8 TB effective capacity would be sufficient for most envisioned scenarios.","Connections","In this embodiment, examples of technologies for connecting the SAN to the AFT are Fiber Channel (FC) and Internet SCSI (iSCSI). FC has traditionally been used in high-end networks where reliability and performance concerns override the relatively higher cost. iSCSI is a newer technology that takes advantage of the riding over existing IP networks at the loss of some throughput. However, since GB Ethernet has become a commodity and with the emergence of 4 GB and 10 GB Ethernet, an iSCSI connection need not be slower than either 1 GB or 2 GB FC.","One of the disadvantages of iSCSI has been the additional load imposed on the host to process the IP packaging of the data. There are currently available iSCSI HBAs that offload the processing from the host. iSCSI HBAs may cost approximately 50 percent of the cost of an FC HBA. Either technology will preferably include a switch for connecting multiple hosts. To eliminate the switch as a single point of failure, dual paths with independent switches should preferably be used. An Ethernet switch may be approximately half the cost of an FC switch of similar capabilities.","Storage Array","In one embodiment, the SAN device can be a JBOD or RAID array. The advantages of using a JBOD array are lower cost as there is no \u201cintelligence\u201d in the array. Each disk may be exposed to the host as an independent volume. With a JBOD array, it may be necessary to use a Logical Volume Manager (LVM) to treat multiple disks as a logical unit, perform mirroring, stripping, parity generation, logical volume expansion, etc. With a RAID array, the array itself has the ability to perform these functions. The overhead on the host to perform mirroring, stripping, and volume expansion is relatively low. However, the overhead to do RAID 5 on the host may be significant both in the effect on host CPU utilization and throughput. In a multi-guard environment, the use of an LVM may require that the LVM configuration information be coordinated among the hosts, whereas on the RAID array the configuration information is in the array. For performance and operational ease, the RAID array is the preferred solution.","Most RAID arrays provide a Web or GUI interface for configuration and status information. Some also provide the capability of e-mail alerts for status\/problem notification.","Disk Type","In one embodiment, the selection of the types of disk drives, SSD, SCSI or SATA II, may be primarily a matter of cost. SSD could provide higher performance than is needed at a prohibitive cost. SATA II drives are normally slower than SCSI drives (7200 RPM vs. 10000 RPM), are less reliable than SCSI drivers, and implement a less complete command set. SATA II drives are less expensive and tend to have a higher capacity. Since file access will be largely sequential rather than random, the slower seek time of the SATA drives is less important due to the operating system read-ahead support. The lower reliability of SATA drives can be offset by using mirroring or parity, which would be used even if SCSI drives are selected.","For the DAS subsystem, performance may be a very high priority. In one embodiment, it is on the DAS that the files will be copied multiple times as they move between processes. There is no requirement that the type of disk drive used in the SAN be the same type as those used for DAS.","Cryptographic Accelerator","In this embodiment, since the interfaces to AFT may be Web-based, the requirement for 3,000 simultaneous user sessions might put a burden on the AFT HTTP server.","In one embodiment, the AFT system uses Transport Layer Security (TLS) to provide confidentiality, integrity, and authentication services between users and the Guard. Under the expected network loads, the Guard is responsible for communicating across a large number of encrypted links. Given that asymmetric cryptography is an computer intensive operation and that numerous symmetric cryptographic operations would further burden the Guard CPU(s), the AFT Guard may employ specially designed cryptographic accelerator cards to free up core Guard processing for its core function, file inspection.","In this embodiment, the Guard may have separate interface processes for the high- and low-side user and FDO roles because each process preferably has its own cryptographic accelerator. Additionally, the different security domains of the connected networks dictate that it is preferably that no single process is permitted to communicate with more than one interface.","The AFT system may leverage the research performed on the CAB project, discussed above, by using, for example, the same nShield accelerator cards manufactured by nCipher. Because of the increased data transfer requirements of AFT, it may be necessary to substitute a higher performance card from the same family","Time Synchronization","In one embodiment, the guard requires access to a timeserver to ensure that the clocks between guards and between nodes within a guard are synchronized. Guard clocks may be synchronized using NTP. Each guard node will preferably access an NTP master of stratum I clock from the high side network.","Operating System","In this embodiment, the operating system (OS) is the system software responsible for controlling and managing hardware and basic system operations. In a self-protecting application such as the AFT guard, the OS may secure the flow of information and enforces the separation of sensitive data. In one embodiment, the AFT OS is based on the RedHat Enterprise Linux 4 Advanced Server (RHEL 4 AS), customized to remove all unneeded packages to eliminate excess code that might be vulnerable to exploits that yield unauthorized access to the system. RHEL 4 also includes Security Enhanced Linux (SELinux) facilities that separate guard components into security domains, and enforces mandatory access control (MAC) over the interactions between the domains. Access controls may be encoded in the SELinux type-enforcement policy, which embodies the architectural design of the system. The components and data flows reflected throughout the AFT architecture were specifically designed to fit well into a SELinux security policy.","In this embodiment, the OS component may also include the iptables firewall software that helps secure the system's network interfaces. Iptables provides the first line of defense against unauthorized access by restricting access to specific, approved network resources. It inspects network traffic as it comes off the wire, before it reaches the internal components, and accepts or rejects it based on a rule set that describes which traffic is or is not permitted. It can base its decision on Internet Protocol (IP) address, port, protocol, network interface, and traffic direction. It is configured to allow only encrypted connections with authenticated client machines. Any other connection attempts are logged and dropped.","Security Enhanced Linux","In this embodiment, RHEL 4 also includes Security Enhanced Linux (SELinux) facilities that separate guard components into security domains, and enforces mandatory access control over the interactions between the domains. With SELinux, root functionality is split into roles. Mandatory access control separates permissions for users, programs, processes, files, and devices. Specific applications are granted only the permissions they need to function. All access controls are encoded in the SELinux type-enforcement policy, which embodies the architectural design of the system. The components and data flows reflected throughout the AFT architecture were specifically designed to fit well into a SELinux security policy.","Firewall","In this embodiment, the OS component also includes the iptables' firewall software that helps secure the system's network interfaces. Iptables provides the first line of defense against unauthorized access by restricting access to specific, approved network resources. It inspects network traffic as it comes off the wire, before it reaches the internal components, and accepts or rejects it based on a rule set that describes which traffic is or is not permitted. It can base its decision on Internet Protocol (IP) address, port, protocol, network interface, and traffic direction. It is configured to allow only encrypted connections with authenticated client machines. Any other connection attempts are logged and dropped.","Network Time Protocol","The Network Time Protocol (NTP) is used widely on the Internet to synchronize computer time to a common clock. In this embodiment, in AFT, NTP is preferred to provide accurate time stamps on audit logs, across processes and across multiple guards in larger configurations. NTP provides comprehensive mechanisms to access national time services, time distribution by means of a local subnet and adjust the local clock in each participating node. NTP provides accuracies of 1-25 ms, depending on the characteristics of the synchronization source and network paths. NTP may be provided by the sites high side network.","File System","In this embodiment, for file systems on the SAN that will be shared R\/W by multiple nodes, the standard Linux ext2 and ext3 file systems are insufficient. Without a file system that is designed to be write-shared by multiple hosts, the file system and the data in it would soon be destroyed. It is therefore preferably run a Cluster File System (CFS). Exemplary CFSs include GFS, Lustre, PVFS2, IBM's GPFS, and SGI's CXFS. Lustre may not be preferably because it only supports object-oriented devices. PVFS2 support for extended attributes is still under development and it is not POSIX-compliant, therefore it is not a preferably alternative. From a security perspective, a CFS that supports security xattrs is preferred to the context-mount labeling alternative.","Cluster Management Software","In this embodiment, GFS requires the cluster manager and a global lock manager available in the RedHat Cluster Package that comes with GFS. The cluster manager has the capability to provide a High Availability (HA) cluster, primarily through application failover in the event of a node failure. Since all nodes in the guard cluster may be running the same application, this feature is not very useful. However, the cluster management software is used in conjunction with GFS to monitor node health and fence failing nodes to prevent corruption of the file system.","Logical Volume Manager","In this embodiment, the Logical Volume Manager (LVM) is software that supports virtualization of disks. For example, using LVM, the user can define a logical volume that spans multiple physical disks so that a file system can be larger than any available physical disk, is stripped for increased performance, is mirrored for redundancy, etc. LVM can also be used to create multiple logical volumes on a single disk so that file systems can be smaller than the physical unit size. If the selected hardware for the SAN is a simple JBOD, LVM may be used to manage the storage on the SAN.","Directory Structure","In this embodiment, the AFT directory structure may be designed to maximize file-system sharing between multiple Guards. This simplifies system administration and Inter-Guard Communications (IGC). Towards that end, the Guards may use a custom kernel that allows them to mount their root partitions from the SAN during normal operation.","In one embodiment, the kernel, some configuration files, all temporary files, and system log files preferably reside on the local disk. In addition, an alternate boot option allows a minimal system to be loaded entirely from the local disk for low-level maintenance or troubleshooting tasks that require it. Therefore, the local disk may use the standard Linux directory structure. Shared configuration files, executables, databases, file repositories, and log files may be stored in similar directories on the SAN to meet disk space requirements, ease system administration, or facilitate IGC.","System-Specific Files","In one embodiment, system-specific configuration files in\/etc are symbolically linked to a mount point on the local disk. These symbolic links are present on both the local and SAN-mounted root partitions so that boot, maintenance and normal processing can access the correct files for each individual guard system.","In this embodiment, each guard platform preferably requires its own set of OS kernel, configuration, temporary and log files. These files may reside in internal disk storage within each guard platform. These files are few in number, and some will be symbolically linked to locations outside the root (\/) partition mounted from the SAN.","Kernel","In this embodiment, the kernel and modules required to initiate a boot sequence may be stored locally in the\/boot partition of each Guard system.","Configuration Files","In this embodiment, the system configuration files in the\/etc directory that are preferably unique between multiple Guards (i.e., be shared between them) are the\/etc\/sysconfig subdirectory. This subdirectory is symbolically linked to the\/loc\/sysconfig subdirectory. This allows the\/etc directory to be mounted via the SAN without overlaying configuration files that must remain unique to each guard. These files set the system hostname and IP addresses.","Temporary Files","In one embodiment, temporary files reside on the local disk. The\/tmp directory is always mounted locally, so temporary files created there are of no concern. The\/var directory is mounted via the SAN, so temporary files created therein require symbolic links. Those files always reside in the\/var\/lock, Ivar\/run and\/var\/tmp subdirectories, so they are symbolically linked to\/loc\/lock,\/loc\/run, and\/loc\/tmp, respectively, to ensure each system's temporary files do not collide when\/var is mounted via the SAN.","Log Files","In this embodiment, system log files may reside in\/var\/log. It is symbolically linked to\/loc\/log so each system's logs don't collide when\/var is mounted via the SAN.","Design Decisions","In this embodiment, security may be the most important aspect of the operating system subcomponent because the operating system allocates and controls resources. A failure in the operating system could violate the integrity of the AFT security model, resulting in contamination or unauthorized disclosure of data. Because of the AFT system processes' highly sensitive data, when unexpected behavior occurs, the system enters maintenance mode so that the system can be verified. Once an administrator has corrected any problems and verified system integrity, AFT can resume production mode. Maintenance mode is explained later.","Decision to Develop or Reuse","In this embodiment, AFT reuses operating system components developed for the CAB CDS wherever possible. In particular, the CAB startup and shutdown scripts and can be reused almost verbatim. Portions of the SELinux policy pertaining to startup and shutdown should be reusable. The firewall rules can be modified for the AFT interfaces. The RPM specification files can be modified to build AFT packages. Other OS-related objects will most likely be developed from scratch because of the differences between the CAB and AFT internal components.","Interface Related Design Decisions","In this embodiment, to function correctly, the AFT components may depend on services provided by the operating system, such as domain separation and control over data flows. In addition, AFT uses the operating system's boot and initialization procedure to start the AFT Initialization process, which in turn starts the various Guard components. When the AFT system shuts down or transitions into maintenance mode the AFT shutdown process must invoke the operating system's power management subsystem to enable the machine to physically turn off or reboot.","Performance Related Design Decisions","In one embodiment, the customized version of RHEL 4 AS built for AFT is a stripped down version, containing the minimum set of packages and processes. In addition to providing security, it improves performance. The AFT operating system may also use a standard SELinux kernel, performance-tuned for the AFT system.","Safety, Security, and Privacy Design Decisions","In this embodiment, RHEL 4 AS with SELinux may be the primary mechanism for enforcing separation of system objects into protected domains, thereby providing safety, security, and privacy. Objects in one domain can preferably only access objects in another domain if they are explicitly permitted to do so. Therefore, information preferably cannot be transferred between domains except through well-known mechanisms specified in the system's policy.","Installation Considerations","In one embodiment, the installation process may use a modified Red Hat Kickstart script. After the system has been installed, a hardening script may execute. The script may address the specific Guard needs.","Flexibility, Availability, and Maintainability Design Decisions","In this embodiment, in order for the system to be maintainable there preferably is a mechanism for installing and updating the packages on the system. For example, RHEL 4 AS uses the RPM package management system for maintaining groups of files on the system. RPM on the AFT system can preferably only be accessed by a system administrator in the AFT maintenance mode policy, described below.","Common Components","Overview","In this embodiment, the Common Components support the initialization, communication, monitoring and overall health of the AFT platform and its various filtering processes. Collectively, they provide the framework for the AFT system.","INIT","In one embodiment, the System Initialization component (also referred to as the AFTInit process) works with the system monitoring components (heartbeat monitor, performance monitor, and shutdown monitor) to establish, maintain, and monitor the state of the guard system components. The System Initialization component may consist of system integrity checks, file integrity checks, and the startup sequence.","In this embodiment, the Initialization subcomponent is charged with verifying that the system is in a trusted state before activating the AFT components. If the system detects an anomaly such as a file that fails an integrity check, the system preferably immediately stops initialization. In this event, initialization halts all processing and then puts the system into a maintenance mode or completely shuts the system off by powering it down. Because an anomaly of this sort should never occur while the system is booting, there is no attempt to automatically repair or recover the process or file. Such recoveries, if necessary, must be performed manually by an administrator.","In one embodiment, the AFTInit process subcomponent is the first AFT subcomponent to start during system boot. Its tasks include verifying integrity by checking the signatures of all AFT-related files in the system, verifying that\/dev contains only the device files needed by AFT, and verifying that only necessary processes are running in the system. If any of the verification tasks return a failure error code or detect an anomaly, AFTInit notifies Audit (if available, otherwise, it logs to a file) and shuts the system down. Once the integrity checks have verified that the system is in a trusted state, it is safe to start up the remainder of the AFT processes. Each AFT process is executed by AFTInit, thereby causing an SELinux domain transition for each process into its own domain. When all AFT processes have been started successfully, the AFTInit process uses the shared Wire Protocol to send the shutdown monitor the process IDs of the processes that it has initialized. Once AFTInit has delivered the process IDs, it has completed all of its responsibilities and exits leaving the heartbeat monitor, performance monitor, and shutdown monitor to monitor system health.","In one embodiment, the file integrity verification mechanism used by AFT is supplied by the open-source file integrity tool, Samhain.","In one embodiment, AFTInit initializes the guard processes in the following order:\n\n","In this embodiment, as an implementation point, because the AFTInit child processes preferably remain functioning after their parent process exits, each AFT process preferably becomes a daemon. This may be achieved, for example, as follows:\n\n","Performance-Related Design Decisions","In this embodiment, the operating system and environment subcomponents are preferably designed to be as efficient as possible. However, security may be a greater concern and many of the elements only run during start up and shut down, making performance less critical. The file integrity check, for example, verifies that critical system files have not been tampered with by computing a cryptographic checksum\u2014a somewhat resource-intensive operation. Because the file integrity check only runs at startup, performance is not a critical concern.","Security Design Decisions","In this embodiment, establishing and verifying a secure, known system state is the main goal of the System Initialization subcomponent. Because the initialization process includes the invocation and coordination of most of the AFT subcomponents, it preferably has a higher privilege of most processes. In one embodiment, the principle of simplicity, as applies to AFT, dictates that the most privileged components should be the simplest. Therefore, initialization may be decomposed into several pieces to reduce complexity.","In this embodiment, the decomposition may consist of creating multiple small initialization elements and assigning each one the absolute minimum of privileges needed and by limiting communication with other components using the underlying SELinux security policy. For example, the file integrity checks needs to read files spanning multiple security domains, and therefore execute in a separate domain from the AFTInit process from which they are invoked. The domain in which the AFTInit process executes does not require all of the privileges required by the file integrity checks; rather, the integrity checks perform domain transfers upon execution, and complete their execution with the appropriate privileges.","Inter-Process Communication","In one embodiment, the purpose of the AFT Inter Process Communication (IPC) Component is to create standard mechanisms for communication between processes and threads. AFT IPC may be comprised of two subcomponents:\n\n","In this embodiment, most inter-process communication will occur using CAB IPC; AFT queues are used where additional functionality is required.","Decision to Develop or Reuse","In this embodiment, the CAB IPC component may be reused by AFT. For details on the CAB IPC component, see above discussion under CAB. AFT queues may be new development as the needed functionality may not exist with CAB IPC.","Interface-Related Design Decisions","In one embodiment, AFT queues will have the following characteristics:\n\n","In this embodiment, items 1, 2, 6, and 7 are characteristics that differentiate CAB and AFT message queues. Item 1 may be required to allow sharing of the message queue between multiple guard nodes to facilitate load balancing. Item 2 may be needed to allow prioritization of messages, rather than a strict FIFO implementation as performed by CAB IPC. Item 7, in conjunction with item 1, may be used for load balancing and distribution of work between guard nodes (CAB IPC supports multiple writers\/single reader). Item 6 may be a \u201cnice-to-have\u201d feature to allow components to control workloads and for performance monitoring, but may not be available for readers and writers because of domain separation considerations.","Performance-Related Design Decisions","In this embodiment, AFT queues may not have the severe latency requirements of the CAB IPC. Using memory-mapped files for the queues may provide enhanced performance.","Security Design Decisions","In this embodiment, the files associated with the AFT queues may be in directories protected by SELinux policy to ensure that only the appropriate processes can read\/write into\/from the message queue. High-to-low, and low-to-high queues may have different security context even when accessed by \u201csimilar\u201d components. For example, the message queue between the input repository manager and the first stage of clean is different for high to low and low to high and has a different security context.","Authentication","In one embodiment, AFT supports both weak and strong authentication. Weak authentication occurs in two phases. First, the Guard authenticates itself to the Client during TLS session establishment, using certificate-based mechanisms provided by the organizational Public Key Infrastructure (PKI). Second, the user authenticates to the Guard with a username and password after TLS session establishment has completed. The two phases may be handled by the HTTP server and Transfer Agent components, respectively. Weak authentication is so-named because a Man in the Middle (MITM) attack is possible when the TLS session is established before both entities have authenticated.","In this embodiment, strong authentication preferably occurs only during TLS session establishment. Both the Guard and the User authenticate using certificates provided by the site's organizational PKI. Strong authentication is so-named because it prevents MITM attacks by completing authentication as part of TLS session establishment. If a PKI is not present, weak authentication may be used, in accordance with the accreditation guidance.","In this embodiment, the Guard Authentication subsystem may consist of three subcomponents: the High-Side Authentication subcomponent, the Low-Side Authentication subcomponent and the High\/Low Authentication Mapper. The High- and Low-Side Authentication subcomponents may be identical in function, but access different databases associated with the respective user communities. The High\/Low Authentication Mapper hides high-side user identities from low-side users.","In this embodiment, these components may be assisted by a cryptographic accelerator card. This hardware component allows the applications to offload most of their authentication and encryption tasks.","High-Side and Low-Side Authentication","In one embodiment, the High-Side Authentication subcomponent is a daemon that processes weak and strong authentication requests, password change requests, and user profile information requests from the High-Side User and FDO Interfaces. The Interface subcomponents communicate with it via separate IPC channels for the different request types. This simplifies the design by eliminating the need to delineate between message types for each request type. Dedicated thread pools in the Authentication daemon \u201clisten\u201d for requests on each IPC channel.","Weak Authentication","In one embodiment, for weak authentication, the Interface Transfer Agent subcomponent presents username and password credentials via the weak authentication IPC channel, and the Authentication component sends a response on the same channel indicating whether the credentials are valid. The following response types are possible, which enables the Transfer Agent to tailor its response to the user appropriately.\n\n","Strong Authentication","In one embodiment, for strong authentication, the Interface HTTP Server presents a Public-Key Cryptography Standard (PKCS) message for validation against the user's certificate. The HTTP Server is the operative Interface subcomponent, not the Transfer Agent, because strong authentication is performed as part of TLS session establishment. In one embodiment, user certificates are preferably stored on the Guard. The HTTP Server sends the request via the strong authentication IPC channel, and the Authentication component sends a response on the same channel. Possible responses include:\n\n","Password Change","In this embodiment, weak authentication passwords may be changed via the associated IPC channel. The Interface Transfer Agent presents the username, current password, and new password on the channel, and the Authentication component responds on the same channel to indicate whether the request was successful. Response types that are possible, enabling the Transfer Agent to tailor its response to the user appropriately, include:\n\n","User Profile Information","In one embodiment, the High-Side Authentication daemon also processes requests for user profile information from the High-Side User and FDO Interfaces. Specifically, the Interface Transfer Agent subcomponents present a username on the user profile IPC channel, and the Authentication component sends the associated profile data on the same channel. This data includes the following items:\n\n","High\/Low Authentication Mapper","In this embodiment, the High\/Low User Mapper subcomponent enables a non-attributable relationship between high-side and low-side user identities. It may be implemented as a database that maps the high-side user IDs to low-side user IDs. For each high-side user ID number, there may be a one-to-one mapping to a distinct low-side user ID number. The Mapper, therefore, allows high and low Authentication subcomponents to translate from high-side- to low-side user identity.","In one embodiment, for high-to-low transfers, senders' high-side user IDs are mapped to their low-side user IDs so low-side recipients cannot discover high-side IDs when files are delivered. For low-to-high transfers, recipients' low-side user IDs are mapped to their high-side user IDs so low-side senders don't need to know high-side IDs to send files.","Design Decisions","In this embodiment, user authentication to the Guard is preferred to ensure that only authorized users can use the AFT system. Furthermore, confidentiality services are preferred to protect session traffic from eavesdropping. To address these issues, AFT may use TLS to authenticate the network ends and encrypt their traffic. Weak authentication requires a two-phased process in which the TLS session is established before the user presents username and password credentials. The individual phases are implemented via the HTTP Server and Transfer Agent components, which communicate with the High-Side User, High-Side FDO, and Low-Side User Authentication components. For strong authentication, all authentications are accomplished during TLS session establishment via the HTTP Server components, which communicate with the same Authentication components.","In this embodiment, TLS provides confidentiality services for session traffic and weak authentication by encrypting all network traffic. The encryption algorithms are implemented through dedicated cryptographic accelerator cards on the Guard.","Interface-Related Design Decisions","In one embodiment, the Authentication components communicate with other components via a dedicated, asynchronous IPC mechanism, keeping with the overall Security Policy. The IPC mechanism may be reused from the CAB project.","In this embodiment, the Authentication subsystem may use Certicom APIs to communicate with the nShield crypto accelerator cards manufactured by nCipher.","Performance Performance-Related Design Decisions","In this embodiment, TLS authentication uses asymmetric cryptography operations that are computationally intensive, and performing such computations in software puts an excessive burden on the Guard CPUs. TLS encryption uses efficient, symmetric cryptography, but it is used for all connections into and out of the Guard, including those for file transfers. Given the volume of data being encrypted, it is preferable to have optimized hardware perform the cryptography. As is common practice in high-load network servers, AFT is designed to take advantage of specialized cryptographic hardware.","Database Design Decisions","In one embodiment, the Authentication subsystem maintains certificates, user IDs, passwords, user settings, and user preferences. Because of the sensitivity of the data in question, it is preferable to store the data securely and efficiently.","In this embodiment, user passwords may be encrypted to protect them from compromise. Strong password requirements may be the same as those discussed above in CAB.","In this embodiment, session encryption occurring at both the high- and low-side interfaces is transient, and therefore need not be persisted in a cryptographic database.","Security Design Decisions","In one embodiment, the SELinux Security Policy preferably ensures domain separation and control over the direction of data flows between components.","In this embodiment, separate cryptographic operations can take place at the high-side and low-side interfaces, each interface transmitting data at a different level of security. For this reason, the Guard preferably has one cryptographic accelerator card for each security level.","One embodiment of AFT supports at a minimum 1024-bit RSA for key exchange and digital signatures, SHA-256 for hashing, and AES for confidentiality (128-bit blocks in CBC mode). Another embodiment may be \u201cSuite B\u201d\u2014compliant.","In this embodiment, because TLS supports virtual connections, it is possible for the Guard and Translator to have one TLS network connection for multiple virtual user sessions.","Flexibility, Availability, and Maintainability Design Decisions","In one embodiment, the Authentication component generates \u201cheartbeat\u201d signals at regular intervals, as defined by the heartbeat monitor subsystem. If any subcomponent of the authentication subsystem were ever to terminate, the heartbeat signals would cease, thereby indicating a serious problem to the heartbeat monitor. Likewise, if any authentication subcomponent detects a condition rendering it unable to continue processing, it would shut down immediately, triggering the heartbeat monitor to initiate system shutdown.","Heartbeat Monitor","In one embodiment, the AFT Heartbeat and Performance Monitoring subcomponents are responsible for monitoring the health of the AFT system. Upon non-receipt of heartbeats or the inability to collect performance data, an audit message is sent and a shutdown initiated","In this embodiment, the Heartbeat Monitor subcomponent interfaces with other AFT processes and tracks those processes that have checked-in. This minimally determines whether a component is still executing and initiates shutdown on heartbeat errors","In this embodiment, the Performance subcomponent interfaces with the Admin Component to allow the admin to initiate performance collection and view the collected data in a report.","Heartbeat Monitor Description","In this embodiment, the Heartbeat Monitor's main functions are to:\n\n","In this embodiment, AFT components preferably will generate a \u201cheartbeat\u201d at regular intervals, which will allow the Heartbeat Monitor subcomponent to guarantee overall system health. This heartbeat interval is configurable and will be tuned to allow enough time for the process. If a component being monitored dies or enters an illegal state, its heartbeat should cease, thereby indicating a serious problem to the Heartbeat Monitor.","In this embodiment, the AFT process generating the heartbeat will communicate the heartbeat to the Heartbeat Monitor using the IPC. The IPC used by the heartbeat monitor limits blocking so that performance hits resulting from sending and receiving heartbeats will have minimal impact on overall system performance.","In this embodiment, each process that generates a heartbeat needs a thread to handle its heartbeat processing. This heartbeat thread may be started by the main thread of each process\/component and sends a periodic heartbeat to the Heartbeat Monitor. The heartbeat thread receives the heartbeat interval from the configuration data sent to its initiating process at startup. The heartbeat thread will establish a write-only IPC channel to the Heartbeat Monitor and periodically send a simple message indicating that the process is working properly.","In this embodiment, after the basic AFT processes are up and running, and the system is ready to start accepting connections, it is the heartbeat monitor's job to notify audit that the system is ready. Audit will create a record in the audit log and based on the policy notify the shutdown monitor to change the Boolean value and allow access to the network interfaces.","In this embodiment, the heartbeat monitor may consist of two threads in addition to the AFT control threads. The first thread blocks on an IPC mechanism and waits for messages to process. Once a message is received, the thread updates the state table with the information conveyed in the message. Monitored processes are able to send messages without needing to block and wait for the heartbeat monitor to process the message. The second thread is responsible for monitoring the state table and ensuring that all processes contain current heartbeat entries. If a problem is detected, this thread will be responsible for notifying the audit subsystem of an error resulting in the shutdown of the system","Performance Monitoring Description","In one embodiment, the Performance Monitoring subcomponent stores current and historical performance data over a configured period. If for some reason the system is unable to collect performance data, the system cannot be trusted and is preferably shutdown.","In this embodiment, performance data will include, for example, CPU and memory usage data, as collected by operating system utilities, for each process. This data may be checked against configuration tolerances and either log warnings to audit or initiate system shutdown as specified by the action to take as specified in the configuration file.","Software Architecture","In this embodiment, the Heartbeat Monitor along with the Performance Monitor may be responsible for ensuring that processes on the AFT system are functioning properly and have the resources required for effective functioning.","In one embodiment, the Heartbeat Monitor is the first process started by the AFT Initialization process because it needs to be available when each of the other AFT processes starts running. The heartbeat monitor is capable of receiving types of messages such as:\n\n","In one embodiment, once a message is received, the heartbeat monitor will update a table that records the state of processes. The table may consist of two fields, a field for the current state of the process, and a field for the last time it was updated. Periodically, the heartbeat monitor will check its table to make sure that every running process has an entry in the table with a recent timestamp. Once a process starts up, it notifies the heartbeat monitor that the process is running and that it should start expecting to receive heartbeats periodically. While the system is running, the heartbeat monitor will monitor the table, and if a process has a timestamp that exceeds the defined heartbeat period, it is assumed that the process is no longer able to function. In the case where a process chooses to exit cleanly, the process preferably sends a shutdown message that notifies the heartbeat monitor that the process is explicitly exiting and that it should no longer expect to receive heartbeats. If however, a heartbeat is received after the process has sent a shutdown message, then that is an indication that something has gone wrong and the process was unable to shutdown. Not receiving a heartbeat in a reasonable time and receiving a heartbeat from a process that should have shutdown are both events that may result in the system being shut down.","In one embodiment, the heartbeat monitor starts up and enters the running state where it receives messages from processes announcing that they have started up. Once processes have started, the system waits to receive heartbeats. If a heartbeat is not received within the specified time, the message is overdue and a message is sent to audit. Once audit is notified, the heartbeat monitor waits for a message from the shutdown monitor instructing the process to shut down. The heartbeat monitor then transitions to shutdown and exits. Otherwise, when the shutdown monitor receives a shutdown message, the heartbeat monitor transitions from the receiveHeartbeat state to the shutdown state and exits.","In one embodiment, the heartbeat monitor will be used by the Guard system components. In each case, the heartbeat monitor will receive data from numerous processes on the system via the shared Wire Protocol. The first message sent to the heartbeat monitor may be a message containing the process id and the process type. This may be a one-way communication channel, where the heartbeat monitor will preferably receive data.","In this embodiment, in addition to receiving heartbeat messages, the heartbeat monitor may also interface with the Audit and Shutdown subcomponents.","In this embodiment, the Performance Component may be integrated with the configuration file subsystem and will interact with the init and audit subsystems.","In one embodiment, the performance monitor receives performance data from audit along and passes the results to the init performance component so that it can determine whether the machine is running within acceptable parameters, if not init performance will be able to shut the system down.","Decision to Develop or Reuse","In this embodiment, the AFT Heartbeat monitor may reuse software modules written for the CAB CDS to provide much of the Heartbeat monitor capability. AFT-specific functionality may be implemented as needed.","Performance-Related Design Decisions","In this embodiment, the Heartbeat Monitor subcomponent may use IPC to receive the heartbeat from the AFT processes. The IPC used by the heartbeat monitor limits blocking so that performance hits resulting from sending and receiving heartbeats will have minimal impact on overall system performance.","In this embodiment, the Performance Monitoring subcomponent of the system preferably has a minimal impact on performance whenever performance data is collected. Periodically the performance component will execute system utilities, read from files in the proc file system, and receive data from other AFT components. In addition to collecting the data, the performance component also processes it and sorts out all relevant data before storing the data.","Database Design Decisions","In this embodiment, the Performance Component may use a database to store and retrieve collected performance data.","Security Design Decisions","In this embodiment, the Performance Component preferably relies on the SELinux policy to provide security for the system. The policy confines the Performance Component in a separate domain reserved specifically for gathering performance information.","Flexibility, Availability, and Maintainability Design Decisions","In this embodiment, the performance monitor component preferably requires layers of abstraction so that it can remain flexible to changes in the underlying way in which it collects data from the system. Unlike other components that require rigid settings for security, the performance monitor preferably needs to remain flexible so that it can easily adjust it the format of data it receives from a file or program changes. It utilizes modularized components for parsing data that it receives so that should a programs output change, or a different mechanism for obtaining a certain metric is changed the system will require a minimal about of configuration changes. The performance monitor also needs to be customizable so that an administrator can select which metrics they would like to record.","Shutdown","In one embodiment, the Shutdown Monitor is responsible for making changes to the state of the system. It waits for a state change event, arriving through IPC, and then responds to it.","In this embodiment, the state change message may contain a number signifying to what state the system should transition.","In this embodiment, the Shutdown Monitor initiates transitions to system states such as:\n\n","In this embodiment, the Production policy state grants privileges to the AFT components allowing them to run while the policy restricts the abilities of maintenance and configuration utilities. Certain configuration tasks cannot and should not be run while the system is processing and this policy ensures this. The Production policy also has two states controlled by a SELinux Boolean, which determine when to activate networking.","In this embodiment, the Network Boolean is a SELinux-related policy switch that either permits (TRUE state) or denies (FALSE state) network connectivity for the system. The default value for the Network Boolean is FALSE, which allows AFT processes to start up safely before allowing connections. After the system has verified that it is ready to receive connections the Boolean value get changed and network connectivity is permitted.","In this embodiment, the Maintenance policy state is designed to allow privileges that are required for performing maintenance on the system. The system transitions into Maintenance mode when initiated by an authorized administrator, or when directed by policy in response to specific error conditions. The Shutdown Monitor receives messages instructing it to transition into maintenance mode from the Audit subsystem or the administrator's shutdown utility.","In this embodiment, the Power Off policy state shuts the system down completely without transitioning into maintenance mode. When a severe error occurs, the Audit Subsystem sends a message to the Shutdown Monitor instructing it to power the system off. The administrative shutdown command can also send a power-off message to the Shutdown Monitor when an administrator would like to completely shut down the system.","In this embodiment, if the system is transitioning into maintenance mode or powering off, the Shutdown Monitor will send messages indicating to each process that they are to shut down and the monitor will send them though each processes' IPC connection to the Shutdown Monitor.","In one embodiment of the Shutdown Monitor, the initialization phase starts out by initializing variables and verifying that the system has adequate resources to start up the process.","In this embodiment, after initialization, two threads are created. The first thread receives a list of process IDs from AFTInit that the monitor needs to notify in the event of a shutdown. Certain processes may start up and shut down while the system is running. In order for these processes to work with the Shutdown Monitor, a process ID will have to be added and removed from the Shutdown Monitor while the system is running. If another process in the system creates processes, it is the responsibility of that process to make sure that Shutdown is told what processes it needs to shut down. Likewise, when a process shuts down, Audit notifies the shutdown monitor and based on the message, the shutdown monitor either removes the ID of that process, or shuts down the system.","In one embodiment, the processes that require shutdown notification are placed into a notification table (or \u201cprocess vector\u201d). The order in which the processes are shut down is not critical; however, the audit subsystem needs to be shut down last so that it can continue to receive audit events as long as possible. Note that the security policy's Network Boolean is set to FALSE before shutdown commences, ensuring that no data enters or exits the system during shutdown.","In this embodiment, the second thread created after initialization is a thread that waits for state change messages. If a \u201cshutdown\u201d or \u201cchange to maintenance mode\u201d message is received, the monitor sets the Network Boolean, notifies the Audit Process that the Boolean has been changed, and then proceeds to notify all processes in the notification table to shut down.","In this embodiment, if the state change message simply requests a change of the Network Boolean, the change is made, Audit is notified, and it continues waiting for messages.","In this embodiment, once the processes have been notified, the system shuts down the system by transitioning into maintenance mode or running\/sbin\/init and powering the system off.","Implementation Decisions","In one embodiment, for processes to be able to interact with the Shutdown Monitor, each process will have been linked to a library that contains special functions for setting up the mechanisms that interface with the initialization subsystem. The library will contain functions that a program will call while it is starting up. The functions will create and control threads and setup IPC communication between the process and the Shutdown Monitor. The shutdown control thread establishes an IPC channel with the Shutdown Monitor, and blocks on read waiting for a message from the Shutdown Manager informing the process that it needs to shut down. When such a message is received, the process will call a shutdown function, which will clean up the Shutdown Monitor thread allowing the process to then return normally.","Subcomponent Details","In this embodiment, changing the Network Boolean value is straightforward. The process will open the appropriate Boolean file in the\/selinux partition and set the value to 1 or 0 depending on the context. The shutdown process runs in a domain that allows write access to the Boolean file.","In this embodiment, transitioning to maintenance mode and powering off may be more complicated. First, it sets the network interface Boolean to FALSE so that no data can move through the session as components are shutting down. If the Boolean is not set to FALSE, it may result in partially processed data going through the system and interface. Second, the Shutdown Monitor sends a message to every process in the system informing them that the system is shutting down and that they must terminate.","In this embodiment, the shutdown monitor is aware of every process because it receives a list of process IDs from any process that execs new processes. As stated in the Initialization section, the AFTInit process sends the process IDs of the processes it has created to the shutdown monitor before exiting. If another process in the system creates processes it will be the responsibility of that process to make sure that shutdown is told what processes it needs to shutdown.","After the AFT processes have terminated, the system will either transition into maintenance mode or continue the shutdown process to turn off the system. If the system is transitioning into maintenance mode, it will first wait for all of the AFT processes to terminate. The shutdown monitor will then execute the load_policy command that will load the maintenance policy on to the system. If the system is shutting down, the shutdown monitor will execute\/sbin\/init and switch to runlevel  instead of calling the load_policy command.","Interfaces","In one embodiment, the Monitor will accept an IPC connection from, and send data to, many of the other processes within the system component. Each process will utilize connect to the Shutdown Monitor and begin listening for a shutdown message. This may be a one-way communication channel, where the Shutdown Monitor only sends data.","In addition to sending shutdown messages to monitored processes, the Shutdown Monitor also interfaces with the Audit and Heartbeat Monitor subcomponents.","Audit","The Audit Subsystem provides audit functions for an assured Guard and other self-protecting components. It preferably provides diagnostic logging capabilities to facilitate system troubleshooting and development. The Audit component also provides related subcomponents necessary for policy enforcement, including a security event response framework.","Diagnostic logging may be preferable to develop AFT components. It also provides wellness metrics not captured by security requirements but necessary for overall system maintenance. Diagnostic logging may be tightly associated with an application's security domain, as generally, a holistic system view is not necessary.","Security event auditing, on the other hand, preferably provides a complete picture of system security events, as observed by all system components. Event auditing satisfies security requirements for a secured, tamperproof record of security-relevant system events.","In one embodiment, persistent repositories can exist and be maintained by Audit to provide storage location for audit data and event policy information. These repositories may be physically located on the SAN. To support AFT journaling, Audit will save the file being journaled to a persistent directory along with the clean report. Reference information such as directory location, submitter name, receiver names will be stored in the audit database. Audit will provide an interface for the administrator to view these files and remove the files from Audit's directory and reference in the database.","Audit data is preferably backed off the system every month by the log operator. The log admin is responsible for deleting the audit file to free file system space. If the file system space is exceeded, the AFT system may shutdown and may not execute until space is available on the file system.","There may be two basic audit files that require backup, each to a separate tape. One contains all the submitted files that have been journaled and the other audit type contains event logs and clean reports of submitted files.","In one embodiment, Audit has the ability to store files for one month. Warnings to the administrator can be sent when the files approach this timeframe. Audit data is preferably copied to tape every month.","Software Architecture","The Audit Subsystem manages and maintains the Audit Store Database and may capture, for example, the following types of information:\n\n","Allow Administrator access to audit information for review.","Audit Data","The Audit Data element provides a data model for Audit events and the operations to manipulate it. The data model may consist of data types, core kinds of data present in Audit records, and the taxonomy of events. The operations may consist of functions for manipulating fields, accessing common fields, and working with field types. It depends on session data defined in the Common::Session package and the safe, portable common types defined in the Common::Types package. The core objects are AuditField and AuditRecord. Helper objects include AuditRecordWrapper and AuditRecordlterator.","An Audit Record is essentially a container of multiple fields, some always present, some frequently used, and some specific to the component generating the record. The Container interface facilitates levels of commonality of fields while supporting software reuse.","Client Interface","In one embodiment, the Audit Subsystem provides extensible C and C++ interfaces for applications to record audit events.","Audit Client","In one embodiment, the AuditClient class provides the C++ interface for generating events. Part of its interface includes non-member functions to store values, similar to the C++IOStreams interface.","C Application Programming Interface","In one embodiment, the C Application Programming Interface (API) provides a C interface to the AuditClient class and includes operations to control event sources and sinks.","Event Source and Sink","The Audit Subsystem supports event sources and sinks to enable auditing failover, caching, and retrieval with minimal client interface. The AuditClient class and C API work polymorphically with the underlying sources and sinks. Audit API users can always create events without concerns about the underlying transport.","In one embodiment, a source, CacheDestination, enables processes (e.g., CABShutdown) to cache events until the Event Manager is ready to receive them. Once the Event Manager is ready, a process could send events from the cache.","Event sources enable the Audit interface to direct events regardless of the target. An event source preferably implements the AuditDestination Non-Virtual Interface (NVI). One embodiment subsystem supports three sources: CacheDestination (to store events), EventMgrDestination (to transmit events via IPC), and the EventMgrLocalDestination (for the Event Manager to transmit events to itself).","In one embodiment, binary serialization is implemented to support failover event recording, in the case that the Audit Subsystem is not available. The BinaryFileDestination class persists serialized events in a flat file. The BinaryFileSource class read serialized events from a flat file.","Audit Server","In one embodiment, the Audit Server is the central repository for all audit events. It receives AuditRecords via the EventManager over IPC.","Event Dispatch","In this embodiment, the Event Dispatch subcomponent provides a policy-driven capability to respond to security-relevant events. When a client detects an auditable event, it sends the event via the Audit client. The client, in turn, sends the message to the EventProcessor that decides which actions should occur when an event is triggered.","Alert","In one embodiment, the Alert subcomponent provides an interface for generating alerts to administrator. This embodiment implements a console-based alert. In another embodiment, there may be additional alerts, such as those to pop-up windows, alarms, etc.","Dynamic Design","In this embodiment, the AFTAudit Subsystem has a shutdown sequence to ensure consistent behavior.","Audit Subsystem Startup","In this embodiment, the Audit Server is preferably ready before vents are sent. Because the Event Manager and Audit Store are separate processes, their startup sequences are in parallel. Moreover, the CABInit process preferably cannot receive messages from processes it has started, so it is not possible for them to indicate success in failure. The Event Manager detects when the Audit Store is online because its IPC sends succeed. Should its IPC sends not succeed within a developer-configurable amount of time or should IPC sends fail after a connection is established, the Event Manager enters its shutdown sequence.","Audit Subsystem Shutdown","In this embodiment, the Event Manager enters its shutdown sequence when it receives an event whose policy rule triggers shutdown. For cases of Event Manager-detected fatal errors, such as an inability to send IPC events, the Event Manager generates events to itself.","Client Failover","In one embodiment, the Audit Client implements failover behavior. If a connection is unsuccessful within a required threshold of time, then events are stored on disk for later import.","Guard Log Admin","In one embodiment, the Log Administrator monitors the Guard to ensure that it is functioning properly and that users are behaving in accordance with policies. With that information, the Log Administrator can take appropriate administrative measures such as notifying other system administrators or site management.","Guard Policy Admin","In one embodiment, the Policy Administrator has operational and policy oversight over the Guard operation, such as auditing behavior, resource allocation, and threshold configuration. In conformance with separation of roles, the Policy Administrator has limited capabilities and should preferably used by highly-vetted individual.","Client Code","In one embodiment, the Client Code actor represents usage of an audit or logging capability external to the Audit component.","Audit Component","In this embodiment, the Audit Component actor represents actions taken by the Audit component.","Attacker","In one embodiment, the Attacker actor attempts to compromise the audit capability, including gaining access to audit data, causing a loss of availability, or altering audit data.","Log Administrator","In one embodiment, the Log Administrator has a view into the system for ordinary oversight. For Auditing, a Log Administrator need only view the local logs.","Audit Client","In one embodiment, the Audit Client has few states: connecting to the Audit Server, ready, and termination.","In one embodiment, client usage essentially consists of a few basic steps:\n\n","Prepare to Send Audit Messages","In this embodiment, an Audit client, whether communicating directly with the Audit server or logging locally, preferably creates the appropriate destination object (local or Audit IPC). Next, the client registers the destination with the AuditClient.","Create and Fill a Record","In this embodiment, the client creates a record through the AuditClient or by using a wrapper.","Send Record","In this embodiment, finally, the client sends the record by way of the AuditClient. It is also possible to reuse the record for multiple destinations (by way of multiple AuditClient instances) or to modify the record and send it as a new event.","Audit IPC","In one embodiment, the Audit component includes an inter-process client\/server interface. The implementation of the interface may be via asynchronous IPC.","Event Dispatch","In this embodiment, when an event arrives at the Audit Server, it can trigger one or more actions, depending on the policy. Invariably, there is an action to record the event to disk. Additional actions include system shutdown, session termination, account lockout, console alerting, and flight recording.","Interface Descriptions","In this embodiment, the Audit interface consists of the client interface, callback interface, and the configuration items available to the administrator.","Client Interface","In this embodiment, the Audit Subsystem provides extensible C and C++ interfaces for applications to record audit events.","C++API","In one embodiment, the AuditClient class provides the C++ interface for generating events. Part of its interface includes non-member functions, represented as AuditClientAux, to store values, similar to the C++IOStreams interface.","C API","In this embodiment, the Audit C API provides functions to control event subsystem initialization and routing and a flexible C wrapper for code that cannot use the C++ API.","Callback Interface","In this embodiment, the Audit callback interface enables other components to receive callback messages from the Audit Server when security-relevant events occur. The callbacks may be registered using the wire protocol interface. An application can register to receive an asynchronous callback when an event occurs. The interface preferably complies with ISecurityAction in order to receive a notification. Examples include LogoutAction, GuardShutdownAction, AccountLockoutAction, and ConsoleAlertAction.","Configuration File Interface","In this embodiment, Audit Subsystem configuration consists of per-application and overall subsystem tuning.","Logging Configuration File Interface","In one embodiment, the logging configuration file interface defines logging settings understood by all applications. It is not modifiable by ordinary administrators.","Audit Client Configuration File Interface","In this embodiment, the audit client configuration file interface defines audit settings understood by all applications. It is preferably not modifiable by administrators.","Event Manager Configuration File Interface","In this embodiment, the Event Manager Configuration file defines the settings used for dispatching events.","Audit Store Configuration File Interface","In one embodiment, the Audit Store Configuration file defines the settings for recording events to disk.","User Interface Design","In this embodiment, the user interface for the Audit Subsystem includes utilities to configure and view the Audit Subsystem. Most utilities are preferably only available to an administrator and other utilities are only available to developers. The Audit Viewer and System Configuration have the highest priority for implementation.","Audit Viewer","In this embodiment, the Audit Viewer enables the administrator to view recorded audit events and execute ad hoc queries.","System Configuration","In this embodiment, the System Configuration utility enables the administrator to set the logging and auditing parameters for each process.","Audit Binary Importer","In this embodiment, the Audit Binary Importer imports binary audit events into the Audit Store database.","Audit Exporter","In one embodiment, the Audit Exporter exports recorded audit events into XML.","Decision to Develop or Reuse","In this embodiment, the AFT Audit Subsystem may reuse software modules written for the CAB CDS to provide most of the auditing capability. AFT specific functionality may be implemented as needed.","Interface-Related Design Decisions","In this embodiment, there are several considerations for the Audit interface:\n\n","In this embodiment, to simplify client usage, the core-auditing interface offers three levels of data abstraction: data element, generic event record, and specialized event record. Orthogonal concerns such as event destination are separated from the data interface.","In this embodiment, the Audit interface is designed to cooperate with other common system components. Audit clients do not need to carry out synchronization of data, as the client interface provides synchronization under the covers.","Performance-Related Design Decisions","CAB's Audit Subsystem may be designed to meet performance requirements for soft real-time response. In this embodiment, the AFT system is not required to perform at the same high level but will take advantage of CAB's Audit performance optimizations.","Database Design Decisions","In this embodiment, the Audit Subsystem database schemas mostly follow Third Normal Form (3NF), to encourage data integrity. There may be two schemas: one for the Audit Store and one for the Event Manager Policy.","Audit Store Database Schema","In this embodiment, the Audit Store database schema is intended to capture live audit data and administrator-configurable static data lists. Static data lists contain normalized choices, such as mappings of fixed names to numeric identifiers (e.g., country names to numbers).","Event Manager Policy Schema","In this embodiment, the Event Manager policy is stored in a database schema to facilitate the numerous relationships between the values stored in it and in the Audit Store database.","Safety, Security, and Privacy Design Decisions","In this embodiment, the Audit component is designed for partitioned security domains. The primary security issues include:\n\n","In this embodiment, the primary design principle to meet these security issues are least privilege and minimality. The Audit Server operates in a security domain that enables it to write persistent data to disk with an \u201caudit data type.\u201d The Log and Forensic administrator are permitted to read the persistent data having \u201caudit data type.\u201d A separate \u201caudit configuration\u201d type identifies configuration files modifiable solely by a Policy Administrator.","Flexibility, Availability, and Maintainability Design Decisions","In this embodiment, the Audit component is instrumental in system maintainability. Security event and diagnostic data support developers and administrators who need to understand the system function. The interface flexibility enables a rich diagnostic capability.","In this embodiment, the Audit component is flexible. It supports in-process and inter-process aggregated logging. The design also supports future development by enabling different persistent stores and transports to be incorporated without affecting the overall implementation.","In this embodiment, the Audit component has implications for system availability. Audit trails are preferably tamperproof and guaranteed to occur for security-relevant events. Therefore, the Audit component becomes a bottleneck that can affect availability or a target for a denial-of-service attack. Audit components are designed to be contention-free as much as possible, so that multiple clients can simultaneously record their events asynchronously.","Administration","In this embodiment, the Administration functional area will manage aspects of system configuration and operation. Role-based privilege enforcement allows the following responsibilities to be divided among one or more administrators, depending on site requirements.\n\n","In this embodiment, the Administration component can customize the configuration of the system and provide interface to view audit and performance information. The implementation for system administration may be GUI based. Any modifications to configuration data will verified to insure that and configuration changes make sense in context to the field before those changes are committed to the system. Verification of the configuration file schema can be handled by Samhain integrity tool. Samhain is a file system integrity checker that can optionally be used as a client\/server application for centralized monitoring of networked hosts. Databases and configuration files can be stored on the server. In addition to forwarding reports to the log server via authenticated TCP\/IP connections, several other logging facilities (e-mail, console, tamper-resistant log file, and syslog) are available","In this embodiment, AFT will use version numbers on each filter policy configuration. The Administration Component will put the updated configurations to their configuration directories. Submit jobs that are in progress will continue to use the configuration version that existed when the submit job was initiated. New submit jobs will pickup the new version.","In this embodiment, Authorization and Access control will be mitigated by the AFT defined role model. The role model will define the access limits for data and processes, e.g., certain roles have access to certain applications at certain times. The role model can be maintained on the guard in a database and will map to SE Linux roles.","Configuration Data","In this embodiment, the Administration Component can provide a GUI for maintaining configuration data. GUI's may be developed for configuring the following:","User Management\n\n","Role management\n\n","Group Management\n\n","Admin Management\n\n","Event Management\n\n","Policy\n\n","Action levels will initially be:\n\n","System Administration\n\n","Firewall Configuration","Interface Descriptions","In this embodiment, the Administration Component is integrated with the configuration file subsystem and may interact with the init and audit subsystems. This component sits at a layer above the configuration file and is passed data types and values that are then verified.","In this embodiment, the Administration Component will invoke process defined library functions that will access the Admin databases to create configuration information specific for that process. This permits the flexibility to provide configuration information in the specific form needed by the process such as flat files or xml files.","User Interface Design","In this embodiment, a GUI will be available to view performance data and to enter configuration for the AFT Subsystem that will be stored in Administration maintained databases.","Decision to Develop or Reuse","In this embodiment, AFT will reuse software modules written for the CAB CDS to provide much of the Administration capability. AFT-specific functionality will be implemented as needed.","In this embodiment, the administration verification tools will be written specifically to validate GUI inputs.","In this embodiment, because of the high-assurance qualities of the system, privileged administrative and maintenance users will require direct physical access to several individual components using a set of administrative interfaces with a common \u201clook and feel.\u201d","Interface-Related Design Decisions","In this embodiment, the Administration component obtains and verifies data from the configuration file and configuration databases. If the configuration file passes verification the only output from this component is a successful error code, however if the file does not pass inspection, an error message describing the failure is printed and an unsuccessful error code is returned.","Database Design Decisions","In this embodiment, the Administration Component will use databases to store and retrieve configuration data. The databases (System config, Audit config, User Mapping, Firewall config, and filter policy) are preferably persistent and therefore will all be stored on the SAN.","Security Design Decisions","In this embodiment, the Administration Component relies on the SELinux policy to provide security for the system. The policy confines the administrative binaries and configuration files into a restricted domain isolating them from other parts of the system.","In this embodiment, virus definition files, clean and dirty word lists and system components are preferably maintained by an authorized system administrators or by designated maintenance personnel who have been properly cleared and trained. The administrators are preferably fully trusted and will not conduct operations outside the security policy.","In this embodiment, AFT supports a flexible configuration that adheres to the security policies in place at each deployment site.","Flexibility, Availability, and Maintainability Design Decisions","In this embodiment, the Administrator Component will maintain data needed to allow the Guard to communicate with other guards for facilitating load and administrative data sharing.","Control Message Filter","In this embodiment, the AFT control message filter component accepts a control message from a Transfer Agent (TA) then validates the format and content of the message before forwarding the control message to a Repository Manager (RM). The control message filter provides content and format filtering for the control messages sent to the repository managers. It should be noted that control messages do not transverse the guard nor are they visible to any user.","Software Architecture","In this embodiment, the AFT Control Message Filter (ACMF) receives input from a TA, validates, and filters the control message, then passes the control message to a RM. There is a different instantiation of the ACMF for each TA\/RM \u201cpair.\u201d All control message flows are preferably one way.","Messages","In this embodiment, the control message filter accepts three different control messages: Delete (requests that a job be deleted from the repository), Release (requests that a job be released by the repository manager) and Reject (Informs the repository manager that a job has been rejected and provides the location of a comments file).","Message Format","In this embodiment, ACMF control messages are fixed length messages. There are two different control message formats, a common format for delete and releases, and an extended format for reject.","The message for delete and release contains:\n\n","The extended message for reject contains:\n\n","Filtering","In this embodiment, the ACMF validates that the command specified in the message is a valid command for the recipient. If the command is not valid, the event is audited and the message deleted. For a valid command, the username and jobid are validated to ensure that they only contain permissible characters. The ACMF does not check to ensure that the username actually has permission to perform the requested function, that checking is the responsibility of the RM.","In this embodiment, for the reject command, the ACMF validates that the path name is valid and that the specified comments file exists. The contents of the contents file are then processed by an appropriate subset of the txt file filters. Failure of any validation is audited and results in the rejection of the message.","Inter-Guard Communication","In this embodiment and as described in the Hardware section, the guard may consist of multiple guard nodes connected to a common SAN and to each other.","In this embodiment, the design of the inter guard communication component is driven by the following considerations:\n\n","Failure of a node within the guard should not cause the loss of a job currently running on that node.\n\n","In this embodiment, the IGC development may be largely based upon commercially available products that provide the needed tools and\/or functions.","Data Sharing","In this embodiment, the data sharing criteria for the guard nodes is satisfied by placing those files that must be shared on the SAN. The following repositories may reside on the SAN:","1. High Side In","2. High-side user Review & Release","3. High Side FDO Review & Release","4. High Side Out","5. Low Side In","6. Low Side Out","7. Low-side user Review & Release","8. Low Side FDO Review & Release","9. Audit","In addition, global configuration files, and global queues may reside on the SAN in one embodiment.","Preventing Job Loss","In this embodiment, when the Work Order (WO) for a job, and the files associated with the WO reside on the SAN other nodes in the guard can access the information in the event of a node failure. However, once the work either moves from a repository into a node for the clean or verify process, if that node fails the information becomes unavailable to other nodes unless a copy is left in a repository. The clean process will not delete the job from the input repository, but will simply copy the job into its directory. After the User R&R process has successfully copied the job into its repository, it will then delete the job from the input repository. Similarly the verify process will not delete the accepted job from its repository. The job will be deleted from the FDO repository by the verify R&R process.","Load Balancing","In this embodiment, load balancing may be addressed in two separate ways. The first way is to balance the network load amongst nodes; the second is to balance the actual filtering work between nodes.","Network Load Balancing","In one embodiment, the simplest method of load balancing is round robin DNS rotation. The advantage to this approach is that there is no additional software required since it is implemented in the connecting host's DNS server(s).","In one embodiment, a second option for load balancing is to use Piranha. Piranha is the clustering product from RedHat. It includes the LVS kernel code, a GUI-based cluster configuration tool and cluster-monitoring tool. Piranha supports multiple different load scheduling algorithms such as Round Robin, Weighted Round-Robin, and Least-Connection. Piranha use a router\/server tied architecture.","In one embodiment, a third option is to add re-direct support to the Transport Agent (TA).","In one embodiment, a fourth option is a hardware switch that performs the same function as DNS rotation.","Whichever solution is selected should preferably ensure that needless SSL credential handshaking is not required. Two methods to achieve this are to provide \u201cpersistent\u201d affinity for at least the SSL session time to or provide some means of sharing the SSL cache between nodes.","Filter Load Balancing","In this embodiment, balancing of the filter load between nodes may be accomplished by placing the message queues that are used to communicate work to the clean and verify processes on the SAN. Therefore the clean or verify processes on all nodes share an \u201cinput\u201d queue.","Performance-Related Design Decisions","In this embodiment, there will be multiple file systems defined on the SAN. Preferably, only those that must have shared write access need be CFS file systems. Those shared read only can be a standard Linux file system type.","The standard RedHat supported Linux file systems are ext2 and ext3. Reiserfs is often considered a higher performance file system than ext3, but is not supported by RedHat and does not support extended security attributes without patching. XFS is also a high performance file system that has been designed and tuned over the years to handle large files. If the clustering file system selected is CXFS, using XFS for the SAN resident r\/o file systems is appealing since XFS and CXFS use the same format on disk.","Structural Components","In this embodiment, the Clean subsystem of the AFT Guard implements the document sanitization process for the AFT Guard.","Overview","Architecture Overview","In this embodiment, the Clean subsystem of the AFT Guard is a series of software components that collectively fulfill the requirements for sanitizing and verifying the target files transferred by the AFT.","In this embodiment, the software subsystem described will be separately instantiated four times in the AFT, to create the following components of the overall AFT system architecture:\n\n","In this embodiment, the same subsystem architecture is used for both Clean and Verify. If the subsystem is installed as Clean, the components may be configured to be able to modify files. If the subsystem is installed as Verify, the components may be configured for analysis only.","In this embodiment, for any given sanitization task, the Verify functionality will be a different implementation than was used in the Clean. For example, the virus scan used by Clean will be from Vendor A, while the virus scan used by Verify will be from Vendor B. This is done to implement a true double check of the file.","In this embodiment, the Clean subsystem is composed of a series of smaller components. Each component implements one step in the process. Clean and Verify differ in that Clean will change the files in order to sanitize them, while Verify does not change the files, it only checks them for security concerns. In this document, the architecture description of Clean also applies to Verify.","In this embodiment, the input process will submit a file sanitization job by writing the files into a directory. This directory holds the target files to be sanitized and the associated overhead files needed for AFT processing. Then a pointer to the job is put into the input queue for the first process in Clean, the Work Scheduler.","In this embodiment, the Work Scheduler begins a series of filter components that operate on the job. The Work Scheduler, Router, Forwarder and Reconstruct are structural components that manage the work flow. The file sanitization is done in the Filter Stage.","Following is a brief summary of responsibilities of each component. Each component is specified in more detail later in the document.\n\n","Component Overview","In this embodiment, all the components of the Clean subsystem share some basic characteristics.","In this embodiment, each component of the Clean subsystem is envisioned as a process which will read input events from an associated queue, and then dispatch worker threads to process the jobs from the queue. The maximum number of threads the component can use will be configurable.","In this embodiment, each component will have its own designated type-enforced working directory area. This is done to prevent one component from overwriting or corrupting the work of another.","In this embodiment, in general, files are moved from component to component by a copy-delete method. The component sending the files will put a message into the queue of the component receiving the files. The receiving component will pull the message out of its queue, read the current directory location of the files from the message, and then copy the files into its own working directory. The receiving component will then delete the files and their directory from the sending component's directory. The job now exists only in the directory which the current component has read and write permission for. Any previous references to the files are now invalid. This moves the job through the system in a type-safe manner.","Repository Manager","In this embodiment, within the AFT Guard, there are points in the system where the files to be sanitized (jobs) must be held for an indeterminate length of time while awaiting some type of event to move them to the next stage of processing. These points in the system are handled with the Repository components. A \u201cjob\u201d is defined as one submission of a file or files to be sanitized, plus whatever meta-data is needed to shepherd these files through the AFT system. The repositories will secure the jobs into a dedicated disk area and keep a separate database detailing the jobs and their disk locations. The database and dedicated disk areas will be on the attached Storage Area Network (SAN), so as to be a shared resource between all guard nodes when the configuration demands more than one node. The database will allow queries so that job statuses can be ascertained.","In this embodiment, the Repository component implements job management in the repository. It sends out notifications of job status to users, cleans up expired jobs, and executes the following commands to manage the jobs:\n\n","In this embodiment, a \u201cjob\u201d is defined as one submission of a file or files to be sanitized, plus whatever meta-data is needed to shepherd these files through the AFT system.","Decision to Develop or Reuse","In this embodiment, the architecture for these components may make use of design patterns and relevant reusable code.","Interface Related Design Decisions","In this embodiment, the databases which the Repository controls will be queried in a read only manner by the Transfer Agent(s). This is done for efficiency, to avoid the need for a temporary file area and the associated cleanup utilities. To address security, the Transfer Agent component will only be allowed to create specific queries from a library and will verify the query for all applicable parameters.","Database Design Decisions","In this embodiment, an existing open source database can be used in the Repository. The main consideration for the database is that it be a lightweight in-process database.","In this embodiment, unless specifically noted otherwise, the databases and associated file directories for each Repository will be stored on the SAN disks to allow them to be shared between all the guard nodes.","Security Design Decisions","In this embodiment, the design principles employed in meeting security issues are least privilege and minimality. Each instantiation of the Repository component will have its own database to enforce least privilege and privacy of data. The URR and FRR are separate components in the system in order to enforce separation between the two stages of processing. The Verify Repository enforces separation between the high and low domains.","Software Architecture","In this embodiment, within the AFT Guard, there are points in the system where the files to be sanitized (obs) must be held for an indeterminate length of time while awaiting some type of event to move them to the next stage of processing. These points in the system are handled with the Repository components. The Repository will secure the jobs into a dedicated disk area and keep a separate database detailing the jobs and their disk locations. The database and dedicated disk areas will be on the SAN, so as to be a shared resource between all guard nodes. The database will allow queries so that job statuses can be ascertained.","Basic Repository Component Functionality","In this embodiment, here is basic component functionality that applies across all Repository components:\n\n","Overview of High-to-Low Processing","In this embodiment, the Repositories needed for one direction in the system are:\n\n","In this embodiment, both directions, High-to-Low and Low-to-High, will have all these same components.  shows an example of High-to-Low processing showing repositories. For the Low-to-High, the URR and the FRR will be in a \u201cquiet mode,\u201d where they do not send notifications or provide review capability, but do continue to fulfill their other system functions. This also puts the components in place to provide all functionality for both directions in the future.","Each of the five types of Repositories is next explained in more detail.","Input Repository (IR)","In this embodiment, the Input Repository holds user input jobs. If necessary, it can send back notifications that the job has been accepted by the system. If due to volume, the job must wait for Clean processing, it will wait in the IR. When the job is first picked up by Clean, it will not be deleted immediately from this repository, but rather will be deleted by the URR after the job has passed the Clean stage of the system. This ensures not losing the job in flight if one node of the guard goes down.","Configurable items for this component:","Whether to send back a notification to the submitting user upon receiving the job. This notification states that the guard system has accepted the job.","User Review and Release (URR)","In this embodiment, basic operation of the URR:\n\n","Configurable items for this component\n\n","FDO Review and Release (FRR)","In this embodiment, basic operation of the FRR:","It is the next component in the chain after the URR, hence its basic input jobs are coming from the URR component.\n\n","In this embodiment, configurable items foreseen for this component:\n\n","Verify Repository (VR)","In this embodiment, the Verify Repository serves as a boundary process between the two domains High and Low. This boundary process will prepare the job to go from one domain to the other, including substituting names\/ids as needed. The boundary process will send all notifications associated with the job. It will clean up any failed jobs so that they never cross the domain boundary.","(U) Verify Repository functionality:\n\n","If this is the High-to-Low processing:\n\n","Output Repository","In this embodiment, Output Repositories hold the sanitized jobs for user pickup.","Output Repository functionality:\n\n","High-to-Low Messaging","In this embodiment, in High-to-low processing, the notifications and command messages include:\n\n","Low-to-High Messaging","In this embodiment, in Low-to-high processing, the notifications and command messages include:\n\n","Transfer Agent Access to RM Databases","In this embodiment, the Transfer Agents of the system are allowed to query the Repository controlled databases. They may also read files from the disk areas of the Repositories. The queries are allowed for the jobs relating directly to that specific user. The queries are implemented as library calls to allow only the necessary queries.","In this embodiment, High-side user Transfer Agent may:\n\n","Interface Descriptions","In this embodiment, the Repository Manager preferably sends notifications back to the user interface. The RM will create a message which has the following:\n\n","In this embodiment, this message will be relayed back to the relevant Transfer Agent(s).","Filter Pipelines","In this embodiment, filters are organized into document processing paths called pipelines, where each pipeline operates on a specific type of file in the job.  shows an example of a summary of the filter pipelines. The \u201cDWS, CM, MCC, Ent\u201d bubbles denote a suite of filters; the Dirty Word Search, Classification Markings, Mobile Code Check and Entrophy filters. The MS Office Suite and the PDF Suite also denote more than one filter.","In this embodiment, the incoming files to be sanitized may consist of several types of files, all included in one job submission. For example, a Word doc file, an Adobe pdf file, and a zip file may comprise one job submission. Recursion through the filter pipelines may be needed to complete all the needed sanitization for the different file types. Recursion is implemented by sending the job back from the Forwarder to the Work Scheduler. The Work Scheduler then sends the job through the next pipeline needed for the job.","Pipeline Management","In this embodiment,  shows an example of the use of directories and the control points for one pass through a filter pipeline. In this diagram, the filter pipeline consists of Filter 1, Filter 2, and the Collator. The Work Scheduler, Router, Forwarder and Reconstruct are the structural components shared between all pipelines.","In this embodiment, the filtering process is controlled with job information files, which direct all the components in their work.","Job Information Files","Job Manifest file","In this embodiment, this file has the top system level data associated with this job. The Job Manifest will follow the job throughout the system. The information in the Job Manifest can include\n\n","In this embodiment, the Job Manifest is originally written by the Transfer Agent. Upon being sent to the Work Scheduler of the clean, the first step of the Clean process will be to send the Job Manifest through a filter to check all its contents.","Job Tracking File (JTF)","In this embodiment, the JTF contains the information needed to control this job's sanitization processing; it is the master roadmap for job processing. This file persists across all the sanitization processes within the Clean subsystem. It details the work to be done to each file, and has a record of the work already done to each file.","In this embodiment, the JTF is created and written to by only the Forwarder. The Work Scheduler may only read this file. The JTF is not read or written by the filters. To enforce these access rules, the JTF is kept in a separate directory.","In this embodiment, the information in the JTF includes of the following elements:\n\n","Job Transaction Ledger (Ledger)","In this embodiment, the Ledger files are specific to one pass through a filter pipeline; they are the tickets for one journey from Work Scheduler to Forwarder via a specific pipeline.","In this embodiment, the Ledger is created by the Work Scheduler. It contains applicable instructions for the journey through the pipeline. As an example, the Ledger may start with this information:\n\n","In this embodiment, the Ledger is placed in a separate directory which all the Filters in the pipeline can read.","In this embodiment, as each Filter operates on the file, it will record the processing of the file in the Ledger, including any findings or cleaning done on the file. The Filter has an append-only ability to write the Ledger, in order to ensure that one filter cannot over-write the results of a previous filter.","In this embodiment, when the job arrives at the end of the pipeline at the Forwarder, the Forwarder merges the relevant Ledger results into the JTF file. The Forwarder merges the findings and cleanings done on each file into the Clean Report. After all information from the Ledger has been transferred to the JTF and Clean Report, the Forwarder deletes the Ledger.","Clean Report","In this embodiment, the Clean Report file is the record of all cleanings and findings for this job. This report will be the basis for all reports seen by the High-side user and the FDO, and will be saved in Audit as the official record of the cleaning done on this job. The Clean Report is created and updated by the Forwarder and kept with the cleaned job files. The Clean Report is updated after each pass through the filter pipelines as the Forwarder analyzes the Ledger files.","Collator Role in Pipeline Management","In this embodiment, the Collator's function is to ensure the Forwarder does not have any access, including read access, to files which have not yet passed all the Clean steps. The Forwarder may read about these files and what has happened to them by reading the Ledger information. The Forwarder can then use this Ledger information to decide what to do next. However, the Forwarder may not have read access to the file itself.","In this embodiment, the Collator separates the cleaned files from the files still in process. The Collator puts the files which have passed all Clean steps into a directory which the Forwarder may read. The Forwarder can then pull these files into its working directory.","In this embodiment, the Collator puts the files which are still in process into a directory which the Forwarder does not have any access to. The Work Scheduler can then pull these files back into its working directory, to prepare them for the next pass through the filter pipeline.","Handling Extracted Files","In this embodiment, files may be created from other files, either by un-archiving or by extraction of embedded files, for example, extracting out a file embedded in an MS Office document. Such files will be documented in the Ledger, detailing their extraction process so that the original file can later be reconstructed. The extracted files will be placed in a dedicated directory which the current filter only has write access for, effectively putting them in a quarantine area.","In this embodiment, the extracted files will not be available to the next filter in the pipeline. They will stay in the quarantine area until the job arrives at the Collator. The Collator will then move these files into a section of its in-process directory, so the Work Scheduler can pick them up and integrate them into the overall job as appropriate.","Consumable Files","In this embodiment, in its processing, a filter may create a subset or variant of the information in a file it is sanitizing. This information may be written out into another working file, to be used by that filter or by another filter in the same pipeline. In that case, this newly created working file is a \u201cconsumable\u201d, and will be written into the filter's working directory. It must be deleted before the job leaves the pipeline; it may be deleted by one of the filters or it may be deleted by the Collator.","As an example of this, for an MS Word.doc file, one thing that might be done is write all the content of that file, text plus any other fields, into an XML file. The XML file would then be processed by the Dirty Word Search (DWS), as it is now in a form which the DWS can process. Then the XML file is deleted after the DWS. The XML file was used by the filter chain and deleted before the job left the pipeline; it qualifies as a consumable file.","Usage of Type Enforced Directories","In this embodiment, to support the pipeline management goals, type enforced directories may be used. For example, non-components may be type enforced directories, with type-enforced access. \u201cRW\u201d denotes Read\/Write access, and \u201cR&D\u201d denotes the Read and Delete access needed for copying the job from component to component. \u201cRA\u201d indicates read access and append-only write access.","Processing Failed Files","In this embodiment, when a file fails the clean processing, the failure notification is written to audit. The processing of the file will be ended gracefully, and the failed file is sent to the audit. The Ledger is updated with all information about the file failure. Then the failed file is deleted from the job. If a failed file does reach the Collator, the Collator will delete it from the job.","In this embodiment, if this failure means the entire job has failed, then after writing to audit as required, all the job files will be deleted. The filter discovering the failure will write the job failure information into the Ledger, and delete files as it can. The Ledger then goes forward in the system and the job failure is recorded in the JTF and the Clean report. This will instruct the Collator, Forwarder and Work Scheduler to execute their procedures to clean up failed jobs. The Clean report, with the history of the processing of the job, will be sent forward into the Repository. The Repository will send out failure notifications and provide failure reports as required.","Synopsis of Pipeline Processing","In this embodiment, each file preferably starts from the Work Scheduler area, goes through the appropriate Filter processes and gets placed in the Forwarder area. If its processing is not yet completed after the current pass through the pipeline, then the file will be caught by the Collator and will be pulled back to the Work Scheduler area.","In this embodiment, when the job first comes into the Work Scheduler, the Work Scheduler will send the Job Manifest file through its filter pipeline. When the Forwarder gets the cleaned Job Manifest, it will analyze the Job Manifest and write the Job Tracking File (JTF). Then, the second time around, there will be a JTF written for the Work Scheduler to refer to for processing instructions.","In this embodiment, the Work Scheduler will read and analyze the JTF. It will copy\/delete back any unfinished files and newly extracted files that are currently in the Collator area. It will integrate the newly extracted files into the job. If any files need a file extension and \u201cmagic number\u201d checks for file type, the WS will do this. Then the WS will choose the next files to process and the next pipeline to send them to. The Work Scheduler writes the Ledger with this information and sends the job to the Router.","In this embodiment, the Router uses the Ledger as instruction, and pulls out only the necessary files from the job and sends them to the correct pipeline.","In this embodiment, each filter operates on the files, putting their findings into the Ledger. If new files are extracted, the extracted files are put into the \u201cquarantine\u201d directory, to be pulled back later and integrated into the job by the Work Scheduler.","In this embodiment, when the job reaches the Collator, it will sort out the cleaned files. Files finished all clean processing are put into the directory for the Forwarder. All other files are put into the directory for the Work Scheduler to pull back. The Collator then sends the job to the Forwarder.","In this embodiment, the Forwarder reads and analyzes the Ledger. It updates the Job Tracking File and the Clean Report with the Ledger information, and then deletes the Ledger. It pulls in any finished files. If the entire job is not complete, the job is sent back to the Work Scheduler.","In this embodiment, when the job completes, the Forwarder knows. At this time, all the files will be out of the Work Scheduler area. But the Work Scheduler has not cleaned up the directory yet, as it could not know if the files will succeed in moving into the Forwarder area or whether they will be returned. So in order to clean up the empty directory in the Work Scheduler area, the Forwarder will put a delete command in the queue for the Work Scheduler for that job. The Work Scheduler will recheck to ensure the directory is empty and delete it. The Forwarder can then move the job to the Reconstruct process.","Work Scheduler","In this embodiment, the purpose of the Work Scheduler is to perform the following functions:\n\n","Router","In this embodiment, the functions of the Router are:\n\n","Filter Components","In this embodiment, the function of a filter component is to run one related set of analysis\/clean functions on the document to be sanitized. Filter components will be run in series to implement all the required Clean functionality.","In this embodiment, filters will have management code, Common Control Functions, which allows it to run as part of the Guard system.","In this embodiment, the Common Control Functions include:\n\n","In this embodiment, the filter component may call third-party software to implement the actual cleaning of the input files. If the third-party software needs to be executed from a command line, the filter component will fork a child process to handle the job. If the third-party software uses threading, the filter component will create and use threads.","In this embodiment, the filter checks for new policy. The policy version to use for each job is specified in the Ledger file. The filter will check the Ledger policy version against the policy version it is currently running. If there is a discrepancy, the filter is updated by reading its new policy from the system configuration area.","In this embodiment, the AFT system-level configuration for the filter components will be viewed in terms of administrative concerns for site security policy. The configuration instructions sent to the filter component to implement this policy must necessarily be much more detailed and written in the format is needed for the specific filter. A translation library will interface these two levels, allowing policy updates to be done efficiently.","Collator","In this embodiment, the Collators performs the following functions:\n\n","Forwarder","In this embodiment, the function of the Forwarder is the following\n\n","In this embodiment, if this is a new job, there will be no existing JTF for it. In this case, read the Job Manifest file and create the JTF for this job.","In this embodiment, pick up the files which are waiting in the Collator's Completed Files directory.","In this embodiment, if the job has completed all processing, send the Delete command back to the Work Scheduler. Delete the Job Tracking File (any needed information is now in the Clean Report). Send the job to the Reconstruct component.","In this embodiment, if the job still has more processing to be done, send the job back to the Work Scheduler.","Reconstruct","In this embodiment, the functions involved in the Reconstruct component are:\n\n","Filter Types","In this embodiment, the following table shows examples of sanitization\/verification capabilities which apply to file types:",{"@attributes":{"id":"p-1610","num":"2419"},"tables":{"@attributes":{"id":"TABLE-US-00056","num":"00056"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sanitization\/Verification Capabilities in AFT"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Capability","Notes"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Virus Scan","The virus identification capability must be updatable through"]},{"entry":[{},"the Administrative interface. There will be 2 separate virus"]},{"entry":[{},"scans for every file, McAfee and Norton are required."]},{"entry":["Dirty Word Search (DWS)","DWS must use configurable Dirty Word and Clean Word"]},{"entry":[{},"lists. These lists will be configured by a policy"]},{"entry":[{},"administrator. A standard algorithm may be used in"]},{"entry":[{},"implementation of the DWS. All files must go through the"]},{"entry":[{},"DWS, including image files which may have text in"]},{"entry":[{},"metadata fields."]},{"entry":["Classification Markings","The Markings must be configurable by the policy"]},{"entry":[{},"administrator, both for the words used in the markings and"]},{"entry":[{},"where the markings are placed in the document."]},{"entry":["Mobile Code Check","Category 1 and Category 2 Mobile Code are not allowed."]},{"entry":[{},"Category 3 Mobile Code is allowed to be transferred. The"]},{"entry":[{},"AFT Guard will be compliant with DOD policy for mobile"]},{"entry":[{},"code."]},{"entry":["Hidden Data","If hidden data is found, the action taken may be to remove it"]},{"entry":[{},"and report it, or it may fail the file."]},{"entry":["Metadata","Removing metadata will be done as much as possible, with"]},{"entry":[{},"the exception that for some file types there are certain"]},{"entry":[{},"metadata fields which must be left in the file or the file will"]},{"entry":[{},"become unusable. The AFT Guard will inspect all files for"]},{"entry":[{},"meta data and allow for policy driven modification of meta"]},{"entry":[{},"data."]},{"entry":["File Type Check","The first method to check file type is be the file extension"]},{"entry":[{},"check. No file without a file extension in its name will be"]},{"entry":[{},"allowed through the AFT guard."]},{"entry":[{},"A second method used will be a \u201cmagic number\u201d validation."]},{"entry":[{},"This refers to the fact that most file types have some internal"]},{"entry":[{},"metadata which can be easily checked to confirm file type."]},{"entry":[{},"Note that not all file types have a \u201cmagic number\u201d."]},{"entry":[{},"These initial checks will determine if a file can proceed into"]},{"entry":[{},"the guard filtering. These checks are not a complete format"]},{"entry":[{},"validation."]},{"entry":["Format Validation","The detailed format validation will necessarily be done by a"]},{"entry":[{},"filter specific to the file type. Format validation filter will"]},{"entry":[{},"check the format and data within the file for anomalies."]},{"entry":["Nested Objects","The term \u201cnested objects\u201d refers to archived or compressed"]},{"entry":[{},"files. The mandate is extract all nested objects out into"]},{"entry":[{},"separate files which are then sent through all the Clean"]},{"entry":[{},"processing required for their file type. The AFT must also"]},{"entry":[{},"ensure the parent file stays within the configurable nesting"]},{"entry":[{},"level."]},{"entry":["Embedded Objects","The term \u201cembedded objects\u201d refers to files held within"]},{"entry":[{},"another file as, for example, OLE objects. Embedded"]},{"entry":[{},"objects must be detected and extracted and cleaning done"]},{"entry":[{},"upon the extracted files. Detection and extraction will be"]},{"entry":[{},"done by filters specific to the file type. The AFT must also"]},{"entry":[{},"ensure the parent file stays within the configurable"]},{"entry":[{},"embedding level."]},{"entry":["Steganography Check","Steganographic information is information hidden in plain"]},{"entry":[{},"sight by use of alternative formats For example,"]},{"entry":[{},"steganographic information may be hidden in image files by"]},{"entry":[{},"stealing the least significant bits of the image data, or could"]},{"entry":[{},"be hidden in text files by Mime-encoding non-text data. The"]},{"entry":[{},"AFT guard will check for this type of information."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, the table below shows examples of file types supported:",{"@attributes":{"id":"p-1612","num":"2421"},"tables":{"@attributes":{"id":"TABLE-US-00057","num":"00057"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Target File Types"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["File Category","File Type"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["MS Office Files","Word, .doc"]},{"entry":[{},"Excel, .xls"]},{"entry":[{},"PowerPoint, .ppt"]},{"entry":[{},"Rich Text, .rtf"]},{"entry":["Adobe PDF files","Only Version 1.3 and previous"]},{"entry":["Archive Files",".zip"]},{"entry":[{},".Z"]},{"entry":[{},".tar"]},{"entry":[{},".gz"]},{"entry":[{},".rar"]},{"entry":[{},".bz"]},{"entry":["ASCII","Only ASCII files of a known format will be allowed through the"]},{"entry":[{},"Guard."]},{"entry":[{},"All such files must have a file extension."]},{"entry":[{},"The format and file extension information will be entered"]},{"entry":[{},"into the Guard by the site policy administration."]},{"entry":["HTML",".htm, .html"]},{"entry":[{},"Only html files of a known schema will be allowed through"]},{"entry":[{},"the Guard. The schema information will be entered into the"]},{"entry":[{},"Guard by the site policy administration."]},{"entry":["XML",".xml"]},{"entry":[{},"Only xml files of a known schema will be allowed through"]},{"entry":[{},"the Guard. The schema information will be entered into the"]},{"entry":[{},"Guard by the site policy administration."]},{"entry":["Active Server Page",".asp"]},{"entry":[{},"Only asp files of a known schema will be allowed through"]},{"entry":[{},"the Guard. The schema information will be entered into the"]},{"entry":[{},"Guard by the site policy administration."]},{"entry":[{},"The processing for the .asp files needs more research"]},{"entry":[{},"concerning content validation and the configurations the"]},{"entry":[{},"policy can set. The information presented in this design is a"]},{"entry":[{},"starting point, to be modified further when more is known about the"]},{"entry":[{},"problem space."]},{"entry":["Image files",".jpg, .jpeg"]},{"entry":[{},".bmp"]},{"entry":[{},".tif, tiff"]},{"entry":[{},".wmf"]},{"entry":[{},".gif"]},{"entry":[{},".png"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, the following table applies to types of MS Office files (Word, PowerPoint, Excel, Rich Text).",{"@attributes":{"id":"p-1614","num":"2423"},"tables":{"@attributes":{"id":"TABLE-US-00058","num":"00058"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Filtering for MS Office Files"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Requirement","Pipeline and Filter Implementing Requirement"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["File Type Check - check file","Work Scheduler"]},{"entry":"extension and check \u201cmagic"},{"entry":"number\u201d information if it is"},{"entry":"available."},{"entry":["Virus Scan","Virus Scan pipeline, Virus Scan 1 and Virus Scan 2"]},{"entry":["Hidden Data - Discover and","MS Office pipeline, Hidden Data filter within the MS"]},{"entry":["scrub out any hidden data.","Office Suite"]},{"entry":["Metadata - Discover and scrub","MS Office pipeline, Metadata filter within the MS Office"]},{"entry":["out metadata.","Suite. There may be some metadata fields which will be"]},{"entry":[{},"allowed to remain in the document; this must be"]},{"entry":[{},"configured by site policy."]},{"entry":["Format Validation - Detailed","MS Office pipeline, MS Office Format Validation filter"]},{"entry":["format and data validation.","within the MS Office Suite."]},{"entry":[{},"This filter will also extract all fields of the document into"]},{"entry":[{},"a searchable text based format (xml in this case) so that"]},{"entry":[{},"the information can be searched by the later filters in the"]},{"entry":[{},"pipeline."]},{"entry":["Embedded Objects - Pull out","MS Office pipeline, MS Office Embedded filter within"]},{"entry":["embedded objects into their own","the MS Office Suite."]},{"entry":["separate files for further","This filter will extract embedded objects out into"]},{"entry":["processing.","separate files. The files names will be assigned by the"]},{"entry":[{},"Embedded filter, and as such will be trusted, the"]},{"entry":[{},"filenames will not need filename validation or dirty word"]},{"entry":[{},"search."]},{"entry":["Link Processing - Check all","MS Office pipeline, MS Office Link filter within the MS"]},{"entry":["document links against policy","Office Suite."]},{"entry":["approved links.","This filter will use the extracted file. Document links"]},{"entry":[{},"will be checked against the site approved links. Any"]},{"entry":[{},"links not on the approved list will be scrubbed out."]},{"entry":["Macro Processing - Check all","MS Office pipeline, MS Office Macro filter within the"]},{"entry":["document macros against policy","MS Office Suite."]},{"entry":["approved macros","This filter will use the extracted file. Macros will be"]},{"entry":[{},"checked against the site approved macros. Any macros"]},{"entry":[{},"not on the approved list will be scrubbed out."]},{"entry":["DWS - Dirty Word Search","MS Office pipeline, DWS within the DWS Suite."]},{"entry":[{},"The DWS Suite runs filters which apply to all text within"]},{"entry":[{},"files."]},{"entry":[{},"This filter will use the extracted file."]},{"entry":[{},"Clean and dirty word lists are configured by site policy."]},{"entry":["Classification Markings - Verify","MS Office pipeline, CM filter within the DWS Suite."]},{"entry":["correct classification markings.","This filter will use the extracted file."]},{"entry":[{},"Rules for classification markings are configured by site"]},{"entry":[{},"policy."]},{"entry":["Mobile Code Check - Check for","MS Office pipeline, MCC filter within the DWS Suite."]},{"entry":["Category 1 and Category 2","This filter will use the extracted file."]},{"entry":"Mobile Code."},{"entry":["Entrophy - Runs a statistical","MS Office pipeline, Entrophy filter within the DWS"]},{"entry":["analysis of the file to verify this","Suite."]},{"entry":["truly is ASCII text.","This filter will use the extracted file."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment, a special consideration is the requirement to maintain trusted links and macros in MS Office documents.","In this embodiment, in general, what vendors can offer is the ability to extract fields from the document out into an xml file. Additional drivers and filters will make use of this ability to fill the requirement to maintain trusted links and macros.","In this embodiment, the AFT mechanism for configuring the list of trusted macros and the list of approved links will have the policy administrator enter a reference file which has all the trusted macros or trusted links in it, and no other. All macros and links from this file will be extracted and saved as site policy. During Clean processing, the Macro and Link filters will refer to the site policy to evaluate which links and macros are approved.","In this embodiment, other file types may be filtered based on similar requirements.","Interface Components","Overview","In this embodiment, the AFT Interface supports the Hypertext Transport Protocol (HTTP) encapsulated in TLS; together, the two protocols are usually called HTTPS. The first Interface subcomponent, the Apache Server, controls HTTPS communications between the users and Guard via the network. A separate Apache Server supports each of the Interface roles (high-side user, FDO, and low-side user). The roles themselves are implemented by a second Interface subcomponent, the Transfer Agent. A separate Transfer Agent is associated with each Apache Server. The Apache Server and Transfer Agent communicate with other Guard components via the third Interface subcomponent, the AFT Application Programming Interface (API).  shows an example of three AFT Interface subcomponents and some internal detail.","HTTP Server","In this embodiment, the Apache Web server was chosen as the AFT HTTP server because it offers a flexible and highly customizable architecture, which will enable enhanced security by tailoring to include only the modules that are required. It is the most-used Web server on the Internet, with more than 70% of all Web sites using it, and the associated SELinux policy is well established and widely distributed.","In this embodiment, the Apache Server supports communications between the user and the Guard by implementing the following functions.\n\n","Transfer Agent","In this embodiment, the Transfer Agent provides the application support needed for the Interface role. It is implemented as a set of Common Gateway Interface (CGI) programs. These CGI programs communicate with other Guard components via the AFT Application Programming Interface (API).","AFT API","In this embodiment, the AFT API was developed to shield the Interface from the details of communicating with the Guard's internal components. It provides the following core capabilities in a set of easily understood library functions that the Interface can call. Examples of services provided by the API are listed below:\n\n","Apache Server","Component Description","In this embodiment, the Apache Server supports communications between the user and the Guard by providing the following capabilities.\n\n","Component Design","In this embodiment, much of Apache's functionality is provided by modules, which are external libraries loaded at start time as specified by configuration options. The Apache functions important for AFT are controlled or affected by modules that are either distributed with Apache, or will be developed by the AFT developers.  shows an example of the AFT Guard Interface detail, which includes the Apache Server subcomponent and associated modules.","In this embodiment, although not shown in the diagram, error conditions described in this document are reported to the Audit component via the AFTaudit function of the AFT API described in a separate section of this document.","Common Gateway Interface (CGI)","In this embodiment, when the Apache Server gets a request for a CGI program, it executes the CGI program as another process (i.e., a separate application); Apache passes this process some parameters and collects its output, which it then returns to the client just as if had been fetched from a static file. This provides a very flexible and dynamic application environment on the Apache Server, because CGI programs can tailor the HTML returned to the browser that initiated the request. From an SELinux perspective, CGI also provides a method to separate the Apache Server and application domains because executing a program is one way to transition from one domain to another.","In this embodiment, the CGI capability is implemented as a module in Apache. AFT uses a third-party module, mod_fastcgi, which enables CGI programs to be implemented as long-running daemons, avoiding the fork\/exec overhead of normal CGI execution. These daemons communicate with mod_fastcgi via a TCP or UNIX socket by calling FastCGI library functions. This enables them to retrieve variables that are passed to normal CGI programs via the environment, and to redirect their standard input and output over the socket to read HTTP POST data and write responses back to the client.","TLS Session Management and Encryption","In this embodiment, TLS encryption is implemented by the mod_ssl module. Users may connect to the Guard using HTTP over TLS, or HTTPS, so they must specify an https:\/\/ prefix on the URL they type into their browser. Establishing a TLS session is computationally expensive, so mod_ssl caches information to avoid full session set-up requirements for subsequent HTTPS requests. AFT stores this cache on the SAN so that the TLS session may be redirected to any node without interruption as the user clicks through the application.","TLS Session Types","In this embodiment, two flavors of HTTPS connections are possible, depending on whether weak or strong authentication is used. For weak authentication, only the server (Guard) side of the connection presents an X.509 certificate to initialize the TLS session. This means the user is assured that they're communicating with the Guard (not another machine masquerading as the Guard), but not vice versa. For strong authentication, both the Guard and user present certificates, so both sides are assured they're communicating with the correct entity.","Encryption Types","In this embodiment, AFT employs nCipher's nShield Hardware Security Module (HSM) cards to reduce encryption and decryption overhead. These cards are driven by Certicom's Apache mod_ssl replacement module. AFT will support the intersection of the encryption types supported by the Certicom mod_ssl module and the users' browsers.","Authentication","In this embodiment, the Apache Server supports both weak and strong authentication. Weak authentication is based on username and password pairs. Strong authentication requires an X.509 certificate issued by an organization's Public Key Infrastructure (PKI). The type of authentication is configurable, based on the Apache \u2018Require\u2019 directive for location specified by the URL.","Weak Authentication","In this embodiment, weak authentication, based on username and password, is provided by the mod_session module. This is an AFT replacement for the mod_auth Apache module, which enables session tracking in addition to authentication. It provides the check_user_id and auth_checker Apache hooks invoked by the other modules to ensure the request is authenticated. The authentication algorithm is configurable, and may be Basic or (more secure) Digest, depending on what the users' browsers support.","In this embodiment, if an unexpired session record doesn't exist for the user, mod_session instructs the browser to prompt the user for username and password. Upon receipt of the username and password, mod_session validates the information by calling the AFTweakAuth function of the AFT API, which communicates with the Auth component. If validation fails because the password has expired, it audits the event and redirects the browser to the Passwd CGI program that helps the user create a new password. If validation fails for another reason, it audits the event and repeats the authentication process a configurable number of times. If all attempts fail, it calls AFTweakAuth with a null credentials parameter, which instructs the Auth component to disable the user account, and audits the result.","In this embodiment, if authentication is successful, mod_session updates the memory-resident request record so other modules can verify that authentication has occurred. Part of this update includes the AFT userID returned by the Auth component, which is used throughout the system to uniquely identify a user without revealing the username. Mod_session also stores the userID in, and deletes other authentication credentials from the CGI environment used to pass information to the Transfer Agent. It then redirects the browser to the SessInit program, which creates and stores a new session record in the session database, so that it can track the session.","Strong Authentication","In this embodiment, strong authentication, based on an X.509 certificate, is provided by the mod_ssl module as part of TLS session establishment. Because mod_ssl is provided by a third party, Certicom, and isn't easily modified, the mod_ssla AFT module hooks in with it to validate the certificate. Mod_ssla calls the AFTstrongAuth function of the AFT API, which communicates with the Auth component. If validation fails, mod_ssla immediately calls AFTstrongAuth with a null credentials parameter, which instructs the Auth component to disable the user account, and audits the action. Additional authentication attempts are not allowed because any failure indicates the certificate is invalid.","In this embodiment, if authentication is successful, mod_ssla updates the memory-resident request record so other modules can verify that authentication has occurred. Part of this update includes the AFT userID returned by the Auth component, which is used throughout the system to uniquely identify a user without revealing the user's name or other information stored in the X.509 certificate. The mod_session module subsequently uses the request record to store the userID in, and delete other authentication credentials from the CGI environment used to pass information to the Transfer Agent. Mod_session then redirects the browser to the SessInit program, which creates and stores a new session record in the session database, so that it can track the session as described in the next section.","User Session Tracking","In this embodiment, the AFT mod_session module performs most user session tracking functions to satisfy two requirements.\n\n","In this embodiment, the session tracking algorithm benefits from the following session characteristics.\n\n","In this embodiment, these session requirements and characteristics eliminate any need for session ID tokens, so session tracking requires only a very simple session database. The session database records are keyed (searched) by userID. The record values are the timestamp of the associated user's last request.","In this embodiment, the mod_session module reads the session database, but does not update it. All updates are performed by the CGI application programs. If necessary, mod_session redirects the browser to another CGI program that performs an update as part of its processing. These redirects can occur for the following situations.\n\n","In this embodiment, updating the session record timestamp is done by the CGI programs because some requests, those submitted automatically by the browser on behalf of the user, should not affect session expiration. Automatic updates are controlled by the CGI programs; ergo, timestamp updates are controlled by the application, and mod_session doesn't need to be modified whenever an application change affects an automatic request.","HTTP-Level Security","In this embodiment, the AFT Apache Server employs the mod_security third-party module, open source intrusion detection and prevention engine for Web applications. It performs the following functions.\n\n","Performance-Related Design Decisions","In this embodiment, nCipher's nShield HSM cards reduce overhead associated with TLS encryption. Certicom's mod_ssl Apache module replacement offloads encryption and decryption tasks to the card.","In this embodiment, the mod_fastcgi module enables CGI programs to be implemented as long-running daemons, avoiding the fork\/exec overhead of normal CGI execution. These daemons communicate with the module via a TCP or UNIX socket by calling FastCGI library functions. This enables them to retrieve variables that are passed to normal CGI programs via the environment, and to redirect their standard input and output over the socket to read HTTP POST data and write responses back to the client.","Database Design Decisions","In this embodiment, most databases used in the AFT Guard are simple, filesystem-resident, dbm files for two reasons.\n\n","In this embodiment, the following Apache server databases are implanted as dbm files on the SAN.\n\n","Security Design Decisions","In this embodiment, a separate nShield HSM card is used for each Guard Interface to eliminate security and performance concerns associated with shared cards, which would require low-level routines to clean hardware registers or other data caches when switching between Apache processes. Each Certicom mod_ssl module is \u201cbound\u201d to a specific card.","In this embodiment, one reason we chose the CGI Web application model was because it offers SELinux domain separation between the Apache server and the application programs.","In this embodiment, TLS-based (strong) authentication by a CGI program is infeasible, so a CGI program would need to \u201ctalk back\u201d to a module to reliably destroy a TLS session and force another authentication exchange when it closes a user session. This would require a module that understands what the CGI is trying to say.","User Interfaces","In this embodiment, the AFT User Interface (UI) component is the interface that enables users to transfer files from one classification domain to another. Requirements may dictate that the client accomplishes this using the standard software base on the user workstations. This requirement drives the UI design towards a Web-based solution that may utilize the existing Java runtime environments on the workstations.","In this embodiment, the UI will be implemented through a Web browser. The browser may need to download Java applets from the guard to meet near real-time feedback requirements.","In this embodiment, in providing the above functions, the client preferably has a minimal amount of impact on the high-side client in the areas of performance, configuration, and maintenance.","Component Description","In this embodiment, the AFT UI component provides secure for access into the AFT Guard from a user's workstation. Users will be required to authenticate to the system to gain access. User's authentication information will be sent to the AFT Guard for log on verification.","In this embodiment, the UI will be designed in a modular fashion, as much as possible, to support plug-and-play UI capability in the future. This will ease the implementation of alternative UI front-ends that can access the functionality to clean and transfer files.","In this embodiment, the UI displays will be implemented as a graphical user interface (GUI) executed from a Web browser using HTML. This design minimizes software installation on both the High-side and Low-side user environments needed to support the AFT application. The High-side and Low-side workstations may have a Web browser, specifically a Java-enabled (version 1.4 or greater) browser. The AFT is not responsible for providing the Web browser or for its installation.","In this embodiment, AFT displays for the three defined AFT user roles (high-side user, low-side user, and FDO) will have similar navigation and visual appearance for consistency. These roles are controlled by the guard.","In this embodiment, the high-side AFT Client provides displays required to:\n\n","In this embodiment, the low-side AFT Client provides displays required to:\n\n","In this embodiment, the FDO AFT Client provides displays required to:\n\n","Component Design","In this embodiment, the main goal of the GUI design is to make the AFT Client application as familiar as possible to the user by employing techniques of other windows-based applications. This familiarity aids the user in the successful use of the application and decreases learning time.","Use Cases","In this embodiment, these use cases only address the AFT application as a stand-lone alone application and does not include CAB interaction.","Assumptions\/Pre-Conditions","In this embodiment, the following conditions have occurred for each use case:\n\n",{"@attributes":{"id":"p-1689","num":"2581"},"tables":{"@attributes":{"id":"TABLE-US-00059","num":"00059"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"High-Side, Low-Side, and FDO Use Cases"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"User",{},{}]},{"entry":["Use Case id","role","Description","Notes"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","HS, LS,","The user logs onto the AFT system","cab\/aft option - cab only, aft"]},{"entry":[{},"FDO",{},"only, cab\/aft"]},{"entry":[{},"HS, LS,","a. User enters name and password and clicks"]},{"entry":[{},"FDO","logon button"]},{"entry":[{},"HS, LS,","b. On successful login the user is presented"]},{"entry":[{},"FDO","the Received page"]},{"entry":[{},"HS, LS,","c. On logon failure, user denied access and"]},{"entry":[{},"FDO","is sent a denial message"]},{"entry":["2","HS, LS","The user wants to submit file(s), and\/or","Uses\u201cSubmit File\u201d menu"]},{"entry":[{},{},"directory(ies)","option"]},{"entry":["3","HS, LS","The user selects submit recipient","Submit Form"]},{"entry":[{},{},"(individual(s), group(s))"]},{"entry":["4","HS, LS","The user want to search for submit recipient","Submit Form - uses \u201cfind\u201d"]},{"entry":[{},{},"(individual(s), group(s))","button"]},{"entry":["5","HS, LS","The user wants to enter a comment to","Submit Form"]},{"entry":[{},{},"accompany submittal"]},{"entry":["6","HS, LS","The user wants to traverse directory to","Submit Form"]},{"entry":[{},{},"select file for submittal"]},{"entry":["7","HS, LS","The user adds file(s) and\/or directory(ies) to","Submit Form - uses \u201cadd to"]},{"entry":[{},{},"submit list","list\u201d button"]},{"entry":["8","HS, LS","The user wants to remove items from the","Submit Form"]},{"entry":[{},{},"submittal list."]},{"entry":["9","HS, LS","The user wants to commit the selected files","Submit Form - clicks send"]},{"entry":[{},{},"for cleaning, or clicks reset to clear entire","button to commit"]},{"entry":[{},{},"list of files. or click remove from list button"]},{"entry":[{},{},"to remove file(s) from list"]},{"entry":["10","HS, LS","The user wants to clear all information (To,","Submit Form - clicks reset"]},{"entry":[{},{},"Comment, selected files) on submit form","button to clear user input on"]},{"entry":[{},{},{},"form"]},{"entry":["11","HS, LS","The user wants to cancel submit window","Submit Form - clicks cancel"]},{"entry":[{},{},"that has list of file(s) to be sent which","button. The Submit form is"]},{"entry":[{},{},"returns user to welcome page?","cleared."]},{"entry":["12","HS","The user wants to review cleaned files"]},{"entry":["13","HS,","The user wants to read the clean report","User clicks on the Review &"]},{"entry":[{},"FDO","associated with the cleaned files","Release folder"]},{"entry":["14","HS, LS","The user wants to cancel a submitted job","HS: Review & Release"]},{"entry":[{},{},{},"folder - Review Report"]},{"entry":[{},{},{},"button"]},{"entry":["15","HS","The user wants to terminate the AFT","FDO: Review - Review"]},{"entry":[{},{},"session.","Report button"]},{"entry":["16","HS, LS","The user wants to customize GUI","Review & Release folder -"]},{"entry":[{},{},"presentation","Delete button"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Interface Descriptions","In this embodiment, the AFT UI manages visual displays and user input\/output for the client application using the Web browser. This includes mouse and keyboard inputs, message displays, and file transfers. Communication to the AFT guard is accomplished by using HTTP for file transfers, message transmissions, and authentication to the guard.  shows an example of a notional AFT user interface.","Transfer Agents","Description","In this embodiment, the AFT Guard Transfer Agent performs the bulk of Guard processing pertaining to the user and FDO Interfaces by providing the following functions.\n\n","Design","In this embodiment, a separate Transfer Agent (TA) subcomponent supports each of the three Guard Interfaces: the High-Side User TA (HSUTA), High-Side FDO TA (HSFTA), and Low-Side User TA (LSUTA). Each is implemented as a set of Common Gateway Interface (CGI) programs invoked by a user or FDO through their respective Interface. With the few exceptions noted in this document, each TA has an identical set of programs. Although a given program may function identically in each TA, its SELinux context and the system resources it may access are \u201chard-coded\u201d at installation time. Therefore, the program descriptions in this document are not delineated by TA, though this delineation is detailed in the resource access requirements tables.","In this embodiment, the TA programs are invoked by the Apache Server subcomponent of the Interface when the user executes a request through the browser. The Apache Server ensures the requests are associated with an authenticated session, and stores the userID, returned by the Auth component, in the environment. This environment variable is read TA programs to establish the identity of the user.",{"@attributes":{"id":"p-1698","num":"2596"},"figref":"FIG. 37"},"Format Browser Display Content","In this embodiment, TA programs format HTML responses for display in the user or FDO browser. The formatting logic is therefore implemented as shared modules in the TA programs.","Track Sessions","In this embodiment, an AFT session begins when a user authenticates to the system, which is controlled by the Apache Server. It ends when the user's session record is revoked by the user (i.e., a Logout button is clicked) or by the system (the session expired). During the session, the user is free to use the application to perform the AFT functions. Afterwards, the user must login again before using the application. AFT must track sessions to meet two requirements.\n\n","In this embodiment, the Apache Server subcomponent of each Interface performs authentication tasks, and ensures all requests are associated with active sessions. This section describes the TA programs that do most of the session tracking work: TAsessInit, TAsessUpdate, and TAsessTerm in this embodiment.","TAsessInit Program","In this embodiment, each TA includes a TAsessInit program that initializes a user session by performing the following tasks.\n\n","In this embodiment, functionality\n\n","TAsessUpdate Module","In this embodiment, each TA program executed because of a user request (i.e., not an automatic transaction) updates the user's session database record. TAsessUpdate, then, is not a separate program but a shared module called by those TA programs.","In this embodiment, functionality\n\n","Resource Access Requirements","In this embodiment, because TAsessUpdate is a module that all request programs execute, they all require write access to their corresponding session database.","TAsessTerm Program","In this embodiment, each TA includes a TAsessTerm program that terminates a user session by performing the following tasks.\n\n","Functionality\n\n","Check File Status","In this embodiment, this TA function encompasses all the programs that enable a system user or FDO to check the status of their files. Two TA programs return status of the following file categories.\n\n","TAfiles Waiting Program","In this embodiment, this program enables users to check the status of files that have been transferred through the system and are awaiting their download. This may include files sent to a group, if the user is a member of the group. For a high-side user or FDO, this also includes reports the system generated that need to be reviewed. Low-side users may not receive reports in this embodiment, and therefore may only receive status for files that were sent to them by high-side users.","In this embodiment, functionality\n\n","TAfilesSubmitted Program","In this embodiment, only high-side users may check the status of files they submitted. The TAfilesSubmitted program provides this functionality by querying the databases for the following repositories.\n\n","Functionality\n\n","Transfer Files","In this embodiment, this is the core function of the AFT Guard, and encompasses the largest set of programs performing the following tasks.\n\n","TAretrieveFiles Program","In this embodiment, this program enables a user to download files from the AFT Guard. Both high- and low-side users can download files that have completed processing and are addressed to them or a group to which they belong. Only high-side users can retrieve files and reports produced by the Clean process so that they can review the changes before releasing them for further processing.","In this embodiment, an FDO cannot download a file that has completed processing (i.e., an FDO cannot be designated as the final recipient of a file); for that, an FDO would require a separate user account. Rather, the system stores files that have completed the Clean process so that a designated FDO can perform a final review before releasing them for Verify processing. Therefore, the TAretrieveFiles program also enables an FDO to download files and reports produced by the Clean process so they can perform the review.","In this embodiment, functionality\n\n","TAsubmitFiles Program","In this embodiment, each TA includes a program to submit files into the system. The TAsubmitFiles program performs the following tasks to validate and accept the files for transfer.\n\n","In this embodiment, functionality\n\n","Release In-Process Files","In this embodiment, both TA subcomponents on the high side require functionality to release in-process files. The system holds these files at the HS User Repository and the HS FDO Repository. The reason for the hold is to enable the user and FDO, respectively, to review cleaned files and approve them for transfer. The TAreleaseFile program performs this function for both repositories. The FDO TA provides additional functionality with the TArejectFile program, which enables the file to be \u201creleased\u201d in the negative sense, along with explanatory comments for the high-side user.","TAreleaseFile Program","In this embodiment, for files held in the HS User Repository, TAreleaseFile enables the user to release the file to the HS FDO Repository (or the Verify component if the system isn't configured for an FDO). For files held in the HS FDO Repository, TAreleaseFile enables the FDO to release the file to the Verify component.","In this embodiment, functionality\n\n","TArejectFiles Program","In this embodiment, this program \u201creleases\u201d files from the HS FDO Repository, but instead of going forward to the Verify component, they go backward to the HS User Repository where the user can review them. TArejectFile requires the FDO to enter comments to explain the rejection to the high-side user, which are sent back as a separate file, along with the files that were rejected.","In this embodiment, functionality\n\n","Delete Files","In this embodiment, only the High-Side User Transfer Agent includes a program to delete cleaned files. This functionality is needed to remove files after the user reviews them and finds unacceptable alterations were performed by the Clean process.","TAdeleteFiles Program","In this embodiment, functionality\n\n","Display Notification Messages","In this embodiment, both High-Side Transfer Agents include a program to display messages sent by internal Guard components to a messages area in the browser display. These messages are \u201cpushed\u201d to the user and FDO in the sense that the user doesn't need to specifically request them. They are retrieved automatically. Low-side users do not receive such messages.","TAdisplayMsgs Program","In this embodiment, this program is invoked periodically via a meta tag (<meta http equiv=\u201crefresh\u201d content=\u201crefresh_seconds\u201d>), or whenever a user action causes a screen update. The meta tag causes the browser to automatically send a request that invokes the TAdisplayMsgs program, which sends another meta tag in its response, and so on, ensuring the updates continue until the session terminates.","In this embodiment, TAdisplayMsgs is currently the only TA program that does not update the session timestamp. This ensures a session will expire after a configurable interval, even though the TAdisplayMsgs program continues to execute periodically.","In this embodiment, functionality\n\n","Change Password","In this embodiment, AFT requirements dictate that users must change their passwords periodically. The TApasswd program enables them to accomplish this through their browsers. The Apache Server subcomponent may redirect their displays to this program when it detects and expired password, or they may invoke it proactively.","TApasswd Program","In this embodiment, this program prompts the user for the current and new passwords. It then communicates with the Auth Component to verify the current password and validate the new password. The Auth component ensures site password policy rules are met.","In this embodiment, functionality\n\n","Message Manager","In this embodiment, the Message Manger component enables AFT to \u201cpush\u201d messages to users. These messages are initiated by the Administrator or Guard and are not in response to a direct request from the recipient. Only high-side users receive them, although the design does not preclude low-side users, as well.\n\n","Software Architecture","In this embodiment, Message Manager I\/O is through AFT Queues. It leverages the following AFT Queue characteristics.\n\n","In this embodiment, the Message Manager accepts messages from the repository managers through a single input AFT Queue. The Message Manager creates this queue when it starts during system initialization. In this embodiment, the following fields comprise the message format.\n\n","In this embodiment, each message also has an inherent priority attribute that is specified by the sending component. Higher numeric values indicate higher priority messages, which affect the order the messages are read and may be used by the receiving component to format message displays for the user.","In this embodiment, the sending component is responsible for formatting the message content. Depending on site configuration, the format may be HTML. This enables the sending repository manager to include clickable links to files within its repository.","In this embodiment, upon receiving a message, the Message Manager validates its format and looks in the High-Side User and\/or High-Side FDO message area, depending on the message Component field, for an AFT Queue whose name matches the UserID field. These queues are created by the Transfer Agent login subcomponent and deleted by the logout subcomponent, so the presence of a queue means the user has an active session. If the queue is found, the message is copied to it with the same priority value that was read from the input queue. Otherwise, if the site is configured for e-mail delivery, the message is copied unaltered to the E-Mail Spooler AFT Queue. The E-Mail Spooler uses the userID message field to look up the recipient's e-mail address for delivery via the site e-mail server.","In this embodiment, this architecture enables immediate message delivery to users' browsers when they're logged on to the system, or delayed delivery via the site's e-mail infrastructure when they aren't.","Interface Related Design Decisions","In this embodiment, the Message Manager writes messages to asynchronous, filesystem-resident AFT Queues. These queues are created by the Transfer Agent login subcomponent and deleted by the logout subcomponent, so a given queue only exists for the life of the user's session. Their names are based on userID, so they're easily located from the userID contained in each message.","In this embodiment, the Transfer Agent periodically reads the accumulated messages, whenever the user's HSUMD (High-Side User Message Display) or HSFMD (High-Side FDO Message Display) CGI program is executed.","In this embodiment, for systems configured to send e-mail messages, the Message Manager may forward the message, unaltered, to the E-Mail Spooler component when a user's message queue doesn't exist (i.e., when the user is not logged onto the system).","Flexibility, Availability, and Maintainability Design Decisions","In this embodiment, the message queues reside on the SAN so that any Guard node can write to them, and a given user can login on any Guard node and receive messages.","E-Mail Spooler","In this embodiment, the AFT E-Mail Spooler is a long-running daemon process that accepts messages from the Message Manager and delivers them via the site e-mail infrastructure to the users specified in the messages. Because it does not receive messages over the network, it is not another interface for submitting files to the system. Its only function is to implement an alternative conduit for notification message delivery when the user is not logged onto the AFT Guard. Notification messages are initiated by the Guard and are not in response to a direct request from the recipient. Only high-side users receive them, although the design does not preclude future support for low-side users, as well.","In this embodiment, the E-Mail Spooler exists only if the system is configured to support e-mail notification messages. In that case, it is started during system initialization.","Software Architecture","In this embodiment, the Message Manager forwards messages unchanged from the repository managers. The E-Mail Spooler accepts messages from only the Message Manager, through a single input AFT Queue. It creates this queue when it starts during system initialization. The queue resides on the SAN, so any Guard node's E-Mail Spooler can process the messages.","In this embodiment, the sending repository manager is responsible for formatting the message content. Depending on site configuration, the format may be HTML. This enables the sending repository manager to include clickable links to files within its repository.","In this embodiment, upon message receipt, the E-Mail spooler queries the Authentication component to obtain the e-mail address associated with the username field of the message.","In this embodiment, after looking up the e-mail address, the E-Mail Spooler queries the Domain Name Service (DNS) to ascertain the mail server associated with the address. At least one DNS server must be specified in the E-Mail Spooler configuration. The server must allow recursive DNS queries from the Guard's IP address.","In this embodiment, after obtaining the mail server, the E-Mail Spooler sends the message via a Simple Mail Transport Protocol (SMTP) exchange.","Administrative Interface","In this embodiment, the Administration functional area will manage all aspects of system configuration and operation. Role-based privilege enforcement allows the following responsibilities to be divided among one or more administrators, depending on site requirements.\n\n","In this embodiment, the Administration component will customize the configuration of the system and provide interface to view audit and performance information. The implementation for system administration may be GUI-based. Any modifications to configuration data may be verified to insure that and configuration changes make sense in context to the field before those changes are committed to the system. Verification of the configuration file schema may be handled by Samhain integrity tool. Samhain is a file system integrity checker that can optionally be used as a client\/server application for centralized monitoring of networked hosts. Databases and configuration files can be stored on the server. In addition to forwarding reports to the log server via authenticated TCP\/IP connections, several other logging facilities (e-mail, console, tamper-resistant log file, and syslog) are available","In this embodiment, AFT will use version numbers on each filter policy configuration. The Administration Component will put the updated configurations to their configuration directories. Submit jobs that are in progress will continue to use the configuration version that existed when the submit job was initiated. New submit jobs will pickup the new version.","In this embodiment, Authorization and Access control will be mitigated by the AFT defined role model. The role model will define the access limits for data and processes, e.g., certain roles have access to certain applications at certain times. The role model will be maintained on the guard in a database and will map to SE Linux roles. The following is a list of exemplary AFT roles.","In this embodiment, the Administration Component will provide a GUI for maintaining configuration data. GUI's will be developed for configuring the following examples:\n\n","Interface Descriptions","In this embodiment, the Administration Component has tight integration with the configuration file subsystem and will interact with the init and audit subsystems. This component sits at a layer above the configuration file and is passed data types and values that are then verified.","In this embodiment, the Administration Component will invoke process defined library functions that will access the Admin databases to create configuration information specific for that process. This permits the flexibility to provide configuration information in the specific form needed by the process such as flat files or xml files.","User Interface Design","In this embodiment, a GUI will be available to enter configuration for the AFT Subsystem that will be stored in Administration maintained databases.","Decision to Develop or Reuse","In this embodiment, AFT will reuse software modules written for the CAB CDS to provide much of the Administration capability. AFT-specific functionality will be implemented as needed.","In this embodiment, the administration verification tools will be written specifically to validate GUI inputs.","In this embodiment, because of the high-assurance qualities of the system, privileged administrative and maintenance users will require direct physical access to several individual components using a set of administrative interfaces with a common \u201clook and feel.\u201d","Interface-Related Design Decisions","In this embodiment, the Administration component obtains and verifies data from the configuration file and configuration databases. If the configuration file passes verification the only output from this component is a successful error code, however if the file does not pass inspection, an error message describing the failure is printed and an unsuccessful error code is returned.","Performance-Related Design Decisions","In this embodiment, the only impact on performance will be when a data is committed to the system.","Database Design Decisions","In this embodiment, the Administration Component will use databases to store and retrieve configuration data. The databases (System config, Audit config, User Mapping, Firewall config, and filter policy) need to be persistent and therefore will all be stored on the SAN.","Safety, Security, and Privacy Design Decisions","In this embodiment, the Administration Component relies on the SELinux policy to provide security for the system. The policy confines the administrative binaries and configuration files into a restricted domain isolating them from other parts of the system.","In this embodiment, virus definition files are maintained by an authorized system administrator.","In this embodiment, clean and dirty word lists are maintained by an authorized system administrator.","In this embodiment, system components will be maintained by authorized system administrators or by designated maintenance personnel who have been properly cleared and trained. The administrators are fully trusted and will not conduct operations outside the security policy.","In this embodiment, AFT must support a flexible configuration that adheres to the security policies in place at each deployment site.","Flexibility, Availability, and Maintainability Design Decisions","In this embodiment, the Administrator Component will maintain data needed to allow the guard to communicate with other guards for facilitating load and administrative data sharing.","The above description is presented to enable a person skilled in the art to make and use the invention, and is provided in the context of a particular application and its requirements. Various modifications to the preferred embodiments will be readily apparent to those skilled in the art, and the generic principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the invention. Thus, this invention is not intended to be limited to the embodiments shown, but is to be accorded the widest scope consistent with the principles and features disclosed herein."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 37"}]},"DETDESC":[{},{}]}
