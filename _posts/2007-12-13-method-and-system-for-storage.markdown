---
title: Method and system for storage
abstract: A method and system for storage is provided that in one embodiment includes a store process that continually appends data to the end of a data file and without deleting the data file. Additions, changes and deletions to data are managed by adding new data to the file and changing appropriate pointers in the data file to reflect the new data. Various application programming interfaces are also provided so that the store process can operate transparently to higher level applications. Various plug-ins are also provided so that the store process can utilize different types, configurations and numbers of storage devices.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08805897&OS=08805897&RS=08805897
owner: Redknee Inc.
number: 08805897
owner_city: Mississauga
owner_country: CA
publication_date: 20071213
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF THE EMBODIMENTS"],"p":["This specification relates generally to computer hardware and software architecture, and more particularly relates to a method and system for storage.","Relational databases were originally developed at a time when the speed of central processing units (\u201cCPU\u201d) were relatively slow, the amount of random access memory was relatively small, the size of hard disks was relatively small, but the speed at which hard disks was accessed was relatively fast. Interestingly, hardware advancements have now lead to a different paradigm, where CPUs are relatively fast, the amount of random access memory is relatively high, the size of hard disks is relatively large, but the speed at which hard disks are accessed is relatively slow. This new paradigm means that where large amounts of data are written in relatively small blocks across a large hard disk, the speed at which that data can be accessed is somewhat limited.","A method and system for storage is provided that in one embodiment includes a store process that continually appends data to the end of a data file and without deleting the data file. Changes to data structures are managed by adding new data to the file and changing appropriate pointers in the data file to reflect the new data. Various application programming interfaces are also provided so that the store process can operate transparently to higher level applications. Various plug-ins are also provided so that the store process can utilize different types, configurations and numbers of storage devices.","An aspect of the specification provides a method for storing comprising:\n\n","Another aspect of the specification provides a skip-list data structure readable by a processing unit. The processing unit is configured to perform operations on contents of the data structure. The skip list data structure comprises a root object, a first child object and a plurality of additional child objects. The root object includes a pointer from said root object to said first child object. The root object also includes a pointer from the root object to every other one of the additional child objects. The every other one of said additional child objects including a pointer to one of each of said additional child objects to which said root object does not point.","Referring now to , a system for storage is indicated generally at . System  can be based on a now-known or future-conceived computing environment. To provide an example,  shows a block diagram representing exemplary components of system . System  thus includes a processor  (which can also be referred to as a central processing unit) which interconnects input devices, if present, (e.g. a mouse  and keyboard ) and output devices, if present, (e.g. a display ). Processor  can be implemented, of course, as a plurality of processors or one or more multi-core processors. Processor  is also connected to a persistent storage device . Persistent storage device  can be implemented using, for example, a hard disc drive, a redundant array of inexpensive discs (\u201cRAID\u201d), or the like, and\/or can include other programmable read only memory (\u201cPROM\u201d) technology, a removable \u201csmart card\u201d and\/or can comprised combinations of the foregoing.","System  also optionally includes a network interface  that connects processor  to a network (not shown), which in turn can connect to one or more additional persistent storage devices (not shown) that are similar in function to persistent storage device .","System  also includes volatile storage , which can be implemented as random access memory (\u201cRAM\u201d), which can be used to temporarily store applications and data as they are being used by processor . System  also includes read only memory (\u201cROM\u201d)  which contains a basic operating system containing rudimentary programming instructions, commonly known as a Basic Input\/Output System (\u201cBIOS\u201d) that are executable by processor  when system  is initially powered so that a higher level operating system and applications can be loaded and executed on processor . Collectively, one can view processor , volatile storage device and ROM  as a microcomputer. It should now be apparent that system  can be based on the structure and functionality of a commercial server such as a Sun Fire X4450 Server from Sun Microsystems Inc., of Palo Alto, USA, but it is to be stressed that this is a purely exemplary server, as server  (and other elements of system and its variants) could also be based on any type of computing device including from other manufacturers.","The microcomputer implemented on system  is thus configured to store and execute the requisite BIOS, operating system and applications to provide the desired functionality of system . In particular, system  is configured so that a plurality of processes is executable on processor . In , processor  is represented as configured to execute the following processes: store , read , commit  and root  each of which can be invoked by commands entered via keyboard  and\/or via other processes (not shown) executing on processor . Also in , persistent storage  is shown as maintaining a file  that can be operated upon by store , read , commit  and root  as will be discussed in greater detail below. File  in  is shown as being \u201cempty\u201d, only including an end-of-file marker EOF, which is located at Location zero L within file .","Referring now to , a flow-chart depicting an exemplary method of implementing store  is indicated generally . Exemplary performance of store  is represented in  as an object O is shown as being taken from volatile storage  and stored within file  using store . At block , a write command is received. Such a write command can be received by store  using any known means, including a direct command inputted via keyboard , or via another process (not shown) executing on processor . At block , the object to be written is received. The object received at block  is associated with the write command received at step . At block , the end of file is sought. As part of block , store  accesses file  and seeks end-of-file marker EOF in file  in order to determine the Location of end-of-file marker EOF. Taking the result from block , at block  store  defines the write Location in file  for object O, which in the present example is Location L. At block , the object is written at the Location defined at block . Block  is represented in  as object O is shown now located at Location L within file . At block  an object identifier is defined that is associated with object O as it is now stored in Location L. The object identifier can be any index or pointer that now reflects Location L. At block , the end-of-file marker EOF is redefined to the Location after the Location in which the object has been written at step . In the present example, as shown in , end-of-file marker EOF is now shown as stored in Location L.","It should now be understood the repeated performances of store  will continue to append objects to file . For example, assume that store  is executed again for a second object O immediately after the preceding exemplary performance of store  for object O. As a result of such performance, file  would appear as represented in , with object O in Location L, object O in Location L, and end-of-file marker EOF at Location L. To continue with this example, the object identifier for O is Location L. According to this example, Table I below shows another representation of the contents of file  that corresponds to .",{"@attributes":{"id":"p-0038","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE I"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary contents of File 300 according to FIG. 5"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Object\/Contents","Location","Active"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Object O1","L0","Yes"]},{"entry":[{},"Object O2","L1","Yes"]},{"entry":[{},"EOF Marker EOF","L2","Yes"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"Thus, Table I corresponds to the file  as shown in , with the one exception that Table I additionally includes a column titled \u201cActive\u201d which is not actually reflective of file contents but instead represents whether the particular object in the respective Location of Table I is currently in use or not. The purpose of the \u201cActive\u201d column will become clearer from further reading below.","The teachings herein are applicable to the storage of many types of file structures. One exemplary type of file structure is a tree structure. Building on the example of file  in  and Table II,  shows object O and object O represented as part of a very basic tree structure T- with a root and single child node, wherein object O is the root and object O is the child node. Accordingly, pointers are also needed identify the relationships in the tree structure. Thus, a root marker RM is additionally needed with a pointer to the Location of object O. Table II builds upon Table I and includes such pointers.",{"@attributes":{"id":"p-0041","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE II"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary contents of File 300 including pointers and root marker"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Object\/Contents","Location","Pointers","Active"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"Object O1","L0","P0 = None","Yes"]},{"entry":[{},"Object O2","L1","P1 = Location L0","Yes"]},{"entry":[{},"Root Marker RM","L2","P2 = Location L1","Yes"]},{"entry":[{},"EOF Marker EOF","L3","P3 = None","Yes"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"Referring now to , a flow-chart depicting an exemplary method of implementing commit  (previously mentioned in relation to ) is indicated generally . Commit  can be used to add root marker RM.  shows system  wherein file  reflects the contents of Table II including the invocation of commit  in order to include root marker RM and appropriate pointers in file . At block , the commit command is received. Such a commit command can be received by commit  using any known means, including a direct command inputted via keyboard , or via another process (not shown) executing on processor . At block , the object ID to be written is received. The object ID received at block  is associated with the commit command received at step , and typically embedded therein. In the present example, the commit command includes the parameter O to identify object O. At block , the root marker is appended. As part of block , commit  accesses file  and seeks end-of-file marker EOF in file  in order to determine the location of end-of-file marker EOF, and then defines the write location for the root marker RM and moves end-of-file marker EOF to location L. Additionally, root marker RM is stored to include pointer P which points to object O in location L, and object O is stored to include pointer P which points to object O in location L. Those skilled in the art will now recognize that file  now stores object O and object O in a manner that corresponds to tree structure T- shown in .","It should now be understood that store  and commit  can be performed any number of times and file  will grow in size, particularly in light of the fact that no delete command is utilized. For example, assume that tree structure T- is to be replaced by tree structure T- shown in . Tree structure T- includes a root containing object O and a child node containing object O. When store  is performed twice to store object O and object O, and when commit  is performed once to identify object O as the root, file  will have the appearance as shown in . Table III shows a corresponding representation of file  in .",{"@attributes":{"id":"p-0044","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE III"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary contents of File 300 including"},{"entry":"pointers and root marker corresponding to FIG. 10"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Object\/Contents","Location","Pointers","Active"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"Object O1","L0","P0 = None","No"]},{"entry":[{},"Object O2","L1","P1 = Location L0","No"]},{"entry":[{},"Root Marker RM","L2","P2 = Location L1","No"]},{"entry":[{},"Object O3","L3","P3 = None","Yes"]},{"entry":[{},"Object O4","L4","P4 = Location L3","Yes"]},{"entry":[{},"Root Marker RM","L5","P5 = Location L4","Yes"]},{"entry":[{},"EOF Marker EOF","L6","P3 = None","Yes"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"Of note is that file  continues to grow, but object O, object O and the root marker RM in location L are no longer active. However, it is to be reemphasized that the \u201cActive\u201d status column is not expressly maintained by file , but is the effective result of utilizing store and commit as previously described. Indeed, the \u201cactive\u201d status need not even be relevant depending on the intended use of file , since tree structure T- in the form of object O, object O and the root marker RM in location L is still available on an archive basis.","Referring now to , a flow-chart depicting an exemplary method of implementing root  (previously mentioned in relation to ) is indicated generally . Root  can be used to locate the root of a given tree structure stored within file .  shows system  representing exemplary performance of the method in . At block , the root command is received. Such a root command can be received by root  using any known means, including a direct command inputted via keyboard , or via another process (not shown) executing on processor . At block , a seek to end of file is performed. At block  a backwards scan through file  is performed until the root marker RM is found. In the case of Table III, the backwards scan reaches the root marker RM in location L, and thus it can be seen where there is more than one root marker RM in a given file, only the root marker RM nearest the end of file marker EOF will be found at block . Accordingly, the remaining root markers RM in a given file are effectively rendered inactive, without the need to expressly identify them as such. At block , the root is located. Block  is performed by examining the pointer associated with the root marker RM found at block . In this example, the pointer references location L, where object O is stored. At block , the root found at block  is returned\u2014and thus in this case object O is returned to root  for further processing.","Referring now to , a flow-chart depicting an exemplary method of implementing read  (previously mentioned in relation to ) is indicated generally . Read  can be used to read the contents of a given object within file .  shows system  representing exemplary performance of the method in . At block , the read command is received. Such a root command can be received by read  using any known means, including a direct command inputted via keyboard , or via another process (not shown) executing on processor . Additionally at block , an object identifier OID associated with the read command is received. In a basic form, the object identifier can be one of the locations L-L within file  in . (In more complex scenarios, the object identifier itself can be a variable (e.g. \u201cX\u201d) that itself points to the location L-L, so that if the object is changed by writing it again at a subsequent location within file  using store , then the location associated with the variable is updated at the time it is written.) In a present example object identifier OID is the location L. At block , the location of file  associated with the location associated with object identifier OID is accessed\u2014which in this example is location L. At block , the contents of the location accessed at block  are returned\u2014which in this example is object O as stored in location L.","Referring now to , another implementation of system  is shown. In , system  additionally includes a plurality of higher-level application program interfaces (API) . APIs , in a present embodiment, include a file system interface , a B-tree (B-tree) interface , a skip list interface , a store and forward interface , and a geographic interface . APIs  in turn can be accessed by a data access object (DAO) , a structured query language (SQL) . All of the foregoing can be accessed by an application . It should now be apparent that store  is in and of itself an application program interface which can be utilized, directly or indirectly, by APIs , DAO , SQL  or application . Such utilization of store  can be substantially transparent, such that the exact means by which store  actually interacts with file  is completely unknown and substantially irrelevant to the operation of APIs , DAO , SQL  or application . It should also be understood that system  as shown in  can be varied to include none of, or one or more of, APIs , DAO , SQL  or application .","In , system  additionally includes a plurality of lower-level plug-ins . Plug-ins , in a present embodiment, include caching plug-in , a clustering plug-in , a partitioning plug-in , a sequencing plug-in , a monitoring plug-in  and a remoting plug-in . It should also be understood that system  as shown in  can be varied to include none of, or one or more of plug-ins . Each plug-in  can be used to influence and\/or enhance how store  interacts with file . It should now also be apparent that regardless of which plug-ins  are used, such plug-ins are also transparent to APIs , DAO , SQL  or application .","File system interface  can be based on any suitable file manager, such as the well-known file manager interface found within a Windows\u2122 operating system from Microsoft Corporation, Redmond, Wash., USA.","B-tree interface , discussed further below, can be an interface that automatically manages the storage (including deletion and appending) of objects maintained in a B-tree structure on behalf of a higher level application. (While the present example is a B-tree, in other embodiments similar tree structures are contemplated such as B+-Tree, B*-Tree, binary tree, trie, and the like.)","Skip list interface , can be an interface that automatically manages the storage (including deletion and appending) of objects maintained in a linked list structure on behalf of a higher level application.","Likewise, store and forward interface  is also an interface that automatically manages storage of objects maintained in the structures bearing similar name to the respective interface. Store-and-forward interface  can be used to implement clustering, since with clustering changes to the local store are communicated to remote stores so that remote stores can make the corresponding changes local to their copies as well. In this example, remoting plug-in  would be used in conjunction with store and forward interface . In the event the remote server being accessed by remoting plug-in  is temporarily inaccessible, then data would be stored somewhere until such time as the missing resource becomes accessible again, all of which would be managed by store-and-forward interface . All updates for the remote node would be stored in a store-and-forward structure until they could ultimately be delivered.","Geographic interface  manages the storage of objects that represent geographic locations, as might be implemented using a quad-tree. It should now be apparent that interfaces  in general manage the storage structure as that structure is utilized by higher level applications, and such interfaces  access store  accordingly. Interfaces  can issue interact with store  via block  and block  as per the method shown in . Though not shown in , interfaces  can likewise interact with read , commit  and root .","DAO , SQL  and application  represent higher level applications or interfaces which directly or indirectly utilize store .","Caching plug-in  can work transparently with and on behalf of store  such that storage of certain objects according to store  are temporarily stored in volatile storage  (or a separate volatile storage device not shown) according to a given criteria. When the criteria is satisfied those objects are actually flushed to persistent storage device  in the manner described above.","Clustering plug-in  can work transparently with and on behalf of store  such that file  is spread across a plurality of persistent storage devices (not shown in ).","Partitioning plug-in  is similar in concept to clustering plug-in  and can also work transparently with and on behalf of store  such that portions of file  are stored across a multiple number of persistent storage devices . By way of further explanation, clustering plug-in stores  all data to all persistent storage devices, whereas partitioning plug-in  typically only stores a subset of data across each persistent storage device. Also, with clustering, updates can originate from multiple locations whereas with partitioning updates typically occur from one location unless there is further partitioning.","Sequencing plug-in , can be implemented as a variant of clustering plug-in , utilizes a plurality of persistent storage devices (not shown) in sequence, such that when one persistent storage device is full the file is continued on the next persistent storage device. Sequencing plug-in , can also be implemented so that data inserted during the same time period (e.g. during one day or week) are all stored in the same file. This implementation can make time-based retention policies simple (ie. deleting data after 90 days for example) as one just drop whole files of when the data in them expires.","Monitoring plug-in  can be used to assess the utilization of persistent storage device  (or multiples thereof) so that operations from store  can be moderated to accommodate any restrictions associated with a given persistent storage devices.","Remoting plug-in  can be used where a remotely connected persistent storage device (not shown) is connected to network interface , in order to permit store  to utilize such remotely connected persistent storage devices.","It is to be reemphasized that the components relative to interfaces  and plug-ins  as introduced in  can be \u201cmixed and matched\u201d according to any desired combination.  shows one such simplified example, wherein B-tree interface  is shown alone in conjunction with store  as being accessed by application .  shows a B-tree T- stored in volatile storage  which is to be written to file .  shows an example of B-tree T- in greater detail that is be stored by application  using B-tree interface  and store . When completely stored, file  will appear as shown in . B-tree interface  issues the instructions to store  (and to commit ) as appropriate so that file  has the structure of storage locations, pointers, root marker and contents that are reflective of B-tree T-, as shown in , all in a manner transparent to application . B-tree T- can now likewise be accessed by application  via tree interface  using read  and root .","File  from this point will simply grow in size. For example,  shows B-tree T-A which adds object O as a child depending from object O. The top half of  shows B-tree T- beside its corresponding version of file , reproducing B-tree T- from  and file  from . Assuming that object O is simply added to B-tree T- to produce B-tree T-A by application , then B-tree interface  will work with store  and commit  such that file  is grown so that it appears as shown in the lower half of . To further assist in the foregoing, Table IV shows the contents of file  as shown in  and in the top half of , corresponding to the initial storage of B-tree T-",{"@attributes":{"id":"p-0064","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE IV"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary contents of File 300 including"},{"entry":"pointers and root marker corresponding to B-tree T-3"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Object\/Contents","Location","Pointers","Active"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"Object O9","L0","P0 = None","Yes"]},{"entry":[{},"Object O7","L1","P1 = None","Yes"]},{"entry":[{},"Object O8","L2","P2 = None","Yes"]},{"entry":[{},"Object O6","L3","P3 = Location L1","Yes"]},{"entry":[{},{},{},"P4 = Location L2"]},{"entry":[{},"Object O10","L4","P5 = Location L3","Yes"]},{"entry":[{},{},{},"P6 = Location L0"]},{"entry":[{},"Root Marker RM","L5","P7 = Location L4","Yes"]},{"entry":[{},"EOF Marker EOF","L6","P8 = None","Yes"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"To further assist in the foregoing, Table V shows the contents of file  after file  is updated from the state shown in Table IV, (and as also shown the bottom half of ), corresponding to the storage of B-tree T-A in File  by B-tree interface  and store  after application  appended object O to object O and instructed that B-tree T-A be persistently stored.",{"@attributes":{"id":"p-0066","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE V"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary contents of File 300 including"},{"entry":"pointers and root marker corresponding to B-tree T-3"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Object\/Contents","Location","Pointers","Active"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Object O9","L0","P0 = None","Yes"]},{"entry":["Object O7","L1","P1 = None","Yes"]},{"entry":["Object O8","L2","P2 = None","No"]},{"entry":["Object O6","L3","P3 = Location L1","No"]},{"entry":[{},{},"P4 = Location L2"]},{"entry":["Object O10","L4","P5 = Location L3","No"]},{"entry":[{},{},"P6 = Location L0"]},{"entry":["Root Marker RM","L5","P7 = Location L4","No"]},{"entry":["Object O11","L6","P8 = None","Yes"]},{"entry":["Object O8","L7","P9 = Location L6","Yes"]},{"entry":["Object O6","L8","P10 = Location L1","Yes"]},{"entry":[{},{},"P11 = Location L7"]},{"entry":["Object O10","L9","P12 = Location L0","Yes"]},{"entry":[{},{},"P13 = Location L8"]},{"entry":["Root Marker RM","\u2002L10","P14 = Location L9","Yes"]},{"entry":["EOF Marker EOF","\u2002L11","P8 = None","Yes"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Using the foregoing, it will now be understood that deletion of nodes can be effected in a similar manner, whereby file  just continues to grow and various locations cease to be active and new locations in file  are written to, even with duplicates of data already present within file  in the event that new pointers are required.","As another example that the components relative to interfaces  and plug-ins  as introduced in  can be \u201cmixed and matched\u201d according to any desired combination,  shows another simplified example, wherein skip list interface  is shown alone in conjunction with store  as being accessed by application , for the purpose of storing a skip list SL- currently being maintained in volatile storage .  shows an exemplary skip list SL- that can be implemented using the teachings herein. In skip list SL- the root is object O which points to objects O, O and O. Object O points to object O and object O points to object . Thus skip list SL- differs in structure from a B-tree. Those skilled in the art, however, will now recognize using the previous teachings herein that skip list interface  can be configured to work with store  to create a version of file  that reflects skip list SL- and, by extension, the various ways that skip list SL- can be stored within file . It is further worth noting that in  a new skip list SL-A is provided, which is the same as skip list SL- except that object O has been added and that object O now additionally points to object O. Assuming that a version of file  already exists that reflects skip list SL-, then as object O is added to file , it is only necessary to write object O for the first time into a new location in file , and rewrite object O into a new location in file  (so that pointers to object O and object O can be provided), and to rewrite object O into a new location in file  (so that the pointer to the new location of object O can be provided.) Otherwise, objects O, O, O and O can remain active within file  and need not be rewritten into new locations of file .","(Those skilled in the art will now recognize that skip-list SL- is a novel skip list, as in order to be a traditional skip-list, object O would need to point to object O; object O would need to point to object O; and object O would need to point to object O. Thus, skip list SL- is in fact a novel skip-list. Skip list SL- is therefore a novel embodiment in and of itself. Skip list SL- can have many uses, such as journal-based storage.)","As another example that the components relative to interfaces  and plug-ins  as introduced in  can be \u201cmixed and matched\u201d according to any desired combination,  shows another simplified example, wherein store  is shown with partition plug-in  and sequence plug-in  (which can be implemented collectively as a single plug-in referred to herein as compound storage plug-in), and in turn three different additional instances of store  are provided, namely store A, store B and store C. (Similar additional instances of read , commit  and root  are also provided but not shown in ). Store A, store B and store C are accessible to plug-ins  and . (Note that the exact placement of each plug-in in relation to each instance of store  may not be exactly as shown in  during an actual implementation. For example, an instance of plug-in  could, in practice, not be implemented above store A, store B and store C but instead below each one of store A, store B and store C.) In , system  also includes three persistent storage devices A, B and C, each with its own respective file A, B and C. In this highly simplified example, file A, B and C each only have two locations. Therefore, in order to store four objects O-O and identify one of those objects as a root, and to have an end of file marker EOF, partition plug-in  and sequence plug-in  cooperate with store A, store B and store C to store objects O-O, the root marker and the end of file marker across storage devices A, B and C. It can be desired to implement system  according to  when the sizes of devices A, B and\/or C are limited and\/or where it is desired to keep a long historical record of changes. A read can be effected to any one of the devices A, B, C. When the devices A, B, C become full a new device  can be added.","As a further enhancement, it is to be understood that partition plug-in  can be implemented, if desired, in accordance with the teachings of co-pending and commonly-assigned U.S. patent application Ser. No. 11\/693,305 filed Mar. 29, 2007, now U.S. Pat. No. 7,680,766, the contents of which are incorporated herein by reference.","As another example that the components relative to interfaces  and plug-ins  as introduced in  can be \u201cmixed and matched\u201d according to any desired combination,  shows a more complex example including a plurality of separate servers remotely connected to each other, with processor A representing the processor of the first server; processor B representing the processor of the second server; and processor representing the processor of the \u201cnth\u201d or final server; Processor A includes store , cache plug-in , partition plug-in  and remote plug-in  as previously discussed. Remote plug-in  can communicate with store  on processor B and store  on processor . Processor B and processor themselves each implement cache plug-in , partition plug-in  and sequence plug-in , which make use of two persistent storage devices  local to each processor B and . The configuration in  highlights the highly scalable nature of the teachings herein to provide large amounts of storage capacity with transaction speeds that can be described as at least \u201cgood\u201d and potentially much better than current commercial database solutions offered by Oracle Corporation, 500 Oracle Parkway, Redwood Shores, Calif. 94065 and others. Furthermore, such storage can be provided relatively inexpensively.","It should now be apparent that many other combinations, subsets and variations of interfaces  and plug-ins  across one or more physical servers are within the scope of the teachings herein. In general, it should now be understood also that combinations, subsets and variations of all of the embodiments herein are contemplated.","Indeed, the present novel system and method for storage can present some advantages in certain implementations. For example, the inventor has done research leading the inventor to believe that a properly configured implementation can provide disk accessing speeds of up to 1.5 million transactions per second. A still further potential advantage from a properly configured implementation where the persistent storage is based on Flash drives can ultimately lead to longer life for such Flash drives, as a properly configured implementation of certain embodiments can lead to substantially equal use of all memory locations in the Flash drive, or at least more equal use of those memory locations than the prior art. Since memory locations in Flash drives \u201cburn out\u201d after a certain number of uses, the useful life of such Flash drives can conceivably be extended. As a still further potential advantage, properly configured implementations of certain embodiments can provide databases where recording of changes to those databases is automatically effected.","In addition, the teachings herein can, in properly configured implementations, support Relational, object oriented, Temporal, Network (Hierarchical), Inverted-Index (search engine), Object-Relational, Geographic and other persistence paradigms which can all be combined into the same database at the same time.","In addition, teachings herein can support, in properly configured implementations, a single top-level first-in-first-out read\/write queue that would suffice for an entire system. No internal synchronization would be required for read operations. This is possible because Objects are never updated, only replaced, which can provide good in-memory performance.","In addition, Compact Disk Representation of Objects can be provided using certain properly configured embodiments of the teachings herein. As known to those skilled in the art, relational databases using fixed-size rows can be very wasteful for cases where many rows are unused or usually contain a default value, or when large strings values are used to store only small values on average. The teachings herein can, in properly configured implementations, support storage of non-default values and so that only amount of string data which is actually used is stored. This can lead to significant performance and disk-space efficiency improvements.","In addition, bursty traffic can be more readily accommodated using properly configured embodiments of the teachings. Under short periods of heavy load a journal garbage collector would execute at a lower priority (or not at all), thus allowing for higher peak loads than what could normally be sustained.","In addition, properly configured embodiments of the teachings herein can provide Large Collection Support and obviate the need for a Separate Transaction Journal. This means that transactions can be easily supported without incurring the overhead normally associated with their use.","In addition, properly configured embodiments of the teachings herein can obviate Separate Clustering Channels. This means that larger clusters can be supported more efficiently. A ten fold increase over certain configurations of current clustering performance could be realized.","In addition, properly configured embodiments of the teachings herein can provide scalability because data is never updated, only replaced, there is a reduced (and possibly zero) possibility for corruption. Properly configured embodiments can be equally suitable for databases of all sizes. For small databases it can be as fast as completely in-memory systems. Large databases can be scaled in the same way as completely disk-based systems. This can allow one to code all of databases in the same way without forcing the use a different system depending on your performance or size requirements."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0018"},"figref":["FIG. 3","FIG. 1","FIG. 2"]},{"@attributes":{"id":"p-0010","num":"0019"},"figref":["FIG. 4","FIG. 1","FIG. 2"]},{"@attributes":{"id":"p-0011","num":"0020"},"figref":["FIG. 5","FIG. 1","FIG. 2"]},{"@attributes":{"id":"p-0012","num":"0021"},"figref":["FIG. 6","FIG. 2"]},{"@attributes":{"id":"p-0013","num":"0022"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0014","num":"0023"},"figref":["FIG. 8","FIG. 1","FIG. 7"]},{"@attributes":{"id":"p-0015","num":"0024"},"figref":["FIG. 9","FIG. 2"]},{"@attributes":{"id":"p-0016","num":"0025"},"figref":["FIG. 10","FIG. 1","FIG. 7","FIG. 9"]},{"@attributes":{"id":"p-0017","num":"0026"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0018","num":"0027"},"figref":["FIG. 12","FIG. 1","FIG. 11"]},{"@attributes":{"id":"p-0019","num":"0028"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0020","num":"0029"},"figref":["FIG. 14","FIG. 1","FIG. 13"]},{"@attributes":{"id":"p-0021","num":"0030"},"figref":["FIG. 15","FIG. 1"]},{"@attributes":{"id":"p-0022","num":"0031"},"figref":["FIG. 16","FIG. 15"]},{"@attributes":{"id":"p-0023","num":"0032"},"figref":["FIG. 17","FIG. 16"]},{"@attributes":{"id":"p-0024","num":"0033"},"figref":["FIG. 18","FIG. 16","FIG. 17"]},{"@attributes":{"id":"p-0025","num":"0034"},"figref":["FIG. 19","FIG. 17"]},{"@attributes":{"id":"p-0026","num":"0035"},"figref":["FIG. 20","FIGS. 17 and 19","FIG. 19"]},{"@attributes":{"id":"p-0027","num":"0036"},"figref":["FIG. 21","FIG. 15"]},{"@attributes":{"id":"p-0028","num":"0037"},"figref":["FIG. 22","FIG. 21"]},{"@attributes":{"id":"p-0029","num":"0038"},"figref":["FIG. 23","FIG. 22"]},{"@attributes":{"id":"p-0030","num":"0039"},"figref":["FIG. 24","FIG. 15"]},{"@attributes":{"id":"p-0031","num":"0040"},"figref":["FIG. 25","FIG. 15"]}]},"DETDESC":[{},{}]}
