---
title: Method and system for policy enabled programming
abstract: A system and method for allowing external execution-time adaptation of application behavior of an application in a telecommunication system without modification to the application code comprises an application having at least one break point and residing on an application server, at least one identifiable decision engine, and a listing of break points that has for each break point at least one identifier of the decision engine, such that at one of the break points, the application accesses the listing of break points, invokes the listed instances of the decision engine corresponding to the break point, and adapts application behavior based on the decision engine. In addition, each entry in the listing of break points can have a sequence number so that if two entries for the same break point have equal sequence numbers, the decision engines identified in these entries can be invoked in parallel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08448159&OS=08448159&RS=08448159
owner: TTI Inventions C LLC
number: 08448159
owner_city: Wilmington
owner_country: US
publication_date: 20071102
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The present invention relates generally to programming of communications, information and entertainment services.","Software applications written in a traditional manner have all the functionality defined within application code. Once such applications are deployed, the providers offering the applications have little leeway to affect the behavior of the application. The application may have a few parameters that can be adjusted, but generally the behavior of the application is fixed unless the application code is modified.","Service providers wishing to address dynamic markets need the flexibility to offer new services rapidly. The cycle time associated with modifying application code can slow the process down unacceptably. Therefore, there is a need for application code in which the behavior can be modified without waiting for a software release.","Similar motivations were involved in the development of the Intelligent Network and Advanced Intelligent Network concepts for constructing telephone network services. It was possible to build new services by changing the code within the telephone switch, but this was rather slow and cumbersome. The approach chosen was to precisely define the call model that specified the state of the telephone switch software in establishing a connection between two parties. At various points in the call model, the telephone switch could be configured to query an external service control point for instructions on how to proceed. New service functionality could be produced by changing the behavior of the logic in the service control point without making changes to the software within the switching system itself.","This approach is highly dependent on the common call model that specifies the state of the switching system and the expected behavior. Such a call model could be defined because the process of establishing calls is consistent from one system to another. Definition and agreement of the call model took a substantial amount of time, which was tolerable because the processing of telephone calls was relatively static over time. In environments where providers are offering new and varied services on a frequent basis, it will not be possible to define such a detailed model for the internal states of the service logic. While this common call model technique has desirable characteristics, it cannot be applied directly to the processing of emerging, new and varied services.","Telecommunications equipment vendors and operators addressed a similar problem in adding features to call processing systems. The agreed upon solution, the basis for the Advanced Intelligent Network (AIN), defines another common call model as the basis for processing the establishment of telephone calls. This common call model provides a pre-defined set of events where external systems can be queried for decisions. U.S. Pat. No. 5,940,487, \u201cProgrammable call processing system and method\u201d, Bunch et al., for example, illustrates this approach on a distributed telecommunication switching system coupled to AIN. This separation of service switching points (switches), which process calls, and service control points, which process service logic, allows new calling services to be defined without making changes to the software within the switch. This approach worked well for controlling telephone calling in the circuit switched networks, and was extended into next-generation packet-switched networks through the results of industry forums such as the Parlay Group specifications and the Java Community Process JAIN specification. The fact that there is a need for such standardization is indicative of the limitations of this approach, in that it deals with a specific functionality (call control) and requires advance agreement and\/or standardization to function. Thus this approach is appropriate for application functionality that is static over time.","In U.S. Pat. No. 6,970,901, \u201cDevice and method for swapping out a part of a service logic program\u201d, Moritz teaches a mechanism for distributing service logic across multiple entities. Moritz specifically focuses on making use of the increasing capabilities of intelligent terminal devices acting as client terminals, by distributing a portion of the service logic to the client terminal. Moritz discloses methods for using this distributed approach for determining charging related information. Distribution to client devices can enable personalization, but does not easily enable modification of the behavior of an overall service, because the change would have to be propagated to all of the client terminal devices. Enabling distribution for a single topic, such as charging, is simplified because the communication mechanism (the \u201ccharge ticket\u201d in Moritz) can be defined and coded in advance. Thus Moritz addresses the need for flexible service logic programs, but in a very limited domain.","In U.S. Pat. No. 6,967,957, \u201cArchitecture for the rapid creation of telephony services in a next generation network\u201d, Anjum et al. describe an object-oriented call model, which \u201chides the detail of the underlying call-state management protocols and hardware from applications\u201d. Specifically, Anjum et al. describe a new call model that is designed to be abstract enough to represent call control in both circuit-switched and packet switched telephony networks. Such a call model is more flexible than the Java Telephony Application Programming Interface (JTAPI) model on which it was based, but still represents a single functionality. Thus this model is not applicable in the more general case where the behaviors are not as well defined, or known clearly in advance.","The Policy Evaluation Enforcement Management (PEEM) effort within the Open Mobile Alliance (OMA), as specified in the draft requirements document \u201cPolicy Evaluation, Enforcement and Management Architecture\u201d (OMA-AD-Policy_Evaluation_Enforcement_Management-V10-200600625-D) describes an architecture for policy-evaluation and execution as support for the OMA's service enablers. These enablers include functions such as group list management, messaging and location. The architecture is designed to provide a common framework for these enablers to query for a policy decision. Such a capability would be useful, although not required, as a building block for the policy-enabled programming described here, because it would simplify the process of mapping interfaces between systems. The OMA work, however, does not specify how an enabler would determine when to query a policy engine (the PEEM enabler), or which policy engine to query.","Another approach is that supported by workflow systems. In these systems, which are often applied to complex order processing, the set of processing steps is defined in textual fashion that is interpretted at run time, rather than compiled in the manner of software code. This provides flexibility, in that the workflow can be modified without changing the code of the workflow engine. However, the interpretation operation is inefficient, leading to performance that is adequate for order processing but generally insufficient for the execution of actual services.","Database systems provide yet another mechanism where triggers and stored procedures can be invoked to execute logic, providing a great deal of flexibility. However, the operations where the stored procedures can be executed exist only for database operations of insert, delete, update and select on the data in the database. The problem with this approach is the restriction for database operations; the entire specification is within the database system and not easily referenceable or modifiable unless one navigates through the data and the associated triggers and stored procedures.","Hence, current processes are restricted to specific types of software applications, e.g., call processing, and have required advanced agreement and\/or standardization of the application processing model before they could be used. Other current processes exist only within middleware, such as databases or workflow systems, which limits their scope and does not meet performance requirements for service execution.","Thus there is a need for a system capable of determining dynamically when and where to query an external descision point, such as a policy engine. There is also a need for a structured and efficient mechanism for configuring such dynamic queries, characterized by breakpoints that can be configured to a controlled set of options.","The present invention advantageously provides a design architecture and methodology for building and deploying application software that allows the behavior of the application to be adapted or configured during execution without making changes to the application code. Reuse of a single software application multiple times for different purposes by configuration or adaptation of the application is provided. Furthermore, the inventive system and method enables rapid deployment of new service behaviors because they can be delivered without the delays associated with the software development cycle.","A system and method for allowing external execution-time adaptation of application behavior of an application in a telecommunication system comprises an application having at least one break point and residing on an application server, at least one identifiable decision engine, and a listing of break points that has for each break point at least one identifier of the decision engine, such that at one of the break points, the application accesses the listing of break points, invokes the listed instances of the decision engine corresponding to the break point, and adapts application behavior based on the decision engine.","The listing of break points can be a file external to the application, and can contain attribute mapping for each identifier and an action type for each identifier and, in addition, can dynamically map the break point to the decision engine.","A system and method to allow external execution-time adaptation of application behavior is presented. The key characteristics of this approach are that it provides application developers with the performance associated with compiled code as well as the flexibility to define the decision points and possible actions within the application flow, allows for dynamic mapping of those decision points to external evaluation engines, and enables application behaviors to be configured as the application is being deployed or even while the application is executing, rather that only during the design and development of the application.","There are two specific mechanisms that support such a system and method. The first is an external table such as a break point configuration table. The application reads this table when it reaches a defined break point during execution to determine what actions to take. The entries in this table can be defined separately from the application, and even changed while the application is running, based on knowledge of what attributes or variables the application has defined at a given break point. The second adaptation method is contained in the external systems. The logic, policies and\/or rules within these systems will create responses that will influence the subsequent flow and behavior of the application. With these two mechanisms, the behavior of applications can be significantly modified without having to re-write or modify the application code.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1","b":["10","12","10","14","14","16","18","10","14","20","10","20","10","10","10"]},"Note that the external system  could also be a workflow system, database system or even another software application. The fact that the mapping can be changed to point to different software applications provides flexibility even if the decision points are hard coded in the policy enabled application .","There are many ways in which a policy enabled application  may react to the response it receives from an external policy engine . Building an application  that gives an external system  complete flexibility in determining its subsequent behavior would be extremely difficult and error prone. Through appropriate limitations on the range of action types or options , however, the complexity can be kept at a manageable level. Specifically, the application  could be designed to support a limited number of action types  based on the response provided by the external system . Examples of these action types  could include a fork or two-way decision point action, a null action, and a variable replacement action.","In the case of a two-way decision action , the application  sends a message to an external system  and the external system provides a binary, i.e. \u201cyes\/no\u201d or \u201ctrue\/false\u201d, response. The application  then follows one pre-defined path if the response is a \u201cyes\u201d and another path if the response is a \u201cno\u201d. While the application  performs only one of two options in this decision action , the overall behavior can vary widely based on the policies or processes used by the external systems  to make decisions. This can be extended to multi-way decision actions where multiple paths are possible.","As an example, an application  designed to deliver or transmit a digital content item to a user could include a break point  just before transmitting the content. In response to this break point , the application  supplies information identifying both the user and the list of content items in a query to an external policy engine . The application  is programmed to proceed with the transmission of the content if the response is a \u201cyes\u201d, and to cancel the transmission if the response is a \u201cno\u201d. In one situation, the external system  could be a real-time charging engine that determines if the user has sufficient balance to pay for the items. If the user's balance is sufficient, the external system  debits the user account and returns a \u201cyes\u201d. If the balance is insufficient, the external system  returns a \u201cno\u201d. In another situation, the external system  can be an authorization system that only allows content to be downloaded to users within a certain physical location, for example, as a corporate security measure, or as a means for restaurants to attract visitors. If the user is within the location bounds specified for the content items, the external system  returns a \u201cyes\u201d and if not, the system  returns a \u201cno\u201d. Hence, two very different services employing distinct external systems  have made use of the same content delivery policy enabled application .","In the case of a null action , the application  simply performs the break point  and continues execution. The null action is appropriate where the application simply needs to inform an external system  of some event. In the content download service example described above, the application  could be instructed to execute a break point  comprising a null action  just prior to transmitting the content. Executing the break point  would cause an external system  to record the download event, including the list of content items, so that the users with post paid accounts could be charged for the content during the next billing cycle.","In the case of a variable replacement action , the application  uses the response from the external system  to alter the value of a variable being processed by the application . In the content download service example above, the application  could be instructed to execute a break point  comprising a variable replacement action  just prior to transmitting the content. Performing the break point  could cause an external system  to filter the list of content items, removing those whose rating information indicates that they are not acceptable for the user, perhaps based on the age or preferences of the identified user. The external system  then returns the filtered list to the application  which replaces the initial list of content items with the filtered list, and proceeds with the download.","Other action types  could be defined, providing greater flexibility in the control of the application flow. Note that it is desirable to limit the number of action types or options  in order to avoid undue complexity in constructing the application .","The policy-enabled application  would execute within an application server  or service delivery platform, and would have local access to the break point configuration table  that would specify the application behavior associated with each break point .  shows an exemplary table  which could be populated by a provisioning system responsible for deploying the product\/service. The table  comprises not only the action types , discussed above, but also the following fields, which are described in more detail below: an address  for the policy engine or external system , a sequence number  and attribute mapping . The policy-enabled application  would interact with one or more external policy decision points. The configuration table  links the points within the program flow where interactions can be performed with the specific decision point to interact with and the manner in which to interact (such as the attributes to transmit).","While the discussion here describes policy decision points, there is nothing in the mechanisms defined here that limits the external systems  to being policy evaluators. Any external system  with a defined invocation interface could be used in place of a policy decision point.","A simplified sample configuration table  is shown in Table 1. In this case, there are two break points entries associated with Break Point  . For the first entry, the application  must perform attribute mapping  by sending attributes A, B and C to the PolicyEngine  via the system address  in the table , and use the response to replace the value of attribute C. For the second entry, the application  must send attributes  A, C and D to PolicyEngine  via its address  in the table , and perform a decision action  based on the \u201cyes\/no\u201d response. The sequence number  in the sequence column indicates the order in which the invocations associated with a single break point  are executed. Invocations that share a sequence number  could be executed in parallel. In cases where no sequence numbers  are used, the application  could execute the queries in the order found in the file.",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Break Point Configuration Table"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Break",{},{},{},{},"Response"]},{"entry":["Point","Break Point",{},"System","Attribute","Replace-"]},{"entry":["ID","Type","Sequence","Address","Mapping","ment"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":["1","Variable","1","PolicyEngine1","A, B, C","C"]},{"entry":[{},"Replacement"]},{"entry":["1","Fork","2","PolicyEngine1","A, C, D"]},{"entry":["2","Null","1","PolicyEngine2","X, Y, Z"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 3","FIG. 1"],"b":["10","1","10","1","2","1","14","10","16","1","14"]},"The right side of  illustrates the flow that is used within the Break Point  module to process these entries. Upon entry at step S, the application  invokes the external system  at step S, using the attribute mappings  defined in the table . When the external system  responds, the application  determines, at step S, the type of break point or action type  being processed. If the action break point type  is Variable Replacement, the application , at step S, performs the replacement as defined in the configuration table  and proceeds to step S to test if there are more break point entries  to be processed. If the break point type  is null, the application  need not wait for a response and proceeds directly to testing, at step S, if more break point entries  need to be processed. If the break point type  is fork, the application  tests the response from the external system  at step S. If the external system  response is \u201cyes\u201d, the application  proceeds to test for more break point entries  at step S. If the external system response is a \u201cno\u201d, the application breaks out of processing any further break point entries  and returns to the main application flow with a \u201cNo\u201d exit condition at step S. When there are no more break point entries  to be processed, the application  returns to the main application flow with a \u201cYes\u201d exit condition at step S.","Handling of exceptions and error conditions in the interactions with the external systems  is not shown. The application  could be programmed with various exception handling behaviors to deal with returned errors or time-outs with no response. Alternatively, the table could be extended to indicate the actions to be taken in the case of certain handled exceptions. The manner in which the application  deals with these situations is not critical to this mechanism.","A key aspect of this dynamic programming approach is that the application break points  can be mapped dynamically to decision point systems  and to specific policies within them. There are numerous methods in which this mapping could be performed. Perhaps the most straightforward is a manual approach, where human analysts create the break point configuration table , define the policies that correspond to each break point , load the configuration table  into the application server  and load the policies into the decision point. A greater degree of automation and validation in this mapping process is possible if the application break points  and policies can be made visible in a structured fashion.","A design environment could import the structured representation of all the break points  in an application  selected by the user. The environment could retrieve policies from decision points known to it. When the human user selects a break point , a brief representation of which is shown in Table 2, the environment could retrieve and present only those policies that are valid. For example, if the break point  only allowed forking operations or two-way decision actions , only those policies that return yes\/no or true\/false values would be appropriate. After selecting a policy, the user would map the variables available from the software application  at the chosen break point  to those specified in the interface to the policy, as shown in Table 3. The environment could then validate the mappings, for example ensuring that the types, e.g., string, integer, etc., match. After all the mappings are successfully defined in this manner, the environment could create the corresponding break point configuration table  and install it on the application server .",{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Abbreviated Break Point Representation Structure"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Break Point"]},{"entry":[{},"Name"]},{"entry":[{},"Description"]},{"entry":[{},"Allowed Types (Null, Variable Replacement, Fork)"]},{"entry":[{},"Variables available (name and type)"]},{"entry":[{},"..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Abbreviated Policy Invocation Interface Structure"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Policy"]},{"entry":[{},"Name"]},{"entry":[{},"Description"]},{"entry":[{},"Input [variable1 (name\/type), variable2...]"]},{"entry":[{},"Output [variable1 (name\/type), variable2...]"]},{"entry":[{},"..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"While the present invention has been described in particular embodiments, it should be appreciated that the present invention should not be construed as limited by such embodiments, but rather construed according to the claims below."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention is further described in the detailed description that follows, by reference to the noted drawings by way of non-limiting illustrative embodiments of the invention, in which like reference numerals represent similar parts throughout the drawings. As should be understood, however, the invention is not limited to the precise arrangements and instrumentalities shown. In the drawings:",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
