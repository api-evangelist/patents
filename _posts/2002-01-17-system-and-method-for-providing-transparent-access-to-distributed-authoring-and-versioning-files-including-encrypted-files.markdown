---
title: System and method for providing transparent access to distributed authoring and versioning files including encrypted files
abstract: Access to WebDAV (Distributed Authoring and Versioning) servers is provided in a manner that is essentially transparent to applications. A WebDAV redirector and related components support file system I/O requests and network requests directed to WebDAV servers identified by URI (Universal Resource Identifier) names, or by a drive may be mapped to a WebDAV share. An application's create or open I/O requests directed to a WebDAV server are detected, and result in a local copy of the file being downloaded and cached for local access. When closed, the local file is uploaded to the WebDAV server. Network-related requests such as for browsing that are directed to a WebDAV server are also handled transparently. WebDAV files may be locally encrypted and decrypted at the file system level, transparent to applications and the WebDAV server, via an encrypting file system that performs local encryption and decryption at the local file system level.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07437429&OS=07437429&RS=07437429
owner: Microsoft Corporation
number: 07437429
owner_city: Redmond
owner_country: US
publication_date: 20020117
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The present invention claims priority to U.S. Provisional Patent Application Ser. No. 60\/268,311 filed Feb. 13, 2001.","The present invention relates generally to computers and the Internet, and more particularly to Internet Distributed Authoring and Versioning.","The use of online storage services for storing and sharing data is becoming more popular. In general, most contemporary access to Internet storage is based on relatively complicated protocols such as FTP (File Transfer Protocol) that require specific application support.","WebDAV, or simply DAV, (Distributed Authoring and Versioning), is a protocol described in Extensible Markup Language (XML) that extends HTTP (HyperText Transfer Protocol) essentially so that Internet content and the like can be manipulated. For example, although HTTP allows content to be written using the PUT and POST verbs, WebDAV allows querying and manipulation of metadata on the files, using verbs like PROPFIND and PROPPATCH, and LOCKing of files, which along with the HTTP verbs like PUT and POST, allow document manipulation. Intermediate programs have been written to simplify the use of these protocols. For example, Microsoft Corporation's Windows\u00ae 95, Windows\u00ae 98, and Windows\u00ae 2000 operating systems provide \u201cWeb Folders,\u201d which act as interfaces to a collection of resources stored on a DAV server. Web Folders appear similar to local file folders, e.g., files can be dragged and dropped into a representation of a Web Folder, and so forth. However, Web Folders cannot be used with a non-modified application program, and only applications that have their code integrated with Web Folders can utilize Web Folders.","Alternatively, a few applications are DAV-aware and are able to work with files on WebDAV servers, such as files appearing in Web Folders. However, such applications require specific support of the protocols to access the data on the Internet, and are generally limited to a few special web authoring tools. The majority of applications, including applications already in existence, are not capable of accessing WebDAV server files, and it is virtually impossible to retroactively adapt such existing application to do so.","Briefly, the present invention provides a system and method that automatically and transparently handle WebDAV file access, whereby applications (including WebDAV unaware applications) can access WebDAV files through conventional file system-directed API (application programming interface) calls or the like. Applications can also issue network-related requests to WebDAV servers, such as for browsing, with those requests transparently handled as if a WebDAV share was a local folder.","To this end, the present invention comprises a WebDAV redirector and related components that receive requests directed to a WebDAV server, and take actions to handle the request locally or remotely as appropriate. For example, the WebDAV redirector and related components support I\/O requests and network requests directed to WebDAV servers identified by URI (Universal Resource Identifier) names, or by a drive that may be mapped to a WebDAV share.","To this end, the redirector components operate to determine whether an application's create or open I\/O request is directed to a WebDAV server that is connected and operating, and if so, whether a specified share and file on that server are accessible. If so, the redirector informs a multiple UNC provider that it can handle the request, and a local copy of the file is downloaded and cached for local I\/O access, whereby reads and writes to the WebDAV server are made from and to the cached file. When closed, the local file is uploaded to the WebDAV server if it has been modified on the client.","Network-related requests that are directed to a WebDAV server, such requests as related to browsing, are also handled transparently by acting on API calls or the like corresponding to the request. For example, an API call to enumerate a WebDAV share is provided to the WebDAV redirector components, which determine whether the server and share is valid, and if so, inform a multiple provider router that the request can be handled. Network communications are controlled by the WebDAV redirector components to handle the request.","WebDAV files may be locally encrypted and decrypted at the file system level, transparent to applications and the WebDAV server. An encrypting file system performs local encryption and decryption at the local file system level, whereby the files cannot be viewed at the WebDAV server, and the WebDAV server need not be burdened with encryption or decryption processing.","Other advantages will become apparent from the following detailed description when taken in conjunction with the drawings, in which:","Exemplary Operating Environment",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["100","100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, tablet devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, and so forth, that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of the computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","The computer  typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by the computer  and includes both volatile and nonvolatile media, and removable and non-removable media. By way of example, and not limitation, computer-readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by the computer . Communication media typically embodies computer-readable instructions, data structures, program modules or other data in other transport mechanisms and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer-readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , file system , application programs , other program modules  and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media, discussed above and illustrated in , provide storage of computer-readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules  and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers herein to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a tablet (electronic digitizer) , a microphone , a keyboard  and pointing device , commonly referred to as mouse, trackball or touch pad. Other input devices (not shown) may include a joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . The monitor  may also be integrated with a touch-screen panel or the like. Note that the monitor and\/or touch screen panel can be physically coupled to a housing in which the computing device  is incorporated, such as in a tablet-type personal computer. In addition, computers such as the computing device  may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface  or the like.","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet. For example, in the present invention, the computer system  may comprise source machine from which data is being migrated, and the remote computer  may comprise the destination machine. Note however that source and destination machines need not be connected by a network or any other means, but instead, data may be migrated via any media capable of being written by the source platform and read by the destination platform or platforms.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface  or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","WebDAV Redirector","The present invention will be generally described in the context of Microsoft Corporation's Windows\u00ae XP operating system, using the NTFS file system. Notwithstanding, it can be readily appreciated that the present invention may be implemented with virtually any operating system and\/or file system.","Turning to  of the drawings, there is shown a user mode application program , which requests various system functions by calling application programming interfaces (APIs) . For accessing network resources, the application  can generally operate in at least one of two ways, a first of which is by placing file input output (I\/O) API calls directed to a network resource to an API layer . For example, applications can examine or access resources on remote systems by using a UNC (Uniform Naming Convention) standard with Win32 functions to directly address a remote resource, e.g., in the form \\\\server\\share, or via a drive mapped to a network shared folder or the like. Another way an application can access network resources is by calling networking APIs, (e.g., Win32 Windows Networking (WNet) APIs in the Windows\u00ae 2000 operating system), such as to enumerate a server's files when browsing. Via these WNet APIS, applicants can enumerate computers and resources that computers export for sharing.","When a file I\/O API (e.g., a file open or create request) is called with a remote filename such as a UNC name, a file I\/O request is received at an I\/O manager . To handle the remote name, the I\/O manager  calls a Multiple UNC Provider, or MUP  to figure out which device handles the name. In other words, the MUP  (e.g., comprising a kernel mode driver) determines which network to access when an application  uses an I\/O API to open a remote file.","More particularly, to determine a device that can handle the given name, the MUP  polls (via asynchronous I\/O request packets, or IRPs) any redirectors that have previously registered with the MUP, e.g., redirectors  and  in . Each redirector that can handle the name responds back, and if more than one respond, the MUP  determines from a priority order (e.g., maintained in at least one system registry key or the like) which one has precedence to handle the request. In one implementation, the SMB (server message block) redirector  defaults to having first precedence in handling UNC requests. The SMB redirector, along with IRPs and the I\/O manager are generally described in the reference, 2000, Third Edition, D. Solomon and M. Russinovich, Microsoft Press (2000).","As part of the response to the MUP , each redirector that recognizes the name indicates how much of the name is unique to it. For example, if the name is the UNC name \\\\SERVER\\SHARE\\foo\\bar1.doc, the SMB (Server Message Block) redirector  recognizes the name as capable of being handled, and if the server is an SMB server, responds by claiming the string \u201c\\\\SERVER\\SHARE\u201d as its own.","When at least one redirector responds and provides the caching information, the MUP driver  caches the information in association with the redirector that responded, (if more than one, it caches the information of the one that takes precedence), whereby further requests beginning with that string are sent directly to that redirector, without the polling operation. For example, future SMB requests directed to a network share corresponding to a cached string are passed to the SMB redirector , which then packages those SMB requests into a data structure that can be sent across the network to that remote SMB server. Note that if inactive for too long, the string information will expire in the cache, whereby polling will again be necessary.","In accordance with one aspect of the present invention, access to WebDAV servers is provided to applications in a manner that is essentially transparent to the applications. To this end, a WebDAV redirector  is provided that supports file system I\/O and network commands directed to WebDAV servers identified by URI (Universal Resource Identifier) names. In a described implementation corresponding to that represented in , the WebDAV redirector  comprises a kernel mode redirector reflector component , a user mode redirector (web client service) component , and a user mode network provider . The general operation and structure of these components are described below.","In general, a WebDAV URI name has the following syntax, (with bracketed parts being optional):\n\n","In the present example, because the request is a URI name, the WebDAV kernel redirector  will be the only redirector that responds, (or otherwise has precedence), provided the URI name identifies an actual, accessible WebDAV server, as described below. The response will indicate to the MUP  that the WebDAV kernel redirector  is capable of handling file I\/O requests directed to that share, and provide the information necessary to bypass the polling operation for subsequent requests directed to that share.","In this manner, once its information is cached at the MUP , each I\/O request directed to that WebDAV share will be sent to the WebDAV kernel mode component  of the WebDAV redirector , which will attempt to satisfy it, (e.g., locally, as described below). If the WebDAV redirector kernel mode component  cannot satisfy an I\/O request locally by calling the underlying file system, then the WebDAV redirector reflects the request up to the user mode WebDAV redirector component , which implements a WebDAV client and attempts to complete the request via an Internet transport component  (e.g., WinInet APIs) and WebDAV server . The user mode WebDAV redirector component  returns the control and any WebDAV server's response back to the WebDAV kernel mode redirector . In this manner, file I\/O requests directed to a WebDAV server will be handled by the WebDAV redirector , whereby the application  will have transparent access (e.g., if they were on a local or SMB network drive) to those files. WebDAV file I\/O requests are described below with respect to the flow diagrams of . Note that for completeness,  represents each kernel mode redirector  and  connected to a Re-Directed Buffering Subsystem , or RDBSS, which comprises a remote file system component that supports multiple file level protocols by providing common buffering code for the kernel mode redirectors, including the SMB redirector  and the WebDAV redirector .","In the other, networking API alternative for accessing remote resources mentioned above, an application  calls networking (e.g., WNet) APIs, which among other functions allow applications to connect to network resources, such as file servers and printers, and to browse the contents of any type of remote file system. Because a networking API can be called to work across different networks using different transport protocols, when one of these networking APIs are called, a corresponding network provider (e.g., network provider  or ) is used to send the request correctly over the network and to understand the results that the remote server returns.","In general, a network provider comprises software code that establishes the operating system as a client of a remote network server. For example, some of the operations a network provider performs include making and breaking network connections, printing remotely, and transferring data. Thus, and as is known, typical functions provided by a network provider include capabilities functions, which allow the caller to determine the capabilities of the network provider, user name functions, which prompts the network provider for the user name associated with a connection, and device redirecting functions, which allow a network provider to redirect drive letters, (described below), MS-DOS\u00ae devices, and LPT ports. Other functions include provider-specific dialog functions, which allow a network provider to display or act on network-specific information, administrative functions, which allow a network provider to display or act on special network directories, and enumeration functions, which allow browsing of network resources.","To determine which network provider to call when an application calls a networking routine of the APIs , in one implementation, the call passes to a multiple network provider router, or MPR , which may be installed as a Dynamic Link Library (DLL). Similar to the MUP , the MPR  determines which user mode network provider recognizes the resource being accessed. To this end, each installed network provider beneath the MPR  supplies a set of functions collectively called a network provider interface that allows the MPR  to determine which network the application is trying to access, and to direct the request to the appropriate network provider software. For example, the network provider of the SMB-mini redirector  is a LANMAN (local area network manager) network provider  as specified in a system registry key or the like. The network provider of the WebDAV redirector  is a WebDAV network provider , also specified in a system registry key or the like.","In a described implementation, when called to connect to a remote network resource, the MPR  checks the registry to determine which network providers are loaded. The MPR  then polls them, one at a time, in the order in which they are listed in the registry, (which is configurable), and each network provider communicates with its corresponding redirector until the resource is recognized or until all available network providers have been polled. Thus, in the event of a networking API call that is directed (e.g., via a URI passed as a call parameter) to the WebDAV server , the MPR will poll the WebDAV network provider , which in turn call via RPC (remote procedure call) into the Web Service  which will contact the kernel mode WebDAV redirector  to determine if the API can be handled, e.g., if the specified WebDAV share is indeed an accessible WebDAV server. If so, the API is handled by the WebDAV redirector components .","Another way in which applications can transparently access network resources is via a drive letter or device name previously mapped (e.g., via a networking API such as WnetAddConnection) to that resource. To this end, when called, the API routes the call to the appropriate network provider, e.g., via polling as described above. The responsive network provider, in turn, creates a symbolic-link object in an object manager namespace that maps the drive letter being defined to its associated redirector for that network. Once mapped, when the WNet or other API calls to open a resource on a different network, the I\/O manager (in conjunction with an object manager, not shown) locates the redirector that handles the request. In keeping with the present invention, a user can thus map a drive to a WebDAV URI, such as by using the shell to call the WnetAddConnection API function, and once the drive is mapped in the object manager's namespace, applications can access files on a WebDAV server  via the drive letter, as the I\/O system will handle the mapping of the letter to the correct URI.","In general, although essentially transparent to applications, a user may interact with WebDAV functionality of the present invention via a system command window, wherein a \u201cnet\u201d command will provide character user interface for WebDAV redirection, e.g. \u201cNET USE*HTTP:\/\/ . . . \u201d, by mapping a network drive, adding a network place, creating shortcuts, opening files, interfacing with a browser Address Bar, and typing via a \u201cStart\u201d-\u201cRun\u201d interface or the like. As is understood, other mechanisms that deal with networks may also lead to WebDAV functionality being invoked.","Turning to an explanation of the operation of the invention, as generally represented in the flow diagrams of , when needed, the kernel mode WebDAV redirector  operates to determine whether it can handle a given URI, by first contacting the named server with an HTTP \u201cOPTIONS\u201d request. For example, this may be in response to a File I\/O Create\/Open-type request that arrives as an IRP, or as part of a browser-like request to display a server's shared folders that is received from the WebDAV network provider, as described above. To determine whether the WebDAV redirector can handle the request, the WebDAV kernel mode redirector  contacts the user mode WebDAV redirector component  to issue the HTTP OPTIONS call to the identified remote server via its server name (parsed from the URI) via the Internet transport component  (e.g., WinInet). This is generally represented in , by steps ,  and .","One possibility is that the remote server does not respond to the OPTIONS request, (e.g., it times out or something unreadable comes back), while another possibility is that the remote server responds but it is not a WebDAV server, which is determinable from the information returned in the response to the OPTIONS request. Steps  and  represent the handling of these possibilities, with step  representing the error handling. For example, if the MUP  is polling the WebDAV kernel mode redirector , in a described implementation, the error handling may simply comprise responding to the MUP  with an errorcode or the like indicating that it cannot handle the particular path. If the operation was initiated by the MPR  calling the WebDAV network provider  which in turn contacted the WebDAV kernel mode redirector  to find out if it could handle the URI, the WebDAV kernel mode redirector  can respond negatively to the WebDAV network provider  to handle appropriately. Note that although not necessary, it is possible to handle a timeout failure at step  by retrying it (return to step ) some number of times before considering the operation a failure.","If at steps  and  the server responds with information indicating that the server is a WebDAV server, step  is executed, which represents preserving any relevant information returned in the response to the HTTP OPTIONS request, e.g., a list of the capabilities of the server. At this time, , step  continues to step  of , as appropriate.",{"@attributes":{"id":"p-0049","num":"0050"},"figref":"FIGS. 4 and 5","b":"216"},"At step  of , once the server is known to support WebDAV, the process attempts to obtain the properties of the share identified in the URI via a WebDAV PROPFIND request that identifies the share. Note that as described above, this is accomplished via the user mode redirector component  (which, for example regularly polls to obtain web service-directed requests when readied by the kernel mode component) and the Internet transport component . Step  represents evaluating whether the PROPFIND request was successful. For example, the PROPFIND request may result in the server responding with an error (e.g., if the requested share does not exist) or the PROPFIND request may time out without a response. If the PROPFIND request fails, error handling is represented at step , which, as is understood, may vary in what is appropriate. For example, a negative response to the MUP or MPR may suffice, as described above. In other circumstances, such as the server being a WebDAV share but the particular requested share being non-existent, a response that ultimately informs the application that the specified share is not found would be appropriate. Of course, it is possible to retry any timeout error or the like as desired before considering it a failure.","In the event that the share's properties are returned, they are preserved in a file control block or the like at step . For example, as described below, one of the properties may indicate that the shared folder is encrypted, which the system needs to know so that any newly created file in that folder will be stored in encrypted form on the WebDAV server. File control blocks are well known data structures for maintaining information in association with a file system's objects, and are thus not described herein for purposes of simplicity.","If successful at step , and following step , step  is executed to issue a PROPFIND request on the identified path to obtain the file properties, e.g., via the user mode redirector component . If the file exists and no other error (e.g., no response) occurred as determined by step , step  is executed to place the file properties in the file control block. At this time, the kernel mode redirector component  responds with a success, e.g., to the MUP , with information that causes the MUP to cache the \u201cServer\/Share\u201d part of the URI, as discussed above. It should be noted that some or all the WebDAV requests can be accomplished in a single PROPFIND request specifying the path. Similarly, the \u201cServer\/Share\u201d part of the URI may be cached following a successful PROPFIND(share) operation. However, in a preferred implementation, separately issuing an OPTIONS request, a PROPFIND(share) request and then a PROPFIND(path) request has been found to provide the desired overall results for various actual circumstances.","Once the file is known to exist and its properties have been retrieved, , step  is executed to issue a \u201cGET\u201d request to retrieve the file to local storage. One way that this can be accomplished is to have the user mode WebDAV redirector component  instruct the Internet transport component  to cache the file upon receipt. For example, with WinInet functionality, a private, per-user and\/or hidden cache  can be specified in advance (e.g., logically separate from other local file system and Internet cached files ). When the file data is received, the Internet transport component  will cache the retrieved file data via the local file system  (e.g., NTFS, which may correspond to the file system  of ) to that specified location , rather than, for example, to a regular folder or the cache used for normal Internet content retrieval.","For purposes of simplicity, the present invention will be primarily described with respect to the entire file being downloaded as a whole via a GET request (step ), and later written back to the WebDAV server as a whole via a PUT request when the application closes the file. Notwithstanding, READ RANGE and other extensions are well-understood alternatives for downloading file data. Moreover, although WRITE RANGE requests are not presently implemented in WebDAV, it is understood that writing the file back in ranges, rather than as a whole, is also a practical alternative.","By way of examples, instead of (or in addition to) issuing a GET request, one ore more READ RANGE requests may be specified. This would allow some file data to be received without awaiting downloading of the entire file, which may provide a more satisfying user experience, particularly with very large files and\/or a low bandwidth connection. For example, with an existing file, since the application's file open request is typically followed by a read request, a separate READ RANGE request could make available at least some (e.g., the first part) of the likely-requested data to the application without waiting for the GET request to complete. Alternatively, multiple READ RANGE requests could be sent to download the file data. As is understood, if used, READ RANGE requests may be made on demand when data is needed and\/or in anticipation of data to be read. However, as is also understood, if the application is allowed to write to the file, then any written (dirtied) portions of the file cannot be allowed to be overwritten with incoming data or the writes would be lost. To this end, such dirtied portions would have to be tracked, such as via a bitmap, with the data kept by either not writing changes to the file until the GET request or READ RANGE request to the dirtied region completes, or by preventing downloaded data from overwriting dirtied regions.","Returning to , step  represents the GET request being issued to read the entire file's data. If not successful, the request can be retried some number of times before being considered an error, but once an error is determined, it is handled at step , such as by returning a suitable errorcode to the application in response to the failed file create\/open API request.","The process continues to step  of , which represents caching of the downloaded data. At step , a decision is made as to whether the downloaded file is encrypted, as described below. This can be done by checking file attribute information, and\/or by using an encrypting file system function that evaluates the data of any file and determines whether it is encrypted by the encrypting file system. The encrypting file system is described below with respect to .","For purposes of the present example, at this time, the file will not be considered as encrypted, and thus step  branches to step  which opens (creates) a file on the local file system, e.g., in a hidden, private WebDAV cache , and step  writes the file data (e.g., from the buffers of the Internet transport ) to the file in the cache . The process then returns to , step , to return the file handle and so on to the application, and thus the file may be left open at this time.","Once locally cached, the locally cached file information (e.g., a file handle returned by the file system ) is made available to the WebDAV redirector components , as represented by step . Step  represents the returning of this handle to the I\/O manager , which provides the handle to the application  via the API response. Note that the file handle (identifier) given to the WebDAV components  by the NTFS file system  is not the same file handle that the WebDAV kernel mode redirector  returns to the I\/O manager , but rather one created to correspond to it. In any event, the WebDAV kernel mode redirector  knows the file handle that the application  has, whereby as described below, the WebDAV kernel mode redirector  can detect when this file handle is closed and thereafter put the file back on the WebDAV server .","Some time after the file is open, the application uses this file handle in a file I\/O request (e.g., a read or write) sent to the I\/O manager  via a file I\/O API, as represented by step . As is known, as a result of this I\/O-related API call, an IRP corresponding to this request is received by the WebDAV kernel mode redirector , which is in the driver stack. The WebDAV kernel mode redirector  recognizes the file handle, and (e.g., if the file is not being closed at step ) generally satisfies the request by simply passing the IRP through to the file system driver  at step , translating the handle value in the IRP to the handle of the cached file, if it was changed. In other words, since in the present example the entire file is present on the local storage  until the file is closed, any file I\/O requests (in the form of IRPs) to read or write to that file as identified by the handle are passed through the WebDAV kernel mode redirector  to the file system driver , adjusting the file handle as necessary. In this manner, reads and writes are to the local file copy via the file system , keeping this aspect of the kernel mode redirector  simple.","Eventually, the application  will request closing of the file, as detected by step , which then branches to step . Note that for efficiency, the kernel mode redirector  can track whether at least one write request or other (e.g., property) change occurred, so that if not (whereby the file did not possibly change), via step , the identical file need not be put back on the WebDAV server . However, if modified as detected at step , to preserve the file on the WebDAV server , at the time of file close, the kernel mode redirector  will issue a PUT request to upload the file content to the WebDAV server , via the user mode redirector  and Internet transport component .",{"@attributes":{"id":"p-0062","num":"0063"},"figref":"FIG. 7","b":["700","702","704","706","708","220"]},"Step  represents the issuing of the \u201cPUT\u201d request to upload the file to the WebDAV server . As with other communications, this is accomplished via the user mode WebDAV redirector component  web services in conjunction with the Internet transport . Step  then returns to step  of .","Step  of  represents testing whether the PUT request was successful. If the PUT is not successful, the WebDAV kernel mode redirector  can take action at step  to ensure that any changes are not lost. For example, the WebDAV kernel mode redirector  can preserve information (e.g., to the registry) indicating the locally cached file's location and other relevant information, so that the WebDAV kernel mode redirector  can later write the file to the WebDAV server, such as when connectivity thereto is restored. So that the file data is not temporarily lost, the WebDAV kernel mode redirector  can also reopen such an unwritten local copy when requested, instead of the WebDAV copy, until the WebDAV kernel mode redirector  is able to successfully upload the local copy to the WebDAV server and resume normal operation.","If the PUT request is successful at step , (or if the file was not modified at step ), then step  is executed to perform any clean-up operations or the like. In this manner, from the application's perspective, the data is transparently transferred to and from a WebDAV server  like any other stored file. Note however that the local file is preferably not deleted, but is maintained locally (as least for some time) in the event the user decides to again open the file, e.g., relatively soon. In this way, the cached file can be used (if it has not been modified) instead of requiring a GET request to download the file from the server.","It should be noted that security is handled by the Internet transport, e.g., the WinInet APIs, which handles the authentication with the server. This includes Passport Authentication. As is known, Microsoft\u00ae Passport is an online service that provides users with secure access to multiple, Passport-enabled Web sites and services using only an e-mail address and a single password.","In the above manner, existing applications can obtain the benefit of WebDAV file access in a manner that is essentially transparent from the applications' user mode perspective. As a result, applications simply work with a WebDAV file as if it was on a local drive or SMB network drive. However, because WebDAV is a file access protocol that travels over HTTP, WebDAV runs over the existing Internet infrastructure (e.g., through firewalls and routers), providing access to files from essentially any Internet-connected location.","Encrypted WebDAV Files","In known prior network storage solutions, a file may have an access control list (ACL) associated therewith, whereby only users having rights to a file may access it. However, this assumes a secure file system such as NTFS and trusted system administrators, which outside of a controlled corporate network or the like, (such as with WebDAV), may not be the actual situation. Further, even with ACLs, network administrators have access to the files, and while this may be acceptable to closed corporate environments, there are no safe assumptions that can be made as to how carefully outside storage providers will store a client's data, e.g., on what file system, how securely from hackers, or who will have administrator rights.","Prior network storage solutions dealt with some of these issues by encrypting the file data on its storage medium, and then when retrieved, decrypting the data and sending it in an unencrypted format to the receiver, who might then re-encrypt the file. Even though the unencrypted file data can be sent securely with another protocol, such a system has inherent problems. One such problem is the load on the server, e.g., if the server supports many clients and has to encrypt and decrypt each incoming and outgoing transaction, performance is significantly decreased. Another problem is that the server has to be able to decrypt files stored on its system, whereby compromising the server compromises the data.","In accordance with another aspect of the invention, WebDAV files may be locally encrypted and decrypted at the file system level, transparent to applications and the WebDAV server. Since with WebDAV files can be arranged in any format, the local client can encrypt the files locally, into a set of binary bits that are unreadable without a key, which the server is never given, whereby the files cannot be decrypted at the server. As a result, since the server never receives the data in unencrypted form, clients can keep confidential information on the server without worrying about it being viewed, regardless of how it is stored and who has access to it. Moreover, since with an encrypted file the WebDAV server simply receives or sends an already encrypted file, the server does not have to do any additional encryption or decryption work to attempt to protect the data.","To provide such locally transparent encryption and decryption for WebDAV files, the kernel mode redirector component  leverages the Encrypting File System (EFS) technology provided with the NTFS file system. As described in U.S. Pat. No. 6,249,866, hereby incorporated by reference herein, EFS automatically encrypts and decrypts file data at the file system level using a public key-private key pair encryption scheme. Files may be marked (e.g., by the user) as encrypted, or entire folders may be marked as encrypted, in which event any files in that folder are stored in encrypted form. Note that at present, EFS only works with the NTFS file system. The kernel mode WebDAV redirector component  can check where it is putting the file to make sure that it is under the NTFS file system.","In general, EFS operates as generally represented in , in one implementation comprising an Encrypting File System (EFS) linked library , (e.g., DLL), an EFS runtime library (FSRTL)  and an EFS service . The EFS linked library  registers with the file system , whereby the file system provides encryption functionality that is transparent (e.g., to an application) by calling the EFS linked library's functions, listed in a function table or the like acquired by the file system during registration.","During initialization, the EFS linked library  registers file system runtime library callback routines (FSRTL  routines) with the NTFS , maintained in the function table . As described below, NTFS  uses these FSRTL  routines to call back to obtain file encryption related services. The EFS linked library  provides the support to communicate with the user mode EFS service  running, as part of the security subsystem. During initialization (or alternatively when encryption or decryption is first needed), the EFS linked library  communicates with the EFS service  using a GenerateSessionKey interface, to establish a symmetric session key that is used to communicate securely between the EFS linked library  and the EFS service . Data communicated between the two is encrypted using this session key. This session key is also used by callouts to the FSRTL  to decrypt I\/O controls from the EFS service . During open of an encrypted file, the EFS linked library  communicates with the EFS service  by passing it the file metadata, including data decryption and data recovery fields that are maintained within EFS-encrypted files, to get back the file encryption key and any updates to the file metadata. The file metadata may be updated because the user may change to a new key, or the recovery agent's keys might get updated. The EFS linked library  passes this information to FSRTL .","During encryption of a plaintext file\/directory or creation of a new encrypted file, the EFS linked library  communicates with the EFS service  to get a new file encryption key, and encryption metadata for the encrypted file. The EFS linked library  also passes this information to the FSRTL .","The FSRTL  is a module that implements NTFS callouts to handle various file system  operations such as reads, writes, and opens, on encrypted files and directories, as well as operations to encrypt, decrypt, and recover file data when it is written to or read from disk. To this end, the present invention provides a callout mechanism including an interface between NTFS  and the FSRTL . This interface is generic to any appropriate library (and driver) that transform data, including the ones described herein that encrypt data, and thus the interface between NTFS  and FSRTL  is more accurately referred to as a data transformation interface .","Operations between the EFS linked library  and FSRTL  include writing EFS attribute data (decryption data and recovery fields) as file attributes, and communicating a file encryption key computed in the EFS service  to FSRTL , such that it can be set up in the context of an open file. This file context is then used for transparent encryption and decryption on writes and reads of file data to and from the non-volatile storage .","The data transformation interface  interfaces the EFS linked library  to the file system  for accomplishing data encryption. The EFS linked library  registers these callbacks with the file system , whereby the file system  uses the registered EFS callback functions at appropriate times to carry out the various encrypting and decrypting tasks that the user requests. The data transformation interface  includes a number of function pointers, or callbacks. A first callback which the file system  uses, the FileCreate callback, tells the registered EFS functions that a stream is being created or opened.","When an application opens or creates a file, the I\/O subsystem including the I\/O manager  determines the file is of a certain file system, e.g., an NTFS file, and passes the request on to NTFS . NTFS  determines whether EFS may be interested in the file, e.g., if the file is created in an encrypted directory or if a stream is created or attached to an encrypted file. IF NTFS  determines that the file is of interest to EFS, and sees that the EFS linked library  is registered therewith, NTFS  calls a registered EFS function, i.e., the FileCreate callback. If the request is a file open request on an existing file, FSRTL  reads the file metadata from the file attribute and fills up a context block, previously allocated by the EFS linked library  to pass back that information to the EFS linked library . When the call returns from NTFS , the EFS linked library  takes the metadata information and communicates with the EFS service  to extract a file encryption key from the metadata. This information is then returned by the EFS linked library  to NTFS  by another FSRTL  interface, FileControl, described below, which sets up a key context on the file being opened. This key context is thereafter retained by NTFS  for future calls to the EFS linked library  until the file is closed. If the file metadata is updated, the updated metadata is also re-written to the attributes by the registered EFS functions through NTFS callbacks.","If a new file is created, the FileCreate call results in the FSRTL  filling up the context buffer with a request for a new file encryption key and metadata. The FSRTL  then passes the context buffer back to the EFS linked library . The EFS linked library  takes this information and communicates with the EFS service  to obtain a new file encryption key and new file metadata from the EFS service . Using a file control callback, the EFS linked library  returns this information to the FSRTL , whereby, using NtOfs function calls, the FSRTL  sets up the key context  on the file being created and writes the file metadata. The NtOfs API is a set of NTFS  function calls that allow the EFS linked library  to call into the file system  to manipulate the data streams containing the encryption metadata.","Another callback, FileSystemControl1, is called by NTFS  in response to the EFS linked library  request when a user is setting the encryption state of a file (EFS_SET_ENCRYPT), either marking it as encrypted or decrypted. In response, NTFS  sets or clears the encryption bit, and the EFS linked library  generates any necessary key storage. EFS_SET_ENCRYPT also originates in the EFS service  when a plaintext file begins to be encrypted, whereby the file state is modified such that no other operations are allowed on the file until the encryption is completed.","NTFS  also calls the FileSystemControl2 interface with various encryption driver-specific file control requests from the EFS linked library . Note that NTFS  takes no action with these callbacks other than to simply pass the call to the FSRTL . The file control requests include EFS_SET_ATTRIBUTE, which comes from the EFS filter EFS linked library  when it wants to write new or updated file metadata, and EFS_GET_ATTRIBUTE, which may come from the EFS linked library  or a user mode application  to query the file metadata. The information includes the list of user public keys and recovery agent public keys that may be used to encrypt the file encryption key. Another request, EFS_DECRYPT_BEGIN, comes from the EFS service  when it starts decrypting an encrypted file. In response, the state of the file is modified such that no other operations are allowed on the file until the decryption is completed. EFS_DEL_ATTRIBUTE is a request originating in the EFS service  when it finishes decrypting an entire encrypted file, and wants to delete the file metadata and associated attribute. The EFS_ENCRYPT_DONE request also comes from the EFS service  when it successfully completes the file encryption. The file state is modified to allow any operations from this point on. EFS_OVERWRITE_ATTRIBUTE comes from the EFS service  when an encryption file is restored from its backup format. The EFS service  supplies the file metadata that needs to overwrite any existing metadata on the file. This request is also associated with the deletion of any key context  associated with that file, such that no reads or writes can proceed while the file is being restored.","The FileSystemControl2 interface is also called by the file system  in response to the FSCTL_ENCRYPTION_FSCTL_IO, also described below. This provides a means for the EFS linked library  to have NTFS  call the EFS linked library  (itself), such as when NTFS  recognizes that a file is in a certain state corresponding to a state for which the EFS linked library  is waiting.","The file system  directly uses the callback, AfterReadProcess after it has read some data from the disk for an encrypted file, and before returning it to the user. The AfterReadProcess function decrypts the data on the fly in response to this callback. Conversely, BeforeWriteProcess is called by the file system  before it writes some data to the disk for an encrypted file. The function encrypts the data as a result of this callback.","The EFS service  also provides support for Win32 APIs , which are programming interfaces for encrypt, decrypt, recover and provide support for importing and exporting encrypted files. Importing and exporting encrypted files allows users to convert the files into opaque data (encrypted) for operations such as backup, restore, and general file transfer purposes, including WebDAV, as described below. The Win32 APIs  provide programming interfaces for encrypting plain text files, decrypting or recovering ciphertext files, and importing and exporting encrypted files (without decrypting them first).","As generally described above, in addition to transparent encryption and decryption of file data at the file system level, EFS can thus encrypt files that were not previously encrypted, add user keys to a file, change any other basic EFS information about an encrypted file, such as the type of encryption used, and perform other functions.","In accordance with one aspect of the present invention, when a file is already encrypted on a WebDAV server, the file can be transferred in encrypted form to the client, locally decrypted for reading, have changes made thereto, and put back on the client and the server in encrypted form. However, because EFS will transparently decrypt reads and encrypt writes at the file system level, the file cannot simply be opened and read to upload it, otherwise the data would not be transmitted in its encrypted form. Similarly, if an encrypted file is downloaded, a file to hold the data cannot simply be created locally and written to, since EFS would attempt to encrypt already-encrypted data when it wrote the data to the local file.","To this end, when uploading an encrypted file, a file image that corresponds to how it appears when stored locally in encrypted form is sent, including EFS information included in the file that is necessary to later decrypt it. Similarly, when downloading an already-encrypted file, the file is written to local storage as an image that corresponds to how it was originally written to the server, i.e., as an encrypted file.","In one implementation, to transfer the data back and forth, the file image is sent using certain functions, namely EFSOpenFileRaw( ), EFSReadFileRaw( ), EFSWriteFileRaw( ), and EFSCloseFileRaw( ) APIs. In essence, this essentially bypasses the encryption or decryption operations by EFS on the file data, whereby the file is transferred as a block of \u201craw\u201d bits.","More particularly, the EFSOpenRawFile( ) function (API) allows the user to open an encrypted file without read access, and without setting up a file encryption key to do transparent reads and writes. For these operations, NTFS  recognizes the access level and does not call the encryption EFS linked library  to look up a key for this file, nor o decrypt reads nor encrypt writes. The only operations allowed on a file opened via this interface are file controls. Thus, an EFSReadRawFile( ) API allows the user to read the data from the file, including the encryption metadata, as a contiguous opaque stream, which can then be sent to the WebDAV server. The EFSWriteRawFile( ) API allows the user to write a contiguous opaque stream received from a WebDAV server to an NTFS disk volume, including the encryption metadata of an encrypted file.",{"@attributes":{"id":"p-0090","num":"0091"},"figref":"FIG. 6","b":["600","600","606","240","608","240","610"]},"At this time, the downloaded file is maintained in local storage like any other encrypted file. Step  opens this file in the normal manner, whereby EFS will now automatically decrypt reads and encrypt writes as the file is accessed with I\/O commands, in a manner that is transparent to other higher level components, including the application. Thus, steps - act as described above with respect to non-encrypted files.","Once the file is closed however, it needs to be put back on the WebDAV server  in its encrypted form. Again, note that the WebDAV server  has no idea of the format and content of the file, as it is simply storing a named collection of bits. Locally, however, the file will not be decrypted when read into the transport's buffers or the like for the PUT operation, and thus the EFS needs to read the raw bits into the buffers as an image of the entire encrypted file, not just the decrypted data portion thereof.","Step  of  determines whether the file is marked as encrypted. If not, it is possible that the directory is marked as encrypted, whereby the file will need to be encrypted as well. Step  checks for this possibility. If not, it is possible that the directory is intended to be encrypted, but has been changed at the WebDAV server, whereby step  checks a registry setting or the like that tracks which WebDAV folders should be encrypted. If the registry setting indicates that this particular WebDAV folder should be encrypted, but for some reason was not at step , then step  branches to step  to reset the WebDAV folder properties to reflect that the folder is encrypted. Note that steps ,  and  can be done at other times, not just at file uploads, to ensure that encrypted folders remain that way, and\/or that the files under those folders are encrypted.","If the folder is encrypted but the file is not, the file is closed at step , as described below. Note that the file inside the encrypted WebDAV folder is not encrypted at this time, but will remain unencrypted until accessed through the WebDAV redirector. In other words, if a file is not encrypted (which means it was created before the folder was marked encrypted), it will remain unencrypted even if it is modified. Only if a new file is created in an encrypted folder is that file created encrypted.","At step , the encrypted local file is closed, and reopened at step  for copying it raw to the WebDAV server. As described above, the raw copying is accomplished by having NTFS open files with the EFSOpenFileRaw( ) API at step , read the file raw (as an opaque stream) via the EFSReadFileRaw( ) API into the appropriate buffer for transmitting the file to the WebDAV server at step , and then close the file via the EFSCloseFileRaw( ) API at step . The file is uploaded to the WebDAV server at step  as described above. In this manner, the WebDAV server stores an image of an encrypted file as is, without any EFS decryption done before uploading. Since the server file cannot be decrypted without a user or recovery agent's private key, which a WebDAV server administrator would not (typically) possess, the server file data remains private, as long as the set of private keys that can open the file is secure. Moreover, the type of file system storage on the WebDAV server is unimportant, since even if the file system is not secure, an encrypted file cannot be viewed in plaintext.","In accordance with another aspect of the present invention, support for other EFS APIs is provided. For example, a previously non-encrypted WebDAV file may be set as encrypted, a user or recovery agent's key may be added to a file, or other basic EFS information about the file may be changed. In general, such operations are performed locally, with the file transferred back and forth using the EFSOpenFileRaw( ), EFSReadFileRaw( ), EFSWriteFileRaw( ), and EFSCloseFileRaw( ) APIs.","To this end, when called, EFS determines whether a file is on a network share, and what the UNC name of that file is. EFS APIs will try to detect the WebDAV path by using WNet APIs or the like, e.g., GetDriveType( ) and WNetGetResourceInformation( ). For example in a Windows\u00ae XP environment, EFS will use GetDriveType ( ) to detect a remote path. When the remote path is obtained, EFS checks whether the path corresponds to a WebDAV path by using WNetGetProviderName( ) and WNetGetResourceInformation( ). If so, via a remote procedure call, EFS provides the UNC name to the local EFS server. If the path is not a WebDAV path, EFS provides the UNC name to the remote EFS server where the file exists.","The EFS server uses the UNC name where a local name is used in the current code, i.e., the EFS server is using the WebDAV UNC name as if it was the local name. This causes WebDAV kernel mode redirector  to intercept and redirect EFS FSCTLs to the local NTFS .","The kernel mode WebDAV redirector  also looks for calls to NtQueryVolumeInformation( ) on a WebDAV handle to return information about the client. Note that if there is not enough space on the server, WebDAV will return an error in a separate path without EFS being aware of it. When the EFS API finishes the jobs, WebDAV will uses the EFSOpenFileRaw( ), EFSReadFileRaw( ) and EFSCloseFileRaw( ) APIs to move the modified file back to the WebDAV server, as described above.","As can be seen from the foregoing detailed description, there is provided a method and system that transparently provide access to WebDAV files. The method and system provide file I\/O functionality and networking (e.g., browsing) functionality as if the file was on a local file system volume instead of at a WebDAV server. Moreover, the present invention enables browsers and the like to access WebDAV stored files via networking APIs. As a result, file sharing across the Internet (through firewalls, routers, and so forth) via WebDAV servers is provided, which cannot be achieved with network file servers. The method and system work with files that are encrypted such that the WebDAV server only sees files in their encrypted form and has no key to decrypt the files.","While the invention is susceptible to various modifications and alternative constructions, certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood, however, that there is no intention to limit the invention to the specific form or forms disclosed, but on the contrary, the intention is to cover all modifications, alternative constructions, and equivalents falling within the spirit and scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 3 and 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
