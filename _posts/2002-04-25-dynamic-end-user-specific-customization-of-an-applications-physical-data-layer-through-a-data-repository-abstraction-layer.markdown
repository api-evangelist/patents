---
title: Dynamic end user specific customization of an application's physical data layer through a data repository abstraction layer
abstract: A system, method and article of manufacture are provided for accessing data independent of the particular manner in which the data is physically represented. In one embodiment, a plurality of data repository abstractions provide different logical views of the same underlying data repository. The plurality of data repository abstractions may each be associated with different users, thereby exposing a different set of data to each user. A runtime component performs translation of abstract queries into a form that can be used against a particular physical data representation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06928431&OS=06928431&RS=06928431
owner: International Business Machines Corporation
number: 06928431
owner_city: Armonk
owner_country: US
publication_date: 20020425
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["1. Field of the Invention","The present invention generally relates to data processing and more particularly to accessing data independent of the particular manner in which the data is physically represented.","2. Description of the Related Art","Databases are computerized information storage and retrieval systems. A relational database management system is a computer database management system (DBMS) that uses relational techniques for storing and retrieving data. The most prevalent type of database is the relational database, a tabular database in which data is defined so that it can be reorganized and accessed in a number of different ways.","Regardless of the particular architecture, in a DBMS, a requesting entity (e.g., an application or the operating system) demands access to a specified database by issuing a database access request. Such requests may include, for instance, simple catalog lookup requests or transactions and combinations of transactions that operate to read, change and add specified records in the database. These requests are made using high-level query languages such as the Structured Query Language (SQL). Illustratively, SQL is used to make interactive queries for getting information from and updating a database such as International Business Machines' (IBM) DB2, Microsoft's SQL Server, and database products from Oracle, Sybase, and Computer Associates. The term \u201cquery\u201d denominates a set of commands for retrieving data from a stored database. Queries take the form of a command language that lets programmers and programs select, insert, update, find out the location of data, and so forth.","One of the issues faced by data mining and database query applications, in general, is their close relationship with a given database schema (e.g., a relational database schema). This relationship makes it difficult to support an application as changes are made to the corresponding underlying database schema. Further, the migration of the application to alternative underlying data representations is inhibited. In today's environment, the foregoing disadvantages are largely due to the reliance applications have on SQL, which presumes that a relational model is used to represent information being queried. Furthermore, a given SQL query is dependent upon a particular relational schema since specific database tables, columns and relationships are referenced within the SQL query representation. As a result of these limitations, a number of difficulties arise.","One difficulty is that changes in the underlying relational data model require changes to the SQL foundation that the corresponding application is built upon. Therefore, an application designer must either forgo changing the underlying data model to avoid application maintenance or must change the application to reflect changes in the underlying relational model. Another difficulty is that extending an application to work with multiple relational data models requires separate versions of the application to reflect the unique SQL requirements driven by each unique relational schema. Yet another difficulty is evolution of the application to work with alternate data representations because SQL is designed for use with relational systems. Extending the application to support alternative data representations, such as XML, requires rewriting the application's data management layer to use non-SQL data access methods.","A typical approach used to address the foregoing problems is software encapsulation. Software encapsulation involves using a software interface or component to encapsulate access methods to a particular underlying data representation. An example is found in the Enterprise JavaBean (EJB) specification that is a component of the Java 2 Enterprise Edition (J2EE) suite of technologies. In the case of EJB, entity beans serve to encapsulate a given set of data, exposing a set of Application Program Interfaces (APIs) that can be used to access this information. This is a highly specialized approach requiring the software to be written (in the form of new entity EJBs) whenever a new set of data is to be accessed or when a new pattern of data access is desired. The EJB model also requires a code update, application build and deployment cycle to react to reorganization of the underlying physical data model or to support alternative data representations. EJB programming also requires specialized skills, since more advanced Java programming techniques are involved. Accordingly, the EJB approach and other similar approaches are rather inflexible and costly to maintain for general-purpose query applications accessing an evolving physical data model.","Another shortcoming of the prior art, is the manner in which information can be presented to the user. A number of software solutions support the use of user-defined queries, in which the user is provided with a tool to construct a query that meets the user's specific data selection requirements. In an SQL-based system, the user is given a list of underlying database tables and columns to choose from when building a query. The user must decide which tables and columns to access based on the naming convention used by the database administrator. This approach does not provide an effective way to subset the set of information presented to the user. As a result, even nonessential content is revealed to the user.","Further, existing database environments do not effectively accommodate multiple users desiring to access different portions of the same physical data simultaneously. Typically, such simultaneous access is accomplished by each user using a separate application. Each application is written to expose the desired data to the respective users. Accordingly, substantial overhead in application development results in today's database environments.","Therefore, there is a need for an improved and more flexible method for accessing data which is not limited to the particular manner in which the underlying physical data is represented and which preferably avoids overhead in application development associated with the prior art.","The present invention generally is directed to a method, system and article of manufacture for accessing data independent of the particular manner in which the data is physically represented and for exposing the data differently using the same application. In one embodiment, a plurality of data repository abstractions provide different logical views of the same underlying data repository. The plurality of data repository abstractions may each be associated with different users, thereby exposing a different set of data to each user. A runtime component performs translation of abstract queries into a form that can be used against a particular physical data representation.","One embodiment provides a method of providing access to data having a particular physical data representation. The method comprises providing a query specification comprising a plurality of logical fields for defining abstract queries; providing a first set of mapping rules which map at least a first portion of the plurality of logical fields to a first plurality of physical entities of the data; and providing a second set of mapping rules which map at least a second portion of the plurality of logical fields to a second plurality of physical entities of the data.","Another method of providing access to data having a particular physical data representation comprises providing an application defining a query specification comprising a plurality of logical fields for defining abstract queries; and providing a plurality of user profiles each defining an association with different sets of mapping rules each of which map at least a portion of the plurality of logical fields to physical entities of the data.","Yet another method of accessing data having a particular physical data representation comprises issuing, by a first user, a first abstract query to an application, wherein the first abstract query is defined according to a first plurality of logical fields and, in response to the first abstract query, accessing a first set of mapping rules having a defined association with the first user. In response to a second user issuing a second abstract query to the application, wherein the second abstract query is defined according to a second plurality of logical fields. In response to the second abstract query, a second set of mapping rules having a defined association with the second user is accessed. Each of the first and second abstract queries are transformed into queries consistent with the particular physical data representation according to respective mapping rules which map the logical fields to physical entities of the data.","Yet another embodiment provides a computer-readable medium containing a database access environment which provides access to data having a particular physical data representation. The database access environment comprises an application comprising a query specification, the query specification comprising a plurality of logical fields for defining abstract queries; and a plurality of mapping rules sets which map the plurality of logical fields to physical entities of the data. At least two of the plurality of mapping rules sets map the plurality of logical fields to different sets of the physical entities of the data and are uniquely associated with at least one of two different requesting entities selected from one of two different users, two different groups of users, and a group of users and a user.","Still another embodiment provides a computer-readable medium containing a program which, when executed by a processor, performs an operation of accessing data having a particular physical data representation. The operation comprises receiving a plurality of abstract queries issued by a plurality of users according to a query specification of an application; wherein the query specification provides a definition for the abstract query according to logical fields; and transforming the abstract query into a query consistent with the particular physical data representation according to a plurality of data repository abstraction components which map the logical fields to physical entities of the data. A different data repository abstraction component is associated with at least two of the users using the application.","Still another embodiment provides a computer comprising a memory containing at least (i) an application comprising a query specification providing a definition for an abstract query according to logical fields, (ii) a plurality of data repository abstraction components which map the logical fields to physical entities of data, wherein at least a portion of the data repository abstraction components have a programmatically defined association with different users, and (iii) a runtime component for transforming the abstract query into a query consistent with the physical entities of data according to the data repository abstraction components.","Introduction","The present invention generally is directed to a system, method and article of manufacture for accessing data independent of the particular manner in which the data is physically represented. In one embodiment, a data repository abstraction layer provides a logical view of the underlying data repository that is independent of the particular manner in which the data is physically represented. A query abstraction layer is also provided and is based on the data repository abstraction layer. A runtime component performs translation of an abstract query into a form that can be used against a particular physical data representation. In one embodiment, the data repository abstraction layer comprises multiple data repository abstraction components\/instances which coexist (and, in some embodiments, cooperate) within a single application space. The provision of multiple instances of data repository abstractions allows different sets of data to be exposed to different users. Further, one embodiment provides for dynamic instantiation of new data repository abstraction components allowing for on-the-fly changes to be made and for multiple dynamic users to customize their respective data abstraction component.","One embodiment of the invention is implemented as a program product for use with a computer system such as, for example, the computer system shown in FIG.  and described below. The program(s) of the program product defines functions of the embodiments (including the methods described herein) and can be contained on a variety of signal-bearing media. Illustrative signal-bearing media include, but are not limited to: (i) information permanently stored on non-writable storage media (e.g., read-only memory devices within a computer such as CD-ROM disks readable by a CD-ROM drive); (ii) alterable information stored on writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive); or (iii) information conveyed to a computer by a communications medium, such as through a computer or telephone network, including wireless communications. The latter embodiment specifically includes information downloaded from the Internet and other networks. Such signal-bearing media, when carrying computer-readable instructions that direct the functions of the present invention, represent embodiments of the present invention.","In general, the routines executed to implement the embodiments of the invention, may be part of an operating system or a specific application, component, program, module, object, or sequence of instructions. The software of the present invention typically is comprised of a multitude of instructions that will be translated by the native computer into a machine-readable format and hence executable instructions. Also, programs are comprised of variables and data structures that either reside locally to the program or are found in memory or on storage devices. In addition, various programs described hereinafter may be identified based upon the application for which they are implemented in a specific embodiment of the invention. However, it should be appreciated that any particular nomenclature that follows is used merely for convenience, and thus the invention should not be limited to use solely in any specific application identified and\/or implied by such nomenclature.","Physical View of Environment",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 1","b":["100","100","102","102","104","104","102","104","126","126","126"]},"The client computer  includes a Central Processing Unit (CPU)  connected via a bus  to a memory , storage , an input device , an output device , and a network interface device . The input device  can be any device to give input to the client computer . For example, a keyboard, keypad, light-pen, touch-screen, track-ball, or speech recognition unit, audio\/video player, and the like could be used. The output device  can be any device to give output to the user, e.g., any conventional display screen. Although shown separately from the input device , the output device  and input device  could be combined. For example, a display screen with an integrated touch-screen, a display with an integrated keyboard, or a speech recognition unit combined with a text speech converter could be used.","The network interface device  may be any entry\/exit device configured to allow network communications between the client computer  and the server computer  via the network . For example, the network interface device  may be a network adapter or other network interface card (NIC).","Storage  is preferably a Direct Access Storage Device (DASD). Although it is shown as a single unit, it could be a combination of fixed and\/or removable storage devices, such as fixed disc drives, floppy disc drives, tape drives, removable memory cards, or optical storage. The memory  and storage  could be part of one virtual address space spanning multiple primary and secondary storage devices.","The memory  is preferably a random access memory sufficiently large to hold the necessary programming and data structures of the invention. While the memory  is shown as a single entity, it should be understood that the memory  may in fact comprise a plurality of modules, and that the memory  may exist at multiple levels, from high speed registers and caches to lower speed but larger DRAM chips.","Illustratively, the memory  contains an operating system . Illustrative operating systems, which may be used to advantage, include Linux and Microsoft's Windows\u00ae. More generally, any operating system supporting the functions disclosed herein may be used.","The memory  is also shown containing a browser program  that, when executed on CPU , provides support for navigating between the various servers  and locating network addresses at one or more of the servers . In one embodiment, the browser program  includes a web-based Graphical User Interface (GUI), which allows the user to display Hyper Text Markup Language (HTML) information. More generally, however, the browser program  may be any GUI-based program capable of rendering the information transmitted from the server computer .","The server computer  may be physically arranged in a manner similar to the client computer . Accordingly, the server computer  is shown generally comprising a CPU , a memory , and a storage device , coupled to one another by a bus . Memory  may be a random access memory sufficiently large to hold the necessary programming and data structures that are located on the server computer .","The server computer  is generally under the control of an operating system  shown residing in memory . Examples of the operating system  include IBM OS\/400\u00ae, UNIX, Microsoft Windows\u00ae, and the like. More generally, any operating system capable of supporting the functions described herein may be used.","The memory  further includes one or more applications  and an abstract query interface . The applications  and the abstract query interface  are software products comprising a plurality of instructions that are resident at various times in various memory and storage devices in the computer system . When read and executed by one or more processors  in the server , the applications  and the abstract query interface  cause the computer system  to perform the steps necessary to execute steps or elements embodying the various aspects of the invention. The applications  (and more generally, any requesting entity, including the operating system  and, at the highest level, users) issue queries against a database (e.g., databases . . . , collectively referred to as database(s) ). Illustratively, the databases  are shown as part of a database management system (DBMS) in storage . The databases  are representative of any collection of data regardless of the particular physical representation. By way of illustration, the databases  may be organized according to a relational schema (accessible by SQL queries) or according to an XML schema (accessible by XML queries). However, the invention is not limited to a particular schema and contemplates extension to schemas presently unknown. As used herein, the term \u201cschema\u201d generically refers to a particular arrangement of data.","In one embodiment, the queries issued by the applications  are defined according to an application query specification  included with each application . The queries issued by the applications  may be predefined (i.e., hard coded as part of the applications ) or may be generated in response to input (e.g., user input). In either case, the queries (referred to herein as \u201cabstract queries\u201d) are composed using logical fields defined by the abstract query interface . In particular, the logical fields used in the abstract queries are defined by a data repository abstraction component  of the abstract query interface . The abstract queries are executed by a runtime component  which first transforms the abstract queries into a form consistent with the physical representation of the data contained in the DBMS . The application query specification  and the abstract query interface  are further described with reference to .","In one embodiment, elements of a query are specified by a user through a graphical user interface (GUI). The content of the GUIs is generated by the application(s) . In a particular embodiment, the GUI content is hypertext markup language (HTML) content which may be rendered on the client computer systems  with the browser program . Accordingly, the memory  includes a Hypertext Transfer Protocol (http) server process  (e.g., a web server) adapted to service requests from the client computer . For example, the process  may respond to requests to access a database(s) , which illustratively resides on the server . Incoming client requests for data from a database  invoke an application . When executed by the processor , the application  causes the server computer  to perform the steps or elements embodying the various aspects of the invention, including accessing the database(s) . In one embodiment, the application  comprises a plurality of servlets configured to build GUI elements, which are then rendered by the browser program .",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 1","FIG. 1"],"b":["102","104","138"]},"Logical\/Runtime View of Environment",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIGS. 2A-B","b":["200","140","202","142","202","154","142","204","206","204"]},"The logical fields specified by the application query specification  and used to compose the abstract query  are defined by the data repository abstraction component . In general, the data repository abstraction component  exposes information as a set of logical fields that may be used within a query (e.g., the abstract query ) issued by the application  to specify criteria for data selection and specify the form of result data returned from a query operation. The logical fields are defined independently of the underlying data representation being used in the DBMS , thereby allowing queries to be formed that are loosely coupled to the underlying data representation.","In general, the data repository abstraction component  comprises a plurality of field specifications , , , and (five shown by way of example), collectively referred to as the field specifications . Specifically, a field specification is provided for each logical field available for composition of an abstract query. Each field specification comprises a logical field name , , , , (collectively, field name ) and an associated access method , , , , (collectively, access method ). The access methods associate (i.e., map) the logical field names to a particular physical data representation , . . . in a database (e.g., one of the databases ). By way of illustration, two data representations are shown, an XML data representation and a relational data representation . However, the physical data representation indicates that any other data representation, known or unknown, is contemplated.","In one embodiment, a single data repository abstraction component  contains field specifications (with associated access methods) for two or more physical data representations . In an alternative embodiment, a different single data repository abstraction component  is provided for each separate physical data representation . In yet another embodiment, multiple data repository abstraction components  are provided, where each data repository abstraction component  exposes different portions of the same underlying physical data (which may comprise one or more physical data representations ). In this manner, a single application  may be used simultaneously by multiple users to access the same underlying data where the particular portions of the underlying data exposed to the application are determined by the respective data repository abstraction component . The latter embodiment will be described in more detail below.","Any number of access methods are contemplated depending upon the number of different types of logical fields to be supported. In one embodiment, access methods for simple fields, filtered fields and composed fields are provided. The field specifications , and exemplify simple field access methods , , and , respectively. Simple fields are mapped directly to a particular entity in the underlying physical data representation (e.g., a field mapped to a given database table and column). By way of illustration, the simple field access method shown in  maps the logical field name (\u201cFirstName\u201d) to a column named \u201cf_name\u201d in a table named \u201ccontact\u201d. The field specification  exemplifies a filtered field access method . Filtered fields identify an associated physical entity and provide rules used to define a particular subset of items within the physical data representation. An example is provided in  in which the filtered field access method maps the logical field name (\u201cAnytownLastName\u201d) to a physical entity in a column named \u201cI_name\u201d in a table named \u201ccontact\u201d and defines a filter for individuals in the city of Anytown. Another example of a filtered field is a New York ZIP code field that maps to the physical representation of ZIP codes and restricts the data only to those ZIP codes defined for the state of New York. The field specification exemplifies a composed field access method . Composed access methods compute a logical field from one or more physical fields using an expression supplied as part of the access method definition. In this way, information which does not exist in the underlying data representation may computed. In the example illustrated in  the composed field access method maps the logical field name \u201cAgeInDecades\u201d to \u201cAgeInYears\/10\u201d. Another example is a sales tax field that is composed by multiplying a sales price field by a sales tax rate.","It is contemplated that the formats for any given data type (e.g., dates, decimal numbers, etc.) of the underlying data may vary. Accordingly, in one embodiment, the field specifications  include a type attribute which reflects the format of the underlying data. However, in another embodiment, the data format of the field specifications  is different from the associated underlying physical data, in which case an access method is responsible for returning data in the proper format assumed by the requesting entity. Thus, the access method must know what format of data is assumed (i.e., according to the logical field) as well as the actual format of the underlying physical data. The access method can then convert the underlying physical data into the format of the logical field.","By way of example, the field specifications  of the data repository abstraction component  shown in  are representative of logical fields mapped to data represented in the relational data representation . However, other instances of the data repository extraction component  map logical fields to other physical data representations, such as XML.","An illustrative abstract query corresponding to the abstract query  shown in  is shown in Table 1 below. By way of illustration, the Data Repository Abstraction  is defined using XML. However, any other language may be used to advantage.",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE I"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"QUERY EXAMPLE"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["001","<?xml version=\u201c1.0\u201d?>"]},{"entry":["002","<?\u2212\u2212Query string representation: (FirstName = \u201cMary\u201d AND"]},{"entry":["003","LastName = \u201cMcGoon\u201d) OR State = \u201cNC\u201d\u2212\u2212>"]},{"entry":["004","<QueryAbstraction>"]},{"entry":["005","\u2003<Selection>"]},{"entry":["006","\u2003\u2003<Condition internalID=\u201c4\u201d>"]},{"entry":["007","\u2003\u2003\u2003<Condition field=\u201cFirstName\u201d operator=\u201cEQ\u201d"]},{"entry":["008","value=\u201cMary\u201d internalID=\u201c1\u201d\/>"]},{"entry":["009","\u2003\u2003\u2003<Condition field=\u201cLastName\u201d operator=\u201cEQ\u201d"]},{"entry":["010","value=\u201cMcGoon\u201d internalID=\u201c3\u201d"]},{"entry":[{},"relOperator=\u201cAND\u201d><\/Condition>"]},{"entry":["011","\u2003\u2003<\/Condition>"]},{"entry":["012","\u2003\u2003<Condition field=\u201cState\u201d operator=\u201cEQ\u201d value=\u201cNC\u201d"]},{"entry":["013","internalID=\u201c2\u201d relOperator=\u201cOR\u201d><\/Condition>"]},{"entry":["014","\u2003<\/Selection>"]},{"entry":["015","\u2003<Results>"]},{"entry":["016","\u2003\u2003\u2003\u2003<Field name=\u201cFirstName\u201d\/>"]},{"entry":["017","\u2003\u2003\u2003\u2003<Field name=\u201cLastName\u201d\/>"]},{"entry":["018","\u2003\u2003\u2003\u2003<Field name=\u201cState\u201d\/>"]},{"entry":["019","\u2003<\/Results>"]},{"entry":["020","<\/QueryAbstraction>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"An illustrative abstract query corresponding to the Data Repository Abstraction  shown in  is shown in Table II below. By way of illustration, the Data Repository Abstraction  is defined using XML. However, any other language may be used to advantage.",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"thead":{"row":[{"entry":"TABLE II"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"DATA REPOSITORY ABSTRACTION EXAMPLE"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["001","<?xml version=\u201c1.0\u201d?>"]},{"entry":["002","<DataRepository>"]},{"entry":["003","\u2003<Category name=\u201cDemographic\u201d>"]},{"entry":["004","\u2003\u2003<Field queryable=\u201cYes\u201d name=\u201cFirstName\u201d displayable=\u201cYes\u201d>"]},{"entry":["005","\u2003\u2003\u2003\u2003\u2003<AccessMethod>"]},{"entry":["006","\u2003\u2003\u2003\u2003\u2003\u2003<Simple columnName=\u201cf_name\u201d tableName=\u201ccontact\u201d><\/Simple>"]},{"entry":["007","\u2003\u2003\u2003\u2003\u2003<\/AccessMethod>"]},{"entry":["008","\u2003\u2003\u2003\u2003\u2003<Type baseType=\u201cchar\u201d><\/Type>"]},{"entry":["009","\u2003\u2003<\/Field>"]},{"entry":["010","\u2003\u2003<Field queryable=\u201cYes\u201d name=\u201cLastName\u201d displayable=\u201cYes\u201d>"]},{"entry":["011","\u2003\u2003\u2003\u2003\u2003<AccessMethod>"]},{"entry":["012","\u2003\u2003\u2003\u2003\u2003\u2003<Simple columnName=\u201cl_name\u201d tableName=\u201ccontact\u201d><\/Simple>"]},{"entry":["013","\u2003\u2003\u2003\u2003\u2003<\/AccessMethod>"]},{"entry":["014","\u2003\u2003\u2003\u2003\u2003<Type baseType=\u201cchar\u201d><\/Type>"]},{"entry":["015","\u2003\u2003<\/Field>"]},{"entry":["016","\u2003\u2003<Field queryable=\u201cYes\u201d name=\u201cState\u201d displayable=\u201cYes\u201d>"]},{"entry":["017","\u2003\u2003\u2003\u2003\u2003<AccessMethod>"]},{"entry":["018","\u2003\u2003\u2003\u2003\u2003\u2003<Simple columnName=\u201cstate\u201d tableName=\u201ccontact\u201d><\/Simple>"]},{"entry":["019","\u2003\u2003\u2003\u2003\u2003<\/AccessMethod>"]},{"entry":["020","\u2003\u2003\u2003\u2003\u2003<Type baseType=\u201cchar\u201d><\/Type>"]},{"entry":["021","\u2003\u2003<\/Field>"]},{"entry":["022","\u2003<\/Category>"]},{"entry":["023","\u2002<\/DataRepository>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 3","b":["300","150","300","302","150","202","2","304","150","306","150","306","308","310","312","308","150","148","150","310","154","1","300","306","306"]},"After building the data selection portion of the concrete query, the runtime component  identifies the information to be returned as a result of query execution. As described above, in one embodiment, the abstract query defines a list of abstract fields that are to be returned as a result of query execution, referred to herein as a result specification. A result specification in the abstract query may consist of a field name and sort criteria. Accordingly, the method  enters a loop at step  (defined by steps , ,  and ) to add result field definitions to the concrete query being generated. At step , the runtime component  looks up a result field name (from the result specification of the abstract query) in the data repository abstraction  and then retrieves a Result Field Definition from the data repository abstraction  to identify the physical location of data to be returned for the current logical result field. The runtime component  then builds (as step ) a Concrete Query Contribution (of the concrete query that identifies physical location of data to be returned) for the logical result field. At step , Concrete Query Contribution is then added to the Concrete Query Statement. Once each of the result specifications in the abstract query has been processed, the query is executed at step .","One embodiment of a method  for building a Concrete Query Contribution for a logical field according to steps  and  is described with reference to FIG. . At step , the method  queries whether the access method associated with the current logical field is a simple access method. If so, the Concrete Query Contribution is built (step ) based on physical data location information and processing then continues according to method  described above. Otherwise, processing continues to step  to query whether the access method associated with the current logical field is a filtered access method. If so, the Concrete Query Contribution is built (step ) based on physical data location information for some physical data entity. At step , the Concrete Query Contribution is extended with additional logic (filter selection) used to subset data associated with the physical data entity. Processing then continues according to method  described above.","If the access method is not a filtered access method, processing proceeds from step  to step  where the method  queries whether the access method is a composed access method. If the access method is a composed access method, the physical data location for each sub-field reference in the composed field expression is located and retrieved at step . At step , the physical field location information of the composed field expression is substituted for the logical field references of the composed field expression, whereby the Concrete Query Contribution is generated. Processing then continues according to method  described above.","If the access method is not a composed access method, processing proceeds from step  to step . Step  is representative of any other access methods types contemplated as embodiments of the present invention. However, it should be understood that embodiments are contemplated in which less then all the available access methods are implemented. For example, in a particular embodiment only simple access methods are used. In another embodiment, only simple access methods and filtered access methods are used.","As described above, it may be necessary to perform a data conversion if a logical field specifies a data format different from the underlying physical data. In one embodiment, an initial conversion is performed for each respective access method when building a Concrete Query Contribution for a logical field according to the method . For example, the conversion may be performed as part of, or immediately following, the steps ,  and . A subsequent conversion from the format of the physical data to the format of the logical field is performed after the query is executed at step . Of course, if the format of the logical field definition is the same as the underlying physical data, no conversion is necessary.","In various embodiments, numerous advantages over the prior art are provided. In one aspect, advantages are achieved by defining a loose coupling between the application query specification and the underlying data representation. Rather than encoding an application with specific table, column and relationship information, as is the case where SQL is used, the application defines data query requirements in a more abstract fashion that are then bound to a particular physical data representation at runtime. The loose query-data coupling of the present invention enables requesting entities (e.g., applications) to function even if the underlying data representation is modified or if the requesting entity is to be used with a completely new physical data representation than that used when the requesting entity was developed. In the case with a given physical data representation is modified or restructured, the corresponding data repository abstraction is updated to reflect changes made to the underlying physical data model. The same set of logical fields are available for use by queries, and have merely been bound to different entities or locations in physical data model. As a result, requesting entities written to the abstract query interface continue to function unchanged, even though the corresponding physical data model has undergone significant change. In the event a requesting entity is to be used with a completely new physical data representation than that used when the requesting entity was developed, the new physical data model may be implemented using the same technology (e.g., relational database) but following a different strategy for naming and organizing information (e.g., a different schema). The new schema will contain information that may be mapped to the set of logical fields required by the application using simple, filtered and composed field access method techniques. Alternatively, the new physical representation may use an alternate technology for representing similar information (e.g., use of an XML based data repository versus a relational database system). In either case, existing requesting entities written to use the abstract query interface can easily migrate to use the new physical data representation with the provision of an alternate data repository abstraction which maps fields referenced in the query with the location and physical representation in the new physical data model.","In another aspect, the ease-of-use for the application builder and the end-user is facilitated. Use of an abstraction layer to represent logical fields in an underlying data repository enables an application developer to focus on key application data requirements without concern for the details of the underlying data representation. As a result, higher productivity and reduced error rates are achieved during application development. With regard to the end user, the data repository abstraction provides a data filtering mechanism, exposing pertinent data and hiding nonessential content that is not needed by a particular class end-user developing the given query.","It should be noted that any reference herein to particular values, definitions, programming languages and examples is merely for purposes of illustration. Accordingly, the invention is not limited by any particular illustrations and examples. Further, while aspects of the invention are described with reference to SELECTION operations, other input\/output operation are contemplated, including well-known operations such as ADD, MODIFY, INSERT, DELETE and the like. Of course, certain access methods may place restrictions on the type of abstract query functions that can be defined using fields that utilize that particular access method. For example, fields involving composed access methods are not viable targets of MODIFY, INSERT and DELETE.","As noted above, one embodiment provides multiple instances of the data repository abstraction components  which coexist in a single application space. One embodiment illustrating such an environment is shown in FIG. . The environment  generally comprises an application layer  (defined by the application ), a data abstraction layer , and a physical data layer . The environment  shows two users ,  accessing the physical data layer  via the application layer . Accordingly, the users ,  are accessing the same physical data layer  through a common application layer . However, the data being exposed to the respective users ,  is not the same. Rather, each user is exposed to selected portions of the physical data layer  according to the definition of the data abstraction layer . More particularly, the data abstraction layer  illustratively includes two data repository abstraction components, DRA1  and DRA2 , which define the data that will be exposed to the users , , respectively, via the application layer . In the present example, the first data repository abstraction (DRA1 ) exposes all of a first database  (registration database) and TABLE 1 of a second database  (payroll database) while the second data repository abstraction (DRA2 ) exposes all of the second database  and TABLE 1 of the first database . It should be noted that the particular data exposed by the respective data repository abstraction components is merely illustrative. More generally, any portion of the databases , 14 may be exposed, as well as any other databases of the data abstraction layer . By way of illustration the environment  shows two users (, ), however, more generally any number of users may be accessing the data of the physical data layer .","In one embodiment, each user has associated profile  (shown in FIG. ). Each profile includes a user ID and determines a particular user's authority on the system. Further, in some cases a profile is associated with a particular data repository abstraction components . These aspects are illustrated in FIG. . For example, Profile A  and Profile B  are profiles for the first user  and the second user  shown in FIG. . As such, Profile A defines an association with the first data repository abstraction component DRA1  and Profile B  defines an association with the second data repository abstraction component DRA2 . In one embodiment, individual profiles define members of a group. For example, Profile C  and Profile D  are members of a Group A . In some cases, the group itself defines an association with a data repository extraction component. For example, Group A  defines an association with a fourth data repository extraction component, DRA4 . In this way, members of a group inherit a data repository abstraction component from the group definition, rather than through their own respective profiles. However, in one embodiment, members of a group override the data repository abstraction component defined by their group, as is exemplified by Profile C which defines an association to a third data repository abstraction DRA3 .",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 6","b":["518","612","612","518","612","518","518","7"]},{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 7","FIG. 7"],"b":["518","612","518","702","704","612","706","706","518","518","612","612","708","612","704","518","708","612","710","712","518","710","708","704","702","708","712","612","612","716","708","720","720","612","720","612","722","704","518","712","704","710","720","612","716"],"sub":"effective "},"The foregoing describes embodiments in which data repository abstraction components  inherit from one another and may be configured to selectively remove some inherited columns. However, embodiments of the invention are contemplated in which other attributes are used to manipulate aspects of a data repository abstraction component. For example, selected inherited columns of one data repository abstraction component may be modified (e.g., by use of a modify attribute) for use by another data repository abstraction component. By way of example, assume that the gender field B of DRA2  takes as valid values \u201cmale\u201d and \u201cfemale\u201d for purposes of end-user usability, while the underlying physical database supports the values \u201cM\u201d and \u201cF\u201d. Accordingly, the runtime component  (i.e., a query builder of the runtime component ) can take what the DRA  gets as input (\u201cmale\u201d or \u201cfemale\u201d) and build queries consistent with the underlying physical database values (\u201cM\u201d and \u201cF\u201d). Another data repository abstraction component can now be defined to extend DRA  and have a gender column that defines the mapping of values for the gender column as 1 and 0 to accommodate users of another work environment. Again, the runtime component  will take the 1 and 0 and convert them into values consistent with the underlying physical database (i.e., \u201cM\u201d and \u201cF\u201d). In one aspect, this approach merely illustrates that a child data repository abstraction component which defines a value inherited from a parent data repository abstraction component, and for which no remove attribute for that column exists, will use its own implementation over that of its parent.","In one aspect, the foregoing embodiment ensures that users cannot make unilateral decisions based on sensitive information such as ethnic origin or gender. By preventing access to selected information of the physical data layer (either by using the remove attribute in the case of inherited\/referenced categories of a child data repository abstraction or by definition of the non-inherited categories of the data repository abstraction components) undesired issues can be avoided. For example, the user of the second data repository abstraction component  is given access to the ethnic group field C, while the user of the third data repository abstraction component  is not.","Referring now to , a method  is shown illustrating an initial program load of the application . At step , execution of the application  is initiated (e.g., by an administrator). At step , a default data repository abstraction component is loaded. In one embodiment, the default data repository abstraction component is specified by properties file  (shown in ) of the application . Specifying a default data repository abstraction component ensures that a data repository abstraction component is always available even if one is not specified by a profile for a user or a group. Once the default data repository abstraction component is loaded, the associated timestamp for the default data repository abstraction component is loaded (step ). As shown in , each data repository abstraction component  as an associated timestamp . The associated timestamps indicate when the respective data repository abstraction component was last modified. The application  is now ready to begin accepting requests.","When a user connects to the application  (i.e., when the user issues a query to the application), it is necessary to determine which data repository abstraction component is needed for the user. In one embodiment, a level\/status and the time of last modification (according to the associated timestamp) are also determined for each data repository abstraction component loaded for a given user. One embodiment of a method  for handling these aspects is described with reference to FIG. . In one embodiment, the method  is representative of a function of an application programming interface (API) for a data repository abstraction component . Upon issuance of a request to the application , the method  determines (step ) whether the profile for the particular user issuing the request specifies a data repository abstraction component . If so, a level\/status for the specified data repository abstraction component is set equal to \u201cprofile\u201d (step ). The level\/status is any mechanism for tracking now a particular data repository abstraction component was specified. In one embodiment, the level\/status may simply be a variable value. A copy of the specified data repository abstraction component is then loaded (step ) and the associated timestamp of the specified data repository abstraction component is loaded into memory (step ). If the profile for the particular user issuing the request does not specify a data repository abstraction component (step ), the method  determines whether the user is part of a group with an associated data repository abstraction component (step ). If so, the level\/status is set equal to \u201cgroup\u201d (step ). A copy of the specified data repository abstraction component is then loaded (step ) and the associated timestamp of the specified data repository abstraction component is loaded into memory (step ). If the user is not part of a group with an associated data repository abstraction component (step ), the level\/status is set equal to \u201capplication\u201d (step ). A copy of the default data repository abstraction component is then loaded (step ) and the associated timestamp of the default data repository abstraction component is loaded into memory (step ).","In a multi-user environment, the method  will be performed for each user. As a result, numerous instances of data repository abstraction components (some of which may be the same) may exist at any given time. Further, in some cases, a data repository abstraction component  may be changed (e.g., by modifying a file associated with the data repository extraction component), added or removed. The latter events (change, modify and add) may occur whether in a single-user or multi-user environment. For example, in operation, a user may initially be working at the application level\/status (i.e., the user is working with their own copy of the default data repository abstraction component). Assume that the user then modifies their copy of the default data repository abstraction component and associates that copy with their profile . Subsequent requests by that user should now access the data repository abstraction component associated with the user's profile . Accordingly, a mechanism is needed whereby these events are detected and handled appropriately. One such mechanism is illustrated by a method  shown in FIG. . In particular, the method  illustrates an algorithm which may be implemented when a particular data repository abstraction component is accessed. In one embodiment, the method  is representative of a function of an application programming interface (API) for a data repository abstraction component . At step , the level\/status of the data repository abstraction component being accessed is checked. As described above with reference to , the level\/status is one of \u201cuser\u201d, \u201cgroup\u201d and \u201capplication\u201d. If the level\/status is \u201cuser\u201d, the method  determines whether the data repository abstraction component being accessed has changed (step ). This is accomplished by comparing the timestamp of the last modification to the data repository abstraction component being accessed (which was loaded into memory at step  of the method ) with the current timestamp of the data repository abstraction component being accessed. If the data repository abstraction component being accessed has not changed, the access is allowed to proceed (step ). Otherwise, the method  is again performed (step ), after which the access request is re-initiated ().","If the level\/status of the data repository abstraction component being accessed is set to \u201cgroup\u201d (as determined at step ), the presence of a data repository abstraction component at the next highest levels\/statuses (for the present user) are checked (step ). In the present embodiment, only the \u201cuser\u201d level\/status is higher than the \u201cgroup\u201d level\/status. Accordingly, if a user level data repository abstraction component does not exist for the particular user, the method  determines whether the data repository abstraction component being accessed has changed (step ), i.e., by comparison of timestamps as described above. If the data repository abstraction component being accessed has not changed, the access is allowed to proceed (step ). Otherwise, the method  is again performed (step ), after which the access request is re-initiated ().","If the level\/status of the data repository abstraction component being accessed is set to \u201capplication\u201d (as determined at step ), the presence of a data repository abstraction component at the next highest levels\/statuses (for the present user) are checked (step ). In the present embodiment, the \u201cuser\u201d level\/status and the \u201cgroup\u201d level\/status are higher than the \u201capplication\u201d level\/status. Accordingly, the method  first determines whether a user level data repository abstraction component exists (step ) and, if not, then determines whether a group level data repository abstraction component exists (step ). If either a user level or group level data repository abstraction component exists for the present user, processing proceeds to step  where the method  is again performed to determine the appropriate data repository abstraction component to be used, after which the access request is re-initiated (). If neither any user level or group level data repository abstraction component exists for the present user, processing proceeds to step  to determine whether the current application level data repository abstraction component being accessed has changed (step ), i.e., by comparison of timestamps as described above. If the data repository abstraction component being accessed has not changed, the access is allowed to proceed (step ). Otherwise, the method  is again performed (step ), after which the access request is re-initiated ().","Accordingly, aspects of the invention provide a high-level infrastructure (i.e., data repository abstraction components) which isolates the application layer from changes in the data manipulated by the application layer. This infrastructure is also highly configurable, thereby allowing applications to be built iteratively. Further, a given data repository abstraction component is extensible to a plurality of applications, allowing for the building of a family of applications, each reusing the initial investment in the data repository abstraction component. As described with reference to , one embodiment of the invention provides for dynamic instantiation of new data repository abstraction component instances, allowing for on-the-fly changes to be made and for multiple users to dynamically customize their data repository abstraction component. In this manner, users may customize their respective data repository abstraction components according to their particular needs. For example, in a medical environment, cardiologists may require full information about cardiology tests, while neurologists require full information about neurology tests. Applying aspects of the present invention, each user may expose only the information considered relevant to them.","While the foregoing is directed to embodiments of the present invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof, and the scope thereof is determined by the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the present invention are attained and can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to the embodiments thereof which are illustrated in the appended drawings.","It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 2A and 2B"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
