---
title: Method, system, and program for optimizing processing of nested functions
abstract: Disclosed is a method, system, and program for processing a function. A set of nested functions are received. A composite function is generated for the set of nested functions. A tagging template is generated for the set of nested functions that corresponds to the composite function. A result is produced by evaluating the composite function using the tagging template.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07124137&OS=07124137&RS=07124137
owner: International Business Machines Corporation
number: 07124137
owner_city: Armonk
owner_country: US
publication_date: 20021219
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","ADDITIONAL IMPLEMENTATION DETAILS"],"p":["The following are co-pending and commonly owned patent applications:","\u201cSYSTEM AND METHOD OF MAPPING BETWEEN SOFTWARE OBJECTS AND STRUCTURED LANGUAGE ELEMENT BASED DOCUMENTS\u201d, by M. Beisiegal et al., application Ser. No. 2,349,905, filed on Jun. 7, 2001;","\u201cMETHOD FOR PROCESSING A DOCUMENT OBJECT MODEL (DOM) HAVING CUSTOM TAGS\u201d, by C. Claussen et al., application Ser. No. 09\/409,600, filed on Sep. 30, 1999; and","\u201cEXTENSIBLE MARKUP LANGUAGE (XML) SERVER PAGES HAVING CUSTOM DOCUMENT OBJECT MODEL (DOM) TAG\u201d, by C. Claussen et al., application Ser. No. 09\/409,598, filed on Sep. 30, 1999.","1. Field of the Invention","The present invention is related to optimizing processing of nested functions.","2. Description of the Related Art","Relational DataBase Management System (RDBMS) software using a Structured Query Language (SQL) interface is well known in the art. The SQL interface has evolved into a standard language for RDBMS software and has been adopted as such by both the American National Standards Institute (ANSI) and the International Standards Organization (ISO).","The SQL standard introduced a set of new Extensible Markup Language (XML) publishing functions, including scalar functions XMLELEMENT, XMLFOREST, and XMLCONCAT, and an aggregate function, XMLAGG. These functions take SQL data as input and generate XML data as output.","An XMLELEMENT function creates an XML element. In particular, the XMLELEMENT function receives an identifier for use in naming the created XML element, an optional set of attribute name\/value items, and an optional list of values for the content of this element. An XMLELEMENT function returns an instance of type XMLType.","An XMLFOREST function creates a forest of XML elements, which contains an element for each of the XMLFOREST arguments. The XMLFOREST function converts each of its argument parameters to XML, and then returns an XML fragment that is the concatenation of these converted arguments.","An XMLCONCAT function creates a forest of XML elements. The XMLCONCAT function takes as input a series of XML values, concatenates the series of values, and returns the concatenated series.","An XMLAGG function is an aggregate function that produces a forest of XML elements from a collection of XML elements. In particular, the XMLAGG function concatenates XML values from each row in a group into a single XML value.","Additionally, an XMLATTRIBUTES function defines one or more XML attributes for the XML element created by the XMLELEMENT function. Syntactically, XMLELEMENT and XMLATTRIBUTES are also referred to as \u201cspecifications.\u201d","Due to the XML feature of element nesting for parent-child relationships and sequence concatenation, the XMLELEMENT, XMLFOREST, XMLCONCAT, and XMLAGG functions are commonly used in nesting and concatenation. Nested functions are ones in which one or more functions are included within another function. For example, SELECT statement (1) includes nested functions, with the XMLATTRIBUTES function and the XMLFOREST functions nested in the XMLELEMENT function:\n\nSELECT XMLELEMENT (NAME \u201cEmp\u201d, XMLATTRIBUTES (e.fname \u2225\u2018 \u2019\u2225 e.lname AS \u201cname\u201d), XMLFOREST (e.birthday, e.dept AS \u201cdepartment\u201d)) FROM EMPLOYEE e; \u2003\u2003(1)\n","A traditional function evaluation technique for nested functions is to evaluate the functions inside-out. That is, the inner most functions are evaluated first and their results are used as input to the next outer level function, whose outputs are used as input to the next outer level function, etc.","The SELECT statement (1) has the following arguments: fname, lname, birthday, and dept. The XMLATTRIBUTES function has an argument, which is the concatenation of fname and lname. The XMLFOREST function generates a forest of two elements, one for each argument birthday and dept.","Assuming that the following are input values for the arguments of SELECT statement (1): fname =\u2018Jack\u2019, lname =\u2018Lee\u2019, birthday=\u201810-28-1960\u2019, and dept=\u2018shipping\u2019, the evaluation of SELECT statement (1) proceeds as follows. First, the XMLATTRIBUTES function is evaluated and XMLATTRIBUTES(e.fname \u2225\u2018 \u2019\u2225 e.lname AS \u201cname\u201d) evaluates to name=\u201cJack Lee\u201d. Second, the XMLFOREST function is evaluated and XMLFOREST(e.birthday, e.dept AS \u201cdepartment\u201d) evaluates to two elements: <birthday> 1960-10-28<\/birthday><department>shipping<\/department>. The bracketed text (e.g., <birthday>) is a start tag of an element in XML, and the bracketed text with a slash (e.g., <\/birthday>) is an end tag of the element. Third, the XMLELEMENT function is evaluated and XMLELEMENT (NAME \u201cEmp\u201d, XMLATTRIBUTES (e.fname \u2225\u2018 \u2019\u2225 e.lname AS \u201cname\u201d), XMLFOREST (e.birthday, e.dept AS \u201cdepartment\u201d)) evaluates to:\n\n<Emp name=\u201cJack Lee\u201d><birthday>1960-10-28<\/birthday><department>shipping<\/department><\/Emp>\n","In this process, the result of each function is usually copied to generate the next level result. For example, the results of the XMLATTRIBUTES function and the XMLFOREST function are copied to generate the results of the XMLELEMENT function. The number of times data is copied is proportional to the levels of nesting. For example, since there are two levels of nesting, in SELECT statement (1), data is copied twice. Even with the simple example illustrated in SELECT statement (1), copying of data at each of the levels of nesting leads to inefficiency of the function evaluation due to data movement.","Moreover, since XML does not limit the number of levels of nesting, the number of levels of nesting for XML may be very large. Nesting levels of 7\u201314 are commonly seen. The large number of levels of nesting would require a great deal of copying of data, which is very inefficient when evaluating a function. In addition, if character large objects (CLOBs) are involved, the size of copied data is even larger.","Thus there is a need in the art for improved function processing.","Provided are a method, system, and program for processing a function. A set of nested functions is received. A composite function is generated for the set of nested functions. A tagging template is generated for the set of nested functions that corresponds to the composite function. A result is produced by evaluating the composite function using the tagging template.","The described implementations of the invention provide a method, system, and program for processing nested functions using a tagging template to describe the structure of the nesting and an intermediate result structure to store argument input values.","In the following description, reference is made to the accompanying drawings which form a part hereof and which illustrate several implementations of the present invention. It is understood that other implementations may be utilized and structural and operational changes may be made without departing from the scope of the present invention.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 1","b":["100","110","110","100","120"]},"Furthermore, the server  is connected to storage devices , , and each storage device ,  has a device interface , . For example, each storage device  and  may be a redundant array of independent disks (RAID). A RAID device enables storage of the same data on multiple hard disks, thus allowing simultaneous accesses to copies of the data.","The client applications  may access data managed by the server . The server  includes a database engine , which includes a nested function processor . In certain implementations, the database engine  is a DB2\u00ae Universal Database (UDB) for z\/OS, which is available from International Business Machines, Corporation.","In certain implementations, a new composite function  is provided for optimized processing of nested XML functions. The composite function  is generated for the highest level function in the set of nested functions (e.g., an XMLELEMENT function). The input to the composite function  is a list of arguments. When the composite function  is generated for the nested functions in SELECT statement (1), the first argument is a reference to a tagging template  and the remaining arguments are arguments in the nested functions. For example, the list of arguments may represent the arguments of XMLATTRIBUTES and XMLFOREST functions nested within an XMLELEMENT function. In certain implementations, the composite function  takes on the format of XMLCONSTRUCT function (2). The output of the composite function  is an intermediate result structure (e.g., such as the one illustrated in ).\n\nXMLCONSTRUCT (<reference to tagging template>, <list of remaining arguments>)\u2003\u2003(2)\n","In certain implementations, the composite function  is not generated, and, instead, a composite structure  that includes a tagging template  is generated. The composite structure including the tagging template  corresponds to a composite function  and is generated for a set of nested functions. A sample structure of a composite structure  including a tagging template  is illustrated in , which are discussed below. The tagging template  is a structure of nodes for XML elements and XML attributes for the nested functions. It is to be understood that the structure of the composite structure  and the tagging template  may vary from the examples illustrated herein without departing from the scope of the invention.","A tree structure  in a parse tree is generated for a nested function. That is, the nested functions are parsed into a parse tree format. The tree structure  is used to generate the composite function  and the composite structure  that includes a tagging template .","At bind time, the nested functions (e.g., the XMLELEMENT function in SELECT statement (3)) are represented in a tree structure  in a parse tree (i.e., the nested functions are parsed into a parse tree format). Bind time refers to the time during which the functions are processed and an execution plan for executing the function is developed. On the other hand, execution time refers to the time during which the function is evaluated against the argument input values.","The following is a sample SELECT statement (3) with nested functions:\n\nSELECT XMLELEMENT (NAME \u201cEmp\u201d, XMLATTRIBUTES (e.fname \u2225\u2018 \u2019\u2225 e.lname AS \u201cname\u201d), XMLFOREST (e.birthday, e.dept AS \u201cdepartment\u201d)) FROM EMPLOYEE e;\u2003\u2003(3)\n",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 2A","FIG. 2A"],"b":["140","200","140","190"]},"In block , at bind time, the nested function processor  maps the nested functions to a composite function  and generates a composite structure  that includes a tagging template  for the nested functions using the tree structure . The processing for the nested functions at bind time by the composite function  is bottom-up (i.e., the inner most function is evaluated first). To convert the nested functions (e.g., XMLELEMENT, XMLATTRIBUTES, and XMLFOREST) into a single composite function  (e.g., XMLCONSTRUCT), the tree structure  is traversed and processed top-down. Additionally, the tagging template and the list of arguments are built by concatenating the elements from each function that are to be part of the tagging template and the list of arguments.","For example, the nested functions are mapped to an XMLCONSTRUCT function format to generate a composite function. Additionally, the tagging template is used to describe the nesting and concatenation structure. In certain implementations, the generation of the composite function  and the composite structure  that includes the tagging template  occur simultaneously.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 2B","b":["140","190","220","140","190","222","140","224","226","224","140"]},"In block , the nested function processor  determines which type of function has been identified. If the function is an XMLELEMENT function, processing continues to block , and the nested function processor  generates a T_XMLELEMENT node in the tagging template  and processes the list of arguments for the XMLELEMENT function. If the function is an XMLATTRIBUTES function, processing continues to block , and the nested function processor  generates a T_XMLATTRIBUTES node in the tagging template  and processes the list of arguments for the XMLATTRIBUTES function. If the function is an XMLFOREST function, processing continues to block , and, for each argument in the list of arguments of the XMLFOREST function, the nested function processor  generates a T_XMLELEMENT node in the tagging template . If the function is an XMLCONCAT function, processing continues to block , and the nested function processor  processes each argument in the list of arguments of the XMLCONCAT function and concatenates the results of processing the arguments. In particular, for an XMLCONCAT function, the structures and arguments are linked (e.g., in a list or array). Arguments are appended to an argument list in the composite structure . Moreover, each argument in the list of arguments is processed sequentially and recursively to be added to the tagging template  (e.g., by constructing a node representing the argument).","Thus, for each argument of an XMLELEMENT function, if the argument is a constant, the argument is added to the tagging template (referenced from T_XMLELEMENT node). If the argument of the XMLELEMENT function is a SQL expression, the SQL expression is added to the list of arguments of the composite function , and the SQL expression is referenced using its ordinal number (e.g., the second argument in the list of arguments has ordinal number (2)). If the argument of the XMLELEMENT function is a nested function, the function processing of  is recursively called and results in pointing to the resulting nodes in the tagging template .","The XMLATTRIBUTES function is similarly processed, but involves a name and value for each argument.","The optimization technique of implementations of the invention combines nested XML publishing functions into a single composite function such that the input arguments from different levels of the nested XML publishing functions are combined into a single-level list. Certain implementations of the invention use a composite function  as the composite function. For example, for SELECT statement (3), the composite function  generates an XMLCONSTRUCT function (4).\n\nXMLCONSTRUCT (reference_to_tagging_template, e.fname \u2225\u2018 \u2019\u2225 e.lname, e.birthday, e.dept)\u2003\u2003(4)\n","As a result of the mapping to the XMLCONSTRUCT function format, all the nested scalar functions (i.e., XMLELEMENT, XMLATTRIBUTES, and XMLFOREST) become flat without nesting. The result is that the XMLCONSTRUCT function evaluation process avoids unnecessary data movement.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 3","b":["300","300","151","300","150","140","300","300","310","300","150","310","360","370","380"]},"The tagging template  includes a T_XMLELEMENT node , which represents the XMLELEMENT function. For ease of reference, a \u201cT_\u201d prefix will be used to indicate that a node is in a tagging template. The T_XMLELEMENT node  specifies an XML element with a name from the XMLELEMENT function, which in this example is \u201cEmp\u201d . If there are attributes nested within the XMLELEMENT function, the T_XMLELEMENT node  also references one or more XMLATTRUBUTES functions. In this example, the T_XMLELEMENT node  references T_XMLATTRIBUTES node , which in turn references an attribute \u201cName\u201d . In the tagging template, the argument to be used during serialization is marked with a number (e.g., (1), (2), (3) etc. in the tagging template) that corresponds to the ordinal number of arguments that follows the tagging template in the XMLCONSTRUCT structure . The T_XMLELEMENT node  also references the XML elements that are generated for each argument of an XMLFOREST function. In this example, the T_XMLELEMENT node  references T_XMLELEMENT node , which has element name \u201cbirthday\u201d  and content (2), where content (2) corresponds to the value of the second argument from the argument list, and T_XMLELEMENT node , which has element name \u201cdepartment\u201d  and content (3), where content (3) corresponds to the value of the third argument from the argument list.","In certain implementations, the binding of the functions in SELECT statement (3) proceeds as follows. First, any top-level scalar XML function (e.g., XMLELEMENT) becomes an XMLCONSTRUCT function. For example, the XMLELEMENT function in SELECT statement (3) becomes XMLCONSTRUCT function (4). Additionally, a top-level node for the tagging template ) is constructed, which is a T_XMLELEMENT node , with element name \u201cEmp\u201d .","Second, when the XMLATTRIBUTES function is processed in SELECT statement (3), the argument of the XMLATTRIBUTES function is added to the XMLCONSTRUCT function (4) list of arguments and a T_XMLATTRIBUTES node  is constructed in the tagging template . In this case, the name of the single attribute is \u201cname\u201d, and the value of the attribute is the first argument  in the argument list for the XMLCONSTRUCT structure . So, e.fname \u2225\u2018 \u2019\u2225 e.lname is in the argument list of the XMLCONSTRUCT function (4) and the XMLCONSTRUCT structure . In certain implementations, the XMLCONSTRUCT structure  is built, but the XMLCONSTRUCT function (4) is not generated.","Third, when the XMLFOREST function is processed, the XMLFOREST function is converted into a list of XMLELEMENTS, one for each of its arguments. In this example, two T_XMLELEMENT nodes ,  are constructed in the tagging template . In the tagging template , T_XMLELEMENT nodes ,  are connected to the current parent node, which is the top-level T_XMLELEMENT node . Also, two more arguments, e.birthday  and e.dept , are added to the list of arguments for the XMLCONSTRUCT function (4) and the XMLCONSTRUCT structure .",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 2C","FIG. 4"],"b":["140","250","140","150","400","400","150","400","400","402","400","400","402","400","404","408","410","412","414"]},"Alternatively, at the execution time, the nested function processor  can generate a Document Object Model (DOM) tree or other data structures based on the tagging template  and argument input values. A DOM tree is based on a Document Object Model (DOM) recommendation by the World Wide Web Consortium (W3C) for access and representation of XML documents. Other data structures could be based on other standards, such as InfoSet, or XPath and XQuery data models defined by W3C.","In block , the nested function processor  performs serialization to obtain a final result using the intermediate result structure , which references the tagging template  and includes argument input values.","In generating a final result for the XMLCONSTRUCT structure , the nested function processor  traverses the tagging template  and the argument input values of the intermediate structure  to create a serialized text string. This process of traversing the tagging template  and the argument input values and creating a serialized text string is referred to as \u201cserialization.\u201d","During serialization, if a T_XMLELEMENT is encountered, a start tag (starting with <) is generated for the element, and the nested function processor  determines whether there are any attributes for the XML element. If there are one or more T_XMLATTRIBUTES nodes in the tagging template , the attributes are included in the start tag, by traversing the attribute list in the tagging template  to generate an attribute list in the form of: <attribute name>=\u2018<value>\u2019 (e.g., fname=\u2018Jack\u2019, lname=\u2018Lee\u2019). The value is obtained by the nested function processor  from the intermediate structure . If there are no attributes, the nested function processor  ends the start tag with an end tag (>).","If there are additional XMLELEMENT contents to process in the tagging template , they are inserted between the start tag and the end tag of the current XML element. Any nested T_XMLELEMENT or T_XMLATTRIBUTES functions in the tagging template  are traversed and processed in the same manner, recursively. In particular, the nested function processor  again generates tags to indicate the beginning and ending of the XMLELEMENTS and generates attribute lists (if there are attributes) for the XMLELEMENTS.","The result of serialization of the tagging template  is:\n\n<Emp name=\u201cJack Lee\u201d><birthday>1960-10-28<\/birthday><department>shipping<\/department><\/Emp>\n","At execution time, late tagging is used to avoid unnecessary duplicates of serialized text strings. Late tagging refers to evaluating the function without putting tags around the input argument values in the intermediate structure. These tags are added to the final result during serialization.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 5","b":["500","500","151"]},"The XMLCONSTRUCT structure  is generated for the XMLELEMENT function in the set of nested functions (5), which has two attributes, e.id and e.fname \u2225\u2018 \u2019\u2225 e.lname.\n\nXMLELEMENT(NAME \u201cEmp\u201d, XMLATTRIBUTES(e.id as \u201cid\u201d, e.fname \u2225\u2018 \u2019\u2225 e.lname AS \u201cname\u201d), XMLFOREST(e.birthday, e.dept AS \u201cdepartment\u201d))\u2003\u2003(5)\n","XMLCONSTRUCT structure  references T_XMLELEMENT node  in tagging template . The XMLCONSTRUCT structure  also references an argument list identifying arguments to the composite function  and which correspond to the arguments marked with numbers in the tagging template . Since there are multiple attributes, the arguments to the composite function  include both e.id  and e.fname \u2225\u2018 \u2019\u2225 e.lname , as well as, e.birthday  and e.dept .","The T_XMLELEMENT node  references the identifier of the XMLELEMENT, which in this example is \u201cEmp\u201d . In this example, the T_XMLELEMENT node  references T_XMLATTRIBUTES node , which specifies an attribute \u201cID\u201d  and an attribute \u201cName\u201d . The T_XMLELEMENT node  also references the XML elements that are generated for each argument of an XMLFOREST function. In this example, the T_XMLELEMENT node  references T_XMLELEMENT , which has name \u201cbirthday\u201d  and content (3) from the third argument of the argument list, and T_XMLELEMENT , which has name \u201cdepartment\u201d  and content (4) from the fourth argument of the argument list.","In addition, with late tagging, for repetitive tagging patterns of an XMLAGG function, one copy of the tagging template is maintained until a serialized text string is generated for each row on which the XMLAGG function operates. A serialized text string is the output of the composite function .","In particular, for an XMLAGG function, serialization refers to traversing the tagging template  and the intermediate result structure  to build an XML result. Therefore, tagging templates also reduce the size of intermediate results when an XMLAGG function is involved.","For example, if the scalar function in SELECT statement (3) is in turn the argument of the XMLAGG function, then one tagging template may be used (rather than one tagging template for each employee). The following SELECT statement (6) includes an XMLAGG function:\n\nSELECT XMLAGG (XMLELEMENT (NAME \u201cEmp\u201d, XMLATTRIBUTES (e.fname \u2225\u2018 \u2019\u2225 e.lname AS \u201cname\u201d), XMLFOREST (e.birthday, e.dept AS \u201cdepartment\u201d)) FROM EMPLOYEE e;\u2003\u2003(6)\n","For the XMLAGG function in SELECT statement (6), the intermediate result values of the same group are linked together using a doubly-linked list, and they all share the same tagging template.","In summary, implementations of the invention provide a new optimization technique that minimizes data movement and copying when processing XML functions. In particular, implementations of the invention use tagging templates and a late tagging technique.","DB2 is a trademark of International Business Machines Corporation.","The described techniques for maintaining information on network components may be implemented as a method, apparatus or article of manufacture using standard programming and\/or engineering techniques to produce software, firmware, hardware, or any combination thereof. The term \u201carticle of manufacture\u201d as used herein refers to code or logic implemented in hardware logic (e.g., an integrated circuit chip, Programmable Gate Array (PGA), Application Specific Integrated Circuit (ASIC), etc.) or a computer readable medium, such as magnetic storage medium (e.g., hard disk drives, floppy disks, tape, etc.), optical storage (CD-ROMs, optical disks, etc.), volatile and non-volatile memory devices (e.g., EEPROMs, ROMs, PROMs, RAMs, DRAMs, SRAMs, firmware, programmable logic, etc.). Code in the computer readable medium is accessed and executed by a processor. The code in which preferred embodiments are implemented may further be accessible through a transmission media or from a file server over a network. In such cases, the article of manufacture in which the code is implemented may comprise a transmission media, such as a network transmission line, wireless transmission media, signals propagating through space, radio waves, infrared signals, etc. Thus, the \u201carticle of manufacture\u201d may comprise the medium in which the code is embodied. Additionally, the \u201carticle of manufacture\u201d may comprise a combination of hardware and software components in which the code is embodied, processed, and executed. Of course, those skilled in the art will recognize that many modifications may be made to this configuration without departing from the scope of the present invention, and that the article of manufacture may comprise any information bearing medium known in the art.","Although implementations of the invention indicate that the generation of the composite function  and the tagging template  occur simultaneously, in additional implementations, they may be generated in any order. For example, the tagging template  maybe generated before the composite function  or after.","Although implementations of the invention refer to an intermediate result structure as a list or an array, there are many variations for the intermediate result structure. For example, in certain implementations, the intermediate result structure may be a linked list.","The logic of , B, and C describes specific operations occurring in a particular order. In alternative implementations, certain of the logic operations may be performed in a different order, modified or removed. Morever, steps may be added to the above described logic and still conform to the described implementations. Further, operations described herein may occur sequentially or certain operations may be processed in parallel, or operations described as performed by a single process may be performed by distributed processes.","The illustrated logic of , B, and C was described as being implemented in software. The logic may be implemented in hardware or in programmable and non-programmable gate array logic.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 6","b":["100","120","100","120","600","602","604","606","605","604","606","606","604","602","608","610","602","612","602"]},"The computer  may comprise any computing device known in the art, such as a mainframe, server, personal computer, workstation, laptop, handheld computer, telephony device, network appliance, virtualization device, storage controller, etc. Any processor  and operating system  known in the art may be used.","The foregoing description of the preferred implementations of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description, but rather by the claims appended hereto. The above specification, examples and data provide a complete description of the manufacture and use of the composition of the invention. Since many implementations of the invention can be made without departing from the spirit and scope of the invention, the invention resides in the claims hereinafter appended."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Referring now to the drawings in which like reference numbers represent corresponding parts throughout:",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2C"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 6","FIG. 1"]}]},"DETDESC":[{},{}]}
