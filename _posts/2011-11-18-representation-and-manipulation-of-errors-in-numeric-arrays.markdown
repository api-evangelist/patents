---
title: Representation and manipulation of errors in numeric arrays
abstract: In an embodiment, a computer system accesses various different data entries in dense data array, where at least one of those data entries in the dense data array is invalid. The computer system creates an associated sparse data array that includes multiple data entries with zero values as well as data entries with non-zero values. The non-zero data entries are configured to store location information and data values for each of the invalid data entries in the dense array. The zero-value data entries are inferred from the location information of the non-zero data entries. The computer system stores the location information and data values of the non-zero data entries in the sparse data array. Those data values stored in the sparse array are proportional to the number of invalid values in the dense array.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08751877&OS=08751877&RS=08751877
owner: Microsoft Corporation
number: 08751877
owner_city: Redmond
owner_country: US
publication_date: 20111118
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","BRIEF SUMMARY","DETAILED DESCRIPTION"],"p":["Computers have become highly integrated in the workforce, in the home, in mobile devices, and many other places. Computers can process massive amounts of information quickly and efficiently. Software applications designed to run on computer systems allow users to perform a wide variety of functions including business applications, schoolwork, entertainment and more. Software applications are often designed to perform specific tasks, such as word processor applications for drafting documents, or email programs for sending, receiving and organizing email.","In some cases, software applications are designed to work with and perform operations on large amounts of data. For instance, software applications may be designed to perform computational operations on large data arrays. These arrays may include various forms of information stored in different data types. Each portion of information stored in such data arrays is subject to error. For instance, arrays storing information from multiple sources may receive erroneous information from one (or more) of those sources. This erroneous information is stored in the array along with the other correct information. Checking for erroneous values one at a time in these large data arrays can be computationally expensive.","Embodiments described herein are directed to generating a sparse array to represent invalid values in a data array and to creating a view into a larger data array using a sparse data array. In one embodiment, a computer system accesses various different data entries in dense data array, where at least one of those data entries in the dense data array is invalid. The computer system creates an associated sparse data array that includes multiple data entries with zero values as well as data entries with non-zero values. The non-zero data entries are configured to store location information and data values for each of the invalid data entries in the dense array. The zero-value data entries are inferred from the location information of the non-zero data entries. The computer system then stores the location information and data values of the non-zero data entries in the sparse data array. Those data values stored in the sparse data array are proportional to the number of invalid values in the dense data array.","In another embodiment, a computer system creates a view into a larger data array using a sparse data array. The computer system creates a sparse data array that includes multiple data entries with zero values and data entries with non-zero values. The non-zero data entries are configured to store location information and data values for each of the invalid data entries in the dense array. The computer system receives an input from a user selecting a portion of the dense data array and translates the sparse data array to construct a view into the dense data array. The translation preserves the ordering of the sparse data array so that iterating over the data entries of the constructed view is equivalent to iterating over the original data entries of the dense data array.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter.","Additional features and advantages will be set forth in the description which follows, and in part will be apparent to one of ordinary skill in the art from the description, or may be learned by the practice of the teachings herein. Features and advantages of embodiments of the invention may be realized and obtained by means of the instruments and combinations particularly pointed out in the appended claims. Features of the embodiments of the present invention will become more fully apparent from the following description and appended claims, or may be learned by the practice of the invention as set forth hereinafter.","Embodiments described herein are directed to generating a sparse array to represent invalid values in a data array and to creating a view into a larger data array using a sparse data array. In one embodiment, a computer system accesses various different data entries in dense data array, where at least one of those data entries in the dense data array is invalid. The computer system creates an associated sparse data array that includes multiple data entries with zero values as well as data entries with non-zero values. The non-zero data entries are configured to store location information and data values for each of the invalid data entries in the dense array. The zero-value data entries are inferred from the location information of the non-zero data entries. The computer system then stores the location information and data values of the non-zero data entries in the sparse data array. Those data values stored in the sparse data array are proportional to the number of invalid values in the dense data array.","In another embodiment, a computer system creates a view into a larger data array using a sparse data array. The computer system creates a sparse data array that includes multiple data entries with zero values and data entries with non-zero values. The non-zero data entries are configured to store location information and data values for each of the invalid data entries in the dense array. The computer system receives an input from a user selecting a portion of the dense data array and translates the sparse data array to construct a view into the dense data array. The translation preserves the ordering of the sparse data array so that iterating over the data entries of the constructed view is equivalent to iterating over the original data entries of the dense data array.","The following discussion now refers to a number of methods and method acts that may be performed. It should be noted, that although the method acts may be discussed in a certain order or illustrated in a flow chart as occurring in a particular order, no particular ordering is necessarily required unless specifically stated, or required because an act is dependent on another act being completed prior to the act being performed.","Embodiments of the present invention may comprise or utilize a special purpose or general-purpose computer including computer hardware, such as, for example, one or more processors and system memory, as discussed in greater detail below. Embodiments within the scope of the present invention also include physical and other computer-readable media for carrying or storing computer-executable instructions and\/or data structures. Such computer-readable media can be any available media that can be accessed by a general purpose or special purpose computer system. Computer-readable media that store computer-executable instructions in the form of data are computer storage media. Computer-readable media that carry computer-executable instructions are transmission media. Thus, by way of example, and not limitation, embodiments of the invention can comprise at least two distinctly different kinds of computer-readable media: computer storage media and transmission media.","Computer storage media includes RAM, ROM, EEPROM, CD-ROM, solid state drives (SSDs) that are based on RAM, Flash memory, phase-change memory (PCM), or other types of memory, or other optical disk storage, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store desired program code means in the form of computer-executable instructions, data or data structures and which can be accessed by a general purpose or special purpose computer.","A \u201cnetwork\u201d is defined as one or more data links and\/or data switches that enable the transport of electronic data between computer systems and\/or modules and\/or other electronic devices. When information is transferred or provided over a network (either hardwired, wireless, or a combination of hardwired or wireless) to a computer, the computer properly views the connection as a transmission medium. Transmissions media can include a network which can be used to carry data or desired program code means in the form of computer-executable instructions or in the form of data structures and which can be accessed by a general purpose or special purpose computer. Combinations of the above should also be included within the scope of computer-readable media.","Further, upon reaching various computer system components, program code means in the form of computer-executable instructions or data structures can be transferred automatically from transmission media to computer storage media (or vice versa). For example, computer-executable instructions or data structures received over a network or data link can be buffered in RAM within a network interface module (e.g., a network interface card or \u201cNIC\u201d), and then eventually transferred to computer system RAM and\/or to less volatile computer storage media at a computer system. Thus, it should be understood that computer storage media can be included in computer system components that also (or even primarily) utilize transmission media.","Computer-executable (or computer-interpretable) instructions comprise, for example, instructions which cause a general purpose computer, special purpose computer, or special purpose processing device to perform a certain function or group of functions. The computer executable instructions may be, for example, binaries, intermediate format instructions such as assembly language, or even source code. Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the described features or acts described above. Rather, the described features and acts are disclosed as example forms of implementing the claims.","Those skilled in the art will appreciate that the invention may be practiced in network computing environments with many types of computer system configurations, including personal computers, desktop computers, laptop computers, message processors, hand-held devices, multi-processor systems, microprocessor-based or programmable consumer electronics, network PCs, minicomputers, mainframe computers, mobile telephones, PDAs, pagers, routers, switches, and the like. The invention may also be practiced in distributed system environments where local and remote computer systems that are linked (either by hardwired data links, wireless data links, or by a combination of hardwired and wireless data links) through a network, each perform tasks (e.g. cloud computing, cloud services and the like). In a distributed system environment, program modules may be located in both local and remote memory storage devices.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1","b":["100","100","101","101","110","134","131","101","130"]},"The dense data array itself may be stored in a plurality of different locations, or in a single location (as illustrated in ). The dense data array  may include a large amount of data stored in array or matrix form. As such, the data is stored in rows and columns. The data may be operated on individually or as a whole. The dense data array includes various types of data entries including entries that are valid () and entries that are invalid (). The invalid entries may be missing entries or erroneous entries. The errors may come as the result of a malfunctioning sensor or due to some other irregularity or failure in how the data is captured and stored in the array. The invalid entries may constitute a small amount of the data entries in the data array. In most cases, the number of valid data entries will greatly exceed the number of invalid data entries.","In some embodiments, the coordinate (e.g. row-and-column) location of these invalid data entries may be stored in a separate data array. Sparse data array creating module  may create a sparse data array  that is configured to store the locations of the invalid data entries. Sparse data arrays, as defined herein, are arrays where the majority of the entries have values of zero. For instance, in one example, a dense array of 1000\u00d71000 may have only 100 non-zero values. These non-zero values (or at least the location information for these values) are stored in the sparse data array . Accordingly, the sparse data array includes data entries with zero values , data entries with non-zero values  and location information  for those data entries with non-zero values.","In some embodiments, a dense multi-dimensional array A may be represented using two components: a one-dimensional data vector D consisting of all the values in the array, and a pair of one-dimensional vectors I and X of length Nwhere Nis the number of invalid entries in the array that indicate respectively the location and values of the invalid entries in the array. The one-dimensional vectors I and X comprise the \u201csparse data array\u201d in A.","The array A can be a view into a larger array A\u2032. In some cases, the process of creating views may involve reordering the elements in the sparse data array to account for views with negative strides into the original array. (As used herein, the stride refers to the combined number of data blocks in a range-partitioned flattened representation of the array that appear consecutively in multiple locales). The sparse data array for the view may be created in such a way that iterating over the view linearly involves linear iteration over the elements of the sparse data array. For example, if I(1) is the index into D of the first error value in A, then I(2) is the index of the second error value, even if A is a view into a larger array, A\u2032 with negative strides.","In many cases and for many applications, algorithms for operating on sparse data arrays (or sparse vectors) can be directly translated into algorithms for creating a sparse data array for an output array as a result of an operation on arrays with sparse data arrays. For example, adding two arrays A and B with sparse data arrays may be performed using a dense addition step consisting of the values in Dand D, followed by a sparse addition step that operates only on the entries in I,Xand I,X. Theoretical results governing the upper-bound on the number of non-zero entries in a sparse matrix operation may directly translate into the number of error values in the result of an operation of two arrays with sparse data arrays.","In some embodiments, the following assumptions may be taken into account: 1) sparse data arrays are read more often than they are written to (which is very similar to the set of assumptions made when creating certain compressed data structures to represent sparse matrices). Therefore, mutating a sparse data array is substantially more expensive than iterating over it. 2) sparse data arrays are optimized for linearly iterating over the elements of an array, irrespective of its dimensionality. Thus, random access through a sparse data array is at best O(lgN) and at worst O(N) o(N) when an array is a view with negative strides into a contiguous array.","The dense array for an array A with N dimensions may include three fields: a vector S of length N containing the shape along each dimension, a vector S\u2032 of length N+1 containing the stride along each dimension and a vector D containing the data for the array stored in column major order. It should be noted that the stride vector S\u2032 can be signed to account for cases where an array is traversed in reverse order along a particular dimension.","The data vector has at least",{"@attributes":{"id":"p-0031","num":"0030"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"munderover":{"mo":"\u220f","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"N"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["S","t"]}}}},"br":{}},"The implementation of sparse data arrays for dense arrays augments the aforementioned array data structure with two arrays of length N: a vector I includes the locations in D which are interpreted as error values, and a vector X that contains the actual error value at that location. The actual value (be it a valid value or an error) at a given linear offset i is given by: \u03bd=X[\u03b5] if I[E]=i else D[i].","In some embodiments, a sparse data array may be created using the following steps: first, the components I and X are created incrementally using a concurrent appendable data structure. Once the entries are created, the sparse data array is \u201ccommitted\u201d by traversing the elements of the underlying concurrent collection, sorting the entries in I in ascending order and creating the final I and X vectors. The process of incrementally creating and committing the sparse data array is abstracted into a data structure configured to store errors that exposes the incremental construction operations via application programming interfaces (APIs). Once the I and X vectors are created, they are attached to an existing dense array instance and replace any existing sparse data arrays for the dense array.","Note that, at least in some cases, the vectors are kept distinct (as opposed to having a single vector consisting of an index-value pair) to permit basic symbolic analysis to be performed on the locations in the array containing error values (for instance, replacing them with a canonical valid value, or for a multi-dimensional array, finding a pattern of distribution of invalid values, etc.) without necessarily iterating over the errors themselves. An alternate implementation may fuse together both the position and the value of the error into one element of the sparse data array .","One operation that may be performed on an array with a sparse data array is the construction of a view into it. A view A\u2032 into an array A is constructed whenever A is indexed using a regular indexing expression of the form A(R, R, . . . , R) where each range expression Rcan be compactly represented by a triplet of start, end and skip values, respectively, (I,J,K), i=1, 2, . . . , N. The start and end indices satisfy the following constraints: 0\u2266I<S[i] and 0\u2266J\u2266S[i]. The skip value Kcan have any non-zero integral value, but (at least in some cases) defaults to 1. The length of each element in the expression is given by",{"@attributes":{"id":"p-0036","num":"0035"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["L","i"]},"mo":"=","mrow":{"mrow":{"mo":["\u2308","\u2309"],"mfrac":{"mrow":{"msub":[{"mi":["J","i"]},{"mi":["I","i"]}],"mo":"-"},"msub":{"mi":["K","i"]}}},"mo":"."}}}},"br":{},"sub":["1","2","N","B","1","2","N","B","1","A","2","A","N","A"]},{"@attributes":{"id":"p-0037","num":"0036"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["\u03b4","B"]},"mo":"=","mrow":{"msub":{"mi":["\u03b4","A"]},"mo":"+","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"N"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":{"mi":["I","i"]},"mo":"\u00d7","mrow":{"mrow":{"msubsup":{"mi":["S","A","\u2032"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"i"}},"mo":"."}}}}}}}},"When constructing a view of an array with a sparse data array configured to store errors, the following additional steps may be performed: 1) find the set of indices in Ithat also belong to B under the indexing operation. This may be accomplished by decomposing each index \u03b5 in Iinto its constituent coordinates, (\u03b5, \u03b5, . . . , \u03b5) and checking if each coordinate lies in the window defined by [I,J]) with a skip of K. 2) Offset the list of error indices Iusing the offset \u03b4computed above, and 3) sort the list of indices in Isuch that if two indices \u03b5 and \u03b5\u2032 are carried over from Ito I, they are ordered according to the dimension such that if \u03b5 occurs ahead of \u03b5\u2032 in I, it occurs ahead of \u03b5\u2032 in Iif and only if K>0, i=1, 2, . . . N. In some embodiments, the dimension sorting step is required to ensure that iterating linearly over the elements of B only requires incrementing the offsets in the sparse data array vectors Iand X. These concepts will be explained further below with regard to methods  and  of , respectively.","In view of the systems and architectures described above, methodologies that may be implemented in accordance with the disclosed subject matter will be better appreciated with reference to the flow charts of . For purposes of simplicity of explanation, the methodologies are shown and described as a series of blocks. However, it should be understood and appreciated that the claimed subject matter is not limited by the order of the blocks, as some blocks may occur in different orders and\/or concurrently with other blocks from what is depicted and described herein. Moreover, not all illustrated blocks may be required to implement the methodologies described hereinafter.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 2","b":["200","200","100"]},"Method  includes an act of accessing one or more data entries in dense data array, wherein at least one of the data entries in the dense data array is invalid (act ). For example, data accessing module  may access data  which includes valid data entries  and invalid data entries  from dense data array . The dense data array is stored in data store , which may be a local or distributed storage system. The data of the dense array includes both valid and invalid data entries. The invalid data entries may be erroneous values, missing values or otherwise anomalous data values.","Method  also includes an act of creating an associated sparse data array that includes a plurality of data entries with zero values and data entries with non-zero values, wherein the non-zero data entries are configured to store location information and data values for each of the invalid data entries in the dense array, and wherein the zero-value data entries are inferred from the location information of the non-zero data entries (act ). For example, sparse data array creating module  may generate sparse data array  which includes data entries with zero values , as well as data entries with non-zero values. The non-zero data entries store location information and\/or data values for each data invalid data entry in the dense data array. The data entries with zero-values  are shown in dotted line form as they are not explicitly stored (at least in some cases). These values are inferred from (and indeed comprise) every space in the array not occupied by a non-zero value. Accordingly, if the non-zero value data entries are known, the zero value entries are also known (or are at least inferable from the location information of the non-zero values).","In some cases, the locations of invalid data entries  are stored in a flattened representation of the array. In such cases, the sparse data array is one-dimensional and is independent of the number of dimensions of the original array. The sparse data array  may include multiple one-dimensional vectors of length N, where Nis the number of invalid data entries in the dense data array. The one-dimensional vectors indicate the location and values of the invalid data entries in the dense data array. As explained above, the one-dimensional vectors may be kept distinct to allow symbolic analysis to be performed on the locations in the array that include invalid data entries. The symbolic analysis may include replacing the invalid data entries with one or more canonical valid values. Additionally or alternatively, the symbolic analysis may include finding a pattern of distribution of invalid data entries in a multi-dimensional data array. Such a pattern of invalid data entries may be found when a sensor has gone bad and is providing erroneous inputs, or when other invalid data is being provided to the dense array. Other patterns may be found when data entries have been deleted or are otherwise missing. It should be noted that the symbolic analysis may be performed without iterating over the invalid data entries themselves.","Method  next includes an act of storing the location information and data values of the non-zero data entries in the sparse data array, wherein the data values stored in the sparse data array are proportional to the number of invalid values in the dense data array (act ). Location information  and data values may be stored for each non-zero data entry  in the sparse data array . The data values stored in the sparse array are proportional to the number of invalid data entries  in the dense data array .","Various different operations may be performed on the non-zero data entries . The number of these operations may be reduced to the number of non-zero entries. In addition to these operations, statistics may be provided indicating where in the dense data array the invalid data entries are located. For example, the statistics may indicate a particular row or column in which a certain number of invalid data entries occurs. Additionally or alternatively, the statistics may indicate clusters or other patterns of invalid data entries. Still further, the sparse data array may be scanned and any invalid data values may be replaced with valid data values at the locations specified in the sparse data array. This is referred to herein as substitution data filtering.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 3","FIGS. 4A-4D"],"b":["300","300","100"]},"Method  includes an act of creating a sparse data array that includes a plurality of data entries with zero values and data entries with non-zero values, wherein the non-zero data entries are configured to store location information and data values for each of the invalid data entries in the dense array (act ). For example, sparse data array creating module  may create sparse data array . The sparse data array includes data entries with zero values and data entries with non-zero values. As explained above, the non-zero data entries store location information for each of the invalid data entries  of dense data array . In some cases, multiple processing threads may be implemented by the sparse data array creation module to construct the sparse data array in parallel. Once all of the processing threads are complete, the processes will commit and the array will be fully constructed.","The dense data array  may be stored as a long contiguous set of data in a flat data representation. As such, the indices in the sparse data array correspond to locations of invalid data entries in the flat data representation. It should be noted that the data entries in the sparse data array are independent of the number of dimension in the dense data array. The data entries only depend on how many elements the array has and how many values are actually considered to be erroneous or missing values.","The computer system  may receive an input  from user  selecting a portion of the dense data array  (act ). The computer system may then translate the sparse data array to construct a view into the dense data array (act ). It should be noted that, at least in some case, act  may be split into two different acts ( and ) where the translation occurs substantially in act , while the construction of the view occurs substantially in act . Translation of the sparse data array preserves its ordering, such that iterating over the data entries of the constructed view is equivalent to iterating over the original data entries of the dense data array. Examples of views created by translation are shown in .","For instance,  shows the construction of sparse data arrays for views into Array A. This example array includes error values, which are circled for easy identification. In this case, the side structure I for array A (I) would include values 1, 3, 5, 6, 9, 11, 13, 14, 16 and 19. These are the linear locations in memory that contain error values. As shown in , a 3\u00d73 view into array A may include the values shown in array B, where the side structure of array B (I) includes error values 1, 5, 6 and 9. An alternative view may be created into array A, as shown in . In , the view includes values from array A taken from rows 2 and 4, columns 1, 3 and 5. The resulting view for the sparse data structure includes values 1, 3, 9, 11, 17 and 19, where values 1, 3, 9, 11 and 19 are erroneous values.  illustrates another view into array A which is 3\u00d73, but is the inverse of the view created in . Index AB illustrates the linear offsets into Dafter offsetting, as explained above. The sparse array for this view would thus include values 1, \u22123, \u22122 and \u22127 (see Iin ).","Accordingly, methods, systems and computer program products are provided which generate a sparse array to represent invalid values in a data array. Moreover, methods, systems and computer program products are provided which creates a view into a larger data array using a sparse data array.","The present invention may be embodied in other specific forms without departing from its spirit or essential characteristics. The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is, therefore, indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["To further clarify the above and other advantages and features of embodiments of the present invention, a more particular description of embodiments of the present invention will be rendered by reference to the appended drawings. It is appreciated that these drawings depict only typical embodiments of the invention and are therefore not to be considered limiting of its scope. The embodiments of the invention will be described and explained with additional specificity and detail through the use of the accompanying drawings in which:",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 4A-4D"}]},"DETDESC":[{},{}]}
