---
title: Automatic source code generation for computing probabilities of variables in belief networks
abstract: A system for computing probabilities of variables in a belief network includes a data acquisition interface configured to receive data representative of the belief network. The system further includes a partial evaluator configured to carry out a partial evaluation algorithm that determines the probability calculations that must be performed on the received data in order to compute the probabilities of the variables in the belief network. The system further includes a source code generator configured to output the probability calculations as a source code in a programming language.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08510246&OS=08510246&RS=08510246
owner: Charles River Analytics, Inc.
number: 08510246
owner_city: Cambridge
owner_country: US
publication_date: 20110615
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present application is a continuation of application Ser. No. 11\/380,784, filed Apr. 28, 2006 which claims priority under 35 U.S.C. \u00a7119(e) to U.S. provisional patent application Ser. No. 60\/676,637, filed Apr. 29, 2005.","Computerized data models that can predict future data and\/or explain past data are helpful in solving real-world problems. These models are especially useful for large and complex data that are difficult for humans to effectively understand. One data modeling technique is probabilistic modeling. Probabilistic modeling provides mathematically rigorous methods for handling uncertainty when modeling a problem domain. Probabilistic modeling has an extremely wide range of applications, including medical diagnoses, bioinformatics, computer vision, signal processing, control systems, cognitive science, and financial modeling.","One probabilistic data modeling technique is Bayesian networks (BN), also known as belief networks, Bayesian belief networks, probabilistic networks, or directed graphical models. A BN consists of nodes connected by directed edges. Each node represents a particular random variable having some number of states. Each edge is directed from a parent node to a child node and represents the causal influence of the parent node on the child node. Each node in a BN has a conditional probability distribution (CPD) associated with it that describes the causal influences of its parents. Bayesian networks are generally used to compute the probabilities that certain events will occur, possibly given the fact that certain other events have already occurred.","Current inference engines that are used to compute probabilities in BNs may have an inherent overhead, because they are written as generic algorithms in high-level programming languages. Further, current inference engines used to compute probabilities in BNs is that they are written by hand by computer programmers in a specific programming language. To use the inference engine in a different programming language, the inference engine may either have to be re-written in the other language or some sort of inter-language communication protocol may have to be used. It may be time-consuming and error-prone to rewrite a complex algorithm such as a BN inference engine in a different programming language. Inter-language communication protocols may have their own overhead and may often be difficult to use effectively. In some cases, an inter-language communication protocol may not even exist for certain programming languages.","A method and system for computing probabilities in BNs without incurring the overhead described above, and without being restricted to a specific programming language, are highly desirable.","A system for computing probabilities of variables in a belief network includes a data acquisition interface configured to receive data representative of the belief network. The system further includes a partial evaluator configured to carry out a partial evaluation algorithm that determines the probability calculations that must be performed on the received data in order to compute the probabilities of the variables in the belief network. The system further includes a source code generator configured to output the probability calculations as a source code in a programming language.","A method of computing probabilities of variables in a belief network includes receiving data representative of the belief network. The method further includes carrying out a partial evaluation algorithm that determines the probability calculations that must be performed on the received data in order to compute the probabilities of the variables in the belief network. The method further includes outputting the probability calculations as a source code in a programming language.","A method and system is described for computing probabilities of variables in a belief network. Partial evaluation is used to determine the calculations necessary to generate the desired probabilities. Through partial evaluation, a modified version of a standard inference algorithm is performed, on the specific Bayesian network for whose nodes the probabilities are being sought. In this way, overhead found in generic inference engines is considerably reduced. Automatic source code generation is performed to output the necessary calculations as a source code. In other words, the necessary calculations are written down and stored in a computer memory, rather than actually being performed.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1","b":["100","120","130","130","120"]},"A BN consists of nodes connected by directed edges. Each node represents a particular random variable having some number of states. Both discrete nodes, which have a finite number of states, and continuous nodes, which have an infinite number of states, can exist in a BN. Each edge is directed from a parent node to a child node and represents the causal influence of the parent node on the child node. Each node in a BN has a conditional probability distribution (CPD) associated with it that describes the causal influences of its parents.","A CPD includes the probability of the node's variable being in a particular state as a function of the states of its parent nodes. There are no restrictions on the types of conditional probability distributions used and each node in the BN can use a different CPD. The CPD for node Child that has n parent nodes Parent, Parent, . . . , Parent, is represented by P(Child|Parent, Parent, . . . , Parent), which specifies the conditional probability distribution for Child given the values of all the parent variables.","Bayesian networks are generally used to compute the probabilities that certain events will occur, possibly given the fact that certain other events have already occurred. The BN represents the joint probability distribution of all of its nodes (or variables). If a BN has the nodes X={X, X, . . . , X,} the BN represents the joint distribution P(X, X, . . . , X)=P(X).","Given a joint distribution, obtaining the probability of a subset of the nodes in the distribution is straightforward using statistical techniques. For example, given two disjoint subsets of the nodes X, XX and XX such that X\u2229X=\u00f8, the joint distribution of the nodes in X, is obtained by marginalizing out the variables not in X, represented by",{"@attributes":{"id":"p-0020","num":"0019"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":"X","mn":"1"}}},{"munderover":{"mo":"\u2211","mrow":{"mrow":{"mi":["x","x"],"mo":"\/"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mo":"\u2062","mrow":{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"X"}}}],"mo":"="},"mo":","}}},"br":{},"sub":"2"},{"@attributes":{"id":"p-0021","num":"0020"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":"X","mn":"2"}}},{"munderover":{"mo":"\u2211","mrow":{"mrow":{"mi":["x","x"],"mo":"\/"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mo":"\u2062","mrow":{"mrow":{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"X"}},"mo":"."}}],"mo":"="}}},"br":{},"sub":["1","2","1 ","2 ","2"]},{"@attributes":{"id":"p-0022","num":"0021"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"P","mo":["(",")"],"mrow":{"msub":[{"mi":"X","mn":"1"},{"mi":"X","mn":"2"}],"mo":"\u2758"}},{"mfrac":{"mrow":[{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":"X","mn":"1"},{"mi":"X","mn":"2"}],"mo":","}}},{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":"X","mn":"2"}}}]},"mo":"."}],"mo":"="}}},"br":{},"sub":["1 ","2 "]},{"@attributes":{"id":"p-0023","num":"0022"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":"X","mn":"1"},{"mi":"X","mn":"2"}],"mo":","}}},{"munder":{"mo":"\u2211","mrow":{"mi":"X","mo":"\/","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}],"mo":","}}}},"mo":"\u2062","mrow":{"mrow":{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"X"}},"mo":"\/"}}],"mo":"="}}}},"The conditional probability of one xi{x,x,} subset of nodes, given another subset of nodes, is thus obtained by dividing the joint probability of those two subsets by the probability of the second subset. The probabilities of interest to be computed for a BN fall into these two categories: 1) the probability of a subset of nodes in the BN, and 2) the conditional probability of one subset of nodes given another subset of nodes in the BN.","The most common probabilities obtained from a BN are called beliefs. Beliefs are the probability distribution of a single node, possibly given the values of some other nodes. Beliefs without values of other nodes are called prior beliefs. Prior beliefs for the node X are represented as P(X). Beliefs given values of other nodes are called posterior beliefs. Posterior beliefs for the node X are represented as P(X|e). The values of other nodes are called evidence and represented by e.","Other probabilities are also useful. As one example, the joint probability of a node Q and a node F,P(Q,F\\e), is used in the calculation of mutual information. As another example, the joint probability of a node X and its parents, P(X,parents(X)), is used when learning the CPD of X from data. The present disclosure covers all probabilities that can be computed for a BN and is not limited to any specific type of probability.","The probabilities for the nodes in the BN are calculated using the CPDs and the evidence. A separate inference engine (IE) may typically be used to do these calculations. Many different IEs have been developed and used. Typically, an IE may be built from a particular BN and may then be used to compute probabilities using any evidence. The CPDs and evidence are inputs to the IE, and probabilities are the outputs. But only the evidence, not the CPD, can change at run-time. If the CPD of any node in the BN changes in any way the IE must be built again before probabilities can be calculated again.","The evidence e specifies the events that have already occurred. In particular, the evidence provides a real number between zero and one (inclusive) for each state of each node that represents an event that has already occurred. These numbers represent the independent likelihood of the states for each observed node. In a typical BN, observations are obtained for some variables in the BN, and probabilities are then calculated for other nodes. Either the human operator or the computer then uses these probabilities to make decisions.","Current inference engines used to compute probabilities in BNs are written as generic algorithms in high-level programming languages, and thus have an inherent overhead. Each algorithm can compute the probabilities of any BN. Typically, significant overhead can be introduced into general-purpose algorithms that are useful to solve a wide range of problems, the overhead not being necessary to solve a specific problem relating to a particular input.","The inference engines used to compute probabilities for a BN tend to be generic algorithms that can compute the probabilities for any BN. Generic algorithms such as these may be very useful, since a single algorithm can be used to solve a wide class of problems, as opposed to a problem-specific algorithm that can only be used to solve a special type of problem. Generic algorithms may suffer from performance overhead, however, since they need to compute, at run-time, those computations that are necessary to perform the specific problem being solved. Generic BN inference engines may also have to compute, at run-time, those computations that are necessary to perform to calculate probabilities for the specific BN they are currently working with. This adds to the overhead.","A BN is a representational model (RM). It represents, or models, some domain of interest. However, in practice, computations are not performed on the actual BN. The BN first must be converted to a computational model (CM) and then an inference engine (IE) uses the CM to calculate beliefs. Many different types of IEs use the CPDs and evidence of the BN to compute beliefs. Different IEs may use different types of CMs and different algorithms for operating on the CM to compute the beliefs.","When a modification is made to the BN that affects a CPD, the CM must be reconstructed. The IE may use this new CM to calculate beliefs. Reconstructing the CM can also be described as rebuilding the IE. When a modification is made to the BN that affects evidence, the CM typically does not need to be reconstructed. The IE just needs to incorporate the new evidence and recalculate beliefs.","Junction Tree (JT) inference engines are one of the most popular inference engines for computing probabilities. A JT is a tree constructed from the BN in which each vertex is a set of nodes from the BN that form a clique, and each vertex in the JT on the path from vertex i to vertex j contains the intersection of the nodes of vertices i and j. The vertices of a JT may be referred to as cliques, and the edges of a JT may be called separators.","One example of a JT inference engine is the Hugin JT inference engine. In the Hugin JT inference engine, each clique i has an object \u03a6, called a potential, associated with it. Each separator connecting cliques i and j also has a potential \u03a6. Initially \u03a6is the product of all CPTs and evidence potentials assigned to clique i and \u03a6consists of all ones. A clique is chosen to be the root of the tree, and then messages are passed in two phases: from the leaves of the tree towards the root and then from the root towards the leaves. After all messages have been passed, beliefs are calculated from the clique potentials.","Each message from clique i to clique j causes the separator potential \u03a6the clique potential \u03a6to be updated as follows:",{"@attributes":{"id":"p-0036","num":"0035"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"mrow":{"mn":"1.","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msubsup":{"mi":["\u03a6","ij","old"]}},"mo":"=","msub":{"mi":["\u03a6","ij"]}}},{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}]},{"mtd":[{"mrow":{"mrow":[{"mn":"2.","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["\u03a6","ij"]}},{"munderover":{"mo":"\u2211","mrow":{"mi":["C","\\","S"],"mo":["\u2062","\u2062"]},"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mo":"\u2062","msub":{"mi":["\u03a6","i"]}}],"mo":"="}},{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}]},{"mtd":[{"mrow":{"mrow":{"mn":"3.","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["M","ij"]}},"mo":"=","mfrac":{"msub":{"mi":["\u03a6","ij"]},"msubsup":{"mi":["\u03a6","ij","old"]}}}},{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}]},{"mtd":[{"mrow":{"mrow":[{"mn":"4.","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["\u03a6","j"]}},{"msub":[{"mi":["\u03a6","j"]},{"mi":["M","ij"]}],"mo":"\u2062"}],"mo":"="}},{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}]}]}}}},"In the above equations, C is the set of nodes assigned to clique i and S is the set of nodes assigned to separator (i,j). After the two phases of message-passing in the JT each clique potential represents the joint probability of the nodes assigned to it and the evidence: \u03a6=P(C,e). Thus, beliefs for node X\u03b5C are calculated by marginalizing the other nodes out of the clique potential \u03a6and then normalizing:",{"@attributes":{"id":"p-0038","num":"0037"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"P","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["X","\\","e"],"mo":["\u2062","\u2062"]}}},{"mi":"\u03b1","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"munder":{"mo":"\u2211","mrow":{"mi":["C","\\"],"mo":["\u2062","\u2062"],"mrow":{"mo":["{","}"],"mi":"X"}}},"mo":"\u2062","mrow":{"msub":{"mi":["\u03a6","i"]},"mo":"."}}}],"mo":"="}}}},"The above algorithm requires the definition of multiplication, division, and marginalization of potentials. These three operations create a new potential from the original potential(s) obtained by multiplying, dividing, or adding, respectively, elements of the original potential(s).","The above algorithm as described, and implemented in current JT-based inference engines, works with any JT and any potentials. When a message is being passed from clique i to clique j, the algorithm incurs several types of overhead:\n\n","The JT-based inference engine also incurs overhead by keeping the JT and related data structures in memory, computing which cliques to send messages to, initialization of the clique potentials, marginalization of clique potentials to compute beliefs, etc. This overhead means slower execution time and increased memory usage for calculating beliefs.","Another type of inference engine, called AMG, avoids much of the overhead of JT-based inference engines by representing all of the multiplications and additions in an Add-Multiply Graph (AMG) (also called an Arithmetic Circuit). The AMG is constructed from the JT by starting at the root clique and going towards the leaves of the JT, adding addition and multiplication operations to the AMG corresponding to the configurations of clique and separator nodes that are added and multiplied during the JT inference algorithm. Thus, the AMG represents explicitly which elements of the clique and separator potentials to add and multiply, reducing much of the overhead inherent in the JT-based inference engine.","The AMG-based inference engine also has its own overhead, however, including storing the AMG data structure and traversing through the AMG to calculate beliefs.","In one embodiment of the present disclosure, the overhead described above may be avoided by using the technique of partial evaluation or specialization. Many computer programs are currently written in a very generic way in a high-level language, including but not limited to C++, Java, and Lisp. In this way, they can be used on any input data and be developed fairly quickly. There are performance costs associated with a generic computer program written in a high-level language. These costs include maintaining abstraction mechanisms, dynamic memory allocation, and object-method dispatching.","Partial evaluation transforms a general-purpose algorithm that will work with any input data into a specialized algorithm that works only with some specific input data. By working with specific input data, many of the performance penalties of the generic algorithm can be removed. As one example, a generic function may compute the inner product of two vectors. The inner product of two vectors vand vis defined as:",{"@attributes":{"id":"p-0046","num":"0049"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":[{"mi":"v","mn":"1"},{"mi":"v","mn":"2"}],"mo":"\u00b7"},{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"n"},"mo":"\u2062","mrow":{"mrow":[{"msub":{"mi":"v","mn":"1"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"i"}},{"msub":{"mi":"v","mn":"2"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"i"}}],"mo":"\u2062"}}],"mo":"="}}}},"The inner product may be implemented generically in a high-level programming language as follows:","function inner-productl(vector v, vector v)","if (length(vl) !=length(v))","fail","result=0","for (i=1 to length(vl))","result=result+(vl[i]*v[i])","return result","If, for a specific problem, it is known that the length of the two vectors is 3. The inner-product function can then be simplified to:","function inner-product(vector v, vector v) return v[1]*v[1]+v[2]*v[]+vl[3]*v[3]","By using partial evaluation to incorporate knowledge of the input data, much of the overhead of the original general-purpose inner product algorithm has been eliminated. No length checking of the vectors is needed. No intermediate result variable is needed. No for-loop overhead (maintain i variable, increment i and check i against vector length each iteration). Calculations can be parallelized (perform multiplications in parallel then add products together) on some special-purpose processors","In some cases, the elements of vector v are known at compile-time. Suppose we know that vl=[3, 2, 5]. The inner product algorithm can then be partially evaluated even further:","function inner-product(vector v)","return 3*v[1]+2*v[2]+5*v[3]","Now the function only takes a single argument and the elements of vl can be stored in program memory instead of taking up valuable space in random access memory (RAM). The inner product algorithm can be optimized more if some of the elements of v are known at compile-time. Suppose the last element is known to be 10:","function inner-product(vector v)","return 3*v[1]+2*v[2]+50","The last multiplication can be computed at compile-time and stored in program memory so it does not have to be computed at run-time.","In addition to overhead, another feature of generic inference engines used to compute probabilities in BNs is that they tend to be written by hand by computer programmers in a specific programming language. To use the inference engine in a different programming language, therefore, the inference engine must either be re-written in the other language or some sort of inter-language communication protocol must be used. It may be time-consuming and error-prone to rewrite a complex algorithm such as a BN inference engine in a different programming language, and inter-language communication protocols have their own overhead and are often difficult to use effectively. An inter-language communication protocol may not even exist for two specific programming languages, preventing this from even being a possibility.","A computer science technique called automatic source code generation can be used to solve this inflexibility. A Source Code Generator (SCG) is a computer program that writes another computer program that does something. The programming languages that the two programs are written in can be different. In general, the SCG helps the user to build some model and then generates a computer program that does something with that model, so the user doesn't have to write the computer program by hand. The generated source code can then be compiled into machine code and executed on a processor, just like hand-written source code.",{"@attributes":{"id":"p-0061","num":"0064"},"figref":"FIG. 2","b":["210","215","220","210","230","240"]},"In one embodiment of the present disclosure, a development application is provided that produces a high level programmatic representation of a specific BN. The high level programmatic representation may be pseudo code, source code or other suitable representation. In some embodiments, the development application allows a user to select the specific high level programmatic representation.","The development application may be a software program written in any suitable programming language. For example, the development application may be written in the Java programming language, but other programming languages such as C++ may be used. The development application may execute on a computer work station or other suitable computer. The development application may run on a computer with single processor or any combination of multiple or networked processors.","In some embodiments, the representation of the BN may be supplied by a user. In such embodiments, the workstation, or other processor, executing the development application may have a user interface allowing a human user to input parameters describing the BN. An example of a suitable interface may be found in co-pending application Ser. No. 60\/591,269 entitled \u201cModeless User Interface Incorporating Automatic Updates for Developing and Using Bayesian Belief Networks\u201d filed Jul. 26, 2004 in the name of Cox, et al. The description of the BN may also be provided by a user in any other suitable way. Further, the method and system described in the present disclosure is not limited for use in connection with BNs specified by a human user. Specification for the BN may come from other sources, including other programs or development applications.","The data describing the BN may be stored in any suitable form. In some embodiments, the data describing the BN may be stored in one or more data structures in computer readable memory associated with the work station or processor on which the development application executes. Such a data structure may, for example, store representations of cliques and separators and other data associated with each of the cliques and separators.","The development application may output the high level programmatic representation of the BN in any desired form. The output may be presented for example, presented on a computer display, on a paper printout or in an electronic file of any desired format. In the embodiments described below, the output is in the form of an electronic file, allowing for further computer processing of the high level programmatic representation of the BN. In the specific example where the programmatic representation is in the form of source code, the file may be in a format as is traditionally used to provide source code to a compiler or other processing tool. In this way, the programmatic representation may be further processed, such as by converting it to an executable file. Such an executable file may then be executed on the work station or other processor containing the development application. Alternatively, the executable file may be loaded into one or more other device with a computers or processors for execution. As a specific example, the executable file may be loaded into a handheld device or other processor having significantly less processing capability than the workstation on which the development application executes. Alternatively, multiple copies of the executable file may be made and distributed throughout an enterprise, thereby allowing multiple users throughout the enterprise to use the same BN consistently for decision making.","In one embodiment, the probability equations that calculate beliefs for a specific BN may be represented in the source code of a programming language directly, so that probabilities for a specific BN can be computed by simply instructing a processor to multiply, add, and divide numbers, instead of relying on complex generic data structures and a corresponding complex generic algorithm to compute the probabilities for any BN.","The BNs for which the development application generates source code for computing probabilities may contain both discrete and continuous nodes with no restrictions on topology or CPDs. Such a BN is commonly referred to as a hybrid Bayesian network (HBN). A BN with only discrete or only continuous nodes may be similarly processed.","The BNs for which the development application generates source code for computing probabilities may contain temporal edges. A temporal edge is directed from a parent node to a child node in the BN and represents the parent node causing the child node in the next time step. Such a BN is commonly referred to as a dynamic Bayesian network (DBN). DBNs may typically only contain discrete nodes. The present disclosure may also include, however, DBNs with both discrete and continuous nodes. These are commonly referred to as dynamic hybrid Bayesian networks (DHBN).","The development application may generate source code for calculating any probabilities of nodes in the BN. As described above, this includes calculating the joint probability of a subset of nodes in the BN, P(X), and calculating the conditional probability of one subset of nodes in the BN given another subset of nodes in the BN, P(X|X). Common probabilities such as beliefs, P(X|e), the joint probability P(Q,F|e) used in mutual information, and the joint probability P(X,parents(X)|e) used in learning are all special cases of these generic probabilities. A development application is not limited to these specific probabilities however, and may process a BN that generates any probability or multiple types of probabilities.","Although an exemplary embodiment has been described for calculating beliefs in a BN with only discrete nodes, the method and system described in the present disclosure is not limited to such probabilities and\/or BNs, but rather includes generating source code for calculating all probabilities in DHBNs. The embodiment described below can be adapted to any standard inference engine that can be used to calculate the desired probabilities in the desired type of BN.","A development application may use the method illustrated in , discussed above. In , a specific BN is provided to the system as input, through the data acquisition interface. The partial evaluation algorithm then determines all of the calculations required to produce the desired probabilities in the BN. These calculations are then output by the source code generator as source code in the proper syntax of a programming language.",{"@attributes":{"id":"p-0073","num":"0076"},"figref":["FIG. 3","FIG. 2","FIG. 3"],"b":["300","310","320","330","330","310"]},"One technique to generate source code in a programming language for computing probabilities uses partial evaluation to traverse the AMG to calculate probabilities, but instead of performing the calculations directly, the calculations that would be performed are output as code. This is, in effect, a modification to a traditional inference engine such that the result is the instructions that would be performed by the inference engine, instead of actually performing those instructions. Any compiler for that specific programming language can then compile this source code and it can be used to compute probabilities for that BN.","Beliefs for a BN are multi-linear functions of CPT entries and evidence values. A multi-linear function is a polynomial of degree at most one. Therefore, the belief equations consist of multiplications and additions of CPT entries and evidence values. These multiplications and additions may be represented in an AMG, and an algorithm made be implemented for traversing the AMG to calculate beliefs.","The belief for state j of node i is defined to be b=\u03bb.value*\u03bb, derivative, where \u03bbis the evidence vertex in the AMG for that particular state. Thus, to compute the belief of a particular state of a particular node in the BN, the belief traversal algorithm starts at the corresponding evidence vertex in the AMG of that state and proceeds through the AMG as follows:","Where v is any vertex in the AMG, p is a parent of v, v\u2032 is one of p's other children besides v, and c is a child of v. The derivative of the root vertex of the AMG is defined to be 1. The value of a leaf vertex is either a CPT entry or an evidence value. Once the value or derivative of a vertex in the AMG has been calculated, it may be cached so that it does not need to be calculated again. In this way, partial calculations can be reused, which greatly speeds up the belief calculations.","In one embodiment, the above traversal algorithm may be modified slightly in order to generate source code for calculating beliefs. Instead of actually performing the additions and multiplications, a list of variable assignments may be generated during traversal. Each element of the list represents the expression for a value or derivative of a vertex in the AMG, and it references the value and derivative of other vertices in the AMG.","In the original AMG algorithm described above, these values and derivatives would actually be calculated, instead of generating code that represents the calculations. The list would be generated such that variables referenced in an assignment are themselves declared and assigned before that assignment to prevent illegal forward references and to ensure the referenced variables have already been assigned their proper value. Also, each variable would only be declared once, although it subsequently may be referenced many times.","After the modified belief traversal algorithm is finished, the list may be transformed into source code by iterating over each element, and outputting each variable assignment to a text file. This text file may be a pre-existing source code file called a template file, in which case the variable declarations would be inserted at a specific position within the source code file. It may also be a plain text file, in which case a developer would then insert the text into a source code file by hand.","In general, each element of the variable assignment list may represent one line of source code in which a variable is optionally declared and is then assigned the result of adding and multiplying other previously defined variables, CPT entries, evidence values, and\/or constant values. For example, an element may represent a variable called m that is assigned the product of ml, cl, and el added to the product of m, c, and e. This element may already be a string of characters that represent the line of source code in a programming language to be output to a source code file.","The element may also be some data structure that represents the multiplication and addition of the variables and the assignment of the result to m. In this case, the element itself or some other part of the system must be able to convert the element into a string of characters that represents the line of source code in a programming language to be output to a source file. Different modules can be provided that translate the element into valid source code for different programming languages. For example, the element for m could be output in Java syntax as:","double m=ml*cl*el+m*c*e;","In another embodiment, variables m, m, and m may actually be elements of an array that is declared elsewhere in the source code. The generated source code statements may, for example, be added to a file, a programming project, or other artifact in a program development environment that contains supporting code, such as input and output code. Such an artifact may also contain structures providing a shell of functions for methods, or other programmatic objects into which source code statements may be inserted. In this case, the element for m could be output in Java syntax as:","m[3]=m[1]*cl*el+m[2]*c*e;","In most cases, the source code for calculating probabilities cannot stand by itself in the source code file. Rather, it needs to be contained in some function or method and also needs to be supported by some kind of input and output code. To continue the example of generating Java source code, the belief equations could be contained in a method provided below:",{"@attributes":{"id":"p-0087","num":"0090"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public void calculateBeliefs( )",{}]},{"entry":[{},"\u2003\u2003(m[1] = el * c1;"]},{"entry":[{},"m[2] = e2 * c2;"]},{"entry":[{},"m[3] = m[1] * c3 * e3 + m[2] * c4 * e4;"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"This calculateBeliefs method would then be called by some other function or method when beliefs need to be recalculated. Details on when beliefs need to be recalculated and how this can be detected and carried out can be found in the co-pending application Ser. No. 60\/591,269 entitled \u201cModeless User Interface Incorporating Automatic Updates for Developing and Using Bayesian Belief Networks\u201d filed Jul. 26, 2004 in the name of Cox, et al., and incorporated herein by reference in its entirety.","The input to the generated source code module may generally be new evidence for nodes in the BN. This may be triggered by the availability of new or updated information in the system in which the generated source code is used. The generated source code may also provide a function or method for clients to call to set this new evidence.","In Java, for example, this may be performed as follows:",{"@attributes":{"id":"p-0091","num":"0094"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003\u2003public void setEvidence(int variable, double( ) evidence)"]},{"entry":[{},"{"]},{"entry":[{},"modified = true;"]},{"entry":[{},"\u2009for (int i = 0, length = evidence.length; i < length; ++i)"]},{"entry":[{},"\u2009{"]},{"entry":[{},"e[variable][i] = evidence[i];"]},{"entry":[{},"\u2009}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In this case, evidence may be stored in the two-dimensional array e [ ] [ ]. Clients may call the method, specifying the variable for which new evidence has been obtained and also the new evidence for the variable. The code may set the proper values of the e [ ] [ ] array for later use in the probability calculation code (i.e. the calculateBeliefs method given previously as an example).","If CPT entries are allowed to change at run-time, the generated source code may also contain a function or method to allow clients to change them. This may be another form of input to the BN, similar to the input of new evidence. CPT entries may be changed at run-time in a system that adapts to new data over time, to model the system better over time. This may be referred to as on-line learning.","One example of such a method in Java is provided below:",{"@attributes":{"id":"p-0095","num":"0098"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003public void setCpt(int variable, int configuration, double"]},{"entry":[{},"\u2003\u2003\u2003probability)"]},{"entry":[{},"{"]},{"entry":[{},"modified = true;"]},{"entry":[{},"\u2009c[variable)(configuration) = probability;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In this case, CPT entries are stored in the two-dimensional array c[ ] [ ]. Clients call the method specifying the variable whose CPT is to be changed, the configuration representing the entry to be changed, and the new conditional probability value. The code sets the proper value of the c[ ][ ] array for later use in the probability calculation code (i.e. the calculateBeliefs method given previously as an example). Note that if CPT entries are not allowed to change at run-time (one optimization hard-codes them for simplification) then this method would not be provided.","The outputs of the generated source code are the desired probabilities for nodes in the BN. There may generally be one or more functions or methods to allow clients to obtain these probabilities. This function or method generally first checks to see if the probabilities need to be recalculated, and if so it will call the function or method that contains the probability calculation code. Next it returns the desired probabilities.","For calculating beliefs in Java, the following may be performed:",{"@attributes":{"id":"p-0099","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003public double[ ] getBeliefs(int variable)"]},{"entry":[{},"{"]},{"entry":[{},"if (modified)"]},{"entry":[{},"\u2009{"]},{"entry":[{},"calculateBeliefs0( );"]},{"entry":[{},"}"]},{"entry":[{},"return b[variable]; }"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"If any modifications were made this method first calls the calculateBeliefs method to re-calculate beliefs and then returns the beliefs for the specified variable.","In one embodiment of the present disclosure, the data structures and algorithms for the BN, JT, and AMG may be written in Java, and the source code for calculating beliefs was be generated for Java.",{"@attributes":{"id":"p-0102","num":"0105"},"figref":["FIG. 4","FIG. 4","FIG. 4"]},{"@attributes":{"id":"p-0103","num":"0106"},"figref":"FIG. 5"},"The present disclosure is of course not limited to generating source code in the Java programming language. Source code for computing beliefs can be generated for any programming language that supports storing numbers in variables and the addition, multiplication, and division operations. Some examples include, but are not limited to, assembly, C, C++, C#, Perl, Lisp, VisualBasic, Fortran, Basic, Scheme, Smalltalk, Cobol, Haskell, Matlab, Mathematica, and Pascal. To extend the development application applies to one or more other programming languages, the variable assignments and belief equations are generated in the proper syntax of the language and the belief equations are contained in some kind of function appropriate to the language. The development application may contain one or more modules or other components that generate variable assignments and belief equations, with one such module available for each programming language in which source is to be generated. A user may specify which language is to be used and the appropriate module could then be invoked.","Optimizations may be made to the AMG, and thus, to the generated belief equations. These optimizations may use the principle of partial evaluation to simplify the belief equations using as much information about the BN that is known at compile-time. One simplification may be obtained by fixing the CPT entries to their values at compile-time. Since these values will not change at run-time, calculations involving them can be partially computed at compile-time. This simplification is similar to the inner-product example discussed above.","As one example, the following calculation may appear in a generated source code:","x=cl*c*c*el+c*c*c*e","If the CPT entries c, c, c, c, c, and c are known to take on the values 0.1, 0.2, 0.3, 0.4, 0.5, and 0.6, respectively, and will not change at run-time, then this calculation can be simplified to:","x=0.006*el+0.12*e","In practice, not all nodes in the BN may receive evidence. Usually, only a subset of the nodes in a BN may receive evidence, depending on the type of information that can be collected from a specific system. By fixing the probabilities of the nodes for which probabilities will not be changed through posting of evidence, the generated code may be simplified.","Another simplification may arise by setting all evidence values of non-evidence nodes in the BN to one. This is mathematically valid since evidence of all ones represents no evidence for a node. Since multiplication of a number with one is the number, the corresponding evidence vertices can effectively be removed from the AMG.","Further, beliefs may not be needed in practice for all nodes in the BN. Usually only a subset of the nodes in a BN may ever need to have their beliefs computed, depending on which beliefs are needed to take action or make a decision in a certain system. In some cases, the belief traversal algorithm may have been specified to compute beliefs for all nodes in the BN. By simply restricting the evidence vertices to those for needed beliefs in which the traversal algorithm starts, however, unneeded beliefs may not have to be calculated, and the corresponding source code for computing those beliefs will not be generated.","Yet another optimization may remove any term of the equations that is multiplied by zero. Since any number multiplied by zero is zero, this term would not contribute to the equation and would just waste computations at run-time. In general, any optimization used to create compiled code may be applied.","If a term in the equations is added by a value of zero, the addition does not need to take place since zero added to any number is that number. Similarly, if a term in the equations is multiplied by a value of one, the multiplication does not need to take place since any number multiplied by one is that number. These are two additional optimizations that can simplify the probability calculations.","The three optimizations discussed above remove calculations involving the values one and zero. In an additional optimization technique, first values below a pre-specified lower bound can be set to zero and values above a pre-specified upper bound can be set to one. This produces more ones and zeros that can be eliminated using the other optimizations.","Some programming languages specify that the compiled machine code of a particular function or method cannot exceed a pre-specified amount. For example, the compiled bytecode of a method in Java cannot exceed 65,535 bytes due to limitations in the Java bytecode instruction set. Other languages have similar restrictions. Because many calculations may be required to compute probabilities in large BNs, the compiled calculations can easily exceed these limits. To prevent this from occurring, an extra processing step can be included in the source code generation step. A running count of the required instructions may be kept, and the calculations may be split up among multiple functions or methods, so each one does not exceed the specified limit of the programming language.","Another use of the above described application is to represent the probability equations that calculate beliefs for a BN in the hardware of a computing device directly, so that probabilities for a specific BN can be computed by simply multiplying and adding numbers, instead of relying on generic data structures and a corresponding generic algorithm to compute the probabilities. Examples of hardware may include, but are not limited to, electronic circuits, Field Programmable Gate Arrays (FPGA), Application-Specific Integrated Circuits (ASIC), biological computers, molecular computers, and quantum computers.","To create or program a hardware device to calculate the probabilities of a BN, typically the system described above may output the probability equations in a certain programming language used to create or program hardware devices. One example of such a language is Verilog. After generating the source code for the hardware device, the source code may then be used to physically create or program a hardware device. In this way, the probability calculations may be carried out directly in hardware, instead of being represented as machine code instructions for a processor to execute.","There are many ways to initiate the automatic generation of software or hardware for calculating the beliefs of a BN. One simple method may be to provide a single button in an application for graphically developing BNs, which when pushed either generates the source code or provides the user of the application a screen to adjust settings of the code generation process, and then after the user adjusts the settings generates the source code. Another method may be to provide a stand-alone computer program that takes as input the specification of a BN and produces as output the software or hardware to compute the beliefs of that BN. Another method may be to provide a library that takes as input a BN and produces as output the source code for calculating probabilities of that BN.","The software for computing probabilities in a BN produced by a development application as described above may be used in many different ways in many different systems. Some examples include, but are not limited to: a software component in a larger software system used to compute the probabilities of a specific BN; a software component interfaced to hardware of a system used to compute the probabilities of a specific BN; and part of a library of BNs used by other software or hardware components","The hardware for computing probabilities in a BN produced by a development application as described above may be used in many different ways in many different systems. Some examples include, but are not limited to: a stand-alone hardware device interfaced to other hardware devices for computing probabilities of a specific BN; a stand-alone reprogrammable hardware device that can be reprogrammed to compute probabilities for different BNs; and hardware that is contained in a larger hardware system for computing the probabilities of a BN.","In sum, methods and systems have been described for computing probabilities, as well as a development application that generates programmatic representations of a model for computing probabilities. In one exemplary embodiment described above, the method begins by receiving a Bayesian network and then uses a standard inference algorithm that is modified to store the calculations it would perform to compute the probabilities instead of actually carrying out those calculations. The probability calculations are then output in the proper syntax of a programming language such that other code in the same programming language can interface with it, such as to request it to calculate the probabilities of variables in the Bayesian network. The programming language of the output source code can be different than the programming language that the Bayesian network and modified inference engine are written in.","While certain embodiments have been described of a system and method for computing probabilities of variables in a belief network, it is to be understood that the concepts implicit in these embodiments may be used in other embodiments as well. The protection of this application is limited solely to the claims that now follow.","In these claims, reference to an element in the singular is not intended to mean \u201cone and only one\u201d unless specifically so stated, but rather \u201cone or more.\u201d All structural and functional equivalents to the elements of the various embodiments described throughout this disclosure that are known or later come to be known to those of ordinary skill in the art are expressly incorporated herein by reference, and are intended to be encompassed by the claims. Moreover, nothing disclosed herein is intended to be dedicated to the public, regardless of whether such disclosure is explicitly recited in the claims. No claim element is to be construed under the provisions of 35 U.S.C. \u00a7112, sixth paragraph, unless the element is expressly recited using the phrase \u201cmeans for\u201d or, in the case of a method claim, the element is recited using the phrase \u201cstep for.\u201d",{"@attributes":{"id":"p-0125","num":"0128"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"center"}},"thead":{"row":[{"entry":"APPENDIX"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Automatically Generated Source Code For Calculating Beliefs In The BN"},{"entry":"Shown In FIG. 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public class Weather"},{"entry":"{"},{"entry":"\u2003\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/"},{"entry":"\u2003\/\/ creation API"},{"entry":"\u2003public weather( )"},{"entry":"\u2003{"},{"entry":"\u2003\u2003n = new String[ ] {\u201cRain\u201d, \u201cSprinkler\u201d, \u201cWetGrass\u201d, \u201cCloudy\u201d};"},{"entry":"\u2003\u2003s = new String[ ][ ] {{\u201cNo\u201d,\u201cYes\u201d}, (\u201cNo\u201d,\u201cYes\u201d), {\u201cNo\u201d,\u201cYes\u201d}, {\u201cNo\u201d,\u201cYes\u201d}};"},{"entry":"\u2003\u2003c = new double[ ][ ]"},{"entry":"\u2003{{0.8,0.2,0.2,0.8},(0.5,0.5,0.9,0.1), {1.0,0.0,0.1,0.9,0.1,0.9,0.01,0.99}, (0.5,0.5}};"},{"entry":"\u2003\u2003e = new double[s.length][ ];"},{"entry":"\u2003\u2003ed = new double[s.length][ ];"},{"entry":"\u2003\u2003for (int i \u2212 0, length = s.length; i < length; ++i)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003e[i] = new double[s[i].length];"},{"entry":"\u2003\u2003\u2003ed[i] \u2212 new double[s[i].length];"},{"entry":"\u2003\u2003\u2003for (int j = 0, length2 = s[i].length; j < length2; ++j)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003e[i][j] = 1.0;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003b = new double[s.length][ ];"},{"entry":"\u2003\u2003for (int i = 0, length = s.length; i < length; ++i)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003b[i] = new double[s[i).length];"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003int[ ] mlengths = (8, 8);"},{"entry":"\u2003\u2003mv = new double[mlengths.length][ ];"},{"entry":"\u2003\u2003md = new double[mlengths.length][ ];"},{"entry":"\u2003\u2003for (int i=0, length=mv.length; i<length; ++i)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003mv[i] = new double[mlengths[i]];"},{"entry":"\u2003\u2003\u2003md[i] = new double[mlengths[i]];"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003int[ ] alengths = (4);"},{"entry":"\u2003\u2003av = new double[alengths.length][ ];"},{"entry":"\u2003\u2003ad = new double[alengths.length][ ];"},{"entry":"\u2003\u2003for (int i=0, length=ay.length; i<length; ++i)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003av[i] = new double[alengths[i]];"},{"entry":"\u2003\u2003\u2003ad[i] = new double[alengths[i]);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/"},{"entry":"\u2003\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/"},{"entry":"\u2003\/\/ beliefs API"},{"entry":"\u2003public double[ ] getBeliefs (int variable)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003if (modified)"},{"entry":"\u2003\u2003\u2003calculateBeliefs0( );"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003return b[variable];"},{"entry":"\u2003}"},{"entry":"\u2003private void calculateBeliefs0( )"},{"entry":"\u2003{"},{"entry":"\u2003\u2003md[0][0]=1.0;"},{"entry":"\u2003\u2003md[0](4)=1.0;"},{"entry":"\u2003\u2003ad[0][0]=md[0][0]*c[2][0]*e[2][0]+md[0][4]*c[2][1]*e[2][1];"},{"entry":"\u2003\u2003md[1][0]=ad[0](0];"},{"entry":"\u2003\u2003md[l][4]=ad[0][0];"},{"entry":"\u2003\u2003md[0][2]=1.0;"},{"entry":"\u2003\u2003md[0][6]=1.0;"},{"entry":"\u2003\u2003ad[0][2]=md[0][2]*c[2][4)*e[2][0)+md[0][6]*c[2][5]*e[2](1];"},{"entry":"\u2003\u2003md[1][2]=ad[0][2]; md[1][6]=ad[0][2];"},{"entry":"\u2003\u2003ed[0][0]=md(1)(0)*c[0][O]*c[1][0]*e[1][0)*c[3][0]*e[3][0]+md[l][4]*c[0)[2]*c[l][2]*e[1]"},{"entry":"\u2003\u2003[0]*c[3](11*e[3][1]+md[1.)[2]*c(0][0]*c[1](1]*e[1][1}*c[3][0]*e[3](0)+md[l][6]*c[0][2]"},{"entry":"\u2003\u2003*c[l][3]*e[1][1]*c[3][1]*e[31[1);"},{"entry":"\u2003\u2003\u2003md(0)[1]=1.0;"},{"entry":"\u2003\u2003\u2003md[0][5]1.0;"},{"entry":"\u2003\u2003\u2003ad[0][1]=md[0][i]*c[2][2]*e[2][0]+md[0][5]*c[2][3]*e[2][1];"},{"entry":"\u2003\u2003\u2003md[1][1]=ad[0][1]; md[1][5]=ad[0][1]; md[O][3]=1.0;"},{"entry":"\u2003\u2003\u2003md[0][7]=1.0;"},{"entry":"\u2003\u2003\u2003ad[0][3]=md[0][3]*c[2][6]*e(2][0]+md[0][7]*c[2][7]*e[2][1];"},{"entry":"\u2003\u2003\u2003md[1](3)=ad[0](3); md[1][7]=ad[0](3);"},{"entry":"\u2003\u2003ed[0][1]=md(1)[1]*c[0][1]*c[1][0]*e[1][0]*c[3][0]*e[3][0]+md[1][5]*c[0][3]*c[1][2]*e[1]"},{"entry":"\u2003\u2003[0]*c[3][1]*e[3][1]+md[1](3]*c[0][1]*c[1][1]*e[1][1]*c[3][0]*e[3][0]+md[1][7]*c[0][3]"},{"entry":"\u2003\u2003*c[1][3]*e[1][1]*c[3][1]*e[3](1);"},{"entry":"\u2003\u2003ed[1][0]=md(1)[0]*c[0][0]*e[0][0]*c[1][0]*c[3][0]*e[3][0]+md[1][4]*c[0][2]*e[0][0]*c[1]"},{"entry":"\u2003\u2003[2]*c[3][1)*e[3][1]+md[1][1]*c(0)[1]*e[0)[1]*c(1][0]*c(3][0)*e[3](0)+md[1][5)*c(0][3]"},{"entry":"\u2003\u2003*e[0][1]*c[1][3]*c[3][1]*e(3)(1);"},{"entry":"\u2003\u2003ed[1][1]=md[1][2]*c(0)(0)*e[0][0]*c(1)(1)*c(3)(0)*e(3)(0)+md(1)(6)*c[0][2]*e[0][0]*c[1]"},{"entry":"\u2003\u2003[3]*c(3)(1)*e(3)[1)+md[1][3]*c[0](1)*e[0][1]*c(1)(1)*c[3][0]*e(3)(0)+md(I)(7)*c[0)[3]"},{"entry":"\u2003\u2003*e[0][1)*c[1][3]*c[3)[1)*e[3)[1);"},{"entry":"\u2003\u2003\u2003mv[1][0)=c[0][0]*e[0][0]*c[1][0]*e(I)[0]*c(3)(0)*e[3][0];"},{"entry":"\u2003\u2003\u2003mv[1][4]=c[0][2)*e[0][0]*c[1][2]*e[1][0]*c[3][1]*e(3)(1);"},{"entry":"\u2003\u2003\u2003av[0][0)=mv[1][0]+mv[1][4);"},{"entry":"\u2003\u2003\u2003mv[1)[1]=c[0][1]*e[0][1]*c[1)[0]*e(I)(0)*c(3)(0)*e(3)[01;"},{"entry":"\u2003\u2003\u2003mv(1)(5)=c[0][3]*e(0)[1]*c[1](2)*e[1][0]*c(3)(I)*e(3)[1];"},{"entry":"\u2003\u2003\u2003av(01[1]=mv[1][1)+mv(1)[5];"},{"entry":"\u2003\u2003\u2003mv(1)(2)=c[0](0]*e(0)(0)*c(1)(1)*e[1][1]*c[3)(0)*e[3][0];"},{"entry":"\u2003\u2003\u2003mv[1][6]=c[0][2]*e[0][0]*c[1](3)*e(1](1)*c[3][1]*e(3)(1);"},{"entry":"\u2003\u2003\u2003av(0)[2]=mv(1][2]+mv[1)[6);"},{"entry":"\u2003\u2003\u2003mv(1)(3]=c[0)[1]*e[0][1]*c[1][1]*e(1)(1)*c[3][0]*e(3)(0);"},{"entry":"\u2003\u2003\u2003mv[1][7]=c(0)(3)*e(0)(1)*c(1)(3)*e[1](1)*c(3)(1]*e[3)(1);"},{"entry":"\u2003\u2003\u2003av[0][3]=mv[1][3]+mv(1)[7];"},{"entry":"\u2003\u2003ed[2][0]=md[0][0]*av[0][0]*c[2](0)+md(0)(1)*av(0)(1)*c[2][2]+md[0][2]*av[0)[2]*c[2][4]+"},{"entry":"\u2003\u2003md(0)(3)*av(0)(3)*c(2)(6);"},{"entry":"\u2003\u2003ed[2][1]=md[0][4]*av[0][0]*c[2][1]+md[0][5]*av(0)[1]*c[2][3]+md(0)(6)*av[0)(2)*c[2](5)+"},{"entry":"\u2003\u2003md[0](7)*av[0][3]*c(2)(7);"},{"entry":"\u2003\u2003ed[3][0]=md[1][0]*c(0)(0)*e[0][0]*c[1](0)*e[1](0)*c[3][0]+md(I)[1]*c[0][1]*e[0][I]*c[1]"},{"entry":"\u2003\u2003[0)*e[1][0]*c[3](0)+md(I)(2)*c(0)(0)*e[0][0]*c[1][1]*e[1][1]*c(3)[0]+md[1][3]*c[0)[1]"},{"entry":"\u2003\u2003*e(0)[1]*c[1][1]*e[1](1)*c[3][0];"},{"entry":"\u2003\u2003ed(3)[1]=md[1][4]*c[0][2]*e(0)[0]*c[1][2]*e[1][0]*c[3][1]+md[1](5)*c[0][3]*e(0)[1)*c(I]"},{"entry":"\u2003\u2003[2]*e[1](0)*c(3)(1)+md[1](6)*c(0)[2]*e(0)(0)*c(1)[3]*e[1][1]*c(3)[1]+md[1)[7]*c[0](3)"},{"entry":"\u2003\u2003*e(0)(1)*c(1]131*e(1)[1]*c(3)[1];"},{"entry":"\u2003\u2003\u2003normalizeBeliefs( );"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003private void normalizeBeliefs( )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003b(0)(0)=e(0)(0)*ed(0)(0);"},{"entry":"\u2003\u2003b[0][1]=e[0][1]*ed(0)(1);"},{"entry":"\u2003\u2003b[1][0]=e[1](0)*ed[1][0];"},{"entry":"\u2003\u2003b(1)(1)=e(1)(1)*ed[1][1];"},{"entry":"\u2003\u2003b[2][0]=e(2)[0]*ed[2][0];"},{"entry":"\u2003\u2003b(2)(1)=e[2](1)*ed[2][1];"},{"entry":"\u2003\u2003b[3][0]=e[3][0]*ed[3](0);"},{"entry":"\u2003\u2003b[3][1]=e(3)(1)*ed(3)[1];"},{"entry":"\u2003\u2003for (int i=0, length=b.length; i<length; ++i)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003double sum = 0.0;"},{"entry":"\u2003\u2003\u2003for (int j=0, length2=b(i).length; j<length2; ++j)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003sum += b[i)(j);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003for (int j=0, length2=b[i].length; j<length2; ++j)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003b[i][j] \/= sum;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003modified = false;"},{"entry":"\u2003}"},{"entry":"\u2003\/** b(i)(j) = belief for state j of node i *\/"},{"entry":"\u2003private double[ ][ ] b;"},{"entry":"\u2003\/** true when something changed and beliefs need to be recalculated *\/"},{"entry":"\u2003private boolean modified = true;"},{"entry":"\u2003\/** these five arrays store partial results of belief calculations *\/"},{"entry":"\u2003private double[ ][ ] mv, md, av, ad, ed;"},{"entry":"\u2003\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/"},{"entry":"\u2003\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/"},{"entry":"\u2003\/\/ evidence API"},{"entry":"\u2003public double[ ] getEvidence(int variable)"},{"entry":"\u2003("},{"entry":"\u2003return e[variable];"},{"entry":"\u2003)"},{"entry":"\u2003public void setEvidence(int variable, double[ ] evidence)"},{"entry":"\u2003("},{"entry":"\u2003\u2003modified = true;"},{"entry":"\u2003\u2003for (int i = 0, length\u2003\u2003\u2003evidence.length; i < length; ++i)"},{"entry":"\u2003\u2003("},{"entry":"\u2003\u2003\u2003e[variable)[i] = evidence[i];"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003public void clearEvidence(int variable)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003\u2003modified = true;"},{"entry":"\u2003\u2003\u2003for (int i = 0, length = e[variable].length; i < length; ++i)"},{"entry":"\u2003\u2003\u2003\u2003("},{"entry":"\u2003\u2003\u2003\u2003e(variable)[i] = 1.0;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003public void clearAllEvidence("},{"entry":"\u2003)"},{"entry":"\u2003\u2003\u2003modified = true;"},{"entry":"\u2003\u2003\u2003\u2003for (int i = 0, length = e.length; i < length; ++i)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003for (int j = 0, length2 = e[i].length; j < length2; ++j)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003e(i] [j] = 1.0;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003\/** e[i)[j) = evidence for state j of node i *\/"},{"entry":"\u2003private double[)(1 e;"},{"entry":"\u2003\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/"},{"entry":"\u2003\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/"},{"entry":"\u2003\/\/ conditional probability API"},{"entry":"\u2003public double getConditionalProbability(int variable, int configuration)"},{"entry":"\u2003("},{"entry":"\u2003\u2003return c(variable) [configuration];"},{"entry":"\u2003}"},{"entry":"\u2003public void setConditionalProbability(int variable, int configuration, double"},{"entry":"probability)"},{"entry":"\u2003("},{"entry":"\u2003\u2003modified = true;"},{"entry":"\u2003c(variable)(configuration) = probability;"},{"entry":"\u2003)"},{"entry":"\u2003\/** c(i)(j) = conditional probability for configuration j of node i *\/"},{"entry":"\u2003private double[ ][ ] c;"},{"entry":"\u2003\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/"},{"entry":"\u2003\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/"},{"entry":"\u2003\/\/ node & state name API"},{"entry":"\u2003public int getVariable(String name)"},{"entry":"\u2003("},{"entry":"\u2003\u2003for (int i = 0, length = n.length; i < length; ++1)"},{"entry":"\u2003\u2003("},{"entry":"\u2003\u2003\u2003if (n[i].equals(name))"},{"entry":"\u2003\u2003\u2003("},{"entry":"\u2003\u2003\u2003\u2003return i;"},{"entry":"\u2003\u2003\u2003]"},{"entry":"\u2003\u2003return \u22121;"},{"entry":"\u2003\u2003)"},{"entry":"\u2003\u2003public String getVariableName(int variable)"},{"entry":"\u2003\u2003("},{"entry":"\u2003\u2003return n(variable);"},{"entry":"\u2003\u2003)"},{"entry":"\u2003\u2003public String( ) getStates(int variable)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003return s(variable);"},{"entry":"\u2003\u2003("},{"entry":"\u2003\u2003public int getVariableCount(1)"},{"entry":"\u2003\u2003("},{"entry":"\u2003\u2003\u2003\u2003return n.length;"},{"entry":"\u2003\u2003)"},{"entry":"\u2003\u2003public int getStateCount(int variable)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003return s[variable].length;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\/** n[i] = name of node i *\/"},{"entry":"\u2003private String( ) n;"},{"entry":"\u2003\/** s[i][j] = name of state j of node i *\/"},{"entry":"\u2003private String[ ][ ] s; \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/"},{"entry":"\u2003)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 5","FIG. 4"]}]},"DETDESC":[{},{}]}
