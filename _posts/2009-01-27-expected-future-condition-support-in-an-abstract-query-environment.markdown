---
title: Expected future condition support in an abstract query environment
abstract: Embodiments of the invention are generally related to data processing, and more specifically to retrieving data from a database. An abstract query may include query conditions and a first logical field comprising conditions for determining whether a second logical field will have a predefined value in the future. Upon execution, the abstract query may return results that satisfy the conditions for determining whether the second logical field will have the predefined value.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08214381&OS=08214381&RS=08214381
owner: International Business Machines Corporation
number: 08214381
owner_city: Armonk
owner_country: US
publication_date: 20090127
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS","Exemplary System","Relational View of Environment"],"p":["1. Field of the Invention","The present invention is generally related to data processing, and more specifically to retrieving data from a database.","2. Description of the Related Art","Databases are computerized information storage and retrieval systems. A relational database management system is a computer database management system (DBMS) that uses relational techniques for storing and retrieving data. The most prevalent type of database is the relational database, a tabular database in which data is defined so that it can be reorganized and accessed in a number of different ways. A distributed database is one that can be dispersed or replicated among different points in a network. An object-oriented programming database is one that is congruent with the data defined in object classes and subclasses.","Regardless of the particular architecture, in a DBMS, a requesting entity (e.g., an application or the operating system) demands access to a specified database by issuing a database access request. Such requests may include, for instance, simple catalog lookup requests or transactions and combinations of transactions that operate to read, change and add specified records in the database. These requests are made using high-level query languages such as the Structured Query Language (SQL) and application programming interfaces (API's) such as Java\u00ae Database Connectivity (JDBC). The term \u201cquery\u201d denominates a set of commands for retrieving data from a stored database. Queries take the form of a command language, such as SQL, that lets programmers and programs select, insert, update, find the location of data, and so forth.","The present invention is generally related to data processing, and more specifically to retrieving data from a database.","One embodiment of the invention provides a computer-implemented method for retrieving query results. The method generally comprises receiving an abstract query comprising at least one first logical field defined in a data abstraction model comprising a plurality of logical field definitions mapping the logical fields to physical fields of a database, wherein the first logical field comprises a plurality of conditions for determining whether a second logical field having a first value will have a predefined second value in the future, the plurality of conditions comprising a precursor condition indicating the predefined second value. The method further comprises executing the abstract query, wherein the execution comprises retrieving results that satisfy the plurality of conditions for determining whether the second logical field will have the predefined second value in the future.","Another embodiment of the invention provides a computer readable storage medium comprising a program product which, when executed by a processor, is configured to perform an operation for retrieving query results. The operation generally comprises receiving an abstract query comprising at least one first logical field defined in a data abstraction model comprising a plurality of logical field definitions mapping the logical fields to physical fields of a database, wherein the first logical field comprises a plurality of conditions for determining whether a second logical field having a first value will have a predefined second value in the future, the plurality of conditions comprising a precursor condition indicating the predefined second value. The operation further comprises executing the abstract query, wherein the execution comprises retrieving results that satisfy the plurality of conditions for determining whether the second logical field will have the predefined second value in the future.","Yet another embodiment of the invention provides a system comprising a memory comprising a program for executing queries and a processor. The processor, when executing the program is generally configured to receive an abstract query comprising at least one first logical field defined in a data abstraction model comprising a plurality of logical field definitions mapping the logical fields to physical fields of a database, wherein the first logical field comprises a plurality of conditions for determining whether a second logical field having a first value will have a predefined second value in the future, the plurality of conditions comprising a precursor condition indicating the predefined second value. The processor is further configured to execute the abstract query, wherein the execution comprises retrieving results that satisfy the plurality of conditions for determining whether the second logical field will have the predefined second value in the future.","Embodiments of the present invention are generally related to data processing, and more specifically to retrieving data from a database. An abstract query may include query conditions and a first logical field comprising conditions for determining whether a second logical field will have a predefined value in the future. Upon execution, the abstract query may return results that satisfy the conditions for determining whether the second logical field will have the predefined value.","In the following, reference is made to embodiments of the invention. However, it should be understood that the invention is not limited to specific described embodiments. Instead, any combination of the following features and elements, whether related to different embodiments or not, is contemplated to implement and practice the invention. Furthermore, in various embodiments the invention provides numerous advantages over the prior art. However, although embodiments of the invention may achieve advantages over other possible solutions and\/or over the prior art, whether or not a particular advantage is achieved by a given embodiment is not limiting of the invention. Thus, the following aspects, features, embodiments and advantages are merely illustrative and are not considered elements or limitations of the appended claims except where explicitly recited in a claim(s). Likewise, reference to \u201cthe invention\u201d shall not be construed as a generalization of any inventive subject matter disclosed herein and shall not be considered to be an element or limitation of the appended claims except where explicitly recited in a claim(s).","One embodiment of the invention is implemented as a program product for use with a computer system. The program(s) of the program product defines functions of the embodiments (including the methods described herein) and can be contained on a variety of computer-readable storage media. Illustrative computer-readable storage media include, but are not limited to: (i) non-writable storage media (e.g., read-only memory devices within a computer such as CD-ROM disks readable by a CD-ROM drive) on which information is permanently stored; (ii) writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive) on which alterable information is stored. Such computer-readable storage media, when carrying computer-readable instructions that direct the functions of the present invention, are embodiments of the present invention. Other media include communications media through which information is conveyed to a computer, such as through a computer or telephone network, including wireless communications networks. The latter embodiment specifically includes transmitting information to\/from the Internet and other networks. Such communications media, when carrying computer-readable instructions that direct the functions of the present invention, are embodiments of the present invention. Broadly, computer-readable storage media and communications media may be referred to herein as computer-readable media.","In general, the routines executed to implement the embodiments of the invention, may be part of an operating system or a specific application, component, program, module, object, or sequence of instructions. The computer program of the present invention typically is comprised of a multitude of instructions that will be translated by the native computer into a machine-readable format and hence executable instructions. Also, programs are comprised of variables and data structures that either reside locally to the program or are found in memory or on storage devices. In addition, various programs described hereinafter may be identified based upon the application for which they are implemented in a specific embodiment of the invention. However, it should be appreciated that any particular program nomenclature that follows is used merely for convenience, and thus the invention should not be limited to use solely in any specific application identified and\/or implied by such nomenclature.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1","b":["100","100","101","101","102","102","101","102","140","140","140"]},"The client computer  includes a Central Processing Unit (CPU)  connected via a bus  to a memory , storage , an input device , an output device , and a network interface device . The input device  can be any device to give input to the client computer . For example, a keyboard, keypad, light-pen, touch-screen, track-ball, or speech recognition unit, audio\/video player, and the like could be used. The output device  can be any device to give output to the user, e.g., any conventional display screen. Although shown separately from the input device , the output device  and input device  could be combined. For example, a display screen with an integrated touch-screen, a display with an integrated keyboard, or a speech recognition unit combined with a text speech converter could be used.","The network interface device  may be any entry\/exit device configured to allow network communications between the client computers  and server  via the network . For example, the network interface device  may be a network adapter or other network interface card (NIC).","Storage  is preferably a Direct Access Storage Device (DASD). Although it is shown as a single unit, it could be a combination of fixed and\/or removable storage devices, such as fixed disc drives, floppy disc drives, tape drives, removable memory cards, or optical storage. The memory  and storage  could be part of one virtual address space spanning multiple primary and secondary storage devices.","The memory  is preferably a random access memory sufficiently large to hold the necessary programming and data structures of the invention. While memory  is shown as a single entity, it should be understood that memory  may in fact comprise a plurality of modules, and that memory  may exist at multiple levels, from high speed registers and caches to lower speed but larger DRAM chips.","Illustratively, the memory  contains an operating system . Illustrative operating systems, which may be used to advantage, include Linux (Linux is a trademark of Linus Torvalds in the US, other countries, or both) and Microsoft's Windows\u00ae. More generally, any operating system supporting the functions disclosed herein may be used.","Memory  is also shown containing a query program  which, when executed by CPU , provides support for issuing queries to server . In one embodiment, the query program  may include a web-based Graphical User Interface (GUI), which allows the user to display Hyper Text Markup Language (HTML) information. The GUI may be configured to allow a user to create a query, issue the query against a server , and display the results of the query. More generally, however, the query program may be any GUI-based program, for example, a browser, capable of rendering any information transferred between the client computer  and the server .","The server  may by physically arranged in a manner similar to the client computer . Accordingly, the server  is shown generally comprising at least one CPU , memory , and a storage device , coupled with one another by a bus . Memory  may be a random access memory sufficiently large to hold the necessary programming and data structures that are located on server . The server  may generally be under the control of an operating system  shown residing in memory . Examples of the operating system  include IBM OS\/400\u00ae, UNIX, Microsoft Windows\u00ae, and the like. More generally, any operating system capable of supporting the functions described herein may be used.","The memory  further includes one or more applications  and an abstract query interface . The applications  and the abstract query interface  are software products comprising a plurality of instructions that are resident at various times in various memory and storage devices in the computer system . When read and executed by one or more processors  in the server , the applications  and the abstract query interface  cause the computer system  to perform the steps necessary to execute steps or elements embodying the various aspects of the invention.","In one embodiment, the applications  (and more generally, any requesting entity, including the operating system ) may be configured to issue queries against a database  (shown in storage ). The database  is representative of any collection of data regardless of the particular physical representation. By way of illustration, the database  may be organized according to a relational schema (accessible by SQL queries) or according to an XML schema (accessible by XML queries). However, the invention is not limited to a particular schema and contemplates extension to schemas presently unknown. As used herein, the term \u201cschema\u201d generically refers to a particular arrangement of data.","In one embodiment, the queries issued by the applications  are defined according to an application query specification  included with each application . The queries issued by the applications  may be predefined (i.e., hard coded as part of the applications ) or may be generated in response to input (e.g., user input). In either case, the queries (referred to herein as \u201cabstract queries\u201d) are composed using logical fields defined by the abstract query interface . In particular, the logical fields used in the abstract queries are defined by a data abstraction model  of the abstract query interface . Abstract queries are executed by a runtime component  which may transform the abstract queries into a form consistent with the physical representation of the data contained in the database . The application query specification  and the abstract query interface  are further described with reference to .","In one embodiment, elements of a query are specified by a user through a graphical user interface (GUI). The content of the GUIs may be generated by the application(s) . In a particular embodiment, the GUI content is hypertext markup language (HTML) content which may be rendered on the client computer systems  with query program . For example, the server  may respond to requests to access a database , which illustratively resides on the server . Incoming client requests for data from the database  may invoke an application . When executed by the processor , the application  may cause the server  to perform the steps or elements embodying the various aspects of the invention, including accessing database .",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2","b":["200","140","202","142","202","127","142"]},"The logical fields specified by the application query specification  and used to compose the abstract query  are defined by the data abstraction model . In general, the data abstraction model  may expose information as a set of logical fields that may be used within a query (e.g., the abstract query ) issued by the application  to specify criteria for data selection and specify the form of result data returned from a query operation. The logical fields may be defined independently of the underlying data representation being used in the database , thereby allowing queries to be formed that are loosely coupled to the underlying data representation.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 3","FIG. 3"],"b":["148","148","308","310","312","310","312"],"i":["a ","a "]},"The access methods may associate logical field names  to a particular physical data representation  (See ) in a database . By way of illustration, two data representations are shown in , an XML data representation , and a relational data representation . However, the physical data representation indicates that any other data representation, known or unknown, is contemplated. In one embodiment, a single data abstraction module  may contain field specifications with associated access methods for two or more physical data representations . In an alternative embodiment, a separate data abstraction module  may be provided for each separate data representation .","Any number of access methods is contemplated depending upon the number of different types of logical fields to be supported. In one embodiment, access methods for simple fields, filtered fields and composed fields are provided. For example, field specifications for Field A exemplify a simple field access method . Simple fields are mapped directly to a particular entity in the underlying physical data representation (e.g., a field mapped to a given database table and column). By way of illustration, the simple field access method , shown in  maps the logical field name (\u2018Diagnosis\u2019) to a column named \u201cDisease\u201d in a table named \u201cTest Table,\u201d as illustrated.","The field specification for Field X exemplifies a filtered field access method . Filtered fields identify an associated physical entity and provide rules used to define a particular subset of items within the physical data representation. For example, the filtered field access method may map the logical field name to a physical entity in a column named \u201cTestVal\u201d in a table named \u201cTest Table\u201d and may define a filter for the test values. For example, in one embodiment, the filter may define a numerical range in which the test values may be deemed valid.","A composed field access method may also be provided to compute a logical field from one or more physical fields using an expression supplied as part of the access method definition. In this way, information which does not exist in the underlying data representation may be computed. For example, a sales tax field may be composed by multiplying a sales price field by a sales tax rate.","It is contemplated that the formats for any given data type (e.g., dates, decimal numbers, etc.) of the underlying data may vary. Accordingly, in one embodiment, the field specifications  may include a type attribute which reflects the format of the underlying data. However, in another embodiment, the data format of the field specifications  is different from the associated underlying physical data, in which case an access method is responsible for returning data in the proper format assumed by the requesting entity.","Thus, the access method must know what format of data is assumed (i.e., according to the logical field) as well as the actual format of the underlying physical data. The access method may then convert the underlying physical data into the format of the logical field. By way of example, the field specifications  of the data abstraction model  shown in  are representative of logical fields mapped to data represented in the relational data representation . However, other instances of the data extraction model  map logical fields to other physical data representations, such as XML.","For purposes of illustration, the data abstraction model  is assumed herein to be associated with a hospital database including patient records. While querying of a hospital database is described herein, embodiments of the invention are not limited to querying of hospital databases. Embodiments of the invention may be used advantageously for querying any type of database containing any nature of information. The patient records in a hospital database may be accessed by health care professionals for diagnosing diseases, conducting research, and the like. For example, a researcher may want to identify diabetic patients while conducting research. Accordingly, the researcher may compose a query including Field A (Diagnosis). For example, the query may request results for patients where Diagnosis=Diabetic.","While the above described query is configured to return data for patients that have already been diagnosed as diabetic, in some cases, the researcher or a doctor may want to identify patients that are at risk of becoming diabetic in the future. By identifying such patients, preventive measures may be suggested to the patient. Such data may also be useful, for example, in determining particular medication that is used to treat the patient for another ailment. For example, potential future diabetic patients suffering from an ailment may be prescribed different medication as compared to non-diabetic patients.","In one embodiment of the invention, the data abstraction model  may include fields that determine an expected future condition of another field. For example,  illustrates a \u201cFuture Diabetics\u201d field for determining patients at risk of developing diabetes. As illustrated in , the future diabetics field may include a precursor condition . The precursor condition  may identify the future condition that is to be determined. For example, in , the precursor condition for the future diabetics field is shown as \u201cDiagnosis=Diabetic\u201d. In other words, the precursor condition  indicates that the field is configured to retrieve results for patients that are at risk of being diagnosed as diabetics in the future.","Any reasonable future condition or set of conditions may be included as the precursor condition . The precursor condition  may include any reasonable operator, for example, equal to, greater than, less than, greater than and equal to, less than and equal to, not equal to, and the like. Furthermore, the precursor condition may be configured to compare values in one or more desired fields in the data abstraction model  to any one of integers, floating point numbers, Boolean values, strings, and the like. For example, another exemplary precursor condition  may include the condition: DiabetesTestValue[[I]]>250.","In one embodiment of the invention, the access method for fields that determine an expected future condition may be a composed access method. The composed access method may be used to determine whether data from one or more other fields of the data abstraction model  indicate that a patient will develop diabetes in the future. For example, the future diabetics field in  includes a composed access field including a list of predictor conditions (or factors)  (shown as factors1-n) factors  may determine whether the expected future condition as defined by the precursor condition  is expected to occur. For example, determining whether a patient is at risk for developing diabetes may involve determining a history of diabetes in the patient's family, the patient's weight, smoking habits, and the like. Accordingly, the factors  may investigate fields relevant to the patient's family history, weight, smoking habits, and the like.","By providing a field that includes factors for determining a potential future value of another field, embodiments of the invention allow the normalization of the factors. For example, in the hospital organization, it may be desirable to have a uniform set of factors for determining whether a patient is at risk of developing diabetes in the future. The uniform list of factors may be captured in the future diabetics field . Therefore, all users of system  may use the same factors to identify future diabetics by using the future diabetics field in their respective queries.","For the purposes of this example, a patient is assumed to be at risk of becoming diabetic if the patient's father is diabetic, if the person's mother is diabetic, or if the person's weight is greater than 250 pounds. Therefore, the factors  may include:\n\n","In one embodiment of the invention, if any one of the factors 1-3 above are true, a patient may be determined to be a future diabetic. Accordingly, the factors 1-3 may be combined using an OR operator. In other words, the factors  may be: (Father's diagnosis=diabetic) OR (Mother's diagnosis=diabetic) OR (Weight>250). In another embodiment, all three factors may have to be true for a patient to be determined as a future diabetic. Accordingly, the factors  may be: (Father's diagnosis=diabetic) AND (Mother's diagnosis=diabetic) AND (Weight>250).","While relating the factors using one of AND and OR operators is described above, alternative embodiments may use any other reasonable means for relating the conditions. For example, in one embodiment a combination of AND and OR operators may be used to relate the factors . In another embodiment, a case statement may be used to relate the factors  with one another. The case statement may test each of the factors  serially. If any one of the factors is true, the case statement may stop testing further factors and determine that the precursor condition is likely to occur in the future.","Included below is an exemplary abstract query (referred to hereinafter as query 1) which uses the future diabetics field :",{"@attributes":{"id":"p-0052","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT Patients, Future Diabetics"]},{"entry":[{},"FROM Test_Table"]},{"entry":[{},"WHERE Age<30"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The query above retrieves data for patients less than the age of thirty that are at risk of becoming diabetic in the future from a table named Test_Table.","In one embodiment of the invention, while processing an abstract query, the runtime component  may be configured to combine conditions of the abstract query with precursor condition  and the factors  prior to transforming the abstract query into a form consistent with the physical representation of the data contained in a database. For example, the above abstract query may be combined as follows:",{"@attributes":{"id":"p-0055","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(Diagnosis \u2260 Diabetes) AND [(Father's diagnosis = diabetic) AND"},{"entry":"(Mother's diagnosis = diabetic)] AND (Weight > 250)] AND (Age<30)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The query above which is formed by combining the conditions of the abstract query with the precursor condition  and the factors  is hereinafter referred to as a combined query. A first portion (Diagnosis\u2260Diabetes) of the combined query above corresponds to the precursor condition. As can be seen above, the precursor condition has been negated. In other words, the precursor condition  which is shown as (Diagnosis=Diabetes) in  has been changed to (Diagnosis\u2260Diabetes). The precursor condition may be negated so that the query results do not include patients that are already diagnosed as diabetic.","For example, the database may include patients that are already determined to be diabetic that meet the conditions . Because only results for patients that are not currently diabetic, but likely to become diabetic in the future is desired, a negated precursor condition is included to remove patients that are already diabetic from the query results.","Negating the precursor condition may generally involve changing one or more comparison operators in the precursor condition. For example, negation of the precursor condition  in  involves changing an \u2018equal to\u2019 comparison operator to a \u2018not equal to\u2019 operator. In other embodiments, negation may include, for example, changing a \u2018greater than an equal to\u2019 operator to a \u2018lesser than\u2019 operator, and vice versa, changing a \u2018greater than\u2019 operator to a \u2018lesser than and equal to\u2019 operator, and vice versa, and the like.","In one embodiment, the precursor condition  may be already negated in the future diabetics field . In other words, the precursor condition may be (Diagnosis\u2260Diabetes) in one embodiment. Therefore, in embodiments where the precursor condition is already negated in a field of the data abstraction model, the runtime component  may simply include the precursor condition without negation in the combined query.","A second portion of the combined query above may include the factors  that are related in a predefined manner, as described above. For example, the factors [(Father's diagnosis=diabetic) AND (Mother's diagnosis=diabetic)] are shown in the combined query above. A third portion of the combined query (Age<30) may include conditions defined in the received abstract query. In the combined query above, the first, second, and third portions of the combined query are combined with an AND operator. In alternative embodiments, any combination of AND and OR operators may be used to combine the first, second, and third portions.","In one embodiment of the invention, it may be determined that a future condition defined by the precursor condition will occur if a predefined number of factors of a plurality of factors  are determined to be present. A factor may be present if a condition defined by the factor is determined to be true. For example, the future diabetics field may include the three factors provided above. In one embodiment of the invention, a patient may be determined to be a future diabetic of a predetermined number (for example, two) of factors of the three factors are present.","In one embodiment of the invention, a logical field definition such as the logical field may include a call to a function configured to analyze the one or more factors . The runtime component  may be configured to invoke the function during execution of an abstract query comprising the logical field. In one embodiment, the function may be configured to determine a number of factors that are present. For example, the run time component may form the following combined query in response to receiving query 1 above:",{"@attributes":{"id":"p-0063","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(Diagnosis \u2260 Diabetes) AND [FactorCount(Father's diagnosis,"]},{"entry":[{},"Mother's diagnosis, Weight)\u22672] AND (Age<30)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As illustrated above, the combined query includes a call to a function FactorCount( ). The function FactorCount( ) may be configured to determine a number of factors of a plurality of factors  that are present. As can be seen in the combined query above, the function FactorCount( ) receives as an input, values associated with the plurality of factors . Exemplary pseudocode for the function FactorCount( ) is provided below:",{"@attributes":{"id":"p-0065","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"count=0"]},{"entry":[{},"If Father's diagnosis = diabetic then count = count+1"]},{"entry":[{},"If Mother's diagnosis = diabetic then count = count+1"]},{"entry":[{},"If Weight > 250 then count = count+1"]},{"entry":[{},"Return count"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The function FactorCount( ) returns the value of count which may be compared to a predefined number (for example, two, in the exemplary combined query above). If the count is greater than or equal to the predefined number, it may be possible that the patient is a future diabetic. In other embodiments, any reasonable comparison operator including greater than, equal to, less than, less than or equal to, or the like may be used to compare the count value returned from the function FactorCount( ) to the predefined number.","In one embodiment, each factor  may have a predefined weight value. Therefore, in some embodiments, the weight values of present factors may determine whether a patient is a future diabetic or not. Exemplary weight values for the three exemplary factors described above are provided below:\n\n","In one embodiment, a patient may be determined to be a future diabetic if the sum of weights of the present factors is greater than or equal to a predefined value. For example, a patient may be determined to be a future diabetic if the sum of the weights of factors present with respect to the patient is greater than or equal to 5.","In one embodiment of the invention, the run time component  may be configured to call a function that is configured to determine the sum of weights of present factors while executing a combined query. An exemplary combined query including a call to a function TotalWeight( ) configured to determine the total weight of the present factors is provided below:",{"@attributes":{"id":"p-0070","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(Diagnosis \u2260 Diabetes) AND [TotalWeight(Father's diagnosis,"]},{"entry":[{},"Mother's diagnosis, Weight)\u22675] AND (Age<30)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Exemplary pseudocode for the function TotalWeight( ) is provided below:",{"@attributes":{"id":"p-0072","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"totweight=0"},{"entry":"If Father's diagnosis = diabetic then totweight = totweight+Father's"},{"entry":"\u2003\u2003\u2003\u2003diagnosis weight"},{"entry":"If Mother's diagnosis = diabetic then totweight = totweight +Mother's"},{"entry":"\u2003\u2003\u2003\u2003diagnosis weight"},{"entry":"If Weight > 250 then totweight = totweight +Weight's weight"},{"entry":"Return totweight"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In the exemplary pseudocode above the Father's diagnosis weight, Mother's diagnosis weight, and Weight's weight correspond to the exemplary weight values for the three exemplary factors described above.","In alternative embodiments, an average weight of present factors may be compared to a predefined value instead of calculating a total weight. In some embodiments of the invention, the runtime component  may call a plurality of functions, for example, the FactorCount( ) and Total Weight( ) functions. Accordingly, in some embodiments, whether a patient is determined to be a future diabetic or not may depend on a total number of factors present and the weight of the factors.","After forming the combined query, the runtime component  may transform the combined query into a form consistent with the physical representation of the data contained in the database , and retrieve results for the query. In one embodiment of the invention, the runtime component  may be configured to order the retrieved results based on a predetermined criteria. For example, in one embodiment, the runtime component  may be configured to order the results based on decreasing total weight (or factor count) values.",{"@attributes":{"id":"p-0076","num":"0081"},"figref":"FIG. 4","b":["150","410","315","316","420","430"]},"By providing a logical field capable of determining whether a second logical field will have a predefined value in the future, embodiments of the invention facilitate retrieval of query results based on expected future values of the second logical field.","While the foregoing is directed to embodiments of the present invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof, and the scope thereof is determined by the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features, advantages and objects of the present invention are attained and can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to the embodiments thereof which are illustrated in the appended drawings.","It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
