---
title: Software component architecture
abstract: Methods and apparatus, including computer program products, implement techniques for structuring applications into reusable components. A reusable software component is implemented. The component encapsulates functionality, where multiple instances of the component are usable at the same time. The component has at least one visual representation. The component has a programming interface for programmatic interaction with the component, a data-binding interface for data communication with the component, and a visual interface to access the at least one visual representation of the component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07409692&OS=07409692&RS=07409692
owner: SAP AG
number: 07409692
owner_city: Walldorf
owner_country: DE
publication_date: 20030930
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","FIRST EXAMPLE","SECOND EXAMPLE"],"p":["The present invention relates to electronic data processing in general, and particularly to application programming.","Applications can be developed using various architectures, including, for example, a model-view-controller (MVC) architecture. The MVC architecture breaks an application into three separate parts\u2014models, views, and controllers. Each model can have multiple views, where each view displays information about the model to a user. A controller of the model receives events, for example, raised by a user interacting with a view to manipulate the model. Each model can have multiple controllers, and a controller can relate to multiple views. The models and the controllers typically include application code. When changes occur in a model, the model updates its views. Data binding is used for data transport between the view and its model or controller. For example, a table view can be defined to display data of a corresponding table that is stored in the model or controller. The table is used as the data source for the table view (data binding). For example, the table view can be replaced by a further view, such as a graph view, that binds against the same table. In this case, the further view displays the table data without changing anything in the controller or the model.","Application development is often divided into two general stages: design time and runtime. Design time can include designing the views of an application (including the layout of the user interface (UI) elements in each view), modeling of the application flow (including the selection of the views to displayed), designing one or more models, and creating and editing other application elements, such as controllers and contexts. Design time can also include the binding of UI elements within the views to data sources that are defined in a data type repository.","Information created during the design time can include application metadata. Application metadata can be stored in a metadata repository, and used as input to the runtime process. During the runtime process, the application metadata can be used to generate the actual runtime code of an application. In some implementations, the application metadata is platform independent, and the generated runtime code is platform specific. The runtime code can be executed in a runtime environment that provides a general framework for running applications. For example, a runtime environment can provide services for deploying and maintaining applications, as well as features such as a caching mechanism that can be used to improve performance, and automatic input assistance and default error handling that is based on the declared application metadata.","Regardless of which architecture is used, it is often desirable to structure an application (including, for example, the models, views, and controllers that make up an MVC application) into reusable entities or components. The reusable components can be embedded by the application, or by another reusable component.","In general, in one aspect, the invention provides methods and apparatus, including computer program products, implementing techniques for structuring applications into reusable components. The techniques include implementing a reusable software component encapsulating functionality, where multiple instances of the component are usable at the same time. The component has at least one visual representation. The component has a programming interface for programmatic interaction with the component, a data-binding interface for data communication with the component, and a visual interface to access the at least one visual representation of the component.","Advantageous implementations of the invention include one or more of the following features. The programming interface, the data-binding interface, and the visual interface can be separate interfaces. One or more controllers can be implemented for the component, each controller having an associated context for storing data and state for the controller. One or more views can be implemented for the component, each view providing a visual representation of the component. A sub-component can be embedded in the component. The sub-component can be embedded using a programming interface, a data-binding interface, and a visual interface of the sub-component. The programming interface can include an interface controller having an associated interface controller context and a configuration controller having an associated configuration controller context, the visual interface can include an interface view, and the data-binding interface can provide context mapping for an interface controller context and a configuration context.","In another aspect, the invention provides methods and apparatus, implementing techniques for implementing an application runtime framework. A component interface to be used in an application is received without a specification of a corresponding component implementation. A particular component implementation can be instantiated at runtime, where the particular component implementation is selected from one or more component implementations corresponding to the component interface.","Advantageous implementations of the invention also include a component interface having a programming interface, a data-binding interface, and a visual interface.","In another aspect, the invention provides methods and apparatus, implementing techniques for implementing an application runtime framework. An event subscription for a subscribing component is received, where the event subscription specifies one or more events generated by sub-components embedded by the subscribing component. If the subscribing component has not been instantiated, any events generated by the sub-components that are specified by the event subscription are cached. The cached events are forwarded to an instance of the subscribing component after the subscribing component has been instantiated.","In another aspect, the invention provides methods and apparatus, implementing techniques for implementing an application runtime framework. One or more context mappings for a component are received, where the context mappings are specified by a component embedder using the component to exchange data with the component. If the component has not been instantiated, the specified context mappings are cached. The specified context mappings are created after the component has been instantiated.","The invention can be implemented to realize one or more of the following advantages. An application development framework provides support for developing software components and managing multiple instances of such components. An application can use multiple instances of a component, and components can be used in multiple applications. Developers do not need to write code to manage multiple component instances.","Components can contain multiple controllers, and storage areas known as contexts. Components can present multiple views. Each component can be accessed through multiple interfaces, including an application programming interface (API), a data binding interface, and a visual interface.","The API can be implemented in an interface controller that is used to interact with the component. Components can also include other types of controllers, including configuration controllers (used to access configuration data, which can be provided at runtime), view controllers (used to implement functionality for views), component controllers (used to implement common functionality required for multiple views), and custom controllers (used to implement application functionality). Each controller can have an associated context, and the controllers can share data by mapping data elements from one context to another context. The data binding interface is used to access the associated contexts of the controllers of the component. The view interface can be used to access the views of the component.","Components can be embedded in other components, thus creating hierarchical arrangements of components. A component embedder that embeds a component can use the visual representations of the embedded component\u2014that is, the arrangement of views for a component can include views from embedded components.","Configuration data for a component can be provided by a component embedder at runtime, when the component is instantiated. Application programmers can program against a component interface at design time without specifying a component implementation that implements the component interface, and the component interface can be resolved to a component implementation implementing the component interface at runtime. Components can subscribe to and act on events from embedded components. If there are no instances of a subscribing component, events can be cached and delivered to instances of the subscribing component when they are created. One implementation of the invention provides all of the above advantages.","The details of one or more implementations of the invention are set forth in the accompanying drawings and the description below. Further features, aspects, and advantages of the invention will become apparent from the description, the drawings, and the claims.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 1","b":["100","105","110","100","110","115","120","125","110","100","105"]},"At runtime, the application runs within a runtime framework that provides the code required to create and manage the instances of the components used by the application program . As discussed below, the services provided by the runtime framework include component lifecycle management and managing component event subscriptions.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2A","b":["200","200","200","200","200","200"]},"The component  provides three separate interfaces-a programming interface , a data binding interface , and a visual interface . The programming interface  is used by the component embedder (by controller usage ) to interact with the component . The component interface is an active component. The component interface is not just a signature. The component interface defines the component methods that are visible to the component embedder and routes the visible method calls to one or more component implementations. The component embedder embeds the component  by programming to the programming interface , i.e., the component embedder can call the methods provided by the programming interface . In one implementation, the programming interface  can be provided by a controller, referred to as a component interface controller. Thus a component embedder can interact with an embedded component through the interface controller of the embedded component.","The component  also has one or more visual representations (which will be referred to as views). As described below, a component embedder can access and use the visual representations of the component  (for example, to form its own visual representations in view composition ) through a visual interface .","The data binding interface , described below, is used by a component embedder to exchange data with the component .","In one implementation, the component  includes one or more controllers, one or more associated contexts, and optionally one or more views. The controllers are used to implement the logic of the component, and the views provide a visual representation of the component. A component can include multiple types of controllers, as explained below. The controllers implement event handlers that are executed in response to an action performed by a user, e.g., pressing a button or making a menu selection. Each controller is bound to an associated context. A context is a local data structure for a controller that stores data and state specific to the controller.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 2B","b":["200","205","200","220","230","220","200","230","200","220","225","220","230","235","200","210","225","235","235","200","200"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 4","b":["400","405","405","410","415","400","400","400"]},"The visual interface can have more than one view, of which only some views are visible at any time. The views that are visible in the visual interface can change, e.g., the views that are visible can change in response to input from the user. Inbound plugs, outbound plugs, and navigation links are design time constructs that are used by application developer to specify transitions between the views. Each view has an inbound plug  and an outbound plug . At design time, each navigation link establishes a potential transition from the view with the outbound plug  to the view with the inbound plug . At design time, a transition from a first view to a second view is specified by connecting the outbound plug  of the first view to the inbound plug of the second view. The navigation links are processed at runtime to cause the view transitions specified at design time. At run time, the application calls the outbound plug of the first view to cause a transition from the first view to the second view.","Each inbound plug  includes an application specific event handler, and calling the inbound plug results in running the event handler for the inbound plug  before displaying the view  corresponding to the inbound plug . Navigation links are typically processed in a runtime framework by calling all the inbound plugs  connected to an outbound plug  when the outbound plug  is called. The event handler for an inbound plug  can call the outbound plug  for the view corresponding to the inbound plug to cause other views connected to the outbound plug  to be displayed. The application can use the event handler for the inbound plug  to initialize the corresponding view, e.g., the corresponding view can be initialized based on why the view is being displayed.","The view  can have an associated view controller that includes the event handlers associated with the inbound plug. The view controller also contains event handlers for the UI elements in the view as well as the presentation logic for the view.","The application or a reusable component can specify any number of views at design time, any of which can be displayed at runtime. The set of views that can be displayed, for the application or the component, is referred to as the view composition. A view assembly is the set of views that are actually displayed at runtime. The view assembly, for an application or a component, consists of views in the view composition that selected for display at a certain point in time. When a navigation link is processed at runtime, a view in a current view assembly may be replaced by one or more destination views from the view composition.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 5","b":["500","505","510","515","505","500","505","515","520","510","525","530","515","535","540","520","525","545","520","535","550","505","520","520","510","515","500","505"]},"Applications can make use of components that contain view compositions. Components can embed other components, such that a first component can interact and make use of a second, embedded, component. The view composition of the first component can include views of the second component. Similarly the view composition of the application can include views of the components used by the application. In addition, an application developer can design application specific views that are part of the application's view composition.","A component developer designates one of the views in the view composition  of the component as an interface view . The interface view , and the associated inbound plug and outbound plug, are the visual interface for the component . At design time, the component embedder can use navigation links to specify view transitions to the interface views  of embedded components  like any other view in the view composition of the component embedder. A component can present more than one visual interface by defining more than one interface view.","Each view has a view controller and a view context associated with the view controller. The view controller implements presentation logic implemented by the view such as triggering events in response to user interaction with user interface elements in the view. The view context stores data and state associated with the view controller. The view context can be used to communicate data between the view and any controller of the component  by mapping the view context to the context of the controller.","Referring to  the component  can also include a component controller  that implements common functionality required by views implemented by the component. The component controller receives control when the component is instantiated, after the component instance has been initialized. The component controller  has an associated component context  for storing data and state for the component controller. The component  can also include one or more custom controllers , and associated contexts . The custom controllers  and associated contexts  are used to implement and structure functionality and data storage for the component .","The component embedder interacts with the embedded component  by using the programming interface , the data binding interface , and the visual interface . The embedded component  can interact with the component embedder by generating events.","The component embedder can subscribe to events generated by the embedded component , and react to such events.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 3","FIG. 3"],"b":["310","300","200","300","200","300","200","300","200","300","305","105","305"]},"Component usage object  provides life-cycle management of the associated component  by providing methods for creating and deleting component instances  of the associated component  at runtime. The life-cycle of the component instance  is controlled by the component embedder . At design time an application programmer programs using a programming interface for a component without specifying a particular implementation of the component. The component programming interface used by the application programmer at design time is bound to a component implementation that provides the programming interface at run time. At run time, the component embedder  creates the component instance , implementing the component programming interface used by the component embedder, by calling the methods provided by the component usage object . The component usage object  responds to requests to create a component instance by selecting a component in the repository  that implements the desired programming interface and creating an instance of the selected component. Alternatively, if the application programmer specifies a component implementation at design time, an instance of the specified component can be created and used at runtime.","The runtime framework uses component usage object  to access the programming interface of the associated component. The component usage object  is also used to manage event subscriptions for the associated component. In an implementation where a component embedder can subscribe to events generated by embedded components, the component usage object  caches the event subscriptions for subscribing component, if there is no instance of the subscribing component (because the subscribing component has not been created or because it has been deleted). In such a situation, the event subscriptions are delivered to the subscribing component when the subscribing component is instantiated. Component usage object  includes a context mapper  that maintains context mappings between the embedder context  of the component embedder  and the component instance . The component usage object  caches specified context mappings for a component that has not been instantiated, and creates the specified context mappings for the component after the component has been instantiated.","Context is a local data structure for a controller that stores data and state specific to the controller. Controllers within a component, i.e., the interface controller, the configuration controller, the component controller, custom controllers, and view controllers, communicate data by mapping contexts. Similarly, the data binding interface allows the component embedder  to communicate data with the embedded component  by mapping the interface context  and the configuration context  using the context mapper .",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 6","b":"604"},"An example of a design time context structure is a node hierarchy, wherein the structure elements of the node hierarchy can be nodes and attributes. The root-node of the node hierarchy represents the context itself. For example, the child nodes of the root node can be defined by the application. Child nodes of the root node will also be referred to as independent nodes. Child nodes of independent nodes depend on their corresponding parent node and will also be referred to as dependent nodes.","A node has a node type. Examples of node types are value nodes and model nodes. A value node can maintain, that is, store and administrate, its own application data (transient application data). The data can be, for example, scalar data, tables or structures. A model node includes a reference to application data that persists in a corresponding model.","The parent node can also have attributes. Each child node can include an arbitrary tree structure that includes further child nodes and\/or attributes. Attributes are leaves in the tree structure. Attributes represent, for example, scalar data types, such as strings and integers or Java types (e.g., java.util.Date).","In the example of , at design time, the context  includes the independent node PN that includes the two attributes A, A and that is the parent node of the dependent nodes CN, CN. The second dependent node CN has two further attributes A, A. This structure defines a first node element  for the parent node PN and a second node element  for the second child node CN. The first node element  includes information about the context structure with regards to the parent node PN. In other words, it summarizes all information that is available at the context structure level that is under the level of the parent node PN. The second node element  includes information about the context structure with regards to the second dependent node CN. The context structure implies that the second node element  depends on the first node element .","At runtime, structure elements (e.g., nodes) represent a set of data instances. Nodes provide type information about object instances that are maintained by the node. Each node can have a node collection, wherein each element of the node collection has the same node element type.","In the example of , at runtime, the parent node PN has a first node collection  that includes multiple runtime instances of the first node element . Each runtime instance of the first node element  can have a second node collection  of multiple runtime instances of the second node element . A node collection can be empty or has at least one instance of the corresponding node element.","A node collection has a cardinality and a node collection type, such as list, tree, set, or collection. The node collection cardinality (see table 2) and the node collection type (see table 1) can be declared at design time. An evaluation mechanism can be used to automatically evaluate the node collection of a child node at runtime when its parent node changes.",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Examples of node collection types"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Value","Meaning"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Collection","forward-only iterator (cursor) without absolute positioning"]},{"entry":["Set","no duplicates, forward-only iterator without absolute"]},{"entry":[{},"positioning"]},{"entry":["List","duplicates allowed, position available, list iterator, absolute"]},{"entry":[{},"positioning (indexed access)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The application can use the cardinality of a node collection to restrict possible operations on a node (e.g., prohibit indexed access to a node that has at most one node collection element).",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Examples of the cardinality of a node collection"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Value","Meaning"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["0 . . . 1","node collection can be empty, contains at most one element"]},{"entry":["1 . . . 1","node collection always contains exactly one element."]},{"entry":["0 . . . n","node collection can be empty or contain any number of elements"]},{"entry":["1 . . . n","node collection always contains at least one element."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The content of a node collection can be determined in various ways.","The node values of independent nodes can be set by initializers or event handlers or can be set through a supply function. The supply function is called when the node is accessed. To access a node, for example, the node is queried for its data by application code or by a user interface (UI) element (of the view) that is bound to the node.","Dependent nodes can get their values by using a supply function. For example, the node collection of a dependent node can become obsolete when a selection of its parent node changes. In this case the dependent node is recalculated, that is, the content of its node collection is determined on a subsequent access. In another example a representation instance is created for each dependent node of a parent node. The values of the representation instances are calculated when the corresponding parent node is accessed. In other words, using representation instances enables a \u201cload data on demand\u201d or a \u201cunload data when not needed\u201d mechanism. Therefore, memory is used in an efficient manner.","The content of a node collection can also be explicitly set to a state, such as \u201cinvalid\u201d or \u201cunfilled\u201d. When the node is accessed the next time, the node collection content is determined again. This can be used to force a re-read of modified data when the modification (e.g., in the model) was not visible to the application runtime.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 7","b":["604","50","710","40","700","710","710","701","700","40","710","50","700","604","701"]},{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 8"},"Because UI elements (e.g., UI elements , ) of views (e.g., VIEW , VIEW ) that are used in a user interface (UI)  bind ,  to view contexts (e.g., VIEW CONTEXT , VIEW CONTEXT ) and long persisting data can reside in custom contexts (e.g., CUSTOM CONTEXT I), an embodiment of the present invention enables mapping ,  of nodes\/attributes of view contexts or custom contexts to nodes\/attributes of custom contexts. In other words, nodes and attributes of view contexts or custom contexts can reference type-compatible nodes and attributes in other custom contexts. Nodes can also be mapped to other nodes within the same context. Node mapping reduces the need for copying data between several contexts by enabling a node N of a first context (e.g., a view context, such as VIEW CONTEXT , or a custom context) to reference  a node N\u2032 of a second context (e.g., a custom context, such as CUSTOM CONTEXT I, or an application context), where the node N\u2032 of the second context has or references the data. The same is true for attributes.","Therefore, the data can be manipulated in a custom\/application context and each view context that references the custom\/application context provides its view with the current data stored in the custom\/application context. Mapping contexts can span multiple context levels. That is, a custom context can reference a further custom context. Therefore, context hierarchies can be created (see ).","For example, related data can be collected in a dedicated custom context. The binding to this data is implemented by using a view context that is mapped to the custom context accordingly.","The extended MVC pattern enables an application developer to quickly modify an application while maintaining consistency of the application. For example, in some cases rearrangement of views or UI elements can be achieved without modifying the corresponding controller code. This provides a way for an application developer to better structure applications in light of potential functional enhancements or changes. For example, reusing a field that already exists on one view in other views can be achieved by defining the corresponding mapping while the corresponding controller code stays valid.","The following examples explain various features of context mapping that can be implemented with the present invention.","If a node M (\u201cMapped Node\u201d) is mapped to a node O (\u201cOrigin Node\u201d), node M maps its node collection to node O's node collection. The node selections of nodes M and O can be mapped. Node M can also maintain its own node selection on node O's node collection.","For example, the node collection cardinality of node M equals that of node O (e.g., by inheritance).","The selection cardinality can be inherited from origin node O. Node M can override the node cardinality inherited from node O.","If node O is a singleton node, node M is a singleton node, too. If node O is a non-singleton node, node M can be a singleton or non-singleton node. If node M is a non-singleton node it shares the same parent node collection with node O. If node M is a singleton node, then the collection of node M follows the instance of node O that belongs to the lead selection of node O's parent node.","For mapped nodes, the content of the node collection can be defined by the node collection of the origin node.","An independent node can always be mapped. It can be mapped to any other node in the same context or to any other node in another custom context (as long as no cycle is formed with regards to parent-child and mapping relationships).","A child node of a mapped node can be unmapped. In this case its content can be determined by the supply function mechanism.","When a parent node is mapped to a further parent node, a child node of the parent node can be mapped to a further child node of the further parent node. In other words, if node W is a child of node X and node Y is a child of node Z, node W can be mapped to node Y if node X is mapped to node Z.","If a child node of a mapped node is mapped to a further child node of the corresponding origin node, then either the mapped node maps to the node selection of the origin node or the origin node is a non-singleton node. This avoids a conflict between the dependencies implied by the parent\/child relationship and the mapping relationship that results from mapping a selection of a child node of an unmapped node.","The invention can be implemented in digital electronic circuitry, or in computer hardware, firmware, software, or in combinations of them. The invention can be implemented as a computer program product, i.e., a computer program tangibly embodied in an information carrier, e.g., in a machine-readable storage device or in a propagated signal, for execution by, or to control the operation of, data processing apparatus, e.g., a programmable processor, a computer, or multiple computers. A computer program can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.","Method steps of the invention can be performed by one or more programmable processors executing a computer program to perform functions of the invention by operating on input data and generating output. Method steps can also be performed by, and apparatus of the invention can be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application-specific integrated circuit).","Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto-optical disks, or optical disks. Information carriers suitable for embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in special purpose logic circuitry.","To provide for interaction with a user, the invention can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.","The invention can be implemented in a computing system that includes a back-end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front-end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the invention, or any combination of such back-end, middleware, or front-end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (\u201cLAN\u201d) and a wide area network (\u201cWAN\u201d), e.g., the Internet.","The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.","The invention has been described in terms of particular embodiments. Other embodiments are within the scope of the following claims. For example, the steps of the invention can be performed in a different order and still achieve desirable results"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"},"Like reference numbers and designations in the various drawings indicate like elements."]},"DETDESC":[{},{}]}
