---
title: Operation processing device and method of detecting memory leak
abstract: A memory leak detecting method includes: producing an object which occupies an area on a first area of the memory; checking a presence of a pointer which points at the object separately so as to remove the object and to repeatedly carry out a process for increasing a counter value of the object; moving the object from the area on the first area of the memory to an area on the second area of the memory when the counter value exceeding a first threshold; and moving the object from the area on the second area to the area on the first area and clearing the counter value of the object upon the object occupying the area on the second area.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08930661&OS=08930661&RS=08930661
owner: Fujitsu Limited
number: 08930661
owner_city: Kawasaki
owner_country: JP
publication_date: 20110314
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD","BACKGROUND","SUMMARY","DESCRIPTION OF EMBODIMENTS"],"p":["This application is based upon and claims the benefit of priority of the prior Japanese Patent Application No. 2010-071056, filed on Mar. 25, 2010, the entire contents of which are incorporated herein by reference.","The application relates to an operation processing device and a method of detecting a memory leak.","After an object which occupies an area to be accessed on a memory is produced and used, the object having been made unnecessary is erased as a general rule. An object once produced, however, can possibly remain without being erased to cause a memory leak for a reason that, e.g., a program writer has made an error in the control of allocating or releasing an area on the memory. If such a memory leak occurs, a usable memory area is limited. If memory leaks increase, the memory can possibly be exhausted possibly resulting in a problem of a system failure, etc.","In a system in which a garbage collection function (GC) is implemented such as the Java (registered trademark) language, an object and a pointer pointing at the object are not managed by the program writer but are managed by the GC. Thus, even if the program writer makes an error in the control of allocating or releasing an area on the memory, that kind of memory leak can be prevented. If no pointer points at the object, the GC identifies the object as garbage and a target to be erased.","In other words, the GC does not identify the object as a target to be erased while the pointer pointing at the object exists. Thus, under conditions in which the object and the pointer pointing at the object exist but nevertheless the object is never used again, the unnecessary object continues to remain in the memory. If such objects increase, the memory ends up being exhausted. That is a memory leak that occurs even to a system in which the GC is implemented.","While a program writer can use a lot of application programming interfaces (API) at present as open usage of software has become widespread, he or she finds it difficult to understand in detail the inside of an API that he or she will use. Thus, an error in a method for using the API can possibly cause a memory leak of a type such that a pointer of an unnecessary object exists and the unnecessary object resultantly continues to remain.","Some methods for detecting a memory leak, e.g., of the Java (registered trademark) language are known, such as Oracle JRockit Mission Control (Memory Leak Detector) or IBM HeapAnalyzer.","The method of Oracle JRockit Mission Control (Memory Leak Detector) is, if instances of one and the same class increase a lot in a time unit, for notifying a user of a name of the class and objects as a candidate of a memory leak.","Meanwhile, the method of IBM HeapAnalyzer is, if lots of instances of one and the same class remain on a memory at the end of the GC, provides a user with a name of the class and object information as a candidate of a memory leak.","These methods for detecting a memory leak have following problems in:","that the methods are unable to detect a small memory leak, e.g., just one leaking object;","that the methods are unable to detect a memory leak that occurred in the past. In case of an application that periodically repeats a memory leak, no leak can be detected even if a tool is used when no memory leak occurs; and","that lots of objects which remain on the memory do not necessarily cause a leak. An object programmed to be used at a certain time after being unused for a while can possibly exist. Thus, in order to identify whether a memory leak is present, it is necessary to observe information of the object for a certain period of time.","Further, a method for recording entire information of access to all objects on every page of a memory so as to detect a memory leak at a frequency of the access is known, e.g., as disclosed in Japanese Unexamined Patent Application Publication No. 2009-26081. Observation of the entire access to all the objects, however, excessively loads the system operation. Further, if objects of different access frequencies are arranged on a same page, the method for recording the access on every page reduces accuracy of the leak detection.","According to an aspect of the embodiment, a method of detecting a memory leak includes:","producing an object which occupies an area on a first area of the memory;","checking a presence of a pointer which points at the object separately so as to remove the object and to repeatedly carry out a process for increasing a counter value of the object;","moving the object from the area on the first area of the memory to an area on the second area of the memory when the counter value exceeds a first threshold;","moving the object from the area on the second area to the area on the first area and clearing the counter value of the object when the object occupies the area on the second area; and","outputting the object occupying the area on the second area when the counter value exceeds a second threshold.","The object and advantages of the embodiment will be realized and attained at least by the elements, features, and combinations particularly pointed out in the claims.","It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory and are not restrictive of the embodiment, as claimed.","According to a method of detecting a memory leak disclosed here by the application, the processor carries out the following (1)-(5) processes:","(1) to produce an object that occupies an area on a first area of the memory;","(2) to repeat a following process. In the process, every object is examined for existence of a pointer that points at the object and an object with no pointer is removed. Further, in the process as well, a counter value of every object with a pointer is individually counted;","(3) to move an object for which the counted value exceeds a first threshold from the area on the first area of the memory to an area on a second area of the memory;","(4) to move, an object occupying an area on the second area, to an area on the first area, and to clear the counter value of the object; and","(5) to output one of objects which occupy areas on the second area, for which the counter value exceeds a second threshold.","Incidentally, the memory to be dealt with by the method of detecting a memory leak disclosed by the application is a memory to be a target in which an object occupies an area, and is not limited to a main memory. If, e.g., the object counts as an area in a storage portion of an HDD (hard disk drive) as a target to be occupied, the storage portion of the HDD is included in the memory of the application.","An embodiment of the application will be explained below.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 1"},"A hardware configuration is illustrated in a lowest portion of , where a personal computer (PC) of an ordinary configuration is assumed. A processor , a memory , an input device  and an output device  are included as hardware . The processor  runs a program. The memory  is in charge of data storage, and is accessed (data writing or reading) upon the program being run. The memory  of the embodiment is a main memory in which the program to be run by the processor  is stored. The memory of the application, however, need not be limited to a main memory, and can be a storage device such as an HDD (hard disk drive).","Further, the input device  includes an input device which accepts a user's operation through a keyboard, a mouse, etc., and a receiving device, etc., which accepts instructions from the outside of the operation processing device  through a communication line, etc.","Further, the output device  includes an image display device which displays an image for a user of the operation processing device , a speaker which delivers sound to the user, and a transmitting device, etc., which sends information to the outside of the operation processing device  through a communication line, etc.","An operating system (OS)  runs on the hardware , and a process  is run as software as controlled by the OS. The OS  is in charge of the process . Controls of the embodiment to be focused on as to the embodiment are \u201cto call a handling process\u201d and \u201cto change access protection\u201d, which will be described later in detail.","The process  has a communication function , a handling process running function , an application running function , a GC running function  and a memory managing function . Further, the process  manages stack trace data  on the memory  and an accessed address list .","The operation processing device  has various kinds of application programs as well as the hardware , the OS  and the process  described here.","The communication function  which forms the process  is a thread in charge of communication between the process  and another process or the input device .","The handling process running function  is in charge of running a handling process when an area B being prohibited from being accessed is illegally accessed, which will be described later in detail.","The application running function  is a thread to be activated when various applications are run.","The GC running function  repeatedly runs the GC. The GC running function  has a counter of GC running . The counter  counts the number of times of GC running for every object, which will be described later in detail.","The memory managing function  sets areas A and B on the memory  on the hardware  and manages the areas A and B. How to use the areas A and B will be described later. The stack trace data  and the accessed address list  will be described later as well.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 2"},"If an application program is run and the application program instructs that an object be produced, the application running function  carries out a process according to the flowchart illustrated in .",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 3"},"The object has a data portion to or from which data is written or read and a header portion in which the number of times of GC running and a pointer to the stack trace data are recorded.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 4"},"Method data representing methods is stacked here in order of a calling method to a called method. Each of the method data is formed by a name of a method and a numerical value (line number) that specifies a line on which the method is written in the program. A method is specified by the name and the line number recorded there.","Method data 1, 2, . . . , N is stacked here, and the method data 1 stacked on the top is the method that has produced the object. The stack trace data further has a \u201creference count\u201d. The \u201creference count\u201d is a counter provided for a case in which objects produced multiple times have the same stack trace data, so as to avoid a plurality of the same stack trace data from being made. A positive number n recorded on the \u201creference count\u201d represents that that one piece of stack trace data is common to n-objects.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 5"},"An object is produced so as to occupy a part of the area A. The area B is not used when an area is produced. An object once produced can possibly be moved, though, in such a way that the object occupies an area in the area B, which will be explained later.","The flowchart illustrated in  will be explained on the basis of the explanation with reference to .","An object is produced (operation S). In order that the object is produced, as described above, an area in the area A is allotted to the object as an area to and from which data is written and read. The object has the header portion illustrated in , and the number of times of GC running set in the header portion is set to an initial value (zero in this case) (operation S).","The calling relations (see ) of the method which produced the object are obtained (operation S), and whether stack trace data which is substantially the same as the stack trace data to be referred to by the object produced exists is identified (operation S). If no such stack trace data exists, produce stack trace data for the object produced (operation S), set the reference count of the stack trace data to \u20181\u2019 (operation S), and set the address of the stack trace data is set to the header of the object produced (operation S).","If substantially the same stack trace data which already exists is identified at the operation S, add \u20181\u2019 to the reference count of the same stack trace data (operation S), and set the address of the same stack trace data to the header of the object (operation S).",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIG. 6","FIG. 1","FIG. 6"],"b":"44"},"In this case, \u20181\u2019 is subtracted from the reference count (see ) of the stack trace data that the pointer of the stack trace data recorded in the header of the object to be removed as determined points at (operation S). Identification of whether the reference count is zero or one or more after \u20181\u2019 is subtracted (operation S). If the reference count is zero, the stack trace data (operation S) is removed, and the object itself to be removed as instructed (operation S) is also removed. If the reference count of the stack trace data being one or more is identified at the operation S, the object to be removed as instructed while leaving the stack trace data (operation S) is removed.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 7"},"In order that an object is produced, as described above, an object is set in the area A. Here, it is called that the object is put in the area A. An object having experienced the GC more than a certain number of times owing to GC repetition described later is changed in such a way that the occupied area is in the area B. Here, it is called that the object is moved to the area B.","If the object moved to the area B is accessed, the object is moved back to the area A.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 8"},"Examples of a method employed here of detecting an access to the object is to use an OS-provided function for changing memory access protection. The OS-provided function for changing memory access protection is mprotect of Solaris or Linux, or VirtualProtect of Windows (registered trademark), etc.","Both reading and writing operations for access protection in the area B are prohibited. Further, a process for handling an illegal access is set.","If an object being in the area B is accessed in the above conditions, the OS detects an illegal access and the handling process having been set is run. According to the handling process, the access protection in the area B is changed to what allows both reading and writing operations, and the access to the object is done. Further, the accessed address is added to the list. The access protection in the area B returns to what prohibits both reading and writing operations. After the handling process ends here, the process returns to the former process.","In a next GC, an object including the address included in the list is moved to the area A and the number of times of GC running of the object is changed to the initial value.","The process for running an object being in the area B will be explained in accordance with a flowchart.",{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 9"},"If an application program accesses an object being in the area B (operation S), an illegal access occurs (operation S) and a handling process is carried out (operation S). After the handling process ends, the process according to the application program continues (operation S).",{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 10"},"According to the handling process at the operation S in , the access protection in the area B is changed to what allows both reading and writing operations (operation S), and a reading or writing operation from or to the object is carried out (operation S). Further, the address in the area B accessed this time is added to the list (see ) (operation S), and the access protection in the area B is changed back to what prohibits both reading and writing operations (operation S).","According to the embodiment, the object is not moved from the area B to the area A at this point of time in the handling process, but is moved when a next GC process is carried out.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 11"},"The GC running function  illustrated in  carries out the GC process explained below. The GC process can be carried out at regular intervals, or can be randomly carried out, e.g., at a timing of a bit dropped rate of operation of the processor  (see ).","According to the GC process illustrated in , at first, the access to the area B having been prohibited is released (operation S). That is, the memory protection attribute of the area B is changed to what allows both writing and reading operations.","The process for moving the object from the area B to the area A is carried out (operation S). That is, the list (see ) in which addresses accessed in the area B are recorded is here referred to, and an object including one of the addresses recorded in the list is moved from the area B to the area A.","Further, an unnecessary object is removed, and a process for moving the object with a lot of number of GC running in the area A is moved to the area B (operation S). Further, a process for outputting data of an object being in the area B possibly causing a memory leak is carried out (operation S). The access to the area B is prohibited again (operation S).",{"@attributes":{"id":"p-0096","num":"0095"},"figref":["FIG. 12","FIG. 11"],"b":"42"},"In , while the objects being in the area B are each focused on one by one, a following process is carried out for the focused-on object (operation S).","An identification is made whether the focused-on object includes one of the addresses recorded in the list (see ) of the accessed addresses (operation S). If the focused-on object has no relation to the addresses in the list, the process returns to operation S and focus on the next object.","Meanwhile, if the focused-on object includes one of the addresses in the list (operation S), the number of times of GC running to zero (operation S) is cleared and the focused-on object from the area B to the area A (operation S) is moved. The process returns to the operation S and focus on the next object.","If the process is completed for all the objects being in the area B, the routine is exited (operation S).",{"@attributes":{"id":"p-0101","num":"0100"},"figref":["FIG. 13","FIG. 11"],"b":"43"},"In , the objects being in any one of the areas A and B are each focused on one by one, and a following process is carried out for the focused-on object (operation S).","An identification is made whether a pointer pointing at the focused-on object exists (operation S). If no pointer points at the object, remove the object from the memory (operation S). The process returns to the operation S so as to focus on the next object, and carry out a similar process for the new focused-on object. The process for searching for an existing pointer and for removing an object with no pointer at the operations S and S is a basic process known as garbage collection (GC), and its detailed explanation is omitted.","If a pointer pointing at the focused-on object is identified as existing at the operation S, \u20181\u2019 is added to the number of times of GC running (see ) of the focused-on object (operation S). An identification is made whether the object is in the area A or in the area B (operation S). If the object is not in the area A (but in the area B), the process returns to the operation S. If the object is in the area A, the process proceeds to operation S so as to identify whether the number of times of GC running of the object has exceeded a threshold (operation S). The threshold is an example of the first threshold of the application. If the number of times of GC running of the object has not exceeded the threshold yet, the process returns to the operation S. If the number of times of GC running of the object has exceeded the threshold, the process returns to the operation S after the object is moved to the area B (operation S).","If the process is completed for all the objects being in the areas A and B, the routine is exited (operation S).",{"@attributes":{"id":"p-0106","num":"0105"},"figref":["FIG. 14","FIG. 11"],"b":"44"},"In , while the objects being in the area B are each focused on one by one, a following process is carried out for the focused-on object (operation S).","A check of the number of times of GC running of the focused-on object being in the area B is made, and an identification is made whether the threshold (used at the operation S in ) subtracted from the number of times of GC running is greater than a fixed value (operation S). The sum of the \u201cthreshold\u201d and the \u201cfixed value\u201d is an example of the second threshold of the application.","If the threshold subtracted from the number of times of GC running is smaller than the fixed value, the process returns to the operation S so as to carry out a similar process focusing on the next object being in the area B.","If the threshold subtracted from the number of times of GC running is greater than the fixed value, output the data of the object (operation S). The process returns to the operation S.","If the process is completed for all the objects being in the area B, the routine is exited.",{"@attributes":{"id":"p-0112","num":"0111"},"figref":["FIG. 15","FIG. 14"],"b":"443"},"As a form of data output, data illustrated in  is displayed here on a screen of the image display device which forms the output device  of the operation processing device  illustrated in .","The first line illustrated in  indicates an object that has never been accessed while experiencing the GC process 1000 times. The second and following lines indicate history of production of the object (see ).","Modifications of the embodiment will be explained below. Matters different from the embodiment only will be explained for each of the modifications.","According to the embodiment described above, the data output process is carried out in course of the GC process (see ). The data output process can be carried out as explained below in addition to, or instead of, being carried out in course of the GC process.",{"@attributes":{"id":"p-0117","num":"0116"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0118","num":"0117"},"figref":["FIG. 16","FIG. 1","FIG. 16"],"b":["40","41","40","40","10","23"]},"As described above, the process  can be configured, upon being requested to send data of an object causing a leak, to carry out a process corresponding to  and to output the data.","If no data output process is carried out in the GC process, the process of the operation  in , e.g., the process illustrated in  is excluded from the GC process.",{"@attributes":{"id":"p-0121","num":"0120"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0122","num":"0121"},"figref":["FIG. 17","FIG. 10"]},"If the handling process illustrated in  is employed for the operation S in , the handling process of  and the process of the operation S in the GC process illustrated in  may be omitted, e.g., the process illustrated in . Further, the list illustrated in  may also not be made.","According to the handling process illustrated in , the access protection in the area B is changed to what allows both reading and writing operations (operation S). The object being in the area B accessed at the operation S in  is moved to the area A (operation S), and the access protection in the area B is changed to what prohibits both reading and writing operations (operation S). Further, the number of times of GC running of the object that has been moved to the area A is cleared to zero (operation S), and a reading or writing operation from or to the object is carried out (operation S).","Although being carried out by the GC running function  according to the embodiment described above, the process for moving the object from the area B to the area A can be carried out by the handling process running function  as illustrated in . If the moving process is carried out by the handling process running function , the process for making the list illustrated in , etc., is unnecessary, so that the process can be simplified. In this case, however, the moving process is carried out in the handling process in course of an application program being run, e.g., an exceptional process of a raised priority, resulting in an increase in the processing load for that. Meanwhile, the GC process can be carried out at a time when the operation processing device  can afford to run applications, so as to prevent the load from increasing.","For any of the embodiment and the modifications, however, it is enough to observe objects being only in the area B and a memory leak can be detected with a light load.","All examples and conditional language recited herein are intended for pedagogical purposes to aid the reader in understanding the principles of the invention and the concepts contributed by the inventor to furthering the art, and are to be construed as being without limitation to such specifically recited examples and conditions. Although the embodiment(s) of the present invention(s) has(have) been described in detail, it should be understood that the various changes, substitutions, and alterations could be made hereto without departing from the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 12","FIG. 11"],"b":"42"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 13","FIG. 11"],"b":"43"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 14","FIG. 11"],"b":"44"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 15","FIG. 14"],"b":"443"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 17"}]},"DETDESC":[{},{}]}
