---
title: Multimedia data routing system and method
abstract: A technique for providing routing of various multimedia events throughout the course of a multimedia presentation using a computer with a storage and a display. A variety of multimedia objects are defined in the storage and grouped in logical relationships to enable multimedia presentations. A display is used to create the presentations interactively by positioning objects representative of the multimedia events and joining them with geometric figures, such as line segments. Each object can then be directly manipulated via a mouse or other pointing device to position a multimedia object to a particular position, or adjust the playback rate of a multimedia object.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06981208&OS=06981208&RS=06981208
owner: Object Technology Licensing Corporation
number: 06981208
owner_city: Cupertino
owner_country: US
publication_date: 20020612
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application is a continuation of U.S. patent application Ser. No. 09\/196,861, filed on Nov. 20, 1998, now U.S Pat. No. 6,421,692, which is a continuation of U.S. patent application Ser. No. 08\/120,270, filed on Sep. 13, 1993, now abandoned.","Portions of this patent application contain materials that are subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","This invention generally relates to improvements in computer systems and more particularly to a system for routing data between multimedia components.","Multimedia is perhaps the fastest growing application for computer systems. Increasingly, users are employing computers to present graphic, sound and imaging information to end users. Users are increasingly demanding ergonomic interfaces for managing multimedia presentations. In the past, a time matrix and programming language were used to implement a multimedia presentation. However, simulating a flexible mixing board to enable the presentation of music or sound with the display of information as a multimedia presentation unfolded was not possible.","Examples of current multimedia systems that do not have the capability of the subject invention are Apple's Quicktime and Microsoft's Video for Windows as described in the March issue of NEWMEDIA, \u201cIt's Showtime\u201d, pp. 36-42 (1993). The importance of obtaining a solution to the routing problem encountered in the prior art is discussed in the March issue of IEEE Spectrum, \u201cInteractive Multimedia\u201d, pp. 22-31 (1993); and \u201cThe Technology Framework\u201d, IEEE Spectrum, pp. 32-39 (1993). The articles point out the importance of an aesthetic interface for controlling multimedia productions.","Accordingly, it is a primary objective of the present invention to provide a system and method for routing multimedia data throughout the course of a multimedia presentation using a computer with a storage and a display. A multimedia data routing system is defined in the storage and displayed as a multimedia object. The routing can then be directly manipulated via a mouse or other pointing device to associate multimedia information with one or more multimedia objects. A variety of multimedia objects are defined in the storage and joined in logical relationships to enable multimedia presentations. A display is used to create the presentations interactively by positioning objects representative of the multimedia events and joining them with geometric figures, such as line segments. Each object can then be directly manipulated via a mouse or other pointing device to position a multimedia object to a particular position, or adjust the playback rate of a multimedia object.","The invention is preferably practiced in the context of an operating system resident on a personal computer such as the IBM\u00ae PS\/2\u00ae or Apple\u00ae Macintosh\u00ae computer. A representative hardware environment is depicted in , which illustrates a typical hardware configuration of a workstation in accordance with the subject invention having a central processing unit , such as a conventional microprocessor, and a number of other units interconnected via a system bus . The workstation shown in  includes a Random Access Memory (RAM) , Read Only Memory (ROM) , an I\/O adapter  for connecting peripheral devices such as disk units  to the bus, a user interface adapter  for connecting a keyboard , a mouse , a speaker , a microphone , and\/or other user interface devices such as a touch screen device (not shown) to the bus, a communication adapter  for connecting the workstation to a data processing network and a display adapter  for connecting the bus to a display device . The workstation has resident thereon an operating system such as the Apple System\/7\u00ae operating system.","In a preferred embodiment, the invention is implemented in the C++ programming language using object oriented programming techniques. As will be understood by those skilled in the art, Object-Oriented Programming (OOP) objects are software entities comprising data structures and operations on the data. Together, these elements enable objects to model virtually any real-world entity in terms of its characteristics, represented by its data elements, and its behavior, represented by its data manipulation functions. In this way, objects can model concrete things like people and computers, and they can model abstract concepts like numbers or geometrical concepts. The benefits of object technology arise out of three basic principles: encapsulation, polymorphism and inheritance.","Objects hide, or encapsulate, the internal structure of their data and the algorithms by which their functions work. Instead of exposing these implementation details, objects present interfaces that represent their abstractions cleanly with no extraneous information. Polymorphism takes encapsulation a step further. The idea is many shapes, one interface. A software component can make a request of another component without knowing exactly what that component is. The component that receives the request interprets it and determines, according to its variables and data, how to execute the request. The third principle is inheritance, which allows developers to reuse pre-existing design and code. This capability allows developers to avoid creating software from scratch. Rather, through inheritance, developers derive subclasses that inherit behaviors, which the developer then customizes to meet their particular needs.","A prior art approach is to layer objects and class libraries in a procedural environment. Many application frameworks on the market take this design approach. In this design, there are one or more object layers on top of a monolithic operating system. While this approach utilizes all the principles of encapsulation, polymorphism, and inheritance in the object layer, and is a substantial improvement over procedural programming techniques, there are limitations to this approach. These difficulties arise from the fact that while it is easy for a developer to reuse their own objects, it is difficult to use objects from other systems and the developer still needs to reach into the lower, non-object layers with procedural Operating System (OS) calls.","Another aspect of object oriented programming is a framework approach to application development. One of the most rational definitions of frameworks came from Ralph E. Johnson of the University of Illinois and Vincent F. Russo of Purdue. In their 1991 paper, Reusing Object-Oriented Designs, University of Illinois tech report UIUCDCS91-1696 they offer the following definition: \u201cAn abstract class is a design of a set of objects that collaborate to carry out a set of responsibilities. Thus, a framework is a set of object classes that collaborate to execute defined sets of computing responsibilities.\u201d From a programming standpoint, frameworks are essentially groups of interconnected object classes that provide a pre-fabricated structure of a working application. For example, a user interface framework might provide the support and \u201cdefault\u201d behavior of drawing windows, scrollbars, menus, etc. Since frameworks are based on object technology, this behavior can be inherited and overridden to allow developers to extend the framework and create customized solutions in a particular area of expertise. This is a major advantage over traditional programming since the programmer is not changing the original code, but rather extending the software. In addition, developers are not blindly working through layers of code because the framework provides architectural guidance and modeling but at the same time frees them to then supply the specific actions unique to the problem domain.","From a business perspective, frameworks can be viewed as a way to encapsulate or embody expertise in a particular knowledge area. Corporate development organizations, Independent Software Vendors (ISV)s and systems integrators have acquired expertise in particular areas, such as manufacturing, accounting, or currency transactions. This expertise is embodied in their code. Frameworks allow organizations to capture and package the common characteristics of that expertise by embodying it in the organization's code. First, this allows developers to create or extend an application that utilizes the expertise, thus the problem gets solved once and the business rules and design are enforced and used consistently. Also, frameworks and the embodied expertise behind the frameworks, have a strategic asset implication for those organizations who have acquired expertise in vertical markets such as manufacturing, accounting, or biotechnology, and provide a distribution mechanism for packaging, reselling, and deploying their expertise, and furthering the progress and dissemination of technology.","Historically, frameworks have only recently emerged as a mainstream concept on personal computing platforms. This migration has been assisted by the availability of object-oriented languages, such as C++. Traditionally, C++ was found mostly on UNIX systems and researcher's workstations, rather than on computers in commercial settings. It is languages such as C++ and other object-oriented languages, such as Smalltalk and others, that enabled a number of university and research projects to produce the precursors to today's commercial frameworks and class libraries. Some examples of these are InterViews from Stanford University, the Andrew toolkit from Carnegie-Mellon University and University of Zurich's ET++ framework.","Types of frameworks range from application frameworks that assist in developing the user interface, to lower level frameworks that provide basic system software services such as communications, printing, file systems support, graphics, etc. Commercial examples of application frameworks are MacApp (Apple), Bedrock (Symantec), OWL (Borland), NeXTStep App Kit (NeXT), and Smalltalk-80 MVC (ParcPlace).","Programming with frameworks requires a new way of thinking for developers accustomed to other kinds of systems. In fact, it is not like \u201cprogramming\u201d at all in the traditional sense. In old-style operating systems such as DOS or UNIX, the developer's own program provides all of the structure. The operating system provides services through system calls-the developer's program makes the calls when it needs the service and control returns when the service has been provided. The program structure is based on the flow-of-control, which is embodied in the code the developer writes.","When frameworks are used, this is reversed. The developer is no longer responsible for the flow-of-control. The developer must forego the tendency to understand programming tasks in term of flow of execution. Rather, the thinking must be in terms of the responsibilities of the objects, which must rely on the framework to determine when the tasks should execute. Routines written by the developer are activated by code the developer did not write and that the developer never even sees. This flip-flop in control flow can be a significant psychological barrier for developers experienced only in procedural programming. Once this is understood, however, framework programming requires much less work than other types of programming.","In the same way that an application framework provides the developer with prefab functionality, system frameworks, such as those included in a preferred embodiment, leverage the same concept by providing system level services, which developers, such as system programmers, use to subclass\/override to create customized solutions. For example, consider a multimedia framework which could provide the foundation for supporting new and diverse devices such as audio, video, MIDI, animation, etc. The developer that needed to support a new kind of device would have to write a device driver. To do this with a framework, the developer only needs to supply the characteristics and behaviors that are specific to that new device.","The developer in this case supplies an implementation for certain member functions that will be called by the multimedia framework. An immediate benefit to the developer is that the generic code needed for each category of device is already provided by the multimedia framework. This means less code for the device driver developer to write, test, and debug. Another example of using system frameworks would be to have separate I\/O frameworks for SCSI devices, NuBus cards, and graphics devices. Because there is inherited functionality, each framework provides support for common functionality found in its device category. Other developers could then depend on these consistent interfaces for implementing other kinds of devices.","A preferred embodiment takes the concept of frameworks and applies it throughout the entire system. For the commercial or corporate developer, systems integrator, or OEM, this means all the advantages that have been illustrated for a framework such as MacApp can be leveraged not only at the application level for such things as text and user interfaces, but also at the system level, for services such as graphics, multimedia, file systems, I\/O, testing, etc.","Application creation in the architecture of a preferred embodiment will essentially be like writing domain-specific pieces that adhere to the framework protocol. In this manner, the whole concept of programming changes. Instead of writing line after line of code that calls multiple API hierarchies, software will be developed by deriving classes from the preexisting frameworks within this environment, and then adding new behavior and\/or overriding inherited behavior as desired.","Thus, the developer's application becomes the collection of code that is written and shared with all the other framework applications. This is a powerful concept because developers will be able to build on each other's work. This also provides the developer the flexibility to customize as much or as little as needed. Some frameworks will be used just as they are. In some cases, the amount of customization will be minimal, so the piece the developer plugs in will be small. In other cases, the developer may make very extensive modifications and create something completely new.","In a preferred embodiment, as shown in , a multimedia data routing system manages the movement of multimedia information through the computer system, while multiple media components resident in the RAM , and under the control of the CPU , or externally attached via the bus  or communication adapter , are responsible for presenting multimedia information. No central player is necessary to coordinate or manage the overall processing of the system. This architecture provides flexibility and provides for increased extensibility as new media types are added. The system makes use of a variety of multimedia objects, some of which that can be used as connecting objects. The connecting objects include gain, filters, amplifiers, mixers, players and other multimedia components that are individually implemented as objects in an object oriented operating system. Objects, as discussed above include a code or method component and a data component. The system includes a mouse for facilitating iconic operations such as drag\/drop, double-clicking, drop-launching, cursor positioning and other typical operations.","In video and audio production studios, media such as sound, MIDI, and video make use of physical patch cords to route signals between sources, effects processors, and sinks. Signal processing algorithms are also often represented as networks of sources, sinks, and processors. Both of these models can be represented as directed graphs of objects that are connected. A preferred embodiment allows this model\u2014connecting objects together\u2014to be realized on a computer system.  illustrates a prior art, simple, home studio setup utilizing a tape deck, mixer, reverberation unit, pair of microphones, and pair of speakers. Since the microphones are connected to the tape deck, sound input is routed from the microphone to the tape deck, where it can be recorded. When the tape deck plays back, its signal is routed to the mixer because of the connection from the tape deck to the mixer. Similarly, the reverberation unit and the speakers are connected an amplifier connected to the mixer.","A preferred embodiment utilizes object-oriented technology to represent a connection model. Multimedia objects can be connected to each other, creating directed data flow graphs. In addition, a standard set of multimedia objects is defined to the system. These objects can be connected together to facilitate multimedia data flow from object to object. The connection operations can be facilitated by connecting multimedia objects via a geometric figure such as a line, line segment or other appropriate geometry. The figures discussed below show examples of various multimedia objects, including connecting objects and the geometric figures that are used to represent the internal data structures and logic joining the multimedia objects.","A time-based media component (hereafter referred to as a media component) base class is a central abstraction used for routing. A media component has zero or more input ports and zero or more output ports. In , for example, the media component has a single input port  and two output ports  and . Ports ,  and  are represented as filled triangles.","Subclasses of media components are connected together by connecting their ports. This processing is analogous to using patch cords to connect audio and video components together in a recording studio. In , a subclass of a media component, an audio player component object, is connected to another media component subclass, a speaker component object. The audio player has one output port and the speaker has one input port. Media components are controlled using member function calls. The audio player in , for example, has member functions for playing audio data. When the audio player's member function Play( ) is called, audio data will be fed from the audio player to the speaker, which will cause the audio to be heard on the computer's speaker. The speaker component does not have a Play( ) function because it plays whatever audio data is transmitted to it. Media components can be implemented completely in software. However, it is possible for a media component to represent a physical piece of hardware. For example, a speaker object can be employed to represent playback hardware of a computer. In this way, external media devices, such as video tape recorders, mixers, and effect processors, can be represented as media components and be connected together.","Media components are connected together by connecting their ports. To prevent client objects and components from writing data simultaneously to the same port, thereby compromising data integrity, clients are not allowed to access ports directly. Instead, clients perform connection operations on multithread-safe surrogate objects. In the context of this description, the term \u201csurrogate\u201d refers to a specialized representation of an underlying class which permits multiple clients to share instances of the class safely. In the case of the media components, surrogate ports permit limited indirect manipulation of the actual ports. Every media component has member functions which create surrogates for each of its input and output ports. These port surrogates are extremely lightweight objects and are well-suited for traversing address boundaries, thus facilitating the connection of media components which reside in different address spaces.","Each port and port surrogate has a data type associated with it. Examples of types are MIDI data, 44 kHz 16 bit audio data, 22 kHz 8 bit audio data, and graphic data for video. When two ports are asked to connect, a type negotiation protocol insures that the ports are capable of supporting compatible data types. An exception is generated if the ports have no types in common.","Converter objects can be inserted between objects which have incompatible port types. Converters are components which take in data of one type in order to produce data of a different type. Examples of fan-in and fan-out ports are shown in FIG. . Specific subclasses may choose to disallow fan-in and\/or fan-out. Audio ports, for example, disallow both, and exceptions are generated by any attempt to connect one port to more than one other port. Fan-in and fan-out properties are handled by the specific media subclasses. For example, in MIDI, fan-out sends the same data to multiple recipients, and fan-in merges data from multiple senders.","Two media components, A and B, are connected together by:\n\n","Audio can be digitized, stored, processed, and played back on a computer. A computer can also be used to synthesize and playback audio. An Analog to Digital Converter (ADC) is used to convert an analog audio electrical signal to a series of numbers called digital audio samples. The audio is typically sampled at rates of 8000 samples per second for telephone quality audio all the way up to 44,100 samples per second for Compact Disc (CD) quality audio and 48,000 samples per second for Digital Audio Tape (DAT). Once in numeric form, the audio can be stored and processed by the computer. The digital audio samples are converted back to an analog audio electrical signal by using a Digital to Analog Converter (DAC). A preferred embodiment defines subclasses of port objects called audio ports that are used to route digital audio data between media components. Audio output ports can be connected to audio input ports to route audio data. If a media component has at least one audio port, it is called an audio component. All audio components are subclasses of media component base class. An audio component has zero or more audio input ports and zero or more audio output ports, as shown in FIG. . Audio components can be connected together by connecting their ports. This is analogous to using patch cords to connect stereo components together utilizing hardware.","A preferred embodiment facilitates the connection of audio components to create a variety of interesting applications. , ,  and  illustrate some example applications that can be constructed using audio components.  shows how a voice annotation application can be written by using an audio player to record and play voice annotations. A telephone handset is used for input and output.  shows how a voice mail\/phone answering application can be constructed. One audio player plays a greeting out over the phone line while another audio player records an incoming message.  illustrates a music application. Echo, a special effect, is added to a musical instrument sound and played through a speaker.  illustrates how three sounds, one for music, one for sound effects, and one for voice over, can be mixed together and fed through an output device, such as a speaker.","Like all media components, audio components are connected together by connecting their ports. This operation is facilitated by selecting an audio component port, extending a geometric figure such as a line from the component port to another multimedia component port and creating a data structure commemorating the linkage represented graphically on the display. Every audio component has member functions which create surrogates for its input and output ports. Clients perform connection operations by requesting input and\/or output port surrogates from each component and then using the member functions provided by the surrogate objects to connect the actual input ports to actual output ports. Each audio port and port surrogate has an audio type associated with it.  lists some of the audio types supported by a preferred embodiment.","A connection, represented by the linking line segment on the display, represents a single audio channel. Stereo is handled by using two connections, one for the left channel and one for the right. When two ports are asked to connect, a type negotiation protocol insures that the ports are capable of supporting compatible data types. An exception is generated if the ports have no types in common. If this happens, an audio type converter can be inserted between the two ports to convert from one type to another as illustrated in FIG. . No loops (cycles) are allowed in a network of audio components. Any attempt to perform a connection that would result in a loop causes an exception to be thrown. The process of connecting audio components is represented graphically on the display by extending a geometric figure, such as a line segment, between icon like figures representative of the audio input and output ports of indicia representative of multimedia objects.","A client-server based architecture is used to implement audio components. For every audio component, there is an audio processor object that resides in a task called the sound server. The audio processor object is responsible for performing the actual signal processing. Audio component subclassers have to write both an audio component and an audio processor subclass. A client\/server approach is used to enhance performance. Patch cord-style routing of audio is most efficiently implemented if all data movement and signal processing are done in a single task. This avoids unnecessary Interprocess Communication (IPC) and context switches. Given that clients exist in many different tasks, a sound server is required to centralize the processing in a single task.","An alternative implementation has been explored which handles signal processing in a separate task per audio component. No server is needed for audio processing. This is an elegant alternative with many advantages, but unfortunately it has one drawback\u2014it is over an order of magnitude slower than the approach presented in a preferred embodiment of the invention. On monoprocessors, this ratio would remain fairly constant even as machines are built with enhanced processing power.","Audio components require facilities for communicating with their corresponding audio processors. A Remote Procedure Call (RPC) interface is used to do this. Generally, member functions of an audio component subclass remotely invoke the \u201creal\u201d member function on the audio processor.  is a block diagram illustrating a remote procedure call in accordance with a preferred embodiment.","Audio processors, in contrast to audio components, own the audio ports. Audio components own the audio port surrogates. Whenever two port surrogates are connected together in the client address space, the corresponding audio ports are connected together in the sound server address space. Subclassers are not required to take any enabling action, the framework does it for them.","Connections between audio ports are implemented using buffers of audio data. Each connection, or \u201cpatch cord,\u201d has a buffer associated with it. The audio processor can ask each of its audio ports for the address and size of this buffer.  is a block diagram illustrating an audio processor architecture with an associated Run( ) member function which reads data from its input buffers, processes it, and writes the result to its output buffers. The size of the buffers is variable but the preferred size accommodates 5 milliseconds worth of samples. This size is necessary to reach a performance goal of being able to start and stop sounds with a maximum of 10 ms latency.","The sound server uses a technique called frame-based processing to process sound samples. The basic process is presented below.\n\n","Audio processors are ordered employing a technique called simulated data flow. Most subclassers don't need to worry about ordering because ordering is determined automatically by a framework in most cases. Simulated data flow iterates through the network in topological order, as if to pass data from one processor to the next. This is done to see which audio processor can run and which audio processor can't. Audio processors that run are put on the run list, and are utilized over and over again during the run phase.","An audio processor node can run if:",{"@attributes":{"id":"p-0107","num":"0000"},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":["#1: its input ports has data available, AND","#2: its output ports have a place to put data.\n\nEach audio processor has a CanRun( ) member function, which returns TRUE if the node can run. CanRun( )'s default implementation uses the above rules, so a subclasser only has to override CanRun( ) if the audio processor needs to override a rule. If an audio processor can run, it simulates the flow of data out on all output ports. Fire( )actually just turns around and calls another Fire( ) member function on each output port. Firing an output port simulates the flow of data out the port, making simulated data available on the input port on the other side. Input ports have an IsAvailable( ) member function, which returns TRUE if the port has simulated data available.  illustrates an audio port in accordance with a preferred embodiment.\n"]}},"Delays must take priority over CanRun( ) because the input to a delay goes silent. Therefore, the delay must still produce output until the delay is exhausted. The input port no longer has data available but the audio processor must still run. CanRun( ) must be modified to return TRUE when no input is available and there is still data in the delay that must be output. Players must also override CanRun( ), because when a player is stopped, a player can't run, even if the dataflow criteria are met. Players must modify the rules so that CanRun( ) always returns FALSE if the player is stopped, regardless of whether dataflow criteria are met or not. An audio processor can query its audio output port to ascertain the delay from when the data is written to the port's buffer to when the audio will actually be heard by the user. This allows audio processors to synchronize to arbitrary time bases. ,  and  are flowcharts illustrating the logic associated with audio processors. An audio processor, such as a player, determines that execution is required and invokes RequestOrder, which is depicted in FIG. .",{"@attributes":{"id":"p-0109","num":"0116"},"figref":"FIG. 18","b":["1800","1810","1820","1830","1850","1840","1850"]},{"@attributes":{"id":"p-0110","num":"0117"},"figref":["FIG. 19","FIG. 19"],"b":["1900","1840","1990","1910","1920","1930","1940","1950","1960","1970","1980","1900","1920"]},{"@attributes":{"id":"p-0111","num":"0118"},"figref":["FIG. 20","FIG. 20"],"b":["2000","1830","2018","2080","2004","1920","2020","2024","2040","2050","2060","2070","2024","2080","2024"]},"If index i does not equal to N at decision block , then the output port i is marked as having NOT fired in function block , the audio processor connected to the output port is obtained at function block , counter i is incremented at function block , and a test is performed at decision block  to determine if the audio processor can run. If the audio processor cannot run, then a recursive call to the logic in  is placed via terminal . If not, then control is passed to decision block  to test the index again and continue the processing.",{"@attributes":{"id":"p-0113","num":"0120"},"figref":"FIG. 21","b":["2100","2104","2106","2110","2120","2104","2120","2122","2130","2124","2126"]},"Video information can be digitized, stored, processed, and played back on a computer. A video digitizer is used to convert an analog video electrical signal to a series of digital images, called a frame. The number of frames digitized per second is called the frame rate. Fifteen to thirty frames a second are typical frame rates. Once in digital form, the video can be stored and processed by the computer. The video can be played back by displaying the digital images in sequence at the original frame rate on a computer screen.","A graphic object is a base class used to represent any object that can be displayed on a computer screen. Subclasses of the graphic object, include, but are not limited to polygons, curves, and digital images. Each frame of digitized video is a digital image, and hence can be represented by a graphic object.","Graphic input and output ports are used to route graphic objects from one media component to another. Digital video can be routed this way, as each video frame is a graphic object. Animation data can also be routed with graphic ports, because graphic ports can route any graphic object. Using media components containing graphic ports, it is possible to create networks of video objects with video streaming between them. A variety of interesting applications can be constructed this way.  illustrates an example of patching a video digitizer component to a viewer component for display on the computer's screen in accordance with a preferred embodiment.",{"@attributes":{"id":"p-0117","num":"0124"},"figref":"FIG. 23"},"The process of connecting video components can be represented graphically on a display by extending a geometric figure such as a line segment between the indicia representative of a video input and output ports.","Graphic ports manipulate graphic data by reading and writing pointers to graphic objects. The port implementation for writing is synchronous: the graphic output port's Write( ) member function blocks until the receiver is done with the graphic object being sent. The graphic port does not employ copy semantics for performance reasons. Copying RGB bit-mapped images is avoided because of the amount of processor and storage involved in such operations. Instead, a pointer to the graphic object is sent from the graphic output port to the graphic input port. The synchronous interface functions across address spaces if shared memory is used for storing the graphic objects being written and read, or if the graphic objects are copied across a task's address space. Blocked graphic ports are unblocked in the event that a connection is broken.",{"@attributes":{"id":"p-0120","num":"0127"},"figref":["FIG. 24","FIG. 25"],"b":["2500","2510","2520","2530","2540","2560","2570","2580"]},{"@attributes":{"id":"p-0121","num":"0128"},"figref":"FIG. 26","b":["2600","2610","2620","2630","2640","2650","2650","2660"]},{"@attributes":{"id":"p-0122","num":"0129"},"figref":"FIG. 27","b":["2700","2710","2720","2730","2740","2760","2750","2760"]},"Musical Instrument Digital Interface (MIDI) defines an interface for exchanging information between electronic musical instruments, computers, sequencers, lighting controllers, mixers, and tape recorders as discussed in MIDI Manufacturers Association publication entitled, 1.0 (1990). MIDI is extensively used both in the recording studio and in live performances and has had enormous impact in the areas of studio recording and automated control, audio video production, and composition. By itself and in conjunction with other media, MIDI plays an integral role in the application of computers to multimedia applications. In comparison to digital audio, MIDI files take up much less space, and the information is symbolic for convenient manipulation and viewing. For example, a typical 3 minute MIDI file may require 30 to 60 Kilobytes on disk, whereas a CD-quality, stereo audio file requires about 200 Kilobytes per second, or 36 Megabytes for 3 minutes. MIDI data may appear as musical notation, graphical piano-roll, or lists of messages suitable for editing and reassignment to different instruments. General MIDI has standardized instrument assignments to greatly motivate the multimedia title producer.","MIDI input and output ports are used to route time-stamped MIDI packets from one media component to another. MIDI ports act as mailboxes for the communication of MIDI packets across address spaces. Many interesting MIDI applications can be created by connecting media components that contain MIDI ports.  illustrates how two components, a MIDI player  and a MIDI interface , can be used to play a music synthesizer connected to the computer. The MIDI interface is used to connect external devices, such as a music synthesizer. MIDI packets are sent from the MIDI player to the MIDI interface. The MIDI interface  converts the MIDI packets to MIDI data which is sent to the music synthesizer for playback.",{"@attributes":{"id":"p-0125","num":"0132"},"figref":["FIG. 29","FIG. 30"],"b":["2910","2900","3000","3010","3020","3010","3000","3010"]},{"@attributes":{"id":"p-0126","num":"0133"},"figref":"FIG. 31"},"The process of connecting MIDI components can be represented graphically on a display by extending a geometric figure such as a line segment between the indicia representative of a MIDI input and output ports.","Devices that support MIDI communicate with each other by sending and receiving MIDI messages. The MIDI standard defines two types of messages: channel messages and system messages. Channel messages are further divided into voice and mode messages. System messages are further divided into common, real-time, and exclusive messages as shown in FIG. . Channel Voice messages contain a channel number (0-15), to which a MIDI device can listen. Channel Mode messages are sent on the basic-channel to determine an instrument's response to Channel Voice messages. System Common messages go to all receivers, and System Real-time messages carry synchronization information to clock-based instruments. System exclusive messages allow manufacturers to offer MIDI support beyond that specified by the standard. All messages start with a status byte, except consecutive messages of the same type which may optionally drop the status byte (running status). All message types except system exclusive, have zero, one, or two data bytes. System exclusive messages consist of any number of data bytes, terminated by an EOX byte.  exhibits formats of MIDI messages in accordance with a preferred embodiment.","A MIDI packet object encapsulates all the MIDI message types and structures. In addition, all MIDI packet objects have a status byte and a time stamp, as shown in FIG. . Subclasses of MIDI packets reflect the MIDI protocol by defining message types with convenient constructors and access member functions.","MIDI ports are used to exchange MIDI packets between media components. A MIDI output port can write a MIDI packet, and a MIDI input port can read a MIDI packet. An output port can be connected to an input port with a surrogate port. Surrogate ports cannot read or write MIDI packets. Instead they are passive objects that can be passed to other address spaces to support connections. Member functions are provided for writing one or many messages at a time to an output port. Similarly, when reading from an input port, either the next message or a count of all buffered messages may be requested. Read will block until the buffer is non-empty, and a blocked Read call can be canceled by another task. A copy of the packet written to an output port is read from the input port.","Packets are read in order of arrival and are not sorted by time stamp. If time-ordered merging of two streams is required, a sorting merge object will be needed. To understand why an input port does not sort, recall first that time can flow both forwards and backwards. Consider a particular playback scenario involving a sequence with events at 6, 8, and 10 seconds. If time starts at 5, goes until 11, turns around, and goes back to 5, the order of events should be 6, 8, 10, 10, 8, 6 and not 6, 6, 8, 8, 10, 10. It is precisely because time goes in both directions that sorting does not suffice for buffering packets.","Fan-in and fan-out of connections is supported. Fanning refers to the capability of a MIDI output port to be connected to more than one MIDI input port, and a MIDI input port can have more than one MIDI output port connected to it.  illustrates an example of a fanning operation in accordance with a preferred embodiment.","A preferred embodiment utilizes a list of connected ports for keeping track of MIDI port connections and a shared buffer for delivering and receiving packets. Each port maintains a list of all the other ports to which it is connected. This list is updated by Connect and Disconnect calls and is used when ports are destroyed to notify all ports that are connected to it that have gone away. This processing prevents an output port from having an input port in its list of connections and trying to write to it, when in fact the input port was destroyed. Thus, an output port maintains a list of input ports that it uses to implement the Write call, and it writes to each port in its list. And an input port maintains a list of output ports that are connected to it and that must be notified when it goes away. A shared buffer supports a producer-consumer protocol. When the buffer is empty, a task may block until it is non empty. Another task that subsequently deposits into its buffer may notify the blocked task that it has written. Alternatively, yet another task may cancel the block, resulting in another kind of notification.","A MIDI output port's Write( ) member function is depicted in FIG. . Processing commences at terminal  and immediately passes to function block  to initialize a counter, and a limit value for a loop. Then, at decision block , a test is performed to determine if the counter has reached the limit value. If the counter has, then processing is completed at terminal . If the counter has not, then at function block , a copy of the packet is inserted into a port's buffer, and a test is performed at decision block  to determine if the buffer has a message. If the buffer is not empty, then an appropriate message is transmitted as shown in function block . If not, then no message is sent. In either case, the counter is incremented at function block  and control is returned via terminal .","A MIDI input port's Read( ) member function is depicted in FIG. . Processing commences at decision block  to determine if the buffer is empty. If so, then the task is blocked until the buffer contains information or a cancel occurs at function block . A test is performed at decision block  to determine if the wait was cancelled. If so, then an exception occurs at terminal . If not, or if the buffer was not empty at decision block , then a packet is copied from the buffer to the caller at function block  and processing is completed by returning at terminal .","A time-based media component, referred to as a media component base class is a central abstraction used for routing. A media component has zero or more input ports and zero or more output ports. In , for example, the media component has a single input port and two output ports.","Mediasequence is an abstract base class that represents media content, including audio sequences. Subclasses of mediasequence are used to represent clips of audio, video, and MIDI. Media sequences are characterized by a duration and a list of types. The duration, represented by a floating point value, indicative of how long the data is. The data is also typed, to indicate what type of sound is represented by the data, for example video, audio, etc. It is possible for a subclass to support multiple types. For example, an audio subclass can supply data in both a linear form and a compressed form. Because of this possibility, mediasequence has a list of types.",{"@attributes":{"id":"p-0138","num":"0145"},"figref":"FIG. 39"},{"@attributes":{"id":"p-0139","num":"0146"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0140","num":"0147"},"figref":"FIG. 41"},{"@attributes":{"id":"p-0141","num":"0148"},"figref":"FIG. 42"},{"@attributes":{"id":"p-0142","num":"0149"},"figref":"FIG. 43"},{"@attributes":{"id":"p-0143","num":"0150"},"figref":"FIG. 44"},{"@attributes":{"id":"p-0144","num":"0151"},"figref":"FIG. 45"},{"@attributes":{"id":"p-0145","num":"0152"},"figref":"FIG. 46"},{"@attributes":{"id":"p-0146","num":"0153"},"figref":"FIG. 47"},{"@attributes":{"id":"p-0147","num":"0154"},"figref":"FIG. 48"},{"@attributes":{"id":"p-0148","num":"0155"},"figref":"FIG. 49"},{"@attributes":{"id":"p-0149","num":"0156"},"figref":["FIG. 50","FIG. 51"],"b":["5100","5110","5120","5130","5140","5150"]},{"@attributes":{"id":"p-0150","num":"0157"},"figref":"FIG. 52"},{"@attributes":{"id":"p-0151","num":"0158"},"figref":"FIG. 53"},{"@attributes":{"id":"p-0152","num":"0159"},"figref":"FIG. 54"},{"@attributes":{"id":"p-0153","num":"0160"},"figref":"FIG. 55"},{"@attributes":{"id":"p-0154","num":"0161"},"figref":"FIG. 56"},{"@attributes":{"id":"p-0155","num":"0162"},"figref":"FIG. 57"},{"@attributes":{"id":"p-0156","num":"0163"},"figref":"FIG. 58"},{"@attributes":{"id":"p-0157","num":"0164"},"figref":"FIG. 59"},{"@attributes":{"id":"p-0158","num":"0165"},"figref":"FIG. 60"},{"@attributes":{"id":"p-0159","num":"0166"},"figref":"FIG. 61"},{"@attributes":{"id":"p-0160","num":"0167"},"figref":"FIG. 62"},{"@attributes":{"id":"p-0161","num":"0168"},"figref":"FIG. 63"},"While the invention has been described in terms of a preferred embodiment in a specific system environment, those skilled in the art recognize that the invention can be practiced, with modification, in other and different hardware and software environments within the spirit and scope of the appended claims."],"BRFSUM":[{},{}],"heading":["COPYRIGHT NOTIFICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","Classes for Routing","Connecting Media Components","Routing Audio Data","Implementing Audio Components","Client\/Server Model","Making Connections","Processing Audio","Frame-Based Processing","Ordering Audio Processors","Routing Video and Graphical Data","Routing Data","Routing MIDI Data","MIDI Packets","MIDI Packet Encapsulates the Standard","MIDI Ports","Implementing MIDI Ports","Abstract MultiMedia Components","Media Component","Media Sequence","Player","Standard Audio Components","Audio Player","Speaker","Microphone","Mixer","Splitter","Gain","Echo","Fuzz","Audio Type Converter","Audio MultiConverter","Sound","Physical Speaker","Physical Microphone","Standard Video Components","Graphic Player","Graphic Viewer","Video Digitizer","Standard MIDI Components","MIDI Player","MIDI Interface","MIDI Filter","MIDI Mapper","MIDI Program Mapper","MIDI Note Mapper","MIDI Channel Mapper"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 16","FIG. 15"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 28","b":"2810"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 39"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 41"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 42"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 43"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 44"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 45"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 46"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 47"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 48"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 49"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 50"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 51"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 52"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 53"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 54"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 55"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 56"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 57"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 58"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 59"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 60"},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 61"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 62"},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 63"},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 64"}]},"DETDESC":[{},{}]}
