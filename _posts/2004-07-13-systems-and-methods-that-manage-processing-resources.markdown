---
title: Systems and methods that manage processing resources
abstract: The present invention provides a port-based technique to manage processing resources that can be utilized by an Operating System. The systems and methods consider time parallelism and pre-emption through sends, receives, and execution context, wherein scheduling of execution units occurs via (aperiodic and/or periodic) communication rather than time slicing. The systems and methods employ a resource manager that listens behind a port associated with a processor, which enables the processor to transition to a reduced power consumption state. When a request for processing resources arrives at the port, the resource manager can allocate the processing resources, wake the processor, and/or return a communication, which can include a location of allocated memory and an execution context of the processor, to a reply channel. Alternatively, the resource manager can preempt the request to mitigate processing resources consumption.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07689998&OS=07689998&RS=07689998
owner: Microsoft Corporation
number: 07689998
owner_city: Redmond
owner_country: US
publication_date: 20040713
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE INVENTION"],"p":["The present invention generally relates to computer processing, and more particularly to systems and methods that allocate computing\/processing resources in a system where all computation is based on communication.","The personal computer has evolved from a luxury that was mainly utilized for word processing to a common household item that is utilized to manage finances, control lighting, security and entertainment systems, pay bills, store recipes, search for information, purchase\/sell goods, participate in gaming, complete school assignments, etc. The evolution has been facilitated by developments and\/or advancements in electrical\/electronics related technologies (e.g., chip manufacturing, bus topologies, transmission medium, etc.) and software related technologies (e.g., operating systems, programming languages, networks, etc.). Such developments and\/or enhancements have reduced component size, manufacturing, labor and business (MLB) expenses, and power consumption, for example, and have rendered high-performance\/low cost user-friendly computing machines. Similarly, various technological developments and\/or advances have transformed mainframes and workstations from basic data processing machines employed by businesses to efficient computing machines that automate control of entire plants, facilitate creating and sharing documentation, and connect employees\/companies that reside in different locations around the world.","A typical computing machine is provided with software (e.g., an Operating Systems (OS) that provides a framework to execute and\/or build applications, view data, control apparatuses, etc. Traditional OSs were developed under a single thread approach, wherein individual processes (e.g., tasks) are handled one at a time. For instance, if five processes were ready for execution, the CPU processes only one of the processes at any given time while the remaining processes are queued for subsequent processing. Such systems commonly employed one or more mechanisms to interrupt processing and transparently re-use resources, for example, to handle higher priority processes.","Advances in the arts lead to the introduction of a multithreaded-multitasking environment, which set forth a notion of concurrent execution of multiple processes or subprocesses. However, with multithreaded-multitasking systems concurrent execution is constrained by the number of processors a particular computing machine employs, wherein the number of processes that can be concurrently processed is proportional to the number of processors. Thus, a single CPU multitasking system, in reality, does not process tasks concurrently. Rather, a hybrid approach is utilized that can appear to concurrently execute processes. For example, in many systems, CPU cycles are shared across multiple processes, but only one process can consume the CPU at a time and respective processes are provided with the CPU for a limited time.","Many conventional single CPU multitasking (multithreaded) systems utilize a time-slice technique to simulate concurrent process execution and preserve responsiveness of any one task to the user or external computing nodes, including devices. For example, the CPU can be utilized to execute at least a portion of one process for one or more clock cycles (a time slice) while processes awaiting the CPU can be stored in a run queue or transition to a \u201csleep\u201d or \u201cwait\u201d state. Upon lapse of the time slice, access to the CPU can be halted regardless of whether processing is completed; in many systems, the time slice is associated with a grace period to provide for smooth termination of processing resources after a time slice expires. The CPU can then be provided to another process for a time slice. This cycle can continue and eventually a second, third, fourth, etc. time slice is provided in order to complete execution of a process.","In many instances, sharing a system's CPU is transparent to a user and appears to provide \u201ctrue\u201d concurrent processing; although, as noted above, concurrent processing does not occur in a single CPU system. This scenario typically occurs when a few simple processes are executing. However, when CPU\/memory hungry applications are executing, competition for limited processing resources and time slice-based processing (serial processing) can be readily apparent to a user. For example, a common phenomenon experienced when running several applications (e.g., word processing, spreadsheet, database, computation, etc.) is increased delay between the time a user issues an event (e.g., a mouse click) and completion of an associated task. Examples of this phenomenon include increased time to save a document or render characters on a display after pressing a key on a keyboard. In some instances, the demand for processing resources can result in a momentary system \u201chang\u201d and\/or a premature termination (e.g., re-boot) without invocation or instruction by the user.","The time-sharing model is a good implementation technique for abstracting true concurrency in a system and allowing a developer to program targeting the desired concurrency of their program, independent of the target. However, it requires heavy weight scheduling mechanisms and, in many cases, processor support so the thread transition is seamless and correct (not observable). Additionally, it fails to guarantee responsiveness under all circumstances since it does not require upfront reservation of resources (e.g., CPU, memory, peripheral bandwidth, etc.). Furthermore, the treatment of resources is not uniform; CPU cycles are managed transparently or with adhoc hints from the user. Memory resources and device bandwidth are managed in yet another way. In addition, the hardware system is required to have a \u201cheartbeat\u201d or clock tick so it can periodically check all threads\/processes to determine whether they are ready for execution or if the time slice has expired. This is computationally expensive and the periodic timer consumes power cycles. The time-sharing, multi-tasking\/threading model also requires a complex programming model, commonly referred to as a threading model, which is often misused and difficult to get right.","The following presents a simplified summary of the invention in order to provide a basic understanding of some aspects of the invention. This summary is not an extensive overview of the invention. It is intended to neither identify key or critical elements of the invention nor delineate the scope of the invention. Its sole purpose is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.","The present invention relates to systems and methods that provide a framework for a computing environment. This framework can be utilized to implement an Operating System (OS) (e.g., run in place of or on top of essentially any traditional OS) and leverages a notion of a communication paradigm, wherein processing resources are allocated after transmitting a request for resources to execute a process, a task, a continuation, an item of execution, etc. Thus, the framework can be utilized to provide processing resources in response to communication rather than a time slice as utilized in conventional systems. This framework additionally provides a uniform treatment of resource allocation and reuse and does not rely on a notion of threads (which can be completely eliminated). In addition, the notion of time can be eliminated as a basic primitive. Instead, clock signals (e.g., messages issued by signal generators) can be treated as resources that are available for allocation like memory, CPU time and\/or device bandwidth is made available.","Conventional systems typically utilize the time slice approach (rather than a communication-based approach) to processing, wherein a time slice (e.g., a time slice \u201ct\u201d) is associated with a process and, for that period, processing resources are dedicated and\/or allocated to executing at least a portion of the process. Upon lapse of the time slice, processing resources are re-allocated for a next process (which could be the same process) associated with a next time slice (e.g., \u201ct\u201d). In many instances, such time slicing corresponds to a system clock (e.g., internal or external), wherein the processor expends resources locating processes to handle with each clock tick\/cycle. The time slice approach is commonly utilized in conventional multitasking environments, wherein tasks can appear to be concurrently executing even though they are serialized and executed within respective time slices. A user of an application can see this serialization even though the operating advertises real-time concurrent processing. For example, the user can invoke an event (e.g., via mouse click) and the time in which the system responds and the length of time consumed to respond depend on processing resources demand, placement of the task in a task queue, etc.","The subject framework provides a novel port-based approach, which considers time parallelism and pre-emption through sends, receives, and execution context, wherein scheduling of execution units occurs via communication rather than time slicing. Thus, rather than utilizing a fixed clock and providing a predefined period in which a task can be executed (at least in part), the present invention provides for a \u201cfree running\u201d system that responds to communication. This enables the processor to limit power and\/or processing consumption (e.g., to essentially zero) unless and\/or until a request for processing resources is transmitted by a client, whereas conventional systems typically consume power at least at clock frequency.","Although a clock is not necessary, the resource manager can compose with a clock (e.g., via a signal generator) for any client that desires periodicity and\/or to facilitate preemption. This novel port-based approach can provide a reservation type scheme, wherein a client can request processing resources, a port to execute continuations, and, optionally, a clock. This enables a client to bind a port for such execution and, optionally, introduce periodicity. It is to be appreciated that a clock tick can be just another message received on a port that a client can utilize as a timeout or as a means to throttle utilization of resources. For example, a timeout can be implemented by just counting messages. In addition, the underlying infrastructure typically utilizes a similar mechanism to throttle utilization of message allocations, thus providing a scale invariant technique to control execution.","It is to be appreciated that the systems and methods of the present invention can additionally be considered as novel improvements over traditional cooperative (e.g., event\/message) based systems. In general, such systems utilize cooperative multitasking, wherein a process currently controlling a CPU typically must offer control to other processes; therefore, programs must cooperate in order for the system to work. Thus, if one program does not cooperate, this non-cooperative program can consume the CPU such that other programs cannot utilize the CPU. This is in contrast to multi-threaded systems (e.g., as described above) that typically force applications to share the CPU based on a time slice, whether the applications are willing to or not. The present invention can mitigate cooperative multitasking by throttling and preempting through turning each interaction into a request for a message allocation, etc. Thus, the present invention can mitigate both cooperative multitasking (e.g., by event\/message based systems) and time-sharing multitasking (e.g., by thread-based systems).","The novel framework of the present invention includes a resource manager that handles requests for processing resources and\/or allocates such resources. A typical request for processing resources can include a request to execute within a processing context (e.g., typically one per processor) and a reply channel (or a reply port) for a response and can be associated with a continuation (e.g., a task). In general, a relatively small number of initial requests are provided upon application startup; however, the resources manager allocates substantially all subsequent messages. The foregoing provides for throttling. For example, for a client application to do any computation the client application has to ask for a message resource (e.g., memory). Upon allocating message recourses, the client can utilize the resource as a request on some port to trigger computation of some other client application or system process. The resource manager can be associated with a port (or a port service) of a processor and can listen behind the port, and such port can also be a resource allocated by interacting with the resource manager.","With this approach, one or more communications (e.g., an interrupt request (IRQ), a message, a signal, etc.) can concurrently arrive at an allocated dispatcher port that can have processors. The one or more communications can be received, prioritized and\/or stored within and\/or across queues that can be associated with disparate priority levels. These queues can be scrutinized and communications stored therein can be handled based on respective priority levels, for example.","By leveraging this communication only paradigm, wherein the client code only issues sends (e.g., the receive operation can be translated to a request to receive with a callback, etc.), a client does not have to wait for a reply and\/or any acknowledgement after transmitting a communication. Instead, the current client execution routine stops execution since it has registered a future callback associated with the receive operation. If the resource manager determines that the requested resources are available and that these resources should be provided for execution of a task, the resource manager can transmit a communication to a reply channel, wherein the communication can include a location of allocated memory, a context of execution, etc. In other instances, the resource manager can preempt a request and mitigate processing resource consumption.","It is to be appreciated that the novel systems of the present invention can be modeled via mobile process algebras such as asynchronous pi calculus and join calculus, for example. Thus, programming languages inspired by such models can target this system in a more natural way than traditional OS application programming interfaces (APIs). In addition, a programmer can write in a synchronous receive fashion, wherein a compiler can target the novel runtime of the present invention by re writing the synchronous receive code to an asynchronous choice request with a continuation attached.","The following description and the annexed drawings set forth in detail certain illustrative aspects of the invention. These aspects are indicative, however, of but a few of the various ways in which the principles of the invention may be employed and the present invention is intended to include all such aspects and their equivalents. Other advantages and novel features of the invention will become apparent from the following detailed description of the invention when considered in conjunction with the drawings.","The present invention relates to systems and methods that consider time, parallelism and preemption in a computing environment through sends, receives, and execution context. In general, scheduling of execution units occurs based on communication (rather than time slicing), which provides for a \u201cfree running\u201d (clockless) port-based approach to managing processing resources, for example, by an Operating System (OS). This approach can enable a processor to transition to a reduced power consumption state when its processing resources are not requested. When a client request for the processing resources is transmitted to an allocated port, it can be queued and subsequently utilized to allocate processing resources. A communication (e.g., with the location of memory, a context of execution, etc.) can then be sent to a reply channel or the request can be preempted in order to mitigate consumption of processing resources.","As utilized in this application, terms \u201ccomponent,\u201d \u201csystem,\u201d and the like are intended to refer to a computer-related entity, either hardware, software (e.g., in execution), and\/or firmware. For example, a component can be a process running on a processor, a processor, an object, an executable, a program, and\/or a computer. By way of illustration, both an application running on a server and the server can be a component. One or more components can reside within a process and a component can be localized on one computer and\/or distributed between two or more computers.","The present invention is described with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It may be evident, however, that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to facilitate describing the present invention.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 1","b":["100","110","120","110","110","110","110","110"]},"In general, the resource manager  can be associated with the processing resources of an entity. When such an association is established, the resource manager  can receive one or more (e.g., all or a subset thereof) communications (e.g., messages, interrupts, etc.) directed to the entity. In one aspect of the invention, an incoming communication can include a request for resources and\/or a request for a context of execution. Such a request can include a particular resource (e.g., a quantity, a location, etc.) and\/or context or other information that can be utilized to determine suitable resources and context. In addition, the communication can include a return location (e.g., an address) or a name (e.g., an alias), which can be the requesting client's location and name and\/or the location and name of another client. For example, a first client can request processing resources for a second client, wherein communication from the resource manager  can be conveyed to either the first or the second client. Furthermore, the communication can include timing information that indicates when and how often the resource manager  can communicate with the client. Moreover, the communication can include information related to an item (e.g., a task, a continuation, etc.) that will be processed by the allocated resources.","Such communications can be stored in a temporary or permanent storage area (e.g., a buffer, volatile memory, non-volatile memory, a register, etc.) or handled upon arrival. When handling a communication, the resource manager  can extract the aforementioned information (e.g., the resources request, the context, a reply path, etc.), as well as other information residing within or conveyed with the communication. It is to be appreciated that the communication can be variously packaged. For example, the communication can be received as a stream, one or more bursts and\/or one or more data packets. In addition, the communication can be compressed, encrypted, encoded, modulated, encapsulated within an envelope, etc. Upon extracting information from the communication, the resource manager  can analyze, interpret, decipher, etc. the information and determine the purpose of communication. Thus, if a communication includes a request for memory, the resource manager  can extract this request and determine the quantity, location, type, etc. of requested memory and\/or allocate such resources.","In addition, the resource manger  can utilize any extracted information to determine whether a response is warranted. For example, where the communication is a request for memory, the resource manager  can check for available memory. It is to be appreciated that memory can be modeled in non-traditional ways. For example, in one aspect of the present invention memory is only available in the form of messages that are allocated through interaction with the resource manager . As with traditional messaging systems, messages typically are only utilized by one process at a time or they can be enforced to be write-once, read many. If the requested resources are not available, the resource manager  can accordingly notify the component, ignore or disregard the communication and\/or forward the communication to another port associated with different processor. In instances where the requested resources can be fulfilled but are not available, the resource manager  can postpone transmitting any communication until the resources become free. However, it is to be appreciated that the resource manager  can determine not to provide any processing resources, regardless of availability. Thus, the resource manager  can preempt the request and\/or offer a different set of resources. When the resource manager  grants processing resources (e.g., the resources are available and the grantor is willing to provide the resources), the resources can be utilized to execute the corresponding item.","When the resource manager  handles an incoming communications, the client can stop executing, wherein its context of execution can be reused for another process. When the resource manager  allocates suitable processing resource, the client code can be \u201cwoken\u201d or instantiated, wherein the client can utilize allocated resources to process a continuation or task. In another aspect of the invention, the continuation or task specified can be processed with the allocated processing resources without any need to \u201cwake\u201d or instantiate the client.","A processor associated with the resource manager  can operate in a \u201cfree running,\u201d clockless mode since the resource manager  can handle communications for the processor as communications arrive. For example, the entity does not need to poll or search clients or queues at a periodic interval (e.g., based on an associated clock) to determine if a communication is ready to be handled. Rather, the entity can enter a state in which essentially no processing resources (e.g., processing cycles) are consumed. In addition, the resource manager  can transition to a similar state. The resource manager  can \u201cwake\u201d upon the arrival of a communication and respond accordingly. When operating as a communication only system with concurrency, known primitives such as join and choice can be utilized to handle concurrent, free-running message streams.","In addition, the resource manager  can maintain a record of allocated processing resources in order to account for available resources. Furthermore, the resource manager , as discussed briefly above, can limit the processing resources allocated or refrain from providing any processing resources; thus, the resource manager  can preempt a client from utilizing the processing resources of the entity. Moreover, the resource manager  can behave aperiodically or periodically, depending on the client request.","The resource manager  can communicate with one or more clients and\/or the entity through the interface . Communication with such components can be through wire and\/or wireless technologies. Suitable technologies include technologies based at least in part on radio frequency (RF), infrared (IR), optics, Wi-Fi, Blue-Tooth, Ethernet (e.g., 10Base-T, 100Base-T, and 1000Base-T), Universal Serial Bus (USB), standard serial or parallel communication, etc. In addition, communication can be over a bus and\/or network. For example, the resource manager  can reside on a bus local to the entity. In one aspect of the invention, the local bus can be a system bus of the entity or a bus residing on a daughter module coupled to a backplane of the entity. In another example, a client can be executing in a machine with the resource manager  or in connection with a remote machine. Irrespective, the client can convey communications to the resource manager  via a bus, as described above, and\/or over a network such a Local Area Network (LAN) or Wide Area Network (WAN) (e.g., the Internet).","It is to be appreciated that the system  and, optionally, the remaining systems, methods, etc. (and variations thereof) described herein can be modeled via a process algebra and\/or derivation thereof. Examples of suitable process algebra include pi calculus (e.g., asynchronous) and derivations thereof, join calculus and derivations thereof, etc. For example, process algebra can be utilized to represent a communication transmission, a request for processing resources, a reply channel, a communication receiving port, a resource manager, a scheduler, a sequencer, a port service, a processor, an execution context, a location of memory, requested memory, a signal generator, etc. Thus, essentially any programming language can target the system  in a more natural way than traditional OS application programming interfaces (APIs). In addition, a programmer can write in a synchronous receive fashion, wherein a compiler can target the novel runtime of the present invention by re writing the synchronous receive code to an asynchronous choice request with a continuation attached.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 2","b":["200","110","120","210","210","210","120","110","110","110"]},"Although a clock is not required, the resource manager  can compose with a clock, if desired. Thus, a client can transmit a communication that includes a request for a clock, along with other information such as resources, an execution context and a reply channel, for example. In one aspect of the present invention, the signal generator  can be utilized as a clocking device. For example, the signal generator  can be configured to operate at a frequency of one tick per cycle (e.g., one microsecond). With this configuration, the signal generator  can be utilized to provide a one-tick clock or a clock executing at multiples thereof. It is to be appreciated that the clock tick is just another message received on a port. This tick can be utilized by a client to issue a timeout. For example, a timeout can be implemented by counting messages or clock ticks. In addition, the clock tick can be utilized to facilitate throttling the utilization of message allocations and, thus, provides a scale invariant technique to control execution.","The frequency of the clock can be varied by piggybacking on a tick (e.g., via join, as described below) until a desired frequency is achieved. For example, rather than transmitting on a first tick, the communication can be delayed until a second tick, for example, simply by counting messages. Thus, the one tick clock essentially becomes a two-tick clock. An N-tick clock, where N is a real number, can be created by counting N\u22121 messages and transmitting on an Nth tick. Utilizing a join mechanism to implement derivative clocks of various frequencies provides for novel improvements since it allows client code to never have to think about clocks and\/or time differently than it does for traditional messages, like the number of responses it received from M (where M is an integer greater to or equal to 1) different remote services. Thus, associating a signal generator with a request for a message and utilizing a join couples resource consumption with some clock signal. Controlling the rate of the signal generator can be through reservations and implementing a hard real-time system. In addition, join can be utilized for message aggregation and\/or controlling timeouts based on clock ticks.","In other aspects of the present invention, an occurrence of an event or observed stimuli can act as clocking device (e.g., aperiodic and periodic). For example, a threshold can be associated with a temperature, an action, a state, a condition, etc. and crossing and\/or equaling the temperature, action, state, condition, etc. threshold can trigger the resource manager  to send a communication. Thus, a client can transmit a communication to the resource manager  and include triggering criteria. The resource manager  can refrain from transmitting a communication to the client until the criteria is achieved. By way of example, a client can transmit a communication to the resource manager  that includes a request for \u201cX\u201d resources and port \u201cY.\u201d The communication can further include a reply channel \u201cZ\u201d and threshold criteria.","The resource manager  can receive this information from the communication and determine whether the request can and should be accepted or denied. When the resources and port become available and the criteria is met, the resource manager  can send a communication to the reply channel \u201cZ.\u201d It is to be appreciated that a temperature threshold was utilized in the foregoing example for explanatory purposes and does not limit the invention. Essentially, the client can define the criteria. In addition, the signal generator  and triggering criteria can be utilized in combination such that the resources, port of execution, and criteria are checked based on a clock frequency produced by the signal generator .",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 3","b":["300","300","110","120","210","310","330","340","110","340","110","120","110","340","340","310","330"]},"In another example, respective queues  can be delineated into regions of different priority. Thus, communications with high priority and communications with low priority can be stored in a similar queue (e.g., queue ), but in separate regions. In yet another example, the queues  can be assigned a priority level and individual queues  can further delineate based on priority to provide for greater discrimination resolution. Thus, communications with high priority information can be stored in a designated high priority queue, and the high priority communications stored therein can be further separated based on priority.","The resource manager  can scrutinize the queues  to determine which communications should be handled prior to other communications. For example, the resource manager  can begin by scrutinizing queues designated for high priority communications. If any such communications are located, the resource manager  can handle the communications. The resource manager  can then scrutinize the queue designated with the next highest priority level and handle any stored communications. This approach can continue until all the queues can be scrutinized and communications requiring service can be handled. In another aspect of the present invention, each time the resource manager  checks the queues it can start with the queue designated to the highest priority communications. Thus, after handling any communications in the queue designated to the highest priority communications, the resource manager  can scrutinize the next queue. If at least one communication is located, the resource manager  can handle the communication. Then, the resource manager  can go back and scrutinize the queue designated to the highest priority communications to address any high priority communications that arrived since the queue was last checked for communications. This approach can guarantee that the highest priority communication is handled with each iteration.","The above two examples depict a sample of suitable techniques that can be employed in various aspects of the invention. It is to be understood that essentially any technique can be employed. Typically, a user of the entity can define a particular approach to employ. In some instances, intelligence (e.g., machine learning) can be utilized to facilitate determining a suitable approach. For example, an intelligent component (not shown) can utilize training sets (e.g., explicit and implicit), a rule base, probabilities, inferences, statistics, history logs, user information, etc. to facilitate selecting and\/or creating an approach to handling stored communications that considers priority. In still other aspects of the invention, a priority can be indicative of the user, a time of day, a day of the week, a duty cycle, a machine, a bandwidth, a capacity, a current load, processing resources, etc.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 4","FIGS. 1-3"],"b":["400","400","410","420","420","410","410","430","410","410","110","420","410","440","430","420"]},"Clients can request processing resources from the entity  by transmitting a request to the port . The request can include a request for a particular amount (e.g., a range) of memory, a request to execute in the context of the entity , whether a clock is desired, triggering criteria (if any), a request for a continuation, and a reply channel. As noted previously, a request can be received as a stream, a burst(s) and\/or a data packet(s), wherein the contents is compressed, encrypted, encoded, modulated, encapsulated within an envelope, etc. Upon transmitting such request, the client can stop executing and its context of execution can be reused for another process. When suitable processing resource are allocated, the client can utilize the allocated resources to being or continue processing a task.","The resource manager  can receive this request, as well as other requests (e.g., IRQs, etc.), through the port . Received requests can be stored in the queues , for example, based on a scheme that considers priority, preferences, rules, etc., as described in detail above. It is to be appreciated that the scheme utilized can consider any combination of the foregoing information, as well as the information. When utilizing multiple bins of information (e.g., a priority consideration bin, a preference consideration bin, a rules consideration bin, etc.), various weighting techniques (e.g., linear and non-linear) can be utilized by a user to bias the resultant criteria. Upon classifying the request (e.g., high priority), the resource manager can store the request in the queues .","The resource manager  can search the queues  and transmit replies via specified reply channels. The order in which requests are handled can be determined by the entity  or user thereof. For example, the resource manager  can respond to requests based on a priority associated with the request and\/or a priority assigned to the request. The resources manger  can search the queues  and the requests stored therein to determine such information. In addition, intelligence (as described herein) can be employed to facilitate any decisions.","When handling a particular request, the resource manager  can determine whether the processing resources are available, and the resource manager can transmit a communication to the specified reply channel, wherein the communication can include a link (e.g., name, alias, address, etc.) to allocated resources. The execution context of the processor  can be reserved and the task associated with the request can be executed by the processor, within its execution context. In one aspect of the invention, the processing resources can be granted such that the processing resources can be locked until the task is complete. In other instances, execution can be halted and the processing resources can be released when a predefined event occurs. For example, if a higher priority communication such as an error message is received, execution can be paused or terminated. If or when the resources and execution context become available again, execution can resume from where it was paused or re-start. In another example, the task can require execution of a second task, wherein the execution context is provided to the second task for execution and then returned to the original task.","In circumstances where the resource manager  determines that it will not provide the requested processing resources, the resource manager  can preempt the request. Thus, the entity  can determine which clients can utilize its execution context, the quantity of processing resources it is willing to provide to a client, how long it will allow its processing resources to be utilized to execute a task, etc. In addition, preemption can be utilized when the requested processing resources are greater than the entity  can provide.","In yet other aspects of the present invention, a signal generator  can be utilized to restrict access to the processing resources. For example, in order to preempt a request and prevent any task from indefinitely consuming processing resources, the signal generator  can be utilized to release the execution context of the processor  after a predetermined time (e.g., a cycle or multiple thereof). The signal generator  can further provide a clocking mechanism for any request that specifies a clock is desired for periodicity.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 5","b":["500","505","500","510","510","510","510","520","520","520","520","530","530","530","530","520","530","540","540","540","550","550","550","550"],"sub":["1 ","N ","1 ","N ","1 ","N ","1 ","N ","1 ","N "]},"The system  further includes a message arbiter  (e.g., an allocated dispatching port) that receives incoming messages and facilitates conveying messages to respective ports . In one aspect of the invention, a received message can include a request for a particular execution context. The message arbiter  can determine whether the message specifies an execution context associated with a particular processor or any execution context of the entity . The message arbiter  can employ various techniques to determine which of the processors  should be utilized to service the request. In one example, if a particular execution context is specified, the message arbiter  can forward the message to the corresponding port or store the message in the system queue .","A stored message can be retrieved or conveyed to the appropriate port at a later time. For example, a messages directed to port can be stored in the system queue . Examples of situations where such storage can occur includes instances where the resource manager rejects the message, the resource manager is unavailable, the resource manager is inoperable, and the request includes information stating the message should be stored in the system queue . In another example, the message may not specify an execution context. In these instances, the message arbiter  can forward the message to an available port or store the message in the system queue . For a stored message, when a port becomes available, the message can be conveyed to a port or a resource manager associated with the port can retrieve or request the message.","The message arbiter  can additionally be utilized to provide security for the entity . For example, the message arbiter  can scrutinize the content of a message to determine a valid port and processor are identified, whether requested resources are within an authorized set of resources, whether an item of execution (e.g., a task) is valid, etc. In one instance, an item of execution can be compared with a database (e.g., a reserved section of the system queue , an external common database, etc.) of known malicious tasks or known valid tasks. In another example, a probability and\/or confidence level can be utilized wherein the entity  can determine a level of risk it is willing to accept.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 6","FIG. 4) and 510","FIG. 5"],"b":["600","600","610","610","410","600","620","630","640","620","650","660"]},"The system  further comprises a communication network  (e.g., wire or wireless) and a plurality of entities  through , which can be similar to the entity . At least one of the plurality of entities  through  can be a component with an item of execution. Such component can transmit a request to the port . As described previously, the request can include requested resources, a request for the execution context, a request for a clock, message triggering criteria, a reply channel, etc. The entity  can reside in a \u201cfree running\u201d state wherein the processor  does not expend any processing resources, for example, to check for requests based on a clock cycles. Instead, the resource manager  can receive requests at the port . Upon receiving a request, the resource manager  can allocate at least a portion of memory  and provide the context of the processor  to execute the item. If the request includes a request for a clock, the resource manager  can employ the signal generator  and periodically (e.g., based on communication transmissions), provide the allocated memory and the execution context to the reply channel when the resources and context are available or terminate execution.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIGS. 7-10"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 7","b":["700","710"]},"When a communication is received at the port, the resource manager determines the purpose of the communication, for example, whether it is a request for processing resources, whether it is an interrupt request, etc. As described supra, the communication can be delivered as a stream, a burst(s) and\/or a data packet(s). In addition, the communication can be compressed, encrypted, encoded, modulated, encapsulated within an envelope, etc. Where multiple communications are concurrently received, one or more communications can be stored in a storage bank. It is to be understood that concurrent as utilized here can refer to simultaneous reception of one or more communications, delayed receptions with at least partial overlap, and separate receptions wherein a second communication arrives prior to completely handling a first reception. The communication can be stored in a first-in-first-out (FIFO), first-in-last-out (FILO), random, or a prioritized manner, for example. The technique in which the communications are handled can vary. For example, in one instance communications can be handled based on importance as indicated by a priority level.","If a communication includes a request for processing resources, information from the communication (e.g., a quantity and type of processing resources, an execution context, indicia indicating whether clocked communication is desired, a reply channel, as well as other information) can be obtained. At reference numeral , the availability of the processing resources is determined. If the processing resources are not available, the communication can be queued or denied until such processing resources are available. If the processing resources are available, at  a communication can be transmitted to a reply channel specified in the request. This communication can include the location of reserved resources (e.g., a pointer, an address, etc.) and access to a processor. At , the processor can be utilized to execute a continuation (e.g., an item of execution, a task, etc) associated with the request.","It is to be appreciated that the foregoing method enables the entity to operate in a \u201cfree running,\u201d clockless mode, wherein the processor is not utilized to periodically (e.g., base on a clock) check for communications. Rather, the processor can transition to an idle state and the resource manager can handle communications. In addition, the resource manager can selectively allocate resources, which provides a mechanism to account for processing resources, preempt requests for processing resources, and limit the processing resources utilize at any given time, for example. However, it is also to be appreciated that a clocking mechanism can be utilized when specified in a request as described herein. Moreover, it is to be appreciated that process algebra (as described herein) can be utilized to model some or all acts and associated actions with the methodology  as well as the remaining systems, method, etc. described herein.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 8","b":["800","810"]},"At , the resource manager can retrieve information from the request and allocate processing resources based on the information. As described herein, the processing resources can include memory and an execution context, for example. In response to the request for a clock, a signal generator can be utilized to create a clock. By way of example, the signal generator can be configurable such that its frequency can be defined. This can be achieved by associating the signal generator with a request for a message and utilizing a join to couple resource consumption with some clock signal. Controlling signal generator rates (e.g., which are allocated like any other resource) can be considered an approach that utilizes reservations and through potentially implementing a hard real-time system. It is to be appreciated that the signal generator can receive and generate messages sent on ports similar to other processes. By interacting with the signal generator, the client code can be utilized similar mechanisms of receiving and coordinating between processes and messages.","In one example, the frequency can be set to one tick per cycle. With this configuration, an M tick clock (where M is an integer greater to or equal to one) can be constructed by utilizing joins to delay a response until the Mth tick by counting messages. This clock can provide periodicity where requested. In other aspects of the present invention, an event and\/or observed stimuli can be utilized to facilitate clock generation. For example, a threshold temperature, action, state, condition, etc. can be specified, wherein crossing and\/or equaling the threshold can be analogous to a tick and trigger the response. The threshold can be utilized to create the M tick clock, via joins, to delay the response until the Mth trigger, or the Mth time the threshold is reached. This clock can provide periodicity or aperiodicity, depending on the frequency in which the threshold is reached. It is to be appreciated that various combinations of time-based and threshold-base, as well as other techniques, can be utilized to create a desired clock.","At reference numeral , communications can be transmitted based on the signal generator. For example, a communication can be transmitted on the Mth tick. In another example, a communication can be transmitted when the threshold is reached or the Mth threshold is reached. In yet another example, a communication can be transmitted after a clock cycle (or Nth clock cycle) and the threshold (or Mth threshold) is reached. The communication can include the location of allocated memory and the execution context. At , the context can be utilized to execute a task. It is to be appreciated the clock can be utilized to terminate (e.g., preempt) a task in execution. For example, a higher priority request can be received which elicits a preemption of a presently executing task. In another example, the processing resource can be shared to execute other task, wherein each task is provided with the processing resources for a limited number of clock cycles. When the limit is reached, a communication can be transmitted which transfers the processing resources for another task.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 9","b":["900","910","920"]},"The resource manager typically scrutinizes queues based on priority. Thus, high priority queues can be scrutinized before low priority queues or vice versa. Likewise, scrutiny within a queue can be based on priority. Typically, requests within a high priority queue are handled before scrutinizing a lower priority queue. In addition, higher priority queues can be rechecked from time to time to determine whether a high priority request arrived while handling requests in the lower priority queue. In another aspect of the invention, a notification can be provided to the resource manager when a high priority request arrives, wherein the resource manager can continue handling the request or begin handling the high priority request. In still other aspects of the invention, the priority can be additionally or alternatively indicative of one or more of the user, a time of day, a day of the week, a duty cycle, a machine, a bandwidth, a capacity, a current load, processing resources, etc.","Upon locating a request to handle, the contents of the request can be observed to determine what processing resources are requested, obtain a reply channel, etc. At reference numeral , a communication can be transmitted to the reply channel, wherein the communication can include a pointer to allocated processing resources. As noted previously, the reply can be associated with a clocking mechanism (e.g., a signal generator, an event, etc.), wherein the clock can determine when the reply can be transmitted, or transmitted when the processing resources become available. At , the processing resources can be utilized to execute a task associated with the request.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 10","b":["1010","1020","1020","1030","1040","1050"]},"The following sections provide various examples of calculus and\/or other representations that can be employed to facilitate modeling the novel aspects of the subject invention and\/or an operating system based on the novel aspects of the present invention. One of ordinary skill in the art would recognize that the following examples do not limit the invention and that alternative and\/or additional calculus can be employed in accordance with an aspect of the present invention. Examples of suitable calculus include pi (including asynchronous and join calculi and derivations thereof.","Such calculus can be utilized to define a set of named procedures, wherein respective procedures can accept a formal argument and include one or more send statements. For example, u, x can be defined to range over variable names and X, Y can be defined to range over procedure names. A send statement u<x> can be defined to send data x over port u, wherein a sequence of statements can be defined as S=\u016b<x>, . . . ; \u016b<x> and a procedure definition can be defined as DEF=X(y)=S. The notation C can be utilized to represent instructions for a set of named procedure definitions, for example, where no procedure name is defined more than once. When one or more instructions are executed (e.g., at runtime), there can be one or more threads of execution and some program state, which can include a set of work units, each of which is a SEQ; and a set of named ports, each of which includes either a set of variable names {tilde over (x)} or a set of procedure names {tilde over (X)}.","An exemplary port (t) can be configured to collect clock ticks. Data into such port can be in the form of D::={tilde over (x)}|{tilde over (X)} and a collection of such ports can be defined as P::=uD, . . . uD, and P\u2190u.D\u2032 can be utilized to replace u.D with u.D\u2032 (e.g., if u already existed) or for adding u.D to P (e.g., if it didn't). The threads of execution can take work units either from the collection of work units or from the network. For example, they can go through the sequence of sends inside the work unit and, accordingly, alter the set of P or create new work units as detailed below.","In another example, respective work units can be considered as autonomous agents that perform sends. A central party can receive these send commands and act accordingly. This state, which can be similar to P above, is a state of the central manager. The central manage can be represented as  for a current state P. The overall state of the system can then be written as STATE::={tilde over (S)}| for a set S of outstanding work units and a central manager. The central manager can behave like a state machine and, thus, it can be represented in a language L. The following is a sample of exemplary commands that can be utilized with such a language: u(z).L can receive a message from a work unit; u(z).L+u(z).Lcan be utilized as select command; vz can allocate a fresh port name z; and parallel S|L can spawn a new work unit. An if\/then command can be represented a left brace.  can be defined as the following:",{"@attributes":{"id":"p-0083","num":"0082"},"maths":[{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":{"mo":["\u2003","\u2003"]},"mo":"\u2062","mi":"P"},{"mrow":[{"munder":{"mo":"\u2211","mrow":{"mrow":{"mi":"u","mo":"\u00b7","mover":{"mi":"x","mo":"~"}},"mo":"\u2208","mi":"P"}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mrow":[{"mi":"u","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"z"}},{"mi":"t","mo":"\u2061","mrow":{"mo":["(",")"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}},{"mi":"P","mo":"\u2190","mrow":{"mrow":{"mi":["u","z"],"mo":"\u00b7"},"mo":"\u2062","mover":{"mi":"x","mo":"~"}}}],"mo":["\u00b7","\u00b7"]}},{"munder":{"mo":"\u2211","mrow":{"mrow":{"mrow":{"mi":["u","Z"],"mo":"\u00b7"},"mo":"\u2062","mover":{"mi":"X","mo":"~"}},"mo":"\u2208","mi":"P"}},"mo":"\u2062","mrow":{"mrow":[{"mi":"u","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"z"}},{"mi":"t","mo":"\u2061","mrow":{"mo":["(",")"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}},{"mo":["(",")"],"mrow":{"mrow":[{"mi":"S","mo":"\u2062","mrow":{"mo":["{","}"],"mrow":{"mi":["z","y"],"mo":"\/"}}},{"mi":"P","mo":"\u2190","mrow":{"mi":"u","mo":"\u2062","mover":{"mi":"X","mo":"~"}}}],"mo":"\u2758"}}],"mo":["\u00b7","\u00b7"]}}],"mo":"+"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00001-2","num":"00001.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["for","Z"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mrow":[{"mrow":{"mo":["(",")"],"mi":"y"},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mi":["S","in","C"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"mrow":[{"mi":"new","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"Z"}},{"mi":"t","mo":"\u2061","mrow":{"mo":["(",")"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}},{"mo":["(",")"],"mrow":{"mrow":[{"mi":"S","mo":"\u2062","mrow":{"mo":["{","}"],"mrow":{"mi":["z","y"],"mo":"\/"}}},{"mi":"P","mo":"\u2190","mrow":{"mi":["z","\u03d5"],"mo":"\u00b7"}}],"mo":"\u2758"}}],"mo":["\u00b7","\u00b7","\u00b7"],"mi":"vz"}],"mo":"+"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00001-3","num":"00001.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["for","Z"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mrow":[{"mrow":{"mo":["(",")"],"mi":"y"},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mi":["S","in","C"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"mrow":[{"mi":"rcv","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["u","Z"],"mo":","}}},{"mi":"t","mo":"\u2061","mrow":{"mo":["(",")"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}},{"mo":["[","]"],"mrow":{"mrow":[{"mrow":[{"mi":"S","mo":"\u2062","mrow":{"mo":["{","}"],"mrow":{"mi":["z","y"],"mo":"\/"}}},{"mrow":{"mrow":[{"mi":"P","mo":"\u2190","mrow":{"mi":"u","mo":"\u00b7","mover":{"mi":"x","mo":"~"}}},{"mi":["u","zx"],"mo":"\u00b7"}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"if"},"mo":"\u2208","mi":"P"}],"mo":"\u2758"},{"mrow":[{"mi":["for","Z"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mrow":{"mrow":[{"mo":["(",")"],"mi":"y"},{"mi":"P","mo":"\u2190","mrow":{"mi":"U","mo":"\u2062","mover":{"mi":"X","mo":"~"}}},{"mi":["u","X"],"mo":"\u00b7"}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mi":["S","in","C","or","if"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}},{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":"\u2208","mi":"P"}],"mo":"="}],"mo":[",","\u2062"],"mstyle":{"mtext":{}}}}],"mo":["\u00b7","\u00b7"]}],"mo":"+"}],"mo":"="}}}]},"The system can perform computational steps, wherein a computational step can transition the system from one state to another. Exemplary suitable computational steps include the following: send data: \u016b<x>.S,{tilde over (S)}|u(Z).L+L\u2032\u2192S,{tilde over (S)}|L{x\/z}; send procedure name: \u016b<X>.S,{tilde over (S)}|u(Z).L+L\u2032\u2192S,{tilde over (S)}|L{X\/Z}; and clock tick: {tilde over (S)}",{"@attributes":{"id":"p-0085","num":"0084"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"mrow":{"mi":"P","mo":",","mrow":{"mi":"t","mo":"\u00b7","mover":{"mi":"z","mo":"~"}}},"mo":["\u2062","\u2062"],"mover":[{"mo":"->","mrow":{"mi":"t","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"x"}}},{"mi":"S","mo":"~"}]},{"mi":"P","mo":",","mrow":{"mrow":{"mi":["t","x"],"mo":"\u00b7"},"mo":"\u2062","mover":{"mi":"z","mo":"~"}}}],"mo":"\u2758"},"mo":","}}},"br":{}},{"@attributes":{"id":"p-0086","num":"0085"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mover":{"mo":"->","mrow":{"mi":"t","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"x"}}}}},"br":{},"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00006","he":"3.13mm","wi":"5.25mm","file":"US07689998-20100330-P00003.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}},"The pi calculus (without recursion or summation for the time being) can be define to include the following: parallel branches: R::=P|R|0 and pi program P::=vx.R|\u016b<x>|u(y).R. This can be alternatively represented, where X(y)=Sin Sfor taking X(y)=Sto be defined in C, as [vy.R|R]=let X(y)=[] in <x>; [R]; [\u016b<X>|R]=\u016b<x>; [R]; and [u(y).R|R]=let X(y)=[R] in  <x>; [R].","The following pseudo instructions provide examples of various computer-implemented instructions that can be employed to facilitate implementing the novel aspects of the subject invention and\/or an operating system based on the novel aspects of the present invention. These instructions include instructions related to a resource manager, a port service, a scheduler, a sequencer, a signal generator, and an implementation of join\/choice. It is understood that one of ordinary skill in the art would recognize that essentially any programming language (e.g., C-based languages) can be utilized to provide such instructions and that additional and\/or alternative instructions can be employed in accordance with an aspect of the present invention. Thus, subsets of and modifications, alterations and\/or additions to the following instructions can be employed in accordance with an aspect of the present invention.","The following computer implemented instructions can be utilized to provide a resource manager.",{"@attributes":{"id":"p-0090","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"{"},{"entry":"\u2003internal class SchedulingAllocations"},{"entry":"\u2003{"},{"entry":"\u2003\u2003public readonly Hashtable htSchedulers = new Hashtable( );"},{"entry":"\u2003\u2003public int numExecutionUnits = 0;"},{"entry":"\u2003}"},{"entry":"\u2003internal class MessageAllocationContext"},{"entry":"\u2003{"},{"entry":"\u2003\u2003public MessageAllocationContext(Type msgType,int msgCount)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003AllocationType = msgType;"},{"entry":"\u2003\u2003\u2003AllocationCount = msgCount;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public readonly Type AllocationType;"},{"entry":"\u2003\u2003public readonly int AllocationCount;"},{"entry":"\u2003}"},{"entry":"\u2003internal class MessageAllocations"},{"entry":"\u2003{"},{"entry":"\u2003\u2003public readonly Hashtable htMessagePools = new Hashtable( );"},{"entry":"\u2003}"},{"entry":"\u2003internal class ResourceManager"},{"entry":"\u2003{"},{"entry":"\u2003\u2003PortCollection m_Main = new PortCollection("},{"entry":"\u2003\u2003\u2003typeof(SchedulingAllocations),"},{"entry":"\u2003\u2003\u2003typeof(MessageAllocations),"},{"entry":"\u2003\u2003\u2003typeof(AllocationResourceType),"},{"entry":"\u2003\u2003\u2003typeof(msgAllocateSchedulingResource),"},{"entry":"\u2003\u2003\u2003typeof(msgAllocateMessageResource),"},{"entry":"\u2003\u2003\u2003typeof(msgAllocateSignalSource),"},{"entry":"\u2003\u2003\u2003typeof(msgFreeResource));"},{"entry":"\u2003\u2003IPortCollection m_PrivateScheduler;"},{"entry":"\u2003\u2003IPortCollection m_SignalSource;"},{"entry":"\u2003\u2003public ResourceManager( )"},{"entry":"\u2003\u2003{ }"},{"entry":"\u2003\u2003internal PortCollection Init( )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Scheduler s = new Scheduler( );"},{"entry":"\u2003\u2003\u2003m_PrivateScheduler = s.Init(2,10,\u201cResourceManager\u201d);"},{"entry":"\u2003\u2003\u2003if (m_PrivateScheduler == null)"},{"entry":"\u2003\u2003\u2003\u2003return null;"},{"entry":"\u2003\u2003\u2003SchedulingAllocations allocTable = new SchedulingAllocations( );"},{"entry":"\u2003\u2003\u2003allocTable.htSchedulers.Add(m_PrivateScheduler,s);"},{"entry":"\u2003\u2003\u2003MessageAllocations messageAllocTable = new"},{"entry":"\u2003\u2003\u2003MessageAllocations( );"},{"entry":"\u2003\u2003\u2003m_Main.RegisterReceiver(typeof(msgAllocateSchedulingRe-"},{"entry":"\u2003\u2003\u2003source),"},{"entry":"\u2003\u2003\u2003\u2003new Schedule(AllocateScheduling),"},{"entry":"\u2003\u2003\u2003\u2003m_PrivateScheduler);"},{"entry":"\u2003\u2003\u2003m_Main.RegisterReceiver(typeof(msgAllocateMessageResource),"},{"entry":"\u2003\u2003\u2003\u2003new Schedule(AllocateMessage),"},{"entry":"\u2003\u2003\u2003\u2003m_PrivateScheduler);"},{"entry":"\u2003\u2003\u2003m_Main.RegisterReceiver(typeof(msgAllocateSignalSource),"},{"entry":"\u2003\u2003\u2003\u2003new Schedule(AllocateSignalSource),"},{"entry":"\u2003\u2003\u2003\u2003m_PrivateScheduler);"},{"entry":"\u2003\u2003\u2003m_Main.RegisterReceiver(typeof(msgFreeResource),"},{"entry":"\u2003\u2003\u2003\u2003new Schedule(Free),"},{"entry":"\u2003\u2003\u2003\u2003m_PrivateScheduler);"},{"entry":"\u2003\u2003\u2003m_Main.Post(allocTable);"},{"entry":"\u2003\u2003\u2003m_Main.Post(messageAllocTable);"},{"entry":"\u2003\u2003\u2003Sequencer seq = new Sequencer( );"},{"entry":"\u2003\u2003\u2003m_SignalSource = seq.Init(m_PrivateScheduler);"},{"entry":"\u2003\u2003\u2003return m_Main;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003void Free(object M)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003msgFreeResource msg = (msgFreeResource) M;"},{"entry":"\u2003\u2003\u2003Scheduler s = null;"},{"entry":"\u2003\u2003\u2003AllocationResourceType t ="},{"entry":"\u2003(AllocationResourceType)msg.Resource.Get(typeof(AllocationRe-"},{"entry":"\u2003sourceType));"},{"entry":"\u2003\u2003\u2003switch (t)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003case AllocationResourceType.SignalGenerator:"},{"entry":"\u2003\u2003\u2003\u2003\u2003msg.Resource.Post(t);"},{"entry":"\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003case AllocationResourceType.Message:"},{"entry":"\u2003\u2003\u2003\u2003\u2003MessageAllocations mAllocTable = (MessageAllocations)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003m_Main. Get(typeof(MessageAllocations));"},{"entry":"\u2003\u2003\u2003\u2003\u2003try"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003MessageAllocationContext context = (MessageAllocation"},{"entry":"\u2003\u2003\u2003\u2003\u2003Context)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003msg.Resource.Get(typeof(MessageAllocationContext));"},{"entry":"\u2003mAllocTable.htMessagePools.Remove(context.AllocationType.Assem-"},{"entry":"\u2003blyQualifiedName"},{"entry":"\u2003);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003IPort portPool = msg.Resource.GetPort(context.Alloca-"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003tionType);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003for (int i=0;i<context.AllocationCount;i++)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003msgResourceManagerBase o ="},{"entry":"\u2003(msgResourceManagerBase)portPool.Test( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003if(o ==null)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003throw new Exception(\u201cResourceManager:FreeRe-"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003source:Detected"},{"entry":"\u2003\u2003resource leak in message pool for type:\u201d+context.AllocationType);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003o.bAllocationPoolDisposed = true;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003finally"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003m_Main.Post(mAllocTable);"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003case AllocationResourceType.Scheduling:"},{"entry":"\u2003\u2003\u2003\u2003\u2003SchedulingAllocations allocTable = (SchedulingAllocations)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003m_Main.Get(typeof(SchedulingAllocations));"},{"entry":"\u2003\u2003\u2003\u2003\u2003try"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003string strInUse= null;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003s = (Scheduler)allocTable.htSchedulers[msg.Resource];"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (s!=null)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003strInUse = (string) s.portDispatcher.Test(typeof(string));"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (strInUse == null)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003allocTable.htSchedulers.Remove(msg.Resource);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003allocTable.numExecutionUnits -= s.ThreadCount;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Debug.WriteLineIf(TS.Core.TraceVerbose,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cResourceManager.Free: Total Execution"},{"entry":"\u2003\u2003Units:\u201c+allocTable.numExecutionUnits);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if(s!=null)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003s.Shutdown(new msgShutdown( ));"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003finally"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003m_Main.Post(allocTable);"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003void AllocateSignalSource(object M)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003msgAllocateSignalSource msg = (msgAllocateSignalSource)M;"},{"entry":"\u2003\u2003\u2003msg.ResultPort.Post(new msgAllocateResourceResult"},{"entry":"\u2003\u2003\u2003(m_SignalSource));"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003void AllocateScheduling(object M)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003msgAllocateSchedulingResource msg = (msgAllo-"},{"entry":"\u2003\u2003\u2003cateSchedulingResource) M;"},{"entry":"\u2003\u2003\u2003SchedulingAllocations allocTable = (SchedulingAllocations)"},{"entry":"\u2003\u2003\u2003\u2003m_Main.Get(typeof(SchedulingAllocations));"},{"entry":"\u2003\u2003\u2003try"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003Scheduler s = new Scheduler( );"},{"entry":"\u2003\u2003\u2003\u2003PortCollection d = s.Init(msg.numExecutionUnits,"},{"entry":"\u2003\u2003\u2003\u2003\u2003msg.numSchedulingItemsPerUnit,"},{"entry":"\u2003\u2003\u2003\u2003\u2003msg.strDispatcherTag);"},{"entry":"\u2003\u2003\u2003\u2003if(d == null)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003msg.ResultPort.Post(new msgFailureResult"},{"entry":"\u2003\u2003\u2003\u2003\u2003(\u201cFailed allocating scheduler\u201d));"},{"entry":"\u2003\u2003\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003d.Post(AllocationResourceType.Scheduling);"},{"entry":"\u2003\u2003\u2003\u2003allocTable.htSchedulers.Add(d,s);"},{"entry":"\u2003\u2003\u2003\u2003allocTable.numExecutionUnits += s.ThreadCount;"},{"entry":"\u2003\u2003\u2003\u2003Debug.WriteLineIf(TS.Core.TraceVerbose,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201cResourceManager.Allocate: Total Execution"},{"entry":"\u2003Units:\u201c+allocTable.numExecutionUnits);"},{"entry":"\u2003\u2003\u2003\u2003msg.ResultPort.Post(new msgAllocateResourceResult(d));"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003catch"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003msg.ResultPort.Post(new msgFailureResult(\u201cFailed"},{"entry":"\u2003\u2003\u2003\u2003allocating scheduler\u201d));"},{"entry":"\u2003\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003finally"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003m_Main.Post(allocTable);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003void AllocateMessage(object M)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003msgAllocateMessageResource msg = (msgAllocateMessageRe-"},{"entry":"\u2003\u2003\u2003source) M;"},{"entry":"\u2003\u2003\u2003PortCollection pool = new PortCollection(msg.MessageType,"},{"entry":"\u2003\u2003\u2003\u2003typeof(AllocationResourceType),"},{"entry":"\u2003\u2003\u2003\u2003typeof(MessageAllocationContext));"},{"entry":"\u2003\u2003\u2003pool.Post(AllocationResourceType.Message);"},{"entry":"\u2003\u2003\u2003for(int i = 0;i<msg.numUnits;i++)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003try"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (msg.MessageAllocator==null)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003object [ ] args = {pool};"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003object o = Activator.CreateInstance(msg.MessageType,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003args);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003pool.Post(o);"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003msg.MessageAllocator(pool);"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003catch"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003msg.ResultPort.Post("},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003new msgFailureResult(\u201cResourceManager.Allo-"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003cateMessage: Failed"},{"entry":"\u2003allocating resource for type:\u201c+msg.MessageType));"},{"entry":"\u2003\u2003\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003MessageAllocations allocTable = (MessageAllocations)"},{"entry":"\u2003\u2003\u2003\u2003m_Main.Get(typeof(MessageAllocations));"},{"entry":"\u2003\u2003\u2003MessageAllocationContext context = new"},{"entry":"\u2003MessageAllocationContext(msg.MessageType,msg.numUnits);"},{"entry":"\u2003\u2003\u2003pool.Post(context);"},{"entry":"\u2003\u2003\u2003pool.Post(AllocationResourceType.Message);"},{"entry":"\u2003allocTable.htMessagePools.Add(msg.MessageType.AssemblyQuali-"},{"entry":"\u2003fiedName,pool);"},{"entry":"\u2003\u2003\u2003m_Main.Post(allocTable);"},{"entry":"\u2003\u2003\u2003\u2003msg.ResultPort.Post(new msgAllocateResourceResult(pool));"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The following computer implemented instructions can be utilized to provide a port service.",{"@attributes":{"id":"p-0092","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"{"},{"entry":"\u2003public delegate void Schedule("},{"entry":"\u2003object state"},{"entry":"\u2003);"},{"entry":"\u2003public class MessageContext : ListEntry"},{"entry":"\u2003{"},{"entry":"\u2003\u2003public object Key;"},{"entry":"\u2003\u2003public object Value;"},{"entry":"\u2003}"},{"entry":"\u2003public class ReceiverContext"},{"entry":"\u2003{"},{"entry":"\u2003\u2003internal Schedule Receiver;"},{"entry":"\u2003\u2003internal readonly IPortCollection Dispatcher;"},{"entry":"\u2003\u2003public ReceiverContext(Schedule NamedReceiver,"},{"entry":"\u2003\u2003\u2003IPortCollection ScheduleDispatcher)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Dispatcher = ScheduleDispatcher;"},{"entry":"\u2003\u2003\u2003Receiver = NamedReceiver;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003public abstract class IPort"},{"entry":"\u2003{"},{"entry":"\u2003\u2003public abstract Guid Identity"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003get;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public abstract void RemoveAll(ArrayList store);"},{"entry":"\u2003\u2003public abstract object Test( );"},{"entry":"\u2003\u2003public abstract object Get( );"},{"entry":"\u2003\u2003public abstract void Post(Object Value);"},{"entry":"\u2003\u2003public abstract void RegisterReceiver(ReceiverContext Context);"},{"entry":"\u2003\u2003public abstract void UnregisterReceiver(Schedule S);"},{"entry":"\u2003\u2003public abstract bool IsReceiverActive( );"},{"entry":"\u2003\u2003internal abstract void Post(MessageContext ctx);"},{"entry":"\u2003\u2003internal abstract object TestInternal(ref WaitHandle doorbell);"},{"entry":"\u2003\u2003internal abstract object TestInternal( );"},{"entry":"\u2003\u2003internal abstract void TestInternal(ref MessageContext ctx);"},{"entry":"\u2003}"},{"entry":"\u2003public abstract class IPortCollection"},{"entry":"\u2003{"},{"entry":"\u2003\u2003public abstract Guid Identity"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003get;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public abstract string LocalName"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003get;"},{"entry":"\u2003\u2003\u2003set;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public abstract void AddPort(params object [ ] key);"},{"entry":"\u2003\u2003public abstract IPort GetPort(object key);"},{"entry":"\u2003\u2003public abstract object Get(object key);"},{"entry":"\u2003\u2003public abstract object Test(object key);"},{"entry":"\u2003\u2003public abstract void Post(object Value);"},{"entry":"\u2003\u2003public abstract void Post(object Key, object Value);"},{"entry":"\u2003\u2003public abstract void RegisterReceiver(object key, ReceiverContext"},{"entry":"\u2003\u2003Context);"},{"entry":"\u2003\u2003public abstract void RegisterReceiver(object key, Schedule Receiver,"},{"entry":"IPortCollection PrivDispatcher);"},{"entry":"\u2003\u2003public abstract void UnregisterReceiver(object key);"},{"entry":"\u2003\u2003public abstract void UnregisterReceiver(object key,Schedule"},{"entry":"\u2003\u2003Receiver);"},{"entry":"\u2003\u2003internal abstract void TestInternal(object key,ref MessageContext"},{"entry":"\u2003\u2003ctx);"},{"entry":"\u2003\u2003internal abstract void Post(MessageContext msgCtx);"},{"entry":"\u2003\u2003public abstract WaitContext this [object key] {get;}"},{"entry":"\u2003\u2003public abstract WaitContext this [object key, Schedule S] {get;}"},{"entry":"\u2003}"},{"entry":"\u2003public enum PortOrderingTypes"},{"entry":"\u2003{"},{"entry":"\u2003\u2003ePortOrderRandom,"},{"entry":"\u2003\u2003ePortOrderFIFO,"},{"entry":"\u2003\u2003ePortOrderLIFO"},{"entry":"\u2003}"},{"entry":"\u2003public class Port : IPort"},{"entry":"\u2003{"},{"entry":"\u2003\u2003public Port(PortOrderingTypes Order)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003OrderType = Order;"},{"entry":"\u2003\u2003\u2003Id = Guid.NewGuid( );"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public Port( )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003PortOrderingTypes OrderType = PortOrderingTypes."},{"entry":"\u2003\u2003ePortOrderRandom;"},{"entry":"\u2003\u2003Guid Id = Guid.NewGuid( );"},{"entry":"\u2003\u2003ManualResetEvent Doorbell = new ManualResetEvent(false);"},{"entry":"\u2003\u2003ArrayList Elements = new ArrayList( );"},{"entry":"\u2003\u2003ArrayList Receivers = new ArrayList( );"},{"entry":"\u2003\u2003public override Guid Identity"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003get"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003return Id;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public override bool IsReceiverActive( )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003lock (this)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003if (Receivers.Count > 0)"},{"entry":"\u2003\u2003\u2003\u2003\u2003return true;"},{"entry":"\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003\u2003return false;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public override object Test( )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003object result = TestInternal( );"},{"entry":"#if DEBUG \u2225 BIGWINRUNTIMEDEBUG"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (result != null)"},{"entry":"\u2003\u2003\u2003MessageBreakpointManager.TestAndExecuteBreakpoint(result);"},{"entry":"#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003return result;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003internal override object TestInternal( )"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003MessageContext ctx = null;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003TestInternal(ref ctx);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (ctx!=null)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003return ctx.Value;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003return null;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003internal override object TestInternal(ref WaitHandle wh)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003wh = Doorbell;"},{"entry":"\u2003\u2003\u2003return TestInternal( );"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal override void TestInternal(ref MessageContext ctx)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003ctx = null;"},{"entry":"\u2003\u2003\u2003lock (this)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003if (Elements.Count>0)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003object res = Elements[Elements.Count\u22121];"},{"entry":"\u2003\u2003\u2003\u2003\u2003Elements.RemoveAt(Elements.Count\u22121);"},{"entry":"\u2003\u2003\u2003\u2003\u2003if(Elements.Count == 0)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Doorbell.Reset( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003ctx = (MessageContext)res;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public override void RemoveAll(ArrayList List)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003lock(this)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003List.InsertRange(0,Elements);"},{"entry":"\u2003\u2003\u2003\u2003Elements.RemoveRange(0,Elements.Count);"},{"entry":"\u2003\u2003\u2003\u2003Doorbell.Reset( );"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public override object Get( )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003object result = null;"},{"entry":"\u2003\u2003\u2003WaitHandle Doorbell = null;"},{"entry":"\u2003\u2003\u2003while (true)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003result = TestInternal(ref Doorbell);"},{"entry":"\u2003\u2003\u2003\u2003if (result==null)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (!Doorbell.WaitOne( ))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003return result;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public override void Post(object Value)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003MessageContext ctx = new MessageContext( );"},{"entry":"\u2003\u2003\u2003ctx.Value = Value;"},{"entry":"\u2003\u2003\u2003ctx.Key = Value.GetType( );"},{"entry":"\u2003\u2003\u2003Post(ctx);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal override void Post(MessageContext ctx)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Debug.Assert(ctx.Key!=null,\u201cKey cant be null\u201d);"},{"entry":"\u2003\u2003\u2003lock (this)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003if (Dispatch(ctx))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003\u2003\u2003Buffer(ctx);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal void Buffer(MessageContext Item)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003try"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003if (Elements.Contains(Item))"},{"entry":"\u2003\u2003\u2003\u2003\u2003throw new Exception(\u201cduplicate msg context detected\u201d);"},{"entry":"\u2003\u2003\u2003\u2003switch(OrderType)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003case PortOrderingTypes.ePortOrderRandom:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Elements.Add(Item);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if(Elements.Count > 1)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003int index = Primitives.Random.Next(Elements.Count\u22121);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003object s = Elements[Elements.Count\u22121];"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003Elements[Elements.Count\u22121] = Elements[index];"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003Elements[index] = s;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003case PortOrderingTypes.ePortOrderLIFO:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Elements.Add(Item);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003case PortOrderingTypes.ePortOrderFIFO:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Elements.Insert(0,Item);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003Doorbell.Set( );"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003catch (System.ObjectDisposedException)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003Debug.WriteLineIf(TS.Core.TraceWarning,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201cportServices.cs: An attempt was made to post to a disposed"},{"entry":"\u2003\u2003\u2003\u2003\u2003port\u201d);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal bool Dispatch(MessageContext Item)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003int count = Receivers.Count;"},{"entry":"\u2003\u2003\u2003for(int i =0;i<count;i++)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003ReceiverContext context = (ReceiverContext)Receivers[i];"},{"entry":"\u2003\u2003\u2003\u2003if (InvokeReceiverSingle(context,Item))"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003return true;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003if (Receivers.Count != count)"},{"entry":"\u2003\u2003\u2003\u2003\u2003i--;"},{"entry":"\u2003\u2003\u2003\u2003count = Receivers.Count;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003return false;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public override void RegisterReceiver(ReceiverContext Context)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003lock (this)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003AddReceiver(Context);"},{"entry":"\u2003\u2003\u2003\u2003SynchronizeReceiver(Context);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public override void UnregisterReceiver(Schedule Receiver)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003if (Receiver == null)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003lock (this)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (Receivers.Count == 1 )"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Receiver = ((ReceiverContext)Receivers[0]).Receiver;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003throw new Exception(\u201cAttempt to UnRegisterReceiver from"},{"entry":"port with none or with more than one\u201d);"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003RemoveReceiver(Receiver);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003void AddReceiver(ReceiverContext ctx)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003for(int i=0;i<Receivers.Count;i++)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003ReceiverContext c = (ReceiverContext) Receivers[i];"},{"entry":"\u2003\u2003\u2003\u2003if (c.Receiver == ctx.Receiver)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003Receivers.Add(ctx);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003ReceiverContext RemoveReceiver(Schedule S)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003lock (this)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003for(int i=0;i<Receivers.Count;i++)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003ReceiverContext ctx = (ReceiverContext) Receivers[i];"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (ctx.Receiver == S)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Receivers.RemoveAt(i);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return ctx;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003return null;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003void SynchronizeReceiver(ReceiverContext Context)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003for(int i=Elements.Count\u22121;i>=0;i--)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003MessageContext msgCtx = (MessageContext)Elements[i];"},{"entry":"\u2003\u2003\u2003\u2003bool bConsumed = InvokeReceiverSingle(Context,msgCtx);"},{"entry":"\u2003\u2003\u2003\u2003if (bConsumed)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003Elements.RemoveAt(i);"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (Context.Dispatcher == null)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003bool InvokeReceiverSingle(ReceiverContext ActiveReceiver,"},{"entry":"MessageContext Item)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003if (ActiveReceiver.Dispatcher == null)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003ActiveReceiver.Receiver(Item);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return Item.Key == null;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003ActiveReceiver.Dispatcher.Post(new"},{"entry":"\u2003\u2003msgScheduleContext(ActiveReceiver.Receiver,Item.Value));"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return true;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003public class PortCollection : IPortCollection"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003internal Hashtable htNodes = new Hashtable( );"},{"entry":"\u2003\u2003\u2003\u2003internal string m_LocalName;"},{"entry":"\u2003\u2003\u2003\u2003internal PortOrderingTypes OrderType = PortOrderingTypes."},{"entry":"\u2003\u2003\u2003\u2003ePortOrderRandom;"},{"entry":"\u2003\u2003\u2003\u2003Guid Id;"},{"entry":"\u2003\u2003\u2003\u2003public override string LocalName"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003get"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return m_LocalName;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003set"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003lock(this)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003m_LocalName = value;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003public override Guid Identity"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003get"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return Id;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003void Init( )"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Id = Guid.NewGuid( );"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public PortCollection(PortOrderingTypes Order)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003OrderType = Order;"},{"entry":"\u2003\u2003\u2003Init( );"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public PortCollection( )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Init( );"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public PortCollection(PortOrderingTypes Order,params object [ ]"},{"entry":"\u2003\u2003keys)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003OrderType = Order;"},{"entry":"\u2003\u2003\u2003Init( );"},{"entry":"\u2003\u2003\u2003AddPort(keys);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public PortCollection(params object [ ] keys)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Init( );"},{"entry":"\u2003\u2003\u2003AddPort(keys);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public override void AddPort(params object [ ] Keys)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003foreach(object o in Keys)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003AddPortInternal(o);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal void AddPortInternal(object key)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003lock(htNodes)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003if (htNodes. Contains(key))"},{"entry":"\u2003\u2003\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003\u2003\u2003Port child = new Port(OrderType);"},{"entry":"\u2003\u2003\u2003\u2003htNodes.Add(key,child);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public ICollection GetPorts( )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003lock (htNodes)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003Port [ ] ar = new Port[htNodes.Count];"},{"entry":"\u2003\u2003\u2003\u2003htNodes.Values.CopyTo(ar,0);"},{"entry":"\u2003\u2003\u2003\u2003return ar;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public override IPort GetPort(object key)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003lock (htNodes)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003return (IPort)htNodes[key];"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003IPort GetPortInternal(object key)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003lock (htNodes)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003object o = htNodes[key];"},{"entry":"\u2003\u2003\u2003\u2003if(o == null)"},{"entry":"\u2003\u2003\u2003\u2003\u2003throw new PortNotFoundException(\u201cPort for key not"},{"entry":"\u2003\u2003\u2003\u2003\u2003found:\u201d+key);"},{"entry":"\u2003\u2003\u2003\u2003return (IPort)o;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public override object Get(object key)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003IPort port = GetPortInternal(key);"},{"entry":"\u2003\u2003\u2003return port.Get( );"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public override object Test(object K)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003MessageContext msg = null;"},{"entry":"\u2003\u2003\u2003TestInternal(K,ref msg);"},{"entry":"\u2003\u2003\u2003if (msg!=null)"},{"entry":"\u2003\u2003\u2003\u2003return msg.Value;"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003return null;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal override void TestInternal(object key, ref MessageContext"},{"entry":"\u2003\u2003msg)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003GetPortInternal(key).TestInternal(ref msg);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public override void Post(object Value)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Post(Value.GetType( ), Value);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public override void Post(object Key, object Value)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003MessageContext ctx = new MessageContext( );"},{"entry":"\u2003\u2003\u2003ctx.Value = Value;"},{"entry":"\u2003\u2003\u2003ctx.Key = Key;"},{"entry":"\u2003\u2003\u2003Post(ctx);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal override void Post(MessageContext msg)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003GetPortInternal(msg.Key).Post(msg);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public override void RegisterReceiver(object key, Schedule Receiver,"},{"entry":"IPortCollection PrivDispatcher)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003RegisterReceiver(key,new ReceiverContext(Receiver,"},{"entry":"\u2003\u2003\u2003PrivDispatcher));"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public override void RegisterReceiver(object key, ReceiverContext"},{"entry":"\u2003\u2003Context)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003GetPortInternal(key).RegisterReceiver(Context);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public override void UnregisterReceiver(object key)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003UnregisterReceiver(key,null);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public override void UnregisterReceiver(object key,Schedule"},{"entry":"\u2003\u2003Receiver)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003GetPortInternal(key).UnregisterReceiver(Receiver);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public override WaitContext this [object key]"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003get"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003return new WaitContext(this,key);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public override WaitContext this [object key, Schedule S]"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003get"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003return new WaitContext(this,key,S);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003public class PortNotFoundException : System.Exception"},{"entry":"\u2003{"},{"entry":"\u2003\u2003public PortNotFoundException(string msg) : base(msg)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The following computer implemented instructions can be utilized to provide a scheduler.",{"@attributes":{"id":"p-0094","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"{"},{"entry":"\u2003class SchedulerThreadContext"},{"entry":"\u2003{"},{"entry":"\u2003\u2003public TimeSpan IdleExpiration;"},{"entry":"\u2003\u2003public Thread ThreadObject = null;"},{"entry":"\u2003\u2003public IPortCollection ListenPort = null;"},{"entry":"\u2003\u2003public void ScheduleExecution( )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003WaitHandle wh = null;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003msgScheduleContext msgCtx;"},{"entry":"\u2003\u2003\u2003IPort ExecutionQueue = ListenPort.GetPort(typeof"},{"entry":"\u2003\u2003\u2003(msgScheduleContext));"},{"entry":"\u2003\u2003\u2003while (true)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003msgCtx ="},{"entry":"(msgScheduleContext)ExecutionQueue.TestInternal(ref wh);"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (msgCtx == null)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (wh.WaitOne(IdleExpiration,true))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003continue;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003try"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"#if DEBUG"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Interlocked.Increment(ref RuntimeStatistics."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003ScheduledItems);"},{"entry":"#endif"},{"entry":"#if DEBUG \u2225 BIGWINRUNTIMEDEBUG"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if(msgCtx.State != null)"},{"entry":"\u2003\u2003\u2003MessageBreakpointManager.TestAndExecuteBreakpoint(msgCtx."},{"entry":"\u2003\u2003\u2003State);"},{"entry":"#endif"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003msgCtx.S(msgCtx.State);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003catch (Exception e)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Debug.WriteLineif(TS.Core.TraceError,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cException not handled by schedule:\u201d+e);"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003finally"},{"entry":"\u2003\u2003\u2003\u2003{ }"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003public class Scheduler"},{"entry":"\u2003{"},{"entry":"\u2003\u2003public string Tag;"},{"entry":"\u2003\u2003TimeSpan DefaultExpiration = new TimeSpan(1,0,0,0,0);"},{"entry":"\u2003\u2003PortCollection m_MainPort = new PortCollection("},{"entry":"\u2003\u2003\u2003PortOrderingTypes.ePortOrderFIFO,"},{"entry":"\u2003\u2003\u2003typeof(msgShutdown),"},{"entry":"\u2003\u2003\u2003typeof(msgGenerateSignal),"},{"entry":"\u2003\u2003\u2003typeof(AllocationResourceType),"},{"entry":"\u2003\u2003\u2003typeof(string),"},{"entry":"\u2003\u2003\u2003typeof(IPort),"},{"entry":"\u2003\u2003\u2003typeof(msgScheduleContext));"},{"entry":"\u2003\u2003ArrayList m_ThreadList = null;"},{"entry":"\u2003public IPortCollection portDispatcher"},{"entry":"\u2003{"},{"entry":"\u2003\u2003get"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003return m_MainPort;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003public int ThreadCount"},{"entry":"\u2003{"},{"entry":"\u2003\u2003get"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003return m_ThreadList.Count;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003public PortCollection Init(int numThreads, int SchedulingItemsPerUnit,"},{"entry":"\u2003string tag)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003return Init(numThreads,SchedulingItemsPerUnit,DefaultExpiration,"},{"entry":"\u2003\u2003tag);"},{"entry":"\u2003}"},{"entry":"\u2003public PortCollection Init(int numThreads, int SchedulingItemsPerUnit,"},{"entry":"TimeSpan Expiration,string tag)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003int i = 0;"},{"entry":"\u2003\u2003m_MainPort.LocalName = \u201cScheduler\/MainDispatch\/\u201d;"},{"entry":"\u2003\u2003m_ThreadList = new ArrayList(numThreads);"},{"entry":"\u2003\u2003Tag = tag;"},{"entry":"\u2003\u2003for (i=0;i<numThreads;i++)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003AddThread(Expiration);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003return m_MainPort;"},{"entry":"\u2003}"},{"entry":"\u2003void AddThread(TimeSpan Expiration)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003SchedulerThreadContext ctx = new SchedulerThreadContext( );"},{"entry":"\u2003\u2003ctx.ListenPort = m_MainPort;"},{"entry":"\u2003\u2003ctx.IdleExpiration = Expiration;"},{"entry":"\u2003\u2003m_ThreadList.Add(ctx);"},{"entry":"\u2003\u2003\u2003Thread t = new Thread("},{"entry":"\u2003\u2003\u2003\u2003new ThreadStart(ctx.ScheduleExecution));"},{"entry":"\u2003\u2003\u2003t.Name = Tag;"},{"entry":"\u2003\u2003\u2003ctx.ThreadObject = t;"},{"entry":"\u2003\u2003\u2003t.Start( );"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public void Shutdown(msgShutdown msg)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003foreach (SchedulerThreadContext ctx in m_ThreadList)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003ctx.ThreadObject.Abort( );"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003msgShutdownResult res = new msgShutdownResult( );"},{"entry":"\u2003\u2003\u2003msg.ResultPort.Post(res);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The following computer implemented instructions can be utilized to provide a sequencer.",{"@attributes":{"id":"p-0096","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"{"},{"entry":"\u2003\u2003public class Sequencer"},{"entry":"\u2003\u2003{"},{"entry":"\u2003DateTime_nextExpiration = DateTime.Now.Add(TimeSpan."},{"entry":"\u2003FromDays(1));"},{"entry":"\u2003Timer _Timer;"},{"entry":"\u2003IPortCollection _portDispatcher;"},{"entry":"\u2003IPortCollection _RequestQueue = new"},{"entry":"PortCollection(PortOrderingTypes.ePortOrderFIFO,"},{"entry":"\u2003\u2003typeof(Timer),"},{"entry":"\u2003\u2003typeof(msgGenerateSignal));"},{"entry":"\u2003IPort _PendingQueue = new Port(PortOrderingTypes.ePortOrderFIFO);"},{"entry":"\u2003\u2003\u2003\u2003public Sequencer( )"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003public IPortCollection Init(IPortCollection Dispatcher)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003_portDispatcher = Dispatcher;"},{"entry":"\u2003\u2003_RequestQueue.RegisterReceiver(typeof(msgGenerateSignal),"},{"entry":"\u2003\u2003\u2003new Schedule(ProcessRequest),"},{"entry":"\u2003\u2003\u2003_portDispatcher);"},{"entry":"\u2003\u2003_Timer = new Timer(new TimerCallback(SignalHandler),"},{"entry":"\u2003\u2003\u2003null,"},{"entry":"\u2003\u2003\u2003TimeSpan.FromDays(1),"},{"entry":"\u2003\u2003\u2003TimeSpan.FromDays(1));"},{"entry":"\u2003\u2003return _RequestQueue;"},{"entry":"\u2003}"},{"entry":"\u2003void ProcessRequest(object m)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003msgGenerateSignal signal = (msgGenerateSignal)m;"},{"entry":"\u2003\u2003TimeSpan interval = (TimeSpan) signal.portClient.Test(typeof"},{"entry":"\u2003\u2003(TimeSpan));"},{"entry":"\u2003\u2003DateTime tNow = DateTime.Now;"},{"entry":"\u2003\u2003tNow.Add(interval);"},{"entry":"\u2003\u2003int repeat = (int) signal.portClient.Get(typeof(int));"},{"entry":"\u2003\u2003if (_nextExpiration > tNow)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003_Timer.Change(interval,"},{"entry":"\u2003\u2003\u2003\u2003(repeat == 0) ? new TimeSpan(\u22121) : interval);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003signal.portClient.Post(interval);"},{"entry":"\u2003\u2003signal.portClient.Post(tNow);"},{"entry":"\u2003\u2003signal.portClient.Post(repeat);"},{"entry":"\u2003\u2003_PendingQueue.Post(signal);"},{"entry":"\u2003}"},{"entry":"\u2003void SignalHandler(object m)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003TimeSpan interval = TimeSpan.FromDays(1);"},{"entry":"\u2003\u2003DateTime now = DateTime.Now;"},{"entry":"\u2003\u2003_nextExpiration = now.Add(interval);"},{"entry":"\u2003\u2003ArrayList signals = new ArrayList( );"},{"entry":"\u2003\u2003object o = null;"},{"entry":"\u2003\u2003while ((o = _PendingQueue.Test( ))!=null)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003signals.Add(o);"},{"entry":"\u2003\u2003};"},{"entry":"\u2003\u2003foreach(msgGenerateSignal signalReq in signals)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003interval = (TimeSpan) signalReq.portClient.Get(typeof"},{"entry":"\u2003\u2003\u2003(TimeSpan));"},{"entry":"\u2003\u2003\u2003DateTime exp = (DateTime) signalReq.portClient.Test(typeof"},{"entry":"\u2003\u2003\u2003(DateTime));"},{"entry":"\u2003\u2003\u2003if (exp <= now)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003msgPeriodicSignal msg = new msgPeriodicSignal(now);"},{"entry":"\u2003\u2003\u2003\u2003signalReq.portClient.Post(msg);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003int repeat = (int) signalReq.portClient.Test(typeof(int));"},{"entry":"\u2003\u2003\u2003int rClone = repeat--;"},{"entry":"\u2003\u2003\u2003signalReq.portClient.Post(exp);"},{"entry":"\u2003\u2003\u2003signalReq.portClient.Post(repeat);"},{"entry":"\u2003\u2003\u2003signalReq.portClient.Post(interval);"},{"entry":"\u2003\u2003\u2003if (rClone>0)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003exp = now.Add(interval);"},{"entry":"\u2003\u2003\u2003\u2003_PendingQueue.Post(signalReq);"},{"entry":"\u2003\u2003\u2003\u2003if (exp < _nextExpiration)"},{"entry":"\u2003\u2003\u2003\u2003\u2003_nextExpiration = exp;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003interval = _nextExpiration - now;"},{"entry":"\u2003\u2003_Timer.Change(interval,new TimeSpan(\u22121));"},{"entry":"\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The following computer implemented instructions can be utilized to compose a signal generator and\/or issue an asynchronous request to receive.",{"@attributes":{"id":"p-0098","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"void Lookup( )"},{"entry":"{"},{"entry":"\u2003\u2003msgWsapLookup lookup = new msgWsapLookup(_btTarget.Value,"},{"entry":"\u2003\u2003new LookupRequestType( ), portResponse);"},{"entry":"\u2003\u2003Common.WsapForwarder.Post(lookup);"},{"entry":"\u2003\u2003msgGenerateSignal msg = new msgGenerateSignal(new"},{"entry":"\u2003\u2003TimeSpan(20000000),1,_portResponse);"},{"entry":"\u2003\u2003_Common.Sequencer.Post(msg);"},{"entry":"\u2003\u2003Primitives.AsyncChoice(_portResponse[typeof"},{"entry":"\u2003\u2003(LookupResponseType),new Schedule(LookupRspHandler)]"},{"entry":"\u2003\u2003+"},{"entry":"\u2003\u2003portResponse[typeof(W3C.Soap.Fault), new Schedule(FaultHandler)]"},{"entry":"\u2003\u2003+"},{"entry":"\u2003\u2003portResponse[typeof(msgPeriodicSignal),new Schedule"},{"entry":"\u2003\u2003(TimeoutHandler)], Common.Dispatcher);"},{"entry":"}"},{"entry":"void TimeoutHandler(object m)"},{"entry":"{"},{"entry":"\u2003\u2003Debug.WriteLineIf(TS.Services.TraceError,\u201cServiceMonitorHelper:"},{"entry":"Got timeout\u201d);"},{"entry":"}"},{"entry":"void FaultHandler(object m)"},{"entry":"{"},{"entry":"\u2003\u2003Debug.WriteLineIf(TS.Services.TraceError,\u201cServiceMonitorHelper:"},{"entry":"\u2003\u2003Got fault\u201d);"},{"entry":"}"},{"entry":"void LookupRspHandler(object m)"},{"entry":"{"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The following computer implemented instructions can be utilized to implement join\/choice in accordance with aspects of the present invention. These instructions allow dynamic accumulation of join statements (e.g., not fixed at compile time) and issuance of the accumulated set in a context of an asynchronous choice. This allows a resource manager (as described herein), client applications, etc. to leverage the join implementation and, optionally, commit all at once, which can mitigate deadlock. It is to be appreciated that dynamically accumulated join and\/or choice branches can be issued by sending WaitContexts to another service or issuing an AsyncChoice, for example.",{"@attributes":{"id":"p-0100","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"{"},{"entry":"\u2003public class ListEntry"},{"entry":"{"},{"entry":"\u2003\u2003internal ListEntry fLink;"},{"entry":"\u2003\u2003internal ListEntry bLink;"},{"entry":"}"},{"entry":"public class List :IList"},{"entry":"{"},{"entry":"\u2003int iCount = 0;"},{"entry":"\u2003ListEntry Token = new ListEntry( );"},{"entry":"\u2003public List( )"},{"entry":"\u2003{"},{"entry":"\u2003\u2003Token.fLink = Token;"},{"entry":"\u2003\u2003Token.bLink = Token;"},{"entry":"\u2003}"},{"entry":"\u2003#region IList Special Members"},{"entry":"\u2003public static implicit operator ListEntry(List L)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003return L.Token;"},{"entry":"\u2003}"},{"entry":"\u2003public ListEntry Head"},{"entry":"\u2003{"},{"entry":"\u2003\u2003get"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003return Token.fLink;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003public ListEntry Tail"},{"entry":"\u2003{"},{"entry":"\u2003\u2003get"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003return Token.bLink;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003#endregion"},{"entry":"\u2003#region List PrivateMembers"},{"entry":"\u2003ListEntry Find(ListEntry v)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003ListEntry p = (ListEntry)Token.fLink;"},{"entry":"\u2003\u2003while (p!=Token)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003if(p == v)"},{"entry":"\u2003\u2003\u2003\u2003return p;"},{"entry":"\u2003\u2003\u2003p = p.fLink;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003return null;"},{"entry":"\u2003}"},{"entry":"\u2003#endregion"},{"entry":"\u2003#region IList Members"},{"entry":"\u2003public bool IsReadOnly"},{"entry":"\u2003{"},{"entry":"\u2003\u2003get"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003return false;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003public object this[int index]"},{"entry":"\u2003{"},{"entry":"\u2003\u2003get"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003return null;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003set"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003public void RemoveAt(int index)"},{"entry":"\u2003{"},{"entry":"\u2003}"},{"entry":"\u2003public void Insert(int index, object value)"},{"entry":"\u2003{"},{"entry":"\u2003}"},{"entry":"\u2003public void Remove(object value)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003ListEntry v = (ListEntry)value;"},{"entry":"\u2003\u2003ListEntry b = v.bLink;"},{"entry":"\u2003\u2003ListEntry f = v.fLink;"},{"entry":"\u2003\u2003b.fLink = f;"},{"entry":"\u2003\u2003f.bLink = b;"},{"entry":"\u2003\u2003v.bLink = null;"},{"entry":"\u2003\u2003v.fLink = null;"},{"entry":"\u2003}"},{"entry":"\u2003public bool Contains(object value)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003if (Find((ListEntry)value) != null)"},{"entry":"\u2003\u2003\u2003return true;"},{"entry":"\u2003\u2003else"},{"entry":"\u2003\u2003\u2003return false;"},{"entry":"\u2003}"},{"entry":"\u2003public void Clear( )"},{"entry":"\u2003{"},{"entry":"\u2003\u2003Token.bLink = Token.fLink = Token;"},{"entry":"\u2003}"},{"entry":"\u2003public int IndexOf(object value)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003return 0;"},{"entry":"\u2003}"},{"entry":"\u2003public int Add(object value)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003iCount++;"},{"entry":"\u2003\u2003ListEntry e = (ListEntry)value;"},{"entry":"\u2003\u2003if(Token.fLink == Token)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Token.fLink = e;"},{"entry":"\u2003\u2003\u2003Token.bLink = e;"},{"entry":"\u2003\u2003\u2003e.fLink = Token;"},{"entry":"\u2003\u2003\u2003e.bLink = Token;"},{"entry":"\u2003\u2003\u2003return iCount;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003ListEntry head = Token.fLink;"},{"entry":"\u2003\u2003Token.fLink = e;"},{"entry":"\u2003\u2003e.bLink = Token;"},{"entry":"\u2003\u2003e.fLink = head;"},{"entry":"\u2003\u2003head.bLink = e;"},{"entry":"\u2003\u2003return iCount;"},{"entry":"\u2003}"},{"entry":"\u2003public bool IsFixedSize"},{"entry":"\u2003{"},{"entry":"\u2003\u2003get"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003return false;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003#endregion"},{"entry":"\u2003#region ICollection Members"},{"entry":"\u2003public bool IsSynchronized"},{"entry":"\u2003{"},{"entry":"\u2003\u2003get"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003return false;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003public int Count"},{"entry":"\u2003{"},{"entry":"\u2003\u2003get"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003return iCount;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003public void CopyTo(Array array, int index)"},{"entry":"\u2003{"},{"entry":"\u2003}"},{"entry":"\u2003public object SyncRoot"},{"entry":"\u2003{"},{"entry":"\u2003\u2003get"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003return Token;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003#endregion"},{"entry":"\u2003#region IEnumerable Members"},{"entry":"\u2003public IEnumerator GetEnumerator( )"},{"entry":"\u2003{"},{"entry":"\u2003\u2003return null;"},{"entry":"\u2003}"},{"entry":"10 \u2003#endregion"},{"entry":"\u2003}"},{"entry":"\u2003public class WaitContext"},{"entry":"\u2003{"},{"entry":"\u2003\u2003public readonly IPort Port = null;"},{"entry":"\u2003\u2003public readonly IPortCollection PortCollection = null;"},{"entry":"\u2003\u2003internal HighwireMatcher Matcher = null;"},{"entry":"\u2003\u2003public readonly object Key = null;"},{"entry":"\u2003\u2003public object Msg = null;"},{"entry":"\u2003\u2003internal Schedule Continuation = null;"},{"entry":"\u2003\u2003internal int InitialJoinCount = 1;"},{"entry":"\u2003\u2003internal int JoinCount = 1;"},{"entry":"\u2003\u2003internal ArrayList ChoiceList = null;"},{"entry":"\u2003\u2003internal SortedList JoinList = null;"},{"entry":"\u2003\u2003internal ChoiceSemaphore ChoiceSemaphore= null;"},{"entry":"\u2003\u2003internal JoinSemaphore JoinSemaphore= null;"},{"entry":"\u2003\u2003internal Schedule ChoiceContinuation;"},{"entry":"\u2003\u2003internal Schedule JoinContinuation;"},{"entry":"\u2003\u2003void Init( )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003ChoiceContinuation = new Schedule(ChoiceListener);"},{"entry":"\u2003\u2003\u2003JoinContinuation = new Schedule(JoinListener);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal void AddJoinContext(WaitContext a)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003if (JoinList == null)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003JoinList = new SortedList( );"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003long id = a.GetTypePort( ).Identity;"},{"entry":"\u2003\u2003\u2003if (JoinList.Contains(id))"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003WaitContext ctx = (WaitContext) JoinList[id];"},{"entry":"\u2003\u2003\u2003\u2003ctx.InitialJoinCount++;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003JoinList.Add(id,a);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public WaitContext Clone( )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003WaitContext wc = null;"},{"entry":"\u2003\u2003\u2003if (PortCollection != null)"},{"entry":"\u2003\u2003\u2003\u2003wc = new WaitContext(PortCollection,Key,Continuation);"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003wc = new WaitContext(Port,Continuation);"},{"entry":"\u2003\u2003\u2003wc.Matcher = this.Matcher;"},{"entry":"\u2003\u2003\u2003wc.Msg = this.Msg;"},{"entry":"\u2003\u2003\u2003return wc;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public WaitContext(IPort P)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Init( );"},{"entry":"\u2003\u2003\u2003Port = P;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public WaitContext(IPort P,"},{"entry":"\u2003\u2003\u2003Schedule S"},{"entry":"\u2003\u2003\u2003)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Init( );"},{"entry":"\u2003\u2003\u2003Continuation = S;"},{"entry":"\u2003\u2003\u2003Port = P;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public WaitContext(IPort P, HighwireMatcher M, Schedule S)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Init( );"},{"entry":"\u2003\u2003\u2003Port = P;"},{"entry":"\u2003\u2003\u2003Matcher = M;"},{"entry":"\u2003\u2003\u2003Continuation = S;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public WaitContext(IPort P, HighwireMatcher M)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Init( );"},{"entry":"\u2003\u2003\u2003Port = P;"},{"entry":"\u2003\u2003\u2003Matcher = M;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public WaitContext(IPortCollection P, object key)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Init( );"},{"entry":"\u2003\u2003\u2003PortCollection = P;"},{"entry":"\u2003\u2003\u2003Key = key;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public WaitContext(IportCollection P,object key,Schedule S)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Init( );"},{"entry":"\u2003\u2003\u2003PortCollection = P;"},{"entry":"\u2003\u2003\u2003Continuation = S;"},{"entry":"\u2003\u2003\u2003Key = key;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public static WaitContext operator +(WaitContext a, WaitContext b)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003if(a.ChoiceList == null)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003a.ChoiceList = new ArrayList( );"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003if(b.ChoiceList != null)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003a.ChoiceList.AddRange(b.ChoiceList);"},{"entry":"\u2003\u2003\u2003\u2003b.ChoiceList = null;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003a.ChoiceList.Add(b);"},{"entry":"\u2003\u2003\u2003return a;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public static WaitContext operator {circumflex over (\u2009)}(WaitContext a, object o)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Type t = o.GetType( );"},{"entry":"\u2003\u2003\u2003PortCollection p = new PortCollection(t);"},{"entry":"\u2003\u2003\u2003p.Post(o);"},{"entry":"\u2003\u2003\u2003WaitContext wc = new WaitContext(p,t);"},{"entry":"\u2003\u2003\u2003return a{circumflex over (\u2009)}wc;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public static WaitContext operator {circumflex over (\u2009)}(WaitContext a, Schedule S)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Debug.Assert(a.Continuation == null,\u201cSchedule already specified"},{"entry":"for join context\u201d);"},{"entry":"\u2003\u2003\u2003return Primitives.ConstructJoinContext(a,S);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public static WaitContext operator {circumflex over (\u2009)}(WaitContext a, WaitContext b)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003if (a.JoinList == null)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003a.JoinList = new SortedList( );"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003if (b.JoinList != null)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003foreach(WaitContext c in b.JoinList.Values)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003a.AddJoinContext(c);"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003b.JoinList = null;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003a.AddJoinContext(b);"},{"entry":"\u2003\u2003\u2003return a;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal IPort GetTypePort( )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003IPort pT = this.Port;"},{"entry":"\u2003\u2003\u2003if (this.PortCollection!=null)"},{"entry":"\u2003\u2003\u2003\u2003pT = this.PortCollection.GetPort(Key);"},{"entry":"\u2003\u2003\u2003return pT;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal bool Compare(IPort p, HighwireMatcher Matcher)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003object value = ((MessageContext)Msg).Value;"},{"entry":"\u2003\u2003\u2003if (p.Identity == 0Port.Identity &&  Matcher.Equals(this.Matcher))"},{"entry":"\u2003\u2003\u2003\u2003return true;"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003return false;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal bool Compare(IPortCollection p, Type T)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003if (PortCollection == p &&"},{"entry":"\u2003\u2003\u2003\u2003GetTypePort( ) == p.GetPort(T))"},{"entry":"\u2003\u2003\u2003\u2003return true;"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003return false;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal void Test(ref MessageContext msg)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003if (PortCollection != null)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003PortCollection.TestInternal(Key, ref msg);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003if (Matcher = null)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003Port.TestInternal(ref msg);"},{"entry":"\u2003\u2003\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003bool bMatch = false;"},{"entry":"\u2003\u2003\u2003\u2003ArrayList 1 = new ArrayList( );"},{"entry":"\u2003\u2003\u2003\u2003do"},{"entry":"\u2003\u2003\u2003\u20030{"},{"entry":"\u2003\u2003\u2003\u2003\u2003Port.TestInternal(ref msg);"},{"entry":"\u2003\u2003\u2003\u2003\u2003if(msg != null)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (Matcher.Match(msg.Value))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003bMatch = true;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u20031.Add(msg);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003} while (msg != null);"},{"entry":"\u2003\u2003\u2003\u2003foreach (MessageContext c in 1)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003Port.Post(c);"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003if(bMatch == false)"},{"entry":"\u2003\u2003\u2003\u2003\u2003msg = null;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal void Post(MessageContext msg)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003if (PortCollection!=null)"},{"entry":"\u2003\u2003\u2003\u2003PortCollection.Post(msg);"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003Port.Post(msg);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal void ChoiceListener(object M)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003MessageContext ctx = (MessageContext)M;"},{"entry":"\u2003\u2003\u2003if (Matcher!=null &&  !Matcher.Match(ctx.Value))"},{"entry":"\u2003\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003\u2003ChoiceSemaphore.AttemptCommit(this,ctx);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal void JoinListener(object M)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003MessageContext ctx = (MessageContext)M;"},{"entry":"\u2003\u2003\u2003if (Matcher!=null &&  !Matcher.Match(ctx.Value))"},{"entry":"\u2003\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003\u2003JoinSemaphore.Decrement(this,ctx);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal void RegisterChoiceListener(ChoiceSemaphore cs)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003ChoiceSemaphore = cs;"},{"entry":"\u2003\u2003\u2003RegisterListener(ChoiceContinuation);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal void RegisterJoinListener(JoinSemaphore js)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003JoinSemaphore = js;"},{"entry":"\u2003\u2003\u2003RegisterListener(JoinContinuation);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal void RegisterListener(Schedule Listener)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003ReceiverContext ctx = new ReceiverContext(Listener,null);"},{"entry":"\u2003\u2003\u2003IPortp = GetTypePort( );"},{"entry":"\u2003\u2003\u2003p.RegisterReceiver(ctx);"},{"entry":"\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal void UnregisterChoiceListener( )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003IPortp = GetTypePort( );"},{"entry":"\u2003\u2003\u2003p.UnregisterReceiver(ChoiceContinuation);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal void UnregisterJoinListener( )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003IPortp = GetTypePort( );"},{"entry":"\u2003\u2003\u2003p.UnregisterReceiver(JoinContinuation);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public static implicit operator WaitResult(WaitContext a)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003return Primitives.SyncChoice(a);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003public class WaitResult"},{"entry":"\u2003{"},{"entry":"\u2003\u2003public readonly WaitContext ActionTaken = null;"},{"entry":"\u2003\u2003public Object Msg"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003get"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003return ActionTaken.Msg;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal WaitResult(WaitContext a)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003ActionTaken = a;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public bool this [WaitContext C]"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003get"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003if (ActionTaken == C)"},{"entry":"\u2003\u2003\u2003\u2003\u2003return true;"},{"entry":"\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003\u2003return false;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public bool this [Type MsgType]"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003get"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003if (ActionTaken.Msg.GetType( ) == MsgType)"},{"entry":"\u2003\u2003\u2003\u2003\u2003return true;"},{"entry":"\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003\u2003return false;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public bool this [IPortCollection p,Type MsgType]"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003get"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003if (ActionTaken.Compare(p,MsgType))"},{"entry":"\u2003\u2003\u2003\u2003\u2003return true;"},{"entry":"\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003\u2003return false;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003internal class ChoiceSemaphore"},{"entry":"\u2003{"},{"entry":"\u2003\u2003System.Threading.ManualResetEvent Doorbell;"},{"entry":"\u2003\u2003internal readonly IPortCollection portDispatcher;"},{"entry":"\u2003\u2003volatile ArrayList Branches = null;"},{"entry":"\u2003\u2003volatile WaitContext Winner = null;"},{"entry":"\u2003\u2003internal int Count = 0;"},{"entry":"#if DEBUG \u2225 TRACE"},{"entry":"\u2003\u2003~ChoiceSemaphore( )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003RuntimeDiagnostics.Unregister(this.GetHashCode( ));"},{"entry":"\u2003\u2003}"},{"entry":"#endif"},{"entry":"\u2003\u2003public ChoiceSemaphore(ArrayList Items, IPortCollection"},{"entry":"Dispatcher, bool bSync)"},{"entry":"\u2003\u2003{"},{"entry":"#if DEBUG \u2225 TRACE"},{"entry":"\u2003\u2003\u2003RuntimeDiagnostics.Register(this);"},{"entry":"#endif"},{"entry":"\u2003\u2003\u2003portDispatcher = Dispatcher;"},{"entry":"\u2003\u2003\u2003if(bSync)"},{"entry":"\u2003\u2003\u2003\u2003Doorbell = new System.Threading.ManualResetEvent(false);"},{"entry":"\u2003\u2003\u2003Branches = Items;"},{"entry":"\u2003\u2003\u2003if (((WaitContext)Branches[0]).Matcher == null)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003portDispatcher.Post(new msgScheduleContext(new"},{"entry":"Schedule(RegisterListeners),"},{"entry":"\u2003\u2003\u2003\u2003\u2003null));"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003RegisterListeners(null);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003void RegisterListeners(object o)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003foreach(WaitContext ctx in Branches)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003Debug.Assert ((ctx.Continuation != null &&  Doorbell =="},{"entry":"null) \u2225"},{"entry":"\u2003\u2003\u2003\u2003\u2003(ctx.JoinContinuation != null &&  Doorbell == null) \u2225"},{"entry":"\u2003\u2003\u2003\u2003\u2003(ctx.Continuation == null &&  Doorbell != null),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201cChoiceSemaphore.RegisterListeners:You must supply a"},{"entry":"continuation for all branches\u201d);"},{"entry":"\u2003\u2003\u2003\u2003if (Count > 0)"},{"entry":"\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003if (ctx.JoinList!=null)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003ctx.ChoiceSemaphore = this;"},{"entry":"\u2003\u2003\u2003\u2003\u2003JoinSemaphore j = new JoinSemaphore(ctx,portDispatcher);"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003ctx.RegisterChoiceListener(this);"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003void CleanupHandler(object w)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003WaitContext winner = (WaitContext)w;"},{"entry":"\u2003\u2003\u2003lock (this)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003foreach(WaitContext ctx in Branches)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003if (ctx != winner)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (ctx.JoinSemaphore!=null)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003ctx.JoinSemaphore.Cleanup( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003ctx.UnregisterChoiceListener( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003if (winner.Continuation!=null)"},{"entry":"\u2003\u2003\u2003winner.Continuation(winner.Msg);"},{"entry":"\u2003\u2003else"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Winner = winner;"},{"entry":"\u2003\u2003\u2003Doorbell.Set( );"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003public WaitContext Wait( )"},{"entry":"\u2003{"},{"entry":"\u2003\u2003Doorbell.WaitOne( );"},{"entry":"\u2003\u2003return Winner;"},{"entry":"\u2003}"},{"entry":"\u2003public void AttemptCommit(WaitContext potential Winner,"},{"entry":"MessageContext msgCtx)"},{"entry":"\u2003{"},{"entry":"\u2003\u2003int result = Interlocked.CompareExchange(ref Count,"},{"entry":"\u2003\u2003\u20031,"},{"entry":"\u2003\u2003\u20030);"},{"entry":"\u2003\u2003if (potentialWinner.JoinList==null)"},{"entry":"\u2003\u2003\u2003potential Winner.UnregisterChoiceListener( );"},{"entry":"\u2003\u2003if (result == 1)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Interlocked.Increment(ref RuntimeDiagnostics.ChoiceFailed-"},{"entry":"Commits);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003else"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003Interlocked.Increment(ref RuntimeDiagnostics.ChoiceCommits);"},{"entry":"\u2003\u2003\u2003\u2003potentialWinner.Msg = msgCtx.Value;"},{"entry":"\u2003\u2003\u2003\u2003msgCtx.Key = null;"},{"entry":"\u2003\u2003\u2003\u2003if (potentialWinner.JoinList!=null \u2225 potentialWinner.Matcher !="},{"entry":"null)"},{"entry":"\u2003\u2003\u2003\u2003\u2003CleanupHandler(potential Winner);"},{"entry":"\u2003\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003portDispatcher.Post(new msgScheduleContext(new"},{"entry":"Schedule(CleanupHandler),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003potentialWinner));"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003internal class JoinSemaphore"},{"entry":"\u2003{"},{"entry":"\u2003\u2003WaitContext Accumulator = null;"},{"entry":"\u2003\u2003ICollection Branches = new ArrayList( );"},{"entry":"\u2003\u2003Hashtable MessageTable = new Hashtable( );"},{"entry":"\u2003\u2003internal readonly IPortCollection portDispatcher;"},{"entry":"\u2003\u2003internal int Count = 0;"},{"entry":"\u2003\u2003internal int InitialCount = 0;"},{"entry":"\u2003\u2003int CleanupPending = 0;"},{"entry":"\u2003\u2003internal JoinSemaphore(WaitContext Accum,IPortCollection"},{"entry":"Dispatcher)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003lock (this)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003Debug.Assert(portDispatcher == null);"},{"entry":"\u2003\u2003\u2003\u2003portDispatcher = Dispatcher;"},{"entry":"\u2003\u2003\u2003\u2003Accumulator = Accum;"},{"entry":"\u2003\u2003\u2003\u2003Accumulator.JoinSemaphore = this;"},{"entry":"\u2003\u2003\u2003\u2003InitialCount = 0;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003foreach(WaitContext ctx in Accumulator.JoinList.Values)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003ctx.JoinCount = ctx.InitialJoinCount;"},{"entry":"\u2003\u2003\u2003\u2003InitialCount += ctx.JoinCount;"},{"entry":"\u2003\u2003\u2003\u2003if (ctx.ChoiceList!= null)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003throw new Exception(\u201cNested choice WaitContexts not"},{"entry":"allowed inside a Join WaitContext\u201d);"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003Branches = Accumulator.JoinList.Values;"},{"entry":"\u2003\u2003\u20030Count = InitialCount;"},{"entry":"\u2003\u2003\u2003RegisterListeners(true);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003bool IsCleanupPending( )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003return CleanupPending > 0;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal void Cleanup( )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003if (Interlocked.Increment(ref CleanupPending) == 1)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003foreach(WaitContext ctx in Accumulator.JoinList.Values)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003ctx.UnregisterJoinListener( );"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003object o = null;"},{"entry":"\u2003\u2003\u2003\u2003lock (this)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003MessageTable.Clear( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (Accumulator.Msg!=null)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003o = Accumulator.Msg;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003Accumulator.Msg = null;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003if(o != null)"},{"entry":"\u2003\u2003\u2003\u2003\u2003portDispatcher.Post(new msgScheduleContext(new"},{"entry":"Schedule(CleanupCommitted),o));"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003void CleanupCommitted(object jr)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003JoinResult j = (JoinResult)jr;"},{"entry":"\u2003\u2003\u2003foreach(WaitContext ctx in j.ContextList)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003ctx.Post((MessageContext)ctx.Msg);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal void RegisterListeners(object r)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003if (IsCleanupPending( ))"},{"entry":"\u2003\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003\u2003Count = InitialCount;"},{"entry":"\u2003\u2003\u2003MessageTable.Clear( );"},{"entry":"\u2003\u2003\u2003foreach(WaitContext c in Branches)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003c.JoinCount = c.initialJoinCount;"},{"entry":"\u2003\u2003\u2003\u2003c.RegisterJoinListener(this);"},{"entry":"\u2003\u2003\u2003\u2003if (IsCleanupPending( ))"},{"entry":"\u2003\u2003\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003bool TrackMessage(MessageContext msgCtx)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003lock (this)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003if (MessageTable.Contains(msgCtx))"},{"entry":"\u2003\u2003\u2003\u2003\u2003return false;"},{"entry":"\u2003\u2003\u2003\u2003MessageTable.Add(msgCtx,null);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003return true;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal void Decrement(WaitContext Branch,MessageContext"},{"entry":"msgCtx)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003if (Thread.VolatileRead(ref Branch.JoinCount) == 0)"},{"entry":"\u2003\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003\u2003if (!TrackMessage(msgCtx))"},{"entry":"\u2003\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003\u2003if (Interlocked.Decrement(ref Branch.JoinCount) == 0)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003Branch.UnregisterJoinListener( );"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003if (Interlocked.Decrement(ref Count) == 0)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003portDispatcher.Post(new msgScheduleContext(new"},{"entry":"Schedule(CommitJoin),null));"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal void CommitJoin(object notUsed)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003if (IsCleanupPending( ))"},{"entry":"\u2003\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003\u2003int i = InitialCount;"},{"entry":"\u2003\u2003\u2003ArrayList fallBack = new ArrayList( );"},{"entry":"\u2003\u2003\u2003WaitContext f = null;"},{"entry":"\u2003\u2003\u2003foreach(WaitContext ctx in Branches)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003for (int ii = 0;ii<ctx.InitialJoinCount;ii++)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (IsCleanupPending( ))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003\u2003\u2003MessageContext msg = null;"},{"entry":"\u2003\u2003\u2003\u2003\u2003ctx.Test(ref msg);"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (msg !=null)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003i--;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003f = ctx.Clone( );"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003f.Msg = msg;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fallBack.Add(f);"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003if (i == 0)"},{"entry":"\u2003\u2003\u2003\u2003\u2003break;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003if (i == 0)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"#if DEBUG \u2225 TRACE"},{"entry":"\u2003\u2003\u2003\u2003Interlocked.Increment(ref RuntimeDiagnostics.JoinCommits);"},{"entry":"#endif"},{"entry":"\u2003\u2003\u2003\u2003Accumulator.Msg = new JoinResult(fallBack);"},{"entry":"\u2003\u2003\u2003\u2003MessageContext ctx = new MessageContext( );"},{"entry":"\u2003\u2003\u2003\u2003ctx.Key = typeof(JoinResult);"},{"entry":"\u2003\u2003\u2003\u2003ctx.Value = Accumulator.Msg;"},{"entry":"\u2003\u2003\u2003\u2003Accumulator.ChoiceSemaphore.AttemptCommit(Accumu-"},{"entry":"lator,ctx);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003{"},{"entry":"#if DEBUG \u2225 TRACE"},{"entry":"\u2003\u2003\u2003\u2003Interlocked.Increment(ref RuntimeDiagnostics.JoinRetries);"},{"entry":"#endif"},{"entry":"\u2003\u2003\u2003\u2003JoinRetryHandler(fallBack);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003internal void JoinRetryHandler(object f)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003ArrayList Fallback = (ArrayList) f;"},{"entry":"\u2003\u2003\u2003foreach(WaitContext ctx in Fallback)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003ctx.Post((MessageContext)ctx.Msg);"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003RegisterListeners(true);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"\u2003public class JoinResult"},{"entry":"\u2003{"},{"entry":"\u2003\u2003internal readonly ArrayList ContextList;"},{"entry":"\u2003\u2003internal JoinResult(ArrayList WaitContextList)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003ContextList = WaitContextList;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public object this [IPort p]"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003get"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003int i = 0;"},{"entry":"\u2003\u2003\u2003\u2003foreach(WaitContext ctx in ContextList)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003if(ctx.Port == p)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003ContextList.RemoveAt(i);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return ((MessageContext)ctx.Msg).Value;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003i++;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003return null;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public object this [IPort p,HighwireMatcher Matcher]"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003get"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003int i = 0;"},{"entry":"\u2003\u2003\u2003\u2003foreach(WaitContext ctx in ContextList)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (ctx.Compare(p,Matcher))"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003ContextList.RemoveAt(i);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return ((MessageContext)ctx.Msg).Value;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003i++"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003return null;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public object this [HighwireMatcher Matcher]"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003get"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003int i = 0;"},{"entry":"\u2003\u2003\u2003\u2003foreach(WaitContext ctx in ContextList)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003if (ctx.Compare(ctx.Port,Matcher))"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003ContextList.RemoveAt(i);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return ((MessageContext)ctx.Msg).Value;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003i++"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003return null;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003public object this [IPortCollection p,Type MsgType]"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003get"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003int i = 0;"},{"entry":"\u2003\u2003\u2003\u2003\u2003foreach(WaitContext ctx in ContextList)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (ctx.Compare(p,MsgType))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003ContextList.RemoveAt(i);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003return ((MessageContext)ctx.Msg).Value;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003i++;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003return null;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003public object this [Type MsgType]"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003get"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003int i = 0;"},{"entry":"\u2003\u2003\u2003\u2003\u2003foreach(WaitContext ctx in ContextList)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003MessageContext msg = (MessageContext)ctx.Msg;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (ctx.Compare(ctx.PortCollection,MsgType))"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003ContextList.RemoveAt(i);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003return msg.Value;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003i++;"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003return null;"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public class Primitives"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003internal static long PortIdCounter = 0;"},{"entry":"\u2003\u2003\u2003public static IPortCollection SyncChoiceDispatcher = null;"},{"entry":"\u2003\u2003\u2003public static Random Random = new Random((int)Date-"},{"entry":"Time.Now.Ticks);"},{"entry":"\u2003\u2003internal static ArrayList CreateFlatChoiceList(WaitContext Accum,"},{"entry":"IPortCollection Dispatcher)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003ArrayList Items = Accum.ChoiceList;"},{"entry":"\u2003\u2003\u2003if (Items == null)"},{"entry":"\u2003\u2003\u2003\u2003Items = new ArrayList( );"},{"entry":"\u2003\u2003\u2003Accum.ChoiceList = null;"},{"entry":"\u2003\u2003\u2003Items.Add(Accum);"},{"entry":"\u2003\u2003\u2003return Items;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public static void AsyncChoice(WaitContext Accumulator,IPort-"},{"entry":"Collection Dispatcher)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003ArrayList Items = CreateFlatChoiceList(Accumulator,Dispatcher);"},{"entry":"\u2003\u2003\u2003ChoiceSemaphore c = new ChoiceSemaphore(Items,Dis-"},{"entry":"patcher,false);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public static WaitResult SyncChoice(WaitContext Accumulator)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003ArrayList Items = CreateFlatChoiceList(Accumulator,null);"},{"entry":"\u2003\u2003\u2003ChoiceSemaphore c = new ChoiceSemaphore(Items,SyncChoice-"},{"entry":"Dispatcher,true);"},{"entry":"\u2003\u2003\u2003return new WaitResult(c.Wait( ));"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003public static WaitContext ConstructJoinContext(WaitContext"},{"entry":"Accumulator, Schedule Continuation)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003Debug.Assert(Accumulator.Continuation == null,\u201cOnly one"},{"entry":"continuation can be supplied to join\u201d);"},{"entry":"\u2003\u2003\u2003Accumulator.Continuation = Continuation;"},{"entry":"\u2003\u2003\u2003Accumulator.AddJoinContext(Accumulator);"},{"entry":"\u2003\u2003\u2003return Accumulator;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The following provides a portion of an exemplary service that can leverage choice\/join. This exemplary service looks at some directories, concurrently and\/or asynchronously issues a request to files in respective directories, and utilizes a dynamically created join to collect responses (e.g., out of order) as they complete. In this example, execution continues when all files have been looked at or at least one failure occurred.",{"@attributes":{"id":"p-0102","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"PortCollection enumDirResult = new PortCollection(typeof(msgParent),"},{"entry":"typeof(msgDone));"},{"entry":"WaitContext joins = enumDirResult[typeof(msgParent)];"},{"entry":"for (int cnt=0; cnt<subDirs.Length+1; cnt++)"},{"entry":"{"},{"entry":"\u2003\u2003joins = enumDirResult[typeof(msgDone)];"},{"entry":"}"},{"entry":"enumDirResult.Post(new msgParent(msg.DonePort));"},{"entry":"msgEnumFilesRequest msgFiles = new msgEnumFilesRequest(dir,"},{"entry":"enumDirResult);"},{"entry":"m_Internal.Post(msgFiles);"},{"entry":"Primitives.AsyncChoice(joinBranch, m_Common.Dispatcher)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In order to provide additional context for implementing various aspects of the present invention,  and the following discussion is intended to provide a brief, general description of a suitable computing environment in which the various aspects of the present invention may be implemented. While the invention has been described above in the general context of computer-executable instructions of a computer program that runs on a local computer and\/or remote computer, those skilled in the art will recognize that the invention also may be implemented in combination with other program modules. Generally, program modules include routines, programs, components, data structures, etc., that perform particular tasks and\/or implement particular abstract data types.","Moreover, those skilled in the art will appreciate that the inventive methods may be practiced with other computer system configurations, including single-processor or multi-processor computer systems, minicomputers, mainframe computers, as well as personal computers, hand-held computing devices, microprocessor-based and\/or programmable consumer electronics, and the like, each of which may operatively communicate with one or more associated devices. The illustrated aspects of the invention may also be practiced in distributed computing environments where certain tasks are performed by remote processing devices that are linked through a communications network. However, some, if not all, aspects of the invention may be practiced on stand-alone computers. In a distributed computing environment, program modules may be located in local and\/or remote memory storage devices.",{"@attributes":{"id":"p-0105","num":"0104"},"figref":"FIG. 11","b":["1100","1100","1110","1110","1100","1120","1120","1120"]},"One possible communication between a client  and a server  can be in the form of a data packet adapted to be transmitted between two or more computer processes. The system  includes a communication framework  that can be employed to facilitate communications between the client(s)  and the server(s) . The client(s)  are operably connected to one or more client data store(s)  that can be employed to store information local to the client(s) . Similarly, the server(s)  are operably connected to one or more server data store(s)  that can be employed to store information local to the servers .","With reference to , an exemplary environment  for implementing various aspects of the invention includes a computer . The computer  includes a processing unit , a system memory , and a system bus . The system bus  couples system components including, but not limited to, the system memory  to the processing unit . The processing unit  can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .","The system bus  can be any of several types of bus structure(s) including the memory bus or memory controller, a peripheral bus or external bus, and\/or a local bus using any variety of available bus architectures including, but not limited to, Industrial Standard Architecture (ISA), Micro-Channel Architecture (MSA), Extended ISA (EISA), Intelligent Drive Electronics (IDE), VESA Local Bus (VLB), Peripheral Component Interconnect (PCI), Card Bus, Universal Serial Bus (USB), Advanced Graphics Port (AGP), Personal Computer Memory Card International Association bus (PCMCIA), Firewire (IEEE 1394), and Small Computer Systems Interface (SCSI).","The system memory  includes volatile memory  and nonvolatile memory . The basic input\/output system (BIOS), containing the basic routines to transfer information between elements within the computer , such as during start-up, is stored in nonvolatile memory . By way of illustration, and not limitation, nonvolatile memory  can include read only memory (ROM), programmable ROM (PROM), electrically programmable ROM (EPROM), electrically erasable ROM (EEPROM), or flash memory. Volatile memory  includes random access memory (RAM), which acts as external cache memory. By way of illustration and not limitation, RAM is available in many forms such as synchronous RAM (SRAM), dynamic RAM (DRAM), synchronous DRAM (SDRAM), double data rate SDRAM (DDR SDRAM), enhanced SDRAM (ESDRAM), Synchlink DRAM (SLDRAM), and direct Rambus RAM (DRRAM).","Computer  also includes removable\/non-removable, volatile\/non-volatile computer storage media.  illustrates, for example a disk storage . Disk storage  includes, but is not limited to, devices like a magnetic disk drive, floppy disk drive, tape drive, Jaz drive, Zip drive, LS-100 drive, flash memory card, or memory stick. In addition, disk storage  can include storage media separately or in combination with other storage media including, but not limited to, an optical disk drive such as a compact disk ROM device (CD-ROM), CD recordable drive (CD-R Drive), CD rewritable drive (CD-RW Drive) or a digital versatile disk ROM drive (DVD-ROM). To facilitate connection of the disk storage devices  to the system bus , a removable or non-removable interface is typically used such as interface .","It is to be appreciated that  describes software that acts as an intermediary between users and the basic computer resources described in the suitable operating environment . Such software includes an operating system . Operating system , which can be stored on disk storage , acts to control and allocate resources of the computer system . System applications  take advantage of the management of resources by operating system  through program modules  and program data  stored either in system memory  or on disk storage . It is to be appreciated that the present invention can be implemented with various operating systems or combinations of operating systems.","A user enters commands or information into the computer  through input device(s) . Input devices  include, but are not limited to, a pointing device such as a mouse, trackball, stylus, touch pad, keyboard, microphone, joystick, game pad, satellite dish, scanner, TV tuner card, digital camera, digital video camera, web camera, and the like. These and other input devices connect to the processing unit  through the system bus  via interface port(s) . Interface port(s)  include, for example, a serial port, a parallel port, a game port, and a universal serial bus (USB). Output device(s)  use some of the same type of ports as input device(s) . Thus, for example, a USB port may be used to provide input to computer , and to output information from computer  to an output device . Output adapter  is provided to illustrate that there are some output devices  like monitors, speakers, and printers, among other output devices , which require special adapters. The output adapters  include, by way of illustration and not limitation, video and sound cards that provide a means of connection between the output device  and the system bus . It should be noted that other devices and\/or systems of devices provide both input and output capabilities such as remote computer(s) .","Computer  can operate in a networked environment using logical connections to one or more remote computers, such as remote computer(s) . The remote computer(s)  can be a personal computer, a server, a router, a network PC, a workstation, a microprocessor based appliance, a peer device or other common network node and the like, and typically includes many or all of the elements described relative to computer . For purposes of brevity, only a memory storage device  is illustrated with remote computer(s) . Remote computer(s)  is logically connected to computer  through a network interface  and then physically connected via communication connection . Network interface  encompasses wire and\/or wireless communication networks such as local-area networks (LAN) and wide-area networks (WAN). LAN technologies include Fiber Distributed Data Interface (FDDI), Copper Distributed Data Interface (CDDI), Ethernet, Token Ring and the like. WAN technologies include, but are not limited to, point-to-point links, circuit switching networks like Integrated Services Digital Networks (ISDN) and variations thereon, packet switching networks, and Digital Subscriber Lines (DSL).","Communication connection(s)  refers to the hardware\/software employed to connect the network interface  to the bus . While communication connection  is shown for illustrative clarity inside computer , it can also be external to computer . The hardware\/software necessary for connection to the network interface  includes, for exemplary purposes only, internal and external technologies such as, modems including regular telephone grade modems, cable modems and DSL modems, ISDN adapters, and Ethernet cards.","What has been described above includes examples of the present invention. It is, of course, not possible to describe every conceivable combination of components or methodologies for purposes of describing the present invention, but one of ordinary skill in the art may recognize that many further combinations and permutations of the present invention are possible. Accordingly, the present invention is intended to embrace all such alterations, modifications, and variations that fall within the spirit and scope of the appended claims.","In particular and in regard to the various functions performed by the above described components, devices, circuits, systems and the like, the terms (including a reference to a \u201cmeans\u201d) used to describe such components are intended to correspond, unless otherwise indicated, to any component which performs the specified function of the described component (e.g., a functional equivalent), even though not structurally equivalent to the disclosed structure, which performs the function in the herein illustrated exemplary aspects of the invention. In this regard, it will also be recognized that the invention includes a system as well as a computer-readable medium having computer-executable instructions for performing the acts and\/or events of the various methods of the invention.","In addition, while a particular feature of the invention may have been disclosed with respect to only one of several implementations, such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore, to the extent that the terms \u201cincludes,\u201d and \u201cincluding\u201d and variants thereof are used in either the detailed description or the claims, these terms are intended to be inclusive in a manner similar to the term \u201ccomprising.\u201d"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
