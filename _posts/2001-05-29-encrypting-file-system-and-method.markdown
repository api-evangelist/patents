---
title: Encrypting file system and method
abstract: A system and method for encryption and decryption of files. The system and method operate in conjunction with the file system to transparently encrypt and decrypt files in using a public key-private key pair encryption scheme. When a user puts a file in an encrypted directory or encrypts a file, data writes to the disk for that file are encrypted with a random file encryption key generated from a random number and encrypted with the public key of a user and the public key of at least one recovery agent. The encrypted key information is stored with the file, whereby the user or a recovery agent can decrypt the file data using a private key. With a correct private key, encrypted reads are decrypted transparently by the file system and returned to the user. One or more selectable encryption and decryption algorithms may be provided via interchangeable cryptographic modules.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06986043&OS=06986043&RS=06986043
owner: Microsoft Corporation
number: 06986043
owner_city: Redmond
owner_country: US
publication_date: 20010529
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["The present application is a continuation-in-part of U.S. patent application Ser. No. 08\/931,774 filed Sep. 16, 1997 now U.S. Pat. No. 6,249,886, herein incorporated by reference.","The invention relates generally to computer storage techniques, and more particularly to an encrypting file system and method for computer systems.","The protection of sensitive data has become a very important issue to users of computers. For example, data such as personnel records or customer credit card numbers may be stored on a computer, and if that computer (or even just the storage media) is stolen, the thief has access to the sensitive information. This is especially troublesome with laptop computers, which are frequently stolen by sophisticated thieves. Moreover, information may be misappropriated even when the storage media is not physically taken, such as when an unauthorized individual gains access to a computer (possibly when that computer is simply online) and copies information from some or all of its files. Those authorized to access the sensitive information may not even know that it has been copied.","To protect information, one type of security procedure involves encrypting the data, so that even if the data falls into the wrong hands, it cannot be read without a key. Many application level programs provide some form of such encryption. While better than nothing, however, such existing encryption schemes suffer from myriad problems.","One serious problem is that the encrypted data is still susceptible to a number of attacks. More particularly, applications providing encryption functions use password\/pass-phrase derived keys, which are weak by definition due to dictionary attacks and the like. Moreover, attacks improve over time, particularly as hardware improves, and what was once considered safe by one application may no longer be safe.","Also, users tend to lose keys. The problem of lost keys can be eliminated by spreading the key around to multiple users, but this further compromises security. Moreover, each file may have a different password, making recall difficult. Accordingly, for convenience many users will encrypt many files with the same password key used to encrypt one file, whereby divulging a key to another person for one file often results in inadvertently giving that person the key to many other files. Moreover, in order to remove or add user access to one or more files, each file (and every copy of each file) must be decrypted and re-encrypted with the new key, and then redistributed.","Yet another significant problem is that the encryption process is inconvenient, requiring the encrypting and decrypting of each such file during each use. As a result, many typical users tend to neglect security concerns rather than bother with encrypting various files.","Another serious problem is that most applications create temporary files while a user works on a document. These temporary files are not always removed after the original is saved, leaving the sensitive data vulnerable. Also, with contemporary operating systems, application-level encryption runs in the user mode, and thus all the data, including the user's encryption key, can make into the page file, making the task of locating a key quite easy. Lastly, most file encryption applications have built-in encryption algorithms, and are therefore not extendible or flexible in supporting different or multiple algorithms that would allow users to update encryption algorithms as such algorithms improve over time, or to select from among encryption algorithms for particular data, e.g., to make a speed versus strength tradeoff based on the sensitivity of the data being encrypted.","Briefly, the present invention provides a system and method for encrypting or decrypting data in a file. Whenever a user specifies that a file or its parent directory is encrypted, the encrypting file system receives an encryption key associated with the file. Then, when the system receives a request to write any plaintext file data to disk in an encrypted manner, the file system receives the file data, encrypts the file data into encrypted file data using the encryption key, and writes the encrypted file data to the disk. Conversely, when the system receives a request to read encrypted file data from the disk, the file system reads the encrypted file data, decrypts the read data into decrypted file data using the encryption key, and returns the decrypted file data to the user. The encryption and decryption are automatically performed at the file system level, and are transparent to the user.","The encryption key is a random number encrypted by the public key of at least one user and at least one recovery agent. These keys are stored with the file, whereby the file can always be decrypted by the private key of either a user or a recovery agent.","The encryption algorithm may be provided in an interchangeable module comprising a set of one or more selectable algorithms. The module may be replaced by an updated module and\/or one having a different algorithm set therein.","Other benefits and advantages will become apparent from the following detailed description when taken in conjunction with the drawings, in which:","General Architecture","Turning to the drawings and referring first to , there is shown a computer system  generally designated  into which the present invention may be incorporated. The illustrated computer system  may be a server, a workstation, or a combination thereof, and may be connected in a known manner to one or more other computer-based resources. Of course, as will become apparent, the invention is not limited to any particular type of computer or network architecture, and may be incorporated into a stand-alone personal computer or the like.","As shown in , the computer system  includes a processor  connected to a memory  having an operating system  loaded therein. One suitable operating system  is Microsoft Corporation's Windows\u00ae 2000 operating system. The computer  has a file system  such as the Windows NT File system  (NTFS ) associated with or included within the operating system . However, as can be appreciated, the present invention is not limited to any particular operating system and\/or file system, but for clarity the present invention will be hereinafter described with reference to Windows\u00ae 2000 and NTFS . At least one application program  in the memory  interfaces with the operating system  and the file system  through application programming interfaces (APIs) .","The computer system  also includes input-output (I\/O) circuitry  for connecting the computer system  to one or more networked devices, to one or more input devices  such as a keyboard and\/or mouse, and\/or to one or more output devices  such as a monitor and\/or speakers. The computer system  also includes a non-volatile storage device  such as a hard disk drive. As can be appreciated, the non-volatile storage device  may also operate in conjunction with the random access memory of the memory  to provide a large amount of virtual memory via swapping techniques.","The file system  connects through a device driver  to communicate with the non-volatile storage device , to manage the files thereon, and generally contains methods for (1) storing, referencing, sharing and securing files, (2) accessing file data and (3) maintaining file integrity. Notwithstanding, there is not always a clear distinction between a file system  and its associated operating system, particularly with those file systems  contained within an operating system. Accordingly, it is understood that any or all of the processes or steps attributed herein to the file system  may alternatively be performed by the operating system , and vice-versa.","The non-volatile storage  stores a number of files \u2013, which, when NTFS serves as the file system , have their data organized in attribute data streams. An NTFS file control block (FCB) associated with each file maintains information identifying the data streams belonging thereto. Windows NT and NTFS  are described in the texts, Inside Windows NT, by Helen Custer, Microsoft Press (1993) and Inside the Windows NT File System, Helen Custer, Microsoft Press (1994). As shown in  and as described below, in accordance with the present invention, at least some of the files \u2013are stored with encrypted data.","EFS Component","In accordance with one aspect of the present invention, to encrypt and decrypt the files, as shown in , an encrypting file system is provided, in one implementation comprising an Encrypting File System (EFS) linked library , (e.g., DLL), an EFS runtime library (FSRTL )  and an EFS service . The linked library  provides relatively tight integration with the file system, (as opposed to an installable filter driver model such as described in parent U.S. patent application Ser. No. 08\/931,774), e.g., both are loaded together (and not according to a registry setting). Notwithstanding, the present invention is not limited to any particular implementation, but will work with a linked library, driver, or virtually any other mechanism including directly incorporating the encryption functions into the file system code.","The EFS linked library  registers with the file system , whereby the file system provides encryption functionality that is transparent (e.g., to an application) by calling the EFS linked library's functions, listed in a function table or the like acquired by the file system during registration. Note that instead of linking in this manner, these functions may be incorporated into the file system , however the modularity of these components provides benefits normally associated with modularity. For purposes of this description, once registered, the EFS linked library  generally may be considered part of the file system . Further, note that if for some reason the EFS linked library  cannot link to and register with the file system, (e.g., errors may occur during the initialization phase), then the file system will not provide encryption and decryption functionality. For example, a user will not be able to access an encrypted file (until the library is properly initialized).","During initialization, the EFS linked library  registers file system runtime library callback routines (FSRTL  routines) with the NTFS , maintained in the function table . As described below, NTFS  uses these FSRTL  routines to call back to obtain file encryption related services.","The EFS linked library  provides the support to communicate with the user mode EFS service  running as part of the security subsystem. During initialization (or alternatively when encryption or decryption is first needed), the EFS linked library  communicates with the EFS service  using a GenerateSessionKey interface, to establish a symmetric session key that is used to communicate securely between the EFS linked library  and the EFS service . Data communicated between the two is encrypted using this session key. This session key is also used by callouts to the FSRTL  to decrypt I\/O controls from the EFS service .","During open of an encrypted file, the EFS linked library  communicates with the EFS service  by passing it the file metadata, including the data decryption and data recovery fields, (, described below), to get back the file encryption key and any updates to the file metadata. The file metadata may be updated because the user may change to a new key, or the recovery agent's keys might get updated. The EFS linked library  passes this information to FSRTL .","During encryption of a plaintext file\/directory or creation of a new encrypted file, the EFS linked library  communicates with the EFS service  to get a new file encryption key, and encryption metadata for the encrypted file. The EFS linked library  also passes this information to the FSRTL .","EFS FSRTL","The FSRTL  is a module that implements NTFS callouts to handle various file system  operations such as reads, writes, and opens, on encrypted files and directories, as well as operations to encrypt, decrypt, and recover file data when it is written to or read from disk. To this end, the present invention provides a callout mechanism including an interface between NTFS  and the FSRTL . As described in more detail below, this interface is generic to any appropriate library (and driver) that transform data, including the ones described herein that encrypt data, and thus the interface between NTFS  and FSRTL  is more accurately referred to as a data transformation interface . For example, an indexing driver could use this interface to monitor all writes to disk and develop an index based on those writes. However, as can be appreciated, a dedicated encryption interface may be alternatively provided. Note that in one preferred implementation the interface  (and other interfaces herein) is generic to allow for other EFS-like packages to be supplied).","Operations between the EFS linked library  and FSRTL  include writing EFS attribute data (decryption data and recovery fields) as file attributes, and communicating a file encryption key computed in the EFS service  to FSRTL , such that it can be set up in the context of an open file. This file context is then used for transparent encryption and decryption on writes and reads of file data to and from the non-volatile storage .","The data transformation interface  is capable of interfacing to any engine or driver that transforms the data in virtually any way, but for purposes herein the interface  will be described as interfacing the EFS linked library  to the file system  for accomplishing data encryption. Notwithstanding, the data transformation interface is not limited to data encryption, but is appropriate for accomplishing virtually any type of data alteration. At present, however, this transformation model supports in-place data transformation wherein the data takes at least no more space than the original plain text. In any event, the EFS linked library  registers these callbacks with the file system , whereby the file system  uses the registered EFS callback functions at appropriate times to carry out the various encrypting and decrypting tasks that the user requests.","Although not necessary to the invention, for convenience, the FSRTL  is stored in a common file with the EFS linked library . Indeed, although the EFS linked library  and FSRTL  are implemented as a single component, they do not communicate directly, but instead use the NTFS file control callout mechanism, i.e., the EFS linked library  can effectively call the FSRTL . The use of the NTFS callout mechanism ensures that NTFS  participates in all file operations, which avoids conditions such as where two users are locked, each user waiting for the release of the other's file.","The data transformation interface  includes a number of function pointers, or callbacks. A first callback which the file system  uses, the FileCreate callback, tells the registered EFS functions that a stream is being created or opened. The actions that EFS linked library  takes at this point (e.g., determining if a user has access if the file is an existing file or getting the metadata stream for a new file) are described in more detail below.","When an application opens or creates a file, the I\/O subsystem  determines the file is of a certain file system, e.g., an NTFS  file, and passes the request on to NTFS . NTFS  determines whether EFS may be interested in the file, e.g., if the file is created in an encrypted directory or if a stream is created or attached to an encrypted file. IF NTFS  determines that the file is of interest to EFS, and sees that the EFS linked library  is registered therewith, NTFS  calls a registered EFS function, i.e., the FileCreate callback. If the request is a file open request on an existing file, FSRTL  reads the file metadata from the file attribute and fills up a context block (e.g., block of , previously allocated by the EFS linked library , as described below) to pass back that information to the EFS linked library . When the call returns from NTFS , the EFS linked library  takes the metadata information and communicates with the EFS service  to extract the file encryption key  from the metadata. This information is then returned by the EFS linked library  to NTFS  by another FSRTL  interface, FileControl, described below, which sets up a key context  on the file being opened. This key context  is thereafter retained by NTFS  for future calls to the EFS linked library  until the file is closed. If the file metadata is updated, the updated metadata is also re-written to the attributes by the registered EFS functions through NTFS callbacks.","If a new file is created, the FileCreate call results in the FSRTL  filling up the context buffer with a request for a new file encryption key and metadata. The FSRTL  then passes the context buffer back to the EFS linked library . The EFS linked library  takes this information and communicates with the EFS service  to obtain a new file encryption key and new file metadata from the EFS service . Using a file control callback (described below), the EFS linked library  returns this information to the FSRTL , whereby, using NtOfs function calls, the FSRTL  sets up the key context  on the file being created and writes the file metadata. The NtOfs API is a set of NTFS  function calls that allow the EFS linked library  to call into the file system  to manipulate the data streams containing the encryption meta data.","Another callback, FileSystemControl, is called by NTFS  in response to the EFS linked library  request when a user is setting the encryption state of a file (EFSSETENCRYPT), either marking it as encrypted or decrypted. In response, NTFS  sets or clears the encryption bit, and the EFS linked library  generates any necessary key storage. EFSSETENCRYPT also originates in the EFS service  when a plaintext file begins to be encrypted, whereby the file state is modified such that no other operations are allowed on the file until the encryption is completed.","NTFS  also calls the FileSystemControl interface with various encryption driver-specific file control requests from the EFS linked library . Note that NTFS  takes no action with these callbacks other than to simply pass the call to the FSRTL . The file control requests include EFSSETATTRIBUTE, which comes from the EFS filter EFS linked library  when it wants to write new or updated file metadata, and EFSGETATTRIBUTE, which may come from the EFS linked library  or a user mode application  to query the file metadata. The information includes the list of user public keys and recovery agent public keys (described below) that are used to encrypt the file encryption key. Another request, EFSDECRYPTBEGIN, comes from the EFS service  when it starts decrypting an encrypted file. In response, the state of the file is modified such that no other operations are allowed on the file until the decryption is completed. EFSDELATTRIBUTE is a request originating in the EFS service  when it finishes decrypting an entire encrypted file, and wants to delete the file metadata and associated attribute. The EFSENCRYPTDONE request also comes from the EFS service  when it successfully completes the file encryption. The file state is modified to allow any operations from this point on.","EFSOVERWRITEATTRIBUTE comes from the EFS service  when an encryption file is restored from its backup format. The EFS service  supplies the file metadata that needs to overwrite any existing metadata on the file. This request is also associated with the deletion of any key context  associated with that file, such that no reads or writes can proceed while the file is being restored.","The FileSystemControl interface is also called by the file system  in response to the FSCTLENCRYPTIONFSCTLIO, also described below. This provides a means for the EFS linked library  to have NTFS  call the EFS linked library  (itself), such as when NTFS  recognizes that a file is in a certain state corresponding to a state for which the EFS linked library  is waiting.","The file system  directly uses the callback, AfterReadProcess after it has read some data from the disk for an encrypted file, and before returning it to the user. The AfterReadProcess function decrypts the data on the fly in response to this callback. The read operation is described in more detail below with respect to .","Conversely, BeforeWriteProcess is called by the file system  before it writes some data to the disk for an encrypted file. The function encrypts the data as a result of this callback. The write operation is described in more detail below with respect to .","The CleanUp callback is called by the file system  when NTFS  is freeing any resources associated with a stream. At this time, the EFS linked library  frees up any memory resources it was using, such as to store keys and the like. When NTFS  receives its last close on a stream, NTFS  performs its normal operations to free up anything stored in memory to keep track of this open file, including the key context . In addition, the file system  calls the EFS linked library  with the context block , giving it the opportunity to free up any memory it was consuming for this file, e.g., the context block .","The AttachVolume callback is called by a file system  (during the first user operation involving encryption), as described above. In response, the EFS linked library  notifies the I\/O subsystem that it wants to attach to the device object representing that volume, thereby logically placing itself above NTFS  for that volume so that the I\/O subsystem will pass information to the EFS linked library  first. DismountVolume is called by a file system  when a volume is being dismounted, either because a user wishes to eject or remove the drive, or because the system is being shut down. In response to the DismountVolume call, an encryption library or driver may free any memory resources that were allocated during the AttachVolume callback. However, it should be noted that the EFS linked library  ordinarily detaches itself and frees any resources when notified by the I\/O subsystem of a volume dismount, but the DismountVolume callback is provided anyway to provide additional flexibility.","EFS Service","The EFS service  is part of the Windows NT security subsystem. As represented in  as EFS service \/Driver Communication , the EFS service  uses the existing local procedure call communication port between a Local Security Authority (LSA) and the kernel mode security reference monitor to communicate with the EFS linked library . In the user mode, the EFS service   interfaces with Microsoft's Cryptography API, CryptoAPI , to provide file encryption keys, and generate decryption field information.","The EFS service  also provides support for Win32 APIs , which are programming interfaces for encrypt, decrypt, recover and provide support for importing and exporting encrypted files. Importing and exporting encrypted files allows users to convert the files into opaque data (encrypted) for operations such as backup, restore, and general file transfer purposes as described below. The Win32 APIs  provide programming interfaces for encrypting plain text files, decrypting or recovering ciphertext files, and importing and exporting encrypted files (without decrypting them first). These APIs  are supported in a standard system DLL, advapi32.dll.","The EFS service  provides a number of services, including generating a session key and exchanging it with the EFS linked library  and the FSRTL . Based on the EFS linked library  request, the EFS service  generates a cryptographically strong session key (using CryptoAPI) and communicates it to the driver and FSRTL . The EFS service  also generates the file encryption keys in fields stored with the file (the Data Decryption Field, or DDF, and the Data Recovery Field, or DRF, described below with reference to ) using the user's and recovery agents' public key defined for EFS. When the EFS linked library  requests a new file encryption key, the EFS service  generates this information using CryptoAPI and returns it to the EFS linked library .","The EFS service  also extracts the file encryption key, i.e., when the EFS linked library  requests this operation, the EFS linked library  supplies the file metadata, including the DDF and DRF key fields. Based on that information, the EFS service  sequentially searches the DDF and (if necessary) the DRF key fields to extract the name of the user's key therefrom, and accesses its private portion via the CryptoAPI provider . If successful, (as described in more detail below), it passes the encrypted file encryption key to the provider for decryption. The service verifies that the decryption was correct (as also described below), and also verifies that the keys used in the file metadata are up to date. If the keys are not up to date, the service regenerates the metadata (DDF and\/or DRF) and returns the extracted file encryption key and the metadata back to the EFS linked library .","When the EFS linked library  is loaded by NTFS , it first initializes its structures, and reserves some space to ensure that some memory is always available thereto. Then, the EFS linked library  registers itself with NTFS . Lastly, to synchronize with the driver, the EFS linked library  attempts to create a new event. If the event is successfully created, this indicates that the EFS service  has not been initialized and the EFS linked library  has been loaded first. If successful, the EFS linked library  then creates a thread waiting on the event to be signaled. Later, when the event is signaled, i.e., the EFS service  is ready to communicate, the EFS linked library  calls the EFS service  to get the session key. Once the session key has been transferred from the EFS service  to the EFS linked library , and the EFS service  and the EFS linked library  are synchronized. Note that if the event was not successfully created, it is ordinarily because the EFS service  was already initialized, in which event the EFS linked library  simply makes the call to get the session key.","In the situation where the EFS service  was loaded first, the EFS service  tries to create a new event. If the event is successfully created, then the EFS linked library  has not been initialized. The EFS service  generates the session key without waiting on the event. Later, when the EFS linked library  is loaded, the EFS service  will be called by the EFS linked library  to provide the session key thereto. When the EFS service  provides the session key, the EFS service  closes the event which was created earlier by the EFS service , and the EFS service  and the EFS linked library  are synchronized. Note that if the event was not successfully created, it is ordinarily because the EFS linked library  was already initialized, in which event the EFS service  instead opens the event and signals the event to let the EFS linked library  know that the EFS service  is ready. Thereafter the EFS service  is asked for the session key by the EFS linked library , and the synchronization is done.","System APIS","As described in more detail below with particular respect to , the EFS service  also provides a number of other user mode interfaces. These interfaces work closely with system APIs (e.g., WIN32 or the like) to enable the user to perform operations such as convert an existing plaintext file to an encrypted file, convert an encrypted file to a plaintext file, and provide a backup and restore mechanism. By way of example, the Win32 interfaces  work with the EFS service  to expose EFS functionality, and include EncryptFile, which is a wrapper that calls into the interface provided by the EFS service  to do file encryption (). Another interface, DecryptFile, is a wrapper that similarly calls into the interface provided by EFS service  to do file decryption\/recovery ().","A Backup\/Restore mechanism is also provided in the system APIs, which enables users and backup operators to backup encrypted files without decryption. To this end, an OpenRawFile interface allows the user to open an encrypted file without read access, and without setting up a file encryption key to do transparent reads and writes. For these operations, NTFS  recognizes the access level and does not call the encryption EFS linked library  to look up a key for this file, nor to decrypt reads nor encrypt writes. The only operations allowed on a file opened via this interface are file controls. Thus, a ReadRawFile interface allows the user to read all the data from the file, including the encryption metadata, as a contiguous opaque stream that can be backed up and later restored. A WriteRawFile interface allows the user to write all the data to the file from its backup, including the encryption metadata, to re-create the encrypted file. Lastly, a CloseRawFile is provided that allows the user to close the file which was opened raw by OpenRawFile.","A FileControl interface allows the Win32 APIs that provide the backup and restore mechanism to read and write raw encrypted data. Note that such raw data reads and writes are from\/to NTFS  direct to\/from the disk (storage); EFS becomes involved because the EFS service  and the EFS linked library  share the common session key, and all file controls need to be verified (as described below). For backing up the file, the Win32 APIs read the EFS metadata via an EFS file control, which translates into the FileSystemControl that returns the EFS stream. Then, NTFS  file controls are called to read the actual file data, which is packaged into an opaque stream and written out. To (gradually) restore the file, the reverse process is performed. An EFS file control is called to identify a first stream and another EFS file control to write the raw data back.","Data Encryption","As conceptually represented in , the present invention implements data encryption and decryption using a public key-based scheme. To this end, file data is encrypted using a fast symmetric algorithm with a file encryption key (FEK)  (). The FEK  is a randomly generated key of a certain length required by the selected algorithm, or as otherwise required if the algorithm supports variable length keys. As represented in , a random number generator  generates the FEK . To encrypt the file data using the FEK , the plain text  of the file is encrypted by a file encryption mechanism  using an appropriate algorithm (e.g., DES) and written as encrypted text  to an encrypted file .","In accordance with another aspect of the present invention, and as shown in , the randomly generated FEK  is itself encrypted with the public key  of at least one user, and stored with the encrypted file  in a special EFS attribute called the Data Decryption Field (DDF) . Using a suitable encryption algorithm, (e.g., RSA), a data decryption field generator  performs the key encryption. In keeping with public-key based schemes, the private portion of the user's key pair is only used during decryption, i.e., an encrypted FEK  in the data decryption field  is decrypted using the private portion of the key pair. The private portion  () of a user key pair is safely stored in a separate location, such as on a smart card and\/or other secure storage device. Note that encryption can also be done using a symmetric algorithm, such as a password-derived key, but while feasible, EFS preferably does not support such encryption because password-based schemes are inherently weak due to dictionary attacks and the like.","In accordance with one aspect of the present invention, as also represented in , the FEK  is also encrypted using one or more recovery public keys . The recovery key encryption public keys  belong to trusted persons, known as recovery agents, as specified by a recovery policy, described below. Similar to the FEK's encryption using the user's public key, the public portion of each recovery key pair is used to encrypt the FEK  using a data recovery field generator , (employing, for example, a suitable encryption algorithm, such as RSA, which need not be the same algorithm used to encrypt the FEK  with the user's public key). This list of encrypted FEKs is similarly stored along with the file  in a special EFS attribute called the Data Recovery Field (DRF) . Thus, only public portions of the recovery key pairs are needed for encryption of the FEK  in the DRF . Note that to facilitate proper operation, these public recovery keys are to be present at all times on an EFS system for normal file system  operations, since a user may wish to encrypt a file at any time. Recovery itself is expected to be a rare operation required only when users leave organizations, lose keys, and so on. As a result, recovery agents are also able to store the private portions  () of the keys on smart cards, floppy disks, and\/or other secure storage devices.","In keeping with the invention, the Encrypting File System architecture is not limited to any particular encryption algorithm, but rather is fully algorithm agile and may use any cryptography algorithm for the various encryption phases. As a result, the Encrypting File System of the present invention allows for the usage of better and better encryption algorithms as such algorithms advance technologically. Moreover, the user is able to choose from among available algorithms to select an algorithm having greater or less security (i.e., based on how sensitive the user thinks the information is) versus the speed of encryption and decryption, (i.e., more secure algorithms are generally slower). Thus, in the above description, DES is one such algorithm used to encrypt file data, while RSA is used to encrypt the FEK.","A choice of algorithms may be made available by providing the algorithm into an installable module separate from the file system and\/or encrypting file system library (although, for example, a default algorithm may still be provided in the library). As generally represented in , a user can select an algorithm from an interchangeable (installable) cryptographic module  having a set of one or more suitable algorithms present therein. Alternatively, or in addition to, the algorithm set may be changed by replacing the interchangeable module with a different cryptographic module  containing a different algorithm set. For security, the interchangeable kernel mode cryptographic module  may be a kernel mode component, such as in the form of a single kernel mode export driver (a kernel-mode DLL). For example, the user (or an administrator) can choose a given encryption\/decryption algorithm for all files by default, on a per-file or per-directory basis, and so on. Once saved, information stored with the encrypted file can identify which algorithm was used to encrypt the data, whereby the appropriate algorithm for decrypting the data can be automatically selected for existing files. In any event, EFS is aware of the appropriate algorithm, and can notify the cryptographic module as to which one to use, e.g., by calling a corresponding function of the module based on the algorithm or by passing an algorithm identifier to the cryptographic module.","By way of example, one such interchangeable kernel mode cryptographic module is a FIPS (Federal Information Processing Standards) system file, such as in the form of a single kernel mode export driver. The cryptographic boundary for this file is defined as the enclosure of the computer system on which the cryptographic module is to be executed.","To securely separate the interchangeable cryptographic module  from EFS library , the interchangeable cryptographic module  comprises a self-authenticating algorithm. The module  initializes before EFS, and does a self-check. When EFS initializes, the EFS library  calls the interchangeable cryptographic module  (driver) and receives a function table in return, and stores it. For example, in an NTFS system, the table is acquired by building a function table request IRP (I\/O request packet) and then sending the IRP to the interchangeable cryptographic module , which in turn returns the table. Thereafter, when EFS performs encryption, EFS looks up the algorithm it will use in the function table, and uses it. Significantly, this provides a straightforward way for to change the algorithm and\/or for an administrator or the like to replace an interchangeable cryptographic module  with an updated version. Such selection\/replacement is independent and transparent to EFS, but allows EFS the flexibility to use different algorithms.","A preferred FIPS cryptographic module runs as a kernel mode export driver and encapsulates several different cryptographic algorithms in a cryptographic module that is accessible by other kernel mode drivers and can be linked into other kernel mode services (e.g., to permit the use of FIPS - Level 1 compliant cryptography). The cryptographic module  may rely on the operating system for the authentication of users. The keys created within the cryptographic module  for one user are not accessible to any other user via the cryptographic module .","Once initialized, to use, for example, a DES or Triple DES function of the installable cryptographic module , a kernel mode system service provides a respective DES or Triple DES key. Keys are not stored by the module , but zeroed after the cryptographic module  completes a respective DES or Triple DES function with the keys.","In general, to encrypt or decrypt data, the EFS library  calls a respective function (e.g., DES, 3DES) of the interchangeable cryptographic module  with a pointer to an input buffer containing the data, and a pointer to an output buffer, a pointer to the key and a parameter specifying whether encryption or decryption is desired. Hashing functions also may be provided in the same module , along with key generation (e.g., random keys), key entry and key output functions.","The following table summaries various states of a preferred FIPS interchangeable cryptographic module:",{"@attributes":{"id":"p-0077","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]},{"entry":[{},"Current",{},{},"Next",{}]},{"entry":[{},"State","Input","Output","State","Comment"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","Power Up","FIPS.SYS loads","NOERROR","Initialized","The Power Up state is entered when"]},{"entry":[{},{},{},{},{},"OS Loader calls the FIP.SYS driver"]},{"entry":[{},{},{},{},{},"entry point function DriverEntry()"]},{"entry":[{},{},{},{},{},"during system boot."]},{"entry":["2","Power Up","FIPS.SYS not","STATUSUN","Init Error","(see comment for"]},{"entry":[{},{},"found","SUCCESSFUL",{},"State 1 above)"]},{"entry":["2","PowerUp","DES MAC check","STATUSUN","Init Error","(see comment for"]},{"entry":[{},{},"on cryptographic","SUCCESSFUL",{},"State 1 above)"]},{"entry":[{},{},"provider fails"]},{"entry":["2","Power Up","One or more","STATUSUN","Init Error","(see comment for"]},{"entry":[{},{},"power-on","SUCCESSFUL",{},"State 1 above)"]},{"entry":[{},{},"cryptographic"]},{"entry":[{},{},"self-tests fail"]},{"entry":["2","Power Up","System error","STATUSUN","Init Error","(see comment for"]},{"entry":[{},{},{},"SUCCESSFUL",{},"State 1 above)"]},{"entry":["3","Init Error","Automatic","No output","Power","The Init Error State is entered when"]},{"entry":[{},{},"transition",{},"Down","FIPS.SYS's DriverEntry() fails as a"]},{"entry":[{},{},{},{},{},"result of either configuration errors"]},{"entry":[{},{},{},{},{},"(i.e. not enough memory, etc.) or"]},{"entry":[{},{},{},{},{},"errors resulting from the power up"]},{"entry":[{},{},{},{},{},"self-tests."]},{"entry":["4","Initialized","Key formatting","No output","Key","The Initialized state"]},{"entry":[{},{},"operation (i.e.",{},"Initialized","is entered when"]},{"entry":[{},{},"FipsDesKey(),",{},{},"FIPS.SYS's"]},{"entry":[{},{},"Fips3Des3Key())",{},{},"DriverEntry() returns"]},{"entry":[{},{},"requested",{},{},"successfully and the"]},{"entry":[{},{},{},{},{},"Windows Loader"]},{"entry":[{},{},{},{},{},"completes the loading"]},{"entry":[{},{},{},{},{},"of FIPS.SYS."]},{"entry":["5","Initialized","Key formatting","Operation","Operation"]},{"entry":[{},{},"operation failure","specific error","Error"]},{"entry":[{},{},{},"message"]},{"entry":["6","Operation","Automatic","No output","Initialized","The Operation Error state is entered"]},{"entry":[{},"Error","transition when",{},{},"whenever an error occurs as a result"]},{"entry":[{},{},"keys have not yet",{},{},"of a cryptographic operation."]},{"entry":[{},{},"been initialized",{},{},"FIPS.SYS will automatically"]},{"entry":[{},{},{},{},{},"transition back to either the Initialized"]},{"entry":[{},{},{},{},{},"or Key Initialized state depending on"]},{"entry":[{},{},{},{},{},"whether or not keys have been"]},{"entry":[{},{},{},{},{},"successfully formatted into a"]},{"entry":[{},{},{},{},{},"DESTable or DES3Table struct."]},{"entry":["7","Key","Generic","Operation","Operation","The Key Initialized"]},{"entry":[{},"Initialized","cryptographic","specific error","Error","state is entered"]},{"entry":[{},{},"operation failure","message",{},"after keys are"]},{"entry":[{},{},{},{},{},"formatted into a"]},{"entry":[{},{},{},{},{},"DESTable or DES3Table"]},{"entry":[{},{},{},{},{},"struct with"]},{"entry":[{},{},{},{},{},"FipsDesKey(),"]},{"entry":[{},{},{},{},{},"Fips3Des3Key()"]},{"entry":["8","Operation","Automatic","No output","Key","(see comment for"]},{"entry":[{},"Error","transition when",{},"Initialized","State 6 above)"]},{"entry":[{},{},"keys have already"]},{"entry":[{},{},"been initialized"]},{"entry":["9","Key","Generic","NOERROR","Initialized","(see comment for"]},{"entry":[{},"Initialized","cryptographic",{},{},"State 7 above)"]},{"entry":[{},{},"operation (i.e."]},{"entry":[{},{},"FipsDes(),"]},{"entry":[{},{},"Fips3Des(), or"]},{"entry":[{},{},"FipsCBC ())"]},{"entry":[{},{},"completed"]},{"entry":["10","Initialized","Automatic","NOERROR","Power","(see comment for"]},{"entry":[{},{},"transition when",{},"Down","States 4 and 5 above)"]},{"entry":[{},{},"Windows XP"]},{"entry":[{},{},"Kernel calls the"]},{"entry":[{},{},"FIPS.SYS"]},{"entry":[{},{},"driver's unload"]},{"entry":[{},{},"function"]},{"entry":["11","Power",{},{},{},"The Power Down state is entered"]},{"entry":[{},"Down",{},{},{},"when OS calls the FIPS.SYS driver's"]},{"entry":[{},{},{},{},{},"unload function which was set in"]},{"entry":[{},{},{},{},{},"DriverUnload field of the"]},{"entry":[{},{},{},{},{},"DriverObject representing FIPS.SYS"]},{"entry":[{},{},{},{},{},"during the Power Up state."]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 4","b":["84","90","74","74","82","86","50","60","60","88","68","64","88"]},"While a file is open, the decrypted FEK  is saved by the file system  in association with the file . As shown in , with NTFS , stream control blocks  maintain file information for each open file, and each stream control block (e.g., ) corresponding to an encrypted file has a key context (e.g., ) pointed to thereby. The key context  maintains the information necessary to encrypt and decrypt a file during writes and reads to the disk, respectively. As described in more detail below, the FEK  is used to decrypt file data reads on a block-by-block basis, i.e., random access to a large file will decrypt only the specific blocks read from disk for that file. The entire file is not necessarily decrypted.","File Recovery",{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIG. 5","FIG. 4"],"b":["90","60","82","74","82","90","92","86","90","74","74","82"]},"Regardless of whether it is a normal user opening or an opening for a recovery, once a key is found that is in the current context, (CryptoAPI  maintains a set of keys for each user), then the key is verified by comparing it to known information decrypted with that key. More particularly, at the time of encryption, the user's public key is appended to the FEK of the file, which is then encrypted with the FEK  as known information. If the found key decrypts the stored information to equal the known information, then the key is verified. This scheme provides a strong encryption technology as it provides one of many possible recovery agents with the ability to recover the file, thereby providing organizations with redundancy and flexibility in implementing recovery procedures.","EFS thus provides a built-in data recovery support, referred to as the \u201cRecovery Policy\u201d. The preferred system enforces configuration of recovery keys, and is intentionally limited to only being usable when the system is configured with one or more recovery keys. The file recovery operation only divulges the randomly generated file encryption key , and not the user's or any other recovery agent's private key. As can be appreciated, this is ideal for most business environments where an organization may need to recover data that was encrypted by an employee after an employee leaves the organization or loses his or her key.","The recovery policy, also known as the EFS policy, may be defined at the domain controller of a Windows NT Domain, whereby the policy is enforced at all machines in that domain. The policy contains the public keys of the recovery agents. As a result, the recovery policy is only under the control of the domain administrators, thereby providing controls on who can recover the data. To enable the use of encryption features on a standalone Windows NT workstation in a home environment, as an added feature, EFS automatically generates recovery keys and saves them as machine keys, thereby reducing the administrative overhead for an average user.","In a domain, the recovery policy is sent to each of the machines on the domain, whereby even when not connected, the local machine maintains the policy therewith in a local security authority, LSA. In this manner, EFS can operate to encrypt files when not connected. Each time a machine joins the domain, or if the recovery policy changes, the policy is propagated to the machines in the domain when they are connected. Moreover, every time a file is opened, the metadata for that file is compared against the recovery policy to see if the recovery policy has changed, and if so, the metadata is updated with the FEK encrypted with the new user and\/or recovery agent public key information. Safeguards, including hashes (MD5), are used to ensure that the recovery policy is not changed, such as by a malicious user.","For example, a malicious user may wish to make a file unrecoverable by changing the DRF . To detect this, using a section of the DRF , a cryptography hash (MD5) is created, signed with the FEK  of the file, and stored with the DRF . Later, when the file is opened and the FEK  is obtained, the section is decrypted with the FEK  to see if the information stored in the DRF  matches. If so, the stored recovery policy is proper, otherwise the recovery policy is replaced with the current recovery policy of the domain.","If a machine is not part of a domain, it still has a local recovery policy, but the recover keys are generated by and kept on the machine as describe above. In this manner, every file encrypted under EFS always has some recovery policy. If the machine later becomes part of a domain, the local recovery policy is wiped out and replaced with the domain policy.","General Operation","Turning to an explanation of the operation of the invention and beginning with the flow diagram of , when a application  wishes to create or open an encrypted file, the application  first calls an appropriate API  requesting a new file be created in an encrypted directory, or an encrypted file be opened.","As shown in , once a create or open request is received, the I\/O subsystem  arranges for passing the request as an IRP to the appropriate file system, e.g., NTFS , at steps \u2013. However, as described above, the IRP is first received by the EFS linked library  at step  of , which recognizes the IRP as specifying an open\/create operation.","The EFS linked library  begins the EFSCreateFile operation by performing some preprocessing as shown in . As represented by step  of , the EFS linked library  allocates an EFS Context Block for this file, and adds it to the EFS context block chain  (). Note that the EFS context block is created for each new file, even though the file may not be encrypted, because the EFS linked library  does not know at this time whether the file is already encrypted or is to be encrypted. The EFS context block includes status information, which is initialized with \u201cNo processing needed,\u201d an IRP pointer pointing to the current file object, and an EFS metadata stream initialized to NULL. Lastly, at step , the IRP is passed to NTFS .","As shown in step  of , when NTFS  receives the IRP from the EFS linked library  and recognizes it as an NTFS  Create packet, NTFS  handles the create\/open IRP.  generally shows how NTFS  handles the IRP. First, as represented by step , information in the IRP is tested to determine if an existing stream is to be opened, or a new stream on file\/directory is to be created. If an existing stream is to be opened, NTFS  opens the stream at step . At step , NTFS  determines if the file or its directory is encrypted, and if so, at step  calls the FSRTL  open\/create callout, described below with reference to .","Conversely, if a new stream was created as determined by step , NTFS  next determines at step  if the parent directory is encrypted. If the parent is encrypted, at step , NTFS  calls the FSRTL  open\/create callout, as described below. Note that if neither the parent is determined to be encrypted (step ) nor the file or directory encrypted (step ), NTFS  does not make the FSRTL  callout, whereby NTFS  simply performs any tasks it needs to at step  before returning to the EFS linked library .","The steps of the EFS create\/open FSRTL  callout are generally represented in , wherein the FSRTL  callout begins by first examining the type of access requested by the user (step ). If an existing stream on the file or directory is opened without read, write, append or execute (R\/W\/A\/E) access, the call is simply succeeded, as no encryption\/decryption is needed, e.g., the user wants to read attributes, and attributes are not encrypted. Otherwise, at step , the FSRTL  searches the EFS context chain  for the appropriate file object corresponding to this file (allocated at step  of ). The Create\/Open callout performs operations based on the type of file\/directory, as set forth below.","If the type of file is an existing file (step ), then FSRTL  was called because either a new stream was created or an existing stream was opened. If so, the user needs to be verified, and the callout process continues to step  of . At step , the EFS metadata from the file is read using an (NtOfs) API. Then, at step , the metadata that was read is set up in the context block and the status on the block changed to indicate \u201cUser Verification Required.\u201d Then the key context  is checked at step , and if the NTFS key context  is NULL, then a key is needed. If the key context  is NULL (step ), this file was not read, and thus there is no possibility that decrypted file data is present in the cache memory. As a result, the context block is set to indicate \u201cNo Cache Check Needed\u201d at step . Lastly, if a new stream was created as determined by step , the context block is set to indicate \u201cTurn On Encryption Bit\u201d at step .","If instead the type of file is a new file (step  of ), a new FEK and EFS metadata are needed. First, at step , the EFS metadata is read from the parent directory using NtOfs API. Step  sets up the metadata that was just read in the context block , and changes the status on the block to \u201cNew File Efs Required,\u201d \u201cTurn On The Encryption Bit\u201d (step ) and \u201cNo Cache Check Needed (step ).\u201d","If instead the file object type indicates a new directory (step ), only new EFS metadata is needed. There is no FEK in this case, because at present, streams in the directory are not encrypted. Accordingly, the EFS metadata from the parent directory is read at step  (using NtOfs API). Then, at step , the metadata that was just read is set up in the context block and the status on the block changed to \u201cNew Directory Efs Required,\u201d \u201cNo Cache Check Needed\u201d (step ) and \u201cTurn On The Encryption Bit\u201d (step ).","Lastly, if the type represents an existing directory (step ), either a new stream was created or an existing stream was opened. At present, no action is taken because the directory data streams are not encrypted. However, it can be readily appreciated that directory streams also may be encrypted in the same manner that file data streams are encrypted using the encrypting file system of the present invention.","As shown in , step , the callout returns to NTFS , whereby NTFS  can perform any of its own operations. The file\/create process returns to step  () the EFS filter EFS linked library  for post-processing.","The EFS Create\/Open File post-processing process is represented in . Beginning at step  of , the context block is evaluated for \u201cNo Cache Check Required\u201d status. If a cache check is required, the process branches to step  where the caller's security context along with the EFS ID for the file stored in the EFS stream are used by the EFS cache to check if this file was successfully opened by the user the recent past. If so, the call is succeeded since the cache already contains the appropriate information.","If not in the cache, step  checks if read data, write data, append data or execute access is requested. If none of these are requested, but a new stream was created as determined by step , and the context block indicates \u201cTurn On Encryption Bit\u201d status (STEP ), the EFS data stream is not needed and is released. Only the encryption bit on the stream needs to be turned on, which is performed at step . The post processing is complete and the overall process returns to step  of .","However, if none of the situations identified above with respect to  are satisfied, different operations need to be performed based on the status information, which is tested beginning at step  of . First, if the status in the context block indicates that user verification is required at step , the EFS linked library  impersonates the security context (provided in the IRP) at step , and at step  calls the EFS service , passing the EFS metadata to request the FEK.","At step , the EFS service  responds to the call by impersonating the context, and using information in the EFS metadata, looks up the user's private key to decrypt the FEK. The EFS service  may also update the EFS metadata (step ) if the user's key has been updated or any recovery keys are updated as determined by step . In any event, at step , the EFS service  verifies the integrity of the FEK  and returns all information back to the EFS linked library . More particularly, to verify integrity, a key integrity block is constructed as follows:\n\n[F(FEK, Puk), FEK]Puk\n\nwhere\n\n","Consequently, when it is believed that a valid FEK has been decrypted with a user's public key, the block above is computed with the present information and compared to the block stored on the file. If they match, the key integrity is verified.","Alternatively, if the status did not indicate that user verification was required (step ), but instead indicated that a new file FEK was required, step  branches to step  of . At step , the EFS linked library  impersonates the securing context in the IRP, and at step  calls the EFS service  passing the parent directory's EFS metadata, requesting a new FEK and EFS metadata. At step , the EFS service  impersonates the context and generates a random FEK . If the user does not have a key as determined by step , at step , the EFS service  auto-generates a key pair for the user. Lastly, step  creates the EFS metadata stream with the FEK  encrypted under the user's public key and the recovery agent's public keys. The EFS service  also encrypts the FEK  using all the public keys in the parent directory's EFS metadata so that users who are allowed access to the parent directory also have access to the file (provided NTFS  access control lists allow such access).","If neither step  nor  was satisfied, the post-process branches to step  to determine if the EFS context indicated that a new directory FEK is required. If so, the post-process branches to step  of  wherein the EFS linked library  impersonates the securing context in the IRP. Step  calls the EFS service , passing the parent directory's EFS metadata and requesting new EFs metadata. Note that no FEK is needed, as directory streams are not encrypted at this time. However, in the future, directory streams will also encrypted in the same manner that file streams are encrypted in accordance with the present invention.","In any event, at step , the EFS service  impersonates the context, and, using an empty FEK, creates the EFS metadata stream. Step  checks to see if the user does not have a key, and if not, at step , the EFS service  auto-generates a key pair for the user. Then, at step , the empty FEK is encrypted under the user's public key and the recovery agent's public keys, and the FEK is also encrypted using all the public keys in the parent directory's EFS metadata so that users allowed access to the parent directory also have access to the file if the access control lists allow such access.","Ultimately, regardless of which of the three statuses were in the context, the post-process winds up at step  of  to issue an appropriate FSCTL. Two such FSCTL calls are available, FSCTLSETENCRYPTION and FSCTLENCRYPTIONFSCTLIO. FSCTLSETENCRYPTION tells NTFS  to turn on or turn off the encryption bit for a stream. The FSCTLENCRYPTIONFSCTLIO is a miscellaneous FSCTL used for performing a number of operations, described below.","To this end, the FSCTLs are accompanied by a data structure , as shown in . The data structure includes a public code so that NTFS  can differentiate between the two types of FSCTL calls, along with an EFS subcode to more particularly define the operation for the EFS linked library  and\/or the EFS service . The data structure also includes EFS data specifying either FEK information () or file handle information (), and, at times, EFS metadata. For purposes of security, the EFS subcode and EFS data fields are encrypted with the session key established when the EFS service  is initialized, as described above.","In use, the FSCTLSETENCRYPTION may be issued, for example, to turn on the encryption bit for a file when that file is first put into an encrypted directory. The subcode indicates whether the encryption bit should be turned on or off. For such an operation, the FEK  is already known, and thus as shown in , the EFS data includes the FEK, and the FEK encrypted with the session key. Note that all but the public code is encrypted with the session code. To verify the integrity and the source of the data structure , the encrypted portion of the data structure is decrypted. Then, the encrypted FEK is decrypted and compared with the other FEK, and if equal, the structure is verified. The EFS stream, if available may also be compared with the EFS metadata, if otherwise known. Since the FEK is not always known, a similar verification is performed using the session key and the file handle as shown in . A repeated file handle is actually used in the appropriate fields () so as to equal a length of eight bytes.","The callouts to the FSRTL  (via FileSystemControl or FileSystemControl, and passed through NTFS ) are used to overwrite attributes or set attributes depending on an accompanying subcode. Two bits of the subcode represent the overwrite attributes or set attributes operations. Note that when the EFS stream is to be written for a new file, FILESYSTEMCONTROL is used with the FSRTL  callout to also turn on the encryption bit (as performed by NTFS , described above). Alternatively, FILESYSTEMCONTROL is used with the callout when no change to the encryption bit is needed, for example, if the user has simply changed user keys.","Regardless which is used, one bit of the subcode represents the operation \u201cSet EFS KeyBlob,\u201d which indicates to the FSRTL  that new encryption key information is available and needs to be entered into the appropriate key context. Another bit represents the operation \u201cWrite EFS Stream.\u201d Write EFS Stream is issued by the EFS service , such as when the user or recovery agent has changed a public key and the file metadata needs to be rewritten with the EFS metadata in the data structure . One other subcode represents \u201cGet EFS stream,\u201d which results in the current EFS attributes for a file being written into the EFS field, such as when a user wants to export a stream or wants to know a key name.","Thus, returning to , step  tests if the only requirement is to turn on the encryption bit, and if so, issues the FSCTLSETENCRYPTION control at step  with the subcode indicating that the bit should be turned on. Of course, the other EFS data including the session key, handle, handle and encrypted copy of same is also in the data structure  for verification purposes. In any event, the FSCTL reaches NTFS , which turns around and sets the encryption bit on the stream (and on the file if not already on) and calls an FSRTL callout to pass the information to the FSRTL .","If step  is not satisfied, the ENCRYPTIONFSCTLIO FSCTL needs to be called with an appropriate subcode in the data structure . Thus, if the status is \u201cUser Verification Required\u201d (step ), the subcode is set to KeyBlob at step . Next, if the metadata has been updated as determined by step , step  sets the Write EFS Stream subcode bit before the call at step . Otherwise, if the status is \u201cNew File FEK Required\u201d (step ), the subcode is set to KeyBlob and Write EFS Stream at step , i.e., both bits are set. If neither of these, then the status is \u201cNew Directory FEK Required,\u201d and the subcode is set to Write EFS Stream at step , i.e., only the other bit is set. The FSCTL is issued at step .","Read and Write","Turning to an explanation of the read and write operations of the present invention, as first shown in , when an application  requests to read some data from the open file (step ), the I\/O subsystem  receives the read request and passes it as an IRP to the appropriate file system , e.g., NTFS. First, however, the IRP is received by the EFS linked library , which recognizes the IRP as corresponding to a read request, and as a result, directly hands the IRP to NTFS  at step . At step , NTFS  reads the encrypted data from disk into a buffer just as it would read the plaintext data for any other file. However, for the encrypted file, the file system  recognizes at step  that this file is encrypted, and at step  remembers and gets the key context that the encryption EFS linked library  earlier had returned from the create\/open callback. At step , NTFS  uses the AfterReadProcess callback and provides the registered function with the data and enough information, including the encryption context, to decrypt the data. In general, the information includes the offset into the file, a pointer to the read buffer, the length to read, and they key. At step , the encryption EFS linked library  decrypts the data and returns it to the file system , whereby at step  the file system  then returns this plaintext through the I\/O subsystem  to the application in the normal way. Note that however that certain NTFS  internal metadata streams containing file indexing and other such information are not encrypted. NTFS  recognizes these streams at step , and temporarily skips over steps \u2013 for these particular streams.","As shown in , when an application  requests to write data to the open file (step ), the I\/O subsystem  receives the write request and passes it as an IRP to the appropriate file system , e.g., NTFS. First, however, the IRP is received by the EFS linked library , which recognizes the IRP as corresponding to a write request, and as a result, directly hands the IRP to NTFS  at step . At step , NTFS  copies the write data into a separate buffer so that no changes can be made to the data that is to be written. For the encrypted file, the file system  recognizes at step  that this file is encrypted, and at step  remembers and gets the key context that the encryption EFS linked library  earlier had returned from the create\/open callback. At step , NTFS  uses the BeforeWriteProcess callback and provides the function with the data and enough information, including the encryption context, to encrypt the data. At step , the encryption EFS linked library  encrypts the data and returns it to NTFS , whereby at step  the file system  then writes the now-encrypted data in the separate buffer to the non-volatile storage  in the normal way, i.e., as if it was plaintext data for any other file. Again note that the NTFS  internal metadata streams containing the file indexing and other such information are not to be encrypted. NTFS  recognizes these streams at step , and temporarily skips over steps \u2013 for these particular streams.","Encrypt and Decrypt File APIs","EFS also provides APIS  to facilitate encryption and decryption of stored files. The Win32 EncryptFile API is used to encrypt a plaintext file\/directory. AS shown in , with this API, the application  (user) provides the name of the file to encrypt at step , and this call translates into a call to the EFS service  to do the operation. At step , the EFS service  opens the file on the user's behalf, makes a backup copy for crash recovery purposes and at step  marks it for encryption by issuing the SETENCRYPT file control (FSCTL). At step , the EFS service  then reads data from each stream in the copy and writes the data back to the original file at step . Note that during the write operation, because the encryption bit is set, the data is automatically encrypted before being written to the disk. The process is repeated via step  until all data streams are written. If this call completes successfully (step ), the backup is deleted at step , otherwise the original file is restored at step  and the call is failed. In the case of a directory, the directory is simply marked encrypted, as there is no data to encrypt. Note that, as described above, NTFS  internal metadata streams are not encrypted.","A WIN32 DecryptFile API is also provided by the EFS service , and is the converse operation of the encrypt file\/directory operation. As shown in , at steps \u2013, the EFS service  is provided with the file name and opens the file on the user's behalf. Steps \u2013 read the data from all streams and write those streams into a copy, which is plaintext, as decryption happens transparently. At step , the service then issues the decrypt file control to delete the metadata and remove the encryption attribute. Then, as shown by steps \u2013, the API writes back all the data streams from the copy over the original, which are written in plaintext. If this completes successfully, the copy is deleted at step , otherwise the original is restored at step . In the case of a directory, the directory is simply marked as decrypted to delete the metadata and the attribute, as there is no data to decrypt.","As can be appreciated, EFS file encryption is supported on a per file or entire directory basis (although NTFS  operates per stream). Directory encryption is transparently enforced, i.e., all files (or subdirectories) created in a directory marked for encryption are automatically created encrypted. Moreover, file encryption keys are per file, making them safe against move\/copy operations on the file system volume. Unlike existing application-level schemes, the file need not be decrypted before use, since, as will become apparent below, the encryption and decryption operations will be done transparently and on the fly when bytes travel to and from the disk. EFS will automatically detect the encrypted file and locate the user's key from a key store. The mechanisms of key storage are leveraged from CryptoAPI, and as a result the users will have the flexibility of storing keys on secure devices such as smart cards and\/or floppy disks.","Moreover, in keeping with the invention, EFS cooperates with the underlying file system  (e.g., NTFS), whereby EFS facilitates the writing (by a properly developed application program) of encrypted temporary files. With such an application program, when temporary files are created, the attributes from the original file are copied to the temporary file making the temporary copy also encrypted. In addition, the EFS linked library  is a Windows NT kernel mode driver, which uses the non-paged pool to store file encryption key, thereby ensuring that the key never makes it to the page file.","The EFS architecture allows file sharing between any number of people by simple use of the public keys of those people. Each user can then independently decrypt the file using their private keys. Users can be easily added (if they have a configured public key pair) or removed from the clique of sharers.","In a stand-alone configuration, EFS allows users to start encrypting\/decrypting files with no administrative effort to set up a key, i.e., EFS supports auto-generation of a key for the user if one is not configured. With a domain configuration, an administrator only needs to set up a domain policy once for EFS to become operational. Lastly, EFS will also support encryption\/decryption on remote files stored on file servers. However, the data once read from the disk is decrypted on the fly and hence may travel in plaintext on the wire if the file sharing protocol does not implement communication encryption, i.e., EFS addresses storage encryption, not communication encryption. Communication protocols can be used to provide such encryption.","As can be seen from the foregoing detailed description, there is provided a system and method for encrypting data, the system and method integrated into a file system such that encryption and decryption work transparently to legitimate users. The system and method provide for the ability to share sensitive data among more than one legitimate user, and adding and removing access for a user is simple. A strong cryptographic solution is provided that addresses encrypted data recovery, such as when users lose keys. The system and method are flexible and extensible.","While the invention is susceptible to various modifications and alternative constructions, a certain illustrated embodiment thereof is shown in the drawings and has been described above in detail. It should be understood, however, that there is no intention to limit the invention to the specific form disclosed, but on the contrary, the intention is to cover all modifications, alternative constructions, and equivalents falling within the spirit and scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 8 and 9"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 13\u201314"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 15\u201319"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 23"}]},"DETDESC":[{},{}]}
