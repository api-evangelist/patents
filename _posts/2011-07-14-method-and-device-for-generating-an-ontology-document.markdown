---
title: Method and device for generating an ontology document
abstract: A computer-implemented method is provided for generating an ontology document, the method comprising inputting a domain description including information about items in the domain and relationships between the items; accessing a data structure and an operation structure, wherein the data structure is a domain-independent model of items and relationships between items, the data structure comprising at least progenitor items each able to contain only progeny items created by the progenitor item as a consequence of the progenitor item accepting an operation from the operation structure invoked against it, the operation structure also being domain-independent; and applying the data structure and the operation structure to the domain description to generate an ontology document for use in producing a software artifact.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08898103&OS=08898103&RS=08898103
owner: Fujitsu Limited
number: 08898103
owner_city: Kawasaki
owner_country: JP
publication_date: 20110714
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":"CROSS REFERENCE TO RELATED APPLICATIONS","p":["This application is a continuation of U.S. Ser. No. 13\/095,029, filed on Apr. 27, 2011, now abandoned which claims priority from European Patent Application No. 10161690.2 filed on Apr. 30, 2010 in the European Intellectual Property Office, the entire disclosures of which are incorporated herein by reference.","Recent progress towards a \u2018web for machines\u2019 and an aspect web 2.0 means that many websites or domains offer access to exposed data and services via an interface such as an API (Application Programming Interface). The consumers of the resulting web applications are machines, rather than humans driving an application through a web browser.","APIs and API support has also enabled the combination of data and services from more than one source to create derived services, mashups and desktop versions of web applications. Additionally, HTTP-based APIs have evolved as a means to support computing requirements (and not primarily to complement an existing website), for example, APIs referred to as Infrastructure-as-a-Service (IaaS) Cloud APIs. Infrastructure-as-a-Service is a mechanism by which a client computer or client network can access external or third-party computing infrastructure via the web for the performance of, for instance, processing and storage tasks.","REST (Representational State Transfer) is an architectural style which governs the proper behaviour of participants in the web for machines. REST sets out constraints for system architectures to which conforming is described as being \u2018RESTful\u2019, the first of which is that the architecture has a client-server arrangement, with clients being separated from servers by a uniform interface. There are four guiding principles of the interface between client and server, and an interface developed in accordance with these principles can be described as \u2018RESTful\u2019. For example, an API can be written in accordance with the REST guiding principles for interfaces, and would hence be described as a \u2018RESTful API\u2019. HTTP as a protocol can be used in a RESTful manner, and RESTful HTTP is suitable for the web for machines. RESTful APIs are popular for a number of key reasons: there is simplicity of the basic protocol built on a proven foundation with solid architectural principles, and the result is approachable and usable by web developers.","In brief, the REST architectural style describes six constraints (one of the six is optional) on a system architecture are as follows:\n\n","The guiding principles for the uniform interface are briefly summarised below:\n\n","A positive aspect of the REST architectural style is that it links well with information models, an information model being a formalised description of items in a domain and relationships between those items. The operations allowed in a RESTful API are constrained (fixed), this avoids the unwanted side effects of poor programming behaviour which would ordinarily lead to problems in linking an interface with an information model.","In fact, a RESTful API for a particular domain may be defined purely in terms of the information model for the domain, and by how this model then appears inside different data formats, the data formats being wire level (low level or implementation level) manifestations of the information model. Unfortunately, APIs currently in use show disparities regarding their approach to information modelling, how this appears inside data formats, and how the semantics of HTTP are brought to use in the specific domain of the API(s) in question. This lack of consistency is problematic since potential benefits of a RESTful protocols are lost, for example, the potential for re-usable toolkits (eg standard code) and generic client agents (equivalent to a browser).","The information model for a particular domain may be captured in an ontology document presented in, for example, the OWL (Web Ontology Language) format. An ontology document can then be used as the basis for an API or an interface specification.","Currently, the approach taken by a service developer writing an API, and potentially following it up with a particular implementation of the API, may be to define a modified or adapted version of a language specific to the domain for which the API is being produced and suitable for a specific data format, for example the language may be based on JSON or XML. This data format-specific approach is problematic because different data formats operate in accordance with different processing rules. The realisation of a generic client able to access all APIs using a common set of processing rules becomes impossible, as custom code is required for each domain and each data format.","Embodiments of the present invention provide a computer-implemented method for generating an ontology document indicating a structure of classes of items within a domain, which items belong to which class, and which operations each class supports, the method comprising inputting a domain description including information about items in the domain and relationships between the items; accessing a data structure and an operation structure, wherein the data structure is a domain-independent model of items and relationships between items for characterising items described in the domain description into classes, the data structure comprising at least progenitor items as a class of items each able to contain only progeny items created by the progenitor item as a consequence of the progenitor item accepting an operation from the operation structure invoked against it, and the operation structure including a domain-independent list of operations which, when applied to a domain description, define processing rules for the classes of items; and applying the data structure and the operation structure to the domain description to generate an ontology document for use in producing a software artefact.","The inventors of the present invention have come to the surprising realisation that mere automation of a programmer's activity is not sufficient to improve runtime reliability of interfaces between a client and a server, and that a radical reformulation of the approach to producing ontology documents modelling the domain can be used for this purpose. The method of the present invention embodies this new approach, applying a core domain-independent data structure and operation structure to a domain description to generate an ontology document. Breaking up the concept of an ontology into domain-dependent and domain-independent structures and descriptions ensures a consistency of approach across domains, and allows assumptions to be made in the domain-independent structures which can be applied to an ontology document for any domain.","An ontology document is not restricted by format, and may include information indicating the structure of classes of items within a domain, which individual items belong to which class, and which operations, for example, which operations each class supports. An ontology document may be written in OWL (Web Ontology Language). Alternatively, the ontology document may not be formally presented as a single document, but may be any collection of pieces of information contributing to a representation of the ontology of a domain.","The ontology document produced by methods embodying the present invention is suitable for use in producing software artefacts. A software artefact is either a computer program, or piece of code for a computer program, or a protocol or specification which can be directly used for producing software code or computer programs. A software artefact may include one or more of the following: a client application, an API, a client implementation, a server-side implementation, a web page, an application skeleton, or in certain embodiments, an interface specification.","The term \u2018interface specification\u2019 may include a protocol for accessing services and exposed data in a domain. Data and services may be exposed insofar as representations of items and resources in the domain are available to client applications or peer server applications acting in the client role re server-side mashups. Alternatively or additionally, data and services in a domain or complete portfolio services may be exposed insofar as they are manageable by a client application. Depending on the embodiment, the term \u2018interface specification\u2019 may include an association with a particular domain, but does not associate the interface with any particular client application or restrict the interface to a particular implementation of the specification (such as an API). An interface specification may for example include any or all of the following:\n\n","The term \u2018interface\u2019 may include an interface between a client and a server.","The term \u2018instance of a class\u2019 may include an item which exists in the domain at runtime and conforms to the template for that class, the template being defined by applying the data structure and operation structure to the domain description, so each instance \u2018belongs\u2019 to a class. Similarly, an \u2018instance of a subclass\u2019 may include an instance which belongs to the subclass and to the class from which the subclass stems. A resource may include a generic class of item which has links to other resources, has fields, and can optionally be deleted.","The domain description may at least include information about items in the domain and relationships between the items, and may include a domain ontology. In some embodiments, the domain description contains sufficient information presented in a manner which allows an ontology document to be generated containing a complete or substantially complete representation of available classes in the domain and the methods they support. The ontology document will therefore allow at least a partial interface specification to be derived (inferred, deduced or to surface) as a software artefact from the ontology document. For example, the domain description may be presented in such a way that the containment hierarchy of resources belonging to each class and subclass present in the domain description can be represented in the ontology document.","The term \u2018data structure\u2019, referring to the data structure optionally provided within the processing engine, or which is accessed in generating the ontology document, may include a domain-independent model of items and relationships between items, and could be considered to include a domain-independent data model or a core data model. The term \u2018data structure\u2019 may include \u2018data structure ontology\u2019. The data structure may provide core, domain-independent classes such as Postable, Collection, Shareable, State, Deletable, and Manageable. When the data structure is applied to the data description in the processing engine the resources in the domain can be characterised as instances of domain-independent classes, or sub-classes stemming from those domain-independent classes and hence inheriting properties of the domain-independent classes.","The term \u2018operation structure\u2019, referring to the operation structure provided within the processing engine, or which is accessed in generating the ontology document, may include a domain-independent list of operations which, when they are applied to the domain description, define processing rules to tell the server how to handle operations performed on resources belonging to certain classes, wherein it is possible that these processing rules will vary based on a state of the resource. The term \u2018operation structure\u2019 may include \u2018operational ontology\u2019. The operation structure could be considered to be an operation model.","The operation structure and data structure together can be referred to as a domain-independent information model. Once the operation structure and data structure have been applied to the domain description, a domain-specific information model, or ontology document, may be obtained, and this is suitable for forming the basis of a software artefact such as an interface specification.","The term \u2018resource\u2019 may include items of the class \u2018Resource\u2019, a generic class of item which has links to other resources, has fields, and can optionally be deleted. The term \u2018container\u2019 may include items of the class \u2018Container\u2019, a class which extends (is a subclass of) the class \u2018Resource\u2019, and is able to contain other resources. A delete operation on a Container removes it and all resources contained therein. The term \u2018progenitor\u2019 may include items of the class \u2018Progenitor\u2019, a class which extends (is a subclass of) the class Container, and is able to create Progeny items, which are themselves a subclass of Resource, within an instance of Progenitor, for example as a consequence of a \u2018post\u2019 operation invoked against (performed on) an instance of the Progenitor class. The class Progenitor is part of the data structure and is a domain-independent concept that can be applied to a domain description to identify through inference and other techniques which resources in a domain can be classified as progenitors when producing an application specification.","Advantageously, producing an ontology document based on a data structure including progenitor items results in an ontology document which can form the basis of a software artefact (such as an application specification) in which problems resulting from misuse of operational terminology is avoided. For example, misuse of HTTP operations GET and PUT can lead to APIs or other software artefacts which do not follow common processing rules and hence require specialist client applications to access exposed data and services in the domain for which the API is produced. The behaviour of a progenitor item (part of the data structure) in response to a POST operation (part of the operation structure) is self-evident from the nature of the progenitor item itself (being a container in which new items are added by creation). The parts of the domain now classified as progenitors and having well-defined behaviour in response to the POST operation are parts of the domain which would have been susceptible to misuse of the GET and PUT operations by a developer creating an API for the domain. Runtime reliability of software artefacts such as interfaces implementing an interface specification based on an ontology document produced via the method of the present invention is improved in relation to prior interfaces.","Optionally, in methods embodying the present invention, the domain description is input to a processing engine, the data structure and operation structure are accessed by the processing engine, the data structure and operation structure are applied to the domain description in the processing engine, and the ontology document is generated by the processing engine.","The processing engine may be realised as a piece of software which, when run on a computing device having a processor, causes the computing device to perform the steps of accepting the domain description as an input, applying the data structure and operation structure to the domain description, and generating the interface specification as an output. Alternatively, the processing engine may be a computing device operable to accept the domain description as an input and, having applied the data structure and operation structure to the domain description, to generate the interface specification as an output. Alternatively, the processing engine in this aspect may be capable of performing as the constrained editor as described in more detail hereinafter.","Advantageously, providing a method whereby a processing engine is used to apply the data structure and operation structure to a domain description can improve consistency of approach in producing ontology documents.","As an implementation detail which may vary between embodiments, each instance of progenitor item is only able to contain progeny items that are instances of a particular class of item.","The membership of a progenitor item may be further restricted to particular sub-classes of a certain class, or individuals within a class or subclass. Individuals in this sense being types of items within a certain class. Advantageously, restricting the membership of a progenitor item in this way simplifies the processing rules that are required to handle the progenitor item so that the ontology document provides a representation of a domain in which the processing rules to be used in running a software artefact such as an interface implementing an interface specification based on the ontology document are simple and well-defined.","Methods embodying the present invention may additionally include generating in a processing engine, and outputting from the processing engine, a URI template in accordance with the ontology document, whereby the URI template can be used to ensure that each resource in the domain at runtime is dereferencable via an HTTP URI.","While formally opaque, URI (Universal Resource Identifier) templates are useful since they ensure that URIs used in a software artefact such as an implementation of an interface specification based on the ontology document reflect the containment hierarchy captured in the ontology document and derived from the domain description. The processing engine may be the same processing engine as previously described. It may be a constrained editor with additional functionality able to function as a combination of constrained editor and transformation engine as described in more detail hereinafter.","In certain embodiments, a full set of URI templates will be generated, so that a URI template for each class of item in the domain is made available.","Optionally, the ontology document defines a class of manageable container, instances of the manageable container class containing a states progenitor item, the states progenitor item being a progenitor item able to contain only progeny items that are instances of a state class of items used for indicating one of a predefined list of operating states of the class of manageable container.","An ontology document defining manageable containers in this way provides a mechanism by which a client can manage the state of items in the domain by posting simple data objects (new state items) to the states progenitor item.","For example, a progenitor \u2018servers\u2019 in a virtual system domain may be able to create a progeny item \u2018server\u2019 as a consequence of a client performing a POST operation. In this case, the acceptance constraints are that for the operation POST, a progeny item server is created, and this remains true regardless of environmental variables. In another example, a manageable resource may have a progenitor \u2018states\u2019, able to create a new state resource as a progeny item when a POST operation specifying a subclass of the class State is invoked against it. It may be that when the states progenitor contains the state \u2018off\u2019, it will only accept a POST operation specifying the resource \u2018on\u2019, which is a subclass of the class State. By making the constraints available to a client tool the interface specification effectively provides a way in which the acceptance constraints can be advertised to a client tool, this may be in response to a query or otherwise. For example, a client tool may identify that a resource in the domain being accessed via an API is manageable, and submit a query to the server to find out what state items can be created in a states progenitor to modify the state of the manageable resource.","As set out above, the constrained editor may alternatively be automated as a function of a processing engine.","Optionally, the data structure and operation structure are accessed via a constrained editor, the constrained editor being an editing environment for constraining the user into inputting the domain description in such a way that the data structure and operation structure are applied to the domain description.","The constrained editor may include a graphical interface to reduce the technical expertise required to produce an ontology document. The constrained editor, which when realised as a piece of software may itself have been derived using the methods described herein, may constrain the actions of a user by allowing an ontology representation to be built up in a graphical format, such as a graph or diagram or map, in which at any stage, the only allowable additions to the ontology representation are those which are consistent with the data structure and operation structure. Furthermore, the constrained editor may review the ontology representation to ensure consistency with the data structure and operation structure, whether continually, intermittently, or at the request of the user. Inputting may include entering domain description information to a computer terminal hosting the constrained editor (or the constrained editor may be a web application or device), and may include producing the domain description.","Embodiments may be provided in which a software artefact produced using the ontology document is consistent with principles of interfaces in the REST architectural style. The REST architectural style for distributed hypermedia systems is favoured in web development for its clear division of the role of client and server which governs the proper behaviour of participants in the web. Whilst the REST architectural style is desirable, producing interfaces between client and server which are consistent with the style is time-consuming and error-prone. The reformulation of approach to deriving an ontology document of the present invention provides a method in which the data structure and operation structure can themselves ensure that the ontology document is suitable for use in generating an interface specification resulting in interfaces compliant with the REST architectural style, or other RESTful software artefacts. The user need not be aware of the REST constraints and style, but can generate an ontology document for use in producing a REST-compliant specification merely by adhering to the data structure and operation structure.","By making certain assumptions at the domain-independent level in the data structure and operation structure, the assumptions (such as processing rules for combinations of a certain operation performed on a certain class of item) carry across all software artefacts that have been created using the method of the present invention. The data structure and operation structure define allowable operations and a way of representing resources within a domain that is consistent with the REST architecture style and hence results in RESTful APIs being produced. The method according to the present invention provides a systematic approach to the process of evolving and producing RESTful APIs, RESTful software artefacts, and interface specifications that ensures consistency with respect to usage of data formats and interaction semantics.","Embodiments may further comprise, in a processing engine, applying a set of rules based on the data structure and the operation structure to the ontology document to generate a software artefact. Based on the content of the ontology document produced using the method of the present invention a set of rules can be applied to infer and derive additional properties and information, such as relationships between items not explicitly stated in the ontology document, in order to produce an interface specification. It may be that the entire process of applying the data structure and operation structure to the domain description also occurs within a processing engine, so that a single-click process enables a user to generate a software artefact from a domain description. An ontology document in this case may be realised as a plurality of pieces of ontology information to which rules are applied in generating a software artefact. Alternatively, it may be that an ontology document capturing the data structure and operation structure is a single entity which is storable and accessible by a user, and to input to a processing engine to generate a software artefact. In this aspect, the processing engine may include a transformation engine, as part of the processing engine previously defined.","Optionally, a method embodying the present invention may be a method comprising in a processing engine, applying a set of rules based on the data structure and the operation structure to an input ontology document to generate a software artefact. The ontology document may be input as a formal OWL document, or may be fed to the processing engine as a plurality of pieces of information representing the ontology of a domain. The ontology document may have been generated according to a method embodying the present invention.","Furthermore, ontology documents and interface specifications generated via a method embodying the present invention, due to the domain-independent structures being applied, can ensure a consistency of approach to dealing with different types of media, so that XML schema for handling representations of resources are not required. It is an additional effect of the methods embodying the present invention that a generic client tool can be used to interface with any domain. That is to say, a client tool for accessing exposed data and services across a range of domains can be realised which does not need specific processing rules for handling representations of resources in each domain. The domain-independent data structure and operation structure is such that a client tool can use generic language, queries, and requests for obtaining information from the domain, and can use generic processing rules for handling representations of resources in the domain.","When the generated software artefact is an interface specification, the interface specification defines an interface according to principles for interfaces in the REST architectural style.","In a particular embodiment, the domain description may be input to a computer terminal by a user, and the data structure and operation structure accessed by a program running on the computer (or being accessed remotely by the computer), and applied to the inputted domain description in a constrained editing environment. An intermediate ontology document in a specified format may then be produced, which can itself be input to a transformation engine (optionally a program run on a computer) operable to apply a set of rules (inference operations and derivation operations) to the ontology document to generate an interface specification or other software artefacts. The intermediate production of a formal ontology document could be omitted, so that the ontology document is not a formal document, but rather the product of having applied the data structure and operation structure to the domain description in a constrained editing environment. An interface specification and other outputs are made available within the constrained editing environment.","Optionally, in embodiments of the present invention, the data structure and the operation structure ensure that the software artefact generated is consistent with principles for interfaces in the REST architectural style.","The benefits of the REST architectural style are well-documented, but the coding of interfaces and interface specifications that comply with the constraints and principles of REST is time-consuming and error-prone. Embodiments of the present invention enable a user to generate an interface specification or documents for use in generating an interface specification using only domain knowledge to produce a domain description. The approach of the present invention does so in a way that user-control and flexibility in operational details for the interface can also be optimised. The domain-independent data structure and operation structure are applied to a domain description in order that an ontology document or interface specification consistent with those structures is generated and the benefits of those structures are inherent in the information model represented in the ontology document. Therefore the user is free to utilise the ontology document or interface specification in a range of applications without compromising the benefits inherent in the fundamental domain independent data structure and operation structure.","As an optional feature, the ontology document may define a class of manageable container, instances of the manageable container class containing a states progenitor item, the states progenitor item being a progenitor item able to contain only progeny items that are instances of a state class of items used for indicating one of a predefined list of operating states of the class of manageable container, so that the state of an instance of the manageable container class at runtime of a software artefact or an implementation of a software artefact is operable to be managed by adding an instance of the state class to the states progenitor item contained by the instance of the manageable container class.","Advantageously, embodiments of the present invention in which the ontology document defines manageable containers as defined above allow a client tool or application to manage the state of items at the server side using simple HTTP or equivalent operations. This approach is compliant with the principles for interfaces in the REST architectural style.","As a further optional feature, the state of the instance of the manageable container class at runtime is indicated by the most recently added instance of the state class to the states progenitor item contained by the instance of the manageable container class, so that the progeny items contained by the states progenitor item are a state history of the instance of the manageable container class.","Managing states in this way has the surprising and desirable effect that a state history is available with no additional processing or storage required. It may be that a list of states in the states progenitor is returned in response to an HTTP GET operation being performed on the states progenitor item. The number of states retained in the states progenitor item may be restricted.","Optionally, instances of the manageable container class are virtual computing systems. Virtual networks and virtual computing systems require state management and this may be from a client tool or client application. Advantageously, in embodiments of the present invention in which a virtual computer system is treated as a manageable container class and classified in this way in the ontology document and resulting interface specification, the client can manage the virtual computing system in a manner compliant with the REST architectural style.","Optionally, the software artefact includes defined acceptance constraints which, at runtime of the software artefact or an implementation of the software artefact, constrain the particular instances of progeny items that can be created by an instance of a progenitor item as a consequence of an operation invoked against it, the acceptance constraints being available to a generic client tool.","It may be desirable to define dynamic acceptance restrictions which a progenitor item can advertise to a client application (the server would return details of some or all acceptance constraints in response to a client request). For example, the next state of a states progenitor item may depend on the current state, so that certain states may follow certain other states, and certain states may be precluded.","Optionally, the domain is a cloud computing environment and the software artefact is an interface specification which can be implemented as an infrastructure as a service API, or the software artefact is an infrastructure as a service API. Cloud computing is internet-based computing. Devices are able to share resources and offer services to one another. Devices and services can be accessed on an on-demand basis, like a public utility. In fact, embodiments of the present invention can also be used to generate a software as a service API, a platform as a service API, and a software as a service API. Specifically, in infrastructure as a service computer infrastructure is provided as a resource available over the internet.","Advantageously, interface specifications and ontology documents generated by methods embodying the present invention can be made to model data in accordance with RDF (Resource Description Framework). RDF is a general method for conceptual description or modelling of information that is implemented in web resources, using a variety of syntax formats. Due to the RDF background of the ontology documents and software artefacts generated by embodiments of the present invention, a generic query function can be added to cloud IaaS APIs (or cloud PaaS APIs) to enable live information regarding environmental and operating conditions within the cloud to be accessed by a client application employing the generic query function at runtime.","The present invention may be embodied as a computing device configured to generate an ontology document indicating a structure of classes of items within a domain, which items belong to which class, and which operation each class supports, the computing device comprising an input module for inputting a domain description including information about items in the domain and relationships between the items; an access module for accessing a data structure and an operation structure, wherein the data structure is a domain-independent model of items and relationships between items for characterising items described in the domain description into classes, the data structure comprising at least progenitor items as a class of items each able to contain only progeny items created by the progenitor item as a consequence of the progenitor item accepting an operation from the operation structure invoked against it, and the operation structure including a domain-independent list of operations which, when applied to a domain description, define processing rules for the classes of items; and a generator for applying the data structure and the operation structure to the domain description to generate an ontology document for use in producing a software artefact. Input module may have the functionality to accept an input, for example, from another program or device or from a user. The computing device may be the constrained editor described elsewhere in this document.","The computer-implemented method for generating an ontology document indicating a structure of classes of items within a domain, which items belong to which class, and which operations each class supports, may comprise, at an input module, inputting a domain description including information about items in the domain and relationships between the items; at an access module, accessing a data structure and an operation structure, wherein the data structure is a domain-independent model of items and relationships between items for characterising items described in the domain description into classes, the data structure comprising at least progenitor items as a class of items each able to contain only progeny items created by the progenitor item as a consequence of the progenitor item accepting an operation from the operation structure invoked against it, and the operation structure including a domain-independent list of operations which, when applied to a domain description, define processing rules for the classes of items; and at a generator, applying the data structure and the operation structure to the domain description to generate an ontology document for use in producing a software artefact. As described above, an input module may have the functionality to accept an input, for example, from another program or device or from a user. An access module may provide a link to a storage, either remote or local, in which the data structure and operation structure are stored. A generator may be a processor constrained to behave in a particular manner by processing rules and instructions, which rules and instructions therefore may also be considered part of the generator.",{"@attributes":{"id":"p-0073","num":"0089"},"figref":"FIG. 1","b":["10","10"]},"The operational ontology and data structure ontology are domain-independent aspects which define generic relationships, rules, and assumptions for all domains. Components of the data structure ontology and operational ontology can be considered to be templates for building blocks that can be used to provide a complete information model for an extended domain.","The data structure ontology may include the categorisation of relationships (links) between classes of items into \u2018contains\u2019, \u2018accepts\u2019, and \u2018other\u2019. That is to say, a relationship between class of items A and class of items B may be categorised as \u2018contains\u2019, i.e. meaning that A contains B. In a domain, item a (belonging to class A), and item b (belonging to class B), if linked, can be linked via the relationship \u2018a contains b\u2019. In other words, class A is a container which may contain items of class B. It may also be true to say that class of items A is linked to class of items B via a relationship categorised as \u2018accepts\u2019, and therefore that in the domain, item a can accept item b. In other words, an item of class A can accept an item of class B.","Components of the data structure ontology may be properties which include simple data items which are exposed on a class of item, referred to as \u2018slots\u2019. Exposed in this sense means the data item that is in the slot is accessible by a client, either to edit, an \u2018editable slot\u2019, or just to gain a representation, a \u2018read only slot\u2019.","Other components of the data structure ontology may be:\n\n","The operational ontology provides a core domain-independent list of methods, such as GET, POST, DELETE, and PUT, and processing rules for how these should be handled by a server. Optionally, the operational ontology may include additional methods or operations which are not applied to domain descriptions as a matter of course, but may be used where required for particular domains. However, it is implicit in embodiments of the invention consistent with the principles of the REST architectural style that operations GET, POST, DELETE, and PUT are included in the operational ontology. The operational ontology may be extended with more operations, however it is desirable to keep the number of different operations to a minimum.","The data structure ontology and operational ontology are applied to the domain ontology in the black box. The black box performs the role of a processing engine, taking in the aspects of the ontology and generating an interface specification (abstract API ). The procedure within the black box can be automated, however it is also possible that user input is required at certain stages. The mechanism occurring within the black box of applying the domain-independent data structure and operational ontologies to the domain ontology is a technical process involving one or more of the following:\n\n","the construction of a view of each class, including computing which \u2018slots\u2019 are present in each class of item. For each class of item, an enumeration of associated properties is computed. For properties inherited from super-class properties (ie class A has property X and class A1 is a sub-class of A so class A1 inherits property X) the most derived properties only are selected.","Part of the process of applying the domain-independent operational and data structure ontologies to the domain ontology within the black box can be described as a recursive process in which:\n\n","define an argument type associated with the operation which contains information needed to create the progeny item of the Progenitor in question.","The code generator  is an optional inclusion in invention embodiments and can produce one or more of XML code, an API, or other software artefacts based on the interface specification (abstract API ) produced by the black box .",{"@attributes":{"id":"p-0084","num":"0111"},"figref":["FIG. 2","FIG. 2"]},"It can be seen from  that there is a class \u2018Operation\u2019. The types of operation are \u2018get\u2019, \u2018post\u2019, \u2018put\u2019, and \u2018delete\u2019. A class \u2018Getable\u2019 supports operations of type \u2018get\u2019, that is, items belonging to the class \u2018Getable\u2019 can have the \u2018get\u2019 operation performed on them. There is a class \u2018Postable\u2019 that supports the \u2018post\u2019 operation in an equivalent way to the way in which the class \u2018Getable\u2019 supports the \u2018get\u2019 operation. Similarly, a class \u2018Putable\u2019 supports the \u2018put\u2019 operation, and \u2018Deletable\u2019 supports the \u2018delete\u2019 operation.","\u2018Resource\u2019 is a subclass of \u2018Getable\u2019. That is to say, a \u2018resource\u2019, an item belonging to the class \u2018Resource\u2019, is inherently \u2018Getable\u2019 since it inherits the property of supporting the operation \u2018get\u2019 from its super-class, \u2018Getable\u2019. A class \u2018Container\u2019 is provided which is a sub-class of Resource, and hence inherits the property of supporting the operation \u2018get\u2019 from its super-class, \u2018Resource\u2019. Items belonging to the class \u2018Container\u2019 can be linked to items belonging to the class \u2018Resource\u2019 by a \u2018contains\u2019 relationship. That is to say, a container item can contain a resource item.","The class \u2018Progenitor\u2019 is a sub-class of the class \u2018Container\u2019, and hence also inherits the property of supporting the operation \u2018get\u2019. The class \u2018Progenitor\u2019 is also a subclass of the class \u2018Postable\u2019, and hence inherits the property of supporting the operation \u2018post\u2019. It is these two sub-class relationships of the class Progenitor that mean that an item of the class \u2018Progenitor\u2019 can also be called a \u2018Postable Container\u2019. The \u2018Progenitor\u2019 class has a special relationship with the \u2018Resource\u2019 class, in that it can contain a resource item only if the resource item is a type of resource or subclass of resource that is defined as the progeny item for that progenitor item. The relationship is then a has_progeny relationship, so the progenitor has the resource as a progeny. The processing rules governing this relationship are distinct from those governing a contains link. Furthermore, the class \u2018Progenitor\u2019 is linked to the class \u2018Resource\u2019 via a relationship denoted as \u2018accepts_progeny\u2019. This relationship denotes that a progenitor item can accept a post operation requesting that a resource item (of a specific type or subclass) be posted to the progenitor item, in response to which the progenitor item can create an instance of the type of resource item in question as a progeny item.","The class Resource supports the HTTP operations GET, DELETE, and PUT, as does the class Container. The class Progenitor supports the HTTP operation GET, DELETE, PUT, and POST.",{"@attributes":{"id":"p-0089","num":"0116"},"figref":["FIG. 3","FIG. 1"],"b":["1","6","1","3","1","3","3","1","4","20","40","3","5","6","3","1","1","6"]},"The process of producing ontologies  from domain knowledge  may be performed using a constrained editor . The domain knowledge may include class definitions and the way of describing links between the classes, including properties of the links. The ontologies  are consistent with the domain independent data structure and operation structure, in fact, the ontologies  may be a domain ontology, a data structure ontology, and an operational ontology (as illustrated in ). That is to say, the classes of items in the domain and the relationships between them, and the operations they support, are based on the data structure and operation structure exemplified in , and\/or the structures described as data structure ontology and operational ontology in relation to .","Formally, the ontologies  may be unified and presented in OWL (the Web Ontology Language). The constrained editor  is an editing environment which allows a user to produce ontologies  in some documented format, for example as an OWL document, without needing to know how to formally construct an ontology document. The constrained editor  may include a graphical interface in which domain knowledge can be applied to a set of fundamental classes that effectively form building blocks. The constrained editor can coerce a user into producing ontologies  consistent with the domain-independent data structure and\/or operation structure, or may even enforce that ontologies  are produced that way. Though the ontologies  are conceptually distinct (having domain-independent and domain-dependent ontologies), they may be presented as a single document unifying the ontologies, or as numerous pieces of information resulting from the combination of domain-independent and domain-dependent ontologies.","Universal interaction semantics and modelling patterns are captured in the domain-independent data structure and operation structure (these can also be referred to collectively as a core ontology, or general ontology). Producing the ontologies  for a particular domain may include importing and making reference to the data structure and operation structure. The step from ontologies  to an implementable interface specification  and other artefacts  (bits of server-side implementation code) may be an automated process taking place within a transformation engine .","Interaction semantics can be thought of as rules dictating how the overall runtime state of a domain can be changed (via an interface of API implementing the interface specification). The runtime state of a domain can be represented by a graph (for example, a map of resources and links between the resources). The universal interaction semantics capture what a client can do to change the shape of the graph in general terms, these can then be applied to a specific domain, for example, by the constrained editor . Examples of interaction semantics include indicating which classes can be deleted, and how a new resource can be added.","The constrained editor  may be realised as a graphical editor which can encode and represent the restrictions and patterns of the domain-independent data structure and operation structure. The domain knowledge of a user being captured in the ontology  then follows the conventions of the data structure and operation structure.","Users employing the constrained editor  are effectively insulated from the complexities of producing an ontology document representing the domain using a language such as OWL. If bypassing the constrained editor a user must themselves ensure that the constraints of the data structure and operation structure are adhered to.","The process of transformation by the transformation engine  may produce the code of an application skeleton as well as an interface specification. An application skeleton can be used as a starting point towards a functioning implementation of the interface specification. The programming style of any such implementation is event-driven, with event handlers attached to the classes of the ontologies .","It may be useful to note here that domain is used in this application to represent a general type of environment, for example the cloud infrastructure domain. A particular provider's domain would be referred to as an environment, so that a domain is an abstraction of environment.","The establishment of a domain-independent data structure and operation structure is enabled by extracting patterns to be incorporated in the structure from re-occurring observations across differing domains. The data structure and operation structure formalise these patterns. Some significant patterns formalised in the data structure and operation structure will now be described.","In  the nature of classes and sub-classes is illustrated, and the properties accepts and contains are exemplified. In , rectangles indicate classes, and rounded boxes represent instances of classes. In , B is a class, and sub-classes Bx and By belong to the class B. A is a class not illustrated in , but item a is an instance of class A. Items b and b are instances of class By. The relationships between the objects in  are represented by the arrows and adjacent text. As previously stated, classes Bx and By are sub-classes of class B. Instances of class A accept items in the class Bx at this point in time. However, at an earlier point in time A accepted class By. Item a is an instance of class A and supports the operations (methods) GET and POST, that is to say, class A is a sub-class of getable and postable. Item a is a container which contains items b and b, both of which are instances of class By. Items b and b support the operation GET, so are resources.","\u2018Contains\u2019 is a property, a type of relationship between two items. The principle of containment demarcates the hierarchical structure inherent in a given domain. The property \u2018contains\u2019 should be applied to subclasses of the same domain, and the range of what item can contain what may be constrained further, depending on the domain in question. The use of \u2018contains\u2019 as a property indicates the containment characteristic of a relationship between two classes. A resource hosting a set of links to contained items (elements) is implicitly a container. In , item a is a resource (it supports the operation GET) of the class A. The ontology of the domain (the domain in  being abstract) declares the \u2018contains\u2019 relationship between the class A, and types of resource it is able to contain. In this case, class A can contain resources with class B and its subclasses (though this is not derivable solely from ). Since item a supports both GET and POST, it is a progenitor item.","As well as being a collection of items, a container may also be able to accept new elements to the collection. Classifying that the container a supports POST, and is hence of the class Progenitor, specifies that instances of class A can accept items. A request is an entity, and a request is received by a progenitor via the POST operation. The request entity describes the resource to be entered into the collection in progenitor a. If accepted (there may be criteria applied to the accepts relationship), then a new actual resource is created and entered into the collection.","In some cases the acceptance policy (the criteria applied to request entities) can be restricted further at runtime, for example, based on environmental variables and states of resources. The contains policy, however, is a design-time restriction on what may appear as members inside the collection. For example, when the lifecycle of a \u2018manageable\u2019 resource is controlled through a collection of states associated with the resource, the \u2018states\u2019 collection is generally able to contain state resources (resources of the class State), and at a particular point in its lifecycle will be able to accept a StartState resource (a subclass of State) to \u2018start\u2019 it. The property \u2018accepts\u2019 can be used to publicise this runtime membership information for a given \u2018postable container\u2019 (progenitor) resource.",{"@attributes":{"id":"p-0103","num":"0130"},"figref":["FIG. 4B","FIG. 4B"]},"Containment implies that there is an exclusivity to the relationship between two items from the perspective of contained resources. The model should be re-factored if it appears that two separate resources may logically contain the same particular resource. An approach to handle this situation is to introduce a \u2018linking\u2019 class. In the example illustrated in , each blink resource is exclusively contained inside a single resource (with class A), with the result that the resource b (with class B) can be associated with multiple instances of class A.",{"@attributes":{"id":"p-0105","num":"0132"},"figref":["FIG. 4C","FIG. 4C"],"b":["2","1","2"]},"For a class declaring containment of non-homogenous items, the data structure and operation structure of the present invention may constrain the ontology to include in its hierarchy an additional set of container classes to ensure that the elements inside a container are homogenous. This is advantageous as instances of homogenous classes can be handled using common processing rules at runtime. The decision regarding the level of homogeneity to require in containers may be hard-wired into the data structure, or may be left to the user (application developer). Often a valid super class is used to specify valid entry into a container.","The data structure and operation structure formalise an approach to using these patterns in the information modelling space (ontology production process), which allows for operational-level software artefacts (i.e. HTTP-based APIs). The transformation from ontology to interface specification and other artefacts does require a number of internal processes, such as inferencing and reasoning, in order to build the interface specification (a set of rules are applied to the ontology).",{"@attributes":{"id":"p-0108","num":"0135"},"figref":"FIGS. 5A to 5D"},"VSYSs  is a progenitor item, its progeny items being VSYS -items. An HTTP GET operation to receive a representation of VSYSs  may return, for example, a list of the VSYS progeny items -contained in VSYSs . An HTTP delete operation performed on the VSYSs item  may remove all of the contained VSYS items -recursively and remove the VSYSs  item.",{"@attributes":{"id":"p-0110","num":"0137"},"figref":"FIG. 5B","b":["100","111","100","111","100","110","100","100"],"i":"d "},"In the context of the virtual computing domain for which the ontology represented by  is generated, posting a new VSYS progeny item may, in real terms, create a virtual system in an already existing group of computing resources, which may be treated by the client application as a complete VSYS (virtual system).",{"@attributes":{"id":"p-0112","num":"0139"},"figref":["FIG. 5C","FIG. 5C"],"b":["110","110","120","130","140","150","160","110","180","110","110","190","110"]},{"@attributes":{"id":"p-0113","num":"0140"},"figref":"FIG. 5D","b":["160","160","110","160","110","160","162","160","110","162","163","161","160","110","160"]},"A client application can manage the state of the VSYS item  by submitting a request entity  to the States progenitor item  using the HTTP POST operation. The body of the request entity  describes the progeny item it would like to be created (in this case a \u2018Migrating\u2019 state item). The States progenitor item  accepts the request entity  and can create a new \u2018Migrating\u2019 state item  within the States progenitor item . Once the \u2018Migrating\u2019 state item  is created, the VSYS  will be in a migrating state. The \u2018Running\u2019 state item  is retained in the States progenitor item , so that by managing the state of the VSYS  in this way, a state history is maintained within the States progenitor item . The operational details of the new state may be hosted by the server, so that the request entity  can contain as little as a valid name of a new state. Optionally, asynchronous state management is assumed which supports non-instantaneous state changes.",{"@attributes":{"id":"p-0115","num":"0142"},"figref":"FIG. 6","b":["200","210","220","230","231","230","230"],"i":["a","c"]},{"@attributes":{"id":"p-0116","num":"0143"},"figref":"FIGS. 7A-7C"},"The domain for which an ontology document and interface specification have been produced in  is a simple domain in which two classes exist, Postie, and Posties. The domain knowledge in this example may be a presentation of simple facts describing the domain, such as: postie items can be stored in a posties container; a postie item can be deleted; a postie item is created within a posties container; and representations of both posties and postie can be returned to a client.",{"@attributes":{"id":"p-0118","num":"0145"},"figref":"FIG. 7A","b":["301","301"]},"We note that the views depicted in  represent final view of the interface specification, this exemplifies a possible form of output from either the code gen (code generator)  or the transformation engine .","A menu bar  contains links to other views of the domain ontology representation , focussing on specific classes or other elements. At the right hand side of the view a \u2018Description text\u2019 area  displays some text summarising the domain.","In the menu bar , a \u2018show all\u2019 button  links to the domain view displayed in , a \u2018Posties\u2019 button links to the Posties view in , and a \u2018Postie\u2019 button links to the Postie view in . The menu bar  is accessible in all views.","In the domain view, a \u2018description text\u2019 area  is provided in which the user can provide an overall description of the domain. Depending on the process by which the domain ontology representation was produced, it may be that the computer program is able to derive the text for the description text area itself, based on the domain description input by the user at some earlier stage.","In this example, the description text  may be, for example: \u2018This is a simple example. There is a collection of posties containing individual posties. Posties is a progenitor, and is able to accept instructions to create a postie item.\u2019","There are two classes of item in the domain ontology representation . Posties  is a progenitor supporting both the (HTTP) GET and POST operations. A highlighter  merely represents that Posties is currently selected, so that hitting the return key would move to the Posties view. An arrow  links Posties  to Postie , indicating that there is a relationship between the classes. Postie  as a class supports the (HTTP) operations GET and DELETE. The boxes for Posties  and Postie  may be used in a similar way to the menu bar to move between views.",{"@attributes":{"id":"p-0125","num":"0152"},"figref":"FIG. 7B","b":["301","340"]},"A class header  and class sub-header  indicate the name for the class and a very brief summary of its role in the domain. The content of the sub-heading may be input by the user, or may be derived by the computer program from the domain description or ontology document. In this case, the class header  reads \u2018Postie\u2019, and the sub-header  reads \u2018progeny of Posties\u2019. A specification section displays outputs of the processing engine, which in this embodiment is part of the computer program. The outputs can be easily implemented as an API or other software artefact by a user.","A URI template area  provides a URI template for items of the class indicated by the class header  for the user. In this example, the URI template area  may include the text:",{"@attributes":{"id":"p-0128","num":"0155"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2018URI template (this is a SUGGESTION only)"},{"entry":"\u2003\/Posties"},{"entry":"\u2003\u2003\/{Postie}\u2019"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The text \u2018Posties\u2019 may be a clickable link to the Posties view.","The Operations Protocol area  provides text to instruct a user on how to code the processing of a request of an HTTP operation for an item of the class indicated by the class header . In the present example, Postie as a class supports the HTTP operations GET and DELETE, so the operations protocol may read:",{"@attributes":{"id":"p-0131","num":"0158"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2018Operations"},{"entry":"GET <item url=\u2019..\u2019 class=\u2019Postie\u2019>"},{"entry":"\u2003\u2003<date> dateTime <\/date>"},{"entry":"\u2003\u2003<text> string <\/text>"},{"entry":"\u2003<\/item>"},{"entry":"DELETE\u2019."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"That is to say, for the operation \u2018GET\u2019, the request does not require an argument (blank request), and the tagged text detailed above (from <item . . . to . . . \/item>) represents the format of the response which would be generated by the server in response to the request. The response would include not only the string of the postie on which the GET operation is performed, but also a dateTime data object representing the creation time of the postie. Similarly, DELETE does not require an argument, neither does the server generate a response, hence there is no text pertaining to the DELETE operation.","The Properties area  provides text to instruct a user as to what properties each class has, and what simple data object these properties are. In the present example, the text might read:",{"@attributes":{"id":"p-0134","num":"0161"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2018Properties (dot indicates read-only)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"date\u2022 ","dateTime"]},{"entry":[{},"text ","string\u2019."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0135","num":"0162"},"figref":"FIG. 7C","b":["301","340"]},"A class header  and class sub-header  indicate the name for the class and a very brief summary of its role in the domain. The content of the sub-heading may be input by the user, or may be derived by the computer program from the domain description or ontology document. In this case, the class header  reads \u2018Posties\u2019, and the sub-header  reads \u2018progenitor of Postie\u2019. A specification section displays outputs of the processing engine, which in this embodiment is part of the computer program. The outputs can be easily implemented as an API or other software artefact by a user.","A URI template area  provides a URI template for items of the class indicated by the class header  for the user. In this example, the URI template area  may include the text:",{"@attributes":{"id":"p-0138","num":"0165"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2018URI template (this is a SUGGESTION only)"},{"entry":"\u2003\/Posties\u2019."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The Operations Protocol area  provides text to instruct a user on how to code the processing of a request of an HTTP operation for an item of the class indicated by the class header . In the present example, Posties as a class supports the HTTP operations GET and POST, so the operations protocol may read:",{"@attributes":{"id":"p-0140","num":"0167"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2018Operations"},{"entry":"GET <item url=\u2019..\u2019 class=\u2019Posties\u2019>"},{"entry":"\u2003\u2003\u2003\u2003<postie url=\u2019..\u2019 class=\u2019Postie\u2019 \/>"},{"entry":"\u2003\u2003<\/item>"},{"entry":"POST creates a Postie child resource inside this collection"},{"entry":"\u2003<item class=\u2019Postie\u2019>"},{"entry":"\u2003\u2003\u2003<text> string <\/text>"},{"entry":"\u2003<\/item>\u2019."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Again, the GET operation does not require an argument, and the text following \u2018GET\u2019 (between <item . . . and . . . \/item>) represents the format of response which would be generated by the server receiving a GET request for a Posties progenitor. The operation POST does have an argument (the string), and the text following \u2018POST\u2019 between <item . . . and . . . \/item> is actually the format that a request to create a new postie via the POST operation should take (the string being the string of the postie). Optionally, text representing the format for a response to such a request could be displayed. However, it would be known by a user that the format of such a response is the same as that for the \u2018Postie\u2019 class detailed above, with a response of the form:",{"@attributes":{"id":"p-0142","num":"0169"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<item url=\u2019..\u2019 class=\u2019Postie\u2019>"},{"entry":"\u2003\u2003<date> dateTime <\/date>"},{"entry":"\u2003\u2003<text> string <\/text>"},{"entry":"\u2003<\/item>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"being generated for each postie item in the Posties progenitor.","The Properties area  provides text to instruct a user as to what properties each class has, though in this case the progenitor item only contains Postie items and has no additional fields, so the Properties area  is blank.","An additional text area, the Children area , is provided since the class Posties is a progenitor class. The Children area  provides details of the classes for which the class indicated by the class header  is a progenitor. In this example the text may read:",{"@attributes":{"id":"p-0146","num":"0173"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2018Progenitor of"},{"entry":"\u2003postie Postie\u2019"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In which the second piece of text, \u2018Postie\u2019, is a link to the Postie view.",{"@attributes":{"id":"p-0148","num":"0175"},"figref":"FIGS. 8A and 8B","b":["350","350","352","353"],"i":["a ","b "]},"The operations of the operational ontology may be HTTP operations, though this is optional.","In any of the above aspects, the various features may be implemented in hardware, or as software modules running on one or more processors. Features of one aspect may be applied to any of the other aspects.","The invention also provides a computer program or a computer program product for carrying out any of the methods described herein, and a computer readable medium having stored thereon a program for carrying out any of the methods described herein. A computer program embodying the invention may be stored on a computer-readable medium, or it could, for example, be in the form of a signal such as a downloadable data signal provided from an Internet website, or it could be in any other form.","In particular, a computer program may be provided which, when executed by a computing device having a processor, causes the computing device to perform a method embodying the present invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"p":[{"@attributes":{"id":"p-0059","num":"0075"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0060","num":"0076"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0061","num":"0077"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0062","num":"0078"},"figref":"FIGS. 4A-C"},{"@attributes":{"id":"p-0063","num":"0079"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0064","num":"0080"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0065","num":"0081"},"figref":"FIG. 5C"},{"@attributes":{"id":"p-0066","num":"0082"},"figref":"FIG. 5D"},{"@attributes":{"id":"p-0067","num":"0083"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0068","num":"0084"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0069","num":"0085"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0070","num":"0086"},"figref":"FIG. 7C"},{"@attributes":{"id":"p-0071","num":"0087"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0072","num":"0088"},"figref":"FIG. 8B"}]},"DETDESC":[{},{}]}
