---
title: Method and apparatus for providing an area network middleware interface
abstract: A method and apparatus for implementing a protocol-neutral middleware interface in a home area network. The method comprises receiving one or more data packets from a client device using a first communication protocol, and decoding the data packets into a set of platform independent data objects. The data packets are decoded into the platform independent data objects by utilizing a metadata mapping located within one or more field classes. The apparatus comprises a frame engine, and one or more field classes. The frame engine receives a data packet in a first communication protocol. The frame engine decodes the data packet into a set of platform independent data objects. The frame engine uses a metadata map contained within the one or more field classes to decode the data packet into the set of platform independent data objects.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08488624&OS=08488624&RS=08488624
owner: Wireless Glue Networks, Inc.
number: 08488624
owner_city: Walnut Creek
owner_country: US
publication_date: 20100922
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application claims benefit of U.S. provisional patent application Ser. No. 61\/277,288 filed Sep. 23, 2009 which is herein incorporated by reference.","1. Field of the Invention","Embodiments of the present invention generally relate to computer networking and, more particularly, to a method and apparatus for a home area network middleware interface.","2. Description of the Related Art","With the advent of affordable wireless technology, home network environments have become inexpensive and ubiquitous. Manufacturers have recognized the potential benefits of this connectivity and many common household devices are retrofitted with wireless transmitters and receivers for the purpose of home automation. Some of these benefits include appliances that monitor and report their energy consumption to a central server to provide \u201csmart\u201d energy, lights, appliances, and thermostats that respond to changing environmental conditions or set programmed profiles, fingerprint locking mechanisms for home security systems, and the like.","One common method for wireless network communication over computer networks is TCP\/IP using the 802.11 series of standards. However, this communications protocol is often unsuitable for the purposes of home automation and integration due to the cost of equipment and the programming overhead in implementing a functional TCP\/IP stack on a comparatively low powered device. As such, manufacturers have recognized the potential benefits of other protocols such as IrDA, Bluetooth, UWB, and ZigBee, such as lower power consumption, easier configuration, mesh network capabilities, and the like.","Configuring these devices to interface with a home network can be problematic. The driver programs responsible for automating and integrating the household devices commonly execute on personal computers or other devices having substantial computing power that facilitates communication over TCP\/IP. Such computing platforms allow the driver program to send and receive data from the Internet, providing benefits such as access for remote users or the ability to upload data to a central server. The execution of the TCP\/IP stack is commonly provided by the operating system or network device driver. In order for the driver program to communicate with the remote devices, the driver must execute an additional protocol stack to transmit in the proper protocol. This may result in significant programming overhead and a need for substantial computing capability. It would be advantageous for the driver program to communicate with the household devices in a platform independent manner while requiring little extra computing capability.","Therefore, there is a need in the art for a method and apparatus for providing a platform independent interface to remote household devices.","An embodiment of the present invention comprises a method and apparatus for implementing a protocol-neutral middleware interface in a home area network. The method comprises receiving one or more data packets from a client device using a first communication protocol, and decoding the data packets into a set of platform independent data objects. The data packets are decoded into the platform independent data objects by utilizing a metadata mapping located within one or more field classes.","The apparatus comprises a frame engine, and one or more field classes. The frame engine receives a data packet in a first communication protocol. The frame engine decodes the data packet into a set of platform independent data objects. The frame engine uses a metadata map contained within the one or more field classes to decode the data packet into the set of platform independent data objects.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1","b":["100","100","102","106","110"]},"In some embodiments, the HAN  is located within a home . In some embodiments, the routing computer  and the network  may also be located within the home . In other embodiments, the routing computer  and the home network  may remotely monitor the devices of the HAN  from outside the home.","One or more client devices  are coupled to one another and the routing computer  via the home network . In one embodiment, the client devices  are general purpose computing devices as commonly known in the art. The client devices  may run software applications designed to allow control, monitoring, and access of devices coupled to a HAN .","The home network  may be coupled to the routing computer  by wires or wirelessly in the manner well-known in the art. In some embodiments, the home network  or routing device  may also be coupled to the Internet. One or more HAN devices  are coupled to one another and the routing computer  via the HAN . The HAN devices  may be common household devices equipped for transmitting and receiving information via the HAN , such as light and temperature sensors, light switches, stereo systems, washers, dryers, refrigerators, or any other common household device that would benefit from connecting to a HAN. The client devices  communicate data packets  to the routing computer  for transmission to the HAN devices .","The routing computer  parses the data packets  and translates them into one or more platform independent data objects . Note that while the present embodiment of the invention is discussed with respect to decoding data packets  into platform independent data objects , one of ordinary skill in the art would recognize that the method is equally applicable to the decoding of a data packet of one format into a data packet of another format. The platform independent data objects  are stored in a platform independent format as data objects suitable for access and modification. The platform independent data representation may consist of complex data objects, though the API gives access to the constituent fields as JAVA primitives, as appropriate for the field type. Each field type (defined at run time in a configuration file) indicates which primitives are supported by the presence of appropriate interfaces in the definition (a class can implement any number of interfaces). These interface declarations are in the class itself; the configuration file maps the field name to the class definition. For instance, if a field class implements the \u201cILongValue\u201d interface, then it supports getting and setting the field value as a \u201clong\u201d integer type. Similar interfaces exist for the other primitives (int, double, etc.) as well as for more basic data objects such as String and BigInteger. Thus, a field class indicates at run time which primitives it supports.","Storing the data in this format advantageously allows the frame engine  and\/or other programs to access and modify the data without the need to explicitly decode platform or protocol specific data structures. The frame engine  provides an application programming interface (\u201cAPI\u201d) for accessing the platform independent data objects. The frame engine  may provide a scripting interface for scripting languages such as JAVASCRIPT, PYTHON, RUBY, and the like.","Most basically, the frame engine  provides access to the data packet  using a type of field  known as a frame. The frame is a type of data structure that consists of an ordered set of dynamically defined field classes. However, the frame itself is a type of field, and therefore this type of data structure can be arbitrarily nested. Although well suited to process the nested blocks of data used by many communication protocols, a frame could represent data encoded in XML or some other format.","The terms \u201cprocessing\u201d or \u201cdecoding\u201d a frame, mean allowing access to the various fields, which contain protocol specific data types, as native language data types, so that those values can easily be read, manipulated, and written in the native language (JAVA, for example). They are then accessed in the natural data types of the Java language, which is a platform independent representation. The frame engine  allows data fields in these potentially complex data structures to be accessed as platform independent data objects  by name, using a hierarchical naming convention. Note that in one embodiment, JAVA is the \u201cnative language\u201d, and the platform independence of the data representation is due to the platform independence of Java's data representation. Not all languages provide a platform independent data representation; for instance, the C\/C++ language data representation is dependent on the architecture of the processor on which the code executes. While one embodiment may be is tightly tied to the JAVA language, if it were to be implemented in a different language, then the \u201cworking\u201d data representation (that presented after a decode operation) would not necessarily be platform independent; it would depend on the specific language.","For example, given a frame f, then f.getInteger(\u201casdu.header.type\u201d) refers to the integer value translation of the field \u201ctype\u201d which is expected to be in a frame which is itself a field named \u201cheader\u201d in a surrounding frame, and that frame is itself a field named \u201casdu\u201d in the outermost frame. Likewise, f.setInteger(\u201casdu.header.type\u201d, 3) will set the same field to the protocol specific translation of the value of 3.","The routing computer  may perform data conversion and access operations on the platform independent data objects . In one embodiment, the routing computer then translates the platform independent data objects  into the proper protocol for transmission to the HAN devices . The routing computer  may then transmit the translated data packets  to the HAN devices . In another embodiment, the platform independent data objects  are processed on the routing computer  for access by external applications. These external applications may execute on the routing computer  or on another client device  networked to the routing computer .","In one embodiment, the routing computer  is a general purpose computer that operates as a specific purpose computer executing a frame engine  containing an embodiment of the present invention. The general purpose computer is a computing device such as those generally known in the art. The routing computer  includes a central processing unit (CPU) , support circuits , and memory . The CPU  may comprise one or more commercially available microprocessors or microcontrollers that facilitate data processing and storage. The various support circuits  are utilized to facilitate the operation of the CPU  and include such circuits as clock circuits, power supplies, cache, input\/output circuits and devices, and the like. The memory  may comprise random access memory, read only memory, removable storage, optical disk storage, disk drive storage, and combinations thereof. In one embodiment, the memory  stores an operating system , a network module , one or more field classes , a frame engine , one or more data packets , one or more decoder classes , and one or more configuration files . In operation, the CPU  executes the operating system  to control the general utilization and functionality of the host computer.","The memory  further comprises a frame engine . When executed by the CPU , the network module  causes the general purpose computer to behave as a specific purpose computer for the purpose of routing, encoding, and decoding data packets . The frame engine  may be implemented as part of a network routing program such as contained within commercially available standalone router devices, or it may be implemented as a separate application. In some embodiments, the network module  may listen for network traffic. The network module  parses data packets  incoming from the client devices  and HAN devices .","The network module  acts to perform data communications from the computer  across the networks  and . The network module  sends and receives the data packets . The network module  parses the data packets  based upon metadata maps contained within the field classes  by using the frame engine . In some embodiments, the network module  passes the received data packets  to the frame engine . In some embodiments, the frame engine  is executed as a subroutine of the network module . The frame engine  decodes the data packets  in accordance with frame definitions contained within the field classes . Embodiments of this process are discussed further with respect to .","In some embodiments, the field classes  may contain \u201craw\u201d field classes which are a type of field that provides a reference to decoder class  (a piece of executable code) that is invoked with undecoded data in order to find or generate an object for use in decoding that field. In other words, when the decoder class executes, it replaces the raw field with a frame of the proper type to do the decoding for that field. Generally field classes have operations for getting and setting the data values, and for translating those values to and from the encoded representation (encode\/decode). A frame decodes by executing a decode operation in turn on each of its constituent field classes. Typically, one of these \u201craw\u201d field classes represents a protocol layer, and the group of frame definitions used at one level will represent a different protocol layer than the enclosing or enclosed frames.","For example, the frame engine  may provide one or more of the following decoder classes  for use in decoding the data packet :","Cluster Decoder: Decodes a ZCL frame (ZigBee Cluster Library) based on the cluster and command IDs, using a decode table to map numeric cluster and command IDs to the name of a field definition to use for the frame.","Array Decoder & List Decoder: Decodes arrays of a named frame type with an explicit (ArrayDecoder) or implicit (ListDecoder) length.","Frame Decoder: Decodes a field using an explicitly named frame definition.","The decoding procedure is bootstrapped by some code (such as the frame engine  or a driver) calling the decode method with the incoming data (even if that frame definition only contains a single \u201craw\u201d data field with a decoder reference). The previous examples are given to illustrate possible embodiments of a decoder class . One of ordinary skill in the art would recognize that decoder classes  can be created for different protocols and data formats.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 2","b":["200","202","124","126"]},"The data packet  is comprised of one or more frames of data encoded in a specific communication protocol. At step , the frame engine  associates the data packet  with one or more field classes  for processing the particular protocol of the packet . The frame engine  knows enough about the device specific data packet to either apply a known field  (a \u201clink\u201d frame) or supply a decoder class that can use other criteria (for example the value at some known offset in the incoming data) to select a field  appropriate to decode that data. In one embodiment, the frame engine  uses a dynamic lookup table to translate the values at known offsets within the data packet  into an identifier, and that frame is then used to decode the data.","The frame engine maintains a number of drivers, which are classes listed in a configuration file. The driver knows how to manage a particular type of connection to a Home Area Network. For instance, one driver may communicate via a USB connection to a locally connected network device, using the TI link protocol. Another driver may communicate over TCP\/IP with a HAN gateway, such as the DAINTREE SENSOR NETWORK ANALYZER. It is the driver for a particular connection type that contains instructions to bootstrap the decoding process for an incoming data packet.","A connection to the HAN is required to send (encode) and receive (decode) frames, and the software component that handles a connection is called a driver. In the present invention, the driver is a modular software component that mediates the communications with a particular type of network device or gateway to allow communications with other devices on a HAN. A connection provides operations such as receiving or sending frames and managing the gateway device. Drivers are configured at runtime in a configuration file . The following is an example entry in this file:","<driver>com.wirelessglue.driver.SnaConnection<\/driver>","This entry causes the named class to be loaded as a driver class when embodiments of the present invention are initialized. When establishing a connection, a connection specifier (much like a URL) specifies the type of connection as well as any required parameters for that connection type. For example, the connection specifier \u201cspi2:COM3\u201d indicates a locally attached, TI based device located at communications port  while \u201csna:192.168.10.1\u201d indicates an instance of a HAN gateway running at the network address 192.168.10.1. The frame engine delegates the recognition and parsing of connection specifiers to the driver classes.","Each field  is associated with an identifier, which is then used to lookup the definition of that field. For example, the field name may be turned into the location of a file containing the frame definition by the following algorithm:\n\n","This algorithm may be used to locate the definition files for a number of objects in addition to field classes . For instance, in one embodiment name-to-value translations are named and stored in a similar fashion under the \u201cenums\u201d directory, and ZigBee cluster definitions (which themselves contain nested frame definitions) are stored under the \u201cclusters\u201d directory. Although these identifiers are discussed with respect to file names, one or ordinary skill in the art would recognize that it is possible to allow configuration data to come from a number of other sources including a relational database, a file \u201cresource\u201d inside of a JAVA Archive (jar) file, or from a web server.","At step , instructions within the field classes  are used to transform the data packet  into one or more platform independent data objects . The data packet  may be comprised of multiple types of data. For example, the data packet  may include a protocol header along with payload data. The protocol header may include the information required to transmit the data packet  in the originating protocol, such as the source and destination addresses. The payload data may be one or more data structures intended for the destination device. The field classes  contain instructions for translating the data within the data packet  into platform independent data objects . The translation process is discussed in further detail with respect to .","At step , the frame engine  provides access to the platform independent data objects . The frame engine  uses rules and instructions from a field  associated with the data types contained within the platform independent data objects . In some embodiments, the frame engine  may encode the platform independent data objects  into other protocols or protocol stack layers. Each translation requires an appropriate field  containing instructions for translating to or from the particular data formats. As stated above, the translation process is discussed further with respect to .","At step , the method ends with the platform independent data object  accessible to applications capable of interfacing with the frame engine .",{"@attributes":{"id":"p-0047","num":"0049"},"figref":"FIG. 3","b":["122","124","126","122","302","302","306","304","122","122","122","122","302","126","304","122"]},"Field classes  translate a particular data type to and from an encoded form, in the sense that they have code that does just such a transformation. This code generally uses various parameters or properties to determine how to perform the encoding. For example, the field type that handles arbitrarily sized integers (IntegerField) must know the length of the encoded field in order to generate the correct output. This size can be configured from an XML frame definition, or it can be set through the API, or it can come from another field. It is this combination of code and parameters that together do the translation (encoding\/decoding).","In some embodiments, the field classes  are configured from Extensible Markup Language (XML) metadata, but a person of ordinary skill in the art would recognize that the object definitions could be implemented in other markup languages such as JAVASCRIPT Object Notation, YAML, and the like.","The simple protocol represented by the exemplary metadata frame  includes three components: source, destination, and data. The source field is further divided into four sub-fields  and a set of field definition instructions . The field definition code indicates instructions for the frame engine for how to parse the data contained within the source field. For example, the field definition code  may instruct the frame engine to use certain bytes within the data packet  as elements of each of the four sub-fields . These four sub-fields  may correspond to the four integers of an IP address, for example. The field definition code instructs the frame engine to store each of these four sub-fields in a platform independent format indicating the source address. In this manner, the metadata frame  defines the way the frame itself is parsed by the frame engine .","The field definition code  present within the field classes  also functions to define the method by which platform independent data objects  are encoded into a particular protocol or protocol layer. The field definition code  corresponds to the various data stored in the platform independent format necessary for encoding the data. For example, the destination may be stored in integer format in a platform independent data type. The field definition code  would provide instructions for encoding the destination integer into the particular format and bytes that the destination is found in data packets of the encoded protocol. The instructions needed to decode data from the protocols associated with the given metadata field  are contained within the metadata frame itself.","A field  is an object that is able to contain a value which can be queried or set, and translate that value to and from an external form, which generally consists of a byte buffer, or sequence of bytes that corresponds to a data packet sent to or from an application. Many different field types may exist in embodiments of the present invention, which are configured in a \u201cfields.xml\u201d configuration file . This file contains a mapping between tag names used in the field definition language and the names of the classes that implement the field classes. For example, this is a typical entry in this file:","<field tag=\u201cuint8\u201d class=\u201ccom.wirelessglue.field.zcl.UnsignedInteger8\u201d\/>","This specifies that the given class will be loaded to handle the \u201cuint8\u201d tag in the frame definition language. So, if a given frame definition has an element like this: <uint8 name=\u201ccount\u201d\/> then the class \u201ccom.wirelessglue.field.zcl.UnsignedInteger8\u201d will be loaded to handle the field. All that is necessary to add a new field type is to implement a class with the appropriate interfaces and to add it to the fields.xml file.","One basic interface is required of all field implementations (IField), but additional, optional interfaces indicate which of the various platform independent data types are supported by the field. For instance, \u201cIIntegerValue\u201d indicates that field can get queried or set with an integer value, and \u201cIFloatValue\u201d indicates that the field supports access as a floating point value. In addition to serving as marker interfaces, these interfaces define the appropriate get and set operations for that data type.","Some field classes can act like containers for other fields, and the frame is an example of this field type. A frame can contain any number of fields, including other frames. The frame class contains convenience classes for accessing nested field classes using hierarchical names, rather than by looking up each nested frame individually. Another instance of a container field in the IntegerField class upon which all of the fixed sized integer field types are based. Integers can contain individual bitfields, which appear as fields within the integer field. Unlike a frame, an integer field has an actual value itself, while the contained bitfields actually reference certain bits of that value.",{"@attributes":{"id":"p-0056","num":"0058"},"figref":"FIG. 4","b":["400","126","402","124"]},"The frame engine  receiving data from a client device  typically uses some device-specific protocol that \u201cwraps\u201d a more standard ZigBee network frame. The incoming frames may be in a format defined by TEXAS INSTRUMENTS \u201cZStack\u201d firmware, though nested inside those frames typically are ZIGBEE \u201cAPS\u201d frames. The frame engine  must generally know enough about the device specific protocol to either apply a known field  (a \u201clink\u201d frame) or supply a Decoder class that can use other criteria (for example the value at some known offset in the incoming data) to select a field  appropriate to decode that data. The frame engine may use a dynamic lookup table to translate the values at known offsets into a frame name, and that frame is then used to decode the data.","In this example, the sequence would proceed as follows:","At step , the frame engine  accumulates data until a full data packet  is received. In one embodiment, the frame engine  uses the ZStack link protocol to receive this data.","At step , the frame engine  looks for a particular identifier corresponding to the type of data packet  that was received. This identifier may be used to perform a table lookup to determine a name for the proper field  used for decoding the data packet . For example, when a ZStack packet is received, the 16 bit command ID of the ZStack frame is looked up in the dynamic \u201cenumeration\u201d named spi2.commands. This table will return a name for the given 16 bit value (in a reverse lookup), for example if a 16 bit command has an ID of 0x4481, the value \u201cAF_INCOMING_MSG\u201d will be returned from this lookup since one of the entries in the file enums\\spi2\\commands.xml looks like this:","<entry name=\u201cAF_INCOMING_MSG\u201d value=\u201c0x4481\u201d\/>","At step , the frame engine  uses the frame name determined in step  to select the appropriate field . Using the ZStack example, the prefix for the ZStack link frames is then prepended to the returned name (getting spi2.AF_INCOMING_MSG), and this value is then used as a frame name for the decode. So, ultimately, the frame definition used for the decode is found in the file frames\\spi2\\AF_INCOMING_MSG.xml. (if the command ID is 0x4481). The method ends at step  after the proper field has been identified.","However, the exact algorithm used to bootstrap decoding is dependent on the protocol and the context. The frame engine  may communicate using an XML protocol, and in that protocol the incoming XML contains the frame name as a string. That driver takes this name directly from the XML, prefixes the driver prefix, and uses this as the frame name to decode","Decoding is \u201cchained\u201d meaning that the new frame used for decoding incoming data can itself have \u201craw\u201d field classes associated with a decoder. Such decoders will be invoked as they are encountered until all data is decoded.","In one embodiment of the present invention, the field classes  represented in a configuration file  implement the data types necessary to implement the ZigBee protocol, and the set of data definitions known as the ZigBee Cluster Library (ZCL).","In addition to simple frame definition files, where one frame definition is listed in a location derived from the frames name, there is another form of frame definition, a special form (the cluster definition language) which has been extended to include ZigBee Cluster Library data representations. The cluster definition language differs from the frame definition language in the following ways:","Although each cluster definition is found using a similar method to that used for frame and enumeration definitions discussed elsewhere, that is, the file name is derived from the cluster name by mapping it to a file in a particular directory, the definitions in a cluster definition are more complex; there are two sections that correspond to the server and client portions of a ZigBee cluster definition, and the ability to declare cluster attributes and cluster commands in each section. ZigBee Cluster Commands are similar to frame definitions, and any of the tags defined in the fields.xml file can be used in a cluster command definition. The primary difference is that the Cluster Library header is assumed to be prepended to any command definitions listed in a cluster definition. That is, certain field classes, corresponding to the header fields of a ZigBee Cluster command header, are assumed to be contained in all cluster commands, and so the fields actually listed in the command definitions are those in addition to the implied fields.","In addition to cluster commands, cluster attributes can be defined in each section (client and server) of a cluster definition. Cluster attributes are dynamically typed data items that can be read and written via \u201cgeneral\u201d ZigBee commands. Field types (by XML tag name) are also used to identify attribute data types, so the list of allowed data types for the attributes is the same as the list of tags allowed in field definitions.","In addition, there is a configuration file  with a predefined name \u201cgeneral-commands.xml\u201d that defines all of the ZigBee general commands, since they are not defined inside of any particular cluster definition.",{"@attributes":{"id":"p-0069","num":"0071"},"figref":"FIG. 5","b":"500"},"At step , the encoding process for a frame generally involves invoking the encode operation on each of the field classes that it contains, in turn. Since a frame is also a field, frames can be arbitrarily nested. However, since some of the metadata constructs in the field definition language allow for conditional presence or alternative field selection, this sequence is not necessarily linear. That is, the presence of a field can be conditionally dependent on the value of another field, or one field from a number of alternatives can be selected based on the value of another field (the same holds true for the decoding process). At step , the method creates a \u201cpacked\u201d byte array, or data packet , ready to be sent or handed to another software component. The method ends at step  after the packet has been created.","Conditional inclusion of a field is accomplished in two ways (this applies to decoding as well). First, any field definition can include the attributes \u201cpresentField\u201d and \u201cpresentValue\u201d. The following fragment of a frame definition illustrates this:",{"@attributes":{"id":"p-0072","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<uint8 name=\u201cStatus\u201d\/>"},{"entry":"<ieeeaddr name=\u201cIeeeAddr\u201d presentField=\u201cStatus\u201d presentValue=\u201c0\u201d\/>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"This fragment defines two fields, Status and IeeeAddr. The IeeeAddr field will only be present if the field Status has the value of 0. The presentValue attribute can also contain a list of alternatives separated by the vertical bar character; in that case the field will be considered present if it matches any of the values listed.","The other way that fields can be conditionally included is through use of a type of field that can contain a number of alternative fields, selected by the value of another field. This is illustrated by this fragment of frame definition language:",{"@attributes":{"id":"p-0075","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<uint8 name=\u201cDestAddrMode\u201d\/>"]},{"entry":[{},"<select name=\u201cDestAddr\u201d field=\u201cDestAddrMode\u201d>"]},{"entry":[{},"<uint16 select=\u201c2\u201d\/><ieeeaddr select=\u201c3\u201d\/><\/select>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The DestAddr field will delegate to either the \u201cuint16\u201d or \u201cieeeaddr\u201d field types, depending on the value of the \u201cDestAddrMode\u201d field. If the value is 2, then the uint16 field is selected, if the value is 3, then the ieeeaddr field is selected.","While the foregoing is directed to embodiments of the present invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof, and the scope thereof is determined by the claims that follow."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the present invention can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to embodiments, some of which are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
