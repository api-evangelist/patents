---
title: Efficient hardware instructions for single instruction multiple data processors
abstract: A method and apparatus for efficiently processing data in various formats in a single instruction multiple data (“SIMD”) architecture is presented. Specifically, a method to unpack a fixed-width bit values in a bit stream to a fixed width byte stream in a SIMD architecture is presented. A method to unpack variable-length byte packed values in a byte stream in a SIMD architecture is presented. A method to decompress a run length encoded compressed bit-vector in a SIMD architecture is presented. A method to return the offset of each bit set to one in a bit-vector in a SIMD architecture is presented. A method to fetch bits from a bit-vector at specified offsets relative to a base in a SIMD architecture is presented. A method to compare values stored in two SIMD registers is presented.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09342314&OS=09342314&RS=09342314
owner: Oracle International Corporation
number: 09342314
owner_city: Redwood Shores
owner_country: US
publication_date: 20130910
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS; BENEFIT CLAIM","FIELD OF THE INVENTION","BACKGROUND","DETAILED DESCRIPTION","General Overview","SIMD Instructions","Fixed-Width Bit Unpack","Exemplary Process","Serial Process","Variable-Length Byte Unpack","Exemplary Process","Serial Process","Burst","Memory Form","Register Form","Hardware View","Serial Process","Ones Index","Register Form","Hardware View","Scalar Process","Gatherb","Register Mask Form","Register Form","Hardware View","Alternative SIMD Implementation","Bit-Vector Comparison Result","Hardware View","Various Other Operations","Variations","Hardware Overview"],"p":["This application claims the benefit of Provisional App. No. 61\/801,207, filed Mar. 15, 2013, under 35 U.S.C. \u00a7119(e). This application also claims the benefit of Provisional App. No. 61\/709,142, filed Oct. 2, 2012, under 35 U.S.C. \u00a7119(e). The application also claims benefit, as a continuation-in-part, of U.S. patent application Ser. No. 13\/708,054, filed Dec. 7, 2012, which in turn claims priority to Provisional App. No. 61\/709,142, filed Oct. 2, 2012, and of Provisional App. No. 61\/568,644, filed Dec. 8, 2011. The entire contents of each of these documents are hereby incorporated by reference as if fully set forth herein.","The present invention relates to single instruction multiple data instructions, and more specifically to efficient hardware instructions for single instruction multiple data processors.","Data formats are designed to enable efficient processing and storage of a variety of different dataset characteristics. Algorithms that process data in these formats are critical. Unfortunately, current processors are not always capable of working with particular data formats efficiently.","Processor designers have historically provided minimal direct support for application specific instructions. Thus, software developers have relied on the increasing speed at which existing processors execute a set of instructions to increase performance of a particular algorithm.","The performance of typical processing units, however, is not increasing at the same rate. Thus, software developers are not able to rely as much on increasing computer power to more quickly process particular data formats.","Single instruction multiple data (\u201cSIMD\u201d) processors perform the same operation on multiple data items simultaneously. SIMD processors exploit data level parallelism by executing a single instruction against data in multiple registers or subregisters. Thus, the throughput per instruction may be increased accordingly. SIMD processors are typically used for graphic and other multimedia applications. Accordingly, it may be difficult to use the SIMD architecture to process particular data formats efficiently.","The approaches described in this section are approaches that could be pursued, but not necessarily approaches that have been previously conceived or pursued. Therefore, unless otherwise indicated, it should not be assumed that any of the approaches described in this section qualify as prior art merely by virtue of their inclusion in this section.","Terms and Notation","For purpose of explanation, the following terms and conventions are used herein to describe embodiments of the invention:","The term \u201cbyte\u201d herein describes number of contiguously stored bits. While the common usage implies eight bits, the size of a byte may vary from implementation to implementation. For example a byte may refer to any size including, but in no way limited to: eight bits, sixteen bits, thirty-two bits, sixty-four bits, and so on.","The notation <XY> herein describes a vector of bits, e.g., <10>. Spaces may be added between bits merely to increase the ability to read the contents of the vector, e.g., <1111 0000 1111 0000>.","The notation [J, K] herein describe a set of contiguous values, where J is a first value and K is a second value, which may be equal or different.","The notation \u201c0x\u201d may be used to denote a hexadecimal number. For example, 0x2C may be used to represent the number forty-four. In some embodiments where bit representations may be unwieldy, hexadecimal representations may be used to increase the ability to read and understand the description.","The term \u201cregister\u201d is a register or subregister that may include one or more smaller subregisters. Unless otherwise specified a register may be a SIMD register or a register typically used in the scalar processor.","In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.","Several instructions are presented for processing particular data formats using SIMD architecture. Specifically, instructions to unpack fixed-width bit values, unpack variable-length byte values, decompress run length encoded bit-vectors, find offsets for bits set to one in a bit-vector, gather particular bits from a bit-vector, and comparing two value-vectors, on a SIMD processor are described.","Many of the instructions presented may be particularly useful for performing operations on particular data formats in memory. The instructions may operate over memory, registers, or immediate operands. Furthermore, instructions with memory operands may operate on data with different degrees of granularity, such as a cache-line or page-sized chunk.","A SIMD instruction is an instruction that, when processed, may cause an operation to be performed multiple times, simultaneously and\/or in parallel, on multiple distinct data values. For the purpose of illustrating a clear example, assume four integer values are to be incremented by one. Also assume that a SIMD processor receives a single SIMD Increment by One instruction. In response to receiving the single SIMD instruction, the SIMD processor may increment each of the four integer values simultaneously.","In contrast, a scalar instruction is an instruction that, when processed, may cause an operation to be performed once. Multiple scalar instructions may be processed serially within a scalar processor, processing unit, or processing core. Assume, for purposes of illustrating a clear example, the same four values in the previous example are to be incremented by one on a scalar processor. The scalar processor may execute a first scalar Increment by One instruction, causing the first value to be incremented by one; then, the scalar processor may execute a second scalar Increment by One instruction, causing the second value to be incremented by one, and so on. Thus, in this example, the scalar processor must execute three more Increment by One instructions than the SIMD processor in the previous example. Furthermore, assume that the scalar processor performs a scalar Increment by One instruction as quickly as the SIMD processor executes a SIMD Increment by One instruction. Because the scalar processor performs scalar instructions serially, and the SIMD processor performs a SIMD instruction on multiple data objects in parallel, the scalar processor may take four times longer to process all four values than the SIMD processor.","One approach for implementing a SIMD operation is to use one or more registers that are each capable of storing multiple distinct data values. Such registers are referred to herein as SIMD registers. Assume, for purposes of illustrating a clear example, that a SIMD register is capable of storing 256 bits. Accordingly, the SIMD register is capable of storing eight distinct 32-bit values, each in a 32-bit subregister; four distinct 64-bit values, each in a 64-bit subregister; or two distinct 128-bit values, each in a 128-bit subregister. Additionally or alternatively, non-power-of-two sized subregisters may be used.","A SIMD operation implemented in hardware and may take one or more machine cycles to execute. For example, a scalar processor, in response to receiving an Increment by One instruction, may increment a value loaded into a register in a single cycle. Likewise, a SIMD processor, in response to receiving an Increment by One instruction, may increment multiple values loaded into multiple SIMD registers, or SIMD subregisters, in parallel, in a single cycle. Additionally or alternatively, one or more SIMD instructions may take more than one cycle to execute.","A computer system that implements both SIMD and non-SIMD instructions may include one or more SIMD registers and one or more non-SIMD registers. Additionally or alternatively, a register may be a SIMD register for purposes of executing SIMD instruction and a non-SIMD register for purposes of executing a non-SIMD instruction. Additionally or alternatively, SIMD registers may be on a different hardware element (for example, a different coprocessor) than the hardware element on which non-SIMD registers reside.","A SIMD instruction, fixed-width bit unpack (\u201cbunpk\u201d), may be used to unpack fixed-width bit values into fixed-width bytes. To efficiently use some SIMD instructions, each value in a register may be stored in, and aligned with, its own subregister. Accordingly, this instruction may be used as an enabler for some subsequent SIMD processing by copying each bit-packed value in a bit-vector into, and aligned with, its own subregister.","Specifically, executing this instruction stores values originally formatted as a series of contiguous bits in a SIMD register, into separate contiguous subregisters. Furthermore, each value may be shifted and aligned within the subregister that the value is stored in. For example, the values three, one, and seven may each be represented as three bits, and may be packed in a bit-vector, e.g., <110 100 111> (wherein the left bit is the least significant bit), stored in a SIMD register. After performing the bunpk instruction on the SIMD register, each value may be stored, and aligned, in its own separate subregister represented as <1100 0000>, <1000 0000>, and <1110 0000>.","In an embodiment, the instruction may take as operands: a register or subregister that contains a series of fixed-width bit values; a register containing subregisters that will store the unpacked values; and a register containing the bit-width of each packed value. Alternatively, the register containing the bit-width of each packed value may be an immediate value. Furthermore, a completer may be included, which indicates the size of each subregister the unpacked values will be stored in. A completer is a value that may be part of the instruction. For example, a completer may specify the size of SIMD subregister(s) used. An instruction may have one or more completers. In one embodiment, where \u201csz\u201d is the completer, the bunpk instruction may be in the form of:\n\nbunpksz s2=s1,r1\n","As a specific example using the form above:\n\nbunpk2 s2=s1,r1,\n\nassuming the value stored in r1 is three, and upon execution of the example, 3-bit values stored contiguously in register s1 may be unpacked into the 2-byte subregisters in s2. Each subregister in s2 may be to be 2 bytes for this instruction because the completer in this example is \u201c2\u201d. For example, assume <110 100 111> is stored in register s1. Upon execution of this instruction, the bits stored in the first subregister in s2 would be <1100 0000 0000 0000>, the bits stored in the second subregister in s2 would be <1000 0000 0000 0000>, and the bits stored in the third subregister in s2 would be <1110 0000 0000 0000>.\n","Alternatively, the second parameter s1 may be the immediate value that represents the packed bits. For example, if 0x01CB is the hexadecimal representation of <110 100 111>, then,\n\nbunpk2 s2=0x01CB,r1,\n\nmay yield the same result as the first example above, in register s2.\n","In other embodiments, other operands and completers may indicate how the unpacked values may be stored in each subregister. For example, an operand may indicate whether unpacked values should be aligned right or left in a subregister, or the endianness of the data in a register.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 1","FIG. 1"]},"SIMD register  comprises subregister , subregister , and subregister ; although subregister  is discussed in the following example. The spaces in subregister  have been included merely to make it easier to follow particular packed bit values. The subregisters in register  may be any size; however, for purposes of giving a clear example, and in following the examples above, the subregisters in register  are sixteen bits wide.","SIMD register  comprises subregister , subregister , and subregister . The spaces in the subregisters of register  have been included merely to make it easier to follow particular packed bit values. The subregisters in register  may be any size; however, for purposes of giving a clear example, and in following the examples above, the subregisters in register  are sixteen bits wide.","In step 0: Subregister  is loaded to contain the packed bits about to be unpacked. Notice, just as in the example above, that that first three sets of bits are <110 100 111>, representing values three, one, and seven, respectively. Each value <110>, <100>, <111>, will be unpacked into a corresponding subregister in register .","In step 1: A shuffle is performed to copy the packed values into corresponding subregisters to be unpacked. For example, the entire contents of subregister , which holds the first three values, are copied and stored in subregister , subregister , and subregister , which are subregisters in SIMD register . SIMD register  comprises subregister  and subregister . The subregisters in register  may be any size; however, for purposes of giving a clear example, and in following with the examples above, the subregisters in register  are sixteen bits wide.","In step 2: A shift is performed to align each unpacked value to its respective target subregister. Accordingly, subregister  is not shifted at all since <110> is already aligned with the beginning of subregister . Subregister  is shifted three bits, such that <100> is aligned with the beginning of subregister . Subregister  is shifted six bits, such that <111> is aligned with the beginning of subregister . In the embodiment illustrated in , the values are aligned to the left. In other embodiments, alignment may be to the right. In still other embodiments, alignment be byte-aligned within the register, but may not be aligned to the beginning of the subregister.","In step 3: A mask is applied to each subregister to clear artifacts from the shuffle in step 1. For example, in subregister  the last thirteen bits contain set bits, which are artifacts from copying the entire subregister  to subregister  in step 1. Thus, a mask is applied to register , clearing the last thirteen bits in subregister . Subregister  and subregister  may be similarly masked.","Therefore at the end of step 3, and as illustrated in , the first three fixed-width bit values stored in register  are unpacked in register , such that each value is copied into, and aligned with, its own subregister.","The pseudo code below describes an embodiment of performing the bunpk instruction on a scalar processor. While the pseudo code below illustrates an embodiment, other embodiments may omit, add to, reorder, and\/or modify any portions described below.",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","tmp_bits = r1;"]},{"entry":[{},"if (tmp_bits > 1*get_completer_val (sz)) {"]},{"entry":[{},"\u2003unsupported_format_fault ( );"]},{"entry":[{},"}"]},{"entry":[{},"tmp_num_datums = sizeof(s2) \/ get_completer_val (sz);"]},{"entry":[{},"for (i=0; i < tmp_num_datums; i++) {"]},{"entry":[{},"\u2003tmp_start_pos = i * tmp_bits;"]},{"entry":[{},"\u2003tmp_lo_off = tmp_start_pos \/ 8;"]},{"entry":[{},"\u2003tmp_hi_off = (tmp_start_pos + tmp_bits) \/ 8);"]},{"entry":[{},"\u2003if (tmp_lo_off == tmp_hi_off) {"]},{"entry":[{},"\u2003\u2003tmp_res = get_1byte_simd (s1, tmp_lo_off);"]},{"entry":[{},"\u2003\u2003tmp_res = (tmp_res >> (tmp_start_pos % 8));"]},{"entry":[{},"\u2003\u2003tmp_res = (tmp_res & (~(-1 << tmp_bits)));"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003else {"]},{"entry":[{},"\u2003\u2003tmp_lo = get_1byte_simd (s1, tmp_lo_off);"]},{"entry":[{},"\u2003\u2003tmp_lo = (tmp_lo >> (tmp_start_pos % 8));"]},{"entry":[{},"\u2003\u2003tmp_lo_len = 8 \u2212 (tmp_start_pos % 8);"]},{"entry":[{},"\u2003\u2003tmp_hi = get_1byte_simd (s1, tmp_hi_off);"]},{"entry":[{},"\u2003\u2003tmp_hi_len = (tmp_bits \u2212 tmp_lo_len);"]},{"entry":[{},"\u2003\u2003tmp_res = (tmp_hi & (~(-1 << tmp_hi_len)));"]},{"entry":[{},"\u2003\u2003tmp_res = (tmp_res << tmp_lo_len) | tmp_lo;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003set_szbyte_simd(s2, i, tmp_res);"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In the pseudo code above, the least significant bit is the right most bit, and memory grows to the left. In the written description below, however, the least significant bit is the left most bit, and memory grows to the right. As shown in the pseudo code above, a serial process may be used to unpack a fixed-width-value bit-vector to a fixed-width-value byte vector. According to an embodiment, first, for each value, the bytes which the value spans may be retrieved. Second, the bytes where the value is not byte-aligned are shifted, such that the bits that represent the value are shifted to the least significant bits. Third, all bits that do not represent the value are masked or set to zero. Fourth, if the value spans more than one byte, the bytes may be joined.","As merely an example, assume five values, [A, B, C, D, E], each three bits wide, are stored in two contiguous eight-bit registers b1 and b2. By way of notation <aaa> shall be the 3-bit representation of the value A. Accordingly, in this example, b1 contains <aaabbbcc> and b2 contains <cdddeee0>. Accordingly, the following exemplary process may be carried out, in an embodiment. This example is in no way meant to be limiting. While this example discusses particular steps according to an embodiment, other embodiments may omit, add to, reorder, and\/or modify any of the steps below, based, at least in part, on the employer, candidates available, and the particular methods used.","In step 1: An iterative loop is defined to iterate over each value in the bit-vector. For example, an iterative loop is defined such that an iteration value, iter, begins at zero and is iteratively incremented by three, since each value is three bits in this example.","In step 2: A low-byte is be determined. A low-byte may be determined by integer-dividing the current value of iter by the width of the destination byte in the byte-vector. For example, in the third iteration, to unpack C, represented by the last two bits in register b1, and the first bit in register b2, the low-byte may be determined by integer-dividing the current value of iter, which in this example is six, by the width of the destination byte, which in this example is eight. Thus, the low-byte for value C in this example is zero, since the integer-division of six by eight equals zero.","In step 3: A high-byte is determined. A high-byte may be determined by summing: the current value of iter, with the width of the packed value; and, integer-dividing the sum by the width of the destination byte in the byte-vector. For example, in the third iteration, which unpacks C, the high-byte may be determined by summing of the current value of iter by the width of the bit-value, which in this example equals nine; and, integer-dividing the sum by the width of the destination byte, which in this example is eight. Thus, the high-byte in this example is one, since the integer-divide of nine by eight equals one.","In step 4: If the low-byte is equal to the high-byte, then the whole value is stored within a single byte and the process proceeds to step 5. Alternatively, if the low-byte is less than the high-byte, then the value is partially represented in the low-byte and partially represented in the high-byte and proceeds to step 6.","In step 5: The value is unpacked from the low-byte. For example, if unpacking B from b1 to result register Res, then the contents of b1 may be stored in Res. Thus, Res would be <aaabbbcc>. Res may then be left-shifted by iter, which in this example is three. Thus, Res would be <bbbcc000>. A mask may then be created to remove the bits that do not represent B, by performing a bitwise NOT of the quantity, negative-one, right-shifted by the size B, which in this example is three. Thus, the mask would be <11100000>. Finally, the mask may be applied to Res by performing a bitwise AND between Res and the mask. Thus, Res would equal <bbbcc000>. Since the entire value was in the low-byte, control returns to process the next iteration.","In step 6: The value is unpacked. If the low-byte and the high-byte are the same byte, the value may be extracted from the low-byte alone. Alternatively, the bits that represent the value in the low-byte, the high-byte, and the bytes between, may be extracted and joined.","For example, in the third iteration, which unpacks C, the low-byte, b1, is loaded in a temporary register, TmpLow, which in this example is presumed to be the same size as b1. Specifically, TmpLow would contain <aaabbbcc>. TmpLow is shifted left by iter modulo the width of Reg, which in this case would be six bits. Thus, TmpLow would be <cc000000>.","The length of the bits used from TmpLow, denoted as TmpLowLength, is computed by computing the difference between the width of TmpLow and number of bits shifted left. Thus, TmpLowLength is equal to eight minus six, which equals two.","TmpHighLength is computed by computing the difference between the widths of the packed bits, which in this example is three, and the TmpLowLength. Thus, in this example, TmpHighLength is equal to three minus two, which equals one.","To unpack the bits in the high-byte, the high-byte, b2, is loaded in a temporary register, TmpHigh, which in this example is presumed to be the same size as b2. Specifically TmpHigh would contain <cdddeee0>.","A mask, TmpHighMask, is created by storing negative-one in a register and right-shifting TmpHighMask by TmpHighLength. Thus, TmpHighMask would be <10000000>.","The mask is applied to TmpHigh by performing a bitwise AND between TmpHigh and TmpHighMask. Thus, TmpHigh would be <c0000000>.","The final result is stored in a result register, Res, by right-shifting TmpHigh by TmpLowLength, and performing a bitwise OR between TmpLow and TmpHigh. Since, in this case, TmpLowLength equals two, after right-shifting TmpHigh by TmpLowLength, TmpHigh would be <00c00000>. Thus, after performing the bitwise OR, Res would be the product of <cc000000> OR<00c0000>, which is <ccc00000>.","A SIMD instruction, variable-length byte unpack (\u201cvlbunpk\u201d), may be used to unpack variable-length byte values into fixed-width bytes. To efficiently use some SIMD instructions, each value in a register may be stored in fixed-width bytes. Accordingly, this instruction may be used as an enabler for some subsequent SIMD processing by storing each variable-length byte value as a fixed-width byte value.","Specifically, executing this instruction stores each value, originally packed in a series of variable-length contiguous bytes in a SIMD register, into contiguous fixed-length subregisters in a SIMD register. For example, the values 1555343273, 59107, 44, and 15937781 may be represented in four bytes, two bytes, one byte, and three bytes, respectively. For example, [0x5CB4A7A9, 0xE6E3, 0x2C, 0xF330F5] may be loaded in a first SIMD register. After performing the vlbunpk instruction on the first register, each value may be represented in contiguous fixed-width subregisters. For example, [0x5CB4A7A9, 0x0000E6E3, 0x000000002C, 0x00F330F5], such that each value is stored in a separate contiguous SIMD subregister.","Since the length of each value in the original packed representation is variable, another register may contain a set of corresponding values that indicate the length of each variable-length packed value. Continuing with the example above, a separate register may contain four values, e.g., [4, 2, 1, 3], which are the byte-lengths of each corresponding variable-length value. The lengths for each of the values in this register may be defined, or based, on an operand or completer included with the instruction.","To ensure each of the packed variable-length values may be represented within the unpacked fixed-width representation, each value is represented with same number of bytes as the greatest value in the packed variable-length values. Thus, as exemplified above, the values 0x5CB4A7A9, 0xE6E3, 0x2C, and 0xF330F5 may each be represented using four bytes after executing the vlbunpk instruction, e.g., 0x5CB4A7A9, 0x0000E6E3, 0x000000002C, and 0x00F330F5.","In an embodiment, the instruction may take as operands: a first register that the unpacked fixed-length values will be stored in; a second register containing the variable-length byte values; and a third register with corresponding values that represent the number of bytes used to represent each packed variable-length value in the second register. Furthermore, a completer may be included to define the length of the resulting unpacked fixed-length values, and the number of bits needed to represent each value in the third subregister. For example:\n\nvlbunpk4 s2=s1,r1\n","In the example instruction above, packed variable-length contiguously stored values in s1, with corresponding length values stored in r1, may be unpacked into fixed-width 4-byte representations stored in s2. For example, assume the packed variable-length representations of values [0x5CB4A7A9, 0xE6E3, 0x2C, 0xF330F5] are stored in register s1, and corresponding lengths [4, 2, 1, 3] are stored in register r1. Upon execution of this instruction, 4-byte representations of each value are stored in register s2, such that each of the values in [0x5CB4A7A9, 0x0000E6E3, 0x000000002C, 0x00F330F5] in s2 is stored in its own contiguous subregister. In other embodiments, other operands and completers may indicate how the values are unpacked or stored in a register or memory.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIG. 2","FIG. 2"]},"In step 0: In preparation for the vlbunpk instruction, the packed variable-length values are loaded into register , and the corresponding lengths are loaded into register . For example, SIMD register  contains four packed variable-length values, [0x5CB4A7A9, 0xE6E3, 0x2C, 0xF330F5].","SIMD register  contains the corresponding lengths for each of the values stored in register . Specifically, register  includes [4, 2, 1, 3]. In an embodiment the length of the values in register  are based on the completer of the instruction. For example, if the completer is set to four, as in the example above, then two bits may be used to describe all the possible lengths of each of the values in register . For example, [4, 2, 1, 3] may be represented as [<11>, <10>, <00>, <01>].","In step 1: The instruction is performed by storing the variable-length byte values in register , into register , according to the values stored in register . For example, register  comprises subregister , subregister , subregister  and subregister . The subregisters in register  may be any size; however, for purposes of giving a clear example, and in keeping with the examples above, the subregisters in register  are four bytes wide. A copy of the first four bytes of register  (based on the first two bits, <11>, in register ), is stored in subregister . This copy is a perfect size match, and so nothing further may be required. Accordingly, subregister  may contain 0x5CB4A7A9, which is a four-byte representation of 0x5CB4A7A9.","A copy of next two bytes of register  (based on the next two bits, <10>, in register ), are copied to subregister . However, when the two bytes from register  are copied to subregister , the value  is zero-extended to fit in the target subregister . Thus, subregister  may contain 0x0000E6E3. Alternatively, the value may be sign-extended. In yet another alternative, the bytes are merely copied into the first two bytes of subregister ; but, subregister  may have been previously cleared, so as not to have any artifacts from previous values stored in subregister .","Likewise, the next byte of register  (based on the next two bits, <10>, in register ) is copied into subregister , zero-extended. Also likewise, the next three bytes of register  (based on the next two bits, <01>, in register ) is copied into subregister , zero-extended. Accordingly, subregister  and subregister  may contain [0x000000002C, 0x00F330F5].","Accordingly, after performing the instruction, register  may contain the unpacked fixed-length values [0x5CB4A7A9, 0x0000E6E3, 0x000000002C, 0x00F330F5], in contiguous subregisters  through .","The pseudo code below describes an embodiment of performing the vlbunpk instruction on a scalar processor, using the operands and completers defined in the sections above. While the pseudo code below illustrates an embodiment, other embodiments may omit, add to, reorder, and\/or modify any portions described below.",{"@attributes":{"id":"p-0076","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"tmp_num_codes = sizeof(s2) \/ get_completer_val(sz);"},{"entry":"tmp_len_mask = (get_completer_val(sz) <= 4) ? 0x3 : 0xf;"},{"entry":"tmp_len_shift = (get_completer_val(sz) <= 4) ? 2 : 4;"},{"entry":"tmp_from_offset = 0;"},{"entry":"for (i=0; i < tmp_num_codes; i++) {"},{"entry":"\u2003tmp_code_len = r1 & tmp_len_mask;"},{"entry":"\u2003tmp_code = extract_bytes_simd(s1, from_offset, tmp_code_len);"},{"entry":"\u2003set_szbyte_simd(s2, i, tmp_code);"},{"entry":"\u2003tmp_from_offset += tmp_code_len;"},{"entry":"\u2003r1 = r1 >> tmp_len_shift;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"As merely an example, to explain the pseudo code above in further detail, the following description is given. The values and steps used are merely for purposes of illustrating a clear example, and are in no way intended to be limiting.","Assume for purposes of example, that s1 includes the variable-length values [A, B, C, D]. Furthermore assume that the lengths of each of the values in s1 is stored in r1 using a two-bit representation, e.g., [<11>, <01>, <00>, <01>], representing [4, 2, 1, 3].","Starting at the beginning of the first iteration through the for-loop: First, the length of the first packed value, A, is retrieved from r1 by masking all the bits except the first two. Second, the value, A, is extracted from s1 using an offset into s1, which in the first iteration is set to zero, and the two-bit value retrieved from r1, which is <11>, and maps to four. Third, the first four bytes of s1 are extracted and stored in s2 in a four-byte chunk, as designated by the completer sz in the set_szbyte_simd function.","The first iteration ends by preparing for the next iteration. Specifically, the offset into s1 is incremented by the number of bytes extracted. Thus, the offset is updated to four, since four bytes were retrieved in the first iteration. Furthermore, the two bits in r1 that represented the length of the first value in s1 are shifted out. Thus the next two-bit value, which corresponds to the second value in s1, sits at the front of r1 to be used in the next iteration.","Starting again at the beginning of the second iteration through the for-loop: First, the length of the second packed value, B, is retrieved from r1 by masking all the bits except the first two. Second, the value, B, is extracted from s1 using the offset into s1, which in this second iteration is set to four, and the two-bit value retrieved from r1, which is <01>, maps to two. Third, the next two bytes of s1 are extracted and stored in s2 in a four-byte, as designated by the completer sz in the set_szbyte_simd function.","The second iteration ends by preparing for the next iteration. Specifically, the offset into s1 is incremented by the number of bytes extracted. Thus, the offset is updated to six, since two more bytes were retrieved in the second iteration. Furthermore, the two bits in r1 that represented the length of the second value in s1 is shifted out. Thus the next two-bit value, which corresponds to the third value in s1, sits at the front of r1 to be used in the next iteration.","The third and fourth iterations proceed similarly as described above in the first two iterations. After all four iterations, the values A, B, C, D are unpacked and stored, [A, B, C, D], in s2 in fixed-length four-byte format.","A SIMD instruction, burst, may be used to decompress a run length encoded (\u201cRLE\u201d) compressed bit-vector. An RLE compressed bit-vector is a bit-vector with a corresponding run-vector, such that each bit in the bit-vector has a corresponding run value in the run-vector. Each run value in the run-vector indicates how many bits the corresponding bit in the bit-vector should be extended. For example, if a compressed bit-vector <10> has a corresponding run-vector, [2, 6], then, in the decompressed bit-vector may be <11000000>.","This instruction may be complicated because, depending on the run values, writes into the result register or memory may be too large for a single instruction. Accordingly, the execution of a burst instruction may also update the operands of the instruction to reflect the current state, such that a subsequent execution of the burst instruction will resume where the previous execution left off.","In an embodiment, the burst instruction may take the following form, and may operate on a particular number of bytes each time the instruction is executed:\n\nburst[r1]=r2,r3,r4\n","In the embodiment above, r1 is a pointer into memory indicating the byte at which the resulting decompressed bit-vector should be stored; r4 is the offset within the byte pointed to by r1, at which the resulting decompressed bit-vector should be stored. Furthermore, r2 is a pointer into memory indicating the byte at which the compressed bit-vector is stored. Further still, r3 is a pointer into memory indicating the byte at which the run-vector may be stored.","The following process may take place each time the burst instruction embodied above is executed:","In step 1: X numbers of bits from a compressed bit-vector are loaded, and X numbers of bytes from a corresponding run-vector are loaded. For example, r2 contains the address of a compressed bit-vector in memory, and r3 may contain the address of a corresponding run-vector in memory. Accordingly, the first two bytes (sixteen bits) of the bit-vector may be loaded into a first register and the first sixteen bytes of the run-vector are loaded into a second register. For purposes of illustrating a clear example, assume that <1010 1010 1010 1010> is loaded into the first register; and [2,3,2,3, 2,3,2,3, 2,3,2,3, 2,3,2,3] is loaded in the second register.","In step 2: The loaded bit-vector is decompressed based on the loaded corresponding run-vector. For example, the compressed bit-vector in the first register is decompressed based on the corresponding run-vector loaded in the second register. The resulting decompressed bit-vector may be stored in a third register. Thus, the third register may contain the decompressed bit-vector, <11 000 11 000 11 000 11 000 11 000 11 000 11 000 11 000>.","In step 3: The decompressed bit-vector is stored in memory. For example, the value loaded in the third register is stored in memory at the byte r1 addresses, offset by the value in r4.","In step 4: The operands are updated such that a subsequent execution of the burst instruction will \u201cautomatically\u201d: 1) load the next contiguously stored bits in the compressed bit-vector; 2) load the next contiguously stored corresponding run values in the run-vector; and 3) store the results contiguously with the results stored in step 3. The word \u201cautomatically\u201d here means that the operands need not be updated before a subsequent burst instruction is executed. Thus, continuing with the current example: 1) r2 is incremented by two, to point to the next contiguous bits in the compressed bit-vector in memory; 2) r3 is incremented by sixteen, to point to the next contiguous corresponding run values in the run-vector in memory; and 3) r1 is incremented by five, to point to the next contiguous location in memory that the next resulting decompressed bit-vector should be stored; r4, however, remains unchanged since forty (the number of bits in five bytes) modulo eight is zero.","Accordingly, the operands of the burst instruction will reflect the current state, such that subsequent executions of the burst instruction will resume where the previous execution left off.","In an embodiment, the burst instruction may take the following form, and may process up to a particular number of bytes each time the instruction is executed:\n\nburst[r1]=r2,s1,r4\n","In the embodiment above, r1 is a pointer into memory indicating the byte at which the resulting decompressed bit-vector should be stored; r4 is the offset within the byte pointed to by r1, at which the resulting decompressed bit-vector should be stored. Furthermore, r2 is a register that contains the compressed bit-vector. And, s1 is a SIMD register holding the run values of the corresponding run-vector.","The following process may take place each time the burst instruction embodied above is executed. However, in this form, it is not always guaranteed that the burst instruction will complete the decompression for the bit-vector stored is r2. Accordingly, the following process may take different steps, than the process above, in order to resume execution where the previous execution left off:","In step 1: The loaded bit-vector is decompressed based on the loaded corresponding run-vector. For purposes of illustrating a clear example, assume that <1010 1010 1010 1010> is loaded into r2; and [2,3,2,3, 2,3,2,3, 2,3,2,3, 2,3,2,3] is loaded in s1. However, assume for purposes of explanation that the result register is four bytes wide. Thus, when the compressed bit-vector in r2 is decompressed based on the corresponding run-vector loaded in s1, a partial decompressed bit-vector may be stored in the result register. In this example, the full decompressed bit-vector cannot be stored in the result register since in this example the result register is four bytes wide, and the entire decompressed bit-vector is five bytes wide. Thus, the result register may contain the partially decompressed bit-vector, <11 000 11 000 11 000 11 000 11 000 11 000 11>.","In step 2: The partially decompressed bit-vector is stored in memory. For example, the value loaded in s1 is stored in memory at the byte r1 addresses, offset by the value in r4.","In step 3: The operands are updated such that a subsequent execution of the burst instruction will \u201cautomatically\u201d: 1) resume decompressing the bit-vector in r2 based on the corresponding run-vector in s1; and 2) the results will be stored contiguously with the results stored in step 2. The word \u201cautomatically\u201d here means that the operands need not be updated before a subsequent burst instruction is executed to resume processing of the currently loaded compressed bit-vector. Thus, continuing with the current example: 1) [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,3,2,3] is stored in s1 to reflect the compressed bits that were not fully decompressed; and 2) r1 is incremented by four, to point to the next contiguous location in memory that the next resulting decompressed bit-vector should be stored; r4, however, remains unchanged since thirty-two modulo eight is zero.","Accordingly, the operands of the burst instruction will reflect the current state, such that subsequent executions of the burst instruction will resume where the previous execution left off.",{"@attributes":{"id":"p-0101","num":"0100"},"figref":["FIG. 3","FIG. 3"]},"Register  corresponds with register r2 and contains a compressed bit-vector comprising one or more bits in step 1. Specifically, register  contains the compressed bit-vector <1010 1010 1010 1010>.","SIMD register  corresponds to SIMD register s1 and contains the run-vector stored in s1. SIMD register  comprises a series of subregisters, such that each subregister stores a run value in the run-vector in step 1. Specifically, register  comprises: subregister , which contains the first run value, two; subregister , which contains the second run value, three; subregister , which contains the third run value, two; and subregister , which contains the fourth run value, three. As indicated, register  contains further subregisters not illustrated in .","Register  corresponds to the result register and contains the partially decompressed bit-vector at the end of step 1. Specifically, register  contains the first four bytes of the decompressed bit-vector <1100 0110 0011 0001 1000 1100 0110 0011>.","After performing the Burst instruction, register  may contain the decompressed bit-vector. Alternatively, the decompressed bit-vector may be stored, or partially stored, in memory .","Memory  may be on-chip cache located on a processor. Alternatively memory  may be off-chip cache, or main memory. Memory  may store full or partial decompressed bit-vectors stored register  as described in step 2 above.","The pseudo code below describes an embodiment of performing the burst instruction on a scalar processor, similarly using the operands and completers defined in the sections above as variables. While the pseudo code below illustrates an embodiment, other embodiments may omit, add to, reorder, and\/or modify any portions described below.",{"@attributes":{"id":"p-0108","num":"0107"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"if (memory_form) {"},{"entry":"\u2003tmp_in = load_2bytes(r2);"},{"entry":"\u2003for (i=0; i < 16; i++) {"},{"entry":"\u2003\u2003tmp_bit = tmp_in & 0x1;"},{"entry":"\u2003\u2003tmp_run_len = load_1byte (r3);"},{"entry":"\u2003\u2003burst_bit (tmp_bit, tmp_run_len, r1, r4);"},{"entry":"\u2003\u2003tmp_in >>= 1;"},{"entry":"\u2003\u2003r4 = (r4 + tmp_run_len) % BIT_VECTOR_CHUNK_SIZE_IN_BITS;"},{"entry":"\u2003\u2003r1 += tmp_run_len \/ BIT_VECTOR_CHUNK_SIZE_IN_BITS;"},{"entry":"\u2003}"},{"entry":"} else {"},{"entry":"\u2003for (i=0; i < 16; i++) {"},{"entry":"\u2003\u2003tmp_bit = (r2 >> i) & 0x1;"},{"entry":"\u2003\u2003tmp_run_len = get_1byte_simd(s1, i);"},{"entry":"\u2003\u2003tmp_runs_written ="},{"entry":"\u2003\u2003\u2003burst_bit_8 (tmp_bit, tmp_run_len, r1, r4);"},{"entry":"\u2003\u2003r4 = (r4 + tmp_runs_written) % BIT_VECTOR_CHUNK_SIZE_IN_"},{"entry":"\u2003\u2003BITS;"},{"entry":"\u2003\u2003r1 += tmp_runs_written \/ BIT_VECTOR_CHUNK_SIZE_IN_BITS;"},{"entry":"\u2003\u2003if (tmp_runs_written != tmp_run_len)"},{"entry":"\u2003\u2003\u2003set_1byte_simd (s1, i, tmp_run_len \u2212 tmp_runs_written);"},{"entry":"\u2003\u2003\u2003return;"},{"entry":"\u2003\u2003} else {"},{"entry":"\u2003\u2003\u2003set_1byte_simd (s1, i, 0);"},{"entry":"\u2003\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"A SIMD instruction, onesidx, may be used to return the index of each bit set to one in a bit-vector. For example, if an operand contains the bit-vector <1000 0100 0111 0000>, then upon successful completion of the onesidx, a SIMD register may contain the index of each bit set to one in each subregister, e.g., [0, 5, 9, 10, 11].","This instruction may be complicated because, depending on the number of bits set to one, writes into the result register may be too large for a single instruction. Accordingly, the execution of a onesidx instruction may also update the operands of the instruction to reflect the current state, such that a subsequent execution of the onesidx instruction will resume where the previous execution left off.","In an embodiment, the onesidx instruction may take the following form, and may find up to a particular number of indexes each time the instruction is executed:\n\nonesidxsz.btype s1=r1,r2,r3\n","In the embodiment above, the register r1 may be the byte address in memory to begin searching a bit-vector, and r2 may be the offset with the byte r1 points to, to begin searching.","The SIMD register s1 may include a series of subregisters, each of which may store an index value. The byte size of each subregister in s1 may be defined by the sz completer. The register r3 may contain the number of indexes found during execution. The btype completer may be the upper bound on the number of bytes to be searched. For example, \u201ccache\u201d may indicate that an entire cache line, starting at the byte r1 points to, should be searched. Similarly, \u201cpage\u201d may indicate that an entire page, starting at the byte r1 points to, should be searched. For example, onesidx1.cache s1=r1, r2, r3, may instruct the processor to: 1) search the bits in memory starting at the byte in memory that r1 addresses, offset by the value stored in r2, through to the end of the cache line; 2) store the index of each bit set to one in a one-byte subregister located in s1; and 3) store the number of indexes found in r3. In other embodiment completer btype may be a number indicating the number of bytes to be searched.","In this embodiment, execution of the onesidx instruction may terminate if either s1 is filled to capacity or the bits in the bit-vector are searched. Thus, it is not always guaranteed that the onesidx instruction will complete the search of the bit-vector in memory. Accordingly, the following process may take place each time the onesidx instruction embodied above may be executed:","In step 1: The bit-vector is loaded from memory into a first register. For purposes of illustrating a clear example, assume that <1000 0100 0111 0000> is loaded into a first register, based on the memory address stored in r1.","In step 2: The loaded bit-vector is searched, starting at the offset stored in r2; the indexes are stored in a SIMD register; and the number of indexes found is updated. For purposes of explanation, assume that r2 is set to zero, the SIMD register, s1, is one four bytes long and each subregister is one byte. As the bit-vector in the first register is searched, the index of each bit set to one is stored in a subregister in s1, until s1 is full. Furthermore, each index stored in s1 increments the value in r3. Since s1 is not wide enough to hold all the index values, step 2 terminates when [0, 5, 9, 10] is stored in s1, and the value four is stored in r3.","In step 3: The operands r1 and r2 are updated, such that a subsequent execution of the onesidx instruction \u201cautomatically\u201d resumes indexing the bit-vector in memory. Here, \u201cautomatically\u201d here means that that the operands need not be updated before a subsequent onesidx instruction is executed to resume processing of the bit-vector stored in memory. Thus, continuing with the example, r1 is incremented by two, in order to point to the byte where searching terminated. Furthermore, r2 is set to three, to indicate that the fourth bit where searching should be resumed.","Accordingly, the operands of the onesidx instruction will reflect the current state, such that subsequent execution of the onesidx instruction will resume where the previous execution left off.","In an embodiment, an operand may indicate where in memory the indexes stored in s1 should be stored. Furthermore, the operand may be updated in step 3, such that in subsequent executions the index values are contiguously stored automatically.","In another embodiment, the bit-vector may reside in r1. Accordingly, the value stored in r2 may indicate which bit in r1 searching should begin. Furthermore, at the end of step 3, r2 may be updated, such that subsequent execution of the onesidx instruction will resume where the previous execution left off.",{"@attributes":{"id":"p-0121","num":"0120"},"figref":["FIG. 4","FIG. 4"]},"SIMD register  may contain a bit-vector comprising one or more bits loaded from memory. In keeping with the example above, register  includes the bit-vector <1000 0100 0111 0000>. As indicated, register  may contain more bits, but those bits are not illustrated in this example.","SIMD register  corresponds to s1 in the example above and may be series of subregisters, such that the value stored in each subregister may be the offset of a bit set to one in register . Specifically, register  comprises subregister , subregister , subregister , and subregister , which are the offsets for the first four bits in register  set to one, respectively. In keeping with the example above, after performing the onesidx instruction, register  may contain offset values [0, 5, 9, 10], based of one or more bits set to one in register . Specifically, the values 0, 5, 9, and 10, are stored in subregister , subregister , subregister , and subregister , respectively.","Memory  may be on-chip cache located on the SIMD processor. Alternatively memory  may be off-chip cache, or main memory. Memory  may contain the bit-vector loaded into register , as described in step 1 above.","The pseudo code below describes an embodiment of performing the onesidx instruction on a scalar processor, using the similarly using the operands and completers defined in the sections above as variables. While the pseudo code below illustrates an embodiment, other embodiments may omit, add to, reorder, and\/or modify any portions described below.",{"@attributes":{"id":"p-0126","num":"0125"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","r3 = 0;"]},{"entry":[{},"for (i=0; i < get_completer_val(btype); i++) {"]},{"entry":[{},"\u2003tmp_byte = load_1byte(r1);"]},{"entry":[{},"\u2003if (i == 0) {"]},{"entry":[{},"\u2003\u2003tmp_byte = (tmp_byte >> r2) << r2;"]},{"entry":[{},"\u2003\u2003r2 = 0;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003for (j=0; j < 8; j++) {"]},{"entry":[{},"\u2003\u2003if (tmp_byte & 0x1) {"]},{"entry":[{},"\u2003\u2003\u2003set_szbyte_simd(s1, r3, r2);"]},{"entry":[{},"\u2003\u2003\u2003r3 += 1;"]},{"entry":[{},"\u2003\u2003\u2003if (r3 == (sizeof(s1) \/ get_completer_val(sz))) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003r2 = (r2 + 1) % 8;"]},{"entry":[{},"\u2003\u2003\u2003\u2003r1 = ((r2 == 0) ? r1 + 1 : r1);"]},{"entry":[{},"\u2003\u2003\u2003\u2003return;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003tmp_byte >> 1;"]},{"entry":[{},"\u2003\u2003r2 += 1;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003r1 += 1;"]},{"entry":[{},"}"]},{"entry":[{},"r2 = 0;"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A SIMD instruction, gatherb, may be used to fetch the value of bits stored in a bit-vector indexed by an index-vector. The results may be stored many different formats. For example, the result could be a bit-mask, wherein each bit represents the value of the corresponding bit fetched in the bit-vector, and zero otherwise. Alternatively, the result may be a series of subregisters where each subregister indicates the value of the corresponding bit fetched.","In one embodiment, the gatherb instruction may include three operands. The first operand may contain an input bit-vector. The second operand may contain an index-vector. And, the third operand may contain the result after the gatherb instruction has been executed.","In an embodiment, upon execution of the gatherb instruction, a bit mask may be stored which describes the values of the bits fetched. Furthermore, the gatherb instruction may take the following form:\n\ngatherbsz r2=s1,r1\n","Specifically, in the embodiment above, r1 may be a register that stores a bit-vector. The register s1 may be a SIMD register, which may contain the index-vector, such that each subregister in s1 may contain an index value. The completer sz may indicate the size of each subregister in s1. The resulting bit-mask is stored in r2.","For example, assume that the bit-vector <0101 1100 1110 0001> is loaded in r1; the index-vector [1, 5, 10, 13] is loaded in s1, and the size of each subregister in s1 is one byte; and a bit-mask <0000 0000 0000 0000> is loaded in r2. Upon execution of gatherb1 r2=s1, r1, the values of the bits in the bit-vector, at the indexed locations, are copied into the corresponding bits in r2. Thus, r2 may contain the bit-mask <0100 0100 0010 0000>. In an embodiment, r2 may be cleared as an initial step when executing the gatherb instruction, such that artifacts from previously stored bits in r2 are cleared before storing copies of the indexed bits in r2.","In an embodiment, upon execution of the gatherb instruction, the bit values stored in the bit-vector, indexed by the index-vector, may be stored, sign extended, in a series of subregisters corresponding to each index value in the index-vector. Furthermore, the gatherb instruction may take the following form:\n\ngatherb.cmb s2=s1,r1\n","Specifically, in the embodiment above, r1 may be a register that stores a bit-vector. The register s1 may be a SIMD register, which may contain the index-vector, such that each subregister in s1 may contain an index value. The register s2 may be a SIMD register, which may contain a series of subregisters, which each correspond to a subregister in s1. The completer cmb may specify both the length of the subregisters in s1 and s2. Thus, the completer cmb may contain two numerals the first numeral indicating the size of s1 and the second numeral indicating the size of s2.","In one embodiment the numerals in the smb completer may be \u201cb,\u201d \u201cw,\u201d or \u201cd,\u201d such that \u201cb\u201d may indicate a byte size of one, \u201cw\u201d may indicate a byte size of two, and \u201cd\u201d may indicate a byte size of four. Other numerals or formats may be used in other embodiments. For example, gatherbwd s2=s1, r1, may indicate that the subregisters in s1 are each two bytes, and the subregisters in s2 are each four bytes.","For purposes of illustrating a clear example, assume that the bit-vector <0101 1100 1110 0001> is loaded in r1; the index-vector [1, 5, 10, 13] is loaded in s1. Upon execution of gatherbbb r2=s1, r1, the values of the bits at the indexed locations are copied into s2, sign extended. Thus, s2 may contain [<1111 1111>, <1111 1111>, <1111 1111>, <0000 0000>], such that each bit-vector is stored in contiguous 1-byte subregisters in r2.",{"@attributes":{"id":"p-0136","num":"0135"},"figref":["FIG. 5","FIG. 5"]},"Register  corresponds with register r1 and contains the bit-vector stored in r1. Therefore, in this example, register  contains the bit-vector <0101 1100 1110 0001>.","SIMD register  corresponds to SIMD register s1 and contains the index-vector stored in s1. SIMD register  comprises a series of subregisters, each one byte wide as indicated by the completer, such that each subregister stores an index value in the index-vector. Specifically, register  comprises subregister , which contains the first index value, one; subregister , which contains the second index value, five; subregister , which contains the third index value, ten; and subregister , which contains the fourth index value, thirteen. As indicated, register  may contain further subregisters not illustrated in .","SIMD register  corresponds to SIMD register s2 and contains the values stored in s2. SIMD register  comprises a series of subregisters, each one byte wide as indicated by the completer, such that after the gatherb instruction has executed, each subregister stores the sign-extended value of the bit in register  indexed by the respective index value in register . Specifically, subregister  contains the sign-extended value, <1111 1111>, of the second bit in register , based on the corresponding index value in subregister . Subregister  contains the sign-extended value, <1111 1111>, of the sixth bit in register , based on the corresponding index value in subregister . Subregister  contains the sign-extended value, <1111 1111>, of the eleventh bit in register , based on the corresponding index value in subregister . Subregister  contains the sign-extended value, <0000 0000>, of the fourteenth bit in register , based on the corresponding index value in subregister . As indicated, register  may contain further subregisters not illustrated in .","Alternatively, the following SIMD implementation may be used. The method below may take as input 1) a vector of codes, and b) a single SET, where a SET may be a bit-vector packed with contiguous values. For example, for a bit-vector of 5-bit codes, each code may represent a bit in the SET. Therefore, the SET may, in an example, contain 2^5=32 bits.","Specifically, two based on the size of the SIMD register, and the bit-width of the codes, either a first method, Algorithm A may be performed, or a second method, Algorithm B may be performed:","1. For a SIMD register that is N bits wide, wherein N may be 128, 256, or more;","2. Determine the length of the codes to be with K bits, e.g. 5 bit codes;","3. If 2^K is <=N, then Algorithm A may be used, otherwise algorithm B may be used.","Algorithm A:","1. Duplicate the set S (which is of size 2^K) into N\/(2^K) partitions in a SIMD register, for which thesplat operation may be used. Suppose that number is P (i.e. P partitions are used in the register). So if K=5 bits, and N=256, then P=256\/32=8.","2. Load P K-bit codes and store the codes in a SIMD register so that the codes are properly aligned within the respective partitions.","3. Use variable-shift to shift each duplicated set by the K-bit code to get the bit targeted in the little-endian position.","4. MOVEMASK to get the bits targeted into a bit-mask and then copy to a bit-vector.","Algorithm B:","1. Load the codes into a SIMD register, similar to step (2) above.","2. Divide each partition by eight to get the byte-offset where the bit is located in the SET.","3. Perform a GATHER instruction to fetch the bytes from the SET, this operations fetches each byte in parallel.","4. Perform a MOD operation of values in step (1) to get the bit offset, i.e., the bit position in the byte where the target bit we want is located.","5. Perform a variable-shift using (4) and (3) to shift the bit to the low-end position.","And, 6. MOVEMASK to take the eight 1-bit values in the 256-bit register computed from step (3) and copy to bit-vector.","Below are two example using the two algorithms previous described:","1) Splat the dictionary across 32-bit partitions in a 256-bit SIMD register, wherein a splat copies a set of bits into each subregister. Since the SET is 32-bits wide, eight copies of the SET are stored in the SIMD register. 2) Load eight 5-bit codes in a SIMD register, so that each code is aligned on a 32-bit boundary in the 256-bit register, and perform: a) SIMD LOAD; b) SHUFFLE, to get the codes in 32-bit partitions; c) Variable-Right-Shift, to shift each code to the right so that each code is aligned on the low-end of the 32-bit partition; and d) AND, mask out upper bits in each partition, so that you're just left with the code. 3) Next, apply variable-shift using the SET register from step (1) with the index register from step (2). The indexed bit is stored in the low end bit position of each 32-bit partition. 4) MOVEMASK to take the eight 1-bit values in the 256-bit register computed from step (3) and copy to the bit-vector.","Alternatively, for higher data widths, e.g. 10-bit dictionary codes or more, which may be wider than the size of the SIMD subregisters the following method may be performed: 1)","Load the codes into a SIMD register, similar to step (2) above. 2) Divide each partition by eight to get the byte-offset where the bit is located in the SET. 3) Perform a GATHER instruction to fetch the bytes from the SET, this operations fetches each byte in parallel. 4) Perform a MOD operation of values in step (1) to get the bit offset, i.e., the bit position in the byte where the target bit we want is located. 5) Perform a variable-shift using (4) and (3) to shift the bit to the low-end position. And, 6) MOVEMASK to take the eight 1-bit values in the 256-bit register computed from step (3) and copy to bit-vector.","A SIMD instruction, BitVecCmpRes, may be used to compare two value-vectors stored in two SIMD registers. Specifically, each subregister in the first SIMD register is compared to the corresponding subregister in the second SIMD register. The output may be a space efficient bit-vector stored in a result register.","In addition, in an embodiment, an offset may be included that indicates the offset within the result register the resulting bit-vector should be stored. Having an offset may allow the results of several BitVecCmpRes executions to be saved in the same bit-vector.","In an embodiment, the BitVecCmpRes instruction may take the following form:\n\nBitVecCmpResSZ r1=s1,s2,r2\n","Specifically, in the embodiment above, the register s1 may be a SIMD register that contains a first value-vector, wherein the values in the first value-vector are stored a series subregisters in s1. The register s2 may be a SIMD register that contains a second value-vector, wherein the values in the second value-vector are stored a series subregisters in s2. Each subregister in s1 has a corresponding subregister in s2 and vice versa. The completer SZ may indicate the size of each subregister in s1 and s2. The register r1 may be a register that contains the resulting bit-vector, wherein each bit in the bit-vector corresponds to corresponding subregisters is s1 and s2. Furthermore, each bit in the bit vector is set to one if the values in the corresponding subregisters in s1 and s2 match, and zero otherwise. The register r2 may contain the offset from which the resulting bit-vector should be stored in r1.","For purposes of illustrating a clear example, assume that the value-vector in s1 contains [98, 62, 21, 16] and the value-vector in s2 contains [62, 62, 21, 46]. Further assume that the value loaded in r2 is zero. Upon execution of the BitVecCmpRes1r1=s1, s2, r2, the resulting bit-vector, <0110>, may be stored in r1.","Further, assume that the values in s1, s2, and r2 are updated, such that s1 contains [14, 24, 12, 58], s2 contains [22, 76, 48, 58], and r2 contains the value four. After BitVecCmpRes1r1=s1, s2, r2 is executed a second time, r1 may contain the bit-vector <0110 0001>. The first four bits in the bit-vector stored in r1 are not clobbered by the second execution because the resulting bits from the second execution were offset by four.",{"@attributes":{"id":"p-0167","num":"0166"},"figref":["FIG. 6","FIG. 6"]},"SIMD register  corresponds to SIMD register s1 and contains the value-vector stored in s1 before the first execution of the BitVecCmpRes instruction. SIMD register  comprises a series of subregisters, each of which is one byte as indicated by the completer, such that each subregister stores a one value in the first value-vector. Specifically, register  comprises subregister , which contains the first value, ninety-eight; subregister , which contains the second value, sixty-two; subregister , which contains the third value, twenty-one; and subregister , which contains the fourth value, sixteen. As indicated, register  may contain further subregisters not illustrated in .","SIMD register  corresponds to SIMD register s2 and contains the value-vector stored in s2 before the first execution of the BitVecCmpRes instruction. SIMD register  comprises a series of subregisters, each of which is one byte as indicated by the completer, such that each subregister stores a one value in the second value-vector. Specifically, register  comprises subregister , which contains the first value, sixty-two; subregister , which contains the second value, sixty-two; subregister , which contains the third value, twenty-one; and subregister , which contains the fourth value, forty-six. As indicated, register  may contain further subregisters not illustrated in .","Register  corresponds with register r1 and contains the bit-vector stored in r1. Therefore, in this example, register  contains the bit-vector <0110> at the end of the first execution, as discussed above.","Register  corresponds with register r2 and contains the value stored in r2. Therefore, in this example, before the first execution of the BitVecCmpRes instruction, register  contains the value zero, as discussed above.","In an alternative embodiment, a completer may also designate the type of comparison made between corresponding subregisters. For example:\n\nBitVecCmpResSZ.gt r1=s1,s2,r2,\n","In the example above, the operands and SZ completer may be used similarly as discussed above. However, in this example, each bit in the bit vector is set to one if the values in the corresponding subregisters in s1 are greater than s2, and zero otherwise. Likewise, any comparative operator may be used, e.g., less than (\u201clt\u201d), less than or equal to (\u201ctle\u201d), greater than or equal to (\u201cgte\u201d), equal to (\u201ceq\u201d), not equal to (\u201cneq\u201d), and so on.","Some of the embodiments illustrated above each subregister may be four, eight, or sixteen bits wide. Other embodiments may include other widths, including, but in no way limited to four bits, eight bits, thirty-two bits, sixty-four bits.","In many examples, subregisters may be one byte. However, subregisters may be larger or smaller than one byte. Furthermore, a default width, an operand, or a completer may be used to define the width of the subregisters for a particular instruction.","In some of the embodiments illustrated and discussed above, the least significant bits were illustrated on the left side of registers or memory, the sign bit was illustrated on the right side, and bits or bytes were padded or shifted to one particular side. However, the examples included above are not intended to be limiting. The instructions discussed above may be implemented on many various hardware configurations that are different than those illustrated.","While the methods described above may be focused on a SIMD architecture, these methods may also be implemented on a scalar or other non-SIMD processor. The methods may also be included as part of an application programming interface. Furthermore the methods may implemented as an intrinsic, which may be a function a compiler recognizes and replaces with a particular block of assembly or machine code. Further still, one or more instructions may be stored on one or more non-transitory computer-readable mediums, which when executed by one or more processors, may cause one or more of the methods described herein to be performed.","In many of the examples, a SIMD register comprises four subregisters. This is not intended to be limiting in any way. SIMD registers may comprise more or fewer subregisters, all of which may be varying widths.","In an embodiment memory grows is the address increases. In another embodiment memory grows as the address decrements. Accordingly, any of the instructions may also include a completer or operand that indicates which direction memory is grows.","According to one embodiment, the techniques described herein are implemented by one or more special-purpose computing devices. The special-purpose computing devices may be hard-wired to perform the techniques, or may include digital electronic devices such as one or more application-specific integrated circuits (ASICs) or field programmable gate arrays (FPGAs) that are persistently programmed to perform the techniques, or may include one or more general purpose hardware processors programmed to perform the techniques pursuant to program instructions in firmware, memory, other storage, or a combination. Such special-purpose computing devices may also combine custom hard-wired logic, ASICs, or FPGAs with custom programming to accomplish the techniques. The special-purpose computing devices may be desktop computer systems, portable computer systems, handheld devices, networking devices or any other device that incorporates hard-wired and\/or program logic to implement the techniques.","For example,  is a block diagram that illustrates a computer system  upon which an embodiment of the invention may be implemented. Computer system  includes a bus  or other communication mechanism for communicating information, and a hardware processor  coupled with bus  for processing information. Hardware processor  may be, for example, a general purpose microprocessor.","Computer system  also includes a main memory , such as a random access memory (RAM) or other dynamic storage device, coupled to bus  for storing information and instructions to be executed by processor . Main memory  also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor . Such instructions, when stored in non-transitory storage media accessible to processor , render computer system  into a special-purpose machine that is customized to perform the operations specified in the instructions.","Computer system  further includes a read only memory (ROM)  or other static storage device coupled to bus  for storing static information and instructions for processor . A storage device , such as a magnetic disk or optical disk, is provided and coupled to bus  for storing information and instructions.","Computer system  may be coupled via bus  to a display , such as a cathode ray tube (CRT), for displaying information to a computer user. An input device , including alphanumeric and other keys, is coupled to bus  for communicating information and command selections to processor . Another type of user input device is cursor control , such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to processor  and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the device to specify positions in a plane.","Computer system  may implement the techniques described herein using customized hard-wired logic, one or more ASICs or FPGAs, firmware and\/or program logic which in combination with the computer system causes or programs computer system  to be a special-purpose machine. According to one embodiment, the techniques herein are performed by computer system  in response to processor  executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory  from another storage medium, such as storage device . Execution of the sequences of instructions contained in main memory  causes processor  to perform the process steps described herein. In alternative embodiments, hard-wired circuitry may be used in place of or in combination with software instructions.","The term \u201cstorage media\u201d as used herein refers to any non-transitory media that store data and\/or instructions that cause a machine to operation in a specific fashion. Such storage media may comprise non-volatile media and\/or volatile media. Non-volatile media includes, for example, optical or magnetic disks, such as storage device . Volatile media includes dynamic memory, such as main memory . Common forms of storage media include, for example, a floppy disk, a flexible disk, hard disk, solid state drive, magnetic tape, or any other magnetic data storage medium, a CD-ROM, any other optical data storage medium, any physical medium with patterns of holes, a RAM, a PROM, and EPROM, a FLASH-EPROM, NVRAM, any other memory chip or cartridge.","Storage media is distinct from but may be used in conjunction with transmission media. Transmission media participates in transferring information between storage media. For example, transmission media includes coaxial cables, copper wire and fiber optics, including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves, such as those generated during radio-wave and infra-red data communications.","Various forms of media may be involved in carrying one or more sequences of one or more instructions to processor  for execution. For example, the instructions may initially be carried on a magnetic disk or solid state drive of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system  can receive the data on the telephone line and use an infra-red transmitter to convert the data to an infra-red signal. An infra-red detector can receive the data carried in the infra-red signal and appropriate circuitry can place the data on bus . Bus  carries the data to main memory , from which processor  retrieves and executes the instructions. The instructions received by main memory  may optionally be stored on storage device  either before or after execution by processor .","Computer system  also includes a communication interface  coupled to bus . Communication interface  provides a two-way data communication coupling to a network link  that is connected to a local network . For example, communication interface  may be an integrated services digital network (ISDN) card, cable modem, satellite modem, or a modem to provide a data communication connection to a corresponding type of telephone line. As another example, communication interface  may be a local area network (LAN) card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation, communication interface  sends and receives electrical, electromagnetic or optical signals that carry digital data streams representing various types of information.","Network link  typically provides data communication through one or more networks to other data devices. For example, network link  may provide a connection through local network  to a host computer  or to data equipment operated by an Internet Service Provider (ISP) . ISP  in turn provides data communication services through the world wide packet data communication network now commonly referred to as the \u201cInternet\u201d . Local network  and Internet  both use electrical, electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link  and through communication interface , which carry the digital data to and from computer system , are example forms of transmission media.","Computer system  can send messages and receive data, including program code, through the network(s), network link  and communication interface . In the Internet example, a server  might transmit a requested code for an application program through Internet , ISP , local network  and communication interface .","The received code may be executed by processor  as it is received, and\/or stored in storage device , or other non-volatile storage for later execution.","In the foregoing specification, embodiments of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense. The sole and exclusive indicator of the scope of the invention, and what is intended by the applicants to be the scope of the invention, is the literal and equivalent scope of the set of claims that issue from this application, in the specific form in which such claims issue, including any subsequent correction."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In the drawings:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
