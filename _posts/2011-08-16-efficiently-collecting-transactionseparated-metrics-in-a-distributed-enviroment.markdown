---
title: Efficiently collecting transaction-separated metrics in a distributed enviroment
abstract: Transaction-segregated metrics are obtained for component invocations of different transactions of an application. Corresponding tree data structures are maintained by an agent and a manager which describe sequences of invoked components of the different transactions. The start and end of each component are each represented by a node in each branch of the tree data structure. Each transaction is identified by matching a branch to a transaction trace. Gatherers are linked to one or more nodes to collect the transaction-segregated metrics. For example, metrics can be gathered separately for component invocations in different transactions. Metrics can also be gathered together for instances of different components in one or more transactions. A user interface includes a directed graph having vertices connected by edges. Edge portions are visually distinguished from one another based on the metrics of the gatherers. Each edge portion can be associated with one or more of the gatherers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08688729&OS=08688729&RS=08688729
owner: CA, Inc.
number: 08688729
owner_city: Islandia
owner_country: US
publication_date: 20110816
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","Technology for monitoring software in a computing environment is provided.","2. Description of the Related Art","The growing presence of the Internet as well as other computer networks such as intranets and extranets has brought many new applications in e-commerce, education and other areas. Organizations increasingly rely on such applications to carry out their business or other objectives, and devote considerable resources to ensuring that they perform as expected. To this end, various application management techniques have been developed.","One approach involves monitoring the infrastructure of the application by collecting application runtime data regarding the individual software components that are invoked in the application. This approach can use agents that essentially live in the system being monitored. For example, using instrumentation of the software, a thread or process can be traced to identify each component that is invoked, as well as to obtain runtime data such as the execution time of each component. Tracing refers to obtaining a detailed record, or trace, of the steps a computer program executes. One type of trace is a stack trace. Traces can be used as an aid in debugging.","Typically, transaction trace data, including static and dynamic data, is communicated from the agent to a manager. However, existing approaches are inefficient and incur substantial overhead costs.","The present invention provides a technique for monitoring software which addresses the above and other issues.","In one embodiment, one or more tangible processor-readable storage devices having computer readable software embodied thereon are provided for programming at least one processor to perform a method for monitoring at least one application, The method includes: (a) providing a tree data structure having respective branches which represent respective transactions of the at least one application, and which include nodes which represent start and end points of components of the respective transactions, where one branch of the respective branches represents one transaction of the respective transactions, and includes, linked to a first gatherer, at least one node for one component, the at least one node for the one component in the one branch represents at least one of a start and an end of one invocation of the one component in the one transaction.","The method further includes: (b) tracing the at least one application to detect one sequence of invoked components, including detecting the at least one of the start and the end of the one invocation of the one component in the one transaction, (c) using the first gatherer to gather at least one metric of the one component in a context of the first gatherer when the tracing detects the at least one of the start and the end of the one invocation of the one component in the one transaction, (d) comparing a result of the tracing to the tree data structure to determine that the one sequence of invoked components is consistent with the one branch, and (e) responsive to the determining that the one sequence of invoked components is consistent with the one branch, reporting, to a manager, the at least one metric for the one component in the context of the first gatherer.","In another embodiment, one or more tangible processor-readable storage devices having computer readable software embodied thereon are provided for programming at least one processor to perform a method for managing at least one application. The method includes receiving one or more reports from at least one agent which traces respective transactions in the at least one application, where the one or more reports include at least one metric for at least one transaction of the respective transactions and an associated identification of a first gatherer, and at least one metric for at least another transaction of the respective transactions and an associated identification of a second gatherer, the first gatherer was used to gather the at least one metric for the at least one transaction responsive to component invocations in the at least one transaction, and the second gatherer was used to gather the at least one metric for the at least another transaction responsive to component invocations in the at least another transaction.","The method further includes providing a user interface based on the one or more reports, where the user interface comprises a directed graph having vertices connected by edges, including an edge having at least a first edge portion which represents the at least one transaction and a second edge portion which represents the at least another transaction, and the first edge portion is visually distinguished from the second edge portion.","In another embodiment, one or more tangible processor-readable storage devices having computer readable software embodied thereon are provided for programming at least one processor to perform a method for monitoring at least one application. The method includes: (a) tracing respective transactions of the at least one application, the tracing detects one instance of a component in at least one transaction and another instance of the component in at least another transaction, (b) determining that the one instance of the component was detected in a context of the at least one transaction, and, separately, that the another instance of the component was detected in a context of the at least another transaction, (c) responsive to the determining that the one instance of the component was detected in the context of the at least one transaction: reporting, to a manager, at least one metric of the one instance of the component in the context of the at least one transaction, and (d) responsive to the determining that the another instance of the one component was detected in the context of the at least another transaction: reporting, to the manager, at least one metric of the another instance of the component in the context of the at least another transaction, where the context of the at least one transaction is distinct from the context of the at least another transaction.","Corresponding processor-implemented methods may be provided which perform computer-implemented steps of the one or more tangible processor-readable storage devices.","Corresponding systems may be provided which include one or more tangible processor-readable storage devices and one or more processors for reading the one or more tangible processor-readable storage devices.","Corresponding tangible computer- or processor-readable storage devices may be provided which are encoded with processor-readable instructions which, when executed, perform methods steps as provided herein.","The present invention provides a technique for monitoring software which efficiently communicates transaction trace data, including static and dynamic data, from an agent to a manager. To improve efficiency and reduce overhead costs, a tree data structure maintained by the agent and manager describes sequences of invoked components of the software. The start and end of each component is represented by a node in a branch of the tree data structure. To identify a transaction, the agent can communicate a unique identifier of the branch, such as an identifier of a last node of the branch. This allows the sequence of invoked components to be reported more efficiently from the agent to the manager. Further, static data can be indexed to one or more of the nodes or components, and accessed by the agent and\/or manager. Static data typically is fixed for a given version of software, and can also be thought of as fixed or execution-independent data. The static data can include, e.g., a class name or method name associated with the component, a sequence of method calls, a name of an archive file (such as a JAVA Archive file or .JAR file or a Web Archive file or .WAR file) from which a traced class file is deployed, a text string, a component type (e.g., servlet, EJB), a port number for a servlet or a socket, a URL, a host name, and a local or remote interface name. These are all types of information which are available from tracing the software. The indexing of the static data avoids the need to repeatedly communicate the static data from the agent to the manager, and the need for the agent and\/or manager to repeatedly obtain the static data.","Dynamic data can be obtained from a trace. Dynamic data can include start and end times of components, and other dynamic data such as a value of a parameter passed to or by a monitored method. The dynamic data can also be indexed to one or more nodes or components. The dynamic data could be indexed to the start and\/or end nodes of a component. Through this indexing, the dynamic data can be reported efficiently from the agent to the manager.","When a transaction is traced, the agent can identify a matching branch in the tree data structure. If there is no match, the agent updates the tree data structure and reports the update to the manager, so that the agent and manager can maintain synchronized versions of the tree data structure. Further, the manager can maintain a tree data structure based on reports from multiple agents, where different portions of the tree data structure are associated with different agents. The manager can also pass on an update which is received from one agent to another agent, when the agents monitor different instances of the same software. In this way, new transactions can be propagated quickly among agents so that the tree data structures of the agents are synchronized.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 1A","b":["100","103","105","109","111","107","111","103","105","101","102","101","102","103","109","103","108","102","107"]},"For example, a corporation running an enterprise application such as a web-based e-commerce application may employ a number of application servers at one location for load balancing. Requests from users, such as from the example web browser , are received via the network , and can be routed to any of the managed computing devices  and . Agent software running on the managed computing devices ,  and , denoted by Agent A (), Agent A () and Agent A (), respectively, gather information from an application, middleware or other software, running on the respective managed computing devices. Such information may be obtained using instrumentation, one example of which is byte code instrumentation. However, the gathered data may be obtained in other ways as well. The agents essentially live in the computing device being monitored and provide a data acquisition point. The agents organize and optimize the data communicated to the manager . In one implementation, different instances of the same application run at the managed computing devices  and , while another application runs at the managed computing device .","The manager  can be provided on a separate computing device such as a workstation which communicates with a user interface , such as a monitor, to display information based on data received from the agents. The manager can also access a database  to store the data received from the agents. For instance, some large organizations employ a central network operations center where one or more managers obtain data from a number of distributed agents at different geographic locations. To illustrate, a web-based e-commerce enterprise might obtain agent data from servers at different geographic locations that receive customer orders, from servers that process payments, from servers at warehouses for tracking inventory and conveying orders, and so forth. The manager  and user interface display  might be provided at a corporate headquarters location. Other applications which are not necessarily web-based or involve retail or other sales, similarly employ agents and managers for managing their systems. For example, a bank may use an application for processing checks and credit accounts. Moreover, in addition to the multi-computing device arrangements mentioned, a single computing device can be monitored as well with one or more agents.","Various approaches are known for instrumenting software to monitor its execution. For example, as mentioned at the outset, tracing may be used to track the execution of software. One example of tracing is discussed in U.S. Pat. No. 7,870,431, issued Jan. 11, 2011, titled \u201cTransaction Tracer,\u201d and incorporated herein by reference. In one approach discussed therein, object code or bytecode of an application to be monitored is instrumented, e.g., modified, with probes. The probes measure specific pieces of information about the application without changing the application's business or other logic. Once the probes have been installed in the bytecode of an application, it is referred to as a managed application, and a computing device on which the application runs is referred to as a managed computing device. The agent software receives information from the probes and may communicate the information to another process, such as at the manager , or process the information locally, such as to determine whether the information indicates an abnormal condition. The agent thus collects and summarizes information received from the probes. The probes collect information as defined by a directives file. For example, the information from the probes may indicate start and stop times of a transaction or other execution flow, or of individual components within a transaction\/execution flow. This information can be compared to pre-established criteria to determine if it within bounds. If the information is not within bounds, the agent can report this fact to the manager so that appropriate troubleshooting can be performed. The agents are typically aware of the software executing on the local managed computing device with which they are associated.","The probes can report a standard set of metrics which include: CORBA method timers, Remote Method Invocation (RMI) method timers, Thread counters, Network bandwidth, JDBC update and query timers, Servlet timers, Java Server Pages (JSP) timers, System logs, File system input and output bandwidth meters, Available and used memory and EJB (Enterprise JavaBean) timers. A metric is a measurement of a specific application activity.","An agent reports information about transactions, which identifies resources which are accessed by an application. In one approach, when reporting about transactions, the word Called designates a resource. This resource is a resource (or a sub-resource) of a parent component, which is a consumer. For example, assume that Servlet A is the first component invoked in a transaction. Under the consumer Servlet A (see below), there may be a sub-resource Called EJB. Consumers and resources can be reported by the agent in a tree-like manner. Data for a transaction can also be stored according to the tree. For example, if a Servlet (e.g. Servlet A) is a consumer of a network socket (e.g. Socket C) and is also a consumer of an EJB (e.g. EJB B), which in turn is a consumer of a JDBC (e.g. JDBC D), the tree might look something like the following:",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Servlet A"]},{"entry":[{},"\u2003\u2003Data for Servlet A"]},{"entry":[{},"\u2003\u2003\u2003\u2003Called EJB B"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003Data for EJB B"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Called JDBC D"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Data for JDBC D"]},{"entry":[{},"\u2003\u2003\u2003\u2003Called Socket C"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003Data for Socket C"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In one embodiment, the above tree is stored by the Agent in a stack, called the Blame Stack. When transactions are started, they are pushed onto the stack. When transactions are completed, they are popped off the stack. In one embodiment, each transaction on the stack has the following information stored: type of transaction, a name used by the system for that transaction, a hash map or dictionary of parameters, a timestamp for when the transaction was pushed onto the stack, and sub-elements. Sub-elements are Blame Stack entries for other components (e.g. methods, process, procedure, function, thread, set of instructions, etc.) that are started from within the transaction of interest. Using the tree as an example above, the Blame Stack entry for Servlet A would have two sub-elements. The first sub-element would be an entry for EJB B and the second sub-element would be an entry for Socket Space C. Even though a sub-element is part of an entry for a particular transaction, the sub-element will also have its own Blame Stack entry. An example of an entry point to a transaction\/branch is a URL. As the tree above notes, EJB B is a sub-element of Servlet A and also has its own entry. The top (or initial) entry (e.g., Servlet A) for a transaction, is called the root component. Each of the entries on the stack is an object.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 1B","b":["115","116","118","4","117","5","119","120","121","4","5","111","122","102","107","122"]},{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 2A","b":["130","132"]},{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Parameters","Appears in","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["UserID","Servlet, JSP","The UserID of the end-user invoking"]},{"entry":[{},{},"the http servlet request."]},{"entry":["URL","Servlet, JSP","The URL passed through to the servlet"]},{"entry":[{},{},"or JSP, not including the Query String."]},{"entry":["URL Query","Servlet, JSP","The portion of the URL that specifies"]},{"entry":[{},{},"query parameters in the http request"]},{"entry":[{},{},"(text that follows the \u2018?\u2019 delimiter)."]},{"entry":["Dynamic","Dynamic JDBC","The dynamic SQL statement, either in a"]},{"entry":["SQL","Statements","generalized form or with all the specific"]},{"entry":[{},{},"parameters from the current invocation."]},{"entry":["Method","Blamed Method","The name of the traced method. If the"]},{"entry":[{},"timers (everything","traced method directly calls another"]},{"entry":[{},"but Servlets,","method within the same component,"]},{"entry":[{},"JSP's and JDBC","only the \u201coutermost\u201d first encountered"]},{"entry":[{},"Statements)","method is captured."]},{"entry":["Callable","Callable JDBC","The callable SQL statement, either in a"]},{"entry":["SQL","statements","generalized form or with all the specific"]},{"entry":[{},{},"parameters from the current invocation."]},{"entry":["Prepared","Prepared JDBC","The prepared SQL statement, either in a"]},{"entry":["SQL","statements","generalized form or with all the specific"]},{"entry":[{},{},"parameters from the current invocation."]},{"entry":["Object","All non-static","toString( ) of the this object of the"]},{"entry":[{},"methods","traced component, truncated to some"]},{"entry":[{},{},"upper limit of characters."]},{"entry":["Class Name","All","Fully qualified name of the class of the"]},{"entry":[{},{},"traced component."]},{"entry":["Param_n","All objects with","toString( ) of the nth parameter passed"]},{"entry":[{},"WithParams","to the traced method of the component."]},{"entry":[{},"custom tracers"]},{"entry":["Primary Key","Entity Beans","toString( ) of the entity bean's property"]},{"entry":[{},{},"key, truncated to some upper limit of"]},{"entry":[{},{},"characters."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Parameters can include query, cookie, post, URL and session type name\/value pairs.","In step , the system acquires a timestamp indicating the current time. In step , a stack entry is created. In step , the stack entry is pushed onto the Blame Stack. In one embodiment, the timestamp is added as part of step . The process is performed when a transaction is started. A similar process is performed when a sub-component of the transaction starts (e.g., EJB B is a sub-component of Servlet A\u2014see tree described above).",{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 2B","FIG. 1A"],"b":["140","142","144","146","142","148","148","146","150","1","150","160","162","111"]},{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 2B"},"Note, in one embodiment, if the transaction tracer is off, the system will still use the Blame Stack; however, parameters will not be stored and no component data will be created. In some embodiments, the system defaults to starting with the tracing technology off. The tracing only starts after a user requests it, as described above.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIG. 3","FIG. 1A","FIG. 1A"],"b":["1","300","1","300","310","320","330","340","310","350","310","330","350","350"]},"A database may be included in the storage device  when the storage device  is part of a computing device  such as an application server, manager and\/or user interfaces. The storage device  can represent one or more storage devices which store data received from one or more agents, and which can be accessed to obtain data to provide a user interface as described herein. The storage device  can represent a data store.","Further, the functionality described herein may be implemented using hardware, software or a combination of both hardware and software. For software, one or more non-transitory, tangible processor readable storage devices having processor readable code embodied thereon for programming one or more processors may be used. The non-transitory, tangible processor readable storage devices can include computer readable media such as volatile and nonvolatile media, removable and non-removable media. For example, non-transitory, tangible computer readable media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Examples of non-transitory, tangible computer readable media include RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by a computer. In alternative embodiments, some or all of the software can be replaced by dedicated hardware including custom integrated circuits, gate arrays, FPGAs, PLDs, and special purpose processors. In one embodiment, software (stored on a storage device) implementing one or more embodiments is used to program one or more processors. The one or more processors can be in communication with one or more tangible computer readable media\/storage devices, peripherals and\/or communication interfaces.",{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 4"},"A top level of the hierarchy is a domain level  named \u201cDomain.\u201d A next level of the hierarchy is a Business Service level . An example of a Business Service relates to trading a stock using a web site. Thus, \u201cTrading\u201d can be the name of a node at the Business Service level of the hierarchy. A next level of the hierarchy is a Business Transaction level. A Business Service can be made up of a number of Business Transactions. For example, for Trading, the Business Transactions can include Reports  (e.g., view a report regarding a stock or an account) and Quotes  (e.g., obtain a quote for a stock price). Further, a Business Transaction can be associated with one or more Business Transaction Components. In one approach, a Business Transaction has only one identifying component. A Business Transaction Component can be a type of component of an application which is recognizable and measurable by a server, such as a servlet or EJB. In one approach, one of the components of an application is set as a Business Transaction Component, which is an identifying transaction component for a Business Transaction.","The Business Transaction Component is the identifying transaction component for the transaction that is the identifying transaction for the Business Transaction. A transaction can represent a sequence of software components which are invoked in response to a request from a client, to provide a corresponding response to the client. For example, a Business Transaction Component can be identified by determining when component data reported by an agent match a set of rules. This definition can include, e.g., a specified URL host name, URL parameters, HTTP post parameters, cookie and\/or session manager parameters. Additionally, or alternatively, the definition may require a transaction to start with a specified URL host name. The agent or manager, for instance, can compare the component data against the set of rules to determine when a Business Transaction Component is present in a Business Transaction. If a Business Transaction Component is detected, then the associated Business Transaction is of a specified type. For example, if the Business Transaction Component  is detected, then the associated Business Transaction is Reports . If the Business Transaction Component  is detected, then the associated Business Transaction is Quotes .",{"@attributes":{"id":"p-0086","num":"0085"},"figref":["FIG. 5A","FIG. 4"],"b":["1","2"]},"Component-oriented programming models are useful in allowing the programmer to assemble an application or other program from building blocks referred to as components. Each component can perform a specific function which fits in with an overall functionality of the software. Furthermore, a component can call other components, as well as calling itself, in a recursive call, so that a sequence of components is invoked in a program. One example of a component oriented programming model is J2EE, which can employ components such as a Java Server Page, an Enterprise Java Bean (EJB), a servlet, and a Java Database Connectivity (JDBC) component. JDBC is an Application Programming Interface (API) for the JAVA\u2122 programming language that defines how a client may access a database. It provides methods for querying and updating data in a database. However, other component oriented programming models such as .NET may also be used. Moreover, the programming model need not be object oriented.","This example provides details of the Reports and Quotes Business Transactions discussed previously. In one possible implementation, each component of a Business Transaction includes one or more class-method pairs. For example, a servlet is a JAVA class. It is an object that receives a request and generates a corresponding response. A class-method pair can be represented by the notation class.method. For example, Reports could include a component C () which displays a reports screen on a user interface (UI) to receive a user's input regarding a desired report. An example format of a class-method pair for C is ServletA.DisplayReportScreen. C is under a root . Thus, whenever an agent detects that C has been invoked, it concludes that the current transaction is part of Reports, and associates its component data with Reports.","C can call C () which relates to a requested report. C could include a class-method pair such as ServletA.RequestedReport which processes a user input of a requested report. This processing could include checking the format of the request, for instance, and, if the format is valid, making a call to a component C () in subsystem, which receives the report request. For instance, this call may be a cross-process, cross-thread transaction or cross-subsystem call. If the format is invalid, the control flow returns to C, which may call C to display an error message, for instance.","An example format of a class-method pair for C is ServletA.ReceiveReportRequest. C can call C () to access a database and\/or C () to access a database, such as based on the type of the report request. For example, C and C can each include a JDBC driver call which invokes one or more SQL statements. The control flow then returns to C, then to C and then to C. Subsequently, C calls C () which relates to providing a display, such as a display of the requested report based on data retrieved from the databases. The control flow then returns to C.","C could call C additional times such as to adjust the display, e.g., based on a user command to display (e.g., re-display) the report data differently (over a different time period, and so forth).","Also, under the root , a component C () can be provided which displays a quotes screen on a user interface (UI) to receive a user's input regarding a desired quote. C can call C () which relates to a requested report. C can process the user input by checking the format of the request, for instance, and if the format is valid, obtaining the requested quote, such as from a data source which is local to subsystem. If the format is invalid, the control flow returns to C, which may call C to display an error message, for instance.","The control flow then returns to C. C can call C (), which relates to providing a display, such as a display of the requested quote based on the data retrieved from the data source. C could call C additional times such as to adjust the display, e.g., based on a user command to display (e.g., re-display) the quote data differently (over a different time period, with different moving averages, and so forth).","Note that a component can continue executing after calling another component, which begins executing, in an asynchronous, multi-thread or multi-process mode. Or, a component can temporarily pause until the called component has finished executing, in a synchronous, single-thread or single-process mode. A component which is pausing can be considered to be in a wait interval, while a component which is executing can be considered to be in an active, executing mode. Also, a component may be invoked more than once during a transaction.",{"@attributes":{"id":"p-0095","num":"0094"},"figref":["FIG. 5B","FIG. 5A"],"b":["505","504","516","507","506","518"]},{"@attributes":{"id":"p-0096","num":"0095"},"figref":["FIGS. 6A-6I","FIG. 5A"]},"The transaction trace of  corresponds to blocks  and  of . A graph portion  represents C, and a graph portion  represents C. C starts executing at t and ends or stops at t. C, which is called by C, starts executing at t and ends at t.","The transaction trace of  is time-aligned with the transaction trace of , and corresponds to blocks  and  of . A graph portion  represents C, and a graph portion  represents C. C starts executing at t and ends at t. C, which is called by C, starts executing at t and ends at t.","The transaction trace of  is time-aligned with the transaction trace of , and corresponds to blocks  and  of . A graph portion  represents C, and a graph portion  represents C. C starts executing at t and ends at t. C, which is called by C, starts executing at t and ends at t. The transaction trace of  could be an alternative to the transaction trace of  if database was called instead of database, for example. The time points t-t are not necessarily the same as in . Moreover, the time points t, t, t, etc. generally do not necessarily represent equal time increments.","The transaction trace of  corresponds to blocks  and  of . A graph portion  represents C, and a graph portion  represents C. C starts executing at t and ends at t. C, which is called by C, starts executing at t and ends at t. This transaction trace could represent the case where C calls C and C determines that the format of the user request is invalid, so that the control flow returns directly to C.","The transaction trace of  corresponds to blocks  and  of . A graph portion  represents C, and a graph portion  represents C. C starts executing at t and ends at t. C, which is called by C, starts executing at t and ends at t. This transaction trace could represent the case where C calls C and C displays or re-displays a report.","The transaction trace of  corresponds to blocks  and  of . A graph portion  represents C, and graph portions  and  represent separate invocations of C. C starts executing at t and ends at t. C, when called by C a first time, starts executing at t and ends at t. C, when called by C a second time, starts executing at t and ends at t. This transaction trace could represent the case where C calls C a first time to display a report, and a second time to re-display a report.","The transaction trace of  corresponds to blocks ,  and  of . A graph portion  represents C, a graph portion  represent C, and a graph portion  represents C. C starts executing at t and ends at t. C, when called by C, starts executing at t and ends at t. C, when called by C, starts executing at t and ends at t. This transaction trace could represent the case where C calls C to display a report, and the user make another request for a report, but the request is in an invalid format so that the control flow returns directly from C to C.","The transaction trace of  corresponds to blocks  and  of . A graph portion  represents C, and a graph portion  represents C. C starts executing at t and ends at t. C, which is called by C, starts executing at t and ends at t. This transaction trace could represent the case where C calls C with a user request for a quote.","The transaction trace of  corresponds to blocks  and  of . A graph portion  represents C, and a graph portion  represents C. C starts executing at t and ends at t. C, which is called by C, starts executing at t and ends at t. This transaction trace could represent the case where C calls C and C displays a quote.","FIG. A depicts an example of tree data structures of agent and agent which are provided based on the transaction traces of . A tree data structure can be represented by a directed graph or distributed tree which includes nodes and arrows or edges connecting the nodes. Each different path through the tree can be considered to represent a branch of the tree. Each respective branch represents a respective transaction or sequence of invoked components of at least one application. Moreover, each node represents the start or end of the execution of a component. Each node can also include a unique identifier. And, the identifier of a last node in a branch can serve as a unique identifier of the branch (e.g., unique within a subsystem\/agent). That is, given the identifier of a last node in a branch, we can work back to each preceding node in the branch, to the first, root node of the branch. A branch of the tree can represent a component sequence or transaction which extends across multiple subsystems as well. For example, a branch portion above the dotted line includes nodes for components which execute in subsystem, and a branch portion below the dotted line includes nodes for components which execute in subsystem. Multiple branches can overlap, at least in part, so that they have some nodes in common. Typically, at least the root node is common to multiple branches.","An agent which monitors an application or other software can maintain an associated tree data structure. For example, an agent (agt) at a subsystem can maintain the tree data structure which begins at root node , and an agent (agt) at a subsystem can maintain the tree data structure which begins at root node . A manager can maintain a tree data structure which is based on the tree data structure of one or more agents. For example, a manager can maintain the tree data structure of FIG. C, which combines the tree data structures of agent and agent.","A root node  is a starting node for all branches in subsystem. A first branch (agt-branch, representing a transaction agt-T) includes nodes , ,  and . A second branch (agt-branch, representing a transaction agt-T) includes nodes , ,  and . A third branch (agt-branch, representing a transaction agt-T) includes nodes , , , ,  and . A fourth branch (agt-branch, representing a transaction agt-T) includes nodes , , , ,  and . A fifth branch (agt-branch, representing a transaction agt-T) includes nodes , ,  and . A sixth branch (agt-branch, representing a transaction agt-T) includes nodes , ,  and .","A root node  is a starting node for all branches in subsystem. A first branch (agt-branch, representing a transaction agt-T) includes nodes , ,  and . A second branch (agt-branch, representing a transaction agt-T) includes nodes , ,  and .","An identifier of each node can indicate a sequential position of the node within a branch, e.g., based on a number of values in the identifier. For example, node  has the identifier \u201c0:0.\u201d This identifier has two values, separate by a colon, indicating that it is the second node in the branch, after the root node (having the identifier \u201c0\u201d). In the second, third and fourth branches, nodes ,  and  (the second, third and fourth nodes) are common. In the second branch, the last node  has the identifier 0:0:1:0:0. In the third branch, the last node  has the identifier 0:0:1:0:1. In the fourth branch, the last node  has the identifier 0:0:1:0:2. Various other node identification schemes\/code words could be used as well.","The node identifiers can be assigned independently, and therefore potentially repeated, in the different subsystems. However, the combination of a subsystem identifier (e.g., agent identifier) and a node identifier will be unique.","The tree data structure can be provided in different ways. In one approach, an agent of the subsystem builds the tree data structure over time as additional transactions are traced. Each transaction trace, e.g., sequence of invoked components, is compared to the branches of the tree to determine if there is a match. If there is a match, the transaction is already represented by the tree. However, if there is no match, the transaction is not already represented by the tree, and the tree data structure can be updated to represent the new transaction. The updating can involve adding a new branch which may or may not overlap, in part, with an existing branch. The new branch is provided by adding additional nodes which represent the start and end of invoked components of the new transaction. The additional nodes can represent another instance of the start and end of an invoked component which is already present in the tree data structure. For example, in agt-branch, nodes  and  represent the start and end of one instance of C, and nodes  and  represent the start and end of another instance of C.","An example of a branch of the tree that extends across multiple subsystems combines agt-branch of subsystem and agt-branch or agt-branch of subsystem, and is shown in FIG. C. For example, node  in branch of subsystem follows node  in branch of subsystem, and returns to node  in branch. Or, node  in branch of subsystem could follow node  in branch of subsystem, and return to node  in branch. In either case, at least one component, e.g., C, in the first subsystem calls at least one component, e.g., C, in the second subsystem.","Each agent at a server and a manager can maintain separate tree data structures which correspond to one another. Ideally, the tree data structures are synchronized, at least in part, so that they represent the same set of transactions of at least one application or other software. As mentioned, when the agent detects a new transaction, it can update its tree data structure and report the update to the manager. The manager, in turn, can update its tree data structure. Moreover, there may be other agents which monitor other instances of the at least one application, and it is desirable for them to receive the updates as well to update their respective tree data structures. In one approach, the agent which detects a new transaction can provide the update directly to the other agents. In another approach, the agent reports the update to the manager, and the manager relays the updates to the other agents. This approach is efficient since the manager knows which other agents are reporting to the manager and can communicate the updates to them. The updates can be provided in any format. Updates sent from an agent to a manager may be communicated with dynamic data or separately.","By having the agent and manager maintain corresponding tree data structures, many efficiencies can be achieved. For example, static data which is associated with a transaction, and with components of the transaction, can be indexed to nodes of the tree and thereby made available to the manager by merely identifying a branch in the tree. The static data need not be repeatedly communicated by the agent to the manager. Static data generally does not change for a given version of the application or other monitored software. Thus, the same static data can be associated with multiple invocations of a given transaction or component. In contrast, dynamic data such as the start and end times of components, and other dynamic data such as a value of a parameter passed to a method, is not fixed, and can change for each traced transaction and for each invocation of a given component. Dynamic data as gathered by the agent can be reported from the agent to the manager. However, efficiencies can still be achieved by indexing the dynamic data to the nodes to readily identify the invoked components to which the dynamic data applies. Various data structures which can be used to achieve these efficiencies are described in connection with FIGS. A-C.","FIG. A depicts an alternative and equivalent view of the tree data structure of FIG. A. Here, nodes  and  are the same as node , and nodes  and  are the same as node  having the same respective node identifiers. In this view, agt-branch includes nodes ,  and , agt-branch includes nodes , , ,  and  and agt-branch includes nodes , , ,  and . This view clarifies that node  is not part of agt-branch and agt-branch.",{"@attributes":{"id":"p-0117","num":"0116"},"figref":["FIG. 7B","FIG. 9"],"b":["1","7","1","2","1","1","1","1","702","1","760","8","762","8","764","1","1"]},"FIG. C depicts a tree data structure of a manager which combines the tree data structures of agent and agent of FIG. A. As mentioned, the tree data structure of the manager can combine tree data structures of different agents to provide a data structure which spans multiple agents and applications or other software. In this case, a first portion of the manager's tree data structure corresponds to a first agent's tree data structure and a second portion of the manager's tree data structure corresponds to a second agent's tree data structure. The dashed line nodes (nodes , , , , ,  and ) correspond to nodes from the agent tree data structure, and the dotted line nodes (nodes  and ) are added based on the dashed line nodes. The solid line node of the manager's tree data structure corresponds to the agent tree data structure. Since it is known that C calls C, node  points to node . Since it is known that C returns to C, node  points to node  for the case where the sequence of nodes , ,  and  is followed, and additional nodes  and  are added where node  points to node  for the case where the sequence of nodes , ,  and  is followed. Nodes  and  are the same as nodes  and , respectively, from the point of view of agent.","Thus, the manager's (mgr) tree data structure includes these branches: mgr-branch, mgr-branch, mgr-branch (same as agt-branch), mgr-branch (same as agt-branch), mgr-branch (same as agt-branch), mgr-branch (same as agt-branch) and mgr-branch (same as agt-branch). Mgr-branch represents a sequence of invoked components in a cross-subsystem transaction because the transaction involves multiple subsystems. Mgr-branch represents a transaction mgr-T which combines multiple transactions, e.g., part of transaction agt-T (nodes  and ), followed by transaction agt-T (nodes , ,  and ), followed by a remainder of transaction agt-T (nodes  and ). Recall that transaction agt-T is from subsystem and agt-T is from subsystem. Mgr-branch represents a transaction mgr-T which combines part of transaction agt-T (nodes  and ), followed by transaction agt-T (nodes , ,  and ), followed by a remainder of transaction agt-T (nodes  and ). Mgr-branch represents a transaction mgr-T which is the same as transaction agt-T (nodes , ,  and ). Mgr-branch represents a transaction mgr-T which is the same as transaction agt-T (nodes , , , ,  and ). Mgr-branch represents a transaction mgr-T which is the same as transaction agt-T (nodes , , , ,  and ). Mgr-branch represents a transaction mgr-T which is the same as transaction agt-T (nodes , ,  and ). Mgr-branch represents a transaction mgr-T which is the same as transaction agt-T (nodes , ,  and ).","The node identifiers in FIG. C are the same as in FIG. A except for: node  (0:0:0:0), node  (0:0:0:0:0), node  (0:0:0:0:0:0), node  (0:0:0:0:0:0:0), node  (0:0:0:0:0:0:0:0), node  (0:0:0:0:0:0:0:0:0), node  (0:0:0:0:1), node  (0:0:0:0:1:0), node  (0:0:0:0:1:0:0), node  (0:0:0:0:1:0:0:0) and node  (0:0:0:0:1:0:0:0:0). These are identifiers of the manager. The identifiers of mgr-branch, mgr-branch, mgr-branch, mgr-branch, mgr-branch, mgr-branch and mgr-branch are the identifiers of nodes , , , , ,  and , respectively, as seen by agent.","When the tree data structure of the manager combines tree data structures of different agents, a transaction of the manager can combine multiple transactions of multiple agents. As an example of a one-to-many correspondence of a manager transaction to agent transactions, mgr-T combines agt-T and agt-T. See FIGS. A-A. In this case, a user interface display of a manager's transaction can be based on multiple, agent transactions.","Alternatively, the tree data structure of the manager need not combine the tree data structures of the different agents, but the manager can maintain a separate tree data structure for each agent which is essentially a copy of each agent's tree data structure. In this case, a transaction of the manager can be the same as a transaction of the agent. As an example of a one-to-one correspondence of a manager transaction to an agent transaction, mgr-T is the same as agt-T. In this case, a user interface display of a manager's transaction can be based on a single agent transaction.","Or, the manager can maintain both separate tree data structures of the different agents, and a tree data structure which combines the tree data structures of the different agents. The separate tree data structure could be used for branch matching, such as in step  of , while tree data structure which combines the tree data structures of the different agents could be used for providing a user interface, such as in steps  and  of , for instance.","FIG. C depicts a correspondence between a last node in agent's tree data structure of FIG. A and a last node of the manager's tree data structure of FIG. C. As mentioned, the identifier of the last node of a branch in a tree data structure can be used to uniquely identify the branch. In some cases, the same last node identifier is used in the tree data structures of an agent and manager. In other cases, such as when the manager combines tree data structures of different agents, different last node identifiers can be used in the tree data structures of the agent and manager. The manager can maintain a correspondence record between last node identifiers. For example, agent's last node identifier of 0:0:0:0:0 corresponds to two last nodes of the manager (nodes  and ), having identifiers 0:0:0:0:0:0:0:0:0 and 0:0:0:0:1:0:0:0:0. The remaining last node identifiers of agent (see identifiers of nodes , , ,  and  in FIG. A) are the same as for the manager. Also, agent's last node identifier of 0:0:0:0:0 corresponds to two last nodes of the manager, having identifiers 0:0:0:0:0:0:0 and 0:0:0:0:1:0:0. In this example, there are no remaining last node identifiers of agent to consider. The node # is provided as an aid to understanding and is not necessarily part of the correspondence record.","Thus, when the manager receives a last node identifier from agent of a first node sequence, and a last node identifier from agent of a second node sequence, it can access its tree data structure based on one or more of these last node identifiers. Moreover, the access can be based on agent's and\/or agent's last node identifier directly and\/or based on the manager's corresponding last node identifier.",{"@attributes":{"id":"p-0126","num":"0125"},"figref":["FIG. 7D","FIG. 7B"],"b":["7","1","1","760","762","764","1","1"]},"FIG. A depicts a record of branches and component invocations for subsystem in the tree data structure of FIG. A. Each branch is identified by a last node identifier. For example \u201c0:0:0:0:0\u201d identifies the node  in FIG. A, thereby also identifying agt-branch and a corresponding transaction agt-T, both in subsystem. The component invocations for this branch are: start C (node ), start C (node ), end C (node ) and end C (node ).","\u201c0:0:1:0:0\u201d identifies the node  in FIG. A, thereby also identifying agt-branch and a transaction agt-T, both in subsystem. The component invocations for this branch are: start C (node ), start C (node ), end C (node ) and end C (node ).","\u201c0:0:1:0:1:0:0\u201d identifies the node  in FIG. A, thereby also identifying agt-branch and a transaction agt-T, both in subsystem. The component invocations for this branch are: start C (node ), start C (node ), end C (node ), start C (node ), end C (node ) and end C (node ).","\u201c0:0:1:0:2:0:0\u201d identifies the node  in FIG. A, thereby also identifying agt-branch and a transaction agt-T, both in subsystem. The component invocations for this branch are: start C (node ), start C (node ), end C (node ), start C (node ), end C (node ) and end C (node ).","\u201c0:1:0:0:0\u201d identifies the node  in FIG. A, thereby also identifying agt-branch and a transaction agt-T, both in subsystem. The component invocations for this branch are: start C (node ), start C (node ), end C (node ) and end C (node ).","\u201c0:1:1:0:0\u201d identifies the node  in FIG. A, thereby also identifying agt-branch and a transaction agt-T, both in subsystem. The component invocations for this branch are: start C (node ), start C (node ), end C (node ) and end C (node ).","FIG. A depicts a record of branches and component invocations for subsystem in the tree data structure of FIG. A.","\u201c0:0:0:0:0\u201d identifies the node  in FIG. A, thereby also identifying agt-branch and a transaction agt-T, both in subsystem. The component invocations for this branch are: start C (node ), start C (node ), end C (node ) and end C (node ).","\u201c0:0:1:0:0\u201d identifies the node  in FIG. A, thereby also identifying agt-branch and a transaction agt-T, both in subsystem. The component invocations for this branch are: start C (node ), start C (node ), end C (node ) and end C (node ).","FIG. B depicts a record of references to static data for different nodes\/components of subsystem in the tree data structure of FIG. A. As mentioned, various types of static data can be referenced to a component and its associated nodes. For example, node \u201c0:0\u201d is associated with component C and is referenced to static_data_C (e.g., methodC, classC and JARC, etc.) Different records of static data which are referenced are depicted in , discussed further below. The class name can include names of one or more parent or super classes as well. In one approach, one or more of the nodes are referenced to static data. In another approach, the nodes which represent the start of a component (but not the nodes which represent the end of a component) are referenced to static data. Other approaches are possible. A goal is to enable the manager to access the static data which is associated with a given component or node such as to annotate a user interface, e.g., a transaction trace. The records of FIGS. A and B can be provided as part of a tree data structure by an agent and\/or by a manager to which the agent reports.","The record can group the nodes which form a branch or a portion of a branch. For example, the first five entries (\u201c0:0\u201d through \u201c0:0:0:0:0\u201d) are for agt-branch, and the last entry (\u201c0:0:0:0:0\u201d) is an identifier of the branch. The entries 0:0:1, 0:0:1:0 and 0:0:1:0:0 are for nodes in agt-branch which are not in agt-branch.","The nodes can be referenced directly to one or more types of static data, or to an identifier which is referenced to the one or more types of static data. In this way, the static data identifier can be repeated efficiently in the record without repeating the one or more types of static data.","The static data can be obtained from the instrumentation of the software, including instrumentation of the one or more components to which the static data is referenced.","The static data of a transaction can be obtained mostly from instrumentation. However, as a principle, it can be obtained from other sources, and mashed up or combined with other static data if necessary. For example, it can be detected from other sources that a given piece of code is statically always related to a given application, or statically always going to be of lower priority. This information may be used to determine the behavior of the trace.","Static data include all types of information which are available from tracing the software. Static data can also indicate that a given component can be called by only a limited number of one or more parent components and\/or that the given component can call only a limited number of one or more child components, because of the way the software is structured. For example, the static data may indicate that C is only called by C or C, and that C only calls C. Static data can also indicate that a given component can call only a limited number of one or more child components, based on one or more parent components which called the given component. In terms of the tree data structure, for instance, a given node may only have one child node based on how the given node was reached, e.g., in a given context. This information can be useful in the matching step  as well as in segregating transaction data according to a transaction context.","As another example, a servlet can call many different methods of a database using SQL statements. But, the servlet will not call the methods arbitrarily all the time. It will call some SQLs if something has happened previously or other SQLs if something else has happened previously. This provides a partition of the SQLs that is relevant according to the business logic. For example, if a transaction is to buy a book on a web site, one portion of the database logic is used, while if a transaction is to buy a hat on a web site, another portion of the database logic is used. In both cases, the servlet may use the same socket to make the database call. But, the use of the tree data structure allows data to be gathered in a specific transaction context. This data can include a transaction trace and the metrics it yields such as response time, as well as other metrics which are obtained for a transaction.","The static data can be cached by the agent so that it does not have to be repeatedly retrieved from the software and\/or the instrumentation.","FIG. B depicts a record of references to static data for different nodes\/components of subsystem in the tree data structure of FIG. A. These records can be provided as part of a tree data structure by an agent of subsystem and reported to an associated manager. This can be the same manager that the agent of subsystem reports to, for instance. Multiple agents can report to a common manager. In the record, as an example, node \u201c0:0\u201d is associated with component C and is referenced to static_data_C.","FIG. B depicts an update to the record of FIG. B for agt-new-branch in . The nodes ,  and  have identifiers 0:0:2, 0:0:2:0 and 0:0:2:0:0, respectively, and are indexed to static_data_C, static_data_C and static_data_C, respectively.","FIG. B depicts a record of references to static data for different nodes\/components of a manager in the tree data structure of FIG. C. Each node has associated static data, as discussed.","FIG. B depicts an update to the record of FIG. B for mgr-new-branch in . The nodes ,  and  have identifiers 0:0:2, 0:0:2:0 and 0:0:2:0:0, respectively, and are indexed to static data C, static_data_C and static_data_C, respectively. The update is the same as in FIG. B, in this example, due to the common node identifiers. In other cases, the updates can differ, e.g., due to different node identifiers.",{"@attributes":{"id":"p-0148","num":"0147"},"figref":["FIG. 8C","FIG. 5A"],"b":["1","7","1","1","1","2","1","2","1","1"]},"The dynamic data includes an entry for node \u201c0:0\u201d, which is associated with C, and which includes a start time (t) for C and other associated dynamic data (dynamic_data_), such as a parameter passed in a call to C. An entry for node \u201c0:0:0\u201d is associated with C, and includes a start time (t) for C and other associated dynamic data (dynamic_data_), such as a parameter passed in a call to C. An entry for node \u201c0:0:0:0\u201d is associated with C, and includes an end time (t) for C and other associated dynamic data (dynamic_data_), such as a parameter passed in a return to C, e.g., a return of a program flow to C from a component which was called by C. An entry for node \u201c0:0:0:0:0\u201d is associated with C, and includes an end time (t) for C and other associated dynamic data (dynamic_data_), such as a parameter passed in a return to C, e.g., a return of a program flow to C from a component which was called by C.",{"@attributes":{"id":"p-0150","num":"0149"},"figref":"FIG. 8D","b":["1","2","3","4","5","6","7","8"]},{"@attributes":{"id":"p-0151","num":"0150"},"figref":"FIG. 9","b":["7","1","900","902"]},"Step  includes, during the transaction, obtaining dynamic data, e.g., metrics, for the sequence of invoked components, including start and end times of the invoked components. This dynamic data can be obtained from the transaction trace. At decision step , a determination is made as to whether there is a matching branch in the tree data structure. For example, assume a transaction trace results in the following sequence of invoked components: start C, start C, end C, end C. This sequence can be compared in turn to each branch in the tree data structure of FIG. A, for instance, until a matching branch is found. In one approach, the comparison proceeds one branch at a time, starting at a first branch. In another approach, branches which have a number of nodes which corresponds to the number of start and end points of the transaction trace are first compared. Other approaches are possible as well. In this example, agt-branch is a matching branch. Step  includes reporting the dynamic data and an identifier of the matching branch (e.g., agt-branch, or node 0:0:0:0:0) to the manager. The dynamic data could be reported as a list of start and stop times of the invoked components, for instance, where each time corresponds to one of the nodes of the branch, and the order of the reported times corresponds to the order of nodes in the branch. The time can be a time stamp, for instance, based on a clock of the agent.","A matching branch can be a branch which has the same number of nodes as the number of start and end points of the sequence of invoked components of the transaction, where the sequence of nodes in the branch matches the start and end points of the sequence of invoked components of the transaction. The root node of the tree need not be considered in the matching. In some case, a branch can have a sequence of nodes which match the start and end points of the sequence of invoked components of the transaction, but have additional nodes as well. In this case, there is a partial match for the start and end points of the sequence of invoked components of the transaction, and decision step  is false. In this case, the subject transaction trace provides a new sequence of start and end points of a sequence of invoked components which is not exactly represented by, and co-extensive with, a branch of the tree data structure. In response to determining this, step  includes updating the tree data structure with a branch which represents, and is co-extensive with, the sequence of invoked components. For example, this can be agt-new-branch in . A co-extensive branch has the same start and end points as the sequence.","At step , the updating can include providing nodes which represent start and end points of one or more invoked components in the transaction trace, in a new branch. For example, in , agt-new-branch includes the newly added nodes ,  and . The new branch can overlap in part with one or more existing branches. For example, in , node  is present (overlapping) in agt-branch, agt-branch and agt-new-branch, so that agt-new-branch overlaps with agt-branch and agt-branch.","Thus, the sequence of invoked components of the new transaction is represented in the tree data structure by a branch (e.g., agt-new-branch) having an overlapping portion (node ) which overlaps with at least one of the pre-existing branches (e.g., agt-branch and agt-branch) and a non-overlapping portion (a branch portion including nodes ,  and ) which does not overlap with any of the pre-existing branches. The new nodes (nodes ,  and ) are provided in the non-overlapping portion but not in the overlapping portion.","In , step  indicates that the updating of the tree data structure includes indexing, to the nodes, static data associated with the one or more of the invoked components. The static data of a component can be accessed by the agent from instrumentation of the component, and indexed as discussed in connection with FIG. B.","Step  includes reporting the update of the tree data structure from the agent to the manager. The update can identify start and end points of the one or more of the invoked components of the subject transaction instance, and indexes to associated static data. This report can be provided in the form of a branch definition as set forth in FIG. A or A, and the references to static data as set forth in FIG. B or B.","After updating the tree data structure based on the new transaction, decision step  will be true when the sequence of invoked components of the transaction trace is again compared to the updated tree data structure. Step  includes reporting dynamic data and an identifier of the matching branch from the agent to the manager. This report can be provided, e.g., in the form of the record of . Upon receipt of this report, the manager can update its tree data structure so that it is synchronized with the agent's tree data structure. Thus, the agent can efficiently report the transaction to the manager while reducing overhead costs such as the amount of bandwidth needed to send data over a communication path and\/or the amount of memory needed to communicate and store such data.",{"@attributes":{"id":"p-0159","num":"0158"},"figref":"FIG. 10A","b":["7","1","1000","1002","1004","8","1","1","1","1","2","2","1"]},"Alternatively, step  can include accessing a record such as in FIG. C to determine that agent's last node of 0:0:0:0:0 corresponds to the manager's last node of 0:0:0:0:0:0:0:0:0, and accessing a record such as in FIG. A to determine that mgr-branch is identified by the manager's last node of 0:0:0:0:0:0:0:0:0, and that this branch includes the components sequence of: start C, start C, start C, start C, end C, end C, end C, end C.","Step  includes, based on the identifier, looking up static data associated with the invoked components of the transaction. This can involve accessing a record such as in FIG. B, e.g., to identify static_data_C which is indexed to node\/branch identifier \u201c0:0:0:0:0\u201d and each of the nodes of the branch. Alternatively, this can involve accessing a record such as in FIG. B, e.g., to identify static_data_C which is indexed to node\/branch identifier \u201c0:0:0:0:0:0:0:0:0\u201d and each of the nodes of the branch.","Step  includes providing a user interface (UI) with a transaction trace of the sequence of invoked components of the transaction. The transaction trace can be provided directly from the identified branch, since the branch identifies the start and stop of each component of the branch. Examples of transaction traces which can be provided on a user interface are in , A and B. Step  includes annotating the transaction trace based on the static and\/or dynamic data, such as depicted in . This can include displaying the static and\/or dynamic data on the user interface. As another example, a UI could be provided such as discussed in connection with .",{"@attributes":{"id":"p-0163","num":"0162"},"figref":["FIG. 10B","FIG. 7D"],"b":["7","1","7","1","1020","1022","1024","1026","8","3"]},"In step , the updating includes providing nodes which represent start and end points of one or more invoked components of the transaction. For example, this can include adding the nodes ,  and  of mgr-new-branch in . In step , the updating includes indexing, to the nodes, static data associated with the invoked components of the transaction, such as depicted in connection with the records of FIG. B. Note that the update to the manager's tree data structure can include some of the nodes of the agent's tree data structure (e.g., nodes ,  and ) but not other of the nodes of the agent's tree data structure (e.g., node ), in the example of mgr-new-branch of .",{"@attributes":{"id":"p-0165","num":"0164"},"figref":["FIG. 11A","FIG. 6A"],"b":["600","1","602","2","1","1","1","1"]},{"@attributes":{"id":"p-0166","num":"0165"},"figref":["FIG. 11B","FIG. 6A","FIGS. 11A and 11B"],"b":["610","5","612","6","1","2","1","5","6","2","2","5"]},"For example, when C is invoked in the transaction agt-T, it can include an identifier of agt-T when it calls C. Agent, when reporting to the manager regarding the transaction agt-T, includes the identifier agt-T. Similarly, agent, when reporting to the manager regarding the transaction agt-T, includes the identifiers agt-T and agt-T. The manager then knows that the transactions\/transaction traces of the identifiers agt-T and agt-T are associated.","Another example user interface provides the tree data structures of FIGS. A-D directly, e.g., by displaying the nodes and edges between them. Status and dynamic data can be displayed within or next to the nodes.",{"@attributes":{"id":"p-0169","num":"0168"},"figref":"FIG. 12A","b":["7","1"]},"In one approach, a gatherer is a software process in the agent code which gathers one or more metrics of a component represented by the node. The agent can use a basic data structure of the pair <agent metric, gatherer> that is connected to instrumented components such as methods in a managed application. The metrics are gathered, e.g., when instrumentation code of the component is triggered when the component is invoked. For example, the metrics can include a count of invocations, which is a number of times an instance of a component represented by the node has been invoked, a response time, which is a response time of an instance of a component represented by the node, an average of such response times across multiple invocations, an error metric which indicates whether an error message is associated with the component represented by the node, or any other metric including those discussed herein. By linking a gatherer to a node in the tree, an invocation of a component represented by the node can be linked to a context of the gatherer. Similarly, the gatherer can be linked only to that node, in which case, there is a one-to-one linking of the gatherer to the context of the branch and the respective transaction represented uniquely by the branch.","One valuable business objective for the agent is to provide metrics segregated by transaction type (transaction separability). For example, we would like to report response time for a given backend (or for some specific SQL statements invoked on the backend) for each identified transaction type on a given customer application, for example, for the transaction \u201cBuy book\u201d and for the transaction \u201cBuy CD.\u201d One step toward this objective is the ability to efficiently deliver \u201ctransaction\u201d metric sets, e.g., metrics whose values are partitioned by the specific transactions that have been invoked in the customer application.","The tree data structure can be used for this purpose. As mentioned, the tree describes transactions through a branching sequence of transaction points or nodes. The edges of the sequence are called transaction segments. The transaction structure has a lifecycle that is equivalent to the longevity of the code from which it is detected. The transaction structure is first detected by an agent that instruments the application with a modified tracer. The transaction structure is then shared with other agents and a manager. The transaction structure is also permanently stored in a database of the manager.","The agent decorates each point of interest in the transaction structure with a set of one or more gatherers. Each gatherer is associated with a multiple set of possible metrics. The agent gathers the \u201cnumbers\u201d for the metrics and, because of the agent structure, is able to determine the specific values that are associated with each one of the possible transaction paths. Some kinds of gatherers can be associated with more than one transaction structure element or node. For example, concurrent invocation gatherers are associated with all the transaction structure elements that are related to the metric being gathered.","Additionally, the agents can receive updates from the manager regarding the transaction structures detected by other agents. This allows, for example, having agents reporting efficiently in case of cross-JVM transactions.","In this example, a gatherer  is linked only to the node  in transaction agt-T and a gatherer  is separately linked only to the node  in transaction agt-T. Nodes  and  both represent an end of the invocation of C, e.g., a stop time of C, but in the different contexts of the respective transactions agt-T (represented by agt-branch) and agt-T (represented by agt-branch). To allow better understanding of the performance of a monitored application, it can be helpful to segregate metrics for a given component according to one or more transaction contexts. This may indicate, for example, that a performance problem regarding a component occurs in one specific transaction context but not in another context. The specific context which is problematic can then be investigated further. The gatherers can be configured, e.g., based on operator experience, for instance, or based on an automated analysis which detects problematic components and\/or transactions.","A gatherer allows metrics to be obtained and reported selectively based on one or more selected nodes in the tree. Since the components are instrumented, it is possible to obtain and report metrics for all occurrences of the components. However, this can lead to unnecessary overhead costs. It is efficient to gather and report metrics only on an as-needed basis. It is also useful to gather and report metrics which are transaction-segregated. For example, metrics obtained at node  by the gatherer  are for an invocation C in the context of agt-T. Alternatively, if the gatherer was linked to nodes ,  and , the metrics obtained would not be specific to a subset of fewer than all transactions in which C is invoked. The gatherer  and any other depiction of a gatherer herein is meant to represent an entity which can gather one or more types of metrics.","In another approach, as mentioned, one gatherer can be linked to multiple transactions so that at least one metric obtained by a gatherer is associated with components of the multiple transactions. Generally, a number of variations are possible including: (1) at least one metric of a gatherer is associated with one component instance in one transaction (e.g., the gatherer  linked to an instance of C in node  in agt-T in ), (2) at least one metric of a gatherer is associated with multiple instances of one component in one transaction (e.g., the gatherer  linked to instances of C in nodes  and  in agt-T in ), (3) at least one metric of a gatherer is associated with one component instance of one component, and one component instance of another component, in one transaction (e.g., the gatherer  linked to an instance of C in node  in agt-T in , modified by the gatherer  also being linked to an instance of C in node  in agt-T), and (4) at least one metric of a gatherer is associated with one component instance of one component in one transaction, and one component instance of another component in another transaction (e.g., the gatherer  linked to an instance of C in node  in agt-T in , modified by the gatherer  also being linked to an instance of C in node  in agt-T). In case (), the at least one metric is for multiple transactions, e.g., the one transaction and the another transaction.",{"@attributes":{"id":"p-0178","num":"0177"},"figref":"FIG. 12B","b":["7","1","1204","706","724","1204","2","1204","1","1","1","4"]},{"@attributes":{"id":"p-0179","num":"0178"},"figref":"FIG. 12C","b":["7","1","1206","712","718","3","1","3","1206","3","1","3"]},"Recall that agt-T includes the sequence of nodes: , ,  and , agt-T includes the sequence of nodes: , , , ,  and , and agt-T includes the sequence of nodes: , , , ,  and , as discussed in connection with FIG. A. Note that, when one or more metrics are obtained for a component invocation corresponding to node , the transaction is not yet uniquely defined because any one of three different node sequences can follow node . In this case, the metrics are gathered and subsequently, a decision can be made to discard the metrics, and not report them to the manager, if the transaction is not of a specified identity. That is, in one approach, the gatherer  can be linked to the node  but only when node  is part of a specific transaction, e.g., agt-T, agt-T or agt-T.","In contrast, when one or more metrics are obtained for a component invocation corresponding to node , the transaction (agt-T) is uniquely defined because only one node sequence can follow node . In this case, the metrics are gathered and it is decided that they will be reported to the manager. For example, the agent may report information such as metrics to the manager periodically, such as very few minutes. Typically, a transaction will have concluded or otherwise progressed to a point where it can be uniquely identified, before a next reporting time. The agent may store the metrics for a not-yet-identified transaction as they are gathered until the transaction is identified, at which time a determination can be made to discard the metrics, report the metrics to the manager, and\/or take some other action.","In another approach, a decision as to whether metrics are to be reported is made after a transaction is complete and identified. See also , which relate to processing by the agent and manager, respectively, when transaction-segregated metrics are provided.","Gatherers of different types, such as depicted in , can be used in combination as well.",{"@attributes":{"id":"p-0184","num":"0183"},"figref":["FIG. 13A","FIG. 12A"],"b":["1200","1202","1200","2","1","1","1202","2","1","4"]},{"@attributes":{"id":"p-0185","num":"0184"},"figref":["FIG. 13B","FIG. 12B"],"b":["1204","1204","2","1","1","1204","2","1","4"]},{"@attributes":{"id":"p-0186","num":"0185"},"figref":["FIG. 13C","FIG. 12C"],"b":["1206","1206","3","1","3","1206","3","1","3"]},{"@attributes":{"id":"p-0187","num":"0186"},"figref":["FIG. 14A","FIG. 13A"],"b":"1400"},"For example, heavy long-dashed lines are used for nodes , ,  and  to identify agt-T, and heavy short-dashed lines are used for nodes , , , ,  and  to identify agt-T. A region  provides example metrics regarding the component instance represented by node  based on data gathered by the gatherer . A region  provides example metrics regarding the component instance represented by node  based on data gathered by the gatherer . The metrics can include, e.g., errors, average response time and number of invocations in the context of the transaction agt-T and, separately, in the context of agt-T.",{"@attributes":{"id":"p-0189","num":"0188"},"figref":["FIG. 14B","FIG. 13B"],"b":["1410","1400","702","704","706","708","1","1","702","710","712","722","724","726","1","4","1412","706","724","1200","1","1","1","4"]},{"@attributes":{"id":"p-0190","num":"0189"},"figref":["FIG. 14C","FIG. 13C"],"b":["1420","702","710","712","716","718","720","1","3","1422","712","718","1206","3","1","3"]},"Similar UIs can be provided for other subsystems. A UI can also combine nodes from multiple subsystems, such as discussed in connection with FIGS. C and D.",{"@attributes":{"id":"p-0192","num":"0191"},"figref":["FIG. 15A","FIG. 5B","FIG. 14A","FIGS. 14A-C"],"b":"1500"},"The nodes include a root node , and in one path, a node  for C, a node  for C or a node  for C, a node  for C, a node  for C, a node  for C and a node  for C. Another path includes a node  for C which in turn can call C or C. An arrow\/edge  connects the nodes  and  and includes multiple edge portions. One edge portion  indicates that C is called by C in the context of agt-T, while another edge portion  indicates that C is called by C in the context of agt-T. Further, the edge portions  and  can have different visual characteristics such as color, pattern or thickness, based on their respective associated metrics. Each edge portion can be associated with one of more of the gatherers and thereby with the metrics collected by the one or more of the gatherers.","In the example provided, the edge portions  and  are visually distinguished from one another by thickness, e.g., based on the number of invocations of the same component (C) which are attributable to one transaction (agt-T) versus a number of invocations of the same component which are attributable to the another transaction (agt-T). In this case, edge portion  is thicker, e.g., wider, than edge portion . For instance, edge portion  being twice as thick as edge portion  would indicate that C was invoked twice as many times by C in agt-T than in agt-T.","In another example, the relative thicknesses of the edge portions  and  is based on a number of errors of C which are attributable to agt-T versus a number of errors of C which are attributable to agt-T. In yet another example, the relative thicknesses of the edge portions  and  is based on an average response time of C which is attributable to agt-T versus an average response time of C which is attributable to agt-T.","In another example, a hotter color such as red can be used to indicate a relatively high number of invocations while a cooler color such as blue indicates a relatively low number of invocations. In another approach, red indicates a relatively high number of errors or a relatively high average response time, while blue indicates a relatively low number of errors or a relatively low average response time. Many other options are possible.","Additionally, display regions  and  provide metrics associated with edge portions  and , respectively. Each edge portion  and  is thus decorated with at least one metric. The display region  indicates a \u201ccaution\u201d state of an alert which has been set for the average response time of agt-T. This state might be set when the average response time exceeds a threshold, for instance. Generally, alerts can be set for the overall performance of a managed computing device and for calls made by a managed computing device, e.g., to another managed computing device or to an uninstrumented back end device. These alerts can be created and configured by a user. An alert can also be defined for a Business Transaction. If an alert is defined, it can appear in one of several states, such as normal (green), caution (yellow) or danger (red). An alert can be set for the transaction-segregated metrics which are obtained by a gatherer so that the alert is also specific to one or more specified transactions. This provides useful information that assists the user in understanding and diagnosing the system.","The UI could allow the user to click on, or otherwise select, a textual description of one of the metrics in one of the display regions  or  to cause the widths or other visual characteristic of the edge portions to reflect the selected metric. Or, another UI device such as a pull down menu can allow the user to configure the UI as desired. The UI can also filter out data which does not meet one or more specified criterion, such as by filtering out data which is not within a time period of interest. The UI can present data based on one or more reporting agents\/subsystems as selected by a user.","The paths between the other nodes in the UI could similarly be enhanced based on available transaction-segregated metrics. The UI can also allow the user to view transaction traces such as in . For example, the UI can provide a list of individual transactions which are used to provide the UI of  or B, and select one of the transactions to view the corresponding transaction trace.","The ability to segregate performance metrics of a component by transaction or group of transaction allows the operator to more readily understand the performance of the application and diagnose problems, relative to that component. For example, an approach which does not use transaction-segregated metrics could only indicate that the component C has an unusually high average response time. In contrast, based on the transaction-segregated metrics, the UI can indicate average response times for the each of the transactions agt-T and agt-T to perhaps determine that one of the transactions but not the other is causing the slow response time.","As another example, assume a managed computing device of an e-commerce web site performs transactions including allowing a customer to shop for an item to buy, and processing a payment of the customer. Or, assume the managed computing device performs transactions including allowing a customer to shop for different types of times. The ability to provide transaction-segregated metrics allows these two transactions to be analyzed separately. The approaches provided herein optimize the kind of data which is gathered and the process for gathering it.",{"@attributes":{"id":"p-0202","num":"0201"},"figref":["FIG. 15B","FIG. 15A","FIG. 15A"],"b":["1530","1","1","1532","1","4","1534","1536","1","1537","3","1538","2","1","1545","1542","1544","1540","1546","1542","1544"]},{"@attributes":{"id":"p-0203","num":"0202"},"figref":["FIG. 15C","FIG. 1A"],"b":["1560","1574","1576","103","109","1560","1","1","1562","2","2","1564","1576","1574","1","2","1568","1570","1575","1568","1570","1566","1572","1568","1570"]},"An automated report could also be provided, e.g., in the form of a list. The list could identify components and\/or managed computing devices for which metrics indicate there is a problem, along with identifying the associated transactions.",{"@attributes":{"id":"p-0205","num":"0204"},"figref":"FIG. 16A","b":["1600","1602","1604","1606","1608","1610","1606"]},{"@attributes":{"id":"p-0206","num":"0205"},"figref":["FIG. 16B","FIG. 16A","FIGS. 14A-15B","FIGS. 15A and 15B"],"b":["1620","1622","1624","1626","1628","1402","1404","1412","1422","1524","1526","1540","1546","1520","1522","1542","1544"]},"The foregoing detailed description of the invention has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. The described embodiments were chosen in order to best explain the principles of the invention and its practical application, to thereby enable others skilled in the art to best utilize the invention in various embodiments and with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the claims appended hereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 3","FIG. 1A"],"b":"1"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 5A","FIG. 4"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 5B","FIG. 5A"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIGS. 6A-6I","FIG. 5A"]},"FIG. A depicts an example of tree data structures of agent and agent which are provided based on the transaction traces of .","FIG. A depicts an alternative and equivalent view of the tree data structure of FIG. A.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 7B","b":["1","7","1"]},"FIG. C depicts a tree data structure of a manager which combines the tree data structures of agent and agent of FIG. A.","FIG. C depicts a correspondence between a last node in the tree data structure of agent of FIG. A and a last node of the manager tree data structure of FIG. C.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 7D","FIG. 7B"],"b":["7","1","1"]},"FIG. A depicts a record of branches and component invocations for subsystem in the tree data structure of FIG. A.","FIG. A depicts a record of branches and component invocations for subsystem in the tree data structure of FIG. A.","FIG. A depicts branch definitions at a manager.","FIG. B depicts a record of references to static data for different nodes\/components of subsystem in the tree data structure of FIG. A.","FIG. B depicts a record of references to static data for different nodes\/components of subsystem in the tree data structure of FIG. A.","FIG. B depicts an update to the record of FIG. B for agt-new-branch in .","FIG. B depicts a record of references to static data for different nodes\/components of a manager in the tree data structure of FIG. C.","FIG. B depicts an update to the record of FIG. B for mgr-new-branch in .",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 8C","b":["1","7","1"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 8D"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 9","b":["7","1"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 10A","b":["7","1"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 10B","b":["7","1","7","1"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 11A","FIG. 6A"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 11B","FIG. 6A"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 12A","b":["7","1"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 12B","b":["7","1"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 12C","b":["7","1"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 13A","FIG. 12A"],"b":["1200","1202"]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 13B","FIG. 12B"],"b":"1204"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 13C","FIG. 12C"],"b":"1206"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 14A","FIG. 13A"]},{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 14B","FIG. 13B"]},{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 14C","FIG. 13C"]},{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 15A","FIG. 5B","FIG. 14A"]},{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 15B","FIG. 15A"]},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 15C"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 16A"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 16B","FIG. 16A"]}]},"DETDESC":[{},{}]}
