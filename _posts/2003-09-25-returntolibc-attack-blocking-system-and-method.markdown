---
title: Return-to-LIBC attack blocking system and method
abstract: A method includes stalling a call to a critical operating system (OS) function, looking up a value at the previous top of stack, and determining whether the value is equivalent to an address of the critical OS function being called. If the value at the previous top of stack is equivalent to the address of the critical OS function being called, the method further includes taking protective action to protect a computer system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07287283&OS=07287283&RS=07287283
owner: Symantec Corporation
number: 07287283
owner_city: Cupertino
owner_country: US
publication_date: 20030925
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION ","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","The present invention relates to the protection of computer systems. More particularly, the present invention relates to a system and method of blocking Return-to-LIBC attacks.","2. Description of the Related Art","Buffer overflow techniques have been used by malicious hackers and virus writers to attack computer systems. Buffers are data storage areas, which generally hold a predefined amount of finite data. A buffer overflow occurs when a program attempts to store data into the buffer, where the data is larger than the size of the buffer.","One category of buffer overflow, sometimes called stack-based buffer overflow, involves overwriting stack memory, sometimes called the stack. Stack-based buffer overflow is typically caused by programs that do not verify the length of the data being copied into a buffer.","When the data exceeds the size of the buffer, the extra data can overflow into the adjacent memory locations. In this manner, it is possible to corrupt valid data and possibly to change the execution flow and instructions.","In the case of a Return-to-LIBC attack, the attacker overflows the stack in such a way that a return address will be replaced to point to a library function in a loaded library inside the process address space. Thus, when the return address is used by the overflowed process, a library function will be executed. This way the attacker runs at least one application programming interface (API) to run a command shell on the compromised system remotely.","A method includes stalling a call to a critical operating system (OS) function, looking up a value at the previous top of stack, and determining whether the value is equivalent to an address of the critical OS function being called. If the value at the previous top of stack is equivalent to the address of the critical OS function being called, the method further includes taking protective action to protect a computer system.","In one embodiment, if the value at the previous top of stack is equivalent to the address of the critical OS function being called, a determination is made that the critical OS function is being called via a RET (return) instruction as part of a Return-to-LIBC attack. By taking protective action such as terminating the critical OS function call, the Return-to-LIBC attack is blocked and defeated.","Embodiments in accordance with the present invention are best understood by reference to the following detailed description when read in conjunction with the accompanying drawings.","Common reference numerals are used throughout the drawings and detailed description to indicate like elements.","In accordance with one embodiment, referring to , a method includes stalling a call  to a critical operating system (OS) function , looking up a value V at the previous top of stack at address [ESP-], and determining whether the value V is equivalent to an address of critical OS function . If the value V is equivalent to the address of critical OS function , the method further includes taking protective action such as terminating call .","In one embodiment, if the value V is equivalent to the address of critical OS function , a determination is made that critical OS function  is being called via a RET (return) instruction  as part of a Return-to-LIBC attack. By taking protective action such as terminating call , the Return-to-LIBC attack is blocked and defeated.","More particularly,  is a diagram of a client-server system  that includes a Return-to-LIBC attack blocking application  executing on a host computer system , e.g., a first computer system, in accordance with one embodiment of the present invention.","Host computer system , sometimes called a client or user device, typically includes a central processing unit (CPU) , hereinafter processor , an input output (I\/O) interface , and a memory . In one embodiment, memory  includes a page based virtual memory system that uses pages, e.g., memory areas.","For example, Windows\u00ae NT and Windows\u00ae 2000 are 32-bit operating systems widely used on home and business computer systems. Windows\u00ae NT and Windows\u00ae 2000 provide page-based virtual memory management schemes that permit programs to realize a 4GB (gigabyte) virtual memory address space. In one embodiment, when processor  is running in virtual memory mode, all addresses are assumed to be virtual addresses and are translated, or mapped, to physical addresses each time processor  executes a new instruction to access memory.","Conventionally, the 4GB virtual memory address space is divided into two parts: a lower 2GB user address space, also referred to as user mode address space or ring , available for use by a program; and, a high 2GB system address space, also referred to as kernel address space or ring , reserved for use by the operating system.","To protect the integrity of the operating system code and other kernel address space code and data structures from errant or malicious programs and to provide efficient system security (user rights management), Windows\u00ae NT and Windows\u00ae 2000 separate code executing in the user address space, e.g., user mode, from code executing in the kernel address space, e.g., kernel mode. User mode code typically does not have direct access to kernel mode code and has restricted access to computer system resources and hardware. To utilize kernel mode code functionalities, such as access to disk drives and network connections, user mode programs utilize system calls, sometimes called operating system (OS) function calls or APIs, that interface between the user mode and kernel mode functions.","Host computer system  may further include standard devices like a keyboard , a mouse , a printer , and a display device , as well as, one or more standard input\/output (I\/O) devices , such as a compact disk (CD) or DVD drive, floppy disk drive, or other digital or waveform port for inputting data to and outputting data from host computer system . In one embodiment, Return-to-LIBC attack blocking application  is loaded into host computer system  via I\/O device , such as from a CD, DVD or floppy disk containing Return-to-LIBC attack blocking application .","Host computer system  is coupled to a server system  of client-server system  by a network . Server system  typically includes a display device , a processor , a memory , and a network interface .","Further, host computer system  is also coupled to a hacker computer system  of client-server system  by network . In one embodiment, hacker computer system  is similar to host computer system , for example, includes a central processing unit, an input output (I\/O) interface, and a memory. Hacker computer system  may further include standard devices like a keyboard, a mouse, a printer, a display device and an I\/O device(s). The various hardware components of hacker computer system  are not illustrated to avoid detracting from the principals of the invention.","Network  can be any network or network system that is of interest to a user. In various embodiments, network interface  and I\/O interface  include analog modems, digital modems, or a network interface card.","Return-to-LIBC attack blocking application  is stored in memory  of host computer system  and executed on host computer system . The particular type of and configuration of host computer system , hacker computer system , and server system  are not essential to this embodiment of the present invention.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 2","FIGS. 1 and 2"],"b":["200","106","108","200"]},"From an enter operation , flow moves to a hook critical operating system (OS) function(s) operation . In hook critical OS function(s) operation , the critical operating system functions, e.g., at least one critical operating system function, of host computer system  are hooked. In one embodiment, a system level, e.g., a kernel mode module or kernel mode driver, hooks the critical operating system functions. Further, in one embodiment, an operating system function is hooked by redirecting calls to the operating system function, for example, to a hook module in accordance with the present invention.","In one embodiment, an operating system function is critical if it is necessary for a first application, e.g., a parent application, to cause execution of a second application, e.g., a child application. In one particular embodiment, an operating system function is critical if it is necessary or likely to be used by a malicious parent application, e.g., an application which contains or uses malicious code, e.g., located on the stack, to execute a child application, where the child application allows remote access, e.g., remote system level access. Examples of child applications include the command prompt or \u201ccmd.exe\u201d on a Windows\u00ae operating system and \u201c\/bin\/sh\u201d on a UNIX or UNIX like, e.g., FreeBSD or MacOS x, operating system. As used herein, a child application is not dependent upon a parent application, i.e., once the child application is executed the parent application can be terminated without termination of the child application.","In one embodiment, on a Windows\u00ae operating system, the CreateProcess() and System() are critical OS functions. In yet another embodiment, critical OS functions are located in the C-library hence the name \u201cReturn-to-LIBC\u201d attack.","As is well known to those of skill in the art, system calls expose all kernel functionality that user-mode programs require. User-mode programs need to utilize the functionality provided by the kernel, for example, to access disk drives, network connections, and shared memory. More particularly, because the processor prevents direct access to kernel mode functions by user-mode programs, user-mode programs use system calls, which form the only permitted interface between user-mode and kernel mode. In accordance with one embodiment, system calls include critical OS function calls and non-critical OS function calls.","From hook critical OS function(s) operation , flow moves to a call to critical OS function operation . In call to critical OS function operation , a call, sometimes called a critical OS function call, to a critical OS function is made by a call module of a parent application. The parent application may be malicious or non-malicious. More particularly, a critical OS function call is made by a call module of a parent application to an OS function that was hooked in hook critical OS function(s) operation .","In accordance with one embodiment of the present invention, a call module includes the critical OS function call instruction(s), i.e., the instruction or set of instructions that originates the critical OS function call. The call module may be malicious or non-malicious. The parent application includes the call module, or, in one embodiment, the parent application is the call module.","For example, system calls are originated by execution of a CALL instruction or a RET instruction (in the case of a Return-to-LIBC attack). In one embodiment, a CALL instruction is used to divert execution to a particular function. A RET instruction, sometimes called a return instruction, is used to return from a subroutine or marks the end of a main function.","From call to critical OS function operation , flow moves to a stall call operation . In stall call operation , the critical OS function call of operation  to the critical OS function is stalled, i.e., is prevented from reaching the operating system. By stalling the critical OS function call, execution of the critical OS function is stalled.","From stall call operation , flow moves to a critical OS function call from RET instruction check operation . In check operation , a determination is made as to whether the critical OS function call originated from execution of a RET instruction. If a determination is made in check operation  that the critical OS function call did not originate from execution of a RET instruction, flow moves to an allow call to proceed operation .","In allow call to proceed operation , the critical OS function call is allowed to proceed. More particularly, the critical OS function call is passed to the operating system. As discussed above, the critical OS function call was stalled in stall call operation . From allow call to proceed operation , flow moves to and exits at an exit operation  or waits for the next critical OS function call and returns to operation .","In a typical Return-to-LIBC attack, a return address is replaced with a malicious return address pointing to a library function in a loaded library, e.g., the C-library, inside the process address space by exploiting a buffer overflow. Thus, when the malicious return address is used by the RET instruction of the call module, a critical OS function call is made. Thus, because a determination is made that the critical OS function call did not originate from execution of a RET instruction in check operation , the likelihood that the call module is malicious code is minimal. In one embodiment, malicious code is defined as any computer program, module, set of modules, or code that enters a computer system without an authorized user's knowledge and\/or without an authorized user's consent.","However, if a determination is made in check operation  that the critical OS function call did originate from execution of a RET instruction, flow moves, optionally, to a known false positive check operation  (or directly to a take protective action operation  if known false positive check operation  is not performed).","In known false positive check operation , a determination is made as to whether the critical OS function call is a known false positive. A known false positive critical OS function call is a critical OS function call that originates from execution of a RET instruction but is, in fact, safe, i.e., is not associated with malicious code. An example of a known false positive critical OS function call is the case when non malicious code pushes an OS function address on to the stack and then transfers control to the OS function via a RET instruction. Illustratively, a user-defined or downloadable exclusion and\/or inclusion list is used to determine whether the critical OS function call is a known false positive.","If a determination is made in check operation  that the critical OS function call is a known false positive critical OS function call, flow moves to allow call to proceed operation , which is performed as discussed above. Conversely, if a determination is made in check operation  that the critical OS function call is not a known false positive critical OS function call, flow moves to a take protective action operation .","In take protective action operation , protective action is taken to prevent the malicious code of or used by the call module from causing damage to or exploiting host computer system . For example, the critical OS function call is terminated. More particularly, the critical OS function call is not passed to the operating system but is terminated. As discussed above, the critical OS function call was stalled in stall call operation .","By terminating the critical OS function call, the malicious code of the call module is prevented from exploiting and\/or damaging host computer system . In one embodiment, by terminating the critical OS function call, the child application is prevented from being executed. By preventing execution of the child application, remote access is denied thus preventing unauthorized access by malicious hackers as well as by replicating malware, e.g., worms.","In one embodiment, because a determination is made in check operation  that the critical OS function call did originate from execution of a RET instruction, the likelihood that the call module is malicious code is significant. However, by terminating the critical OS function call, the critical OS function is prevented from being execution. By preventing execution of the critical OS function, remote access is denied, thus preventing unauthorized access by malicious hackers and also by replicating malware, e.g., worms.","As another example of protective action, the parent application including the call module and\/or a malicious thread running within the context of the parent application is terminated. Termination of applications is well known to those of skill in the art and so is not discussed further for clarity of discussion.","Flow moves from take protective action operation , optionally, to a notify host computer system user\/administrator operation  (or directly to exit operation  if operation  is not performed). In notify host computer system user\/administrator operation , the user of host computer system  and\/or the administrator are notified that protective action has been taken on host computer system , e.g., that a call, a parent application and\/or a call module have been terminated. The user and\/or administrator can be notified using any one of a number of techniques, e.g., by using a pop up window, by writing to a file and\/or otherwise by logging the event. Further, a notification can be provided to a security center.","From notify host computer system user\/administrator operation , flow moves to and exits at exit operation  or waits for the next critical OS function call and returns to operation .",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 3","FIGS. 2 and 3","FIG. 1"],"b":["300","306","308","204","306","106"]},"More particularly, a hooked system service table  routes noncritical OS function calls directly to the operating system (not shown). However, hooked system service table  routes critical OS function calls to hook module , e.g., a kernel mode module or kernel mode driver.","As is well known to those of skill in the art, a system service table, sometimes called a dispatch table or a system call table, relates system calls to specific addresses within the operating system kernel. Hooked system service table  in accordance with one embodiment of the present invention, redirects critical OS function calls to hook module  and from the specific addresses within the operating system kernel to which the critical OS function calls would otherwise be directed.","Although  describes one example of a hooked operating system function call path, in light of this disclosure, those of skill in the art will understand that other techniques can be used to hook operating system function(s). The particular technique used depends, for example, on the particular operating system.","In one embodiment, hook module  is used to stall a critical OS function call during stall call operation  of . Further, hook module  continues to stall the critical OS function call during critical OS function call from RET instruction check operation  (and known false positive check operation  if performed). Hook module  allows the critical OS function call to proceed to the operating system and thus to critical OS function  during allow call to proceed operation . Conversely, hook module  terminates the critical OS function call and\/or takes other protective action during take protective action operation .","In accordance with this embodiment, a critical OS function call  originates from a call module  during call to critical OS function operation . Critical OS function call  is routed by hooked system service table  to hook module . Critical OS function call  is stalled by hook module  in stall call operation .",{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 4","FIG. 1"],"b":["440","310","440","114","440","114"]},"The register ESP, i.e., the extended stack pointer, holds the top of the stack. More particularly, the register ESP holds a value, sometimes called the stack pointer, that is the address of the top of the stack. Accordingly, the address of the top of the stack is sometimes called address [ESP]. The top of the stack is the address where instructions that use the stack, e.g., PUSH, POP, CALL and RET instructions, actually use the stack. The operation and use of stacks, stack pointers, and the top of the stack are well known to those of skill in the art. Note that the bottom of the stack is the uppermost area of stack  in the view of , i.e., the top of stack  is down in the view of  and the bottom of stack  is up in the view of . Generally, the addresses in stack  decrease towards the top of the stack, i.e., the addresses decrease going down in the view of .","Referring now to  together, to originate critical OS function call , call module  executes instructions , , , and . More particularly, call module  includes instructions ,  and  that push parameter P, parameter P, and parameter P, respectively, on to stack . Call module  further includes an instruction  that calls a critical OS function and an instruction  that decrements the stack pointer for cleanup of stack  as those of skill in the art will understand.","Execution of instructions ,  and  push parameter P, parameter P, and parameter P, respectively, on to stack  as shown by the arrows. Execution of instruction  causes critical OS function call  to be made and pushes the return address RA to which the critical OS function is to return, e.g., the address of instruction , on to stack  as shown by the arrow.","Accordingly, when critical OS function call  is made by call module , the top of the stack at address [ESP] contains the return address RA. The previous top of stack, sometimes called the previous DWORD, contains a value V typically unrelated to critical OS function call . In one embodiment, the previous top of stack is the memory address at which the last (most recent) value from the stack was popped, i.e., read. The value, sometimes called data, in the previous top of the stack is still there because the value is just read from the stack when it is popped and not overwritten. In one embodiment, the previous top of the stack is at address [ESP-], i.e., the stack pointer minus 4 bytes.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 5","FIG. 2","FIGS. 2","FIG. 2"],"b":["210","200","3","4","5","502","208","504","504","4","504","506"]},"In check operation , a determination is made as to whether the value V at the previous top of stack at address [ESP-] determined in operation  is equivalent, and in one embodiment, exactly equal, to the address of the critical OS function being called. In accordance with this embodiment, critical OS function call  is a call to critical OS function , which is located at a particular address in memory  (). The particular address of critical OS function  is obtained using any one of a number of techniques well known to those of skill in the art and the particular technique used is not essential to the present invention.","As discussed above, the previous top of stack at address [ESP-] contains a value V typically unrelated to critical OS function call  and, specifically, unrelated to the address of critical OS function . Accordingly, in this embodiment where call module  is not malicious, a determination is made in check operation  that the value at the previous top of stack at address [ESP-] is not equivalent to the address of critical OS function . Accordingly, flow moves to allow call to proceed operation  through operation .",{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIG. 6","FIGS. 2 and 6","FIG. 3"],"b":["300","306","308","304"]},"In accordance with this embodiment, a critical OS function call  originates from a malicious call module  during call to critical OS function operation . For example, control is transferred from a parent application  to malicious call module . As discussed further below, instead of returning control to parent application , malicious call module  originates critical OS function call  by executing a RET instruction using a malicious return address placed on to a stack as a result of a buffer overflow in a typical Return-to-LIBC attack.","Critical OS function call  is routed by hooked system service table  to hook module . Critical OS function call  is stalled by hook module  in stall call operation .",{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 7","FIGS. 6 and 7"],"b":["440","610","610","602","702"]},"More particularly, malicious call module  includes RET instruction  () that is used to return control to parent application  during normal operation. However, by exploiting a buffer overflow, malicious parameters are loaded into overflowed stack A. For example, a buffer overflow is exploited from hacker computer system  ().","Specifically, a buffer overflow is exploited to load parameters PZ, PY, PX and a dummy return address DRA into addresses [ESP+], [ESP+], [ESP+], [ESP], respectively, of overflowed stack A. Also, the value V, sometimes called a malicious return address, is loaded into address [ESP-] of overflowed stack A during the exploitation of the buffer overflow.","Accordingly, during execution of RET instruction  of malicious call module , the value V is read, sometimes called popped, from overflowed stack A. Accordingly, malicious call module  returns to the address specified by value V. As part of the Return-to-LIBC attack, the value V is the address of critical OS function . Thus, malicious call module  attempts to transfer control to critical OS function  by generating critical OS function call .","Accordingly, when critical OS function call  is made by malicious call module , the previous top of stack at address [ESP-] contains a value V, which is the address of critical OS function . Further, the top of the stack at address [ESP] contains dummy return address DRA followed by PX, PY and PZ, which is what critical OS function  would expect to see in the stack and thus intentionally placed there during the Return-to-LIBC attack.","Referring now to , ,  and  together, from enter operation  (and from stall call operation  of ), flow moves to look up value at previous top of stack operation . In operation , the value V at the previous top of stack at address [ESP-], i.e., the address of critical OS function , is determined. From operation , flow moves to value equivalent to address of critical OS function check operation .","In check operation , a determination is made that the value V at the previous top of stack at address [ESP-] determined in operation  is equivalent to the address of the critical OS function being called.","Accordingly, in this embodiment where malicious call module  is malicious, a determination is made in check operation  that the value at the previous top of stack at address [ESP-] is equivalent to the address of critical OS function . Accordingly, flow moves to known false positive check operation  (or directly to take protective action operation  if known false positive check operation  is not performed) through operation .","After a determination that critical OS function call  is not a known false positive in check operation , protective action is taken in take protective action operation .","Illustratively, hook module  terminates critical OS function call . By terminating critical OS function call , execution of critical OS function  is prevented. This, in turn, denies remote access thus preventing unauthorized access to host computer system  by malicious hackers and also by replicating malware, e.g., worms.","Optionally, operation  is performed as discussed above and flow exits at exit operation .","Referring again to , Return-to-LIBC attack blocking application  is in computer memory . As used herein, a computer memory refers to a volatile memory, a non-volatile memory, or a combination of the two.","Although Return-to-LIBC attack blocking application  is referred to as an application, this is illustrative only. Return-to-LIBC attack blocking application  should be capable of being called from an application or the operating system. In one embodiment, an application is generally defined to be any executable code. Moreover, those of skill in the art will understand that when it is said that an application or an operation takes some action, the action is the result of executing one or more instructions by a processor. In one embodiment, Return-to-LIBC attack blocking application  is implemented as a system level, e.g., kernel mode driver.","While embodiments in accordance with the present invention have been described for a client-server configuration, an embodiment of the present invention may be carried out using any suitable hardware configuration involving a personal computer, a workstation, a portable device, or a network of computer devices. Other network configurations other than client-server configurations, e.g., peer-to-peer, web-based, intranet, internet network configurations, are used in other embodiments.","Herein, a computer program product comprises a medium configured to store or transport computer readable code in accordance with an embodiment of the present invention. Some examples of computer program products are CD-ROM discs, DVDs, ROM cards, floppy discs, magnetic tapes, computer hard drives, servers on a network and signals transmitted over a network representing computer readable code.","As illustrated in , this medium may belong to the computer system itself. However, the medium also may be removed from the computer system. For example, Return-to-LIBC attack blocking application  may be stored in memory  that is physically located in a location different from processor . Processor  should be coupled to the memory . This could be accomplished in a client-server system, or alternatively via a connection to another computer via modems and analog lines, or digital interfaces and a digital carrier line.","More specifically, in one embodiment, host computer system  and\/or server system  is a portable computer, a workstation, a two-way pager, a cellular telephone, a digital wireless telephone, a personal digital assistant, a server computer, an Internet appliance, or any other device that includes components that can execute the Return-to-LIBC attack blocking functionality in accordance with at least one of the embodiments as described herein. Similarly, in another embodiment, host computer system  and\/or server system  is comprised of multiple different computers, wireless devices, cellular telephones, digital telephones, two-way pagers, or personal digital assistants, server computers, or any desired combination of these devices that are interconnected to perform, the methods as described herein.","In view of this disclosure, the Return-to-LIBC attack blocking functionality in accordance with one embodiment of present invention can be implemented in a wide variety of computer system configurations. In addition, the Return-to-LIBC attack blocking functionality could be stored as different modules in memories of different devices. For example, Return-to-LIBC attack blocking application  could initially be stored in server system , and then as necessary, a portion of Return-to-LIBC attack blocking application  could be transferred to host computer system  and executed on host computer system . Consequently, part of the Return-to-LIBC attack blocking functionality would be executed on processor  of server system , and another part would be executed on processor  of host computer system . In view of this disclosure, those of skill in the art can implement various embodiments of the present invention in a wide-variety of physical hardware configurations using an operating system and computer programming language of interest to the user.","In yet another embodiment, Return-to-LIBC attack blocking application  is stored in memory  of server system . Return-to-LIBC attack blocking application  is transferred over network  to memory  in host computer system . In this embodiment, network interface  and I\/O interface  would include analog modems, digital modems, or a network interface card. If modems are used, network  includes a communications network, and Return-to-LIBC attack blocking application  is downloaded via the communications network.","This disclosure provides exemplary embodiments of the present invention. The scope of the present invention is not limited by these exemplary embodiments. Numerous variations, whether explicitly provided for by the specification or implied by the specification or not, may be implemented by one of skill in the art in view of this disclosure."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWING","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 5","FIG. 2"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
