---
title: Method and system for deploying a model-based application to an application server
abstract: Computer-based methods and systems for deploying model-driven applications to an application server are described. Consistent with an embodiment of the invention, an application server includes a model deployment module that provides a model deployment service. The model deployment module receives as input a data model that serves as a single source of truth for an application. Based on the input model, the model deployment module configures the application server, for example, by automatically generating object-relational mapping logic that facilitates data persistence by mapping data elements in an object domain to data elements in a relational database domain. Additionally, the model deployment module generates a utility module that supports advanced modeling capabilities, including derived properties and constraints.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08688752&OS=08688752&RS=08688752
owner: Adobe Sytems Incorporated
number: 08688752
owner_city: San Jose
owner_country: US
publication_date: 20090828
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["The present disclosure generally relates to model-driven software development tools. More specifically, the present disclosure relates to methods and systems for deploying a model-based application to an application server.","A model-driven software development technique is a development methodology in which models, or abstractions, are utilized to implement a software application. For example, utilizing a model-driven software development tool, an application developer may develop a graphical or text-based model of a software application. The model is then provided as input to a code generator, which analyzes the model and generates application code for a target platform based on the model.","A variety of problems exist with conventional model-driven software development tools. First, many conventional model-driven software development tools only generate a portion of the necessary code required to successfully deploy a fully functional application. For instance, many development tools will only generate a portion of the server-side code (e.g., the application tier, or, the database tier) that is required to successfully implement a working application. This leaves the application developer to manually code the remaining portions of the server-side code. Similarly, some tools only generate server-side code (or, client-side code) based on a model, leaving the application developer to manually generate the client-side code (or, server side-code).","Another problem with many conventional development tools is that they lack the ability to fully deploy the code generated based on the model. For instance, many development tools generate code, but require an application developer to perform various configuration tasks at the target platform (e.g., an application server), and\/or manually install the code on the target platform. This problem is compounded when the application is bound for a target platform that utilizes an object-oriented programming paradigm in conjunction with a relational database to persist data. In such a scenario, the code that performs the translation or conversion between data elements in the object domain and data elements in the relational database domain must be updated every time the database schema changes. Consequently, application developers are often tasked with manually updating and configuring the application code.","Methods and systems for deploying a model-based application to an application server are described. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the various aspects of different embodiments of the present invention. It will be evident, however, to one skilled in the art, that the present invention may be practiced without these specific details.","Consistent with an embodiment of the invention, an application server includes a model deployment service, facilitated by a model deployment module, which enables the deployment of a model-based software application at the application server. Accordingly, an application developer with a complete and annotated data model can utilize the model deployment service to fully create and configure the application server for the application described by the model. In some embodiments, deploying a fully annotated model enables an application developer to generate a working application without having to write a single line of code and without having to manually configure any portion of the application server.","The model deployment service enables, through the use of a single model, the configuration of the database tier. For instance, the model deployment service provides a mechanism to establish the database schemas (e.g., tables and indices) defined by the model, and enables the creation and\/or configuration of object-relational mapping logic to map data elements within the object domain with data elements residing in the relational database domain, thereby providing a mechanism for persisting application data.","In addition to enabling the configuration of the database tier, the model deployment service enables the configuration of the application server tier. In some embodiments, this involves the creation and configuration of destination objects that enable client applications to perform create, read, update and delete (CRUD) operations on the data described by the model and persisted in the relational database.","Furthermore, in contrast to many conventional model-driven application development approaches, some embodiments of the invention provide a modeling framework that supports advanced modeling and data processing features, including support for derived properties, constraints, validations, variant properties, and style information. Furthermore, in some embodiments, tight integration between the modeling framework and the data management tier (e.g., part of the application server tier) allows support for advanced features of the data management tier to be accessed and controlled via the modeling framework. For instance, in some embodiments, the modeling framework, in conjunction with the data management tier, facilitates advanced features including: data caching, data synchronization across all participating clients, efficient paging of data out to clients, and lazy loading of associations. Other aspects of various embodiments of the invention are described in greater detail below, in connection with the description of the figures.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 1","FIG. 1"],"b":["10","18","12","14","16","10","18","20","20","14","10","12","16","14"]},"In some embodiments, the generated model  is the basis for both server-side and client-side application logic. In some embodiments, the model  may have a graphical representation, while in alternative embodiments, the model  may be text-based, or a combination of graphical elements and text. In some embodiments, the model  can be communicated to the application server  over a network  directly from the software development application. For instance, the software development application may provide a user interface component enabling an application developer to select a particular application server to which a particular model is to be automatically communicated, and deployed.","As illustrated in , the application server  includes both an application server tier  and database tier , in addition to a model deployment service . When the model deployment service  is invoked to deploy a model, the model deployment service  will receive and process the model, configure all of the relevant application and database elements of the application server tier and database tier, and generate any required runtime code. As described more completely below, in some embodiments, the model deployment service  generates destination objects for use with the data management tier , and data access objects for use with the object-relational mapping logic . Together, these objects (destination objects and data access objects) provide a mechanism for client applications to perform data operations (e.g., CRUD operations) on data that is persisted in the relational database . Accordingly, once a model-based application is deployed to an application server , client applications, such as clients ,  and , can interact with the deployed application residing with the application server .","As used in , the term \u201capplication server\u201d  refers to the various software components comprising the application server framework, for example, residing and executing on the server computer (with reference number ). In one embodiment, the application server  may be a version of Apache Tomcat, an open source software implementation of the Java Servlet and JavaServer Pages technologies. In some embodiments, the data management tier  may be a web application implemented with a version of LiveCycle Data Services, developed by, and available from, Adobe, Inc. of San Jose, Calif. However, skilled artisans will readily recognize that the terms \u201capplication server\u201d, \u201capplication server framework\u201d and \u201cdata management tier\u201d generally refer to the software framework that is utilized to expose application logic (e.g., business logic) to web- or network-based client applications, often through the use of an application programming interface (API). Moreover, although not necessarily the case, application servers are frequently Java-based (e.g., based on Java Platform, Enterprise Edition, or Java EE). Thus, although example embodiments may be described in the context of an application server based on Tomcat and LiveCycle Data Services, the inventive concepts described and claimed herein are applicable to a wide variety of application servers, server frameworks, and web applications, beyond those that might specifically rely on an implementation of Tomcat and LiveCycle Data Services.","In some embodiments, data is converted from an object domain to a relational database domain, and back again, through the use of a technology generally referred to as object-relational mapping (ORM). In particular, in some embodiments of the invention, the ORM functionality is facilitated by a version of Hibernate. Hibernate is an object-relational mapping (ORM) library for the Java programming language, providing a framework for mapping an object-oriented domain to a traditional relational database. However, various alternative ORM implementations might be used without departing from the scope and spirit of the invention.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 2","FIG. 2","FIG. 2"],"b":["40","32","40","42","40","42"]},"In the context of an embodiment of the invention, the model  is an abstract structure that describes how data is represented and accessed, at the application server . The model  is broadly similar in scope and granularity to a relational database schema, in the sense that it defines an interrelated set of structured data collections, and provides the means to express specification at structure, collection, and relationship scales. The model defines entities (e.g., model entities), which are abstract interrelated data objects. Model entities represent custom data types and are made up of data elements referred to as data properties, which correspond to persistent storage, and derived properties, which are not backed by persistent storage and enable behavior customization in expressions over data properties and function calls. A model also defines abstract services responsible for delivering model entities to and from clients. Services declare collections of functions, external callable endpoints that can be invoked within value expressions. Consistent with some embodiments of the invention, in addition to entities and services, definitions found in the model  include styles, which bundle user-interface-related information with data types, and annotations, which enable an application developer to add domain-specific information to a model.","In some embodiments, the model is an XML-based language that allows an application developer to define model entities, the relationships between those entities, and abstract services responsible for delivering the model entities to data clients. In some embodiments, the modeling language works in conjunction with a set of Java-based API's, referred to as the core API's (and depicted in  as part of the model processing module ), that process and validate the content of the models and can also generate concrete application code, based on the model. For example, the core modeling API's  provide built-in support for generating the following:\n\n","When a model is deployed to an application server , the model deployment module  processes the model, and in particular, the defined model entities, to generate an object-relational mapping (ORM) configuration file . This is illustrated in  by the arrow leading to the block with reference number . The ORM configuration file  specifies mapping attributes to define a mapping between data elements in an object domain, and data elements in a relational database domain. For instance, in some embodiments, the ORM configuration file is a Hibernate configuration file, and specifies a mapping between data properties of an object defined by a model entity and a SQL query used to select data from a relational database.","In addition to generating the ORM configuration file, the model deployment module  processes the model  to generate one or more ORM objects (e.g., data access objects (DAO)) . In some embodiments, one ORM object is generated for each model entity. These ORM objects, or DAO's, are objects that provide an abstract interface to a type of persistence mechanism (e.g., a database), without exposing details of the database. Like the ORM configuration file, the ORM objects provide a mapping between data elements in an object domain, and data elements in a relational database domain\u2014or, from application calls to the persistence layer. The ORM objects provide an isolation layer\u2014in effect, separating the concerns of what data accesses the application needs, in terms of domain-specific objects and data types (e.g., the public interface of the DAO), and how these needs can be satisfied with a specific relational database and database schema (e.g., the implementation of the DAO).","The model deployment module  also generates an application server-specific data management destination object  for each model entity defined in the model. For example, in a particular embodiment with the LiveCycle Data Services web application, the destination objects generated would conform to the LiveCycle Data Services requirements. These destination objects are addressable and provide a client application with an addressable target for requesting data or services provided by the various data objects and data management tier.","Consistent with some embodiments of the invention, the model processing module  generates a model entity utility module  for each model entity defined in the model. As described in greater detail below, the model entity utility module  enables, on a per model entity basis, support for advanced model-supported functions, including: derived properties, constraints, validations, variant properties, and style information. For instance, when a client application communicates a request to the application server for a data element defined by a derived property, the destination object invoked by the client request will invoke the model entity utility model corresponding to the invoked destination object to request that the utility model generate the derived property.",{"@attributes":{"id":"p-0029","num":"0030"},"figref":["FIG. 3","FIG. 3"],"b":["60","60","62","64","66"]},"In one embodiment of the invention, the communications tier may be implemented with Blaze DS from Adobe, Inc. Of course, a wide variety of other software applications or components might also be used. In any case, the communications tier (Java Remoting and Web Messaging Module ) is shown to include both a messaging servlet  and a model deployment servlet . At runtime, the messaging servlet operates to handle the routing of messages between the application server module  and the client applications (e.g., client ). Similarly, during model deployment, the model deployment servlet  handles the routing of the model  between the software development application that is communicating the model to the application server , and the application server  itself.","In some embodiments, the application tier (represented in  as the application server module ) may be implemented with Adobe LiveCycle Data Services. Of course, a wide variety of alternative software applications or components might also be used. In any case, as illustrated in , the application server module  includes three sub-modules: an application data management module , a model-application integration module , and a model processing module .","In some embodiments, when a model is first communicated to the application server to be deployed, the model processing module  receives and processes the model. In particular, various processes associated with the core API of the model processing module are invoked. One such process involves validating the model to determine whether the model conforms to certain formatting and substantive requirements. Additionally, the model processing module  may save a copy of the model to non-volatile storage (e.g., a fixed disk drive) and modify one or more server initialization routines so that upon restarting the server, the model is automatically processed and deployed. In addition, the model processing module  processes the model to generate the outputs described in connection with the description of  (e.g., the outputs with reference numbers , ,  and  in ). For example, the model processing module  generates an ORM configuration file (e.g., a Hibernate XML file), and for each model entity, a corresponding ORM object  (e.g., Hibernate plain old java objects (POJOs)), a corresponding destination object , and a corresponding model entity utility module .","The model-application integration module  includes logic utilized to process model-driven applications, both in the deployment stage and at runtime. For example, the destination manager  of the integration module  facilitates the generation, deployment and management of the destination objects  during deployment of the model. The model assembler  handles requests from destination objects and ORM objects  to facilitate the communication of data between modules operating in the object domain and the relational database domain.","The application data management module  provides the core library and an API for performing various data processing tasks loosely associated with the application logic. For example, the application data management module  operates in conjunction with one or more other modules to enable data caching, data synchronization across all participating clients, efficient paging of data out to clients, and lazy loading of associations. In addition, the destination objects  and model entity utility module  are part of and operate in conjunction with the application data management module . The model entity utility module  provides functionality associated with advanced modeling features, such as derived properties, constraints, validations, variant properties, and style information.","The database module  includes the object-relational mapping database module . In some embodiments, this module  is an implementation of Hibernate. Of course, other software components or applications might be used to provide similar functionality. In any case, the object-relational mapping database module  includes the SQL commands for querying the relational database . The database module  operates in conjunction with the ORM objects  to provide a mechanism for converting data in the object domain to the relational database domain and vice versa.","When a model  is initially communicated to the application server , the model is received at the model deployment servlet . The model deployment servlet  routes the model  to the destination manager  and ultimately to the model processing module  where the model  is initially processed to generate the various outputs, including an ORM configuration file, one or more destination objects , one or more ORM objects , and one or more model entity utility modules .","At runtime, a client  communicates a message to the messaging servlet  of the application server . The message is directed to the addressed destination object  where it is initially processed. If the message includes a request to perform a simple CRUD operation, the destination object invokes the model assembler , which in turn instantiates an ORM object that is processed by the ORM database module . If the request involves an advanced operation, such as a request for a derived property, the model entity utility module  for the destination object  is invoked to process the request. Further aspects of the model deployment and runtime routines are described in connection with the description of .",{"@attributes":{"id":"p-0038","num":"0039"},"figref":"FIG. 4","b":"100"},"At method operation , the model is processed to generate a configuration file for use in mapping data elements (e.g., data properties of objects) in the object domain, to data elements in a relational database domain. Next, at method operation , for each model entity defined in the model, an addressable destination object is generated. These destination objects receive client requests involving requests for data operations, at runtime.","Next, at method operation , for each model entity defined in the model, a data access object, or ORM object, is generated. In some embodiments, the ORM objects are Hibernate POJOs. The Hibernate POJOs facilitate the conversion of data between an object domain and a relational database domain.","Finally, at method operation , for each model entity defined in the model, a model entity utility module is generated. The model entity utility module provides advanced modeling features, including the ability to compute at runtime, derived properties, variant properties, constraints, validation and style information.","The various operations of example methods described herein may be performed, at least partially, by one or more processors that are temporarily configured (e.g., by software) or permanently configured to perform the relevant operations. Whether temporarily or permanently configured, such processors may constitute processor-implemented modules that operate to perform one or more operations or functions. Accordingly, the modules referred to herein may, in some example embodiments, comprise processor-implemented modules.","Similarly, the methods described herein may be at least partially processor-implemented. For example, at least some of the operations of a method may be performed by one or more processors or processor-implemented modules. The performance of certain of the operations may be distributed among the one or more processors, not only residing within a single machine, but deployed across a number of machines. In some example embodiments, the processor or processors may be located in a single location (e.g., within a home environment, an office environment or at a server farm), while in other embodiments the processors may be distributed across a number of locations.","The one or more processors may also operate to support performance of the relevant operations in a \u201ccloud computing\u201d environment or as a service, for example, such as in the context of \u201csoftware as a service\u201d (SaaS). For example, at least some of the operations may be performed by a group of computers (as examples of machines including processors), these operations being accessible via a network (e.g., the Internet) and via one or more appropriate interfaces (e.g., Application Program Interfaces (APIs).)",{"@attributes":{"id":"p-0045","num":"0046"},"figref":"FIG. 5"},"The example computer system  includes a processor  (e.g., a central processing unit (CPU), a graphics processing unit (GPU) or both), a main memory  and a static memory , which communicate with each other via a bus . The computer system  may further include a display unit , an alphanumeric input device  (e.g., a keyboard), and a user interface (UI) navigation device  (e.g., a mouse). In one embodiment, the display, input device and cursor control device are a touch screen display. The computer system  may additionally include a storage device (e.g., drive unit ), a signal generation device  (e.g., a speaker), a network interface device , and one or more sensors , such as a global positioning system sensor, compass, accelerometer, or other sensor.","The drive unit  includes a machine-readable medium  on which is stored one or more sets of instructions and data structures (e.g., software ) embodying or utilized by any one or more of the methodologies or functions described herein. The software  may also reside, completely or at least partially, within the main memory  and\/or within the processor  during execution thereof by the computer system , the main memory  and the processor  also constituting machine-readable media.","While the machine-readable medium  is illustrated in an example embodiment to be a single medium, the term \u201cmachine-readable medium\u201d may include a single medium or multiple media (e.g., a centralized or distributed database, and\/or associated caches and servers) that store the one or more instructions. The term \u201cmachine-readable medium\u201d shall also be taken to include any tangible medium that is capable of storing, encoding or carrying instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention, or that is capable of storing, encoding or carrying data structures utilized by or associated with such instructions. The term \u201cmachine-readable medium\u201d shall accordingly be taken to include, but not be limited to, solid-state memories, and optical and magnetic media. Specific examples of machine-readable media include non-volatile memory, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks such as internal hard disks and removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks.","The software  may further be transmitted or received over a communications network  using a transmission medium via the network interface device  utilizing any one of a number of well-known transfer protocols (e.g., HTTP). Examples of communication networks include a local area network (\u201cLAN\u201d), a wide area network (\u201cWAN\u201d), the Internet, mobile telephone networks, Plain Old Telephone (POTS) networks, and wireless data networks (e.g., Wi-Fi\u00ae and WiMax\u00ae networks). The term \u201ctransmission medium\u201d shall be taken to include any intangible medium that is capable of storing, encoding or carrying instructions for execution by the machine, and includes digital or analog communications signals or other intangible medium to facilitate communication of such software.","Although an embodiment has been described with reference to specific example embodiments, it will be evident that various modifications and changes may be made to these embodiments without departing from the broader spirit and scope of the invention. Accordingly, the specification and drawings are to be regarded in an illustrative rather than a restrictive sense. The accompanying drawings that form a part hereof, show by way of illustration, and not of limitation, specific embodiments in which the subject matter may be practiced. The embodiments illustrated are described in sufficient detail to enable those skilled in the art to practice the teachings disclosed herein. Other embodiments may be utilized and derived therefrom, such that structural and logical substitutions and changes may be made without departing from the scope of this disclosure. This Detailed Description, therefore, is not to be taken in a limiting sense, and the scope of various embodiments is defined only by the included claims, along with the full range of equivalents to which such claims are entitled."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF THE FIGURES","p":["Some embodiments are illustrated by way of example and not limitation in the figures of the accompanying drawings, in which:",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
