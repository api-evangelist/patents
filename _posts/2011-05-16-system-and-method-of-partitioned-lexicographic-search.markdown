---
title: System and method of partitioned lexicographic search
abstract: A search method is provided. The method comprises, building a first plurality of collectors, associating a first plurality of index entries with the first plurality of collectors, wherein each index entry comprises a search target and is associated with at least one of the first plurality of collectors based on a similarity between the search target of the index entry and the at least one collector, selecting a second plurality of collectors from among the first collectors based on a similarity between a search term and each of the second plurality of collectors, selecting a second plurality of index entries from among the index entries associated with the second plurality of collectors based on a similarity between the search term and the search target of each of the index entries associated with the second plurality of collectors, and presenting information related to the second plurality of index entries.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09129010&OS=09129010&RS=09129010
owner: ARGO DATA RESOURCE CORPORATION
number: 09129010
owner_city: Richardson
owner_country: US
publication_date: 20110516
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT","REFERENCE TO A MICROFICHE APPENDIX","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["None.","Not applicable.","Not applicable.","Data may be stored in data stores and\/or data bases that provide access to the data via application programming interfaces to other applications that use the data in various ways. Banks and\/or financial services companies may store account information in data stores. Telecommunications service providers may store account information and\/or information about subscribers in data stores. Data stores and\/or data bases may be an abstraction that is supported by underlying software that executes on one or more servers. Data in the data store and\/or data bases may be accessed based on one or more keys. Typically, to access a particular item of data in a data store, for example to access an entry for a financial account, a key that exactly matches the key of the subject entry needs to be provided.","In an embodiment, a computer automated search method is disclosed. The method comprises an application executing on a computer building a first plurality of collectors and an application executing on a computer associating a first plurality of index entries with the first plurality of collectors, wherein each index entry comprises a search target wherein each index entry is associated with at least one of the first plurality of collectors based on a similarity between the search target of the index entry and the at least one collector. The method further comprises an application executing on a computer selecting a second plurality of collectors from among the first collectors based on a similarity between a search term and each of the second plurality of collectors and an application executing on a computer selecting a second plurality of index entries from among the index entries associated with the second plurality of collectors based on a similarity between the search term and the search target of each of the index entries associated with the second plurality of collectors. The method further comprises presenting information related to the second plurality of index entries.","In an embodiment, a computer automated search method is disclosed. The method comprises an application executing on a computer building a first plurality of collectors and an application executing on a computer associating a first plurality of index entries with the first plurality of collectors to create an index, wherein each index entry comprises a search target, wherein each one of the first plurality of index entries is associated with at least one of the first plurality of collectors based on a similarity between the search target of the index entry and the at least one collector. The method further comprises, in response to one of adding at least one index entry to the index or deleting at least one index entry from the index to create a second plurality of index entries, an application executing on a computer building a second plurality of collectors using the genetic algorithm, wherein the second plurality of collectors is based on the first plurality of collectors. The method further comprises an application executing on a computer associating the second plurality of index entries with the second plurality of collectors, wherein each one of the second plurality of index entries is associated with at least one of the second plurality of collectors based on a similarity between the search target of the index entry and the at least one collector and an application executing on a computer selecting a third plurality of collectors from among the second plurality of collectors based on a similarity between a search term and the third plurality of collectors. The method further comprises an application executing on a computer selecting a third plurality of index entries from among the second plurality of index entries associated with the third plurality of collectors based on a similarity between the search term and the search target of each of the third plurality of index entries and presenting information related to the third plurality of index entries.","In an embodiment, a computer automated method for determining a similarity between two symbol strings is disclosed. The method comprises an application executing on a computer receiving a first symbol string. The method further comprises creating a data structure that has a first group of elements, wherein the number of elements in the first group of elements is equal to the number of different symbol values in a symbol set that the first symbol string is composed from, and wherein each element of the first group of elements corresponds to one of the symbol values and indicates the location of the corresponding symbol value in the first symbol string. The method further comprises receiving a second symbol string, wherein the second symbol string is composed from the symbols that comprise the symbol set and determining a similarity between the second symbol string and the first symbol string based on using each of the symbols of the second symbol string to index into the corresponding element of the first group of elements in the data structure to determine whether the subject symbol in the second symbol string is present in the first symbol string. The method further comprises automatically taking an action based on the similarity between the second symbol string and the first symbol string.","These and other features will be more clearly understood from the following detailed description taken in conjunction with the accompanying drawings and claims.","It should be understood at the outset that although illustrative implementations of one or more embodiments are illustrated below, the disclosed systems and methods may be implemented using any number of techniques, whether currently known or not yet in existence. The disclosure should in no way be limited to the illustrative implementations, drawings, and techniques illustrated below, but may be modified within the scope of the appended claims along with their full scope of equivalents.","A system and method for conducting partitioned lexicographic searches is described. These searches may be conducted based on one or more similarity metrics and may be referred to in some contexts as partitioned lexicographic similarity-based searches. As used herein, a similarity-based search is meant to refer to a search that is conducted to find a plurality of near or approximate matches of entries in a data store to a search term. Such near or approximate matches to the search term are, in a sense, similar to the search term. For example, a lexicographic similarity-based search of a data store using \u2018robed brown\u2019 as the search term may return a plurality of entries from the data store, including entries having a name field of \u2018robed brown\u2019, \u2018roberta brown\u2019, \u2018robed braun\u2019, \u2018robert towne\u2019, \u2018roger brown\u2019, and others. As another example, a lexicographic similarity-based search using \u2018robrt brown\u2019 as the search term may likewise return a plurality of entries from the data store including entries having a name field of \u2018robert brown\u2019, \u2018roberta brown\u2019, \u2018robert braun\u2019, \u2018robert towne\u2019, \u2018roger brown\u2019, and others. It is understood that the entries in the data store may have a number of fields in addition to the name field, for example an address field, an account number field, a driver license number field, a social security number field, and other fields.","A lexicographic search is a search that is seeking to find a relatively small symbol string, for example a name like \u201crobert brown\u201d or an address such as \u201c12345 street, anytown, us, 54321.\u201d In an embodiment, a lexicographic search may be limited to seeking a symbol string comprised of less than 1000 symbols. A lexicographic search is distinct from a document search, which may seek an entire document based on some search criteria, for example based on word frequencies. The term lexicographic search as used herein may be said to involve searching structured data. For example, a name, an address, or a social security number are structured pieces of data with specific meaning as a field or collection of fields. By contrast, document searches may be said to involve searching unstructured data, for example searching a lot of text with no readily characterized structure.","Without limiting the applicability of the partitioned lexicographic search disclosed herein, a lexicographic similarity-based search may be able to find wanted entries or records in a data store based on an input search term that is not an exact match to one of the keys of the entry in the data store. The set of near matches to the search term may be identified by determining a similarity metric that quantifies a similarity between the search term and one or more fields in the entries in the data store, and selecting those near matches that are most nearly similar to the search term, as quantified by the similarity metrics. In an embodiment, the similarity metric may be calculated using an edit distance algorithm, for example a Jaro edit distance algorithm or a modified Jaro edit distance algorithm. It is understood that the concept of near match includes an exact match. Thus, both \u2018roberta\u2019 and \u2018robert\u2019 may be deemed near matches to the search term \u2018robert.\u2019","Data stores that are used in some practical business environments may comprise up to about 1 million entries, up to about 5 million entries, up to about 10 million entries, or more entries. Calculating a similarity metric between a search term and a field in every entry in a data store may become intractable as the number of the entries in the data store grows large: the search may take too long to complete and\/or may consume more processing resources than desirable. The present disclosure teaches intelligently pruning or selecting the portions of the database that are searched, thereby limiting the processing load of conducting the lexicographic similarity-based search in a large data store environment. This is accomplished by creating an index data store comprising index entries that may reference or identify the corresponding entries in the data store. A plurality of partitions are defined, and each of the index entries is distributed to one of the partitions based on a similarity metric that is calculated between a search target of the index entry and a collector associated with each of the partitions. Each index entry is associated with or distributed to the partition associated with the collector to which the search target of the index entry is most similar, as quantified by the similarity metric. In some contexts the collector may be known or referred to as a token or an attractor. The collector comprises and\/or embeds a symbol string. In an embodiment, the search target comprises a symbol string, for example a string of letters \u201crobert brown,\u201d that promotes searching for the index entry.","When a lexicographic similarity-based search is initiated, a similarity metric is calculated between the search term and each of the collectors, and a relatively small number of the partitions whose collectors are most similar to the search term are selected for searching based on the similarity metric values, thereby intelligently pruning or limiting the search space. For each of the selected partitions, a similarity metric is calculated between the search term and the search target of each of the index entries associated with the selected partition. Those index entries whose search targets are most similar to the search term, as quantified by the similarity metrics, may be deemed a near match to the search term and to comprise in aggregation the lexicographic similarity-based search results.","In an embodiment, the index entries of the lexicographic similarity-based search results are displayed on a user interface, perhaps to provide functionality for a user to select from among these lexicographic similarity-based search results. Alternatively, in an embodiment, entries in the data store corresponding to the index entries of the lexicographic similarity-based search results are accessed and several fields of these entries in the data store may be presented on a user interface. Alternatively, the information that is sought is stored directly in the index entries. In testing of prototypes, the disclosed partitioned lexicographic similarity-based search methods have been effective for finding sought after symbol strings based on search terms created by moderately mangling and strongly mangling the sought after symbol string.","As an example, an index data store of 1 million index entries may be distributed to about 1 thousand partitions, where about 1 thousand index entries are associated with each partition. Each of the index entries are distributed to or associated with one of the partitions based on determining a similarity between the search target of the index entry and each of the collectors and then distributing the index entry to the collector, and hence the associated partition, that is most similar to the search target of the index entry. As will be discussed further hereinafter, in an embodiment the process of building the partitions and\/or defining the collectors may be performed using a genetic algorithm where the collectors are mutated, the resultant partitions are evaluated according to a fitness metric, and the results of the fitness metric evaluation may drive further evolution cycles.","After the partitions have been built, the index comprising the partitioned index entries may be searched using a search term. A similarity metric is calculated to quantify the similarity of the search term with each of the collectors associated with the 1 thousand partitions, and the 10 collectors that are determined to be most similar to the search term may be selected. In other circumstances, a different number of collectors may be selected. Selecting the 10 collectors entails calculating 1 thousand values of the similarity metric. The similarity metric is then calculated to quantify the similarity of the search term with the search target of each of the index entries associated with the 10 partitions identified by the selected 10 collectors is calculated. 20 of the index entries associated with the highest values of the similarity metric may be deemed the lexicographic similarity-based search results. Identifying the 20 index entries from among the selected 10 partitions entails calculating 10 thousand values of the second similarity metric. In other circumstances, a different number of index entries from among the selected 10 partitions may be identified and\/or selected. Together, 11 thousand similarity metrics are calculated in this example, which is much more tractable than calculating 1 million similarity metrics that otherwise may have been performed if partitioning were not employed. The approach described in brief above may be said to intelligently prune away 990 of the 1000 partitions, thereby saving much execution time.","The description above has related to a single index, for example a name index. In some embodiments, however, the index data store may be built to support searching using any one of a plurality of different indices. For example, the index data store may comprise a first index comprising index entries having a name search term distributed to a first plurality of partitions, a second index comprising index entries having an address search term distributed to a second plurality of partitions, a third index comprising index entries having an account number search term distributed to a third plurality of partitions, and possibly other indices comprising index entries having different types of search terms. An index data store comprising a plurality of different kinds of indices may promote searching based on any of a name alone, an address alone, an account number alone, or other individual types of search terms.","The index entries from different indices that are associated with the same specific entry in the data store may each contain a reference that references the same specific entry in the data store. For example, if the data store comprises an entry \u201c18357:robert brown:12345 Street:6789\u201d; a first index may have an index entry having a name search target value of \u201crobed brown\u201d and a reference \u201c18357\u201d; a second index may have an index entry having an address search target value of \u201c12345 Street\u201d and the reference \u201c18357\u201d; and a third index may have an index entry having an account search target value of \u201c6789\u201d and the reference \u201c18357.\u201d The first index may be associated with a first plurality of partitions; the second index may be associated with a second plurality of partitions; and the third index may be associated with a third plurality of partitions. Thus, any of the types of search target may be used to find the entry in the data store. In an embodiment, the system may support searching based on two search terms at the same time, as will be discussed in more detail hereinafter. The index entry may not contain a reference to the data store and instead may contain within itself the information that is sought by the lexicographic similarity-based searches.","Turning now to , a partitioned lexicographic similarity-based search system  is described. In an embodiment, the system  comprises an application data store  having a plurality of entries , a server computer , an index data store , a network , and a user interface . In some contexts, the application data store  may be referred to simply as the data store. The application data store  may store data associated with an application independent of the applications , , , for example a bank account management application, a telecommunications service provider subscriber account management application, or other application. The server computer  may execute a plurality of applications including an initialization application , an optimization application , and a search application . In an embodiment, the application data store  and the index data store  may be located within the same large data store  and\/or database management system (DBMS).","Those skilled in the art will readily appreciate that the functionality of the system  may be implemented in other forms and\/or by other variant configurations, all of which are contemplated by the present disclosure. For example, the index data store  may be outside of the large data store  and instead independently coupled to the network  and\/or to the server computer . The index data store  may be maintained in random access memory (RAM) of the server computer . The server computer  may be a desktop computer, and the user interface may be provided by the desktop computer. Two or more of the applications , ,  may be integrated into a single application or one of the applications , ,  may be implemented as two or more separate applications and\/or components. The server computer  may comprise a plurality of computers. One or more of the applications , ,  may execute in the large data store , for example in a stored procedure executing in a database management system. In an embodiment, the system  may not comprise the application data store , for example when the sought for information is stored directly in the index entries. Yet other variations are consistent with the spirit and teachings of the present disclosure.","The network  may be any combination of public and private communication networks. Some of the coupling between the application data store , the server computer , and the user interface  may be provided over virtual private network (VPN) channels. The server computer  may be any computer or computer system, for example comprising a plurality of computers that collectively share a processing load associated with the applications , , . Computer systems are described in more detail hereinafter. The application data store  may be provided by a database management system (DBMS). The application data store  may be provided by a computer system coupled to secondary storage devices. The user interface  may be a desktop computer, a workstation, or other electronic device.","The index data store  comprises indices, wherein each of the indices is comprised of index entries having a type of a search target that is distinctive to the subject index. For example, a first index may comprise index entries having a name type of search target. In some contexts, indices may be named based on the type of search target of their index entries. For example, the first index may be referred to as the name index or the name string index. Depending on the index, the search target of the index entries may correspond to a name, an address, an account number, a driver license number, a social security number, or other information. The index entries may comprise an identifier of a collector and\/or a partition to which the index entry is associated. The index entry may comprise a reference to one of the entries  in the application data store , for example the information that a lexicographic similarity-based search based on the search term may be intended to access. Alternatively, the index entry may comprise target information that itself contains the information sought by the lexicographic similarity-based searches. In an embodiment, each of the indices may further comprise a search target data structure that is discussed hereinafter.","The index entries of a given index in the index data store  are distributed to a plurality of partitions based on a similarity between the search target of each index entry to the collector associated with a specific partition. The collector may contain multiple fields and\/or components, and when it is said that the collector is similar to a given symbol string, this means that the given symbol string is similar to a symbol string encapsulated within the collector. For example, a first index entry is associated with a first collector, and hence with a first partition associated with the first collector, because a similarity metric calculated based on the search target of the first index entry and the first collector indicates a higher degree of similarity than the similarity metrics calculated based on the search target of the first index entry and every other one of the collectors.","Collectors have a one-to-one relationship to partitions. For example, each partition is associated with a unique collector, and each collector is associated with a unique partition. Due to this identity between collectors and partitions, to some extent these terms may be used interchangeably herein. For example, an index entry may be said to be distributed to a collector or distributed to a partition. As another example, an index entry may be said to be associated with a collector or associated with a partition.","Turning now to , aspects of an embodiment of the index data store  are described. The index data store  may be said to comprise a plurality of indices , for example a name index that may also be referred to as a first index , an address index that may also be referred to as a second index , an account number index that may also be referred to as a third index , and possibly other indices. Each index  may comprise a large number of index entries , for example more than 10,000 index entries. Each of the index entries  may comprise a data store entry reference that identifies a database entry . Alternatively, the index entries  may comprise a target information component, element, or field that contains the information that is sought by the lexicographic similarity-based searches. Each index entry  comprises a search target corresponding to the type of index . The search target may be a symbol string, for example \u201crobert brown.\u201d Each of the indices  further comprises a plurality of partitions  to which the index entries  are distributed. Each of the partitions  of the subject index  is associated with a collector . In some contexts the collector  may be referred to or known as a token or an attractor. The index entries  may further comprise a collector identity, for example a collector identity attribute or field, that identifies the collector  (and hence the partition ) that the subject index entry  is associated with. In another embodiment, however, the index data store  may be structured otherwise.","It is understood that a partition  may be simply an abstraction for understanding how the index data store  works: partitions  may have no existence separate from the collectors  that they are said to be associated with. Alternatively, a partition  may be a data structure or a data table that comprises various information including the collector  and\/or information about the distribution of index entries  to the subject partition . A partition  may be considered to comprise a plurality of index entries  that are associated with the same collector , for example, these index entries  may have a collector identity field that is the same. Some of the discussion below will focus on a single index , but the description substantially applies to the other indices  as well. Where there are differences between different indices , these differences will be pointed out and described.","The index data store  may be initialized by the initialization application  and\/or the optimization application . In an embodiment, when initializing the index data store , each of the indices  is built based on accessing each of the entries  in the application data store . An index entry  may be created for each entry  for each index . Thus, if there are two search fields, a first index and a second index , two index entries  are created, a first index entry and a second index entry , each having a reference that identifies the first entry , for example a key used by the application data store  to uniquely identify the first entry . The search target of the first index entry corresponding to the first index will be assigned a value based on information contained in the first entry associated with the first index ","For example, if the first index is a name index , then the search target of the first index entry corresponding to the first index will be assigned a name contained in the first entry , for example \u201crobed brown.\u201d The search target of the second index entry corresponding to the second index will be assigned a value based on information contained in the first entry associated with the second index . For example, if the second index is an address index , then the search target of the second index entry corresponding to the second index will be assigned an address contained in the first entry , for example \u201c12345 street.\u201d To generalize, in an embodiment the search targets comprise strings of symbols from a pre-defined symbol set. These pre-defined symbol sets may comprise one or more of an alphabet, a set of numerals, and other sets of symbols. The pre-defined symbol set may comprise the symbol set defined by the American Standard Code for Information Interchange (ASCII) or the symbol set defined by the extended ASCII. The pre-defined symbol set may comprise an expressly enumerated and bounded set of values.","When the index entries  do not have a data store reference identifying entries  in the application data store , the indices  are initialized somewhat differently. For example, the initialization application , may read a data file or obtain the information from another source and may automatically generate the index entries  with target information component storing the sought for information in the index entries  themselves. In this case, a plurality of indices  may likewise be created, and in this case a plurality of index entries \u2014one index entry  per index \u2014may be initialized with the same information that is sought by the searches.","Additionally, when initializing the index data store , a plurality of collectors  associated with each of the indices  is built. In an embodiment, a number of collectors  to be built is determined based on the number of entries  in the application data store  and\/or based on the number of index entries . The collectors  may be formed of the same symbols, such as characters and numerals, that are used to assign the search targets. In an embodiment, however, the symbols may be other than characters and numerals. Thus, for names, characters excluding numerals may be assigned as search targets. For addresses, both characters and numerals may be assigned as search targets of the index entries . The collectors  associated with an index  may each be formed of the same number of symbols. In an embodiment, the collectors  may be formed of a greater number of symbols than the longest search target of the index entries  in the subject index . Alternatively, the collectors  may be formed of a number of symbols that is longer than some threshold percentage of the search targets of the index entries . Alternatively, the collectors  may be formed of a number of symbols that is fewer than the number of symbols in the subject symbol set. Alternatively, the collectors  may be formed of some other number of symbols.","Turning now to , an embodiment of a collector  is described. In an embodiment, the collector  comprises a collector symbol string  that comprises a string of symbols, for example a string of symbols from a symbol set such as an alphabet or other symbol set. In an embodiment, the collector  may further comprise a collector data structure  that represents the collector symbol string  in a form that promotes improved performance of an algorithm for determining a similarity metric. The collector data structure  is described further below with reference to . The collector  may further comprise additional components, elements, or fields related to maintaining counts of index entries  associated with the subject collector  and statistics of similarity metric calculations performed when associating index entries  to collectors . In some embodiments, the collector  may be replaced by a partition data structure that comprises the collector symbol string  and the optional collector data structure . In another embodiment, however, the collector  may have different structures and\/or components.","Turning now to , an embodiment of an index entry  is described. The index entry  may comprise a search target , a collector identity , and a data store entry reference  that identifies an entry  in the application data store . In some contexts the data store entry reference  may be referred to as an application key. In an embodiment, the index entry  may comprise additional data elements, for example a search target data structure  that represents the search target  in a form that promotes improved performance of an algorithm for determining a similarity metric. The search target data structure  will be described in more detail further below with reference to . In an embodiment, the index entry  may not comprise the data store entry reference  and instead may comprise a target information component , attribute, or field that contains the data or information that is sought by the lexicographic similarity-based searches. In another embodiment, however, the index entry  may have different structures and\/or components.","The collectors  may be generated in any way that conforms to the constraints described above. Further, the collectors  or collector symbol string  may be generated in such a way that there are no duplicate collectors. In an embodiment, the initial set of collectors  associated with the index  may be generated randomly from the set of symbols allowable for the subject index . For example, if the collectors  comprise a sequence of 40 symbols selected from a symbol set comprising 36 different symbols, a random number generator may execute to produce a first random number, this random number may be used to select the first symbol of the collector  from the symbol set; next the random number generator may execute to produce a second random number, this random number may be used to select the second symbol of the collector  from the symbol set; and so on to select the remaining symbols of the collector  from the symbol set. In another embodiment, a given number of index entries  may be selected randomly, and collectors  may be defined based on these index entries , for example by padding and\/or mutating the symbol strings contained by the index entries . A check can be run at some point to exclude duplicate collectors. The set of letters of the alphabet, ignoring case, and the numerals 0 through 9 would comprise a symbol set of 36 symbols.","In an embodiment, creating the collector  comprises assigning a symbol string value to the collector symbol string . In an embodiment, creating the collector  further comprises analyzing the symbol string value to build and assign values to the collector data structure . As will be discussed further below, the collectors  associated with the subject index  may be compared to a fitness metric and, based on the fitness of the collectors  and\/or the partitions  associated with the collectors , the collectors  may be evolved by discarding some collectors  and mutating other collectors  to create new collectors  related to their parent collectors  while the collectors that were mutated to create the new collectors  may be retained in the partitions . This may be referred to as creating a set of collectors  and\/or  partitions based on a genetic algorithm.","It is understood that the present disclosure teaches creating collectors , search targets , and other symbol strings (such as search terms discussed below) based on other symbol sets, for example based on character sets other than the English character set such as French characters (e.g., \u00e7, \u00e9, \u00f4, are not part of the English character set), Cyrillic characters, Arabic characters, Hebrew characters, Hangul characters, Kanji characters, Chinese characters, and other character sets. It is contemplated that expanded character sets may be employed as a symbol set, for example a set of both upper case and lower case letters. It is contemplated that the American Standard Code for Information Interchange (ASCII) symbol set and or the extended ASCII symbol set may be employed. In an embodiment, the symbol set may be defined by a Unicode character set, where the Unicode characters are mapped to other symbols, for example characters other than those included in the English language character set. Further, it is contemplated that other symbol sets may be employed that are not related to language character sets, such as symbols employed in creating universal product codes (UPCs), bar codes, and two dimensional bar codes. Likewise, it is contemplated that other symbol sets related to magnetic strip values and electrical values such as quadrature amplitude modulation (QAM) symbols, 16-QAM symbols, 64-QAM symbols, etc., may be employed.","The index entries  associated with the index  are then distributed to each of the collectors  and\/or to the partitions . For each of the collectors , a similarity metric is calculated between the search target  of the index entry  and the collector . Then the index entry  is distributed and\/or associated to the collector  having the highest similarity with the search target  of the index entry , based on the calculated similarity metrics. Distributing or associating an index entry  to a collector  may entail writing the symbol string encapsulated in the collector , for example in the collector symbol string , into the collector identity  of the index entry . Alternatively, or in addition, distributing or associating an index entry  to the collector  may entail writing a collector key value encapsulated in the collector  into the collector identity  or another field of the index entry . The collector key value may comprise a number, for example an eight byte number, that may be used as a look-up or reference to access the subject collector . Each of the index entries  may be distributed to a set of collectors  in this manner. It is understood that associating an index entry  to a collector  may be referred to in some contexts as associating, allocating, or assigning the index entry  to the partition  associated with the collector . This process of associating index entries  with collectors  can be repeated for each of the indices  in a similar fashion.","In an embodiment, an edit distance algorithm may be employed to determine the similarity metric. An edit distance algorithm generally calculates a similarity metric value that represents the distance between a first thing and a second thing, for example between a first symbol string and a second symbol string. For example, the edit distance between the symbol strings \u201crobert brown\u201d and \u201croberta brown\u201d would be expected to be relatively small while the edit distance between the symbol strings \u201crobert brown\u201d and \u201cjohn smith\u201d would be expected to be relatively large. In some cases the edit distance algorithm may calculate a value in the range for 0 to 1, where the value 1 corresponds to an exact match between the things compared and the value 0 corresponds to zero similarity between the things compared. The similarity between \u201crobert brown\u201d and \u201croberta brown\u201d would be expected to be relatively close to but less than the value 1, while the similarity between \u201crobert brown\u201d and \u201cjohn smith\u201d would be much closer to the value 0, though not 0 because at least some symbols are shared between the two disparate symbol strings, for example \u2018o\u2019, \u2018n\u2019, and T. In other embodiments, the range of values calculated by the similarity metric and\/or edit distance algorithm may be different.","In an embodiment, a Jaro edit distance algorithm may be employed to determine the similarity metric value, for example when the search target  and the collectors  comprise symbols that are characters, numerals, and\/or other symbols. In an embodiment, an enhanced Jaro edit distance algorithm may be employed to determine the similarity metric. Jaro edit distance algorithms and an enhanced Jaro edit distance algorithm will be discussed in more detail below. In other embodiments, however, other edit distance algorithms and\/or other similarity metric calculation algorithms may be employed. It is understood that in some embodiments, the similarity metric calculation may be based on the semantics of the information contained in the search targets .","It may happen that the first random selection of collectors  for partitioning the index entries  of an index  and\/or distributing the index entries  to collectors  of an index  may result in an undesirable distribution of the index entries . The relative quality of the distribution of the index entries  to partitions  and\/or to collectors  may be quantified by calculating a fitness metric of the distribution of index entries  and\/or a fitness metric of the partitions . It is understood that a variety of fitness metrics and\/or fitness algorithms may be suitable for use with the system . In an embodiment, the fitness metric may be calculated based on the numbers of index entries  distributed to each partition  and\/or collector . Generally, it may be preferred that the numbers of index entries  distributed to each partition  and\/or collector  be approximately equal for each of the partitions  and\/or collectors .","For example, if there are about one thousand partitions  and about one million index entries , it may be preferred that each partition  have about one thousand index entries  associated with it. On the other hand, a selection of collectors  that promotes a distribution that results in one hundred of the partitions  having zero index entries  associated with them and forty partitions  each having twenty thousand index entries  associated with them may be deemed relatively unfit. In this case, searching two of the partitions  from among the forty partitions  would involve forty thousand calculations of the similarity metric, many more calculations than would be involved in searching ten of the partitions  that had about one thousand index entries  distributed to each of them.","When the fitness metric determined for the distribution does not satisfy a fitness criterion, the collectors  may be determined again, the index entries  distributed again, and the fitness metric determined for the new distribution. Each set of collectors  and partitions  and the distribution of index entries  to the collectors  and\/or the partitions  may be referred to as a generation and the process of creating new generations of collectors  and\/or partitions  may be referred to as evolution and\/or evolving the collectors  and\/or the partitions . Some of the collectors  may be retained from a first generation to a second generation, some collectors  present in the first generation may be deleted from the second generation, and some collectors  present in the first generation may be split into two or more collectors  in the second generation. Alternatively, this process of creating new generations of collectors  and\/or partitions  and distributing the index entries  to the collectors  and\/or the partitions  may be referred to as optimization and\/or optimizing the index . This process may continue until the determined collectors  result in a distribution that satisfies the fitness metric criterion. It is observed that as the index  changes\u2014as new index entries  are added and as some index entries  are deleted, the fitness of some of the collectors  and\/or partitions  may decline, and ultimately a new cycle of evolution or optimization may be triggered to improve the fitness of the collectors , the partitions , and\/or the distribution of index entries to collectors  and\/or partitions .","At an abstract level, this approach may be characterized as a genetic algorithm. In some tests of system , this genetic algorithm has been found to produce an effective distribution of index entries  to collectors  and\/or partitions  in as few as four cycles and\/or iterations. Without limitation, a genetic algorithm may be said to consist in computing a fitness metric on a population of entities, in the present case the collectors , and mutating at least some members of the population of entities based on the fitness metric to evolve the population of entities toward a more optimal state as quantified by the fitness metric. The present disclosure contemplates a variety of implementations of genetic algorithms for evolving the collectors  over time, as new index entries  are added to the index  and as other index entries  are deleted from the index . In an embodiment, the mutation and evolution of the collectors  and\/or the partitions  may be performed in part by the optimization application .","In an embodiment, collectors  that are associated with zero or a relatively small number of index entries  may be deemed unfit and may be deleted from the set of collectors . Collectors  that are associated with a relatively high number of index entries  may be deemed unfit and may be replaced by two new collectors, three new collectors, or greater than three new collectors, depending on how much the number of index entries  associated with the subject collector  exceeds a partition  fitness criterion and\/or a collector  fitness criterion. In an embodiment, the original collector  having a relatively high number of index entries  associated with it may be retained, which may be referred to as the parent collector , and one or more new collectors  may be created by mutating the parent collector . A reproduction rate may be configured that identifies how many new collectors  to create based on the relative fitness of the subject collector . A mutation rate may be configured that identifies how many symbols of the collectors  are changed during a mutation, for example a mutation rate of 0.2 may mean that about 1 out of 5 symbols of the collector  are mutated. The mutation rate may be statically configured. Alternatively, the mutation rate may be adaptively determined based on a phase of evolution. For example, a first mutation rate may be employed during initialization of the index ; a second mutation rate may be employed after the collectors  have evolved to a given level of fitness, for example as minor adjustments are made to accommodate minor imbalances in the distribution of index entries  to collectors  and\/or partitions  over time with addition and loss of index entries .","The present disclosure contemplates a variety of different mutation algorithms. In general, the approach is to either replace or supplement a collector  that attracts too many index entries  by creating a close neighbor of the strong collector . This may be done in a variety of ways, often involving retaining at least some of the symbols of the original collector . At a high level, the role of mutation is to introduce new previously unknown entities\u2014collectors \u2014into the population. If the mutation is good, the mutation will survive; if the mutation is bad, the mutation will die. Some mutation algorithms may be substantially random and may produce as many poor mutations as good mutations. Other mutation algorithms may attempt to bias the fitness of mutations to have more fit mutations than unfit mutations by doing some analysis of the index entries .","In an embodiment, the new collectors  are determined from the old collector  by randomly selecting a number of symbol positions of the old collector  for mutation. Then the selected symbol positions may be assigned a symbol value based on a randomizing algorithm, for example a random number generator generates a random number and this random number is used to select one of the members of the symbol set. For each new collector , this process may be repeated to build each new collector . The old collector  that has been mutated may be discarded or deleted from the index . Alternatively, the old collector  may be retained.","In another embodiment, a new collector  may be determined from the old collector  by selecting one or more symbols in the old collector that are determined to have been relatively unimportant in attracting the index entries  associated with the old collector  and forming a new collector  by replacing at least one of these relatively unimportant symbols with a symbol not present in the old collector  but present in either a relatively high number or in an average number of the index entries  associated with the old collector . To support these symbol frequency determinations a variety of counts may be accumulated during the course of distributing the index entries  to the collectors  and\/or the partitions .","For example, at the time of assigning the collector identity  in the index entry , the similarity between the collector  and the search target  of the index entry  may be recalculated, and a first histogram may be constructed recording the number of times a symbol in the collector  matches a symbol in the search target . In an embodiment, the first histogram may tally a count only when the position of the symbol in the collector  and the matching symbol in the search target  are in relatively the same positions within their corresponding symbol strings. Thus, when a \u2018g\u2019 in the first third of the collector symbol string  matches a \u2018g\u2019 in the first third of the search target  of an index entry , a \u2018g\u2019 count of the first histogram is toggled; but when the \u2018g\u2019 in the search target  occurs in the second third or the last third of the search target , the \u2018g\u2019 count of the first histogram is not toggled.","When the index entries  have been distributed, then, the first histogram associated with every collector  would provide a record of the frequency of occurrences of symbols in the collector  in the index entries  associated with that collector . A second histogram could be built which records the frequency of occurrence of all symbols in the symbol set across the search targets  of the index entries  associated with that collector . It would be a relatively simple matter for one skilled in the art, provided with the teachings of the present disclosure, to perform the mutation described above once provided with the first and second histograms. The histograms may be implemented as an array of integers, each array element of the first histogram corresponding to a symbol in the first collector  and each array element of the second histogram corresponding to one of the symbols in the complete set of symbols. Alternatively, the histograms may be implemented in another form.","By retaining the old collector  and adding a new collector  that represents the described mutation of the old collector , it is hoped that the new collector  will attract some, but not all, of the index entries  originally associated with the old collector . By adjusting the selection of the replacement symbol from the second histogram\u2014for example varying between frequent occurrence, to average occurrence, to rare occurrence in the search target  of the index entries \u2014it may be possible to adjust the portion of index entries  that are attracted away from the old collector  and to the new collector . It is thought that the investment of extra processing time in building the first and second histograms may be recovered by an optimization that converges more rapidly on fit collectors  and\/or partitions .","Note that the mutation based on the first and second histograms above takes only the frequency of symbols into consideration and ignores the positions of the symbols. In some edit distance algorithms, such as the standard Jaro edit distance algorithm, the calculation depends not only on symbol matches but also the relative positions of the matching symbols. In an embodiment, a third histogram may be constructed that is substantially similar to the second histogram, but adds position information. In an embodiment, the third histogram comprises a plurality of arrays where each element of the array corresponds to a count of occurrence of the corresponding symbol from the symbol set in the search targets  and each array is associated with a position in the search targets . In an embodiment, the positions in the search targets  may be categorized into a front position, a middle position, and an end position, and the third histogram comprises three arrays. This third histogram promotes selecting replacement symbols not only based on frequency of occurrence of the symbols in the search targets  but also based on the position of the symbols in the search targets . Thus, the symbol selected in the old collector  for replacement can be replaced with a symbol that is not in the old collector  and that has a relatively high or average frequency of occurrence in the search targets  of the index entries  in the corresponding position within the collector  and\/or the collector symbol string .","In another embodiment, two collectors  that are deemed to be strong attractors, by virtue of an above average number of index entries  having been distributed to the two collectors , may be recombined to form one or more new collectors  that may attract away some index entries  from the two strong attractors. For example, a first new collector  is created as a copy of the first collector . Based on a mutation rate, a number of symbols in the first new collector  are selected, these selected symbols are replaced by the symbols in the corresponding positions of the second one of the collectors , and the first new collector  based on the recombination of the two strong collectors  is added to the set of collectors . A second new collector  may also be formed from recombining the two collectors  and added to the set of collectors . For example, the second new collector  is created by copying the second collector . Based on the mutation rate, a number of symbols in the second new collector  are selected, and these selected symbols are replaced by the symbols in the corresponding positions of the first collector . The selection of symbols in the original collectors  to be replaced may be selected at random. The number of symbols that are selected for replacement, in an embodiment, may be about half of the symbols in the subject collector . Yet other mutation algorithms and techniques are contemplated by the present disclosure for building new collectors  based on strong collectors .","After a new set of collectors  have been built comprising the new collectors  and the old collectors  that have not been discarded, the index entries  are again distributed to the collectors  and\/or partitions  as described above. In an embodiment, all the index entries  are distributed to the collectors , including those index entries  formerly distributed to collectors  that were not deleted or mutated, because index entries  formerly associated with the undeleted collectors  may be more similar to one of the new collectors . If these index entries  were left associated with the undeleted collectors , the search application  may be less likely to locate them. When the collectors  satisfy the fitness metric or after a maximum number of mutation cycles, the initial distribution of index entries  to collectors  can be considered to be completed.","During initialization or during an optimization operation, intermediate collectors  and associations of index entries  to collectors  may not be changed in the index data store  but may instead be stored in a random access memory (RAM) or cache of the server computer system . When the set of collectors  is settled upon, then the information may be written into the data structures of the index  in the index data store . Alternatively, after the selection of the set of collectors  is settled upon or finalized, the index entries  may be distributed to the collectors  by again calculating the similarities between search targets  and collectors  or collector symbol strings . Writing into the data structures of the index  may comprise, for example, updating the collector identity  in some of the index entries  (those that have been distributed to a different collector ). Writing into the data structures of the index  may comprise deleting some collectors  and\/or partitions  and creating new collectors  and\/or partitions . Writing into the data structures of the index  may comprise writing various counts and distribution metrics into the collectors  and\/or into the partitions , for example a count of how many index entries  are associated with the subject partition  and statistical information about symbol matching between the search target  of the index entries  associated with the collector  and the collector symbol string  of the collector . Collectors  that are created may have a version identifier associated with them that remains unchanged during their continued existence and may be used to analyze the rate of change of the collectors  and\/or the partitions . The version identifier may also be used during optimization to avoid losing search target  and\/or index entries .","As new index entries  are added during in-service operation of the partitioned lexicographic similarity-based search system , they are distributed to the appropriate partition  and\/or collector  as described above. As partitions  grow or decline, they may either be mutated into two new collectors  and\/or partitions  or deleted, for example by performing optimization. The periodic or triggered evolution of the partitions  that occurs after completion of the initialization of the index  may be referred to in some contexts as optimization. It is understood that this process of initializing and evolving the index  happens to all of the indices  of the index data store . It should be noted that different indices may evolve independently. For example, the first index may run triggered optimizations about every two weeks while the second index may run triggered optimizations about every 10 days.","It will be appreciated by one skilled in the art that the above described abstractions associated with the index data store  may be implemented in a variety of ways, and different implementations may be deemed suitable for different application contexts. For example, in an embodiment, each of the index entries  may be implemented as described with reference to  having the search target , the collector identity , and the data store entry reference . Alternatively, the index entry  may not comprise the collector identity , and a partition  may comprise a data structure that identifies each of the index entries  associated with it. For example, the partition  may comprise an array comprising elements that identify each of the index entries  associated with the collector  associated with that partition . Alternatively, rather than an array, the partition  may comprise a linked list of elements that identify each of the index entries  associated with it. The data structure that defines the partition  may also comprise the collector  associated with the partition . The collectors  of an index  may be stored in an array or in a linked list or in another data structure. Yet other implementations are contemplated by the present disclosure and are consistent with the partitioned lexicographic similarity-based search based on distributing index entries  to partitions  based on collectors .","When the index entries  have been distributed to the partitions \u2014or in other words when each of the index entries  has been associated with a collector  which is most similar to the search target  of the index entry \u2014the system  may be used to perform lexicographic similarity-based searches, for example, executing the search application  to find one or more entries  in the application data store  based on an input search term that need not be an exact match to a key of the corresponding entry  in the application data store . Alternatively, the search application  may be executed to find one or more target information components  based on the input search term that need not be an exact match to the search target  of the index entries .","The user interface  may request that a search term be entered into a text box associated with a particular index , for example one of a name search field, an address search field, an account number search field, or other search field. A user may enter a search term, for example the search term \u201crobrt brown,\u201d into the user interface  in a name search field text box. Note that the input may be errored for some reason: it may be that the input should have been \u201crobert brown.\u201d One skilled in the art will readily appreciate the many sources of error that can produce this kind of error. A clerk may have mistyped. A keyboard coupled to the user interface  may have a sticky key or have a hardware fault. The clerk may have misspelled a name (for example, misspelling \u201cbraun\u201d as \u201cbrown\u201d). The input to the user interface  may have been processed first by an automated voice recognition tool that made an error mapping from audio to the spelled name. Yet other error sources may account for this kind of error.","Alternatively, the search term may have no error, but the original information in the data store entry  or in the search target  may be in error. For example, if the initial creation of the data store entry  erroneously entered the account owner name as \u201crobrt brown,\u201d when conducting an exact search for a \u201crobert brown\u201d search term will fail to find this entry. The lexicographic similarity-based search taught herein may find this entry in the application data store .","Turning now to , an exemplary partitioned lexicographic similarity-based search is described. The user interface  may pass a first search term  to the search application  to conduct the search. The search application  calculates a similarity metric of the similarity of the first search term  \u201crobrt brown\u201d to each of the collectors  of the name index . The search application  selects a plurality of collectors  based on their similarity to the first search term . It should be recalled that each index entry  is distributed to one of the collectors  based on the similarity of its search target  to the collector . Hence, by selecting the collectors  that are most similar to the first search term , it is expected that the index entries  with the search targets  most similar to the first search term  will be found within the partitions  associated with the collectors  that are most similar to the first search term .","In an embodiment, the search application  is configured to select a specific number of collectors , for example ten collectors, that are most similar to the search term . In an embodiment, the search application  is configured to select a specific percentage of all the collectors , for example 1% of all the collectors, that are most similar to the search term . In an embodiment, the search application  is configured to select all the collectors  with a similarity metric relatively close to the highest calculated similarity metric. In another embodiment, the number of collectors  selected by the search application  is determined to assure analyzing a minimum number of index entries . In an embodiment, the number of collectors  selected by the search application  is determined to assure analyzing a minimum percentage of all the index entries  in the index . In an embodiment, two or more of the criteria described above may be combined. For example, in an embodiment, at least ten collectors  are searched and if less than 5000 index entries  are analyzed, additional collectors  are searched. For example, if the ten selected collectors  are associated with partitions  that contain only a total of 1000 index entries , it may be desirable to select additional collectors  to assure that at least 5000 index entries  are tested for similarity of their search target  to the search term .","In an embodiment, the number of collectors  to select may be based in part on a current search load on the search application , for example from a plurality of user interfaces  or applications. When the processing load is light, the number of collectors  selected may increase within a range of adjustment up to a maximum number, and when the processing load is heavy, the number of collectors  selected may decrease within a range down to a minimum number. In an embodiment, the number of collectors  to select may be adaptively determined based on feedback about the success rate of the lexicographic similarity-based searches. In another embodiment, yet other methods for determining the number of collectors  to select may be employed, all of which are contemplated by the present disclosure. The selection of the collectors  may be said also to select the partitions  that are associated with the collectors .","A similarity metric is determined indicating the similarity of the first search term  to the search target  of each of the index entries  associated with the selected partitions . A plurality of the index entries  are identified from among the selected partitions  whose search targets  are determined by the similarity metric to be most similar to the first search term , and these index entries  may be deemed to be a result or an intermediate result of the lexicographic similarity-based search. The number of the index entries  that comprise the result of the lexicographic similarity-based search may be configured in the search application . Alternatively, the number of index entries  that comprise the result may be input from the user interface  when initiating the lexicographic similarity-based search. Alternatively, the number of index entries  that comprise the result may be adaptively determined based on feedback about the success rate of the lexicographic similarity-based searches.","The presentation of results to users of the system  may vary depending upon the specific application and context, and a variety of manners of presenting the results are contemplated by the present disclosure. In an embodiment, the value of the search targets  of each of the index entries  that were selected due to similarity to the first search term  may be presented, for example in a list of menu selections on a display of the user interface  ordered according to the different similarity metric values associated with the results. For example, based on the first search term  value \u201crobrt brown,\u201d the user interface  may display \u201crobert brown,\u201d \u201croberta brown,\u201d \u201crobert braun,\u201d \u201crobert towne,\u201d and \u201croger brown.\u201d The user may be able to click on the \u201crobert brown\u201d result, and the user interface  may use the data store entry reference  associated with the search target  \u201crobert brown,\u201d for example DB Ref, to access and read a corresponding data store entry and to present the information from this data store entry to the user via the user interface . For example, the user interface  may display robert brown, an address, an account number, and possibly other information. Alternatively, the search application  may retrieve the data store entries  identified by all of the index entries  whose search target  were selected due to similarity to the first search term  and display at least some of the information retrieved from the application data store  for each of the subject data store entries . Alternatively, when the index entry  does not comprise a data store entry reference  but instead comprises the target information component , the information stored by the target information component  may be presented.","In an embodiment, rather than providing the lexicographic similarity-based search results on a display of the user interface , the search application  may return the lexicographic similarity-based search results to a calling application.  schematically represents some of the steps described textually above.  includes partitions , , , that may be said to comprise index entries  that may have been found to have search targets  most similar to the first search term . The subject index entries  correspond to data store entries , , , , and ","Some search targets  may be comprised of a plurality of sub-fields. For example, search targets  storing names may comprise a first name sub-field, a middle name sub-field, and a last name sub-field. As another example, search targets  storing addresses may comprise a street sub-field, a city sub-field, a state sub-field, a zip-code sub-field, a country sub-field, and other sub-fields. In an embodiment, rather than a street sub-field, the search targets  may comprise a street number sub-field and a street name sub-field. Search terms , collectors , collector symbol strings , and\/or collector data structures  associated with an index  where index entries  have search targets  comprised of a plurality of sub-fields may be composed of parallel sub-fields. The determination of similarity between symbol strings having sub-fields may be determined as a series of similarity metrics that are then combined to form an aggregate or total similarity metric. For example, a similarity metric between symbol strings having a first sub-field, a second sub-field, and a third sub-field may be determined as a first similarity determined over the first sub-fields, a second similarity determined over the second sub-fields, a third similarity determined over the third sub-fields, and an aggregate similarity based on a combination of the first, second, and third similarities.","The aggregate similarity may be determined by summing the similarities of each of the sub-fields. The aggregate similarity may be determined by summing the similarities of each of the sub-fields and dividing through by the number of sub-fields. The aggregate similarity may be determined by multiplying each of the sub-fields by a weighting coefficient that is configured for that specific sub-field and summing the resultant products. The aggregate similarity may be determined by multiplying each of the sub-fields by a coefficient that is configured for that specific sub-field, summing the resultant products, and dividing by the sum of the weighting coefficients. In some indices  associated with sub-groups, the weighting coefficients may be based on the semantics of the information to be searched. For example, in a telephone number, the first three digits may provide an area code and may be granted more weight in determining similarity than other sub-groups of the symbol strings. Yet other methods for aggregating similarity metrics determined over sub-fields are contemplated by the present disclosure.","The search term  for searching an index  having collectors  and index entries  associated with sub-fields may provide a search string that provides symbols for each of the sub-fields. In another embodiment, however, or in an alternative user interface , a search string may be input that provides symbols for some but not all of the sub-fields. In this case, the search application  may fill in the empty sub-fields with wildcard symbols: symbols that match any other symbol.","In an embodiment, the index data store  is implemented using a traditional database to store its data. As is known to those skilled in the art, databases and\/or database tools provide an application programming interface for interacting with data and\/or information stored by the database tool. The database tool may create a variety of internal structures to promote rapid searching and\/or accessing of data. This traditional database may comprise a PART_TERM table, where PART_TERM may stand for partition terms, and terms are synonymous with index entries . There is one record in the PART_TERM table per index entry  stored in the index . Each record in the PART_TERM table is an index entry  that comprises a unique key, the normalized value of the search target , original value of the search target , data store references , collector identity  and\/or partition identity, etc. The normalized value of the search target  may be a symbol string that eliminates punctuation marks such as apostrophes, spaces, and changes the case of all letters to lower case. The collector identity  may be a foreign key reference to a PARTITIONS table. The PARTITIONS table contains one record for each partition  per index . The collector identity  foreign key reference relates the index entry  to the collector  and\/or the partition . In addition, the collector identity  foreign key field also has a database index on it. Thus, the database creates a B+-tree data structure under the covers that promotes requesting records from PART_TERM table by providing a collector identity  value, and the PART_TERM table can return all of the index entries  associated with the subject collector  and\/or partition  without needing to do an exhaustive scan of every record and\/or entry in the PART_TERM table, i.e., without reading all the index entries  in the subject index .","When a lexicographic similarity-based search is executed by the search application , the index entries  associated with a selected relatively small number of collectors  are read from the index data store . However, at this stage of the lexicographic similarity-based search execution, only the normalized value of the search target  and the unique key are needed. Thus, the normalized value of the search target  has been added to the database index on collector identity . When the index data store  is queried for all index entries  in a specific partition , the index data store  only needs to consult its b+-tree for collector identity  and to return the unique id and the normalized value of the search target  of the subject index entries . This saves the index data store  from having to (a) find all index entries  for the partition  by using the given collector identity , then (b) looking up each in the PART_TERM table to get the normalized value. This is called a covering index, because the index b+-tree structure ordered by the collector identity  includes all of the requested information, thereby saving the index data store  some work effort. In other embodiments, however, a different implementation may be employed.","It will readily be appreciated that the partitioned lexicographic similarity-based search system  described above may be used in a wide variety of contexts. It is contemplated that the system  may be employed for performing lexicographic similarity-based searches in banking, in financial services, in medical records, in governmental services, in security, in telecommunications services, in organization member services, and in other applications. For example, in banking, the lexicographic similarity-based search may be used when opening a new account to assure that an already existing account does not conflict in some way with the new account\u2014for example two different John Smith's attempting to open an account in the same bank\u2014and to take any customary process steps to accommodate these circumstances. Also in banking, the lexicographic similarity-based search may be used to identify individuals who may be on a watch list, such as people that have bad credit, that a bank may wish to avoid opening accounts for or lending money to.","A store item that is tagged with a universal product code (UPC) that is corrupted and can only be partially read, for example frost on a UPC tag adhered to a frozen turkey may be identified based on the partial UPC code using the partitioned lexicographic similarity-based search system . The lexicographic similarity-based search may be used to look up medical records in a large national database where childhood visits to the family doctor may list a child's name as Tom while the name used by the adult is Thomas. The lexicographic similarity-based search may be used to map from non-canonical names to canonical names, for example complicated medical terms that a lay person may misremember when searching for further data on a condition his or her doctor may have diagnosed. The partitioned lexicographic similarity-based search system  or portions thereof may be embedded in other applications as a partitioned lexicographic similarity-based search engine.","It is contemplated that the system  may be used in applications for performing lexicographic similarity-based searches over a large number of data entries. Initial tests of prototype implementations of the partitioned lexicographic similarity-based search system  have accomplished effective, timely lexicographic similarity-based searches for data stores  ranging in size from about one million data store entries  to about twenty million data store entries . It is thought that the system  is scalable for use with quite large data stores , for example data stores  containing on the order of about one billion to about twenty billion or more data store entries , by algorithmic structuring and\/or by distributing the search problem across a plurality of computers, for example across a plurality of server computers .","The Jaro edit distance algorithm generally determines a metric of the similarity of two symbol strings, for example two strings of letters such as \u201crobed brown\u201d and \u201crobrt brown.\u201d While in this example, the symbols are letters or characters, it is understood that the principles would apply to other symbol sets. Without describing the technical details in depth, it can be said that the Jaro edit distance algorithm takes account of the number of matching symbols and the location of matching symbols among the two symbol strings. Further, the Jaro edit distance algorithm provides a self-normalized similarity metric. In an embodiment, to perform the Jaro edit distance algorithm for a first symbol string having n symbols and a second symbol string also having n symbols (note that the algorithm does not constrain the symbol strings being compared to be of equal length) may entail performing many comparisons. For example, for the first symbol in the first symbol string, every symbol in the second symbol string is compared to the first symbol of the first symbol string; for the second symbol in the first symbol string, every symbol in the second symbol string is compared to the second symbol in the first symbol string; and so on. In practice, the algorithm can be implemented with efficiencies to reduce the number of operations somewhat.","In the context of the present disclosure, the efficiency of the similarity metric algorithm is of concern because this operation may be the primary limit on the speed of the optimization application  and the search application . For example, if the index data store  comprises one million index entries  distributed to one thousand partitions , and if ten partitions  are selected for searching, the similarity metric algorithm may be executed eleven thousand times. The similarity metric algorithm is executed to determine the similarity of the search term  with each of the one thousand collectors : one thousand executions of the similarity metric algorithm. Then the similarity metric algorithm is executed to determine the similarity of the search term  with the search target  of each of the index entries  associated with the ten selected partitions . Assuming there are about one thousand index entries  associated with each partition , this makes ten times one thousand equals ten thousand executions of the similarity metric algorithm, and thus a total of eleven thousand executions of the similarity metric algorithm.","In an embodiment, an enhanced Jaro edit distance algorithm is used to calculate the similarity metric between the search targets  and the collectors , between the search term  and the collectors , and between the search term  and the search targets . It is a characteristic of the system  that collectors  and index entries  are created relatively rarely but are involved in calculations of the similarity metric relatively often. In an embodiment, the collectors  and the search targets  of the index entries  are analyzed when the collectors  and the index entries  are first created. Based on the analysis, a data structure that represents the symbol content and positions of the symbols in the collectors  and the search targets  is created and becomes part of the collectors  and the index entries . For example, a collector data structure  is created based on the collector symbol string  of each of the collectors , and a search target data structure  is created based on the search target  of each of the index entries .","The data structures ,  promote execution of an enhanced Jaro edit distance algorithm that need not repeatedly parse a given collector  or a given search target  to know whether a given symbol found in the search term  is present or where it is present in the subject collector  or subject search target . While additional processing effort is entailed in the initial creation of the collectors  and the search targets  having the data structure , , because of the high number of times the data structures ,  are used in calculating similarity metrics, this initial investment of processing effort may be paid back many times over with increased efficiency in calculating the similarity metrics. Further, the additional processing effort to create the collector data structure  and the search target data structure  may be done in a batch processing operation mode that does not interfere with partitioned lexicographic similarity-based searches.","Turning now to , an exemplary search target data structure  is described. In an embodiment, the search target data structure  may comprise an array  comprising a first group of elements  that correspond in number to the number of symbols in an ordered symbol set  used to create search terms , search targets , and collectors . For example, in the case of an ordered symbol set comprising English alphabetic characters and roman numerals (note for this simple illustration the case of the alphabetic characters is ignored, but in an embodiment, the symbol set could be extended to comprise 26 small alphabetic letters and 26 capital alphabetic letters), the first group of elements  may comprise 36 elements: 26 elements for each of the letters of the English alphabet ordered in alphabetic order and 10 elements for each of the digits 0 through 9 ordered according to increasing value. The first element of the array  may be associated with the first symbol in the ordered symbol set , the second element of the array  may be associated with the second symbol in the ordered symbol set , etc. Each of the elements of the array  contain either a zero, indicating that none of the corresponding symbols are present in the subject symbol string , for example a search target , or a positive integer indicating that at least one of the corresponding symbols is present in the symbol string  and indicating a location in the array  among a second group of elements  where information identifying how many of the subject symbol are present in the subject symbol string  and what their locations are in the symbol string . The first group of elements  comprise a fixed number of elements, and the second group of elements  comprise a variable number of elements.","For example, given the symbol string  \u201cbill\u201d, the first element of the array  would contain a \u20180\u2019 value, because \u201cbill\u201d contains no \u2018a\u2019 symbols. The second element of the array  would contain a \u201837\u2019 value to indicate that at least one \u2018b\u2019 is present in the symbol string  and to indicate what element of the array  contains further information about the position of the letter \u2018b\u2019 in the symbol string . The 37th element of the array  would contain the value \u20181\u2019 indicating that the letter \u2018b\u2019 is in the first position of the symbol string . The 38element of the array  would contain a \u20180\u2019 value to indicate that there are no further occurrences of the letter \u2018b\u2019 in the symbol string . The third element through the eighth element of the array  each contain the value \u20180\u2019 to indicate there are no symbols from the set c, d, e, f, g, or h in the symbol string . The ninth element of the array  would contain a \u201839\u2019 value to indicate that at least one \u2018i\u2019 is present in the symbol string  and to indicate what element of the array  contains further information about the position of the letter T in the search string . The 39element of the array  would contain a \u20182\u2019 value indicating that the letter T is in the second position of the symbol string . The 40element of the array  would contain a \u20180\u2019 value to indicate that there are no further occurrences of the letter T in the search string .","The tenth and eleventh elements of the array  would each contain the value \u20180\u2019 to indicate that there are no symbols from the set j or k in the symbol string . The twelfth element of the array  would contain a \u201841\u2019 value to indicate that at least one \u2018l\u2019 is present and to indicate what element of the array  contains further information about positions of the letter \u2018l\u2019 in the symbol string . The 41element of the array  would contain a \u20183\u2019 value indicating that the letter \u2018l\u2019 is in the third position of the symbol string . The 42element of the array  would contain a \u20184\u2019 value indicating that the letter \u2018l\u2019 is also in the fourth position of the symbol string . The 43element of the array  would contain a \u20180\u2019 value indicating that there are no further \u2018l\u2019 letters in the symbol string . The remaining elements of the first group of elements \u2014thirteenth element through thirty-sixth element\u2014each contain a \u20180\u2019 value indicating that the symbol string  contains none of the corresponding letters or numerals.","Any of the collectors , for example the collector symbol string , the search targets , and the search term  may be mapped using the array . In some embodiments, the search term  may not be mapped at all but rather parsed on every execution of the determination of the similarity metric involving the search term . Alternatively, the search term  may be mapped to a search term data structure comprising an array of integers indicating which position of the symbol set  corresponds to each position in the search term . For example, the search term \u2018billy\u2019 could be mapped to an array of integers {2, 9, 12, 12, 25, 0}, where the 0 value indicates the end of the search term . Again, because the similarity metric is calculated many times for a search term , the extra computational effort of building a search term data structure may be rewarded by increased efficiency achieved in the calculation of the similarity metric.","One skilled in the art will readily appreciate the reduced number of operations used to determine an edit distance between the search term \u201cbilly\u201d mapped to an array of integers and the array  described above with reference to the number of operations used by a standard Jaro edit distance algorithm performed on two symbol strings. Further, in an embodiment, the use of the data structures ,  to determine edit distance between two symbol strings may promote cache operation improvements when executing the applications , , , for example as a result of improved cache locality.","It is understood that the present disclosure contemplates alternative implementations of the data structures ,  as well as the search term data structure. For example, in an embodiment, one of the elements of first group of elements may contain a \u2018\u22121\u2019 value to indicate that none of the following symbols in the first group of elements  of the array  are present in the represented symbol string and may promote shortening the similarity analysis of the subject symbol string . For example, in the exemplary case of the symbol string \u201cbill,\u201d the 13element of the array may contain a \u2018\u22121\u2019 value indicating that there are no other symbols contained in the symbol string  and further processing of the array  can be avoided. As a further refinement, the order symbols of the array  need not follow the canonical order of the symbol set , for example alphabetic order, and instead may be ordered according to a frequency of occurrence of symbols from most frequently occurring symbols to least frequently occurring symbols. This non-canonical ordering of symbols in the array  may promote greater shortening of the similarity analysis. The frequency of occurrence may be based on standard frequency of occurrence statistics. It is understood that the use of non-canonical ordering of symbols may be employed for each of the indices  and that different symbol frequency statistics may apply for each different index .","Alternatively, the frequency of symbol occurrence statistics may be determined by the applications ,  when distributing index entries  to partitions . An additional housekeeping type of operation may be defined that redefines the order of symbols in the array  and rebuilds the collectors  of the partitions  based on the redefined symbol order. The search target data structures  of each of the index entries  may be revised in accordance with the changed collectors  or alternatively the index entries  may simply be redistributed to the partitions based on either executing the initialization application  or the optimization application . The redefinition of symbol order in the array  may be performed periodically or based on some triggering event such as determining that the accumulated statistics of symbol frequency occurrence has changed beyond a threshold amount since the previous redefinition of symbol order in the array .","As another refinement, in an embodiment, elements in the array  that are not associated with a symbol in the symbol string  may provide an index to the next element in the array  that is associated with a symbol in the symbol string . For example, element  of array  may contain a \u2018\u22129\u2019 value to indicate that the next non-zero value in the array  occurs at the ninth array element, allowing the analysis to skip over array elements - and proceed directly to array element . Likewise, element  of array  may contain a \u2018\u221212\u2019 value to indicate that the next non-zero value in the array  occurs at the twelfth array element, allowing the analysis to skip over array element  and proceed directly to array element .","One skilled in the art will readily appreciate that there may be tradeoffs between the efficiency gains of implementing such elaborations versus the additional complexity added to the logic of the applications , , . The benefit provided by some of these elaborations may depend on the character of the search terms  and\/or the search targets . It is understood that applications , ,  may comprise different procedures and\/or algorithms directed to some of the indices . For example, the search target data structures  and the collector data structures  associated with the first index may be determined based on structuring the array  according to a canonical symbol order, and the search target data structures  and the collector data structures  associated with the second index may be determined based on structuring the array  according to a non-canonical symbol order. These differences may be defined in the schemas , discussed below with reference to .","The information stored in the elements of the array  may be different from integers, for example real number type data or character type data. For example, rather than the array , a linked list data structure might be used. Additionally, the array  may be structured in a different way in the second group of elements . For example, rather than using an array element having a \u20180\u2019 value to indicate there are more symbols of the subject type, the number of symbols of the subject type, for example the number of \u2018l\u2019, may be embedded in the integer contained in the first location\u2014for example in the two most significant bits of an 8 bit integer, the five most significant bits of a 16 bit integer, or some other coding pattern. The present disclosure contemplates yet other implementations of the search data structures and the search term data structure.","In an embodiment, one or more domain specific similarity metric calculation algorithms may be employed to determine the similarity between search targets  and collectors , between search terms  and collectors , and between search terms  and search targets . Domain specific similarity metric calculations may be employed to determine similarity based on a variety of different kinds of distances, for example the distance between different symbols as laid out on a keyboard, for example a QWERTY keyboard; geographic distances; phonetic distances; magnetic scanning distance; optical scanning distance; and others. For example, a magnetic distance may be determined between a misread magnetic strip on a credit card and a stored value of the magnetic strip.","A domain specific similarity metric calculation algorithm may take into account semantics of a symbol string, for example a string of 10 digits forming a phone number, a string of 9 digits forming a social security number, a time and date stamp, a set of global positioning system (GPS) coordinates, a set of latitude and longitude coordinates, and other semantics. Domain specific similarity metric calculation algorithms may be used to determine geographic similarity, for example the distance between two global positioning system coordinates. A domain specific similarity metric calculation algorithm may be used to determine similarity between a magnetic ink character recognition (MICR) data read from a check and a MICR string stored in a database. Such a MICR similarity metric calculation algorithm may take into account the specific characteristics of MICR strings to develop insight into a distance between an automatically read MICR string and a stored MICR string. A domain specific similarity metric calculation algorithm may be used to determine a similarity between an automatically read vehicle identification number (VIN) and a VIN stored in a database. A VIN similarity metric calculation algorithm may take into account the particular structure of VINs to determine a distance between an automatically read VIN and a stored VIN. Domain specific similarity metric calculation algorithms may be used to determine similarity of automatically read to stored universal product codes, bar codes, and two dimensional bar codes. Domain specific similarity metric calculation algorithms may be used to determine the similarity between different phonetic representations of spoken words. Domain specific similarity metric calculation algorithms may be used to determine the similarity between different magnetic strip value strings. Other domain specific similarity metric calculation algorithms are contemplated by the present disclosure. Domain specific similarity metric calculation algorithms may be defined for determining a distance between automatically determined DNA sequences and a stored DNA sequence. Domain specific similarity metric calculation algorithms may be defined for determining a distance between an automatically scanned signature and a stored signature.","Turning now to , an embodiment of the schemas  is described. The schemas  are not the same as the schemas employed in database technologies. In database technologies, a schema may define the elements of database tables, the relationships among database tables, the structure of database tables in terms of column arrangements and data types of columns, various keys, and other information needed to support standard interactions with the database. The schemas , however, define information that is employed by the applications , ,  to perform partitioned lexicographic similarity-based searches. In some contexts, the schemas  may be referred to as similarity-based search schemas.","The schemas  may optionally be part of the index data store  to promote flexibility and\/or configurability of the applications , , . In an embodiment, a schema  may comprise a collector format definition  that defines the format of the collector . For example, the collector format definition  may define the symbol set from which the collectors  of an index  is composed and the number of symbols in the subject collectors . The schema  may further comprise a search target format definition  that defines the format of the search targets  of the index entries  associated with the subject index . The schema  may further comprise a similarity metric algorithm definition  that identifies a similarity metric algorithm that is used to calculate a similarity metric with reference to operations on the subject index . A different schema  may be defined for each index .","Turning now to , an optional aliasing feature of the partitioned lexicographic similarity-based search system  is described. In an embodiment, it may be desirable to define a plurality of index entries  in a single index  each referring back to the same data store entry . For example, robert brown may be known to some people as \u201crobert brown,\u201d as \u201cbob brown\u201d to other people, as \u201cbobby brown\u201d to other people, and as \u201cbubba brown\u201d to yet other people. In some applications it may be useful to be able to find the \u201crobert brown\u201d data store entry when any of these alternative names are entered into the user interface  as a search term .","When initializing the index data store  or at some later time, index entries  that alias another index entry  may be created. For example, an index entry  can be created having a search target  with the value \u201cbob brown\u201d and the data store entry reference  \u201cDB Ref\u201d which therefore points to the same data store entry as does the index entry  having the search target  \u201crobert brown.\u201d Note that the alias index entry  will be distributed to a partition  based on its search target  \u201cbob brown\u201d and given the difference from \u201crobert brown,\u201d the alias index entry  may be distributed to a different partition  from the partition  to which the index entry  having the search target  \u201crobert brown\u201d is distributed. The alias feature described above with respect to alternative names and\/or nicknames is applicable to other circumstances. For example, sometimes a single physical building may be referred to by two different addresses. By creating a primary index entry  and an alias index entry  in an address index , a lexicographic similarity-based search based on either of the alternative addresses may find the same data store entry  associated with the subject building. The aliasing concept is readily applied to index entries  that do not have the data store entry reference  and instead comprise the target information component .","Turning now to , a method  is described. At block , a first plurality of collectors  is built. The format of the collectors  may be defined by the collector format definition  in the schema . In an embodiment, the plurality of collectors  may be built using a genetic algorithm. Alternatively, the first plurality of collectors  may be built using another algorithm, for example a deterministic algorithm based on analyzing the search targets  of the index entries . As discussed further above, a variety of genetic algorithms are contemplated for evolving a set of collectors  to adapt the partitions  in accordance with a fitness metric. Additionally, as discussed further above, the process of evolving the set of collectors  may involve evolving through several generations of collectors  to improve the fitness of the collectors  and\/or the partitions , for example iterating the process of evolving several times.","The genetic algorithm may comprise comparing a plurality of collectors  to a fitness criterion\u2014for example the desirable number of index entries  attracted to the collectors \u2014and mutating at least one of the collectors  to build a new collector , where the at least one of the collectors  is selected based on the comparison of the at least one of the collectors  to the fitness metric. The new collector  may be formed by mutating a collector  using any mutation method, several of which are disclosed above.","In an embodiment, the collectors  may each comprise a symbol string composed from a common symbol set, for example an alphabet, a set of numerals, or another set of symbols. For example, one symbol set may have 36 symbols that comprise the letters of the English alphabet (ignoring case) and the digits 0 through 9. In other cases, however, other symbol sets may be used. The symbol set may also be defined in the collector format definition  or perhaps in a separate portion of the schema . The collectors  may comprise a plurality of components, for example the collector symbol string  and a collector data structure , where the collector symbol string  may comprise a string of the symbols and the collector data structure  may represent the string of symbols in a way which promotes efficient determination of similarity metrics between the collector  and other symbol strings, for example a search target  of an index entry  and\/or a search term . Building the collectors  may comprise analyzing the collector symbol string  to form the collector data structure , as described above with reference to . In an embodiment, each of the collectors  and\/or the collector symbol strings  may have the same number of symbols.","At block , a first plurality of index entries  are associated with the first plurality of collectors . Each index entry  comprises a search target  associated with at least one of the first plurality of collectors  based on a similarity between the search target  of the index entry  and the at least one collector , for example the collector symbol string . The similarity between the search target  and the at least one collector  may be determined by using any algorithm for calculating similarity, for example the algorithms for calculating similarity described above and\/or other algorithms. In an embodiment, the similarity may be determined by an edit distance algorithm, for example a Jaro edit distance algorithm or an enhanced Jaro edit distance algorithm.","In an embodiment, some of the index entries  may be associated with two collectors  and\/or partitions . For example, when a search target  of an index entry  has similarity metric values for two different collectors  that are close in value and are the two highest similarity metric values for the index entry  compared to all the collectors , the index entry  may be associated with both collectors  and\/or both partitions . In this way, if a search term  selects one of the two collectors , the index entry  will be tested for similarity of its search target  to the search term . In an embodiment, the index entry  may have a plurality of collector identities  and further may include information about the similarity metric values associated with each of the collectors  in each of the collector identities . In some contexts, this may be referred to as fuzzy partitioning, because some of the index entries  may be \u201cfuzzily\u201d assigned to a plurality of partitions . It is understood that index entries  in the embodiment employing fuzzy partitioning may notwithstanding be associated with one and only one collector  and\/or partition , as when the second highest similarity metric representing the similarity between the collector  and another collector  is below a minimum threshold for associating with the second collector .","The associations of index entries  with the first plurality of collectors  may have been determined during the processing of block . For example, to evaluate the fitness of the first plurality of collectors  the similarity between the collectors  and the search targets  may be determined, the preferred association of index entries  with collectors  may be determined based on the similarities, and the associations may be saved in random access memory (RAM) or in cache or in some other process memory. Alternatively, after the collectors  have been finalized, the similarity between the search target  of the index entries  and the collector symbol string  of the collectors  may again be analyzed, and the index entries  distributed to the collectors  and\/or the partitions . The processing of block  may comprise assigning the collector identity  of the index entry  to identify the collector  and\/or partition  with which the index entry  is associated. In an embodiment, the processing of blocks  and  may comprise either of the initialization of the index data store  or the optimization of one or more indices . As described further above, the process of updating the collector identities , for example the processing of block , takes time, and care may be taken to handle lexicographic similarity-based searches that are conducted during the process of reassigning the collector identities .","After block , a search term  may be received by the search application  for conducting a partitioned lexicographic similarity-based search. For example, another application invokes an application programming interface (API) of the search application  to provide the search term  or the user interface  provides the search term . It is understood that the search term  is composed of symbols from the same symbol set used to compose the collector , for example the collector symbol string , and the search target .","At block , a second plurality of collectors  are selected from among the first plurality of collectors  based on a similarity between the search term  and the collector , for example between the search term  and the collector symbol string . Any of the algorithms for calculating similarity metrics described above as well as other algorithms for calculating similarity metrics may be employed to evaluate the similarity between the search term  and the collector .","The second plurality of collectors  may be selected based on the calculated similarity metric and based on another criterion, for example a minimum number of collectors  and\/or partitions  and\/or a minimum number of index entries  associated with the second plurality of collectors . For example, the five collectors  found to be most similar to the search term  are selected. Alternatively, the ten collectors  found to be the most similar to the search term  are selected. Alternatively, some other number of collectors  is selected. Conceptually, the similarity metrics of all the collectors  can be listed in order according to similarity, and given a desired number N, the N most similar collectors  can be selected as the first N collectors  in the ordered list.","At block , a second plurality of index entries  are selected from among the index entries  associated with the second plurality of collectors  based on a similarity between the search term  and the search targets  of each of the index entries  associated with the second plurality of collectors . The similarity between the search term  and the search targets  may be determined in a manner similar to that described for block  above, as described elsewhere above, or according to different algorithms. For example, if ten thousand index entries  are associated with ten collectors  that comprise the second plurality of collectors , ten thousand similarity metric values are calculated, and some fraction of those index entries  are selected based at least in part on the similarity between the search term  and the search targets  of the index entries  associated with the second plurality of collectors . For example, all index entries  that exceed a specified threshold of similarity with the search term  are selected as the first plurality of index entries . Alternatively, the index entries  are ordered according to similarity, and the M most similar index entries  are selected as the first plurality of index entries .","At block , information related to the second plurality of index entries  is presented, for example displayed on the user interface . The information may be stored in the target information component , for example a canonical name for a medical procedure. Alternatively the information may comprise information stored in the application data store  that is retrieved using the optional data store entry reference . Additionally, the search target  of each of the first plurality of index entries  may be presented. The information that is presented may be presented ordered based on the similarity metric value, for example with the information associated with the index entries  that were found to be most similar to the search term  listed first. Lexicographic similarity-based search metrics may be presented along with the search targets . For example, the similarity order of the collector  to which the corresponding index entry  was associated may be displayed. The similarity metric determined for the similarity between the search term  and the search target  of the corresponding index entry  may be presented. Presenting such information about the conduct of the lexicographic similarity-based searches may promote adapting or tuning the search application  and\/or the index data store , for example using the user interface  to invoke commands on the applications , ,  to tune one or more execution configuration parameters.","Turning now to , a method  is described. At block , a first plurality of collectors  are built. The first plurality of collectors  may be built using a genetic algorithm or a deterministic algorithm based on analysis of the index entries . The processing of block  may be conducted similarly to the processing of block  described above with reference to  and method . At block , a first plurality of index entries  are associated with the first plurality of collectors  to create an index . Each index entry  in the subject index  comprises a search target  and one of the data store entry reference  or the target information component . Each of the first plurality of index entries  is associated with at least one of the first plurality of collectors  based on a similarity between the search target  of the index entry  and the at least one collector  and\/or collector symbol string . The processing of block  may be conducted similarly to the processing of block  described above with reference to  and method . In an embodiment, some of the index entries  may be associated with two or more collectors  and\/or partitions  as described above with reference to  block  and to fuzzy partitioning.","A plurality of lexicographic similarity-based searches may be conducted in a manner similar to that described above. Further, after the processing of block  has been completed new index entries  can be added to the subject index  and associated with collectors  and\/or partitions . Likewise, some index entries  may be deleted from the subject index . As these additions and deletions of index entries  take place, the partitions  may become less fit for partitioned lexicographic similarity-based searches. For example, some partitions  may become undesirably small (associated with relatively too few index entries ) and other partitions  may become undesirably large (associated with relatively too many index entries ). Either of adding or deleting index entries  creates a second plurality of index entries  that comprises all the index entries  that are present in the first plurality of index entries , excepting any deleted index entries , and further including any added index entries  that are not comprised in the first plurality of index entries .","At block , in response to either adding at least one index entry  to the subject index  or deleting at least one index entry  from the subject index , which may be referred to as a second plurality of index entries , building a second plurality of collectors  using the genetic algorithm, wherein the second plurality of collectors  is based on the first plurality of collectors . The second plurality of collectors  may contain many of the collectors  present in the first plurality of collectors , but the first and second plurality of collectors  are not identical. The second plurality of collectors  may be missing some collectors  that are present in the first plurality of collectors  and may have other new collectors  that are mutated from one or more collectors  of the first plurality of collectors . A variety of methods of mutating new collectors  from old collectors  associated with partitions  that may contain too many index entries  is described further above. Any of these mutation methods may be used to generate new collectors .","This processing can comprise determining the similarity metric between the search targets  of all the index entries  in the subject index  with each of the collectors  in the second plurality of collectors  to identify a preferred partitioning of the index entries , determining a fitness of this preferred partitioning, and possibly reiterating the process of generating collectors  using the mutation process, and then again determining the fitness of the resulting partitions . This may be referred to as evolving or optimizing the partitions , and the process of repeatedly mutating a population, determining a fitness of the new population, and again mutating the population can be considered to be a genetic algorithm. In an embodiment, the optimization application  may perform the processing of block  and the following block .","In an embodiment, the optimization process is conducted while the search application  remains in service, hence in the presence of lexicographic similarity-based searches conducted in the indices . The processing of block  described above may be accomplished without changing the partitions  in the index data store , for example by storing the results of the evolution cycles in random access memory, in cache, or in other memory separate from the index data store . When the optimization application  has evolved the collectors  to a satisfactory point\u2014for example when the collectors  are determined to satisfy a minimum fitness standard or after a maximum number of evolution cycles\u2014the second plurality of index entries  are redistributed to the second plurality of collectors , by writing to the collector identities  of the index entries  that have moved. Alternatively, once the collectors  have been determined, the similarities between the search target  of the index entries  and the collector symbol string  of the collectors  may be determined again and the index entries  distributed appropriately to the collectors  and\/or the partitions . It is contemplated that the optimization procedure may be time consuming, so the optimization process may be designed to support interruption and pausing without interfering with partitioned lexicographic similarity-based searching.","Because the updating of collector identities  may take a period of time, while the updating of collector identities  are ongoing, the lexicographic similarity-based searches are performed against both the old set of partitions  and the new set of partitions . While the second plurality of index entries  are having their collector identities  updated, some index entries  will be located in the old partitions  and other index entries  will be located in the new partitions  (wherein \u201clocated in\u201d a given partition  simply means the collector identity  of the subject index entry  identifies the collector  of the partition ). Thus, by searching both sets of collectors  and\/or partitions , index entries  that are similar to the search term  are less likely to be missed.","Lexicographic similarity-based searches begun after the second plurality of index entries  have all been migrated to the second plurality of collectors  may only search among the second plurality of collectors  and\/or partitions . The first plurality of collectors \u2014or those collectors  that are not located in the second plurality of collectors \u2014are deleted only after the last lexicographic similarity-based search begun before the second plurality of index entries  have all been migrated over to the second plurality of collectors  and\/or partitions .","The optimization operation may be executed periodically, for example about weekly, about monthly, or at some other periodic interval. The optimization operation may be scheduled to occur during intervals of low activity, for example during early morning hours and\/or on weekends. The optimization operation may be completed in portions, for example a first portion on a first morning, a second portion on a second morning, and a final third portion on a third morning. The optimization operation may be triggered by the determination that a fitness threshold has been exceeded, and the optimization may start immediately or be deferred to the next preferred optimization scheduling opportunity, for example early in the morning and\/or on a weekend. In an embodiment, optimization is designed to reduce the risk that a lexicographic similarity-based search conducted while optimization is taking place may produce an incorrect and\/or a less accurate search result.","At block , the second plurality of index entries  is associated with the second plurality of collectors , wherein each one of the second plurality of index entries  is associated with at least one of the second plurality of collectors  based on the similarity between the search target  of the index entry  and the at least one collector . For example, the collector identity  of some of the second plurality of collectors  is overwritten with the identity of a collector  to which the subject index entry  have been moved to. The determination of similarity may be performed as described above in block . After block , a search term  may be received by the search application  for conducting a partitioned lexicographic similarity-based search, for example as described above with reference to  and block . At block , a third plurality of collectors  from among the second plurality of collectors  is selected based on a similarity between the search term  and the third plurality of collectors . The similarity between the search term  and each of the second plurality of collectors  may be determined substantially as described above.","At block , a third plurality of index entries  is selected from among the second plurality of index entries  associated with the third plurality of collectors  based on a similarity between the search term  and each of the third plurality of index entries . The similarity between the search term  and each of the search targets  of the second plurality of index entries  may be determined substantially as described above. The third plurality of index entries  may be considered to be lexicographic similarity-based search results and\/or intermediate lexicographic similarity-based search results. The third plurality of index entries  may comprise the desired search results, for example stored in the target information component  of the index entries , or may comprise a reference to the desired search results, for example stored in the optional data store entry reference  of the index entries . At block , information obtained by the lexicographic similarity-based search is presented substantially similarly to the presentation of results described above with reference to  block .","Turning now to , a method  is described. At block , a first plurality of collectors  is built, wherein each collector  comprises a collector symbol string  and a collector data structure . At block , a first plurality of index entries  is associated with the first plurality of collectors . Each index entry  comprises a search target , a search target data structure , and one of a data store entry reference  or the target information component . Each index entry  is associated with at least one collector  based on an edit distance between the search target  of the index entry  and the collector symbol string  of the at least one collector . The index entry  may be associated with the collector  that is determined to be most similar to the index entry , for example the search target  is determined to be most similar to the subject collector symbol string . Alternatively, the index entry  may be associated with two or more collectors  that are determined to be most similar to the index entry , as for example when the index entry  is treated with a fuzzy partitioning technique. The edit distance is determined based on one of analyzing the collector data structure  and the search target , analyzing the collector symbol string  and the search target data structure , or analyzing the collector data structure  and the search target data structure . After block , a search term  may be received by the search application .","Each of the collector data structures  and the search target data structures  comprise a data structure having a first group of elements . The number of elements in the first group of elements  is equal to the number of different symbol values in a symbol set that the search term  may be composed from. Each element of the first group of elements  corresponds to one of the symbol values and indicates the presence or absence of the corresponding symbol values in the collector symbol string  or the search target .","At block , a second plurality of collectors  is selected from among the first plurality of collectors  based on an edit distance between the search term  and the collector symbol string  of each of the second plurality of collectors , wherein the edit distance is determined based on analyzing the search term  and the collector data structure . The second plurality of collectors  may be the collectors  that are determined to be most similar to the search term , for example the collector symbol strings  are determined to be the most similar to the subject search term . At block , a second plurality of index entries  is selected from among the index entries  associated with the second plurality of collectors  based on an edit distance between the search term  and the search target  of each of the index entries  associated with the second plurality of collectors , wherein the edit distance is determined based on analyzing the search term  and the search target data structure  of each of the index entries  associated with the second plurality of collectors . For example, the search target  of the second plurality of index entries  are determined to be the most similar to the subject search term  among the index entries  associated with the second plurality of collectors .","At block , information related to the second plurality of index entries  is presented, for example as described in further detail with reference to  block  and\/or  block .","Turning now to , a method  is described. The method  may be performed by one or more applications and\/or computer programs that execute on one or more computers. For example, a first application executing on a first computer may determine a similarity value and send this similarity value to a second program executing on the first computer or executing on a different second computer for further processing. At block , a first symbol string is received. At block , a data structure is created that has a first group of elements, wherein the number of elements in the first group of elements is equal to the number of different symbol values in a symbol set that the first symbol string is composed from, and wherein each element of the first group of elements corresponds to one of the symbol values and indicates the location of the corresponding symbol value in the first symbol string. The data structure may be similar to the array  discussed above with reference to .","Symbol sets were discussed further above, and it is contemplated that the method  may be practiced using a wide variety of different symbol sets. It is understood that the elements of the first group of elements may be arranged in any order. In an embodiment, the first group of elements may be arranged in a canonical order associated with the subject symbol set. In another embodiment, the first group of elements may be arranged in an order of frequency of occurrence of symbols of the symbol set in a domain of symbol strings to which the first and second symbol strings belong. For example, a characteristic frequency of occurrence of letters in first names of people may be different from a characteristic frequency of occurrence of letters in street addresses.","At block , a second symbol string is received, wherein the second symbol string is composed from the symbols that comprise the symbol set. At block , a similarity between the second symbol string and the first symbol string is determined based on using each of the symbols of the second symbol string to index into the corresponding element of the first group of elements in the data structure to determine whether the subject symbol in the second symbol string is present in the first symbol string. In an embodiment, the similarity between the symbol strings may be determined based on the number of symbols shared in common by the symbol strings and\/or based on the relative positions of the common symbols within the symbol strings. In an embodiment, the similarity may be determined based at least in part on using a Jaro edit distance algorithm. At block , action is taken based on the similarity between the second symbol string and the first symbol string. For example, the first symbol string is presented on a display screen. Alternatively, the data structure may be associated with other information, and at least some of this other information may be presented on a display screen or further processed by an application.","Method  contemplates using the techniques discussed above with reference to  in other applications that may not involve partitioning of a data store of index entries based on the similarity of a symbol string in the index entry to a symbol string associated with each of the partitions.",{"@attributes":{"id":"p-0138","num":"0137"},"figref":"FIG. 13","b":["380","380","382","384","386","388","390","392","382"]},"It is understood that by programming and\/or loading executable instructions onto the computer system , at least one of the CPU , the RAM , and the ROM  are changed, transforming the computer system  in part into a particular machine or apparatus having the novel functionality taught by the present disclosure. It is fundamental to the electrical engineering and software engineering arts that functionality that can be implemented by loading executable software into a computer can be converted to a hardware implementation by well known design rules. Decisions between implementing a concept in software versus hardware typically hinge on considerations of stability of the design and numbers of units to be produced rather than any issues involved in translating from the software domain to the hardware domain. Generally, a design that is still subject to frequent change may be preferred to be implemented in software, because re-spinning a hardware implementation is more expensive than re-spinning a software design. Generally, a design that is stable that will be produced in large volume may be preferred to be implemented in hardware, for example in an application specific integrated circuit (ASIC), because for large production runs the hardware implementation may be less expensive than the software implementation. Often a design may be developed and tested in a software form and later transformed, by well known design rules, to an equivalent hardware implementation in an application specific integrated circuit that hardwires the instructions of the software. In the same manner as a machine controlled by a new ASIC is a particular machine or apparatus, likewise a computer that has been programmed and\/or loaded with executable instructions may be viewed as a particular machine or apparatus.","The secondary storage  is typically comprised of one or more disk drives or tape drives and is used for non-volatile storage of data and as an over-flow data storage device if RAM  is not large enough to hold all working data. Secondary storage  may be used to store programs which are loaded into RAM  when such programs are selected for execution. The ROM  is used to store instructions and perhaps data which are read during program execution. ROM  is a non-volatile memory device which typically has a small memory capacity relative to the larger memory capacity of secondary storage . The RAM  is used to store volatile data and perhaps to store instructions. Access to both ROM  and RAM  is typically faster than to secondary storage . The secondary storage , the RAM , and\/or the ROM  may be referred to in some contexts as computer readable storage media and\/or non-transitory computer readable media.","I\/O devices  may include printers, video monitors, liquid crystal displays (LCDs), touch screen displays, keyboards, keypads, switches, dials, mice, track balls, voice recognizers, card readers, paper tape readers, or other well-known input devices.","The network connectivity devices  may take the form of modems, modem banks, Ethernet cards, universal serial bus (USB) interface cards, serial interfaces, collector ring cards, fiber distributed data interface (FDDI) cards, wireless local area network (WLAN) cards, radio transceiver cards such as code division multiple access (CDMA), global system for mobile communications (GSM), long-term evolution (LTE), worldwide interoperability for microwave access (WiMAX), and\/or other air interface protocol radio transceiver cards, and other well-known network devices. These network connectivity devices  may enable the processor  to communicate with the Internet or one or more intranets. With such a network connection, it is contemplated that the processor  might receive information from the network, or might output information to the network in the course of performing the above-described method steps. Such information, which is often represented as a sequence of instructions to be executed using processor , may be received from and outputted to the network, for example, in the form of a computer data signal embodied in a carrier wave.","Such information, which may include data or instructions to be executed using processor  for example, may be received from and outputted to the network, for example, in the form of a computer data baseband signal or signal embodied in a carrier wave. The baseband signal or signal embodied in the carrier wave generated by the network connectivity devices  may propagate in or on the surface of electrical conductors, in coaxial cables, in waveguides, in an optical conduit, for example an optical fiber, or in the air or free space. The information contained in the baseband signal or signal embedded in the carrier wave may be ordered according to different sequences, as may be desirable for either processing or generating the information or transmitting or receiving the information. The baseband signal or signal embedded in the carrier wave, or other types of signals currently used or hereafter developed, may be generated according to several methods well known to one skilled in the art. The baseband signal and\/or signal embedded in the carrier wave may be referred to in some contexts as a transitory signal.","The processor  executes instructions, codes, computer programs, scripts which it accesses from hard disk, floppy disk, optical disk (these various disk based systems may all be considered secondary storage ), ROM , RAM , or the network connectivity devices . While only one processor  is shown, multiple processors may be present. Thus, while instructions may be discussed as executed by a processor, the instructions may be executed simultaneously, serially, or otherwise executed by one or multiple processors. Instructions, codes, computer programs, scripts, and\/or data that may be accessed from the secondary storage , for example, hard drives, floppy disks, optical disks, and\/or other device, the ROM , and\/or the RAM  may be referred to in some contexts as non-transitory instructions and\/or non-transitory information.","In an embodiment, the computer system  may comprise two or more computers in communication with each other that collaborate to perform a task. For example, but not by way of limitation, an application may be partitioned in such a way as to permit concurrent and\/or parallel processing of the instructions of the application. Alternatively, the data processed by the application may be partitioned in such a way as to permit concurrent and\/or parallel processing of different portions of a data set by the two or more computers. In an embodiment, virtualization software may be employed by the computer system  to provide the functionality of a number of servers that is not directly bound to the number of computers in the computer system . For example, virtualization software may provide twenty virtual servers on four physical computers. In an embodiment, the functionality disclosed above may be provided by executing the application and\/or applications in a cloud computing environment. Cloud computing may comprise providing computing services via a network connection using dynamically scalable computing resources, which may be referred to in some contexts as elastic provisioning. Cloud computing may be supported, at least in part, by virtualization software. A cloud computing environment may be established by an enterprise and\/or may be hired on an as-needed basis from a third party provider. Some cloud computing environments may comprise cloud computing resources owned and operated by the enterprise as well as cloud computing resources hired and\/or leased from a third party provider.","In an embodiment, some or all of the functionality disclosed above may be provided as a computer program product. The computer program product may comprise one or more computer readable storage medium having computer usable program code embodied therein to implement the functionality disclosed above. The computer program product may comprise data structures, executable instructions, and other computer usable program code. The computer program product may be embodied in removable computer storage media and\/or non-removable computer storage media. The removable computer readable storage medium may comprise, without limitation, a paper tape, a magnetic tape, magnetic disk, an optical disk, a solid state memory chip, for example analog magnetic tape, compact disk read only memory (CD-ROM) disks, floppy disks, jump drives, digital cards, multimedia cards, and others. The computer program product may be suitable for loading, by the computer system , at least portions of the contents of the computer program product to the secondary storage , to the ROM , to the RAM , and\/or to other non-volatile memory and volatile memory of the computer system . The processor  may process the executable instructions and\/or data structures in part by directly accessing the computer program product, for example by reading from a CD-ROM disk inserted into a disk drive peripheral of the computer system . Alternatively, the processor  may process the executable instructions and\/or data structures by remotely accessing the computer program product, for example by downloading the executable instructions and\/or data structures from a remote server through the network connectivity devices . The computer program product may comprise instructions that promote the loading and\/or copying of data, data structures, files, and\/or executable instructions to the secondary storage , to the ROM , to the RAM , and\/or to other non-volatile memory and volatile memory of the computer system .","In some contexts, a baseband signal and\/or a signal embodied in a carrier wave may be referred to as a transitory signal. In some contexts, the secondary storage , the ROM , and the RAM  may be referred to as a non-transitory computer readable medium or a computer readable storage media. A dynamic RAM embodiment of the RAM , likewise, may be referred to as a non-transitory computer readable medium in that while the dynamic RAM receives electrical power and is operated in accordance with its design, for example during a period of time during which the computer  is turned on and operational, the dynamic RAM stores information that is written to it. Similarly, the processor  may comprise an internal RAM, an internal ROM, a cache memory, and\/or other internal non-transitory storage blocks, sections, or components that may be referred to in some contexts as non-transitory computer readable media or computer readable storage media.","While several embodiments have been provided in the present disclosure, it should be understood that the disclosed systems and methods may be embodied in many other specific forms without departing from the spirit or scope of the present disclosure. The present examples are to be considered as illustrative and not restrictive, and the intention is not to be limited to the details given herein. For example, the various elements or components may be combined or integrated in another system or certain features may be omitted or not implemented.","Also, techniques, systems, subsystems, and methods described and illustrated in the various embodiments as discrete or separate may be combined or integrated with other systems, modules, techniques, or methods without departing from the scope of the present disclosure. Other items shown or discussed as directly coupled or communicating with each other may be indirectly coupled or communicating through some interface, device, or intermediate component, whether electrically, mechanically, or otherwise. Other examples of changes, substitutions, and alterations are ascertainable by one skilled in the art and could be made without departing from the spirit and scope disclosed herein."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a more complete understanding of the present disclosure, reference is now made to the following brief description, taken in connection with the accompanying drawings and detailed description, wherein like reference numerals represent like parts.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
