---
title: Technique to generically manage extensible correlation data
abstract: A technique to generically manage extensible correlation data is provided for correlating a series of events. The technique employs a global unique identifier (GUID) for identifying an event and uses the GUID as a key to associate one or more extensible correlators of correlation data. A transport correlator may be configured to transport the GUID for associating with a GUID of a second event such that a small and fixed amount of data is passed by the communications layer providing the transport, minimally impacting communications. An arbitrary amount of data may be logged and keyed with the GUID, providing optimization and flexibility.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09342431&OS=09342431&RS=09342431
owner: International Business Machines Corporation
number: 09342431
owner_city: Armonk
owner_country: US
publication_date: 20090205
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present invention is a continuation to parent Canada patent application CA 2424006 A1, filed Mar. 28, 2003, entitled \u201cTechnique to Generically Manage Extensible Correlation Data\u201d, priority to which is claimed. The invention relates to computing systems, including distributed computing systems and more particularly to a technique to generically manage extensible correlation data in computing systems.","Computing systems today are often complex, involving many integrated applications executing on one or more computing systems. Yet, when problems occur with such systems, analysis is often hampered by the complex nature of the computing.","Most computing systems such as individual servers in a distributed computing environment are configured, via a logging or other instrumentation service provider, to generate reasonably useful logs of their own activity. Servers further provide tools to assist a system administrator to analyze the server logs for problem determination. Many middleware applications that facilitate communication between other applications also provide a logging service and analysis tools. However, it is common today for a distributed application configuration to include six or more independent servers located on a multitude of physical machines. Correlation of the various error or other event logs from each of the applications, especially those applications on different physical machines, is complex and may not be possible.","Correlation is the process of relating information based on the contents of the information. For example, correlation is used to determine relationships (both implicit and explicit) between instrumentation information captured in instrumentation artefacts generated by an instrumentation service. Such artefacts may comprise trace records, log records, and messages generated by a computer system.","How correlated events are related to one another may be determined by the type of correlation. Associative correlation is used to group events that are related to one another, such as a set of events describing the processing of a specific request.","Associative correlation is typically performed using one of two methods: a) A unique ID is created that is used by all related events; or b) Each event is assigned a unique ID and information is provided which relates the IDs associated with related events.","Sequential correlation is used to order events sequentially, in the order in which the events occurred to indicate flow. Sequential correlation can be used to order log and trace records created by a product or show the order in which events occurred between several products.","Sequential correlation may be implemented in a number of different ways. In many products, the sequence of events may be implicitly defined by the order of the events in a log. In other products, a timestamp is used to sequence the events. However, event order in a log may be misleading and a timestamp may not be sufficiently granular. Neither method addresses products which use distributed logs on two or more distributed computers having clocks out of synchronization.","Environmental correlation is a special type of associative correlation, in that an association is drawn between an event and the environment (e.g. execution environment) that created the event.","The scope of correlation defines the range of events to be correlated.","There are two general scopes of correlation, intra-log correlation (the relating of events within a log) and inter-log correlation (the relating of events within separate logs).","Correlation is typically performed by using information contained in the event logs to determine relationships between the events.","Deterministic correlation creates relationships between events by using explicit correlation information contained in each event to determine the relationships within the data.","Correlating data using explicit data correlation is usually reliable, limited only by the type of correlation (associative, sequential, environmental) provided by the data correlators used. Deterministic correlation can only be performed for those software products (e.g. applications) that capture the explicit correlation information (correlators) in their event information. With few exceptions, today's products do not include correlation information in their data and must be modified (re-instrumented) to add the correlator information to their existing log and trace information. In other words, deterministic correlation cannot be used for all products in a computing solution until each of the products has been modified to provide explicit correlation information.","Deterministic correlation between products requires the products to exchange correlator information which is then captured in the events created by the products. Therefore, not only must each product be re-instrumented to capture the correlator information in their events, but the products must also be modified to exchange correlator information with other products. Often, there are performance impacts involved in exchanging correlation information during runtime, requiring coordinated usage models between the products. Adding correlation information to a product to product communication may adversely impact performance when that added information is too large or of unfixed size.","Some products recognise the need for correlators between events that occur within the same or on separate servers in a distributed application environment. For example, one product, Tivoli\u00ae ARM (application response measurement) measures service response levels for transactions in a distributed environment. Tivoli is a registered trademark of International Business Machines Corporation. ARM employs transaction correlators to provide a capability to break down a transaction into its component parts, so that the contribution of each part to the total response time can be analyzed.","In accordance with ARM, each application responsible for a component of the overall transaction to be measured is modified to include calls to ARM via an application programming interface (API). The calls may request correlators for transactions with one or more child transactions (i.e. a transaction invoked in response to the requesting or parent transaction), send the assigned correlators to the child transaction(s) along with the data needed to invoke (i.e. cause the occurrence of) the child transaction(s) and pass correlators received from parent transactions to the ARM measurement agents.","ARM measurement agents follow conventions when creating correlators in accordance with a defined format. Included within the correlator is environment information identifying the computer, the transaction class, the transaction instance, and some flags. The ARM correlator format is somewhat flexible and extendible; however, the correlator and the framework for handling it are specific to the needs of the ARM service. The size of the ARM correlator may adversely impact performance in some scenarios. That is, it is not a generic correlator per se for use by one or more varied service applications. Moreover, ARM correlators provide identification only to the level of a transaction instance.","A solution to some or all of these limitations or problems is therefore desired.","A technique to generically manage extensible correlation data is provided for correlating a series of events. The technique employs a global unique identifier (GUID) for identifying an event and uses the GUID as a key to associate one or more extensible correlators of correlation data. A transport correlator may be configured to transport the GUID for associating with a GUID of a second event such that a small and fixed amount of data is passed by the communications layer providing the transport, minimally impacting communications. An arbitrary amount of data may be logged and keyed with the GUID, providing optimization and flexibility.","An embodiment of the invention, computer system , is illustrated in . Computer system , which is illustrated for exemplary purposes as a single computing device, is adapted to communicate with other computing devices (not shown) using network . As will be appreciated by those of ordinary skill in the art, network  may be embodied using conventional networking technologies and may include one or more of the following: local networks, wide area networks, intranets, the Internet, and the like.","Through the description herein, an embodiment of the invention is illustrated with aspects of the invention embodied solely on computer system . As will be appreciated by those of ordinary skill in the art, aspects of the invention may be distributed among one or more networked computing devices which interact with computer system , using one or more networks such as, for example network . However, for ease of understanding, aspects of the invention have been embodied in a single computing device\u2014computer system .","Computing device  typically includes a processing system  which is enabled to communicate with the network , various input devices , and output devices . Input devices , (a keyboard and a mouse are shown) may also include a scanner, an imaging system (e.g., a camera, etc.), or the like. Similarly, output devices  (only a display is illustrated) may also include printers and the like. Additionally, combination input\/output (I\/O) devices may also be in communication with processing system . Examples of conventional I\/O devices (not shown in ) include removable recordable media (e.g., floppy disk drives, tape drives, CD-ROM drives, DVD-RW drives, etc.), touch screen displays, and the like.","Exemplary processing system  is illustrated in greater detail in . As illustrated, processing system  includes a number of components: a plurality of central processing units (CPUs) A, B, . . . , collectively ; memory ; network interface (I\/F) ; and input-output (I\/O) interface . Communication between various components of the processing system  may be facilitated via a suitable communications bus  as required.","Each CPU  is a processing unit, such as an Intel Pentium\u2122, IBM PowerPC\u2122, Sun Microsystems UltraSparc\u2122 processor, or the like, suitable for the operations described herein. As will be appreciated by those of ordinary skill in the art, other embodiments of processing system  could use alternative CPUs and may include embodiments in which one CPU is employed (not shown). CPUs  may include various support circuits to enable communication between CPUs  and the other components of processing system .","Memory  includes both volatile memory  and persistent memory  for the storage of: operational instructions for execution by CPUs ; data registers; application and thread storage; and the like. Memory  preferably includes a combination of random access memory (RAM), read only memory (ROM), and persistent memory such as that provided by a hard disk drive.","Network I\/F  enables communication between other computing devices (not shown) and other network computing devices via network . Network I\/F  may be embodied in one or more conventional communication devices. Examples of a conventional communication device include: an Ethernet card; a token ring card; a modem, or the like. Network I\/F  may also enable the retrieval or transmission of instructions for execution by CPUs , from or to a remote storage media or device via network .","I\/O interface  enables communication between processing system  and the various I\/O devices  and . I\/O interface  may include, for example a video card for interfacing with an external display such as output device . Additionally, I\/O interface  may enable communication between processing system  and a removable media device . Removable media  may comprise a conventional diskette or other removable memory devices such as Zip\u2122 drives, flash cards, CD-ROMs, static memory devices, and the like. Removable media  may be used to provide instructions for execution by CPUs  or as a removable data storage device.","The computer instructions\/applications stored in memory  and executed by CPUs  (thus adapting the operation of computer system  as described herein) are illustrated in functional block form in . As will be appreciated by those of ordinary skill in the art, the discrimination between aspects of the applications illustrated as functional blocks in , is somewhat arbitrary in that the various operations attributed to a particular application as described herein may, in an alternative embodiment, be subsumed by another application.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 3","FIG. 3"],"b":["300","100","100","100","100","204","204","100","100","204","304","304","304","306"]},"As is understood to persons skilled in the art, one manner of incorporating a service such as a logging provider into an application is to include invocations of the provider service via an API at selected points in the application code that define an event of interest to be logged by the logging provider. In a distributed computing environment, particular events of interest are those involving communications, via middleware or other transport mechanisms, between the application (e.g. client) executing on one machine and another process (e.g. server) running on second machine located remotely from the first machine. These events of interest often require correlation.","Parent's API  interfaces with a correlator service (CS)  in accordance with the invention using a parent correlator  and stores events to an event log . Correlator service  uses a globally unique correlator (GUC) generation mechanism  to obtain a GUC for events and stores GUCs and other event data as will become apparent to a GUC log . Product (parent)  communicates with a product (child) A via middleware  over a transport . Product (child) A is referred to as a \u201cchild\u201d as it responds to an exemplary transaction initiated by product (parent)  as described further herein below with reference to . As such, instrumentation API A is referred to as a child's API A and its correlator is a child correlator A.","Middleware  is adapted with a middleware transport adapter . Though only a single middleware is shown, it is understood that if computer system  or A communicates via more than one type of middleware (e.g. SOAP over HTTP, ORB and RMI-IIOP, JDBC etc.) a middleware adapter for each type is provided. Transport  provides, through interaction with an operating system and network I\/F  () suitable communication protocols to enable communication with other networked computing devices via network  (). Transport may include one or more of such protocols such as TCP\/IP, Ethernet, token ring and the like and higher layer protocols such as hyper text transfer protocol, (HTTP).","Though not shown, memory , A stores an operating system (OS) and other support software for product (parent) , product (child) A, such as an application server as may be necessary.","The OS stored by memory , A is an operating system suitable for operation with selected CPUs  and the operations described herein. Multi-tasking, multi-threaded OSes such as, for example IBM AIX\u2122, Microsoft Windows, Linux, or the like, are expected to be preferred in many embodiments. Depending on the OS, different execution environments may be configured for system , A (note that OS for system  need not be the same OS employed for system A). Correlation in accordance with the invention may be adapted to a variety of execution environments such as the following:","A thread of execution, such as a UNIX pthread. Threads represent the lowest dispatchable environment within a system.","A system process, such as a UNIX process. Processes represent a set of related threads, all of which share the same set of system resources.","A system, which is the environment in which the processes execute. A simple system is a single machine, but complex systems, such as a system with multiple virtual systems, or a system cluster, are possible and within the cope of the present invention. In the most general sense, a system is: the combination of one or more of the following:","A virtual execution environment, such as a VMWARE\u2122 virtual system or an OS\/390\u2122 LPAR (logical partition);","A physical execution environment, e.g. an actual server machine, which may contain multiple virtual execution environments; and","A cluster, which is a group of virtual or physical execution environments into a single collaborative execution environment.","As described further herein below, the respective correlator service , A, GUC generation mechanism , A GUC log , A, instrumentation APIs , A and middleware transport adapters , A for each particular application , A provide a technique for generically managing extensible correlation data. Correlator service  A may be invoked to generate, store and provide a correlator for a particular event of a product, such as products , A or provide such a correlator for transport. Instrumentation via the APIs , A may use the correlator locally, for example, as a part of a log entry for the application. The correlator may be transported via adapted middleware to another component, for example, from product (parent)  to product (child) A, of the distributed computing system for association with another event by the correlator service local to the other component.","When middleware transport adapter , A receives an inbound transport communication including a correlator, the correlator is removed and passed to the respective CS with which the middleware transport is coupled in order that the CS may associate the inbound parent correlator with a correlator generated by the CS service. This parent correlator is linked to a correlator for an event generated by the CS Service in response to an invocation by an instrumentation API on the computer system receiving the correlator. This basic mechanism provides a framework for arbitrary applications and systems to create and communicate correlators in a distributed computing environment.","In addition to providing a service for generating and transporting correlators in a distributed computing environment, the present invention provides a generic correlator for identifying events in such an environment. Advantageously, the correlator provides correlation information that identifies a specific instrumentation call in a time sequence, even if the system clocks of one or more machines on the path of a unit of work or transaction are out of synchronization. Further, the correlation information is sufficiently granular enough to be able to uniquely distinguish between two consecutive instrumentation calls with identical clock granularity (e.g. msec).","In a high transaction environment, it is highly desired and important for performance considerations to minimize the amount of data transferred via the transport between two product instances. Accordingly, the invention provides a correlator that comprises three components, namely, a transport correlator (TransportCorrelator), a local correlator (LocalCorrelator) and a log record correlator (LogRecordCorrelator).","TransportCorrelator comprises information that is transported via transport  and therefore comprises a minimal amount of data required to uniquely identify a unit of work (event) to minimize performance impact or system operation. In accordance with an embodiment of the invention, TransportCorrelator chiefly comprises two components, a Globally Unique Correlator, a globally unique identifier (GUID) for the event and sequencing counters as described further below.","GUC, in an exemplary embodiment, additionally comprises a GUID length and a flag indicating a version number of the GUID generation algorithm and a type of the GUID. Table 1 shows an exemplary GUC:",{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"GUC"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["GUID_Length",{},{}]},{"entry":["Bytes","GUID_type","Description of GUID_data"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["16","\u201c0\u201d","GUID_data:"]},{"entry":[{},{},"MAC address\/systemID;"]},{"entry":[{},{},"timestamp;"]},{"entry":[{},{},"processID;"]},{"entry":[{},{},"random counter;"]},{"entry":[{},{},"May be hashed to 16 (GUID_Length)"]},{"entry":[{},{},"bytes through a message digest algorithm"]},{"entry":[{},{},"such as MD5 to guarantee uniqueness"]},{"entry":[{},{},"and security across the entire network"]},{"entry":[{},{},"service by the correlator service."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"To sequentially order events from the same instrumentation, correlator service employs a process calling sequence counter and a thread calling sequence counter. Process calling sequence counter (ProcessCallingSequenceCounter) is a sequence counter at the process level for instrumentation serving this process to assist in ordering the events, for example, when clocks on different machines in the distributed computing environment are out of synchronization or when clock granularity is insufficient. This counter is incremented for each instrumentation call that occurs on any thread. If this counter rolls over and two ProcessCallingSequenceCounter values are identical within the same process, the timestamp and the order of arrival may be used for sequencing.","The thread calling sequence counter (ThreadCallingSequenceCounter) is a sequence counter at the thread level of a particular instrumentation to assist in ordering the events, for example, when clock granularity is insufficient. Also it permits the identification of the reuse of a particular thread within a process, for example, when the counter is reset to zero. This counter is incremented for each instrumentation call that occurs on a particular thread. If this counter rolls over and two ThreadCallingSequenceCounter values are identical within the same process and thread, the timestamp and the order of arrival may be used for sequencing.","To support extensibility, TransportCorrelator may include a transport correlator length, a format identifier or other flags, and a GUC length. In a further option, an additional correlator length and an additional correlator data to hold any product specific correlator data may be included.","The data that TransportCorrelator carries often needs to be updated from hop to hop (i.e. as the processing of a transaction progresses through various applications and computer systems). Each product may increase the size of the TransportCorrelator by adding their correlator data (e.g. in a name\/pair value format). Accordingly a level of consistency across all applications and middlewares is maintained.","LocalCorrelator includes data such as execution environment information useful for correlation but which does not need to be transported with each event. The amount of information to include in LocalCorrelator may depend on the deterministic correlation granularity desired, for example, thread level.","LocalCorrelator comprises a GUC and optional execution environment information such as:","id\u2014A property used to identify instances of this class.","hostID\u2014This property represents the name or address of the system that has generated the artefact. Examples of the content of this property are IP address, VTAM LU, or the names of the host machine from which the artefact was originated.","hostIDFormat\u2014A heuristic is defined to create the hostID to attempt to always generate the same ID, independent of discovery protocol. hostIDFormat property identifies how the hostID is generated, using a heuristic. It assumes that the documented rules are traversed in order to determine and assign a hostID.","processID\u2014This property identifies the processID of the \u201crunning\u201d component or subcomponent that generated the artefact.","threadID\u2014This property identifies the threadID of the component or subcomponent indicated by the process ID that generated the artifact. A running process may spawn one or more threads to carry its function and\/or incoming requests. The threadID will change accordingly.","creationTime\u2014The time (e.g. timestamp) when the artefact was created.","artifactEncodingFormat\u2014This property identifies the artifact encoding format (e.g. UTF-8, UTF-16, and UTF-32).","artifactCreatorID\u2014This property is the identity of the component or subcomponent that created this artefact. The creator can be one of the various parts of a product, or OS resource (e.g., a module name).","uniqueInstanceID\u2014The unique ID (JVM scope or C\/C++ scope) for each instance of this class.","LocalCorrelator may be associated with a TransportCorrelator via its GUC. LocalCorrelator may be stored locally in a file (e.g., GUC log  or event log ).","LogRecordCorrelator comprises two TransportCorrelators, namely a parent and a child TransportCorrelator. The parent TransportCorrelator is the TransportCorrelator that was received or imported into the local computer system (i.e., the remote TransportCorrelator) and the child TransportCorrelator is the current TransportCorrelator that is generated locally on the local computing system (i.e., the local TransportCorrelator).","LogRecordCorrelator is not transported but is returned to the instrumentation and logging mechanism by correlator service  to be logged into a file (e.g. Event log ) as an instrumentation artefact for deterministic correlation purposes. The LogRecordCorrelator may be prepended to any instrumentation log entry to provide end to end correlation.","Persons of ordinary skill in the art will appreciate that the various correlators and GUC may be implemented in a variety of manners including as data objects with associated methods for manipulating the objects, for example, setting and getting various data as described.","Correlator service , as described above, is responsible to create and maintain correlators for any instrumentation calls on a particular process of product , A. Correlator service , A creates LogRecordCorrelator, updates its content and returns the correlator to the instrumentation (Parent's API , Child's API A). To provide this type of functionality, correlator service , A provides a programming model in accordance with the following requirements.","For the GUC, correlator service , A provides a mechanism for GUC insertion, query, removal, comparison and for updating each of the thread and process calling sequence counters.","For the correlator, correlator Service , A provides a mechanism to create, update, suspend, resume, associate (parent\/child), destroy and stream. The following description details these operations.","The create service is a request to obtain a correlator. This service may tie into different \u201cFactories\u201d for different correlator types. Update provides methods to update the properties of a correlator that are permitted to be updated. Suspend temporarily suspends a correlator in use so another type of correlator can be started\/requested while resume resumes a temporarily suspended correlator so the resumed correlator type can be started\/requested. Associate (Parent\/Child) associates an inbound parent correlator to the current or child correlator. Destroy discards a previously created correlator. Stream provides the transport (wire) definition of the correlator, in other words, streaming of a correlator object (to binary) for transmission across different protocols (RMI, JMS, SOAP over HTTP, . . . ) and rebuilding the correlator object at destination. Stream can also be used to obtain a format for persistent storage of a correlator.","In accordance with an embodiment of the invention, correlator service provides the methods described in Table 2.",{"@attributes":{"id":"p-0080","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Correlator Service Methods"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CorrelatorService( )"]},{"entry":["CorrelatorService","Default constructor."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["byte[ ]","getCorrelatorStream( threadID,"]},{"entry":[{},"ProblemTokenArtifact[ ] properties)"]},{"entry":[{},"Streams the Transport correlator into a"]},{"entry":[{},"byte stream for the middleware to flow on an"]},{"entry":[{},"outbound call. The properties parameter"]},{"entry":[{},"allows performing different type of streaming."]},{"entry":["byte[ ]","getCorrelatorStream(ProblemTokenArtifact[ ]"]},{"entry":[{},"properties)"]},{"entry":[{},"Streams the Transport correlator into a"]},{"entry":[{},"byte stream for the middleware to flow on an"]},{"entry":[{},"outbound call. The properties parameter"]},{"entry":[{},"allows performing different type of streaming."]},{"entry":["LogRecordCorrelator","pullCorrelator(threadID)"]},{"entry":[{},"Pulls the most recent"]},{"entry":[{},"LogRecordCorrelator from the Correlator"]},{"entry":[{},"Service correlation table and increments both"]},{"entry":[{},"counters."]},{"entry":["LogRecordCorrelator","pullCorrelator( )"]},{"entry":[{},"Pulls the most recent LogRecord"]},{"entry":[{},"Correlator from the Correlator Service"]},{"entry":[{},"correlation table and increments both"]},{"entry":[{},"counters."]},{"entry":["LogRecordCorrelator","pushCorrelator(threadID,"]},{"entry":[{},"LocalCorrelator correlatorData)"]},{"entry":[{},"Pushes the Application local correlator"]},{"entry":[{},"into the Correlator Service correlation table"]},{"entry":[{},"and returns the associated"]},{"entry":[{},"LogRecordCorrelator. The LocalCorrelator"]},{"entry":[{},"class needs to provide a toXML( ) method to"]},{"entry":[{},"stream the object, store the XML string into the"]},{"entry":[{},"GUID.log or Event.log file."]},{"entry":["GUC","getGloballyUniqueCorrelator(GUC_type)"]},{"entry":[{},"Returns a new GUC to the caller based"]},{"entry":[{},"on the GUC type."]},{"entry":["LogRecordCorrelator","pushCorrelator(threadID,"]},{"entry":[{},"LogRecordCorrelator correlator)"]},{"entry":[{},"Updates the LogRecordCorrelator"]},{"entry":[{},"counters into the Correlator Service correlation"]},{"entry":[{},"table and returns the associated"]},{"entry":[{},"LogRecordCorrelator."]},{"entry":["LogRecordCorrelator","pushCorrelator(LogRecordCorrelator correlator)"]},{"entry":[{},"Updates the LogRecordCorrelator"]},{"entry":[{},"counters into the Correlator Service correlation"]},{"entry":[{},"table and returns the associated"]},{"entry":[{},"LogRecordCorrelator."]},{"entry":["int","associateRemoteCorrelator(threadID,"]},{"entry":[{},"byte[ ] correlator)"]},{"entry":[{},"Associates the parent correlator for the"]},{"entry":[{},"affected LogRecordCorrelator(s) when an"]},{"entry":[{},"inbound middleware call is received."]},{"entry":["int","associateRemoteCorrelator("]},{"entry":[{},"byte[ ] correlator)"]},{"entry":[{},"Associates the parent correlator for the"]},{"entry":[{},"affected LogRecordCorrelator(s) when an"]},{"entry":[{},"inbound middleware call is received."]},{"entry":["Int","start( )"]},{"entry":[{},"Starts the Correlator Service class."]},{"entry":["Int","stop( )"]},{"entry":[{},"Stops the Correlator Service class."]},{"entry":["Long","incrementProcessCallSeqCtr( )"]},{"entry":[{},"Increments the"]},{"entry":[{},"ProcessCallingSequenceCounter and returns"]},{"entry":[{},"the updated value. It is called when a"]},{"entry":[{},"LocalCorrelator is created on a thread and"]},{"entry":[{},"every time an instrumentation call occurs on"]},{"entry":[{},"any thread within the process. The return"]},{"entry":[{},"value will be the value stored in the"]},{"entry":[{},"TransportCorrelator. For GUC that do not have"]},{"entry":[{},"a counter, this value may just be incremented"]},{"entry":[{},"but will not be put on the wire"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"With reference to , there is illustrated the assignment of process and thread sequence counters to exemplary event occurrences for, respectively, a single provider instrumented on a multi-threaded process, multiple providers instrumented on a single threaded process and multiple providers instrumented on a multi-threaded process. For the purposes of simplification,  illustrate at most two threads and two providers but it is understood that additional threads or providers are contemplated by the invention.","With reference to  there is illustrated an event line for each of two threads TH and TH of process ProcA instrumented by single instrumentation provider, Prov. The process calling sequence counter is represented by counter Proc# counting each of the nine sample events. The respective thread calling sequence counters TH# and TH# assign respective counts to the events that occur on the respective threads. Collectively, the nine events produce the following process sequence count and thread sequence count pairs (Proc#, THn#): (1,1) (2,1) (3,2) (4,2) (5,3) (6,3) (7,4) (8,4) and (9,5). As understood to persons skilled in the art, the assignment of a unique count to a process sequence counter, for example, of a correlator may be accomplished through well known steps to lock access to the counter supplying the count.","With reference to  there is illustrated an event line for each of two instrumentation providers Prov and Prov instrumented on one thread TH of a process ProcB. It is noted that for the same nine sample events as depicted in , the process sequence count and thread sequence count pairs are the same. With reference to  there is shown an event line for each of two providers Prov and Prov instrumented on two threads TH and TH of process ProcA to illustrate a further example of the assignment of a temporal identifier.","Thus the process calling sequence counter and thread calling sequence counter assign unique sequencing identifiers to event occurrences generally identified by the GUC and optionally other geographic and logical identifiers within the generic correlator structure. The counters provide temporal granularity independent of a time stamp or other system clock reference.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":["FIGS. 5A, 5B, 5C and 5D","FIG. 3","FIG. 5A"],"b":["204","100","306","304","304","306","100","306","312","312","314"],"sub":["P ","P "]},"CS  logs the GUC, ID, and its associated LocalCorrelator Cin the GUC log  or event log  (not shown) indexed by GUC (i.e. ID).","CS creates a LogRecordCorrelator (LR) which creates the current or child TransportCorrelator (ID+#) and returns the LogRecordCorrelator (LR=ID+#) to the parent's API call. As this exemplary call initiates a transaction, it has no parent call from another product and no parent TransportCorrelator exists for associating in the LogRecordCorrelator LR. The TransportCorrelator ID+# is considered a child TransportCorrelator when viewed in relation to the role of system  in the transaction since system  generated it. CS  increments the process and thread calling sequence counter fields before returning the LogRecordCorrelator holding the GUC and counters. Similar artefacts are shown in memory A of computer system A for a prior event of product (child) which persons of ordinary skill in the art will understand were generated in a like manner.",{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 5B","b":["30","304","304"]},"Middleware  intercepts the outbound call and then calls middleware transport adapter  which calls getCorrelatorStream of CS  to get the TransportCorrelator (ID+#) associated with this execution thread. CS  returns the most recent TransportCorrelator associated with this execution thread to middleware transport adapter . Middleware transport adapter  then puts the TransportCorrelator on the transport wire .",{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 5C","sub":["P","C","P","P","P","C","P","C"],"b":["100","322","320","312","312"]},"Middleware Transport A then calls the product (child) application method associated with the inbound request.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 5D","b":["304","318","306","306","312"]},"CS  retrieves the current LogRecordCorrelator (LR=ID+#, ID+#) now containing the associated parent TransportCorrelator. and returns it with incremented counters to the child's API A call. CS  then resets the parent TransportCorrelator information from its internal copy of the LogRecordCorrelator.","Child's API A then calls its current recording mechanism (not shown) to store LogRecordCorrelator (LR=ID+#, ID+#) and the event data (A) for the instrumentation for later analysis to event log A. The GUCs generated by each system may be used to associate events between logs as well as within logs. The sequence counters may be used within logs to put events in sequence.","A tool may be configured to interpret GUC logs and event logs from networked computer systems among which correlators in accordance with the invention are employed to correlate events. Such correlated events may then be used for various purposes, for example, such as tracing, performance analysis or problem determination. A correlation tool (CT) (not shown) may be configured to perform the following exemplary operations to correlate events, in accordance with an aspect of the invention.","Assuming that the GUC log (, A) data has been logged in the respective event log file (, A) on each computer system to be correlated, CT opens an event log file on a machine (eg. A). It reads two types of log records: the records holding LocalCorrelator (i.e. GUC log data) as well as the records holding the LogRecordCorrelator (event log data). Next CT associates all the child TransportCorrelator GUCs with their corresponding LocalCorrelators.","CT then attempts to associate the parent TransportCorrelator GUCs with their corresponding LocalCorrelator. If CT can't associate the parent TransportCorrelator GUC with its corresponding LocalCorrelator, it opens another event log file on another machine (e.g. ) and performs the steps again.","CT performs the steps until it has processed all the event log files from its known network topology. Once it has found the parent TransportCorrelator GUC on a machine, CT will then find the corresponding LogRecordCorrelator that has a child TransportCorrelator equal to the parent TransportCorrelator and associate them. Then, CT can create correlated views of the events and event data (A) at different granularities based on the GUC and LocalCorrelator contents.","The invention provides associative correlation by assigning a unique ID to a group of events (typically the events related the processing of a request by a specific product). The unique ID is unique in space and time to provide robust correlation. Each event record in an instrumentation log contains information that identifies the ID defined for the event (typically the ID is contained in each log or trace record in the group). Different groups of events (e.g. the events associated with processing a request by several products) are then combined by providing additional information that associates the IDs for each group with one another. Sequential correlation is performed by adding event sequencing information to the unique ID, creating a correlator that provides both associative and sequential correlation.","The unique ID acts as a key for associating different correlation information for an event. Moreover, it is adapted to minimally impact performance when communicated between products and when logged. By exchanging only the unique ID, runtime performance is enhanced.","A Globally Unique Correlator (GUC) may be defined for the GUID and optional sequence information and is described herein as an open structure, meaning an implementation can use any data structure that provides the appropriate associative and sequential correlation properties. An exemplary GUC implementation, although described for use in problem determination, is meant to be a general purpose correlator that can be used to correlate events for any purpose.","The embodiment(s) of the invention described above is(are) intended to be exemplary only. The scope of the invention is therefore intended to be limited solely by the scope of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Further features and advantages of the present invention will become apparent from the following detailed description, taken in combination with the appended drawings, in which:",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 4A, 4B and 4C"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIGS. 5A, 5B, 5C and 5D","FIG. 3"]}]},"DETDESC":[{},{}]}
