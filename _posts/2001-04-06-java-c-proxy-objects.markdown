---
title: Java C++ proxy objects
abstract: A system and method for enabling the efficient accessing of Java objects and methods by legacy GUIs is disclosed. The system and method provide a base proxy object that encapsulates the JNI APIs necessary for calling Java methods across the JNI boundary. Legacy proxy objects proxy the Java objects and enable legacy GUIs to issue method requests as if the legacy proxy objects were fully functional objects. The legacy proxy objects receive method requests from the GUIs and call base proxy object methods that in turn make the necessary JNI API calls to call Java methods.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06915520&OS=06915520&RS=06915520
owner: Hewlett-Packard Development Company, L.P.
number: 06915520
owner_city: Houston
owner_country: US
publication_date: 20010406
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The invention relates to programming language interactions, and more specifically to legacy C++ GUI interactions with a Java environment.","In many software systems today, the existing or legacy graphical user interfaces (\u201cGUIs\u201d) are coded in C++ code. Over the past few years, however, Java\u00ae has become the programming language of choice. In order to use Java for providing the functionality of a system, the C++ GUIs must be made useable with Java. One alternative is to rewrite all of the lines of C++ code in Java. Rewriting the C++ code may comprise rewriting many lines of code. In many situations this is impractical. Furthermore, in many situations, it is desirable, practical, and cost-effective to maintain the C++ GUIs, instead of replacing them, and to use them to interface Java objects and methods of the Java functional code.","Accordingly, another alternative is to enable the C++ GUIs to make calls directly to the Java objects and methods in a Java Virtual Machine (\u201cJVM\u201d) in the Java environment. The Java objects and methods control the functions of the computer systems. In order for the C++ GUIs to make calls directly to the Java objects and methods in the JVM, the C++ GUIs must make Java Native Interface (\u201cJNI\u201d) Application Programming Interface (\u201cAPI\u201d) calls across the Java to legacy boundary, as conceptually shown in FIG. . Likewise, Java data types must be converted to C++ data type, and vice-versa.","A solution to this requirement comprises coding JNI APIs and data type conversions into each of the C++ GUIs as required. This is disadvantageous because it litters or clutters the legacy C++ GUIs with the JNI API and data type conversion coding, bloating the size of the C++ GUIs and causing future maintenance problems. Moreover, many of the JNI APIs are repetitious among the C++ GUIs. Therefore, coding the JNI APIs into each of the C++ GUIs is inefficient. Additionally, when the C++ code is converted to Java, the JNI APIs must be deleted, as they will be unnecessary when the former C++ GUIs are on the Java side of the JNI.","The present invention comprises a system and method for enabling the efficient accessing of Java objects and methods by legacy C++ GUIs. A base proxy object according to the present invention encapsulates the JNI APIs necessary for calling the Java methods in order to manipulate the Java objects. The base proxy object also comprises the necessary mapping mechanism for converting Java data types to C++ data types, and vice-versa. The JNI APIs and mapping mechanism are contained in general functions coded into the base proxy object.","A method of efficiently accessing Java objects, classes and methods by legacy C++ GUIs according to the present invention comprises a C++ GUI obtaining a Java object, the base proxy object creating a C++ object that proxies the Java object, the C++ GUI executing a callback that sends a request, via the C++ proxy object, to the base proxy object. The request comprises the Java object name, a class name, a method name, a C++ data type and, if setting a Java attribute, data of the C++ data type. The base proxy object processes the request and makes the necessary JNI API calls to pass it to the JVM. The base proxy object obtains the Java method ID, calls the Java object, class and method, and gets or sets the Java attribute. If the callback gets an attribute, the base proxy object converts the retrieved Java attribute from the Java data type to the C++ data type and sends the converted attribute to the C++ proxy object. If the callback sets an attribute, the base proxy object converts the data from the C++ data type to the Java data type prior to sending the data through the JNI layer.","The present invention may be used with computer systems that utilize C++ graphical user interfaces (\u201cGUIs\u201d) to access Java objects across a Java Native Interface (\u201cJNI\u201d).  illustrates a computer network system with which the present invention may be used. The network system  comprises a ServiceControl Manager (\u201cSCM\u201d)  running on a Central Management Server (\u201cCMS\u201d)  and one or more nodes  managed by the SCM  on the CMS . Together the one or more nodes  managed by the SCM  make up a SCM cluster . A group of nodes  may be organized as a node group .","The CMS  preferably is an HP-UX 11.x server running the SCM  software. The CMS  includes a memory (not shown), a secondary storage device, a processor, an input device (not shown), a display device (not shown), and an output device (not shown). The memory, a computer readable medium, may include, RAM or similar types of memory, and it may store one or more applications for execution by processor, including the SCM  software. The secondary storage device, a computer readable medium, may include a hard disk drive, floppy disk drive, CD-ROM drive, or other types of non-volatile data storage. The processor executes the SCM  software and other application(s), which are stored in memory or secondary storage, or received from the Internet or other network , in order to provide the functions and perform the methods described in this specification, and the processing may be implemented in software, such as software modules, for execution by the CMS  and modes . The SCM  is preferably programmed in Java\u00ae and operates in a Java(& environment that is preferably accessed by using legacy C++ GUIs and the present invention. See HP\u00ae part number: B8339-90019, available from Hewlett-Packard Company, Palo Alto, Calif., which is hereby incorporated by reference, for a more detailed description of the SCM . The HP\u00ae part number: B8339-90019 is also accessible at http:\/\/www.software.hp.com\/products\/scmgr.","Generally, the SCM  supports managing a single SCM cluster  from a single CMS . All tasks performed on the SCM cluster  are initiated on the CMS  either directly or remotely, for example, by reaching the CMS  via a web connection . Therefore, a workstation  at which a user sits only needs a web connection  over a network  to the CMS  in order to perform tasks on the SCM cluster . The workstation  preferably comprises a display, a memory, a processor, a secondary storage, an input device and an output device. In addition to the SCM  software and the HP-UX server described above, the CMS  preferably also comprises a data repository  for the SCM cluster , a web server  that allows web access to the SCM  and a depot  comprising products used in the configuring of nodes, and a I\/UX server .","The nodes  are preferably HP-UX servers or other servers. The nodes  may be referred to as \u201cmanaged nodes\u201d or simply as \u201cnodes\u201d. Conceptually, the node  represents a single instance of HP-UX running on some hardware. The node  may comprise a memory, a secondary storage device, a processor, an input device, a display device, and an output device.","Although the CMS  is depicted with various components, one skilled in the art will appreciate that the CMS  may contain additional or different components. In addition, although aspects of an implementation consistent with the present invention are described as being stored in memory, one skilled in the art will appreciate that these aspects can also be stored on or read from other types of computer program products or computer-readable media, such as secondary storage devices, including hard disks, floppy disks, or CD-ROM; a carrier wave from the Internet or other network; or other forms of RAM or ROM. The computer-readable media may include instructions for controlling the CMS  (and\/or the nodes ) to perform a particular method, such as those described herein.","Java objects operating in a JVM provide the functionality of the SCM . In the system , when a user, through a C++ GUI, wants to access the functionality of the SCM  (e.g., to create, retrieve, save, delete or modify persistent data (e.g., in the data repository ) of the Java objects or to run a tool on a node(s) or node group(s)), the C++ GUI executes a callback that causes a particular Java class to be instantiated, thus creating a particular Java object and a C++ object, that proxies the Java object. Java classes are meta-definitions that define the structure of a Java object. Java classes when instantiated create instances of the Java classes and are then considered Java objects. Methods within Java objects are used to get or set attributes of the Java object and to change the state of the Java object. Consequently, the C++ GUI may subsequently execute callbacks that execute methods on the proxy C++ object and that are processed by a base proxy object of the present invention to run the methods of the Java object to get or set attributes of the Java object, thereby creating, retrieving, saving, deleting or modifying data in the persistent store or running a tool on a node(s) or node group(s).","Some of the objects and classes discussed herein are named with a prefix \u201cmx\u201d. The mx prefix is indicative of the application utilizing the objects and classes (e.g., the SCM ) and is merely exemplary. Indeed, the names of classes, objects and methods discussed herein are exemplary, are not intended to be limiting, and are merely used for ease of discussion.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 3","FIG. 3"],"b":["40","42","48","40","12","14","40","42","43","44","46","48","50"]},"The C++ proxy objects  proxy the Java objects  and each C++ proxy object  is created when a C++ GUI  obtains a Java object , as described below. Accordingly, each C++ proxy object  includes methods that correspond to the methods of the Java object  that the C++ proxy object  proxies. The C++ proxy objects  also maintain names of the Java objects  that they proxy, identifying the Java classes that need to be instantiated to create instances of the Java objects . As is discussed below, when the C++ GUI  sends a request to a C++ proxy object  (i.e., executes a callback that executes a method on the C++ proxy object ), the C++ proxy object  passes the method name, corresponding to the Java object  method name to the base proxy object . Each instance of a C++ proxy object , and the Java object  that the C++ proxy object  proxies, will exist for the duration of execution of the C++ GUI  that obtained the Java object .","Referring again to , the base proxy object  hides the mechanics of using the JNI from C++ consumers (GUIs ) of Java objects. By hiding these mechanics, the base proxy object  makes it appear to C++ GUIs  that the C++ GUIs  are interacting with and manipulating fully functional C++ objects  when the C++ GUIs  execute callbacks to get or set attributes of the Java objects  that the C++ objects  proxy.","The base proxy object  is a base C++ class that provides a basic mapping mechanism. The C++ proxy objects  are sub-classes of the base proxy object . The base proxy object  preferably caches both Java Class IDs as well as Java Method IDs in order to minimize the number of C++ to Java Virtual Machine (\u201cJVM\u201d) transitions. The base proxy object  preferably uses the C++ Standard Template Library (STL) to implement both the caching and \u201cmethod name (Java) to method ID (Java)\u201d mapping mechanisms.","As described above, a JNI API call is required for a C++ GUI  to access a Java object  across the JNI boundary . The base proxy object  preferably includes the JNI API calls necessary to access Java objects  requested by all of the C++ GUIs . The JNI API calls are coded into general functions (functions and methods are used interchangeably herein with regards to C++ objects) in the base proxy object  that call a Java method to either get or set an attribute of a specific type in the Java object being accessed (for exemplary general functions, see ). Coding the JNI API calls necessary to access Java objects  requested by all of the C++ GUIs  in the base proxy object  collects these JNI API calls in one class, instead of littering or cluttering each C++ GUI  with the JNI API calls necessary for that individual C++ GUI .","Collecting the JNI API calls in the base proxy object  has a number of advantages: for example, since some JNI API calls would otherwise be used by more than one C++ GUIs , collecting them in the base proxy object  prevents unnecessary repetition, allows generalization (e.g., getting a user name is generalized as getting a String with a specific method call) and increases efficiency; and, the C++ GUIs  are kept streamlined, which is especially advantageous if the legacy C++ GUIs  are ever converted to Java. Conversion of the legacy C++ to Java may basically comprise the re-writing of C++ syntax to Java syntax; by keeping the JNI API calls out of the C++ GUIs  and in the base proxy object , the base proxy object  and C++ proxy objects  may simply be removed when the legacy C++ is converted to Java. These and other advantages will become apparent throughout this specification.","Java data types and C++ data types are different. Therefore, when accessing the JVM  through the C++ environment , as illustrated by , it is necessary to map the Java data types to C++ data types. Accordingly, the base proxy object  comprises a mapping between Java data types and C++ data types. The mapping preferably used is shown in the following table:",{"@attributes":{"id":"p-0031","num":"0030"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Java Data Type","C++ Data Type"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"String","String"]},{"entry":[{},"boolean (Bool)","bool"]},{"entry":[{},"long","long long"]},{"entry":[{},"int","long"]},{"entry":[{},"Array of int","vector of long"]},{"entry":[{},"Array of object","vector of proxy object"]},{"entry":[{},"Array of String","vector of string"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":"40"},"Referring back to , the general interaction between the C++ GUIs , C++ proxy objects , the base proxy object  and the Java objects  is shown. Assuming that a C++ proxy object  proxying a Java object  has already been created (as described below), a C++ GUI  executes a callback that in turn executes a method on the C++ proxy object  (corresponding to a method of the proxied Java object ) to get or set an attribute(s) in the proxied Java object . The C++ proxy object  passes control through the GUI callback to the base proxy object  as a method call with arguments including a Java object name, a class name, a method name(s), and the C++ data type of the output the C++ object  is getting or the input the C++ object  is setting. The Java object name, class name and method name(s) passed by the C++ proxy object  to the base proxy object  identify the proxied Java object , the Java class that defines the structure of the proxied Java object , and a method(s) of the Java object  that the C++GUI  needs to access. The base proxy object  processes the method arguments to access the Java object and to call the requested method(s) across the JNI boundary .","In order to call a Java method across the JNI boundary , a method ID for the Java method is required. The method ID is a unique identifier associated with a Java method that is established when the Java class containing the Java method is initialized. The method ID retains its value until the Java class containing the method ID is unloaded. The base proxy object  obtains the method ID across the JNI boundary  using the method name provided by the C++ proxy object. When a C++ proxy object  is first created (as described below) the method IDs and class ID are preferably dynamically obtained as instance data from the Java objects  and cached. When the method is subsequently called, the method ID may be accessed from the cache without having to access the method ID via the JNI, thereby reducing the number of C++ to JVM transitions. The cache may be a method data hash table, wherein the method data comprises the method signature and the method ID.","Accordingly, the base proxy object  preferably processes the method request by identifying the Java object  using the Java object name provided by the C++ proxy object , obtaining the method ID from the cache, and calling the Java object  and Java method(s) via the JNI , using the object name and method ID. If a set function is called, the base proxy object  will pass the input data supplied by the C++ GUI  to the Java object .","If the executed callback specifies a get function (i.e., returning an output from the Java object), the called Java method will return a Java data type output and the base proxy object  will convert the output to the C++ data type specified by the above mapping in Table 1. If the executed callback specifies a set function (i.e., sending input data to the Java object), the base proxy object  will convert the input data from a C++ data type supplied by the callback to the Java data type specified by the above mapping in Table 1 before sending the input data to the Java object .",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 4","FIG. 4"],"i":["a ","a. "],"b":["40","40","40","44","40","43","44"]},"The base proxy object  also comprises base proxy object functions or methods  and the general functions or methods  mentioned above. The parameters of the functions  and  are shown within the parenthesis and the returned data or data type is shown after the colon. The base proxy object functions  include a constructor (init), a copy constructor (MxProxy), and getJavaObject, get ClassName, getJniEnv and getMethodID functions. The constructor is used to initialize the C++ proxy objects and is called by the C++ object constructors called below. The copy constructor is used to copy the C++ proxy objects if the C++ proxy objects are stored in vectors. The getJavaObject function returns the proxied Java object reference from the myJavaObject variable  so that it may be passed to the JVM. The getClassName function is used to return the Java class name from the myJavaClass variable . The getJniEnv function returns the JNI environment pointer returned from a call to ObamGetJNIEnv( ) or an appropriate JNI API call; the current JNI environment pointer is retrieved in order to make a call to the JNI API. The getMethodID provides a protected method for acquiring a method ID from an instantiated class (e.g., the proxied Java class).","The general functions  call a Java method to get or set an attribute of a specific type in the Java object being accessed. The inventors realized that getting or setting attributes of any Java object generally meant getting or setting a data of a particular data type by running a particular method. For example, the function getString(in methodName: string &): string*, will return a pointer to a C++ STL string using the method identified by methodName, which is a string provided by the C++ proxy object , and return a pointer to a C++ string. As an example, assuming a C++ proxy object  MxUser with a method name called getUserName( ): string*, a C++ GUI callback method invocation comprising the name call getUserName( ): string* will be executed as a getString with getUserName as the methodName. The getString(getUserName) will retrieve a String from the Java method getUserName and convert the String to a C++ string for output to the C++ proxy object  and to the C++ GUI .",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 4","FIG. 4","FIG. 4"],"i":["a ","a","a"],"b":["44","44","43","50","44","44","12","44","50","43","50","50","44","43","50","44","43"]},"In a preferred embodiment, a plurality of Java objects  provide functionality for a computer system. Related to the Java objects  are a corresponding number of C++ proxy objects  that proxy the Java objects . In the computer network system  illustrated in , the SCM  includes the following C++ proxy objects  proxying Java objects  with the same name: MxUser, MxUserName, MxNode, MxNodeName, MxIPAddress, MxNodeGroup, MxNodeGroupName, MxTool, MxToolName, MxToolGroupName, MxToolToolGroupPair, MxFileCopyPair, MxParameter, MxRunnableTool, MxTaskStatus, MxTargetStatus, MxTargetOutput, MxAuthorization, MxRole, MxRoleName, MxString. Consequently, C++ GUIs  may access all of the Java objects  with the above names, through the corresponding C++ proxy objects  and the base proxy object .","A method data hash table  (e.g., MxMethNameToMethData) is also shown in MxMethNametoMethData is an object that is a data member in the C++ base proxy class . Initially, MxMethNametoMethData is an empty hash table . Each C++ proxy object , such as MxNode, preferably has a method info array (e.g., an array methodInfo_t object) that is a subset of data that goes into the MxMethodNametoMethData hash table . The methodInfo_t data preferably contains the method name and signature. Preferably, the methodInfo_t data does not include the method ID, since this is obtained dynamically, as described herein. The methodInfo_t data is placed inside the hash table  in order to provide fast and efficient access to the methodInfo_t data.","As implied by the name MxMethNameToMethData, the method name is the key to the hash table  and the methodInfo_t data is retrieved from the hash table  simply by using the method name. If the methodInfo_t data were left as an array, this array would have to be linearly searched to locate the correct data. The methodInfo_t data is entered into the hash table  by passing the methodInfo_t object to the MxMethNameToMethData object and asking the MxMethNameToMethData object to populate itself with the passed methodInfo_t object.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 4","FIG. 4"],"i":["b ","b, "],"b":["44","44","441","10","12","43","10","44","43","44","50","40","40","43","44"]},"Another advantage of the base proxy object  of the present invention is that it is customizable. Since it is customizable, the base proxy object  may be used in any system in which a C++ to Java transition similar to that described above takes place. The base proxy object  may be customized by adding or removing base proxy object functions  or general functions . For example, the base proxy object  shown in does not include getting or setting of floats. If a particular system required the getting or setting of floats, getFloat and\/or setFloat functions could be added to the base proxy object . Likewise, additional or different the C++ proxy objects  may be implemented to mirror additional or different Java objects , as determined by the particular needs of the computer system (e.g., network system ) with which the invention is used.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 5","b":["60","44","43","62","64","66","62","50","48","43","43"]},"When the new Java object is obtained, the JNI environment pointer, Java object name and Java class name are returned as a call to the C++ environment , therefore executing a constructor function to create and link a C++ proxy object  to the Java object . Accordingly, the initiating C++ proxy object linkage to the Java object  may comprise calling the appropriate constructor function with the JNI environment pointer, Java object name and Java class name as parameters to create and link a C++ proxy object  to the new Java object . For example, a call comprising the Java object name MxUser will execute a constructor that creates a C++ proxy object  of the same name (MxUser). The new C++ object MxUser will be linked, and therefore will proxy, the Java object MxUser.","When created, the new C++ proxy object  calls a constructor in the base proxy class  to initialize the instance data and to create global references for the proxied Java object . Therefore, the passing instance data to the base proxy object  may comprise the new C++ proxy object  calling the init function in the base proxy object and passing the JNI environment pointer, the Java object name and the Java class name with the init call (see ). The method  may also comprise a step of populating a method name to method date hash table . The hash table links method names with method data (e.g., method signature). The populating step  preferably comprises the new C++ proxy object  passing method names and method data to the hash table . The method names and method data are instance data of the new C++ proxy object . As noted above, maintaining the method data in the hash table  enables easier access to the method data by the base proxy object  and reduces the number of JNI API calls necessary.","After a Java object  and its proxy, the C++ object , have been created, the C++ GUI  can get\/set attributes in the Java object , through the C++ proxy object  and the base proxy object .  illustrates a method  for getting\/setting attributes in the Java object . The method  corresponds to the general interaction between the C++ GUIs , C++ proxy objects , the base proxy object  and the Java objects  shown in FIG.  and described above. The method  comprises a C++ GUI issuing a request to a C++ proxy object , the C++ proxy object passing method data to the base proxy object , the base proxy object processing the method data  and the Java object executing a Java method . The method steps may be performed as described above with reference to , and and as illustrated by the exemplary sequence diagram described below.","Accordingly, issuing a request to a C++ object  preferably comprises the C++ GUI  invoking a method call on the C++ proxy object  and providing the user entered data as the necessary parameters of the invoked C++ proxy object  method. The invoked C++ proxy object  method corresponds to the Java object  method that needs to be invoked to get or set attributes of the proxied Java object .","Passing method data to the base proxy object  preferably comprises the C++ proxy object  processing the method call invoked by the C++ GUI  and calling a base proxy object  method. The C++ proxy object  includes the method data (e.g., Java method name and the user entered data) in the base proxy object  method call. The C++ proxy object  method invoked by the C++ GUI  determines the base proxy object  method called. For example, a common C++ proxy object  method, setCreatedBy(const long uid):void, invoked by the C++ GUI  to set the uid of a created Node, User, Tool, etc., will call the base proxy object  method setInt(const string & methodName, const long cppInt): void when processed, since a uid has a C++ data type long that maps to Java data type Int (as seen in Table 1 above). Consequently, setting the Creating By attribute is basically setting a Java int.","Processing the method data  preferably comprises the base proxy object  executing the called method, getting the Java method ID using the method name provided by the C++ proxy object , issuing necessary JNI API calls with the method ID to call the Java method indicated by the method ID, and converting C++ data to Java data (and vice-versa). Executing a Java method  preferably comprises a Java object , which is proxied by the C++ object , executing the Java method called by the base proxy object  and identified by the method ID. If the Java method is a get method, the Java object  returns a pointer to the C++ data .",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 7","FIG. 7"],"b":["40","50","43","43","90","92","44","94","40","96","46","98","100","405","90","100","102","90","100","104","102","102","104","102","90","100","102","106"]},"In the exemplary process shown, the MxNewNode box  represents a C++ GUI  that may be used to enter data to create a new node in the network system . As seen in , the MxNewNode GUI  issues a call (shown by the getNode( ):jobject call line ) to obtain a Java object . As noted above, a C++ GUI  may obtain a Java object , for example, via a JNI call that returns a Java object or via a call to the Objectifier. In the present example, as noted by the associated notation , the MxNewNode GUI obtains the Java object  via a call to the Objectifier (represented by MxObjectifier box ). A new, empty MxNode Java object  is thus created in the JVM .","The Objectifier returns the new, empty MxNode Java object  as a call to the C++ environment . This call is illustrated by the MxNode(JNIEnv*env,jobject javaObject,const string & className) call line  extending from the MxNewNode  vertical time-line  to the MxNode  time-line . If the Java object  were returned by a JNI call, or in another manner, the Java object  would also be returned to the C++ environment  as a call. As noted by the associated notation , the MxNode call initiates C++ proxy object  linkage by calling the appropriate constructor function (i.e., MxNode) in the C++ environment . With the parameters provided within the parenthesis, the MxNode call links the new MxNode C++ proxy object  to the new MxNode Java object .","The MxNode box  represents the new MxNode C++ proxy object  created by the MxNode call. The new MxNode C++ proxy object  issues a call to the base proxy class  invoking a function in the base proxy class  (i.e., the init function) to initialize the instance data and to create global references for the proxied Java object . This function call is shown by the init(JNIEnv*env, jobject javaObject, const string & className): void call line . The \u201c:void\u201d indicates that the method call returns a void (i.e., nothing). The env is the JNI Environment pointer obtained from ObAM or directly via a JNI API call (as discussed above), the javaObject reference is the Java object reference obtained by the GUI (e.g., from the Objectifier) and the className is the name of the proxied Java class also provided by the GUI.","As noted above, the init function initializes the instance data and creates global references for the proxied Java object  and class. Accordingly, the base proxy object , represented by the MxProxy box , issues appropriate JNI API calls that are coded into the init function. These JNI API calls are illustrated by the NewGlobalRef(jobject):jobject, FindClass(string):jclass, and NewGlobalRef(jclass): jclass call lines . The NewGlobalRef call passes the jobject reference included in the init function call. The FindClass call passes the className string included in the init function call. The NewGlobalRef call passes the jclass reference obtained by the FindClass call.","Once the instance data is initialized and global references are created, the new MxNode C++ proxy object  issues a call to populate the method data hash table  (represented by the MxMethNametoMethData box ) with the method data from the proxied Java class. The method data includes a count (methodCount) of the number of methods in the methodInfo_t array and a pointer (methodInfo_t*) to the methodInfo_t array. The methodInfo_t array includes the method name and signatures. The C++ proxy object  issues this call since the method data, method names, and method signatures are embedded as instance data in the C++ proxy object  and the method data hash table  is preferably visible to all base proxy object  sub-classes. This call is illustrated by the populate(const int methodCount, const methodInfo_t*const & methodInfo):void call line . As noted above, the method name is used as a key to access the method data populated in the hash table .","After the above steps are executed, the C++ GUI  may issue a method execution request to set the name of the Java object , as shown in FIG. . This request is illustrated by the setName(const string & nodeName): void call line  extending from the MxNewNode vertical time-line . The setName request is passed to the MxNode C++ object . The string in the request is the name of the MxNode Java object  created above that is to be set.","The MxNode C++ proxy object  passes the request to the base proxy object . The setString method of the base proxy object (see above) is preferably used to set the name of the Java object , since the setString method makes calls on the proxied Java object . To set the name of the node, an MxNodeName object  is preferably instantiated. Therefore, the method data (i.e., method name and Java class ID for the MxNodeName Java object ) is passed to the base proxy object  via a setNameObject call, shown by the setNameObject(const string & methodName,const string & classpath,const string & name): void call line . The setNameObject call causes the setNameObject method in the base proxy object  to be executed.","Consequently, the setNameObject method comprises getting a method ID for the method of the MxNode Java object  that sets the name attribute of the MxNode Java object  and creating a new Java name object from the string specified in the C++ GUI setName method request by calling the Java method that sets the name attribute with the new Java name object.","The getMethodID and GetMethodID call lines  show the getting a method ID step. The first time getting a methodID, the base proxy object  gets the method ID by crossing the JNI boundary  using the proxied java class ID, the methodName string and the method signature, all provided by the C++ proxy object . Subsequently, the methodID is cached in the method data hash table, from which it may be retrieved as needed.","Referring to , the base proxy object  first calls its own getMethodlD method (as indicated by the self-referential getMethodID call line  that indicates that MxProxy is the method initiator and target). The invoked getMethodID(string & methodName):jmethodID function calls the hash table  (the MxMethNameToMethData object) using the method name as a key. This call retrieves a methodInfo_t object linked to the method name. The \u201cgetMethodID\u201d function looks inside the methodInfo_t object and if it finds a non-null java method ID, then the method ID has already been obtained and the getMethodID function does not need to make the call to the JNI . The \u201ccached\u201d method ID is simply returned. If however, the java method ID is null, the getMethodID function makes the call to the JNI  and caches the returned ID in the methodInfo_t object, and then puts the methodInfo_t object back into the hash table  (the MxMethNameToMethData object) for later use if so requested. Then the getMethodID function returns the method ID to the caller.","Consequently,  illustrates the lookup (lookup(string key,javaMethodData_t & retValue):bool ), the JNI call (GetMethodIDjclass clazz,const char*methodName,const char*signature):jmethodID) and the put back of the methodInfo_t object (putBack(string key,javaMethodDate_t & refvalue) : bool) since the method ID has not been previously retrieved and cached.","The newNameObject(const string & javaClassPath, const string & name):jobject is a self-referential method that calls the constructor of a Java name object (e.g., MxNodeName) that takes the Node name string provided by the C++ GUI  and returns a Java object global reference, jobject, to the constructed Java name object. The newNameObject method converts the C++ string provided by the C++ GUI  to a Java string, finds the method ID of the Java name object constructor, invokes the constructor to create the Java name object and creates a global reference to the new Java name object (not shown in FIG. ). The CallVoidMethod calls the Java method that sets the name of the MxNode Java object . As shown, the parameters include the global reference of the MxNode Java object  (i.e., the firstjobject), the Java method ID, (i.e., the jmethodID), and the global reference of the Java name object MxNodeName (i.e., the second jobject). The CallVoidMethod is the JNI API call to the JVM, in which the method identified by the jmethodID (i.e., the method of the MxNode Java object  that sets the name attribute of the MxNode Java object ) is called. Once the name of the MxNode Java object  has been set, the global reference of the Java name object MxNodeName is no longer needed. Accordingly, the base proxy object issues a DeleteGlobalRef(jobject) call to delete the jobject global reference of the Java name object MxNodeName.","Once the Java object  and its proxy, the C++ object , have been created, the C++ GUI may get\/set attributes of the Java object . Again referring to , the MxNewNode GUI  issues a method call to set the created by attribute of the Java object . This method call is shown by the setCreatedBy(const long uid):void call line . Therefore, this calls the setCreatedBy function in the MxNode C++ object , passing a C++ long user id (uid).","Since a C++ long is mapped to a Java int, the MxNode C++ proxy object  passes the parameter to the base proxy object  by calling a setInt function. This is shown by the setInt(const string & methodName, const long cppInt): void call line . As seen, the setInt call includes a string for the method name and the C++ long for the Java Int as parameters. In this example, the method name is MxNode.setCreatedBy (i.e., the MxNode Java object  method that sets the uid (userid) identifying the user that created the node object).","When received by the base proxy object , the setInt method gets the method ID of the method in the MxNode Java object  that sets the setCreatedBy attribute. Once the method ID (jmethodID) is returned (by the self-referential getMethodID method call shown), the base proxy object calls the method, passing the method ID and the long uid (converted to a java Int jint) to the MxNode Java object . This is illustrated by the CallVoidMethod(jobject jmethodID jint) call to the JNI. The jobject parameter is the global reference to the MxNode Java object .","While the invention has been described with reference to the exemplary embodiments thereof, those skilled in the art will be able to make various modifications to the described embodiments of the invention without departing from the true spirit and scope of the invention. The terms and descriptions used herein are set forth by way of illustration only and are not meant as limitations. Those skilled in the art will recognize that these and other variations are possible within the spirit and scope of the invention as defined in the following claims and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":["The detailed description will refer to the following drawings, in which like numbers refer to like items, and in which:",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4","i":"a "},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4","i":"b "},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
