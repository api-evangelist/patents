---
title: Receiver-processor-dispatcher mechanism for inbound connectors
abstract: System and method for receiving inbound messages from external systems and delivering the messages to applications within application servers are described. Embodiments may provide implementations of a Receiver-Processor-Dispatcher (RPD) architecture for inbound connectors that segments the work of delivering inbound messages from an Enterprise Information System (EIS) to an application into the discrete stages of receiving messages from the EIS, processing the messages to determine which components in the application should receive the messages, and dispatching the messages to the components. The delivery of messages from an EIS to an application is performed by receiver, processor, and dispatcher components of an RPD connector. RPD connectors implemented according to the RPD architecture may provide a common framework for delivering messages from an EIS to an application. Developers may implement RPD connectors according to the common framework, while customizing the RPD connectors according to the particular requirements of the EIS and/or application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07802260&OS=07802260&RS=07802260
owner: Oracle America, Inc.
number: 07802260
owner_city: Redwood City
owner_country: US
publication_date: 20040809
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims priority to U.S. Provisional Application No. 60\/577,739, filed Jun. 7, 2004, entitled \u201cRECEIVER-PROCESSOR-DISPATCHER MECHANISM FOR INBOUND CONNECTORS\u201d.","1. Field of the Invention","This invention relates to application servers, and more particularly to connectors that interface between application servers and other systems.","2. Description of the Related Art","The Java 2 Enterprise Edition (J2EE) is a family of standards that describes how application servers work with Java programs. If a Java developer writes an application according to these conventions, then that application can be run more securely and efficiently inside the application server. In addition, the application server takes care of many common tasks that the Java program would otherwise have to take care of itself, allowing the developer to concentrate on the specifics of an application.","One of these common facets has to do with how application servers and the Java programs that run inside them integrate with software that does not follow the J2EE standards. These could include Java programs that were not built to comply with the J2EE standard as well as programs written in languages other than Java. The J2EE Connector Specification describes the features that application servers must provide to allow J2EE applications to work with these other software systems, referred to as Enterprise Information Systems (EISs). The J2EE Connector Specification also describes how J2EE applications may make use of those application server features to work with an EIS. A key aspect of the overall solution is the concept of a connector (or resource adapter) that lies between the J2EE application and a particular type of EIS. The connector acts a bridge between the J2EE part of the solution and the EIS. A J2EE connector allows a J2EE application written according to the J2EE rules to work with an EIS that was not written that way. A J2EE connector for a particular EIC understands both the J2EE rules and how to work with the particular EIS. The J2EE connector links them in a way that works for both the J2EE application and the EIS.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1","b":["106","100","102","112","114","110","106","100","108","106","102","106","114","104"]},"The J2EE Connector Specification describes both outbound and inbound communication between the J2EE application and the external EIS. Outbound communication occurs when the J2EE application initiates the contact with the EIS. Typically, the J2EE application, during its execution, needs to use some function or service provided by the EIS. In a sense, the EIS is passive in this scenario, waiting for the J2EE application to request some work of it.","With inbound communication, the EIS initiates the contact with the J2EE application. Some business event may become known within the EIS (the creation of a new purchase order, for example) and the J2EE application needs to become aware of that business event. The EIS takes an active role in this scenario, and the EIS initiates the contact with the J2EE application at a time of its choosing. In practice, different EISs may use different techniques for communicating with other software to accomplish inbound communication (from the EIS to the J2EE application). For example, some EISs may send messages over a network connection to a specific network port, and others may deposit files in specified directory. As a result, even though some of the logic inside a connector can be common to many or even all connectors, some connector logic will always depend on the particular EIS.","When an enterprise application calls a function of an EIS, it uses the connector's outbound connectivity. In general, the application obtains a logical connection from the connector, and through that logical connection requests the connector to invoke one or more functions that the EIS makes available through its API. Results of the API function are returned from the EIS API to the connector that returns them to the application. Note that the enterprise application initiates the exchange with the EIS, using the connector as an intermediary.","When an enterprise application accepts messages from an EIS, it uses the connector's inbound connectivity. The connector, without any direct instigation by the application, sets up a physical connection to the EIS. As the EIS runs, it can send messages to the connector over this connection. As it receives each message, the connector delivers the message to the application. Note that here the EIS initiates the exchange of information with the application, using the connector as an intermediary.","The J2EE Connector Specification includes several interfaces and mandates in considerable detail the behavior required in the application and the connector for handling outbound connectivity. Further, the specification mandates that the connector deliver incoming messages only to one or more message-driven beans (MDBs) that are part of the application. Because the administrator can deploy several connectors and several applications with MDBs into a container, the specification requires that the container's deployment tool allow the administrator to form associations between specific MDBs in applications and specific connectors. The J2EE Connector Specification refers to these logical associations as message endpoints. The specification allows a single MDB to serve as more than one message endpoint, even to the same connector.","The specification also prescribes the API the connector must use to deliver messages to MDBs. Beyond this, the specification says very little else about how the connector should handle inbound connectivity internally. The developer\u2014or generator\u2014of the connector may use any useful approach that accepts messages from the EIS and delivers them in a specification-compliant way to the application's MDBs. In particular, the specification does not address how a connector solicits and accepts messages from an EIS, how the connector selects which message endpoints should receive a particular incoming message, or how the connector manages delivery of message to the selected MDBs.","Embodiments of a system and method for receiving inbound messages from external systems such as Enterprise Information Systems (EISs) and delivering the messages to applications within application servers are described. Embodiments may provide implementations of a Receiver-Processor-Dispatcher (RPD) architecture for inbound connectors that segments the work of delivering inbound messages from an EIS to an application into the discrete stages of receiving messages from the EIS, processing the messages to determine which components in the J2EE application should receive the messages, and dispatching the messages to the components. Inbound connectors implemented according to the RPD architecture may be referred to as RPD connectors.","RPD connectors implemented according to the RPD architecture may provide a common framework for delivering inbound messages from an EIS to an application. Components and\/or mechanisms that are common to all EIS\/Application interfaces may be implemented in all RPD connectors according to the RPD architecture. Specific RPD connectors may also include components and\/or mechanisms that are specific to the requirements of the EIS and\/or application. Thus, developers may implement RPD connectors according to the common framework, while customizing the RPD connectors according to the particular requirements of the EIS and\/or application.","The delivery of inbound messages from an EIS to an application is performed by the receiver, processor, and dispatcher components of an RPD connector. The receiver receives incoming messages from the EIS. The receiver may encapsulate all dependencies on the particular EIS API. The receiver may also be responsible for keeping the connection to the EIS open. The processor processes each incoming message to choose which candidate message endpoint(s) should receive this message and, in one embodiment, creates a separate dispatcher for each destination. A dispatcher handles the physical delivery of a single message to a single message endpoint. A dispatcher may encapsulate all dependencies on the associated MDB. Note that there may be more than one dispatcher.","RPD connectors may be written manually by a developer or, in one embodiment, generated using an RPD connector builder mechanism. An RPD connector builder mechanism may accept information specific to an EIS\/application interface and automatically generate a custom RPD connector for the EIS\/application interface according to the specific information.","In one embodiment, the RPD architecture may include a sequencer component for use in RPD connectors that may be used to specify whether the processor runs synchronously or asynchronously with the receiver and whether the dispatcher(s) run synchronously or asynchronously with each other and the processor. In one embodiment, the default behavior of the sequencer implements strictly serial message handling as described above, and developers may provide alternative implementations if they want their RPD connectors to behave differently.","Note that while embodiments are generally described herein for J2EE application server environments and connectors that conform to the J2EE Connector Specification, embodiments of connectors implemented according to the RPD architecture may be used in other environments and for connectors conforming to other connector specifications. In general, connectors implemented according to the RPD architecture may be used in any scenario for delivering messages of any type from a source to a destination.","While the invention is described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that the invention is not limited to the embodiments or drawings described. It should be understood, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description or the claims. As used throughout this application, the word \u201cmay\u201d is used in a permissive sense (i.e., meaning having the potential to), rather than the mandatory sense (i.e., meaning must). Similarly, the words \u201cinclude\u201d, \u201cincluding\u201d, and \u201cincludes\u201d mean including, but not limited to.","Embodiments of a system and method for receiving inbound messages from external systems such as Enterprise Information Systems (EISs) and delivering the messages to applications within application servers are described. A connector accepts messages that originate from an external back-end system (referred to herein as an Enterprise Information System, or EIS), and then uses interfaces defined in the J2EE Connector Specification to deliver the messages to the application. Embodiments may provide implementations of a Receiver-Processor-Dispatcher (RPD) architecture for inbound connectors that segments the work of delivering inbound messages from an EIS to an application into the discrete stages of receiving messages from the EIS, processing the messages to determine which components in the J2EE application should receive the messages, and dispatching the messages to the components. Inbound connectors implemented according to the RPD architecture may be referred to as RPD connectors.","RPD connectors implemented according to the RPD architecture may provide a common framework for delivering inbound messages from an EIS to an application. Components and\/or mechanisms that are common to all EIS\/Application interfaces may be implemented in all RPD connectors according to the RPD architecture. Specific RPD connectors may also include components and\/or mechanisms that are specific to the requirements of the EIS and\/or application. Thus, developers may implement RPD connectors according to the common framework, while customizing the RPD connectors according to the particular requirements of the EIS and\/or application.","In one embodiment, the RPD architecture may include a sequencer component for use in RPD connectors that may be used to specify whether the processor runs synchronously or asynchronously with the receiver and whether the dispatcher(s) run synchronously or asynchronously with each other and the processor. In one embodiment, the default behavior of the sequencer implements strictly serial message handling as described above, and developers may provide alternative implementations if they want their RPD connectors to behave differently.","In one embodiment, the RPD architecture may be implemented as classes in an object-oriented programming language, such as the Java programming language. The components of an RPD connector including, but not limited to, the receiver, processor, and dispatcher, may be instances of the classes that may, if necessary, include extensions to the classes for supporting the particular requirements of the EIS\/application interface.","RPD connectors may be written manually by a developer or, in one embodiment, generated using an RPD connector builder mechanism. An RPD connector builder mechanism may accept information specific to an EIS\/application interface and automatically generate a custom RPD connector for the EIS\/application interface according to the specific information. An exemplary RPD connector builder mechanism for generating RPD connectors is described herein.","Note that while embodiments are generally described herein for J2EE application server environments and connectors that conform to the J2EE Connector Specification, embodiments of connectors implemented according to the RPD architecture may be used in other environments and for connectors conforming to other connector specifications. In general, connectors implemented according to the RPD architecture may be used in any scenario for delivering messages of any type from a source to a destination.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIGS. 2 through 4"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 2","b":["214","204","220","222","224","206","220","214","220","212","220","214","222","224","224","224","204","204","224"]},"In one embodiment, an RPD connector  may include a mechanism or mechanisms for using the receiver , processor  and dispatcher  components in specific, well-defined ways. For example, the container  may inform the RPD connector  during its own start-up as well as during each message endpoint activation. RPD connector  may include a mechanism that may employ the receiver , the processor , and the dispatcher  at the appropriate times and in the appropriate order to successfully deliver EIS messages to the application .","In one embodiment, receiver  may act to ensure that the RPD connector  maintains an open connection to the EIS  over which a flow of messages can arrive from the EIS . During initialization, the RPD connector  may invoke the receiver 's \u201copen\u201d method that uses the EIS API  to establish a connection between the EIS  and the RPD connector . As it runs, the receiver  may detect failures in the connection and attempt to re-establish the connection.","Depending on the EIS , and in some cases on the connector developer's choice, the RPD connector  may start the receiver  during RPD connector  start-up or during endpoint activation. The receiver  accesses information it needs to give the EIS APT  in order to connect the EIS . This connection information may be available as configuration properties of the RPD connector , the message endpoint, or both. In one embodiment, the RPD connector  may start a receiver  during RPD connector  startup only if all connection-related configuration is defined as RPD connector  configuration properties. If any information needed to open the connection comes from the message endpoint configuration, then the RPD connector  waits until endpoint activation to start the receiver .","In one embodiment, receiver  may accept each arriving message and submit it to the rest of the RPD connector  for ultimate delivery to message endpoints. Some EIS APIs  may require the receiver  to register a listener object that will be informed as each new message arrives. Other EIS APIs  may offer a method that the receiver  may invoke each time it seeks to read a newly arrived message. In this second case, the developer may specify, for example to an RPD connector builder mechanism, that explicit action is required to obtain an incoming message. In one embodiment, RPD connector  may periodically execute a timed task that invokes the receiver 's read method. In any case, once the receiver  obtains a new message from the EIS , it makes the message available to the RPD connector  as a whole by invoking an \u201con read complete\u201d method. In one embodiment, the \u201con read complete\u201d method may be implemented by the receiver's superclass.","In one embodiment, receiver  may close the connection to the EIS  when requested. Most EIS APIs  provide a method the receiver  may invoke to sever the physical connection to the EIS . In one embodiment, the receiver class may provide a \u201cclose\u201d method that the developer may customize to use the particular EIS API  to disconnect from the EIS . In one embodiment, if the RPD connector  started a receiver  during RPD connector  start-up, receiver  may invoke \u201cclose\u201d during RPD connector  shutdown. If the RPD connector  started a receiver  during endpoint activation, then receiver  may invoke \u201cclose\u201d during the deactivation of that same message endpoint.","In one embodiment, receiver  may extract transaction-related information from a message when requested. The J2EE Connector Specification allows the EIS  to start a global XA transaction and furnish the transaction ID (Xid) in the incoming message, at which time the connector must forward the Xid to the container so the application may join the transaction. However, the J2EE Connector Specification does not specify how the Xid will appear in the message. There may be an EIS API  method the receiver  may invoke to obtain the Xid. Alternatively, the Xid may be embedded in the message body from which the receiver  may extract by using knowledge of the message format used by the EIS .","In one embodiment, receiver  may include a \u201cprepare execution context\u201d method as a default implementation that returns null. The developer may customize this method if the EIS API  or the message format provides transaction IDs. The processor  class may call this method as part of message processing, described below.","In one embodiment, receiver  may provide an XAResource object. In certain recovery scenarios, the RPD connector  provides an XAResource to the container  that the container  may use for recovering outstanding transactions. The EIS API  may provide its own XAResource implementation, or it may provide other classes or methods that accomplish the same effect. In one embodiment, the receiver , as the sole point of contact between the EIS  and the RPD connector , the container , and the application , may provide an XAResource for this purpose.","In one embodiment, receiver  may include a \u201cprepare XA Resource\u201d method as a default implementation that returns null. The developer may customize this method if the EIS API  provides either an XAResource implementation of its own or functionally equivalent methods on other classes. The receiver 's \u201cprepare XA Resource\u201d method may be invoked when the container  asks the RPD connector  to participate in transaction recovery.","The aspects of the receiver  described above may depend directly on the particular EIS API  and\/or the EIS message format. Further, in one embodiment, all dependencies on the EIS  are collected together into the receiver . The developer may customize the receiver  using the specifications of the particular EIS API  to define and implement the receiver 's responsibilities. Even so, much of what a receiver  does is the same for all EISs\/EIS APIs. As a result, the developer may need to customize only certain aspects of the receiver  to achieve a fully functioning RPD connector , in particular opening a connection, reading a message, and closing the connection.","In one embodiment, the RPD architecture may include a network endpoint manager component of RPD connectors that provides a specific way for communicating with the EIS. In one embodiment, the network endpoint manager component creates and initializes receivers when and how they are needed.","EIS APIs  may exhibit two styles of interaction with the receiver :\n\n","The RPD architecture and the RPD connectors  implemented according to the RPD architecture may be used to provide receivers  that may follow either or both styles of interaction. In one embodiment, a \u201ccallback\u201d receiver  may be invoked by the EIS  when the EIS  needs to send information to the RPD connector . Typically, as the receiver  is initialized during the RPD connector's start-up, the receiver  may register itself with the EIS  so the EIS  knows it is there and that it is interested in receiving messages. When a message becomes available, the EIS  calls back to the receiver  to report the arrival of the message. Once a callback receiver  has registered its interest with the EIS , it is largely passive, waiting for the EIS  to callback to it.","Some EISs may require the receiver  to actively check whether new messages from the EIS  have arrived. To handle this, a \u201crecurring read\u201d receiver  may use a timer to trigger repeating checks for new messages. In one embodiment, developers may define periodic receivers  that check according to a fixed schedule. The generated logic may be customized to build a more general recurring read receiver  that might not be strictly periodic. For instance, if messages from the EIS  are known to have distinct high- and low-traffic intervals, then the receiver  might check less frequently if it finds no messages waiting. Conversely, the receiver  might check more frequently during times when it finds messages waiting for it. This approach may be useful, for example, if the operation of checking for a new message takes a long time or places a heavy demand on system resources.",{"@attributes":{"id":"p-0051","num":"0052"},"figref":["FIGS. 3A-3C","FIG. 3A"],"b":["220","206","214","206","230","232","232","232","204","204","204","206","230","232","200","206","204"]},{"@attributes":{"id":"p-0052","num":"0053"},"figref":"FIG. 3B","b":["220","214","222","220","206","206","222","222"]},"In one embodiment, the processor  may choose from the candidate message endpoints (candidates ) in candidate set  one or more message endpoints (candidate A, in this example) that are to receive the message. Although the administrator associated message endpoints with the RPD connector  when the application was deployed, the developer may not want each of the RPD connector 's active message endpoints to receive every message from the EIS . In one embodiment, the message is passed to the processor 's \u201cselect recipients\u201d method, which returns a collection of active message endpoints that should be sent the message. In one embodiment, the default behavior for the \u201cselect recipients\u201d method is to choose all eligible, active message endpoints. In , the processor  has selected only one candidate A from candidate set  as the message endpoint to receive the particular incoming message. This is represented by the bold line linking candidate A with MDB A, while the lines between the other candidates  and MDBs  remain light. Note that one or more message endpoints may be selected.","In one embodiment, the processor  may use the receiver  to extract any transactional information from the message. In one embodiment, the processor  may invoke a \u201cprepare execution context\u201d method of the receiver  to obtain transactional information from the message.","In one embodiment, the processor  may arrange for delivery of the message to each selected message endpoint. One embodiment may use a separate dispatcher  to handle delivery of a single message to a single message endpoint. In one embodiment, the processor  may create a dispatcher  for each appropriate message endpoint and submit the collection of dispatchers  to the RPD connector  for execution. In one embodiment, the default implementation simply instantiates a dispatcher  for each selected recipient and then submits them.",{"@attributes":{"id":"p-0056","num":"0057"},"figref":"FIG. 3C","b":["224","222","224","206","206","224"]},"The J2EE Connector Specification defines the Java interface javax.resource.cci.MessageListener as a generic interface that any MDB may implement. During RPD connector definition, the developer may specify the Java type of the MDB interface. In one embodiment, if an RPD connector builder mechanism is being used, the Java type of the MDB interface may be specified through the RPD connector builder mechanism's user interface. If the developer chooses javax.resource.cci.MessageListener as the MDB's interface type, then the RPD connector builder mechanism may generate the RPD connector's dispatcher class entirely. In many if not most cases, the developer may not need to customize the dispatcher. However, if the developer specifies a different Java type for the MDB's interface, then the RPD connector builder mechanism may not be able to determine how to deliver the message to the MDB. In this case, the developer may customize the \u201cdeliver\u201d method of the dispatcher to deliver the message.",{"@attributes":{"id":"p-0058","num":"0059"},"figref":"FIG. 4","b":"250"},"As indicated at , a processor component of the RPD connector may determine one or more components (e.g. MDBs) of the application to receive each of the inbound messages. In one embodiment, the RPD connector may create the processor component after the receiver component receives the inbound messages from the EIS. In one embodiment, to determine the component(s) to receive the inbound messages, the processor component selects one or more message endpoints indicating the application components from a set of message endpoints maintained by the RPD connector. Each message endpoint indicates one of the application components as a destination for incoming messages from the EIS.","As indicated at , one or more dispatcher components of the connector may each dispatch one of the inbound messages to one of the determined application components. In one embodiment, the RPD connector may create the dispatcher components after the processor component determines the application components to receive the inbound messages. In one embodiment, each dispatcher component encapsulates all dependencies of the RPD connector on the corresponding application component.","In one embodiment, the receiver component, processor component, and dispatcher component(s) may process incoming messages serially. In this embodiment, the receiver component waits for the dispatcher component(s) to deliver the inbound messages before accepting a next inbound message from the EIS. In one embodiment, the receiver component, processor component, and dispatcher component(s) may process incoming messages asynchronously. For example, the receiver component may accept a next inbound message from the EIS before the dispatcher component(s) deliver the inbound messages.","Sequencing Message Handling within the RPD Connector","As described above, the stages of message handling\u2014receipt, processing, and dispatching\u2014occur serially. The receiver that accepts a message waits for the RPD connector to processes the message before accepting the next message. The processor waits for all of the dispatchers to complete before returning to the receiver. This serial method of message handling is a \u201csafe\u201d method of message handling, in that any error that occurs during any stage of the message handling may be detected by the receiver, which could then inform the EIS of the problem directly, for example through a response message or throwing an exception.","However, some RPD connectors and\/or applications may be better served by alternative styles of message handling. For example, if the logic in the application's MDB takes significant time, then the receiver may be blocked from accepting additional messages for that length of time. During message handling, new incoming messages from the EIS may back up, waiting for the receiver to read again. Therefore, in one embodiment, the RPD architecture may provide for the implementation of RPD connectors that provide an alternative method or methods for orchestrating the receipt, processing, and dispatching of messages in the RPD connector.","In one embodiment, the RPD architecture may include a sequencer component of RPD connectors that may be used to specify whether the processor runs synchronously or asynchronously with the receiver and whether the dispatcher(s) run synchronously or asynchronously with each other and the processor.  illustrates an RPD connector with a sequencer according to one embodiment. The sequencer  may be used to control when the receiver , processor , and dispatcher(s)  execute with respect to each other. For example, a developer may want the RPD connector  to receive a message, then process it, and then dispatch it before accepting another message from the EIS . Alternatively, a developer may prefer that, once a message is received from the EIS , the processing and dispatching occur in parallel with the next receipt of a message. The sequencer  may be used to determine whether message handling by the other components is performed serially or whether part or all may be performed concurrently. In one embodiment, the default behavior of the sequencer implements strictly serial message handling as described above, and developers may provide alternative implementations if they want their RPD connectors to behave differently.","RPD Connector Builder Mechanism","An exemplary RPD connector builder mechanism is described that may accept information specific to an EIS\/application interface and automatically generate a custom RPD connector for the EIS\/application interface according to the specific information. In one embodiment, the RPD connector builder mechanism, or RPD connector builder for short, may provide or generate most of the logic needed for RPD connectors, and the developer may provide some code and\/or modifications to the generated code specific to the EIS. Thus, the RPD connector builder may generate much of the RPD connector implementation for the developer, thus reducing the amount of customization needed, and may organize the RPD connector according to the common RPD architecture so that the developer can perform any customization quickly and accurately.","In one embodiment, the RPD connector builder provides a user interface that allows a developer to describe the characteristics of the EIS of interest. The RPD connector builder then generates all or almost all of the RPD connector code. In one embodiment, the RPD connector builder generates RPD connectors according to the RPD architecture described herein. This allows the RPD connector builder to manage and coordinate how the components of the RPD architecture (receiver, processor and dispatcher) work together, while leaving the developer with only a few points where custom-written logic may be required according to the specifics of the EIS.","The RPD connector builder may allow users to define and generate RPD connectors that comply with the RPD connector architecture and make use of particular EISs. In one embodiment, the user enters information about the EIS and its API into a user interface of the RPD connector builder, and makes specific choices about the behavior the RPD adapter should have: e.g., transactional support, security authentication, etc. Then, the RPD connector builder combines the user's input with its own intelligence about how J2EE Connector Specification-compliant adapters should behave, and generates Java code that implements a specification-compliant RPD connector for that user's particular EIS. In one embodiment, the user may need to customize a few points in the generated code to provide logic that the RPD connector builder cannot generate itself. An example of the sort of logic that may require customization is how the EIS API should be used to establish a new physical connection to the EIS so that the adapter and the EIS can exchange messages.","Once the user has customized the generated RPD connector (if necessary), the RPD connector builder may be used to build the RPD connector and package it. The resulting RPD connector archive contains the RPD connector and everything needed for its proper operation, and the archive is ready for deployment into any J2EE-compliant container.","In one embodiment, the generated RPD connector complies with the J2EE Connector specification. In one embodiment, the RPD connector may also include other features, such as logging and exception handling, which are beyond what is required by the J2EE Connector specification.","In one embodiment, the RPD connector builder may provide an implementation of the service provider interface (SPI) for non-managed environments such as Web servers and stand-alone Java virtual machines (JVMs).","Certain behavior is common to all connectors. In addition to generating the components of RPD connectors that may vary from one RPD adapter to the next, the RPD connector builder may provide an extensive framework of classes that are common to all connectors. In one embodiment, the classes generated by the RPD connector builder are subclasses of the classes in the common framework, and these subclasses may implement only the connector-specific behavior. The common superclasses provide the common, connector-independent logic.","In one embodiment, the developer may need to customize certain parts of the RPD adapter that the RPD connector builder cannot generate. In one embodiment, the RPD connector builder may allow the developer to regenerate the RPD connector as many times as needed, and may preserve customizations that the developer has already implemented in previously generated classes.",{"@attributes":{"id":"p-0073","num":"0074"},"figref":"FIG. 6","b":["300","302","302","304","300","306","304","308"]},{"@attributes":{"id":"p-0074","num":"0075"},"figref":"FIG. 7","b":["350","350","352","352","354","354","350"]},"System  may include, in memory , an embodiment of an RPD connector builder  as described herein. The developer may input EIS and possibly other information  into the RPD connector builder . The RPD connector builder  may generate an RPD connector  according to the input EIS information . If necessary or desired, the developer may customize  the RPD connector  according to the specific EIS by adding code and\/or modifying generated code to generate a production RPD connector . In one embodiment, the RPD connector may be regenerated, if necessary or desired, preserving customizations.","Various embodiments may further include receiving, sending or storing instructions and\/or data implemented in accordance with the foregoing description upon a computer-accessible medium. Generally speaking, a computer-accessible medium may include storage media or memory media such as magnetic or optical media, e.g., disk or CD-ROM, volatile or non-volatile media such as RAM (e.g. SDRAM, DDR, RDRAM, SRAM, etc.), ROM, etc. As well as transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network and\/or a wireless link.","The various methods as illustrated in the Figures and described herein represent exemplary embodiments of methods. The methods may be implemented in software, hardware, or a combination thereof. The order of method may be changed, and various elements may be added, reordered, combined, omitted, modified, etc.","Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. It is intended that the invention embrace all such modifications and changes and, accordingly, the above description to be regarded in an illustrative rather than a restrictive sense."],"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS","CONCLUSION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 3A-3C"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
