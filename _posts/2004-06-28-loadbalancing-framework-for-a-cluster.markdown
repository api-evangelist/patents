---
title: Load-balancing framework for a cluster
abstract: Various embodiments of a system and method for balancing nodal loading in a cluster are disclosed. In a cluster, each node may execute an instance of a distributed application component. A pluggable load balancer may receive requests targeted at the application component. For each request, the load balancer may invoke a pluggable load-balancing function to determine a next node to which the request should be forwarded to balance the workload of the cluster nodes. Each node of the cluster may include a load-balancing framework that provides a standard load-balancing API. In order to determine the next node to which a request should be milted, the load balancer may send requests for node information conforming to the API, to the cluster members. This information may include nodal CPU speed, memory capacity, number of queued requests, and number of requests serviced during a specified time period.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07757236&OS=07757236&RS=07757236
owner: Oracle America, Inc.
number: 07757236
owner_city: Redwood City
owner_country: US
publication_date: 20040628
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS"],"p":["1. Field of the Invention","This invention relates to computer systems, and more particularly to load balancing requests among nodes in a cluster environment.","2. Description of the Related Art","Distributed applications are often implemented as part of commercial and non-commercial business solutions for an enterprise. For example, a company may leverage the use of an enterprise application that includes various databases distributed across multiple computers. Applications of this type, which support E-commerce, typically support hundreds or thousands of sessions simultaneously during periods of peak utilization. For scalability and fault tolerance, the servers running such applications may be clustered.",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1","b":["100","110","100","120","110","140","130","100","140","130","140","130","130","140","100","140"]},"Typically, a cluster load balancer is implemented as a hard-coded component of one of the cluster nodes. It may implement one or more load balancing algorithms such as random, round robin, etc. In many cases the included algorithm may not be the best choice for the particular condition that exist in a given cluster, but there may be no easy way to modify or replace the included algorithm. Also, the type of information that the load balancer has available to it may limit the type and\/or performance of the included algorithm. For example, load-balancing algorithm based on node loading may only be able to accept estimates of operational loadings input when the load balancer is configured. There may be no provision in the load balancer to obtain real-time updates to these estimates, and no provision in the nodes to provide the supporting information.","Various embodiments of a system and method for balancing nodal loading in a cluster are disclosed. In a cluster, each node may execute an instance of a distributed application component. A pluggable load balancer may receive requests targeted at the application component. For each request, the load balancer may invoke a pluggable load-balancing function to determine a next node to which the request should be forwarded to balance the workload of the cluster nodes. Each node of the cluster may include a load-balancing framework that provides a standard load-balancing API. In order to determine the next node to which a request should be routed, the load balancer may send requests for node information conforming to the API, to the cluster members. This information may include nodal CPU speed, memory capacity, number of queued requests, and number of requests serviced during a specified time period.","The standard load-balancing API may allow any custom load balancer written to conform to the API to be plugged into the cluster and access nodal information made available by the load-balancing framework. The load-balancing framework may receive a request for information from the load balancer, collect and\/or calculate the requested data, and return the data to the load balancer. For example, in order to determine the next node, the load-balancing function may need the number of requests that a node has serviced per minute, averaged over that last three hours. The load-balancing framework may access one or more logs and perform several calculations in order to obtain the requested loading data.","The standard load-balancing API may allow a custom load-balancing function to be plugged into various cluster components. The location within the cluster and initial configuration of the load balancer\/load-balancing function may be specified in one or more deployment descriptors. In one embodiment, the load-balancing function may be included in a naming service. When the naming service receives a lookup request for an application component, it may invoke the load-balancing function to determine a next node and return the application component instance running on the next node. In this way, the requests from the client requesting the lookup may be routed to a different node than those from the client that requests a subsequent lookup.","In another embodiment, the load-balancing function may be included in an augmented stub. In this case, when the client requests access to the application component, the augmented stub may invoke the load-balancing function to determine a next node and use a stub corresponding to the next node to route the client request. In this case requests from an individual client may be routed to instances of the application component on various nodes to balance the workload. In still other embodiments, the load-balancing function may be deployed in a stand-alone cluster component or in each node of the cluster. In the case of a stand-alone load balancer, it may receive all requests for the application component, invoke the included load-balancing function to determine a next node, and distribute each request to the next node based on a random, round robin, weighted round robin, or loading based load-balancing function.","In the case where load-balancing functionality is included in cluster nodes, it may be included in the load-balancing framework or in another component of the node.","In one embodiment, the nodal load-balancing function may serve as a safety valve for another load balancer located elsewhere in the cluster. For example, the nodal load balancer may poll the load-balancing framework within its node to determine when the node's workload reaches a predefined level. When the specified level is reached the nodal load balancer may determine a next node, and route received requests to the next node until its application component can accommodate additional requests.","While the invention is described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that the invention is not limited to the embodiments or drawings described. It should be understood, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description or the claims. As used throughout this application, the word \u201cmay\u201d is used in a permissive sense (i.e., meaning having the potential to), rather than the mandatory sense (i.e., meaning must). Similarly, the words \u201cinclude\u201d, \u201cincluding\u201d, and \u201cincludes\u201d mean including, but not limited to.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 2","b":["200","240","240","220","220","210","220","250","220","210","250","220","220","250","250"]},"The augmented stub  for an application component  may act as a client's local representative or proxy for the application component . The client may invoke a method on the augmented stub, which is responsible for carrying out the method call on the application component . In one embodiment, the mechanism for performing a method call on application component  may be remote method invocation (RMI). In RMI, a stub within the augmented stub for the application component may implement the same set of remote interfaces that the application component implements. The augmented stub appears as a normal stub to the client. When the augmented stub's method is invoked, the normal stub within the augmented stub may initiate communication over a connection with the cluster node containing the application component, marshal (write and transmit) the parameters to the application component, wait for the result of the method invocation, un-marshal (read) the return value or exception returned, and return the value to the client. The stub may hide the serialization of parameters and the network-level communication in order to present a simple invocation mechanism to the client.","For a client  to invoke a method on an application component , that client may first need to obtain a reference to the object. A reference to an application component may be obtained from a naming service .","When client  requests the lookup of an application component , naming service  may return the augmented stub  for the requested application component to the client. In some embodiments, naming service  may be cluster-aware, and if the requested object is executing on a cluster, it may return the augmented stub to the client, whereas if the requested object is executing on a single server, it may simply return a normal stub for the requested object. In one embodiment, in response to an initial lookup request for an application component, naming service  may return an augmented home stub that includes a normal home stub for the application component. Once the client  has obtained the augmented home stub (which appears to the client as the normal home interface to the desired application component ), it may invoke the create( ) or find( ) methods provided by the home interface to obtain the application component's remote interface (which may be returned as an augmented remote stub).","In one embodiment, if the distributed application component  is stateful, that is if it includes data that must be maintained between client requests or longer, then the component may store the that persistent data to commonly accessible persistent data storage . In one embodiment persistent data storage  may be a database running on a backend system coupled to the cluster by a network. In order to support the persistence requirements of application components  and failure recovery methods of cluster , persistent data storage  may be accessible by all cluster members .",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 2A","b":["270","280"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 3","b":["300","310","330","310","320"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 4","b":["210","430","430","430","440","410","210","250","210","220","200","230","230","210","430","440","410","440","240","200","410","440","240","210","410","250","240"]},"At some point, cluster node A may experience a failure. This failure could be a hardware failure of the platform of the node, a software failure in the application component itself or the supporting software running on the platform, or a failure in the network linking the node to the rest of the cluster. Augmented stub  may detect this loss of communication with node A and select another node from node list  that is running the application component. For example, if node list  includes nodes A, B, and C, and augmented stub  detects the failure of node A, it may select node B to fail-over the application component. Augmented stub  may send a lookup request to naming service , which may return new stub  for application instance B, so that new stub  may be obtained to replace old stub . Augmented stub  may use new stub  to send the client request that failed on node A, and all subsequent requests to node B. Augmented stub  may perform the functions described above completely transparently to the client , thus allowing for graceful failover of remote services provided for the client from node A to node B.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 5","b":["500","510","520","520","540"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 6","b":["250","640","620","620","200","250","620","640","240","210","240","640","240"]},"The augmented stub  may detect loss of communication with the application component A or failure of node A. In response to such a failure, augmented stub  may select another stub from stub array , for example stub B. The node associated with the selected stub B, in this case node B, then becomes the failover node for recovering the required functionality of the application component. The augmented stub  may retry and\/or resume communications with the application component using stub B. This fail-over functionality of the augmented stub may occur transparently to client . For example, client  may be unaware of the fail-over to a different node in the cluster.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 7","b":"700"},"As shown in block , the augmented node may select a new stub from the stub array. The node corresponding to the selected stub may become the failover node to provide the application component functionality. The new stub may be selected randomly or by using a load balancing mechanism, or by any other selection technique. In one embodiment, the augmented stub may select the new stub based on a round robin method.","In another embodiment, the augmented stub may include data on cluster workload distribution, and may select a stub corresponding to the node whose workload is currently lightest. Regardless of the selection method, once the new stub has been placed into service, the augmented node may retry and\/or resume communication with the application component instance running on the failover node using the new stub, as shown in block . This fail-over may occur transparently to the client.","In order to successfully failover the application component from a failed node to a failover node, the augmented stub  may need to maintain data concerning the state of the cluster membership. In one embodiment augmented stub  may maintain node list . As described previously, node list  may include identification of all cluster nodes capable of providing the application component. Therefore, node list  represents a list of nodes that are candidates to assume the role of failover node in the event that the node currently being accessed should fail. Cluster membership may change with time as nodes fail or are removed from the cluster for other reasons. Additionally, failed nodes may recover and rejoin the cluster, or new nodes may be added to the cluster.","In another embodiment, the augmented stub may include a stub array  that may include stubs configured to connect to all nodes in cluster  that are capable of providing the application component, including the one that is currently being used to provide communications with an instance of the application component. As described in the previous paragraph, cluster membership may evolve with time, and stubs linked to failover candidates at one point may be invalid at another point, whereas when new failover candidate nodes join the cluster, corresponding stubs should be added to the stub array . One method of keeping the node list  or stub array  up to date may be through the use of a cluster membership state identifier (e.g. epoch number) as described below.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 8","b":["800","810"]},"As indicated in block , at some point in time a cluster node may receive a request from an augmented stub including an identifier (e.g. epoch number) indicating the configuration in which the augmented stub believes that cluster to be. This augmented stub's identifier may correspond to the membership of the node list  in one embodiment, or the stub array  in another embodiment. As indicate in block , the node may compare the received cluster membership identifier with its own identifier. For example, in an embodiment using epoch numbers as unique identifiers of cluster membership state, the node may compare the epoch number received from the augmented stub to its own epoch number. If the two identifiers differ, as determined in decision block , the node may return its copy of the cluster state data, or some subset thereof; to the augmented stub, as shown in block . In this way, node list  and\/or stub array  may be updated to reflect the current state of cluster membership. In an embodiment in which the augmented stub includes a stub array, the augmented stub may send a lookup request to a naming service to obtain a new stub for any new cluster members in order to update its stub array. In one embodiment, augmented stub  may send its cluster membership state identifier to a node each time the client accesses the node. In another embodiment, augmented stub  may send its epoch number to a node on a periodic or aperiodic basis, unassociated with client accesses.","Distributed applications components  may be either stateless or stateful. Graceful failover of a stateless application component may only require the instantiation of the component on the failover node since the new instance can immediately provide the same functionality as the failed instance.","Failing over a stateful application component in such a way that the client  is completely unaware of the failure, may be somewhat more complex. Apart from similar recovery of the application component instance on the failover node, the state of the application component must be restored on the new instance. Since access to a node's memory is lost with the failure of the node, graceful failover of a stateful application component may require that the component persist state data to a persistent store available to other nodes of the cluster, as updates to the state occur.","In one embodiment, an instance of application component  may persist its state data to persistent data storage  whenever a change occurs. In another embodiment, the container in which application component  is executing may be responsible for persisting changes to the application component state for that instance. In both of these cases, the persistent data store  may include the latest version of the application component state.","If the node executing a particular instance of application component  should fail, all the other nodes of the cluster may have access to its state data in persistent data store . Once the augmented stub associated with the failed instance has instantiated a new instance of the application component on another node, the new instance may be able to locate and access the state data of the failed instance using a primary key supplied by the augmented stub.","Some application component containers may provide only limited failover capability. In this case, whenever an instance of a stateful application component is created, a duplicate or mirror copy may be placed on another node in the same cluster. The duplicate may not be used unless the node running the primary fails, in which case the duplicate may assume the role of the primary and nominate another duplicate. Each time a transaction on the primary commits, its state is synchronized with that of the duplicate. If the primary instance should fail, augmented stub  may failover to the duplicate instance, which has the latest state data.","In one embodiment, augmented stub  may include functionality for load balancing the nodes of cluster  either instead of or in addition to the failover functionality described previously. When a client  requests a lookup for an application component , an augmented stub  may be returned, which includes a load balancing mechanism. Thereafter, when the client  makes a create( ) or find( ) request to that application component, the augmented stub  may use the included load balancing functions to determine to which node the request should be sent.","In addition to failover, another feature of a server cluster may be load balancing. Load balancing algorithms may range from simple round robin to schemes requiring data on the state cluster and each node therein.  illustrates cluster  wherein each node  may include a pluggable load-balancing framework , according to one embodiment. Pluggable load-balancing framework  may provide an API to support a pluggable custom load balancer . In one embodiment, the API may be based on JAVA. The API may allow access to support functions included in pluggable load-balancing framework  by any custom load balancer  written in compliance with the API. In this way the API may insure the pluggability of a custom load balancer  into a variety of components of a clustered computer system, as will be described below.","The pluggable load-balancing framework  may allow the administrator of the cluster to select a load balancer to be \u201cplugged in\u201d to the cluster from among different load balancers or to plug in a custom load balancer. Load balancers implementing a variety of load balancing algorithms such as random, round robin, weighted round robin, and load based the load-balancing framework , as accessed through the API, may provide a means of communication through which the load balancer may distribute requests to each node  of cluster . To support custom load balancers including more complex node selection algorithms, load-balancing framework  may provide a variety of functions through the API.","In one embodiment, nodes  of cluster  may include computers of differing capabilities, such as memory capacity or CPU speeds. In this case balancing the load among nodes  may include sending more jobs to the nodes with faster CPUs and fewer jobs to those with slower CPUs. In such a system, the load balancer  may include a weighted round robin selection algorithm. For example, if the computer of node A has a 200 MHz CPU; node B, 400 MHz; and node C, 800 MHz, the weighted round robin selection algorithm of load balancer  may determine that every seventh job be sent to node A, while two of every seven jobs go to node B, and four jobs go to node C. During initialization, custom load balancer  may send a query message conforming to the specification of the load-balancing framework API, to each node  requesting its capabilities, such as memory capacity or the speed of its CPU. The API-compliant load-balancing framework  in each node  may implement a function that will return the requested capability information in response to such a query. Custom load balancer  may use the information returned from each node  to establish the weighting values associated with the weighted round robin selection algorithm. Note that in some embodiments, a weight of zero may be assigned to some nodes in order that they may be reserved as backup nodes for failover purposes.","In another embodiment, custom load balancer  may implement a dynamic load-balancing algorithm based on node workload. Load balancer  may send an API-compliant load query message to all nodes  of the cluster  from time to time. The load-balancing framework of each node  may respond to the load query by executing one or more functions to produce information such as the number of jobs currently running on the node, the number of queued jobs awaiting execution, expected duration of jobs within the node, or many other types of information that may be used to assess the relative loading of the nodes. Custom load balancer  may use the loading information returned from each node  in its algorithm to determine to which node the job should be forwarded. In some embodiments, the custom load balancer  may poll nodes  for loading information on a periodic or aperiodic basis and may use the information to ratio its distribution of new jobs among nodes . In other embodiments, instead of load balancer  explicitly requesting information, each node may pass its loading information to the load balancer on a periodic or aperiodic basis. For example when the a node's loading changes by ten percent, it may send an update to this effect to the load balancer.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 10A","b":["1000","1010","1020"]},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 10B","b":["1050","1060"]},"As was stated previously, the provision of an API within the load-balancing framework  may allow a conforming custom load balancer  to be plugged into various components of a system including a node cluster.  illustrates various elements of the system that may include load-balancing functions, according to one embodiment. Information pertaining to load balancer  location and configuration may be specified in deployment descriptors  for each node. One location for load-balancing functions  is a separate, dedicated load balancer. The load balancer F may receive or intercept all requests to an application component running on cluster . For each request, the dedicated load balancer may execute its algorithm to determine to which of the cluster nodes the request should be routed.","In one embodiment, load-balancing functions  may be incorporated into naming service . Naming service  may provide the initial access point to the cluster for all clients . When a client  creates an initial context, a naming factory may return a cluster naming context rather than a standalone naming context. The cluster naming context may include a load balancer containing load-balancing functions . The load balancer may maintain current cluster membership and\/or node loading data, which it may obtain from the load-balancing framework of each node . When the client  performs a lookup on the cluster context, the load balancer may execute its algorithm and return a stub for the \u201cnext\u201d node. The term next node may be used to indicate the node selected by the load-balancing algorithm.","As described above load-balancing functions  may be included in an augmented stub. When an augmented stub receives a request to access the corresponding remote application component, the included load-balancing functions  may determine the next node to which the received request will be forwarded. The inclusion of load-balancing functions  in augmented stubs may therefore, result in method calls from a single client being distributed across many of the nodes  of cluster . Note that this may have significant implications on data integrity\/coherency in the case of stateful application components. For example, if a client generates many requests as part of a session and these requests are distributed by load-balancing functions  to several nodes of the cluster , then each cluster node must have access to the latest version of the state data for that particular session. In other embodiments, the augmented stub may employ \u201csticky\u201d load balancing such that requests for the same session are sent to the same node.","Load balancing may be performed by two distinct types of augmented stubs. In the first case, the augmented stub includes a single stub connected to the application component on one particular cluster node. When this augmented stub receives a request to access the application component, it may determine a next node to which the request is to be forwarded and replace its current stub with a stub connected to the next node, obtained from the naming service. The other type of augmented node may include stubs connected to each of the cluster nodes running the application component. When the client requests access to the application component, this augmented stub may also determine a next node to which the request will be forwarded. However, since this augmented stub already includes a stub connected to the next node, no access to the naming service is required.","An example of hierarchical load balancing may be manifest in embodiments in which load-balancing functions  are included in nodes . In such a system, an initial load balancer may distribute requests to the nodes  of cluster  according to an included algorithm. Each node  may include additional load-balancing functions . For example, if the node is running an application server including an EJB container, the load-balancing functions  may be included as a part of the EJB container.","The load-balancing functions  within each node  may monitor the request load on the node and when a certain threshold is reached, may divert received requests to another node of the cluster , according to an included algorithm. In one embodiment, this hierarchical load balancing may act as a \u201csafety valve\u201d to prevent imperfections in the primary load-balancing algorithm from inadvertently overloading a particular node . In another embodiment, the load-balancing functions  included in nodes  may provide the only load balancing in the system. For example, all requests sent to the application component may be received by node A. Node A may continue to receive and execute requests until some level of workload is reached. At that point node A may divert received requests to node B until its workload is reduced and it is once again able to process new requests. Likewise, if node B becomes overloaded, it may divert excess received requests to node C, and so on.","To support normal cluster operations such as load balancing, failover, and cluster reconfiguration a means for inter-nodal communications may be required. For example, to support load balancing and\/or failover, each node may require current information on cluster membership including existing nodes that have failed and\/or new nodes that have joined the cluster. When a cluster node fails, load-balancing functions such as those described previously may need to be aware of the failure so as not to send new requests to the failed node. Likewise, a failed node should be removed from the list of candidates for failover node for all other nodes. In one embodiment, each node may gather cluster membership information for itself, while in another embodiment one node may determine cluster membership and disseminate a list to other members.","The architecture of the cluster communication channel may take various forms from daisy chained, to star coupled, to rings, and bussed. Additionally, various communication protocols may be implemented for use on multiple network topologies. For purposes of maintaining current cluster membership information in each node, a peer-to-peer cluster communication channel is described below.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 12","b":["240","1200","240","1200","240","1200","240","1200","240","240","240","1200","1200","240","240"]},"In order to insure that the failure of a cluster node is detected within a given period of time, each node may occasionally or periodically communicate with every other node of the cluster using the socket connections. In one embodiment, a timer may be set to initiate a communication with a particular node if no other communication takes place with that node prior to the expiration of the timer. In this case, a node failure may go undetected for a maximum time equal to the period of the timer. If the timer is set to a relatively short interval, cluster members may detect the failure of a node at approximately the same time, and their membership data may be updated coherently. Because the cluster communication channel is peer-to-peer, each node may detect the failure based on its socket communication with the failed node and update its cluster membership data without the need for a central entity to manage cluster membership or passing an updated membership list from node to node.","A node joining the cluster may be detected as it makes a socket connection to each existing member. At startup, a node may obtain information on cluster membership and the cluster naming service from commonly accessible storage. With this information, the node may create socket connections to each cluster member based on the peer-to-peer nature of the cluster communication channel. When the joining node establishes a connection to a member node, it may add the name of the member node to its membership list. Likewise, the establishment of the connection may cause the member node to update its cluster membership data to include the joining node without the need to pass a membership list around the cluster. When communication has been attempted with each member node, the joining node may create a server socket and bind it to the naming service so that other nodes can perform lookups and connect to it.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 13","b":["1300","1310"]},"When a member node receives a request for connection from a joining node, it may establish the connection. If the joining node determines, at decision block , that the socket connection is successfully established, it may update its cluster membership information to include the name of the contacted node, as depicted in block . Likewise, the member node may update its cluster membership information to include the name of the joining node. If, however the joining node determines, at decision block , that the socket connection cannot be successfully established, it may update its cluster membership information to exclude the name of the targeted node, as depicted in block . By repeating this process for each target node, the joining node may build a list of active cluster members, while adding itself to the cluster membership data of each active member. When the joining node has attempted to establish socket connections with all member nodes, as determined at decision block , it may create a server socket and bind it to the naming service so that other nodes can perform lookups and connect to it, as shown in block .","As described previously, cluster member nodes may use the socket connections established at startup for cluster management communications to support functions such as failover and load balancing by maintaining accurate cluster membership data. Depending upon the frequency with which such communications occur and the required coherency of cluster membership data from one node to another, each node may periodically communicate with every other node in the cluster in order to determine its status.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 14","b":["1400","1410","1430","1420"]},"In addition to providing for independent detection of changes to cluster membership, the peer-to-peer cluster communication channel may facilitate other cluster management operations. For example, updating an existing application or adding a new application to a cluster may involve cloning or exact replication of resources to all nodes. In a cluster with a non peer-to-peer communication channel, changes to node configuration may have to be performed on a node-by-node basis. An administrator may access one node, change its configuration and then repeat this procedure for the other nodes in the cluster. This process may present significant opportunity for the administrator to fail to get the exact same configuration on each node. If the cluster is put into a state where resources have been added or updated on some nodes but not on others, system function and\/or data integrity may be compromised.",{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 15","b":["1510","1510","240","200","240","1510","1510","1500","240","1510","1510","240","200"]},"The cluster configuration service  in the node  on which the administrator is initiating changes may insure that those changes are propagated to the other nodes of the cluster  atomically. For example, if an administrator is using administrative console  to add an application component to node A, cluster configuration service A may communicate with cluster configuration services B and C for each step of the addition. At some point during the operation, cluster configuration service A may get a failure indication from a communication with cluster configuration service C. In response, cluster configuration service A may \u201crollback\u201d all changes made to nodes B and C as well as those made to node A and display and error message for the administrator.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 16A","b":["1600","1610","1620"]},"In response to the returns received from the requests to the responding cluster nodes, the cluster configuration service in the initiator node may determine whether the configuration change requests were successfully executed, as indicated by decision block . If all responses indicate success, the cluster configuration service may request that all cluster nodes make the change permanent, as shown in block . However, if it is determined at decision block  that one or more of the nodes cannot commit to making the change, the cluster configuration service may request that all cluster nodes rollback their configurations to the state prior to the change request, as illustrated in block .",{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 16B","b":["1605","1615","1625","1635","1625","1645"]},{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 17","b":["1700","1700","1710","1720","1725","1715","1715"]},"The computer system  preferably includes a memory medium on which computer programs according to various embodiments may be stored. The term \u201cmemory medium may include an installation medium, e.g., a CD-ROM, or floppy disk; a computer system memory such as DRAM, SRAM, EDO DRAM, SDRAM, DDR SDRAM, Rambus RAM, etc., or a non-volatile memory such as a magnetic media, e.g., a hard drive , or optical storage. The memory medium may include other types of memory as well, or combinations thereof. In addition, the memory medium may be located in a first computer in which the programs are executed, or may be located in a second different computer, which connects to the first computer over a network. In the latter instance, the second computer provides the program instructions to the first computer for execution.","Also, the computer system  may take various forms, including a personal computer system, mainframe computer system, workstation, network appliance, Internet appliance, personal digital assistant (PDA), television system or other device. In general, the term \u201ccomputer system\u201d can be broadly defined to encompass any device having a processor, which executes instructions from a memory medium. The memory medium preferably stores a software program or programs for event-triggered transaction processing as described herein. The software program(s) may be implemented in any of various ways, including procedure-based techniques, component-based techniques, and\/or object-oriented techniques, among others. For example, the software program may be implemented using ActiveX controls, C++ objects, JavaBeans, Microsoft Foundation Classes (MFC), or other technologies or methodologies, as desired.","Memory  may store program instructions accessed by the CPU . For example, instructions and data implementing a load-balancing framework  and\/or a cluster configuration service  may be stored in memory . Load-balancing framework  may facilitate the pluggability of a custom load balancer and the execution of load-balancing functions in a system including a server cluster. Cluster configuration service  may insure that changes to the configuration of cluster nodes are made atomically.","Computer system  may further include other software and hardware components, such as an input\/output (I\/O) interface , that may be coupled to various other components and memory . The CPU  may acquire instructions and\/or data through the I\/O interface . Through the I\/O interface , the CPU  may also be coupled to one or more I\/O components. As illustrated, I\/O components may include a hard disk drive , a network adapter , a display adapter  and\/or a removable storage adapter . Some components  to  may be coupled to the I\/O interface . In addition, the computer system  may include one or more of a particular type of component. The computer system  may include one or more components coupled to the system through a component other than the I\/O interface . Some computer systems may include additional and\/or other components such as application software (e.g., stored in memory ), other CPUs, video monitors or other displays, track balls, mice, keyboards, printers, plotters, scanners, or other types of I\/O devices for use with computer system .","Various embodiments may further include receiving, sending or storing instructions and\/or data implemented in accordance with the foregoing description upon a carrier medium. Generally speaking, a carrier medium may include storage media or memory media such as magnetic or optical media, e.g., disk or CD-ROM, volatile or non-volatile media such as RAM (e.g. SDRAM, DDR SDRAM, RDRAM, SRAM, etc.), ROM, etc. as well as transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network and\/or a wireless link.","The flow charts described herein represent exemplary embodiments of methods. The methods may be implemented in software, hardware, or a combination thereof. The order of method may be changed, and various elements may be added, reordered, combined, omitted, modified, etc.","Various modifications and changes may be made to the invention as would be obvious to a person skilled in the art having the benefit of this disclosure. It is intended that the following claims be interpreted to embrace all such modifications and changes and, accordingly, the specifications and drawings are to be regarded in an illustrative rather than a restrictive sense.","Various embodiments may further include receiving, sending or storing instructions and\/or data implemented in accordance with the foregoing description upon a computer readable medium. Generally speaking, a computer readable medium may include storage media or memory media such as magnetic or optical media, e.g., disk or CD-ROM, volatile or non-volatile media such as RAM (e.g. SDRAM, DDR SDRAM, RDRAM, SRAM, etc.), ROM, etc. as well as transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network and\/or a wireless link."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 10A"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 10B"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 15","b":"1510"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 16A"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 16B"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 17"}]},"DETDESC":[{},{}]}
