---
title: System, method, and computer program product for a tessellation engine using a geometry shader
abstract: A method, system, and computer program product are disclosed for providing tessellated primitive data to a geometry shader. The method comprises computing a set of tessellated vertices and a computed set of connectivity data based on an original set of vertices and an original set of connectivity data, generating computed vertex data based on the original set of vertices and the set of tessellated vertices, receiving the computed set of connectivity data, requesting a subset of the computed vertex data based on the computed set of connectivity data, and processing primitives defined by the subset of the computed vertex data. The system and computer program product are further disclosed for accomplishing a similar result as the aforementioned method.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08836700&OS=08836700&RS=08836700
owner: Advanced Micro Devices, Inc.
number: 08836700
owner_city: Sunnyvale
owner_country: US
publication_date: 20090527
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present application claims the benefit of U.S. Provisional Application No. 61\/056,936, filed on May 29, 2008, titled \u201cSystem, Method, and Computer Program Product for a Tessellation Engine Using a Geometry Shader\u201d, which is incorporated herein by reference in its entirety.","1. Field of the Invention","The present invention relates generally to optimizing tessellation operations in a graphics processing unit.","2. Background","A graphics processing unit (GPU) is a special-purpose integrated circuit optimized for graphics processing operations. A GPU is often incorporated into computing devices (e.g., personal computers, rendering farms or servers, handheld devices, digital televisions, etc.) used for executing applications with demanding graphics processing needs, such as, for example, video game applications.","In most modern GPU implementations, the processing of graphics operations is broken into various functional units, each located within a different stage of a processing pipeline. Typically, input to the GPU is in the form of a set of vertices as well as some connectivity information identifying how the vertices are connected to each other. A set of vertices coupled with connectivity information for that set of vertices defines a geometric primitive. Often, the geometric primitive of choice is a triangle, which is defined by three vertices and three edges, the edges represented as connectivity information.","As each geometric primitive is processed by the GPU for rendering, individual vertices are processed by a vertex shader. The vertex shader is generally used to perform operations that apply to individual vertices. Examples of these operations include transform operations and lighting operations. As a result of these operations, data regarding a computed vertex position, the color of the primitive at that vertex, and texture coordinates at that vertex for texture mapping are generally computed.","After computations involving individual vertices are performed, an additional stage of the pipeline may perform operations on primitives as a whole. This stage, commonly referred to as the geometry shader, can apply graphics techniques to an entire primitive, potentially resulting in the creation of additional primitives. For example, a geometry shader can be used to apply a displacement map, for repositioning the vertices, or for applying fur and fin techniques.","Upon completion of the geometry shader stage, the output is commonly sent to a rasterizer for conversion into a two-dimensional image, and further enhancements can be performed by a pixel shader.","The techniques performed by the geometry shader typically result in the creation of additional primitives for the purpose of enhancing the appearance of a rendered object. By applying a displacement map, for example, additional primitives are generated in order to provide additional vertices, which are then displaced according to a texture bitmap. Generally, as more primitives are used in the computation of the technique, the smoother and more realistic the final object will appear. However, providing too many vertices can overwhelm the vertex and geometry shaders, and may not result in a noticeably improved rendering of the object, particularly when the object being rendered is located at a significant distance from the viewing plane.","Prior implementations have relied on using a tessellation engine to increase the number of primitives immediately prior to the vertex shader stage. For example, commonly-owned U.S. Patent Application Publication No. 2004\/0085312 to Buchner et al. (application Ser. No. 10\/287,143), which is herein incorporated by reference in its entirety, discloses a method and apparatus for performing such tessellation. However, previous implementations have simply allowed for output from the tessellation engine to be processed by the vertex shader, then transmitted to the rasterizer for rendering to the display. If a developer using a prior implementation wanted to increase the primitive count by tessellating the primitives, then running the tessellated primitives through the geometry shader, it was necessary to store the tessellated output somewhere in memory. The developer would then need to re-run the GPU pipeline on the tessellated data in order to allow the geometry shader to perform its computations on the tessellated data.","Accordingly, what are needed are improved techniques to reduce the rendering costs attributed to tessellation when further processing tessellated data in a geometry shader.","Embodiments of the invention include a method for providing tessellated primitive data to a geometry shader. The method comprises computing a set of tessellated vertices and a computed set of connectivity data at a tessellation engine based on an original set of vertices and an original set of connectivity data, generating computed vertex data at a vertex shader based on the original set of vertices and the set of tessellated vertices, receiving the computed set of connectivity data at the geometry shader, requesting, at the geometry shader, a subset of the computed vertex data based on the computed set of connectivity data, and processing primitives defined by the subset of the computed vertex data.","Embodiments of the invention additionally include a graphics processing unit for providing tessellated primitive data to a geometry shader. The graphics processing unit comprises a tessellation engine for computing a set of tessellated vertices and a computed set of connectivity data based on an original set of vertices and an original set of connectivity data, a vertex shader for generating computed vertex data based on the original set of vertices and the set of tessellated vertices, and the geometry shader for receiving the computed set of connectivity data, requesting a subset of the computed vertex data based on the computed set of connectivity data, and processing primitives defined by the subset of the computed vertex data.","Embodiments of the invention further include a computer program product comprising a computer-usable medium having computer program logic recorded thereon for enabling a processor to provide tessellated primitive data to a geometry shader. The computer program logic comprises instructions and\/or data enabling the processor to: compute a set of tessellated vertices and a computed set of connectivity data at a tessellation engine based on an original set of vertices and an original set of connectivity data, generate computed vertex data at a vertex shader based on the original set of vertices and the set of tessellated vertices, receive the computed set of connectivity data at the geometry shader, request, at the geometry shader, a subset of the computed vertex data based on the computed set of connectivity data, and process primitives defined by the subset of the computed vertex data.","Further features and advantages of the invention, as well as the structure and operation of various embodiments of the invention, are described in detail below with reference to the accompanying drawings. It is noted that the invention is not limited to the specific embodiments described herein. Such embodiments are presented herein for illustrative purposes only. Additional embodiments will be apparent to persons skilled in the relevant art based on the teachings contained herein.","Introduction","The following detailed description of the present invention refers to the accompanying drawings that illustrate exemplary embodiments consistent with this invention. Other embodiments are possible, and modifications can be made to the embodiments within the spirit and scope of the invention. Therefore, the detailed description is not meant to limit the invention. Rather, the scope of the invention is defined by the appended claims.","It would be apparent to one of skill in the art that the present invention, as described below, can be implemented in many different embodiments of software, hardware, firmware, and\/or the entities illustrated in the figures. Any actual software code with the specialized control of hardware to implement the present invention is not limiting of the present invention. Thus, the operational behavior of the present invention will be described with the understanding that modifications and variations of the embodiments are possible, given the level of detail presented herein. Additionally, and as will be apparent to one of ordinary skill in the art, the simulation, synthesis and\/or manufacture of the various embodiments of this invention may be accomplished, in part, through the use of computer readable code (as noted above), including general programming languages (such as C or C++), hardware description languages (HDL) including Verilog HDL, VHDL, Altera HDL (AHDL) and so on, or other available programming and\/or schematic capture tools (such as circuit capture tools). This computer readable code can be disposed in any known computer usable medium including semiconductor, magnetic disk, optical disk (such as CD-ROM, DVD-ROM) and as a computer data signal embodied in a computer usable (e.g., readable) transmission medium (such as a carrier wave or any other medium including digital, optical, or analog-based medium). As such, the code can be transmitted over communication networks including the Internet and Internets. It is understood that the functions accomplished and\/or structure provided by the systems and techniques described above can be represented in a core (such as a GPU core) that is embodied in program code and may be transformed to hardware as part of the production of integrated circuits.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 1","b":["100","100","102","104","106","108"]},"In a typical use of GPU pipeline , a graphics application provides vertex shader  with a set of vertices and a set of connectivity data. Together, this set of vertices and the set of connectivity data define an object or a scene to be rendered.","The vertex shader  is operable to manipulate the set of vertices to perform per-vertex operations. These operations include, for example, transform operations and lighting operations. The vertex shader allows a graphics application to manipulate an object to be rendered by, for example, moving the object within a scene by adding an offset to each of the vertices that comprise the object. As an example, if a graphics application wanted to move an object to be rendered by five units along the x-axis in x,y,z-space, the vertex shader would be useful in computing a +5 offset to the x-coordinate of each vertex comprising the object, resulting in the movement of the entire object to the new offset location. In accordance with an embodiment of the present invention, such computations are accomplished by issuing a single-instruction multiple-data (\u201cSIMD\u201d) instruction to the GPU pipeline .","Geometry shader  obtains the manipulated vertex set and the set of connectivity data from the vertex shader in preparation for further manipulation. The geometry shader  is configured to operate on simple geometric shapes known as primitives. While primitives may be any set of vertex data and the connectivity data between the vertices in that set, most geometry shader  implementations operate primarily on triangles. Triangles are defined by three vertices and the connectivity data between those three vertices. The geometry shader  can be used, for example, to apply a displacement map, for repositioning the vertices in a set of primitives, or for applying fur and fin techniques to a set of primitives.","The result of the geometry shader  applying the aforementioned techniques may be the creation of additional vertices and connectivity data, therefore forming additional primitives. For example, the application of a displacement map may result in the generation of additional vertices, and corresponding connectivity data, in order to displace areas of an object where vertices may not have previously been located.","The techniques applied at the vertex shader  and geometry shader  tend to benefit from higher primitive counts as an input to the geometry shader , resulting in smoother, more complex objects. Accordingly, it is beneficial to use high-order surfaces as inputs to the GPU pipeline  in order to obtain better results from the application of the primitive-manipulation techniques at the vertex shader  and geometry shader .","Rasterizer  takes the final vertex set and connectivity data set and, based on a viewing plane, determines what a scene comprising the vertex set and connectivity data set would look like if rendered in two dimensions from the corresponding point of view. This rendered scene, typically comprising a set of picture elements (\u201cpixels\u201d) ready for display on a two-dimensional display device, is then sent to pixel shader  for additional processing on a per-pixel level.","As previously noted, it is generally beneficial when performing processing of primitives within GPU pipeline  to have additional primitives to work with, for the purposes of image quality.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 2","b":["200","200","203","104","106","108","100","202"]},"Tessellation engine  is operable to take a vertex data set and connectivity data set and tessellate the resulting primitives, providing a new vertex data set and new connectivity data to vertex shader  for further processing. Commonly-owned U.S. Patent Application Publication No. 2004\/0085312 to Buchner et al. (application Ser. No. 10\/287,143), which is herein incorporated by reference in its entirety, discloses a method and apparatus for performing such tessellation. The output of tessellation engine  is then sent to the vertex shader  as in the traditional pathway, allowing the vertex shader  to compute a new set of vertices and store them within an evaluation shader . Rasterizer  could subsequently retrieve the vertices from evaluation shader  and continue operations as before.","In this implementation it is not possible to perform geometry shader operations on a tessellated output within the pipeline , as there is no means by which the tessellated output could be retrieved by the geometry shader . Accordingly, in order to apply the geometry shader  techniques to tessellated data, it would be necessary to store the tessellated data somewhere in memory and restart the pipeline  using the tessellated data as an input to vertex shader  to pass the data to geometry shader .","Optimized GPU Pipeline with Tessellation",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 3","b":["300","300","202","102","204","104","106","108"]},"Tessellation engine  is operable to retrieve (or receive) a set of vertices and a set of connectivity information from a memory location (not shown), in accordance with an embodiment of the present invention. Applying a tessellation technique, such as the one described in commonly-owned U.S. Patent Application Publication No. 2004\/0085312 to Buchner et al. (application Ser. No. 10\/287,143), which is herein incorporated by reference in its entirety, allows the tessellation engine to generate tessellated primitives, in accordance with an embodiment of the present invention.","In accordance with an additional embodiment of the present invention, application of the tessellation technique at the tessellation engine  results in the output of the original vertices for the original input primitives as well as tessellated vertices. New connectivity information is generated by the tessellation engine corresponding to the original vertices and the tessellated vertices. The tessellated vertices are output, in the exemplary embodiment, as barycentric coordinates.","As shown in , the output from tessellation engine  is transmitted to both geometry shader  and vertex shader . In accordance with an embodiment of the present invention, tessellation engine  transmits the computed vertex set, comprising original vertices as well as tessellated vertices, to vertex shader . Vertex shader  is operable to compute vertex values for the computed vertex set, in accordance with an embodiment of the present invention. In accordance with an additional embodiment of the present invention, vertex shader  is operable to perform additional vertex operations on the vertices of the computed vertex set such as, for example, a transformation operation. One skilled in the relevant arts will appreciate that the functionality of the vertex shader includes well-known techniques for vertex-level manipulation. When all changes on the computed vertex set are performed, the computed vertex set is written to evaluation shader . In accordance with an embodiment of the present invention, evaluation shader  comprises a ring buffer to which the computed vertex set is written.","Tessellation engine  further transmits the connectivity data of all vertices, both original and tessellated, directly to geometry shader . Geometry shader  is then operable to use this connectivity data to obtain the vertices corresponding to a primitive defined by a subset of the connectivity data, in accordance with an embodiment of the present invention. Geometry shader  retrieves the vertex data from evaluation shader , where it has been stored by vertex shader , in accordance with an embodiment of the present invention.","Communication flow diagram  of  further illustrates this process in accordance with an embodiment of the present invention. Flow diagram  shows the communications between tessellation engine , vertex shader , evaluation shader , and geometry shader . After performing tessellation, tessellation engine  transmits the original and tessellated vertex set to vertex shader  at step . Upon computing the computed vertex set, vertex shader  stores the computed vertex set at evaluation shader  at step . Furthermore, tessellation engine  transmits the computed connectivity data for all vertices directly to geometry shader  at step .","With the connectivity data in hand, geometry shader  then requests the set of vertices corresponding to a primitive defined by the connectivity data at step , in accordance with an embodiment of the present invention. Evaluation shader  then provides the requested vertices at step . Geometry shader  is then operable to perform primitive-level operations on the vertices returned at step .","Method of Operation",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 5","FIG. 3"],"b":["500","300","501","502"]},"In accordance with an embodiment of the present invention, tessellation is only applied when a certain threshold has been met. This threshold could be, for example, the distance of an object being rendered from a viewing plane, the curvature of the object, or other criteria. One skilled in the relevant arts will recognize that other thresholds exist for optimizing the complexity of a rendered object relative to the ability of a user of a graphics application to perceive the complexity. Moreover, the threshold is modified, in accordance with an embodiment of the present invention, based on considerations such as the computational ability of the particular GPU pipeline , the display area, and user preferences. If tessellation is not requested at step , the method proceeds at step  without performing tessellation.","At step , tessellation is performed in the tessellation engine , with the tessellation engine  computing tessellated vertices and generating new connectivity data defining connections between all vertices, both original and tessellated. At step , the vertex shader  computes modified vertex data, in accordance with an embodiment of the present invention. As previously disclosed, vertex shader  receives the original and the tessellated vertex set at step  of  from the tessellation engine , on which vertex shader  is operable to generated the computed vertex set at step . In accordance with an additional embodiment of the present invention, the computed vertex set is stored in evaluation shader .","The method proceeds to step , where the geometry shader  receives the connectivity data from tessellation engine . At step , the geometry shader  identifies the primitives corresponding to the connectivity data and retrieves the corresponding vertices. In accordance with an embodiment of the present invention, geometry shader  retrieves the vertices from evaluation shader , where they have been stored by vertex shader . Geometry shader  then performs primitive-level operations on the retrieved primitives, and the method ends at step .","Computer System Implementation","Various aspects of the present invention can be implemented by software, firmware, hardware, or a combination thereof.  illustrates an example computer system  in which the present invention, or portions thereof, can be implemented as computer-readable code. For example, the methods illustrated by flowchart  of  can be implemented in system . Various embodiments of the invention are described in terms of this example computer system . After reading this description, it will become apparent to a person skilled in the relevant art how to implement the invention using other computer systems and\/or computer architectures.","Computer system  includes one or more processors, such as processor . Processor  can be a special purpose or a general purpose processor. Processor  is connected to a communication infrastructure  (e.g., a bus or network).","Computer system  also includes a main memory , preferably random access memory (RAM), and can also include a secondary memory . Secondary memory  can include, for example, a hard disk drive , a removable storage drive , and\/or a memory stick. Removable storage drive  can comprise a floppy disk drive, a magnetic tape drive, an optical disk drive, a flash memory, or the like. The removable storage drive  reads from and\/or writes to a removable storage unit  in a well known manner. Removable storage unit  can comprise a floppy disk, magnetic tape, optical disk, etc. which is read by and written to by removable storage drive . As will be appreciated by persons skilled in the relevant art, removable storage unit  includes a computer-usable storage medium having stored therein computer software and\/or data.","In alternative implementations, secondary memory  can include other similar means for allowing computer programs or other instructions to be loaded into computer system . Such means can include, for example, a removable storage unit  and an interface . Examples of such means can include a program cartridge and cartridge interface (such as those found in video game devices), a removable memory chip (e.g., EPROM or PROM) and associated socket, and other removable storage units  and interfaces  which allow software and data to be transferred from the removable storage unit  to computer system .","Computer system  can also include a communications interface . Communications interface  allows software and data to be transferred between computer system  and external devices. Communications interface  can include a modem, a network interface (such as an Ethernet card), a communications port, a PCMCIA slot and card, or the like. Software and data transferred via communications interface  are in the form of signals which can be electronic, electromagnetic, optical, or other signals capable of being received by communications interface . These signals are provided to communications interface  via a communications path . Communications path  carries signals and can be implemented using wire or cable, fiber optics, a phone line, a cellular phone link, a RF link or other communications channels.","In this document, the terms \u201ccomputer program medium\u201d and \u201ccomputer-usable medium\u201d are used to generally refer to media such as removable storage unit , removable storage unit , and a hard disk installed in hard disk drive . Signals carried over communications path  can also embody the logic described herein. Computer program medium and computer-usable medium can also refer to memories, such as main memory  and secondary memory , which can be memory semiconductors (e.g., DRAMs, etc.). These computer program products are means for providing software to computer system .","Computer programs (also called computer control logic or data and\/or instructions) are stored in main memory  and\/or secondary memory . Computer programs can also be received via communications interface . Such computer programs, when executed, enable computer system  to implement the present invention as discussed herein. In particular, the computer programs, when executed, enable processor  to implement the processes of the present invention, such as the steps in the methods illustrated by flowchart  of , discussed above. Accordingly, such computer programs represent controllers of the computer system . Where the invention is implemented using software, the software can be stored in a computer program product and loaded into computer system  using removable storage drive , interface , hard drive  or communications interface .","The invention is also directed to computer program products comprising software stored on any computer-usable medium. Such software, when executed in one or more data processing device, causes a data processing device(s) to operate as described herein or, as noted above, allows for the synthesis and\/or manufacture of computing devices (e.g., ASICs, or processors) to perform embodiments of the present invention described herein. Embodiments of the invention employ any computer-usable or -readable medium, known now or in the future. Examples of computer-usable mediums include, but are not limited to, primary storage devices (e.g., any type of random access memory), secondary storage devices (e.g., hard drives, floppy disks, CD ROMS, ZIP disks, tapes, magnetic storage devices, optical storage devices, MEMS, nanotechnological storage devices, etc.), and communication mediums (e.g., wired and wireless communications networks, local area networks, wide area networks, intranets, etc.).","Application-Level Implementation",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 7","b":["700","702","702","704","706","704"]},"The various APIs may further interact with an abstraction layer commonly provided by a graphics hardware manufacturer to interact with the specific graphics hardware, namely graphics hardware drivers . The various levels of communication are received by the operating system kernel , which then sends the appropriate messages to graphics hardware .","In accordance with an embodiment of the present invention, the aforementioned graphics pipeline  of  is implemented within graphics hardware . In accordance with an additional embodiment of the present invention, graphics hardware drivers  and graphics API  are optimized to use the tessellation features of graphics pipeline .","Conclusion","While various embodiments of the present invention have been described above, it should be understood that they have been presented by way of example only, and not limitation. It will be understood by those skilled in the relevant art that various changes in form and details can be made therein without departing from the spirit and scope of the invention as defined in the appended claims. It should be understood that the invention is not limited to these examples. The invention is applicable to any elements operating as described herein. Accordingly, the breadth and scope of the present invention should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated herein and form a part of the specification, illustrate embodiments of the present invention and, together with the description, further serve to explain the principles of the invention and to enable a person skilled in the relevant art to make and use the invention.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7"},"Further features and advantages of the invention, as well as the structure and operation of various embodiments of the invention, are described in detail below with reference to the accompanying drawings. It is noted that the invention is not limited to the specific embodiments described herein. Such embodiments are presented herein for illustrative purposes only. Additional embodiments will be apparent to persons skilled in the relevant art based on the teachings contained herein."]},"DETDESC":[{},{}]}
