---
title: System and method for coordinating access to data for a distributed application
abstract: A system and method for controlling access to data in a distributed computer system. Distributed Token Manager (DTM) is a system-level service that coordinates read/write access of data objects (tokens) in a multi-process and multi-threaded environment. The DTM ensures that at any given time either: 1) One or more client processes or threads currently have read access rights to the data object, and no client processes or threads currently have write access rights to the data object; or 2) One client process or thread currently has write access to the data object and no other client processes or threads currently have read or write access rights to the data object. DTM also ensures that such coordination works smoothly even in the case of process/machine/network failure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07130905&OS=07130905&RS=07130905
owner: Sun Microsystems, Inc.
number: 07130905
owner_city: Santa Clara
owner_country: US
publication_date: 20020110
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["1. Field of the Invention","The present invention relates to the field of distributed software applications, and more particularly to a system and method for coordinating access to data in a distributed computer system.","2. Description of the Related Art","In the software arts, the problem of coordinating multiple threads or processes to share data or resources often arises. For example, when one process or thread is writing to data, other processes or threads may need to be prevented from writing to the same data at the same time in order to prevent data errors from occurring. Also, processes or threads may need to be prevented from reading from the data while it is being written to, in order to ensure that partial or incorrect data is not read.","Another aspect of coordinating the execution of multiple threads or processes pertains to forcing a series of operations to be performed atomically. For example, consider an application where one process updates a static data structure containing X and Y coordinates for items to be displayed by another process. If the update process alters the X coordinate for an item and is preempted before it can change the Y coordinate, the display process attempt to display the item before the Y coordinate is updated, resulting in the item being displayed at the wrong location.","Various types of \u201csynchronization objects\u201d have been used in synchronizing execution among multiple threads. For example, one type of synchronization object is a mutex. A mutex (short for mutual exclusion) may be used to guarantee exclusive access to shared data or a shared resource, typically by controlling access to the data or resource through \u201clock\u201d and \u201cunlock\u201d operations. For example, a first thread may lock (acquire) a mutex indicating that the corresponding data or resource is in use before performing an update. The first thread may then unlock (release) the mutex after the data or resource has been updated. Any other threads must wait for the mutex to be unlocked before updating the data or resource. This technique of waiting for a mutex is often called \u201cblocking\u201d on a mutex because the thread is blocked and cannot continue until the mutex is released. Other types of synchronization objects known in the prior art include semaphores and queues.","Programmers often find it difficult to properly implement execution synchronization using synchronization objects. One reason for this is that the programmer is typically responsible for coding and managing execution synchronization at a relatively low level. This responsibility may include: properly releasing synchronization objects; defining and implementing timeout behavior when waiting to acquire a synchronization object; etc. In a complex application, this can require a significant amount of detailed work on the part of the programmer and can be difficult to accomplish.","Thus, execution synchronization can be difficult to implement correctly and serious problems can arise when not implemented correctly. Therefore, an improved system and method for synchronizing execution of software activities is desired. It would be desirable for the improved system and method to simplify the task of implementing execution synchronization for an application. In particular, it would be desirable to abstract this task so that the programmer can work at a more intuitive level, e.g., using an application programming interface (API) to perform the synchronization.","In addition, various systems may not provide a solution for coordinating access to distributed data in a highly distributed environment with multiple processes and threads accessing the distributed data. For example, consider the problem of a distributed application implemented over a cluster of application servers, such as a large-scale web application. It would be desirable to provide a system and method for coordinating access to distributed data for such an application. It would also be desirable for the system and method to ensure that that the coordination works smoothly even in the case of process, machine, or network failure.","A system and method for coordinating access to data in a distributed computer system is provided. A Distributed Token Manager (DTM) service may manage a collection of \u201ctokens\u201d (also referred to herein as \u201cdata objects\u201d) for which access may be controlled using access rights. As used herein, the term \u201ctoken\u201d or \u201cdata object\u201d may refer to a portion of data stored in memory of a computer system. Each token or data object may comprise data of any kind and may be structured or formatted in any of various ways.","One example of a token is HTTP session data or a portion of HTTP session data. Another example of a token is IIOP session data. Another example of a token is a component or object having callable methods or functions, such as a JavaBean, a Component Object Model (COM) object, a Common Object Request Broker Architecture (CORBA) object, etc.","In a distributed system, the tokens may be stored in memory of any computer of the system. For example, with respect to a distributed system comprising a cluster of application server computers, the tokens may be stored on one of the application servers, on a web server coupled to the application servers, in a database coupled to the application servers, in a backend system coupled to the application servers, etc. The tokens may be stored on the same or on different computers. Also, the tokens may vary in kind. For example, some tokens may represent HTTP session data for various end users, whereas other tokens may be executable components or objects.","A thread or process may be required to interface with the DTM service to acquire access rights before accessing a token. The thread or process may be required to acquire access rights for each token it needs to access. Thus, if the thread or process needs to access Token A as well as Token B, the thread or process may need to acquire access rights for each respective token. In one embodiment, there may be different types of access rights corresponding to different types of access to the tokens. For example, for read access of a token, the thread or process may need read access rights, whereas for write access of a token, the thread or process may need write access rights.","The DTM service may provide an application programming interface (API) through which clients can request to acquire and release access rights. For example, the DTM API may include a Lock( ) and an Unlock( ) method for these purposes. For any given token, the DTM may operate to ensure that one of the following statements is true at any given time: 1) One or more client processes or threads currently have read access rights to the token and no client processes or threads currently have write access rights to the token; or 2) One client process or thread currently has write access to the token and no other client processes or threads currently have read or write access rights to the token. In one embodiment of the second case, the single client process or thread with write access rights to the token may simultaneously have read access rights to the token. The DTM may maintain state information indicating which clients currently hold which access rights to which tokens to ensure that these conditions are met.","The system may also include a DTM backup service. The DTM backup service may be designed to perform backup of state information of the DTM service. In the event that the DTM service itself becomes unavailable (e.g., due to a failure of the computer system in which the DTM service executes), the DTM backup service can become the DTM service.","In one embodiment, each Lock( ) method call may be implemented as a synchronous message communication between a client and the DTM service, and each Unlock( ) method call may be implemented as an asynchronous message communication from a client and the DTM service. Thus, when a client calls the Unlock( ) method to release access rights, the client may immediately interface with the DTM service, and the DTM service may update its data to indicate that the client no longer holds the access rights for the token. This may be referred to as an \u201cactive\u201d model.","For certain services and applications, especially those that perform mostly read access and seldomly perform write access, such communication overhead may not be necessary. Thus, in another embodiment, a \u201clazy model\u201d may be utilized, wherein the DTM service may perform \u201clazily reclamation\u201d of access rights. For lazily reclaimed access rights, the client may not actively interface with the DTM service when Lock( ) and Unlock( ) methods are called. Instead, the DTM service reclaims the access rights when necessary, e.g., when another client needs the access rights. This may substantially reduce communication overhead between the client and the DTM service.","While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and are herein described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.","FIG. \u2014Web Application Architecture",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 1","FIG. 1"]},"In general, a web application may be defined as an Internet or Intranet-based application comprising a collection of resources that are accessible through uniform resource locators (URLs). The resources may include web pages comprising HTML, XML, scripting code such as Javascript or VBScript, or other types of elements. The resources may also include any of various types of executable programs or components, such as CGI programs, Java servlets, JavaBeans components, CORBA components, downloadable code such as Java classes or ActiveX components, etc. The resources may also include any other type of resource addressable through a URL.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 1","b":"100"},"The web browser may run in any type of client computer . For example, the web browser may run in a desktop computer or workstation running any of various operating systems, such as Windows, Mac OS, Unix, etc., or the web browser may run in a portable computing device, such as a personal data assistant, smart cellular phone, etc. The client computer  may use a network connection for communicating with a web server  via a network , such as the Internet or an Intranet. The client network connection may be a connection of any type, such as a PPP or SLIP dialup link, an Ethernet or token ring connection, an ISDN connection, a cable modem connection, any of various types of wireless connections, etc. Although web applications are often associated with particular communication protocols, such as HTTP or SSL, it is noted that any communication protocol, including TCP-based protocols and UDP-based protocols, may be used to communicate over the network .","As the web server  receives a request from a client computer , the web server may treat the request differently, depending on the type of resource the request references. For example, if the request references a document , such as an HTML document, then the web server may process the request itself, e.g., by retrieving the document from the web server's local file system or from a local cache and returning the document to the client computer. For other types of requests, e.g., requests referencing executable components, such as Java servlets, JavaBeans components, C program modules, CORBA components, etc., the web server may broker the request to an application server . For example, as shown in , there may be a plurality of application servers , and the web server may select an application server to which to broker the request, e.g., using load balancing techniques. The web server  may interface with an application server  using various techniques, e.g., through an in-process extension, such as an ISAPI or NSAPI extension.","The application server  may be configured as a part of an application server cluster. Although  illustrates an application server cluster with only two application servers, it is noted that the cluster may comprise any number of application servers. Each application server may interface with various types of other servers or systems. For example, as illustrated in , the application servers may communicate with a database . Each application server in the cluster may interface with the same systems, or the application servers may differ in which systems they interface with. For example, application server B is shown to interface with a backend system , e.g., a CICS, R\/3, PeopleSoft, or other type of backend system. For example, the backend system  may be responsible for managing enterprise data or performing business functions for an enterprise.","Application servers in a cluster may or may not be in close physical proximity to each other. The application server computers may be connected to each other in any of various ways. For example, in one embodiment, each application server computer may be a member of a single local area network (LAN). In another embodiment, various of the application server computers may be located in two or more LANs, wherein the LANs are networked together.","In alternative embodiments, a client computer may communicate directly with an application server or application server cluster, without interfacing through a web server. As one example, the application servers may run an enterprise resource planning application, and the client computer  may be a computer within the enterprise that is connected to the application servers  via a WAN. In this example, the client computer may run \u201cthick client\u201d software, e.g., client software that comprises a portion of the enterprise resource planning application logic. The client computer software may interface directly with executable programs or components running on the application servers, e.g., through a protocol such as the Internet Inter-Orb Protocol (IIOP).","As noted above,  represents an exemplary architecture only, and many variations are possible. As a small handful of examples of alternative embodiments, multiple web servers may be present to receive requests from client computers and broker the requests to application servers, the web server may itself interface directly with a database, application servers may interface with various other types of systems, such as specialized authentication servers, e-commerce servers, other types of legacy systems, etc.","In a distributed application such as shown in , multiple threads or processes may access the same data. The multiple threads or processes may execute on the same and\/or on different computer systems. For example, two processes which execute respectively on application server A and B may each access the same data. This data may be stored in any of various locations, such as on one of the application servers A or B, in the database , in the backend system , on the web server , etc. As described below, access to the data may be coordinated among the multiple threads or processes by associating access rights with the data. To access the data, a thread or process may be required to first acquire the appropriate access rights.","One example of a type of data for which access may be controlled in this manner is HTTP session data. As well known in the art, such session data may be used to track end users of a web application, i.e., users of client computers such as the client computer  illustrated in . Consider a case in which an end user submits a first request requiring the session data to be changed. The first request may be directed to the application server A. If the end user then submits a second request requiring the session data to be changed, the request may be load-balanced such that the second request may be directed to the application server B. If the two requests are received or processed closely together in time, the result may be that a first process on application server A and a second process on application server B attempt to write changes to the session data simultaneously, causing the session data to be corrupted. However, this problem may be avoided if each process is required to first acquire access rights to the session data before the process can access the session data.","Access for any of various other types of data may also be controlled in this manner. One example is IIOP session data. Another example is a stateful component or object, such as an Enterprise JavaBean. For example, a process may be required to acquire access rights before invoking methods or functions (or before invoking certain of the methods or functions) of the component or object.","FIGS. A and B\u2014Shared Tokens",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 2A","b":["204","204"]},"One example of a token  is HTTP session data or a portion of HTTP session data. Another example of a token  is IIOP session data. Another example of a token  is a component or object having callable methods or functions, such as a JavaBean, a Component Object Model (COM) object, a Common Object Request Broker Architecture (CORBA) object, etc.","In a distributed system, the tokens  may be stored in memory of any computer of the system. For example, with respect to the distributed system of , the tokens  may be stored on one of the application servers A or B, on the web server , in the database , or in the backend system . The tokens  may be stored on the same or on different computers. For example, a first plurality of tokens  may be stored on the application server A, and a second plurality of tokens  may be stored on the application server B. Also, the tokens  may vary in kind. For example, some tokens  may represent HTTP session data for various end users, whereas other tokens  may be executable components or objects.","As described above, a thread or process may be required to acquire access rights before accessing a token . The thread or process may be required to acquire access rights for each token  it needs to access. Thus, if the thread or process needs to access Token A as well as Token B, the thread or process may need to acquire access rights for each respective token. In one embodiment, there may be different types of access rights corresponding to different types of access to the tokens. For example, for read access of a token, the thread or process may need read access rights, whereas for write access of a token, the thread or process may need write access rights.","In various embodiments, the access rights may be used to control access to the tokens using any of various techniques. For example,  illustrates a client thread or process executing on a client application server . As shown, the client thread or process may access the tokens  through application code . In one embodiment, the application code  may implement an application code interface enabling the client to access the tokens, wherein the tokens are not otherwise accessible to the client. Thus, the application code  may check to ensure that the client holds the appropriate access rights for a token before allowing the client access to the token or before allowing the client a certain kind of access to the token.","In another embodiment, a client may be able to access a token directly, even without holding the appropriate access rights. Such an embodiment may rely on programming convention to avoid conflicts. In other words, even though a programmer may write code operable to access a token without first acquiring the appropriate access rights, the programmer is expected as a matter of practice to write program code that first acquires access rights before accessing a shared token.","FIGS.  and \u2014Distributed Token Manager","Each client thread or process that needs to acquire access rights for a token may do so by requesting the access rights from a service referred to herein as the Distributed Token Manager (DTM) . The DTM service  manages the collection of tokens . The DTM service may provide an application programming interface (API) through which clients can request to acquire and release access rights. For example, the DTM API may include a Lock( ) and an Unlock( ) method for these purposes. In one embodiment, the Lock( ) and Unlock( ) methods may have an access type parameter, e.g., either READ, WRITE, and\/or READ-WRITE to designate the type of access performed on the token, i.e., the type of access right(s) being acquired or released.","The DTM service  may also implement AddToken( ) and RemoveToken( ) methods to add new tokens to or remove tokens from the managed set of tokens, respectively. Calling the AddToken( ) method may not actually create the data of the token, but simply instructs the DTM to begin managing access rights for the token. Similarly, calling the RemoveToken( ) method may not actually delete the token data, but simply instructs the DTM to stop managing access rights for the token. For example, when a new end user begins to use a web application, an AddToken( ) method may be utilized to associate access rights with an HTTP session data token for the end user. When a new token is added, the DTM may assign the token a unique ID to identify the token. Clients may pass this token ID when requesting to acquire or release access rights for the token.","For any given token, the DTM may operate to ensure that one of the following statements is true at any given time: 1) One or more client processes or threads currently have read access rights to the token and no client processes or threads currently have write access rights to the token; or 2) One client process or thread currently has write access to the token and no other client processes or threads currently have read or write access rights to the token. In one embodiment of the second case, the single client process or thread with write access rights to the token may simultaneously have read access rights to the token. The DTM may maintain state information indicating which clients currently hold which access rights to which tokens to ensure that these conditions are met.","As described below, when a client acquires access rights to a token, a timeout may be associated with the access rights. The DTM may ensure that access rights are released when they are timed-out.","A DTM request may be initiated by DTM API methods (e.g., AddToken( ), RemoveToken( ), Lock( ), Unlock( )). Such requests may be processed through a sequence of messages as shown in . As shown, messages that may be sent from a DTM Client  to the DTM service  include:\n\n","These messages are further described below.",{"@attributes":{"id":"p-0057","num":"0063"},"figref":"FIG. 3","b":["112","112","111","111","112","111","111","112"],"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":["MSG_Token_Info (indicates information regarding a token)","MSG_Token_Removed (indicates that a token was removed)"]}}}},"In various embodiments, the Distributed Token Manager (DTM) service  may execute in various locations with respect to the architecture of the distributed system. For example, where the distributed system includes a cluster of application servers, the DTM service  may execute on one of the application servers, such as the application server D shown in . Thus, client processes or threads running on application servers A, B, and C may interface with the DTM service on application server D to acquire and release access rights for tokens. Also, client process or threads on application server D itself may call the DTM service to acquire and release access rights. As one example, when a client process or thread on application server A needs to update an HTTP session data token, e.g., in response to a request directed by the web server  of , the client process or thread may call the DTM service on the application server D to acquire write access rights for the HTTP session data token.","In another embodiment, the DTM service  may execute on a separate DTM server computer , such as shown in . The application servers A\u2013D may interface with the DTM server computer  similarly as described above.","The DTM backup service  may also execute in various locations with respect to the architecture of the distributed system, such as on one of the application server computers  or on a separate computer system. In an embodiment in which there are application server computers located on separate sub-nets, the DTM service  may be located in a first sub-net, and the DTM backup service  may be located in a second sub-net, to facilitate failover capabilities in case the first sub-net becomes inaccessible.","As discussed above, in one embodiment, the DTM service may be utilized in a distributed system comprising a cluster of application servers that support a web application. In one embodiment, one of the application servers may be designated as a \u201cprimary\u201d application server. The primary application server may store data regarding end users, such as HTTP session data. Thus, in addition to being able to process end user requests, the primary application server may act as a centralized location for storing shared data needed by other application servers in the cluster. When an application server other than the primary application server receives an end user request to process, that application server may need to interface with the primary application server to obtain HTTP session data for the end user.","In one embodiment, the DTM service may execute on the primary application server. As described above, the DTM service may coordinate access to HTTP session data. Thus, when an application server needs to acquire read and\/or write access rights to HTTP session data for an end user, the application server may first interface with the primary application server to acquire access rights for the HTTP session data, i.e., may send a request to the DTM service on the primary application server. Once the access rights have been acquired, the application server may then access the HTTP session data stored on the primary application server.","One or more of the other application servers in the cluster may be designated as \u201cbackup\u201d application servers. The backup application servers may mirror the shared data stored on the primary application server. The backup application servers may be assigned different priorities, and if the primary application server becomes inaccessible, the backup application server with the highest priority may be designated as the new primary application server. In one embodiment, the DTM backup service may execute on the backup application server. If there is more than one backup application server, then a DTM backup service may execute on each of the backup application servers. If a backup application server is promoted to become the primary application server, then the DTM backup service on that application server may be promoted to become the new DTM service.","Also, one or more other application servers in the cluster may be designated as \u201calternate\u201d application servers. The alternate application servers may also be assigned priorities. If the number of backup application servers in the cluster falls below a threshold value, then the alternate application server having the highest priority may be promoted to the role of a backup application server.",{"@attributes":{"id":"p-0065","num":"0073"},"figref":"FIG. 4C","b":["108","108","108","108","108","108","110","109","108","109"]},"In the system of , the DTM service  executes on the primary application server D, and the backup application servers B and C each execute a DTM backup service . The DTM service  maintains DTM data  (e.g., state information), and each DTM backup service  maintains a mirror  of the DTM data .","FIG. \u2014Computer System Block Diagram",{"@attributes":{"id":"p-0067","num":"0075"},"figref":["FIG. 5","FIG. 4A","FIG. 4B","FIG. 5"],"b":["108","210"]},"The computer may include at least one central processing unit or CPU  which is coupled to a processor or host bus . The CPU  may be any of various types, including an x86 processor, e.g., a Pentium class, a PowerPC processor, a CPU from the SPARC family of RISC processors, as well as others. Main memory  may be coupled to the host bus  by means of memory controller .","The host bus  may be coupled to an expansion or input\/output bus  by means of a bus controller  or bus bridge logic. The expansion bus  may be any type of bus, including the PCI (Peripheral Component Interconnect) expansion bus. The expansion bus  may include slots for various devices such as the sound card  and the modem card . The computer may further include a video display subsystem  and hard drive  coupled to the expansion bus .","The main memory  may store operating system software as well as other software for operation of the computer system. The main memory  may also store software to implement the DTM service which operates as described herein.","Computer programs operable to perform the methods described herein may also be stored on other types of memory media. The term \u201cmemory medium\u201d is intended to include an installation medium, e.g., a CD-ROM, floppy disks, or tape device, a computer system memory or random access memory such as DRAM, SRAM, EDO RAM, etc., or a non-volatile memory such as a magnetic media, e.g., a hard drive, or optical storage. The memory medium may comprise other types of memory as well, or combinations thereof. In addition, the memory medium may be located in a first computer in which the programs are executed, or may be located in a second different computer which connects to the first computer over a network, such as the Internet. In the latter instance, the second computer may provide the program instructions to the first computer for execution.",{"@attributes":{"id":"h-0009","num":"0000"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0072","num":"0080"},"figref":"FIG. 6"},"In step , a client process or thread may call a Lock(<TokenID>, READ) or Lock(<TokenID>, WRITE) method of the DTM service to obtain read or write access rights, respectively, to a token. The <TokenID> parameter may be an identifier for the desired token. As described above, the identifier may have been generated when the AddToken( ) method of the DTM was called to add the token to the managed set of tokens. The READ\/WRITE parameter may identify which type of access right is being requested. The client process or thread may execute in any of various computers of a distributed system, e.g., an application server , web server , etc.","In step , the DTM service may grant read or write access rights to the token in response to the request received in step . As described above, the DTM may keep data indicating which clients currently hold which access rights to which tokens. Thus, in step , the DTM may update this data to reflect the new grant of access rights. Of course, if another client already holds access rights to the token which prevents the requesting client from acquiring the requested access rights, the access rights may not be granted. In one embodiment, the DTM may notify the requesting client when the other client releases the access rights. The client may then re-request the access rights. In another embodiment, the DTM may automatically grant the access rights to the requesting client when the other client releases the access rights. In another embodiment, the requesting client process or thread may synchronously block until the access rights are granted. In one embodiment, the client may specify the desired behavior in the event that access rights cannot be granted.","In one embodiment of step , the DTM may return to the client a data structure indicating that the client has acquired the requested access rights. When the client then attempts to access the token, this data structure may be required. For example, as described above with reference to , the client may access the token via application code . The application code  may check to see that the data structure passed by the client is valid before allowing the client to access the token. In another embodiment, the client may not receive any such data structure from the DTM. For example, when a client attempts to access the token, the application code  may interface with the DTM to verify that the client holds access rights for the token, or the application code may be operable to itself examine the DTM data to verify that the client holds the necessary access rights.","In step , the client process or thread may perform read or write access to the token, e.g., according to which type of access rights were requested in step . Performing read access may comprise the client reading the token data. Performing write access may comprise the client writing to or changing the token data. In a case where the token is an executable component or object, in one embodiment, some of the component's methods or functions may require read access for the client to be able to call them, whereas other methods or functions may require write access for the client to be able to call them. For example, a method may require write access if the method changes stateful data of the component and may require read access otherwise. In another embodiment, all methods of a component or object may require read or write access only.","In step , the client may call an Unlock(<TokenID>, READ) or Unlock(<TokenID>, WRITE) method of the DTM service to release access rights for the token.","In step , the DTM service may remove the client's read or write access rights to the token. Similarly as described above for step , this may comprise the DTM updating data to indicate that the client no longer holds the access rights.","In one embodiment, when if the client acquired write access to the token in steps , then when the client releases the write access in step , the client may still hold read access to the token by default. Thus the client may require write access rights to a token and may perform write and\/or read access to the token. The client may then release the write access rights and still perform read access to the token. Other clients may also acquire read access to the token at this point. The client may then release the read access rights when they are no longer required.  illustrates a state diagram showing this relationship.",{"@attributes":{"id":"p-0080","num":"0088"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0081","num":"0089"},"figref":"FIG. 8","b":["1","2","1","2","1","2","2","1","1","2","2","1","1"]},"FIG. \u2014Two Clients Simultaneously Hold Read Access",{"@attributes":{"id":"p-0082","num":"0090"},"figref":"FIG. 9"},"In step , Client , i.e., a first client process or thread, issues a Lock(<TokenID>, READ) message to the DTM to acquire read access rights for a token.","In step , the DTM grants read access rights for the token to Client .","In step , Client  issues a Lock(<TokenID>, READ) message to the DTM to acquire read access rights for the token.","In step , the DTM grants read access rights for the token to Client .","In step , Client  issues an Unlock(<TokenID>, READ) message to the DTM to release read access rights for the token, e.g., after performing read access of the token.","In step , Client  issues an Unlock(<TokenID>, READ) message to the DTM to release read access rights for the token, e.g., after performing read access of the token.","Lazily Reclaimed Access Rights","In one embodiment, each Lock( ) method call may be implemented as a synchronous message communication between a client and the DTM service, and each Unlock( ) method call may be implemented as an asynchronous message communication from a client and the DTM service. Thus, when a client calls the Unlock( ) method to release access rights, the client may immediately interface with the DTM service, and the DTM service may update its data to indicate that the client no longer holds the access rights for the token. This may be referred to as the \u201cactive\u201d model.","For certain services and applications, especially those that perform mostly read access and seldomly perform write access, such communication overhead may not be necessary. Thus, in another embodiment, a \u201clazy model\u201d may be utilized, wherein the DTM service may perform \u201clazily reclamation\u201d of access rights. For lazily reclaimed access rights, the client may not actively interface with the DTM service when Lock( ) and Unlock( ) methods are called. Instead, the DTM service reclaims the access rights when necessary, e.g., when another client needs the access rights. This may increase the efficiency of the application.","According to the lazy model, when the client invokes the Unlock( ) method, the client may not interface with the DTM service to release the access rights in response. Instead, for example, the Unlock( ) method may operate locally on the client computer to indicate the client has released the access rights. Thus, when the client performs another Lock( ) method to again acquire access rights, the Lock( ) method does not need to communicate with the DTM service. Instead, for example, the Lock( ) method may operate locally on the client computer to indicate the client has acquired the access rights. When the DTM service receives a request for access rights to the token from another client, the DTM service may then reclaim the access rights, e.g., by issuing a MSG_Reclaim_RdToken or MSG_Reclaim_WrToken message to the client.","Thus, communication overhead between the client and the DTM service may be substantially reduced. Server-client communication may only happen when the client issues a Lock( ) request and the access rights are not available locally, or when the DTM server reclaims the token from the client.","FIG. \u2014Lazily Reclaimed Access Rights",{"@attributes":{"id":"p-0093","num":"0101"},"figref":"FIG. 10"},"In step , Client  issues a Lock(<TokenID>, READ) message to the DTM service to acquire read access rights for a token.","In step , the DTM service grants read access rights for the token to Client  in response to the request.","In step , Client  issues a Lock(<TokenID>, WRITE) message to the DTM service to acquire write access rights for the token.","In step , the DTM service may reclaim the read access rights granted to Client . In one embodiment, Client  may still hold the access rights until Client  calls the Unlock( ) method. At that point, Client  may interface with the DTM service to release the access rights. In another embodiment, Client  may have to immediately relinquish the access rights when the DTM service reclaims the access rights. However, in this embodiment, the access rights may only be immediately relinquished if Client  has held the access rights for a threshold amount of time, e.g., to ensure that the access rights are not reclaimed immediately before Client  has time to access the token.","In step , the DTM service grants write access rights for the token to Client .","In step , Client  issues an Unlock(<TokenID>, WRITE) message to the DTM service to release its access rights for the token. As described above, in one embodiment, Client  may also issue an Unlock(<TokenID>, READ) message to the DTM to fully release the access rights.","In step , Client  issues a Lock(<TokenID>, READ) message to the DTM service to re-acquire read access rights for the token. In another embodiment, step  may not be necessary, and the DTM service may automatically re-grant access rights to a client from whom the access rights have been reclaimed.","DTM Server Implementation Details","This section provides miscellaneous implementation details for one embodiment of the DTM service.","The DTM service may maintain the following state information for each token:\n\n","The DTM service may be operable to handle received MSG_Get_RdToken, MSG_Get_WrToken, MSG_RdToken_Rlnqshd, and MSG_WrToken_Rlnqshd messages.","The DTM service may be operable to handle failure of clients and the DTM backup. When a DTM client becomes unavailable, the client may be removed from the owner lists for the tokens. When the DTM backup service becomes unavailable, the DTM service may instantiate new DTM backup services and backup its state information to the new DTM backups.","The DTM service may detect and remove deadlocks. A deadlock detection algorithm may detect token deadlocks, and a deadlock resolution mechanism may resolve the deadlock situations.","Handling MSG_Get_RdToken Messages","For a received MSG_Get_RdToken message, the DTM service may perform the following operations:","If write access rights have been issued for the token:\n\n","The DTM service may then issue access read access rights for the token. The read access rights may be issued in \u201clazy reclaim\u201d mode. However, if any other queued requests are requesting write access rights for the token, the read access rights may not be issued in \u201clazy reclaim\u201d mode.","The DTM service may also send a MSG_Token_Info message to the DTM backup service.","Handling MSG_Get_WrToken Messages","For a received MSG_Get_WrToken message, the DTM service may perform the following operations:","If write access rights have been issued for the token:\n\n","If read access rights have been issued for the token:\n\n","The DTM service may then issue access write access rights for the token. The write access rights may be issued in \u201clazy reclaim\u201d mode. However, if any other queued requests are requesting read or write access rights for the token, the write access rights may not be issued in \u201clazy reclaim\u201d mode.","The DTM service may also send a MSG_Token_Info message to the DTM backup service.","DTM Backup Service Implementation Details","This section provides miscellaneous implementation details for one embodiment of the DTM backup service.","The DTM backup service may be operable to handle MSG_Token_Info and MSG_Token_Removed messages received from the DTM service. The messages may be unpacked or unmarshaled and the DTM backup service state information may be updated accordingly. The DTM backup service may maintain identical state information as the DTM service.","The DTM backup service may also provide a callback method for handling the failure of the DTM service. When the DTM service becomes unavailable, this callback may be invoked. All access rights previously issued by the DTM service may be reclaimed.","Client Implementation Details","This section provides miscellaneous implementation details for one embodiment of a client computer that interfaces with the DTM service.","On each client computer, the following methods may be implemented: Lock( ), Unlock( ), AddToken( ), RemoveToken( ), IsLockedForWrite( ), IsLockedForRead( ).","Each client may maintain information regarding access rights for tokens accessed by the client, such as:\n\n","Each client may be operable to handle MSG_Reclaim_RdToken and MSG_Reclaim_WrToken messages received from the DTM service.","Multiple DTM Services","In one embodiment, there may be multiple DTM services. For example, each DTM service may execute on a different application server . Each token may be managed by only one DTM service. In one embodiment, an algorithm may be employed to determine how tokens are allocated among the DTM services. For example, the algorithm may be designed to reduce network traffic by assigning tokens the DTM service most near to the client computers that need to access the tokens. The algorithm may also be designed to be scalable, e.g., so that a balanced workload occurs across different application servers.","Although the embodiments above have been described in considerable detail, numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A better understanding of the present invention can be obtained when the following detailed description of the preferred embodiment is considered in conjunction with the following drawings, in which:",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 2A and 2B"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 4C"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
