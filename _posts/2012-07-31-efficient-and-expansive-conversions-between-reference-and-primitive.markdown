---
title: Efficient and expansive conversions between reference and primitive
abstract: A tool, such as a compiler or an interpreter, receives program source code and determines that the code includes an operation for which type conversion is permitted on an operand. The tool determines a source type of the operand, and a target type to which the operand is to be converted. In response to determining that the source type is a reference type and the target type is a primitive type, the tool generates a set of instructions to (a) determine whether, at run time, in accordance with a class definition of the reference type, a value of the target primitive type can be obtained via one or more method invocations on the operand (b) if such a value can be obtained, obtain the value and assign the value to a result of the operation and (c) if such a value cannot be obtained, generate an error indication.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08863079&OS=08863079&RS=08863079
owner: Oracle International Corporation
number: 08863079
owner_city: Redwood City
owner_country: US
publication_date: 20120731
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS"],"p":["For performance and other reasons, object-oriented computer programming languages, such as Java\u2122, may support a set of primitive data types in addition to reference data types. In general, a variable's data type determines the values it may contain, and the operations that may be performed on it. The terms \u201cprimitive types\u201d and \u201creference types\u201d may be used herein to refer to \u201cprimitive data types\u201d and \u201creference data types\u201d respectively. Primitive types may be predefined by the language specification, and may be named using reserved keywords (such as int or float). In some environments, the value of a primitive type may be stored in a location of a fixed size on the stack, such as a four-byte (32-bit) location for int variables, and may not share state with other primitive values. In contrast, a data type for which, when an object of that data type is instantiated, a reference (in effect, a pointer) to a heap location storing the value of the instantiated object is created, is called a reference type. In other environments, the stack-versus-heap distinction between primitive and reference types may not always apply. For example, virtual machines with escape analysis optimization may be able to stack-allocate certain objects of reference types. In general, a small number of primitive types may be supported by the language, while arbitrary numbers of reference types (e.g., classes, interfaces, or arrays, in the case of Java\u2122) may be defined and created by users of the language. It is noted that the distinction between primitive and reference types may be affected somewhat by language features like value types, which may allow user-defined types to behave more like primitives than reference types. For example, objects of values types would not be comparable for identity, only for value.","Some language constructs or frameworks (such as various classes defined in the Java\u2122 Collections framework for representing aggregates like sets, lists, and maps) may be provided strictly for reference types in object-oriented languages. That is, it may not be legal in the language to set up an aggregate of primitive values, or use aggregate features such as iterators directly on primitive values. However, a number of special reference types, called wrapper types, may also be supported in some languages to manually or automatically encapsulate primitive values as objects (e.g., an int value may be encapsulated using the Integer wrapper reference type in Java\u2122, effectively converting a primitive value to a reference to an object with the same numerical value), so that the functionality provided by the frameworks may be extended to primitive values which are suitably wrapped.","The object-oriented programming language may support implicit and explicit data type conversion operations, in which, for example, the value of an expression of a source data type S may be stored in a variable of a target data type T. The following code may represent an example explicit casting conversion operation:",{"@attributes":{"id":"p-0005","num":"0004"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1. \/\/ someMethod returns an object of type SourceType"]},{"entry":[{},"2. SourceType s = someClass.someMethod( );"]},{"entry":[{},"3. \/\/ explicit cast to convert s to type TargetType"]},{"entry":[{},"4. TargetType t = (TargetType) s;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Several different kinds of type conversion operations may be supported in a given programming language. For example, exhaustive primitive-to-primitive conversions may be supported for numerical primitives, such as a conversion of an int to a short, or a short to an int. However, in many cases, there may be limitations and irregularities in the extent to which conversions from primitive types to reference types (or from reference types to primitive types) are supported in a given version of a programming language. For example, even though it may appear to a programmer that it would be reasonable and meaningful to be able to convert from a reference type R to a primitive type P (e.g., Long to int), on the grounds that it is meaningful to convert from the unwrapped form of R to P (i.e. long to int), the language may not permit such a transformation (i.e., a compile-time error or a run-time error may be thrown).","A system and method is disclosed for efficient and expansive conversions between primitive and reference types. A tool capable of generating executable instructions (such as a compiler or an interpreter) for a programming language that supports primitive data types and reference data types is configured to receive source code for a program. For an operation included in the source code for which type conversion is permitted for at least one operand, the tool determines a source type of the operand, and a target type to which the operand is to be converted. In response to determining that the source type is a reference type and the target type is a primitive type, the tool generates a set of instructions to (a) determine, at run time, in accordance with a class definition of the reference type, whether a value of the target primitive type can be obtained via one or more method invocations on the operand (b) if such a value can be obtained, obtain the value and assign the value to the result of the operation and (c) if such a value cannot be obtained, generate an error indication. In embodiments where the tool comprises a compiler, the generated instructions are stored in an executable version of the program; in embodiments where an interpreter is used, the instructions may be executed upon generation, without being stored in a persistent executable version of the program. In some embodiments, to determine whether the value of the target primitive value can be obtained, the tool may generate instructions to determine whether the run-time class of the operand is a wrapper class designed to encapsulate a primitive value.","In one embodiment, if the tool determines that the source type is a primitive type and the target type is a reference type, the compiler may generate a set of instructions to (a) obtain at run time, using the operand as a parameter, an object of a wrapper class corresponding to the primitive type; (b) perform a numeric conversion operation supported by the wrapper class to obtain an intermediate primitive value of a different primitive type encapsulated by the target type; and (c) perform a boxing operation to obtain an object of the target type from the intermediate primitive value.","According to some embodiments, if the tool determines that the source type is a reference type and the target type is also a reference type, the tool may generate a set of instructions to implement a sequence of operations to obtain an object of the target type from the operand, wherein the sequence comprises one or more of: a reference-to-primitive conversion, an unboxing operation, a primitive-to-reference conversion, a boxing operation, or a numeric value extraction operation.","While the invention is described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that the invention is not limited to the embodiments or drawings described. It should be understood that the drawings and detailed description hereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the invention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. Any headings used herein are for organizational purposes only and are not meant to limit the scope of the description or the claims. As used herein, the word \u201cmay\u201d is used in a permissive sense (i.e., meaning having the potential to) rather than the mandatory sense (i.e. meaning must). Similarly, the words \u201cinclude\u201d, \u201cincluding\u201d, and \u201cincludes\u201d mean including, but not limited to.","It is noted that, while much of the following description refers to the use of a compiler for various type conversion operations, similar operations may be performed in some embodiments by a different tool, such as an interpreter. For example, an interpreter may consume source code as input (just as a compiler does) and generate executable instructions implementing similar logic as described below with respect to a compiler. In cases where an interpreter is being used, the generated instructions may be executed forthwith, and may not be stored in a persistent form (e.g., as an executable version of the source program) as they typically would be if a compiler were used. The kinds of errors thrown when conditions such as an attempt to perform an unsupported conversion are encountered, and the error messages provided, may differ in some cases between the compiler and the interpreter. In various embodiments, the kinds of type conversions described below may be considered as functions on (a) the static type of a source expression, (b) the static type of a target variable, and (c) the dynamic type of the source expression. In embodiments where a compiler is used, the term \u201cstatic\u201d may be translated as \u201cknown at compile-time\u201d; however, in embodiments where a different tool is being used, the term \u201cstatic\u201d can be generalized to mean \u201cknown prior to execution\u201d. The involvement of a dynamic type implies that conversion can only be effected by a tool emitting operations that are to be performed at runtime. An interpreter (e.g., for Java\u2122 source code) may actually have an advantage over a compiler in some cases, since it not only knows the \u201cstatic\u201d source and target types, but also the dynamic type of the source expression. Such an interpreter may perform at runtime the same operations to effect conversion which a compiler would have emitted.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1"},"According to the illustrated embodiment, the workflow begins when a compiler implementing type conversion functionality, such as compiler , receives source code for a computer program, such as files . In various embodiments, source code  may be specified in various high-level and\/or object-oriented programming languages, such as Java\u2122 and\/or other languages. Source code may be provided as a set of .java files in embodiments where Java\u2122 is being used. In some embodiments, source code  may be specified using a combination of languages, which may include one or more low-level and\/or intermediate languages (e.g., assembly). In some embodiments, at least some of the source code may initially be written in a dynamically-typed high-level language, such as Python or Ruby, while in other embodiments, all of the source code may be in a statically-typed language such as Java\u2122.","The compiler  may analyze the source code  to produce an executable version of the program, such as bytecode files  (e.g., .class files or .jar files in the case of Java\u2122) in the depicted embodiment. Different types of executable code formats may be used in various embodiments; for example, binary machine language may be used instead of bytecodes. In some scenarios, parts of the executable code  may be in bytecode while others are in a native binary machine language. As part of compiling program source code  into executable code , the compiler  may perform a sequence of analysis operations and generate various intermediate data structures before generating the executable version, as described below in further detail with reference to . The compiler  may, for example, identify various data type conversion operations such as cast operations, determine the source and target types of the conversions, and decide, based on the static source and target types that can be determined at compile-time, whether a compile-time error should be generated. If a given conversion operation is determined to be acceptable for compilation, appropriate code may be generated for it. Depending on the run-time behavior of the program (i.e., exactly which objects of which types are instantiated during execution), even if a conversion is successfully compiled, a run-time exception may still be generated in some cases, as described below in further detail.","As illustrated in , executable code  may be passed to an execution environment, such as run-time environment , which executes the code on an execution platform , thereby creating various output data and\/or behavior. In various embodiments, the run-time environment  may include a virtual machine  (e.g., a Java\u2122 Virtual Machine or JVM). The virtual machine  may in turn comprise a number of different components, such as a memory manager  (which may include a garbage collector), a bytecode verifier  to check the validity of the executable code, an interpreter and\/or a just-in-time (JIT) compiler  such as the HotSpot compiler. The JIT compiler may in some embodiments be responsible for translating some or all of the bytecode (for example, heavily-used portions of bytecode) into platform-specific machine code to improve performance of the program execution. A run-time environment , such as the Java\u2122 Runtime Environment or JRE, may also include code to implement a number of application programming interface (API) libraries  in some embodiments. The run-time environment  may run on top of lower-level software such as an operating system  in some embodiments. In embodiments where virtualized compute resources are being used as the execution platform, virtualization software such as a hypervisor may be used to configure the execution platform  for the operating system  (i.e., the operating system may run as an application on top of the hypervisor).","In different embodiments, the output or behavior produced as a result of the execution of the compiled code may include data stored in various levels of system memory (e.g., in-memory objects and\/or data structures), on persistent storage (e.g., files on a file system), etc. The behavior may also include various program functionalities, such as displaying output on a screen, sending messages over a network, and\/or otherwise interacting with various users and\/or components.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 2","FIG. 1","FIG. 2"],"b":"110"},"According to the illustrated embodiment, compiler  may include lexical analyzer , which may be configured to break the input source code into tokens, such as tokens . Each token  may correspond to a single atomic unit of the given language, such as keywords, identifiers, etc. In various embodiments, the token syntax may be represented as a regular language. Compiler  may include preprocessor  in the depicted embodiment, which may be used to support macro substitution in some languages. In some embodiments, preprocessor  may modify various ones of tokens , which may result in a set of modified tokens, such as .","Compiler  may also include a syntactic analyzer  in some embodiments, which may be configured to parse the modified tokens  to identify syntactic structure of the input program. The syntactic analyzer may be configured to build a parse tree, such as parse tree , which may organize the tokens  into a tree structure according to the formal grammar of the programming language of the source code.","In the depicted embodiment, the compiler  may further include a semantic analyzer , which may be configured to add semantic information to parse tree  to create an annotated internal representation of the program, such as intermediate representation . In some embodiments, a code generator, such as code generator , may convert the intermediate representation  into an executable program, such as . Executable program  may be encoded in binary and\/or bytecode and may correspond to executable code  in .","In some embodiments, semantic analyzer  may also build and\/or maintain a symbol table, such as symbol table , which maps various symbols in the source code to associated information, such as the location, scope, and\/or type. The semantic analyzer  may also include a type checker, such as type checker , to perform type-checking functions, e.g., to determine whether a conversion operation between a particular source type and target type is acceptable. If the type checker determines that a conversion operation is unacceptable, a compile-time error may be generated, and at least in some embodiments the compilation may fail. In some instances, warnings may be generated for certain types of operations, instead of or in addition to compile-time errors. For example, in some implementations, if a conversion is attempted that may result in some loss of precision of a numeric value, a warning may be generated even though the operation may be permitted and the program compiled. In some embodiments the compiler  may support special flags (such as \u201c-Xlint\u201d) to enable the generation of a larger set of warnings than would otherwise be generated. In various embodiments, different components of compiler  shown in  may be combined or further deconstructed into multiple components. The compiler may also implement various additional types of functions, such as optimization, line reconstruction, and the like, not shown explicitly in , in some embodiments.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 3"},"In the embodiment depicted in , the supported primitive types include boolean, byte, short, int, long, float, double and char. Other primitive types may be supported in different embodiments, and\/or some of the depicted primitive types may not be supported. A boolean primitive may use just one bit, and the possible range of its values may be limited to \u201ctrue\u201d and \u201cfalse\u201d. Four primitives to store integral (i.e., non-fractional) numeric values may be supported: byte, short, int and long, taking up one two, four, and eight bytes, respectively. As indicated by the range shown in  for each integral primitive type, the larger primitive integral types may logically \u201cinclude\u201d the smaller ones. For example, every possible int value may be represented as a long value, every short value may be represented by an int or a long, and so on. Accordingly, as described below, it may be fairly straightforward for a compiler or an interpreter to convert or cast an int to a long in some embodiments, using what may be termed a \u201cwidening\u201d conversion herein; such a conversion or cast may simply involve setting some of the bits of the larger primitive value to zero. Narrowing conversions, on the other hand, where a source primitive value (such as a long) is converted into a target primitive value that uses less space (such as an int), may involve some loss of precision or information, as also described below. Floats (four bytes) or doubles (eight bytes) may be used for numerical values that are not whole integers (i.e., contain some fractional components). Char primitives may use two byes to store character values defined in some character encoding set, such as UTF-16 (the 16-bit Unicode Transformation Format character encoding standard).",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 4","FIG. 4","FIG. 4"]},"A widening primitive conversion may be defined as a conversion in which in general, the target type has a wider range of supported values than the source type. For example, \u201cshort s= . . . ; int i=s;\u201d is a widening primitive conversion from a 16-bit short value to a 32-bit int value.\u201d. In widening conversions between the integral primitive types (byte, short, int, or long), no information may be lost, i.e., the numeric value of the source may be preserved exactly. Some other widening primitive conversions, such as int to float, may result in loss of precision,\u2014i.e., the result may lose some of the least significant bits of the value, and the result may be rounded according to some standard such as the IEEE 754 floating-point standard.","A narrowing primitive conversion (such as conversion of an int to a short), may be defined as a conversion in which in general, the source type has a wider range of supported values than the target, and less space is available for the target value than was available for the source value. As a result, a narrowing conversion may result in a loss of information about the magnitude of the numeric value of the source, loss of precision of the numeric value, a reduction in range of supported values, or some combination of these effects.","It is noted that some non-standard rules may apply in the case of a few primitive-to-primitive conversions (especially for char primitives), based on the language specification\u2014e.g., the conversion from a byte to a char may involve a widening (of the byte to an int) followed by a narrowing (of the int to a char), as indicated by the notation \u201cw, n\u201d in , and conversions between short values and char values may be defined as narrowing conversions in both directions, despite the fact that both primitive types use two bytes. The kinds of primitive-to-primitive conversions illustrated in  may serve as building blocks for other kinds of conversions involving reference types, as described below in further detail.","In at least some embodiments, the instruction set of the bytecode (or machine code) generated from the source code may include instructions for direct conversions between some or all of the primitive types (e.g., an \u201ci2b\u201d instruction usable to convert an int to a byte, or a \u201cd2i\u201d instruction usable to convert a double to an int). Such direct conversion instructions may be used to generate the code for various types of conversion operations (not just primitive-to-primitive conversions) in some embodiments. In other embodiments, the instruction set may not include direct conversion instructions, and the compiler or interpreter may have to generate code for type conversion operations using more basic instructions supported by the instruction set, such as various arithmetic and logic instructions.","Some object-oriented languages may define a set of wrapper reference types to encapsulate primitive values as class objects, e.g., to allow the use of language features that are typically available only for objects (like various types of Collection functionality). For example, the Java\u2122 language defines the following wrapper classes (i.e., wrapper reference types defined as classes in the java.lang package): Byte, Short, Character, Integer, Long, Float and Double for the primitive types byte, short, char, int, long, float and double respectively. (The wrapper class Boolean is also defined for primitive type boolean; however, conversions to or from these two types are not explicitly discussed below.) The following two statements illustrate the difference between a primitive data type and an object of a wrapper class:\n\n","The statement in line 1 declares an int variable named x and initializes it with the value 25. The second statement instantiates an Integer object on the heap, initialized with the value 33. A reference or pointer to that heap object is assigned to the object variable y. Conversion of a primitive value to an object of the corresponding wrapper type may be referred to as \u201cboxing\u201d the primitive value, and the extraction of the primitive value from an object of the corresponding wrapper class may be referred to as \u201cunboxing\u201d the wrapper. One or more unboxing class methods may be supported for a given wrapper class in some embodiments, e.g., the intValue( ) method for an Integer may return an int representing the numerical value of an Integer object. For numeric wrapper types (i.e., wrapper types other than Boolean or Character), unboxing class methods may be available to obtain primitive values for all the other numeric primitive types in some embodiments\u2014e.g., the Integer class may support byte Value( ) shortValue( ) long Valued, floatValue( ) and doubleValue( ) methods in addition to intValue( ). These methods may be used for reference-to-primitive conversions in some embodiments, as described below with reference to , and may be referred to collectively as \u201cvalue extraction methods\u201d or as the \u201c*Value( )\u201d methods herein.","To help simplify programming, and reduce the potential program clutter induced by explicit boxing and unboxing operations, in some embodiments the object-oriented language may support automating the process of boxing and unboxing. Such \u201cautoboxing\/auto-unboxing\u201d support may, for example, result in the following being considered legal statements: \u201cint y=3; Integer z=y;\u201d or \u201cInteger k=new Integer(56); int l=k;\u201d. Some of the kinds of reference-to-primitive or primitive-to-reference conversions described below may use boxing and\/or unboxing operations in various embodiments. As noted above, data type conversions may be supported in several different contexts in various programming languages. Some kinds of conversions may be considered \u201csafer\u201d than others, e.g., with respect to possible loss of information, and may be supported in more different contexts than other conversions that are deemed less \u201csafe\u201d. For example, because a widening primitive-to-primitive conversion like byte-to-int does not (as long as it is implemented correctly) involve possible information loss, it may be permitted in several contexts, and may not be limited to casting operations. Similarly, the techniques described below for implementing widening primitive-to-reference conversions (such as byte-to-Integer conversions) may allow such conversions to be supported in several different contexts in some embodiments. In contrast, a narrowing primitive-to-primitive conversion, such as int-to-byte, may be considered unsafe due to the possibility of information loss, and as a result may be limited to contexts such as explicit casting operations where the programmer has to acknowledge the danger of possible loss if information. Similar logic may also restrict the contexts in which narrowing primitive-to-reference conversions (such as Integer-to-byte conversions), described below, are allowed in some embodiments.",{"@attributes":{"id":"p-0043","num":"0044"},"figref":["FIG. 5","FIG. 5","FIG. 5","FIG. 6","FIG. 5"]},"The following symbols are used in  to indicate the different types of conversions: \u201cu\u201d for an unboxing conversion, \u201cNN\u201d for narrowing reference-to-primitive conversion, \u201cWW\u201d for a widening reference-to-primitive conversion, \u201cw\u201d for a widening primitive-to-primitive conversion, and \u201cr\u201d for a narrowing reference-reference conversion. With respect to reference-to-primitive conversions, a conversion may be termed \u201cnarrowing\u201d if in general, the unboxed primitive type corresponding to the source has a wider range of supported values than the target, and less space is used for the target than would be used for the unboxed primitive value of the source, such as in the case of a Long-to-int conversion. Similarly, a reference-to-primitive conversion may be termed widening if in general the unboxed primitive type corresponding to the source has a narrower range of supported values than the target, and more space is used for the target than would be used for the unboxed primitive value of the source, such as in the case of an Integer-to-long conversion. The Character-to-short conversion and the Short-to-character conversions may be deemed \u201cnarrowing\u201d even though the values of both of the corresponding primitives may be stored using two bytes. A narrowing reference-to-reference conversion, may, for example, represent a conversion from a supertype to a subtype. In the illustrated embodiment, the NN conversions may preserve the numeric value of the reference source object when possible.","In order to implement the NN conversions shown in  efficiently, in some embodiments the compiler or interpreter may take advantage of support provided in the language to determine whether a particular expression with static type Object represents a runtime object of one of the wrapper types discussed above, and if so, whether it represents a Character wrapper type or a numeric wrapper type. Consider the following source code as a generic example of a reference-to-primitive conversion that may require an NN conversion:\n\n","In at least some such embodiments, the bytecode or machine code generated for the above reference-to-primitive conversion (or for similar conversions in other contexts than casts, such as method invocation or assignment) may be logically equivalent to the following high-level code:",{"@attributes":{"id":"p-0047","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"1. \/\/ Target primitive type P is one of byte\/short\/char\/int\/long\/float\/double"},{"entry":"2. \/\/ declare a variable target of type P"},{"entry":"3. \/\/ in line 5, \u201cP\u201d would be replaced by the appropriate primitive type,"},{"entry":"\u2003e.g.,"},{"entry":"4. \/\/ \u2003\u2002line 5 might be \u201cint target\u201d;"},{"entry":"5. P target;"},{"entry":"6. \/\/ check, using the isPrimitive( ) method of the java.lang.Class class ,"},{"entry":"7. \/\/ \u2003\u2003\u2002whether the source object belongs to one of the wrapper classes"},{"entry":"8. if (o.getClass( ).isPrimitive( )) {"},{"entry":"9. \u2003\u2003\/\/ now check whether source object is numeric"},{"entry":"10. \u2003\u2002if (o instanceOf java.lang.Number) {"},{"entry":"11. \u2003\u2003\u2003\/\/ obtain target value by (a) explicit cast to Number, and then"},{"entry":"12. \u2003\u2003\u2003\/\/ \u2003\u2002\u2009(b) using the appropriate *Value( ) unboxing method"},{"entry":"13. \u2003\u2003\u2003target = ((Number)o).PValue( );"},{"entry":"14. } else if (o instanceOf java.lang.Character) {"},{"entry":"15. \u2003\u2003\u2003\/\/ obtain target value by (a) explicit cast to Character,"},{"entry":"16. \u2003\u2003\u2003\/\/ \u2003\u2002\u2009(b) extracting character value using charValue( ) method"},{"entry":"\u2003\u2003\u2003\u2003\u2002and then"},{"entry":"17. \u2003\u2003\u2003\/\/ \u2003\u2002\u2009(c) using primitive-to-primitive conversion to target type"},{"entry":"18. \u2003\u2003\u2003target = (P)((Character)o).charValue( );"},{"entry":"19. \u2003\u2002} else \/\/ o is a Boolean"},{"entry":"20. \u2003\u2003\u2003throw new ClassCastException;"},{"entry":"21. \u2003\u2002}"},{"entry":"22. } else { \/\/ isPrimitive( ) returned false, so throw runtime exception"},{"entry":"23. \u2003\u2002throw new ClassCastException;"},{"entry":"24. }"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In the above example, the compiler or interpreter may first determine whether the source type is a reference type (i.e., that the source type is not a primitive type), and then generate code to determine more details about exactly what types of values can be extracted from the source. As indicated in the high-level code snippet above, the compiler or interpreter may generate code to determine whether a primitive value of the target data type can be obtained using one of the other supported conversion operators\u2014such as, in the case of the numeric wrapper source types, the intValue( ), shortValue( ) and other *Value( ) or value extraction methods available, and (in the case of a Character reference type) the char-to-primitive conversions shown in . Common bytecode implementing the logic shown in the above code may be shared for a plurality of the NN conversions shown in  in some embodiments, instead of using different logic specific to each of the wrapper types. As shown in lines 20 and 23, the generated code may still throw an exception if it is determined at run time that a meaningful primitive value cannot be extracted from the source expression of the conversion operation. It is noted that although the source code snippet shown above uses the \u201cNumber\u201d superclass of the numeric wrapper classes, the use of such a superclass is not a requirement; e.g., in some embodiments, instead of generating code for the Number-based if clause in lines 10 and 13, code for separate if clauses for each of the numeric wrapper classes could be generated, such as \u201cif o.instanceOf(javalang.Integer) {target=(Integer)o.PValue( )} else if o.instanceOf(java.lang.Long) {target=(Long)o.PValue( )} and so on. It is also noted that although the value extraction methods in the example are shown as being offered by the wrapper classes (in lines 13 and 18), such value extraction methods do not necessarily have to be offered by the wrapper classes themselves; e.g., value extraction methods provided by a utility class (and not by a wrapper class) may be used in some embodiments.","The \u201cu, w\u201d conversions, shown above the diagonal in , may be easier to implement than the NN conversions, in that once a primitive value is obtained by unboxing, it may straightforward to then use the \u201cw\u201d conversions of  to obtain the desired target primitive value. The \u201cWW,NN\u201d Byte-to-char conversion may be analogous to the special-case \u201cw, n\u201d byte-to-char conversion of .","The bottom row of  represents four possibilities for conversions from expressions of static (e.g., compile-time, in environments where a compiler is being used) type Object to a primitive target type for some embodiments. (It is noted that especially in cases where source code is in a dynamically typed language such as Ruby or Python, the static or compile-time type of a substantial number of the objects being dealt with may default to general object types; that is, the type of the objects may only become clear at run-time.) If the run-time type of the source is numeric or Character, and exactly matches the primitive target type, e.g., in a case similar to \u201c(byte) new Byte(42)\u201d, a narrowing reference conversion may be followed by unboxing. If the run-time type of the source object is numeric or Character, and does not match the primitive target types exactly, such as in the examples \u201c(byte) new Integer(42)\u201d, the NN conversion may be implemented using the logic described above (in the example code that uses isPrimitive( ) and instanceOfjava.lang.Number). In the special case of a conversion from Byte to char, a WW,NN conversion involving both widening and narrowing may be used. Finally, if the run-time type of the source object is not numeric or Character, a ClassCastException or some other run-time error may result. It is noted that Boolean reference-to-primitive conversions may also be supported in some embodiments, although Boolean is not listed among the wrapper types of .",{"@attributes":{"id":"p-0051","num":"0054"},"figref":["FIG. 6","FIG. 6","FIG. 5","FIG. 6"]},"Consider, as an example, the following primitive to reference cast operation (the \u201cnn\u201d case, since this is a conversion from an int to a Short):\n\n","To implement the requested conversion from the int primitive to the Short reference type, a compiler or an interpreter could in some embodiments generate code to do the following: (a) converting the int to an Integer (b) extracting the short primitive value of the Integer, e.g. using the shortValue( ) class method available for Integers and then (c) boxing the short value to a Short object. E.g., code to perform the logical equivalent of the following may be generated:",{"@attributes":{"id":"p-0054","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1. \/\/ box the int to an Integer"]},{"entry":[{},"2. Integer tempInteger = Integer.valueOf(i);"]},{"entry":[{},"3. \/\/ extract a short"]},{"entry":[{},"4. short tempShort = tempInteger.shortValue( );"]},{"entry":[{},"5. \/\/ box to Short"]},{"entry":[{},"6. Short s = Short.shortValue(tempShort);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"It is noted that the three conversion operations illustrated separately above may also be accomplished by a single line of high-level code, such as \u201cShort s=Short.shortValue(Integer.valueOf(i).shortValue( );\u201d . A similar three-step approach (boxing to obtain a wrapper corresponding to the source primitive operand, followed by value extraction of the primitive type that can be wrapped by the target reference type, followed by boxing to the target reference type) may be used for \u201cww\u201d widening conversions in some embodiments.","Given support for the different primitive-to-reference conversions illustrated in , and support for the different reference-to-primitive conversions illustrated in , numerous reference-to-reference conversions may be enabled in some embodiments. For example, a cast from a Short to an Integer may be accomplished using any of the following approaches: (a) Short-to-int conversion as in , followed by int-to-Integer boxing; (b) Short-to-short unboxing, followed by short-to-Integer conversion as in ; (c) Short-to-short unboxing, followed by short-to-int conversion as in , followed by int-to-Integer boxing; or (d) integer value extraction using the Short.intValue( ) method, followed by int-to-Integer boxing. The specific choice as to which combination of operators, among these types of choices, is used by the compiler or interpreter for reference-to-reference conversions may differ from one implementation to another. The set of composite conversions between various reference types may be represented as commutative diagrams in some embodiments, in which the vertices represent the types, and the edges represent the conversions. Some of the conversion paths in such a diagram may have alternative implementations of the same functionality, from which one may be selected in a given embodiment or implementation; the conversion function in a mathematical sense may be separated from its implementation. It is also noted that in various embodiments, the different conversion tables shown in ,  and  may not have some of the illustrated structural properties, such as symmetry around the diagonal of a given table or a 1:1 correspondence between the reference-to-primitive conversion table of  and the primitive-to-reference conversion table or . That is, in some embodiments, only a subset of the conversions illustrated may be supported.",{"@attributes":{"id":"p-0057","num":"0062"},"figref":"FIG. 7","b":["701","705"]},"In the (source==reference, target==primitive) case, as detected in element , the tool may generate code for the conversions illustrated in . Executable code (e.g., in the bytecode for the language in which the program is written, and\/or in machine code) may be generated for the high-level operations illustrated in  in some embodiments, as shown in element  of . In the (source==primitive, target==reference) case, as detected in element , code may be generated for the conversions illustrated in , corresponding to the high-level operations illustrated in  in the depicted embodiment, as indicated in element .","If the conversion is a reference-to-reference conversion between source type S and target type T of one of the supported kinds indicated above, as determined in element , code may be generated in a number of different ways involving different combinations of unboxing, boxing, value extractions using the *Value( ) value extraction methods, and so on, as discussed above. Examples of the high-level operations for these choices, for which corresponding executable code may be generated, are shown in , as indicated in element  of . If the conversion is primitive-to-primitive, code may be generated corresponding to the different operations illustrated in  (element ). In embodiments where a compiler is being used, the generated code may be stored in an executable file as shown in element , and may be executed at an execution platform as described above with reference to .",{"@attributes":{"id":"p-0060","num":"0065"},"figref":"FIG. 8","b":["801","819"]},"If code generated for isPrimitive( ) or its equivalent returns a \u201ctrue\u201d result, there may be three further possibilities regarding the type of the source. If the source is an instance of one of the numeric wrapper types (such as Byte, Short, Integer, Long, Float or Double), as determined in code generated for element ), the target primitive value may simply be extracted using code for the appropriate value extraction method (e.g., intValue(for int, shortValue for short, and so on) (element ). If the source is an instance of the Character wrapper type (as detected in code generated corresponding to element ), code may be generated to first extract the char value of the source (e.g., using the equivalent of a charValue( ) method), as shown in element  of . The char value may then be converted to the target primitive type using code generated for the appropriate primitive-to-primitive conversion (e.g., one of the conversions shown in the char row of ), as indicated in element . The third and final scenario if isPrimitive( ) or its equivalent returns true is that the source is of type Boolean, in which case a run-time error or exception may be generated (element , reached from \u201cNo\u201d branch out of element ). It is noted that, depending on the tool being used, the generated code for the operations shown may either be stored for later execution (e.g., if a compiler is being used) or may be executed immediately (e.g., if an interpreter or just-in-time compiler is being used).",{"@attributes":{"id":"p-0062","num":"0067"},"figref":"FIG. 9","b":["901","913"]},"If the target type is one of the wrapper types, code may be generated to obtain a wrapped object from the primitive source value\u2014e.g., an Integer if the source is an int, a Short if the source is a short, and so on (element ). If the source is \u201cint i\u201d, for example, the wrapped object may be obtained using the code for the equivalent of \u201cInteger tempinteger=Integer.valueOf(i);\u201d. Then, using code for the appropriate *Value( ) value extraction method for the wrapper object so obtained, an intermediate primitive value of a primitive type that can be wrapped to obtain an object of the target type may be obtained (element ). For example, if the target reference type is Short, code may be generated in the above example for the following: \u201cshort tempShort=tempInteger.shortValue( )\u201d. Finally code may be generated to box the primitive obtained from the *Value( ) method, to the target type of the conversion, e.g., code for \u201cShort s=Short.shortValue(tempShort);\u201d may be generated in the example scenario of converting an int to a Short.",{"@attributes":{"id":"p-0064","num":"0069"},"figref":["FIG. 10","FIG. 4","FIGS. 5 and 8","FIGS. 6 and 9","FIG. 10","FIG. 10","FIG. 10"]},"In the embodiment depicted in , a tool such as a compiler or interpreter may choose one of the four approaches \u201cRef-prim-box\u201d, \u201cUnbox-prim-prim-box\u201d, \u201cUnbox-prim-ref\u201d, and \u201cGetValue-box\u201d, and generate code according to the chosen approach. It is noted that in some embodiments, the tool may be configured to support just one of the approaches, i.e., the tool may not need to explicitly choose among more than one approach; and that in other embodiments, a subset of the four approaches may be implemented.","If the Ref-prim-box approach is taken (element ), code may be generated to first convert the source of type S to a primitive value of type t, e.g., using the reference-to-primitive conversion techniques described earlier (element ), and then to box the primitive value t to the target reference type T (element ). If the Unbox-prim-prim-box approach is taken (element ), code may be generated to first unbox the source of type S to a primitive value of type s (element ), followed by a primitive-to-primitive conversion to type t (element ), followed by a box to type T (element ).","If the Unbox-prim-ref approach is taken (element ), code may be generated to first unbox the source of type S to a primitive value of type s (element ), followed by a primitive-to-reference conversion to type T (element ). If the GetValue-box approach is taken, the code may be generated to first use the equivalent of a value extraction method to obtain a primitive value of type t (element ), followed by a boxing of the primitive value to type T (element ).","At least in some embodiments, more (or different) approaches may be feasible for reference-to-reference conversions than those shown in , using various combinations of the primitive-to-primitive, primitive-to-reference, and reference-to-primitive conversion techniques described earlier. In some embodiments, the instruction set for the bytecode (or machine code) to which the source code is compiled may include instructions for direct conversions of some or all of the primitive types (e.g., an \u201ci2b\u201d instruction usable to convert an int to a byte, or a \u201cd2i\u201d instruction usable to convert a double to an int), which may be used by a compiler or an interpreter to generate the code for various types of conversion operations included in the source code. In at least one embodiment, new bytecode instructions may be added to the bytecode instruction set specifically for the purpose of facilitating the different types of conversions described herein.",{"@attributes":{"id":"p-0069","num":"0074"},"figref":"FIG. 11","b":["3000","3000","3000","3010","3020","3030","3000","3040","3030"]},"In various embodiments, computing device  may be a uniprocessor system including one processor , or a multiprocessor system including several cores or processors  (e.g., two, four, eight, or another suitable number). Processors  may be any suitable processors capable of executing instructions. For example, in various embodiments, processors  may be general-purpose or embedded processors implementing any of a variety of instruction set architectures (ISAs), such as the SPARC, x86, PowerPC, or MIPS ISAs, or any other suitable ISA. In multiprocessor systems, each of processors  may commonly, but not necessarily, implement the same ISA.","System memory  may be configured to store program instructions implementing a compiler , an interpreter , source code  of various programs to be compiled, executable code  generated by the compiler or other compilers, and an execution environment  similar to runtime environment  of . System memory may also include program instructions and\/or data for various other applications. Program instructions may be encoded in platform native binary, any interpreted language such as Java\u2122 bytecode, or in any other language such as C\/C++, Java\u2122, etc. or in any combination thereof. In various embodiments, system memory  may be implemented using any suitable memory technology, such as static random access memory (SRAM), synchronous dynamic RAM (SDRAM), nonvolatile\/Flash-type memory, or any other type of memory.","In one embodiment, I\/O interface  may be configured to coordinate I\/O traffic between processor , system memory , and any peripheral devices in the device, including network interface  or other peripheral interfaces. In some embodiments, I\/O interface  may perform any necessary protocol, timing or other data transformations to convert data signals from one component (e.g., system memory ) into a format suitable for use by another component (e.g., processor ). In some embodiments, I\/O interface  may include support for devices attached through various types of peripheral buses, such as a variant of the Peripheral Component Interconnect (PCI) bus standard or the Universal Serial Bus (USB) standard, for example. In some embodiments, the function of I\/O interface  may be split into two or more separate components, such as a north bridge and a south bridge, for example. Also, in some embodiments some or all of the functionality of I\/O interface , such as an interface to system memory , may be incorporated directly into processor .","Network interface  may be configured to allow data to be exchanged between computing device  and other devices  attached to a network or networks , for example. In various embodiments, network interface  may support communication via any suitable wired or wireless general data networks, such as types of Ethernet network, for example. Additionally, network interface  may support communication via telecommunications\/telephony networks such as analog voice networks or digital fiber communications networks, via storage area networks such as Fibre Channel SANs, or via any other suitable type of network and\/or protocol.","In some embodiments, system memory  may be one embodiment of a computer-accessible medium configured to store program instructions and data as described above for  for implementing embodiments of the corresponding methods and apparatus. However, in other embodiments, program instructions and\/or data may be received, sent or stored upon different types of computer-accessible media. Generally speaking, a computer-accessible medium may include non-transitory storage media or memory media such as magnetic or optical media, e.g., disk or DVD\/CD coupled to computing device  via I\/O interface . A non-transitory computer-accessible storage medium may also include any volatile or non-volatile media such as RAM (e.g. SDRAM, DDR SDRAM, RDRAM, SRAM, etc.), ROM, etc., that may be included in some embodiments of computing device  as system memory  or another type of memory. Further, a computer-accessible medium may include transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as a network and\/or a wireless link, such as may be implemented via network interface . Portions or all of multiple computing devices such as that illustrated in  may be used to implement the described functionality in various embodiments; for example, software components running on a variety of different devices and servers may collaborate to provide the functionality. In some embodiments, portions of the described functionality may be implemented using storage devices, network devices, or special-purpose computer systems, in addition to or instead of being implemented using general-purpose computer systems. The term \u201ccomputing device\u201d, as used herein, refers to at least all these types of devices, and is not limited to these types of devices.","Various embodiments may further include receiving, sending or storing instructions and\/or data implemented in accordance with the foregoing description upon a computer-accessible medium. Generally speaking, a computer-accessible medium may include storage media or memory media such as magnetic or optical media, e.g., disk or DVD\/CD-ROM, volatile or non-volatile media such as RAM (e.g. SDRAM, DDR, RDRAM, SRAM, etc.), ROM, etc., as well as transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network and\/or a wireless link.","The various methods as illustrated in the Figures and described herein represent exemplary embodiments of methods. The methods may be implemented in software, hardware, or a combination thereof The order of method may be changed, and various elements may be added, reordered, combined, omitted, modified, etc.","Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. It is intended to embrace all such modifications and changes and, accordingly, the above description to be regarded in an illustrative rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
