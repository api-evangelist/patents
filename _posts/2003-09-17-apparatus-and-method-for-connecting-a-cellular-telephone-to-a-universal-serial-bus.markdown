---
title: Apparatus and method for connecting a cellular telephone to a universal serial bus
abstract: A mobile phone interface (MPI) is molded between the ends of a Universal Serial Bus (USB) cable. One end of the USB cable is plugged into a standard USB port on a personal computing device and the other end is plugged into a cellular telephone. The MPI comprises a USB serial interface engine (USB SIE), a digital translation block (DTB) and a cellular phone interface. The cellular phone interface provides electrical connections to the signals within the supported cellular telephone. The DTB performs synchronous and asynchronous data transfers and buffer functions in accordance with the implemented protocol. The USB serial interface engine performs serialization, de-serialization and USB set-up in accordance with USB standards. Software for controlling the MPI is installed on the computer system. The control software comprises a communication control stack, a hardware access driver and an external plug-in module.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07079865&OS=07079865&RS=07079865
owner: Skyworks Solutions, Inc.
number: 07079865
owner_city: Irvine
owner_country: US
publication_date: 20030917
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["The present application is a continuation of U.S. patent application Ser. No. 09\/312,064, filed May 13, 1999 now U.S. Pat. No. 6,625,472.","1. Field of the Invention","The present invention relates generally to a system and method for connecting a cellular telephone to a computer system, and more specifically to a system and method for connecting a cellular telephone to a personal computer system through a universal serial bus port.","2. Related Art","There is an increasing need for connecting portable computing devices to computer networks, such as the Internet. A very economical way to perform such connections is to make use of existing cellular telephones that are already in use by consumers. Thus, there is a great need for an efficient and economical means for connecting cellular telephones to portable computing devices, such as lap top computers, personal digital assistants (PDAs) and the like.","Several systems for connecting cellular telephones to personal computer systems exist today. The problem is that these current systems are very expensive both from a manufacturing standpoint and from a consumer standpoint. In addition, many of these systems require that the PC manufacture (or OEM) install a unique and proprietary cellular telephone connector to the PC motherboard or other device. Such unique connectors can only be used with specific cell phone cables that are also produced by the PC manufacturer or OEM. Thus, these current solutions prevent users from connecting their cellular telephones to other personal computer systems that lack the specific built-in and proprietary connectors.","Other solutions that are in existence today, for example, make use of a PCMCIA card to connect cellular telephones to personal computer systems. The advantage to using these systems is that they can be attached to any personal computer system that supports the Personal Computer Memory Card International Association (PCMCIA) standard.","However, the problem is that these systems are extremely expensive to manufacture. Furthermore, these devices, although relatively small, are bulky when compared to the size of many PDAs in existence today. Additionally, these devices require a separate proprietary cable in addition to the PCMCIA logic card. Still further, these devices include a micro-controller, which increases the expense, size, weight and power requirements of the device.","Therefore, what is needed is a system and method for connecting a personal computing system to a cellular telephone that is economical, small in size and weight, consumes low power and can be used with a variety of general-purpose computing systems.","Accordingly, the present invention is directed toward an economical system and method for connecting a cellular telephone to a personal computing device, such as a laptop computer or a personal digital assistant (PDA). The present invention can be made extremely small, has very low power requirements and is economical to manufacture. Furthermore, the present invention can be used with a variety of general-purpose computing systems.","In one embodiment of the present invention, a mobile phone interface (MPI) is molded between the ends of a Universal Serial Bus (USB) cable. One end of the USB cable is plugged into a standard USB port on any personal computing device that supports the USB standard. The other end of the USB cable is plugged into a cellular telephone.","The MPI comprises several logic components that are controlled by software installed on the personal computing system. Preferably, the MPI is implemented using integrated circuit technology such as an application-specific integrated circuit (ASIC) or the like. In this fashion, the MPI can be made extremely small and unobtrusive to the user. In fact, in a preferred embodiment, the MPI is not much wider than the USB cable itself.","The portability of the MPI is a distinct advantage of the present invention over current systems. In addition, the adaptability, (i.e. the ability to use the present invention with any personal computer that supports USB), is another distinct advantage of the present invention. Another advantage of the present invention is that it makes use of the attached computer system to provide the control for the MPI via software, thereby lowering the cost, size and power requirements of the USB adapter.","In one embodiment, the MPI comprises a USB serial interface engine (USB SIE), a digital translation block (DTB) and a cellular phone interface. The cellular phone interface component is used to provide electrical connections to the signals within the supported cellular telephone. Typically, the configuration of the cellular phone interface is in accordance with cellular phone interface standards. An example of such a standard is the NTT DoComo standard, which provides standard interfaces for particular cellular telephone systems in Japan. The advantage to using such standards is that the telephone interface connections do not vary between cellular handset manufacturers.","The DTB component of the present invention performs synchronous and asynchronous data transfer functions in accordance with the particular protocol implemented for each specific embodiment of the present invention. In addition, a typical embodiment includes data buffers to buffer the data between the USB bus and the cellular phone system. The USB serial interface engine performs serialization and de-serialization of USB transmissions as well as implementing the necessary communication protocol and set-up procedures in accordance with the USB standards.","Software for controlling the MPI and for interfacing between the application program running on the computer system and the MPI, is installed on the personal computer system. The software comprises a communication control stack, a hardware access driver and an external plug-in module. The communication control stack comprises an AT parser for parsing standard Hayes AT commands, a call control module for controlling the transfer of data and a number of internal plug-in protocol modules. In addition an external plug-in module is provided. The external plug-in module comprises an external protocol stack and may have its own AT and command parsers.","The external protocol stack comprises a control path and a data path. The control path is used to process control and status data and the data path is used to process communications data. The control path comprises a high level interface, a control stack and a low level interface. Similarly, the data path comprises a high level interface, a data stack and a low level interface.","The high level interfaces communicates with the communication control stack and the low lever interfaces communicate with the hardware access driver, which is closely coupled to the hardware in the MPI. The hardware access driver is interrupt-driven based on the hardware interrupt requests generated by the MPI. The control stack is used to format and store control and status data. The format of the control and status data is in accordance with the particular protocol being implemented by the external protocol stack.","Similarly, the data stack is used to format and store communications data. The format of the communications data is in accordance with the particular protocol being implemented by the external protocol stack.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 1","b":["1","9","9","8","3","1"]},"In this example the typical cellular network is represented by a base station  that is coupled with a public switched telephone network , through a mobile switching center . Typically, the base station  comprises a radio transceiver used for communicating with the radio transceiver built into the cell phone . This forms the wireless link  of the communication channel. The wireless link  may comprise a digital or analog signals depending on the specific implementation of the present invention. In the example embodiments described below, digital cellular phone systems are used. The use of a digital cellular phone system in the examples below should not be construed to limit the scope and breadth of the present invention.","The base station  is typically coupled with the mobile switching center  via standard wired telecommunication transmission links. Similarly, wired transmission links are used to connect to the public switched network  and to the computer network . The wired link between the public switched network  and the Internet  is generally referred to as a point-of-presence with respect to the Internet .","In this example, the end-to-end communication path is completed at the server . The server  is also connected to the Internet  in some fashion. The configuration shown in  can be used for example, to connect a web browser application program running on the laptop computer system , with a world-wide-web server  on the Internet . Thus, for example, the laptop computer  can communicate in this fashion with any server coupled to the Internet .",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 2","b":["3","1","16"]},"The MPI  comprises a Universal Serial Bus (USB) serial interface engine (USB SIE) , a digital translation block (DTB)  and a cell phone interface module . The cellular phone interface component  is used to provide electrical connections to the signals on the cellular telephone . The configuration of the cell phone interface is in accordance with the particular cellular phone  used to connect to the present invention.","The DTB  performs synchronous and asynchronous functions as necessary for the cell phone's data channel and control channel respectively. In addition, the DTB  buffers data between the USB SIE  and the cell phone interface module . The USB serial interface engine  performs serialization and de-serialization of USB transmissions as well implementing necessary communications and set-up procedures in accordance with the standard USB protocols.","As shown, the MPI  connects to a standard USB controller  through a standard USB connector . The USB controller  is typically built into the personal computer system . USB is a personal computer bus that can support up to 127 peripheral devices in a daisy chain configuration. One advantage to using USB is the use of inexpensive cables can be up to 5 meters long. In addition, as described below, the MPI  of the present invention can be implemented on a single ASIC. This reduces size requirements for the MPI  so that an embodiment of the present invention can be molded into a standard USB cable in a very inconspicuous manner.","In general, USB is a \u201cplug-and-play\u201d interface between a computer and add-on devices. Typical add-on devices that use the USB are audio players, joysticks, keyboards, telephones, external modems, scanners, and printers. One benefit to using USB technology is that new devices can be added without having to add an adapter card and without having to turn the computer system  off. The USB peripheral bus standard was developed by Compaq, IBM, DEC, Intel, Microsoft, NEC, and Northern Telecom.","In addition, since October 1996, the Windows\u00ae operating systems have been equipped with USB drivers or special software designed to work with specific I\/O device types. USB is integrated into Windows 98. In addition, USB support was added to Windows 95. Thus, the Microsoft Windows 9x operating systems now support USB devices. As of mid-1998, most new computer systems have been equipped with one or more USB ports. USB ports are also becoming very popular on laptop computer systems and PDAs and the like. An embodiment of the present invention can be used with any device that supports USB.","As shown, the USB controller  is typically coupled to a standard Peripheral Component Interconnect (PCI) bus  on the personal computer system (also referred to a \u201cPC\u201d) . However, the particular means to implement the USB I\/O port is immaterial to the present invention as long as the USB peripheral bus standard is implemented. As will be described below, the USB SIE component  implements the USB peripheral bus standard for communicating between the DTB  and the USB controller .",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 3","b":["16","16","21"]},"PDC has two modes of data communications. The first mode is referred to as \u201cHigh-Speed Data Mode\u201d and provides data communications up to 9600 bps. The second mode of PDC is referred to as \u201cPacket Mode\u201d and provides packet data communications up to 28.8 Kbps.","It is noted that in the examples below, a PDC telephone system is used to distinctly point out and describe the details of a preferred embodiment of the present invention. Persons skilled in the relevant art(s) would appreciate that the present invention can be used with any type of cellular technology. Examples of other cellular technologies that can be used with the present invention include, but are not limited to GSM, CDMA and TDMA. Accordingly, by reading the present disclosure, persons skilled in the relevant art(s) would be able to apply the principals presented in the examples herein to other cellular telephone technologies for the purpose of implementing alternate embodiments of the present invention. As such, the examples presented herein should not be construed to limit the scope and breadth of the present invention.","In , a PDC telephone  is coupled to the MPI  in accordance with an embodiment of the present invention. A standard pin-out for a PDC telephone  is shown in block . In this example, the standard pin-out for the phone side  is in accordance with NTT DoComo standards for digital PDC cellular telephones. Additionally,  depicts the interconnection between the MPI  (specifically, the cell phone interface ), and the standard PDC interface .","As stated, in this example using PDC, two modes of data communications are possible. The first mode is referred to as \u201cHigh Speed Data Mode\u201d and provides data communications up to 9600 bps. The pin-outs and definitions for PDC High Speed Data Mode are shown below in Table 1. The names of the signals correspond with the pin-out  as depicted in ",{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"PDC High-speed Phone Side Data Mode Connector"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PDC High Speed",{}]},{"entry":["Name of Pin","Data Mode Signal Description","Direction"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["TCH_TX","Transmit synchronous data (28 Bytes\/frame)","PDC\u2190PC"]},{"entry":["TCH_FRAME","This signal tells if the current frame is","PDC\u2192PC"]},{"entry":[{},"Rx (H) or Tx (L)."]},{"entry":["TCH_CLOCK","Clock signal (42 kbps bit rate intermittent","PDC\u2192PC"]},{"entry":[{},"clock)"]},{"entry":["CTL_TX","TX control serial data (600\u20139600 bps)","PDC\u2190PC"]},{"entry":["CTL_RX","RX control serial data (600\u20139600 bps)","PDC\u2192PC"]},{"entry":["TCH_RX","Receive synchronous data (28 Bytes\/frame)","PDC\u2192PC"]},{"entry":["ADP","Indication whether PC is connected to PDC","PDC\u2190PC"]},{"entry":["PDC Control","Signal to enable the direct memory access","PDC\u2190PC"]},{"entry":["signal1","of the PDC phone for Phone book support"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The second mode of PDC is referred to as \u201cPacket Mode\u201d and provides packet data communications up to 28.8 Kbps. The pin-outs and definitions for PDC Packet Mode are shown below in Table 2. The names of the signals correspond to the pin-outs  as depicted IN .",{"@attributes":{"id":"p-0057","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"PDC Packet Mode Connector"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PDC High-speed",{}]},{"entry":["Name of Pin","Data Mode Signal Description","Direction"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["TCH_TX","Transmit synchronous data (HDLC frame)","PDC\u2190PC"]},{"entry":["TCH_FRAME","This signal tells if the system is in","PDC\u2192PC"]},{"entry":[{},"communication"]},{"entry":["TCH_CLOCK","Clock signal (42 kbps LAPB clock)","PDC\u2192PC"]},{"entry":["CTL_TX","TX control serial data (600\u20139600 bps)","PDC\u2190PC"]},{"entry":["CTL_RX","RX control serial data (600\u20139600 bps)","PDC\u2192PC"]},{"entry":["TCH_RX","Receive synchronous data (HDLC frame)","PDC\u2192PC"]},{"entry":["ADP","Indication whether PC is connected to PDC","PDC\u2190PC"]},{"entry":["PDC Control","Signal to enable the direct memory access","PDC\u2190PC"]},{"entry":["signal1","of the PDC phone for Phone book support"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 4","FIG. 4"],"b":["16","16","13","14","15","15","21"]},"The left side of  depicts the USB controller  that typically resides in the host computer system , as shown in . The USB controller  is coupled with the USB SIE  of the MPI . As indicated, the USB SIE  comprises four functional blocks , ,  and  that correspond to the USB Endpoints ,,  and  respectively. For the purposes of the discussion herein, the USB Endpoints can be thought of as data pipes. The USB Endpoint modules , ,  and  are implemented in accordance with USB protocol standards. Accordingly, the logic used to implement the USB Endpoints is dictated by the USB protocol standards. Such logic is well known and would be apparent to persons skilled in the relevant art(s).","As shown, the Endpoint-  data pipe is used for USB setup. In this example, the Endpoint-  data pipe is used for the data channel for sending and receiving data between the cell phone  and the USB controller . Endpoint-  is used for the control and status channel between the USB controller  and the cell phone . Endpoint-  is used in conjunction with a general-purpose input\/output (GPIO) module  to manage  additional control signals required to operate the cell phone , as shown.","As stated, The DTB module  performs synchronous and asynchronous functions as necessary to manage the cell phone's data channel and control channel respectively. In addition, the DTB  buffers data between the USB SIE  and the cell phone interface module  as required in accordance with data transmission speeds and the implemented protocol.","In this example, a 16\u00d79 FIFO is used to buffer the data channel in each direction. In particular, a transmit FIFO  is used to buffer data from the data channel USB Endpoint- . Similarly, a receive FIFO  is used to buffer data from the TCH receiver\/transmitter (TCH RxTx) . The depth of each data buffer, such as the data buffer , depends on the baud rate (i.e. maximum transmission speed possible) of each implementation of the present invention.","Thus, the Endpoint-  receives data from the USB controller . From there, the data is stored and queued in the 16\u00d79 transmit FIFO . As described below, The TCH RxTx , which functions as a Synchronous Receiver\/Transmitter, sends the data in a serial fashion from the FIFO  through the TCH_TXD signal. The TCH_Frame and TCH_Clock signals  are used to perform the necessary synchronous functions. In this example, when the TCH_FRAME signal  is high, data is received on the TCH_RX line synchronously with the TCH_CLOCK signal. Similarly, when the TCH_FRAME signal  is low, data is sent on the TCH_TX line synchronously with the TCH_CLOCK signal. A timing diagram shown in  illustrates the the various timings for the synchronous data flow in accordance with this example embodiment of the present invention.","Data received from the TCH_RXD line  is de-serialized by the TCH RxTx  and stored in the receive FIFO . Data from the receive FIFO , is sent through the Endpoint-  data pipe to the USB controller .","Endpoint-  is used for the control and status channel in this example. As noted, a two-byte transmit FIFO  and a two-byte receive FIFO  are used to buffer the control and status data. A standard Universal Synchronous\/Asynchronous Receiver Transmitter (USART)  in asynchronous mode is used to serialize and de-serialize the control and status data. Thus, control and status data are sent to the PC  via the Serial In signal . This data is de-serialized and stored in the Rx FIFO . From there the data is sent to the Endpoint-  data pipe to the USB controller . Similarly, control and\/or status data is sent from the USB controller , to the Endpoint-  data pipe. From there the data is stored in the Transmit FIFO  before it is serialized by the USART  and sent to the cell phone  via the Serial Out signal .","A precision time generator (PTG)  is used to control the baud rate of the asynchronous control\/status channel. Specifically, one PTG  is connected to the receive side of the USART  and another PTG  is connected to the transmit side of the USART  to control the baud rate is both directions.","The Endpoint- module is used to drive the GPIO logic module  to send additional control signals from the PC  to the cell phone . Specifically, the GPIO logic module  is used to supply the Control signal- and the ADP signal to the cell phone . As indicated in the table above, in this example, the ADP signal indicates to the cell phone  whether the PC  is connected. Similarly, the PDC control signal  is used to enable direct memory access of the PDC  phone for phone book support. This is a feature that is specific to PDC. Other GPIOs can be added for other cellular phone system (like PHS, CDMA, . . . ).","As would be apparent to person(s) skilled in the relevant art(s), the particular functions implemented by the various USB Endpoints , ,  and  are somewhat arbitrary and will vary depending on each implementation of the present invention. Accordingly, the examples presented herein should not be construed to limit the scope and breadth of the present invention.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 6","b":["62","1","46","62","108","52","102","50","108","62","54","54","107","54","101","101","100","50","1","44","1","44"]},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 7","b":["1","44","62","1","44","50","121","54","124","124","62","54","122","125","50","62"]},"Register settings for the precision time generators , the USART , the GPIO module  and the TCH Receiver\/Transmitter  are described below. It is noted that these are examples depicting one method that can be used to implement the example embodiment and should not be construed to limit the scope and breadth of the present invention.","Precision Time Generator A (PTGA) and PTGB ","The PTGA  is connected to the receive side of the USART  and PTGB  is connected to the Transmit side. Only one PTG  is shown in  for simplicity. Preferably, PTGA and PTGB  consist of five 8-bit registers and a 17-bit pulse accumulator. The three input registers are: PTG Mode Register, PTG Buffer, PTG Upper Latch. The two output registers are: PTG Lower Residue, PTG Upper Residue.",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Programmable Timing Generator A and B"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PTGA","PTGB"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"PTG Mode Register (PAM)","PTG Mode Register (PBM)"]},{"entry":[{},"PTG Buffer (PAB)","PTG Buffer (PBB)"]},{"entry":[{},"PTG Upper Latch (PAUL)","PTG Upper Latch (PBUL)"]},{"entry":[{},"PTG Lower Residue (PALR)","PTG Lower Residue (PBLR)"]},{"entry":[{},"PTG Upper Residue (PAUR)","PTG Upper Residue (PBUR)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"The contents of the three input registers are readable and writable. Whenever the CPU in the PC  writes to the PTG Upper Latch, the content of the PTG buffer is transferred to PTG Lower Latch. This allows a simultaneous 16-bit update of the input latch. Operation of the precision time generator is governed by the equation:\n\nRate=Latch*(Internal clock rate in Hz)\/2\n",{"@attributes":{"id":"p-0076","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"PTG Mode Register Bits"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Bit 7: PTG interrupt flag","This bit is read only. This bit is set to logic 1"]},{"entry":[{},"when the PTG accumulator overflows. Reading"]},{"entry":[{},"or writing to PTG upper latch clears this flag."]},{"entry":["Bit 6: PTG interrupt","When bit 6 is a logic 1, interrupt is asserted"]},{"entry":["Enable.","when the interrupt flag is set to a logic 1."]},{"entry":"Bit 5\u20132: Not used."},{"entry":["Bit 1: PTG output enable","When set to logic 1, output port is connected"]},{"entry":[{},"to the accumulator overflow."]},{"entry":["Bit 0: PTG Timer Mode","When set to logic 1, PTG operates as a timer."]},{"entry":["Select","When set to logic 0, PTG operates as a"]},{"entry":[{},"precision time generator."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"USART  (Control Channel) Registers","The USART 8 bit registers are defined as follows:\n\n","A read to the serial-in-buffer removes data from the RXD input buffer. A write to the serial-out-buffer loads data into the TXD output buffer.","Serial Interrupt Register",{"@attributes":{"id":"p-0081","num":"0090"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Serial Interrupt Register (SIR)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SIR7 - RXD Status","This bit is set to 1 whenever any of the following"]},{"entry":["Interrupt Flag:","status signals are true: Frame error (SS3),"]},{"entry":[{},"parity error (SS2), or overrun error (SSR1)."]},{"entry":[{},"This bit is also set whenever the RXD status"]},{"entry":[{},"break interrupt (SS4) changes state. SIR7 is"]},{"entry":[{},"cleared by writing to the Status Register (SSR)."]},{"entry":["SIR6 - RXCLK Output","SIR6 is set to 1 for internally generated RXCLK"]},{"entry":["Enable:","to become an output signal."]},{"entry":["SIR5 - TXCLK Output","SIR5 is set to 1 for internally generated TXCLK"]},{"entry":["Enable:","to become an output signal."]},{"entry":"SIR4\u20133: Not Used."},{"entry":["SIR2 - RXD Status","When SIR2 and SIR7 are both set, interrupt is"]},{"entry":["Interrupt Enable:","asserted."]},{"entry":["SIR1 - TXD Buffer","This bit, when 1, enables interrupt to be asserted"]},{"entry":["Empty:","when the TXD buffer empty bit (SSR5) is"]},{"entry":[{},"also set."]},{"entry":["SIR0 - RXD Buffer","This bit, when is a logic 1, enables interrupt to be"]},{"entry":["Full:","asserted when the RXD buffer full bit (SSR0)"]},{"entry":[{},"is also set."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Serial Mode Register",{"@attributes":{"id":"p-0083","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Serial Mode Register (SMR)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SMR7 - TXD Mode","When 1, all TXD functions are enabled for"]},{"entry":["enable","either asynchronous or synchronous operation."]},{"entry":["SMR6 - RXD Mode","When 1, all RXD functions are enabled for"]},{"entry":["enable","either asynchronous or synchronous operation."]},{"entry":["SMR5 - USART timing","This bit must be set to logic 0 in Basic 2. Then"]},{"entry":["source","the assigned precision timing generator is the"]},{"entry":[{},"assigned USART timing source for all"]},{"entry":[{},"asynchronous or synchronous operations."]},{"entry":["SMR4 - Synchronous","This bit must be set to logic 0, which selects"]},{"entry":["Mode select","asynchronous modes for all USART operations."]},{"entry":"SMR3 - not Used"},{"entry":["SMR2 - TX Reference","This bit must be set to logic 0, which selects"]},{"entry":["Clock Select","the internally generated clock from the PTGA."]},{"entry":["SMR1\u2013SMR0 - Not","This is set to logic 0 for asynchronous"]},{"entry":["used.","operation."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Serial Line Register",{"@attributes":{"id":"p-0085","num":"0094"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Serial Line Register (SLR)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SLR7 - Parity Stuff","This bit is copied to the TXD parity bit position"]},{"entry":["Bit","when SLR3 and SLR5 are both set to logic 1."]},{"entry":["SLR6 - Set Break","If 1, the TXD signal is forced to a space, logic 0."]},{"entry":[{},"Break is disabled by clearing this bit."]},{"entry":["SLR5 - Enable Parity","When SLR5 and SLR3 are both set, SLR7 is"]},{"entry":["Stuff","copied to the TXD parity bit position."]},{"entry":["SLR4 - Even Parity","When SLR3 is enabled and SLR5 is disabled, a"]},{"entry":[{},"one or zero is automatically inserted to the TXD"]},{"entry":[{},"parity position. The total number of ones in the"]},{"entry":[{},"data and parity fields is either odd (SLR4 = 0)"]},{"entry":[{},"or even (SLR4 = 1)."]},{"entry":["SLR3 - Enable Parity","If set to a logic 1, a logic 1 or 0 parity bit is"]},{"entry":[{},"inserted into the TXD parity position. The parity"]},{"entry":[{},"bit is positioned between the last data bit and"]},{"entry":[{},"first stop bit in the serial bit stream."]},{"entry":["SLR2 - Two Stop","When this bit is set in the asynchronous"]},{"entry":["Bits","operation, a second stop bit is added to the TXD"]},{"entry":[{},"serial bit stream."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SLR1:0 - Word","SLR1","SLR0","Word Length"]},{"entry":["Length","0","0","5 bits"]},{"entry":[{},"0","1","6 bits"]},{"entry":[{},"1","0","7 bits"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"8 bits"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Serial Status Register",{"@attributes":{"id":"p-0087","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Serial Status Register (SSR)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SSR7 - RXD Parity Bit","This bit copies the received parity bit."]},{"entry":["SSR6 - TXD Under-run","This bit is set to a logic 1 whenever the"]},{"entry":[{},"TXD shift register empties and the TXD"]},{"entry":[{},"input buffer has not been loaded by the"]},{"entry":[{},"CPU. SSR6 is cleared when the CPU"]},{"entry":[{},"writes new data to the TXD input"]},{"entry":[{},"buffer."]},{"entry":["SSR5 - TXD Buffer Empty","This bit is set to indicate that the RXD"]},{"entry":[{},"input buffer is empty."]},{"entry":["SSR4 - RXD break Interrupt","This bit is set to logic 1 whenever the"]},{"entry":[{},"RXD data input is held in the space"]},{"entry":[{},"(logic 0) state continuously from the"]},{"entry":[{},"start bit to the first stop bit. This bit is"]},{"entry":[{},"cleared when a mark bit (logic 1) is"]},{"entry":[{},"detected."]},{"entry":["SSR3 - RXD Framing Error","SSR3 is set when RXD channel detects an"]},{"entry":[{},"incorrect stop bit and cleared when a"]},{"entry":[{},"correct first stop bit is detected."]},{"entry":["SSR2 - RXD Parity Error","SSR2 is set when a parity error is found."]},{"entry":["SSR1 - RXD Overrun Error","SSR1 is set when a new data is being"]},{"entry":[{},"transferred from the RXD shift register to"]},{"entry":[{},"the RXD output buffer and the previous"]},{"entry":[{},"data in the output buffer has not been read"]},{"entry":[{},"by the CPU."]},{"entry":["SSR0 - RXD Buffer Full","SSR0 is set when a new character from"]},{"entry":[{},"the RXD shift register is downloaded into"]},{"entry":[{},"the RXD output buffer and cleared when"]},{"entry":[{},"the CPU reads the contents in he RXD"]},{"entry":[{},"output buffer."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Serial Form Register",{"@attributes":{"id":"p-0089","num":"0098"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Serial Form Register (SFR)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SFR7 - Not used.","Set to logic 0."]},{"entry":["SFR6 - Not used.","Set to logic 0."]},{"entry":["SFR5 - TXD to RXD","When SFR5 = 1, the RXD input pin is routed"]},{"entry":["loop-back","as a TXD output pin."]},{"entry":["SFR4 - Not used.","Set to logic 0."]},{"entry":["SFR3 - Not used","Set to logic 0."]},{"entry":["SFR2 - PTG Div by 3","When SFR2 = 1, the PTG direct timing is"]},{"entry":["Bypass:","selected when SMR5 = 0."]},{"entry":[{},"When SFR2 = 0, the PTG timing is"]},{"entry":[{},"divided by 3."]},{"entry":["SFR1 - 0: Short Stop Bit.","This must be set to 0 for 1-bit width stop bit."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Serial Out Divider Latch (SODL)","This is restricted to a value of $0F for asynchronous operation. Each time CPU  writes to the SODL, the new latch value is download to the SOUT programmable counter in the USART.","Serial In Divider Latch (SIDL)","When asynchronous operation is selected, the latch should contain a hex value of $0F.","GPIO Logic Block ",{"@attributes":{"id":"p-0095","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 10"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"GPIO Registers"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Register Name","R\/W","Bit Positions"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"GPIN","R","8:0"]},{"entry":[{},"GPOUT","R\/W","8:0"]},{"entry":[{},"GPO_MODE","R\/W","8:0"]},{"entry":[{},"GPDIR","R\/W","8:0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"GPIN[8:0]=GPIO inputs.","GPOUT[8:0]=GPIO outputs. Writing to bits programmed as inputs does nothing.","GPDIR[8:0]=>\u20180\u2019 programs the particular GPIO to be an input. A logic 1 programs the corresponding GPIO to be an output. 0x0000 is default.","GPO_MODE register controls the behavior of GPIO pins. When a GPIO is an input, GPO_MODE[x]=1 indicates that GPIO[x] generates level interrupts. Otherwise, GPIO[x] generates edge interrupts. When a GPIO is an output, GPO_MODE[x]]=1 indicates that GPIO[x] is an open drain driver. Otherwise, GPIO[x] is a pullup\/pulldown (totem-pole) driver.","TCH Receiver\/Transmitter  (Synchronous Data Channel)","The data channel uses the following 8 bit registers:\n\n","Control Register:","Read\/write register on all bits","Default value of the register\u20140x00","Bit \u2014Inverted Interrupt Request. When high the output Interrupt Request output pin will be active low. When low the output Interrupt Request output pin will be active high.","Bit \u2014PDC transmitter enable. When high allows performing a transmission via PDC block. When low it resets all transmitter machine and counters.","Bit \u2014PDC receiver enable. When high allows performing receiving from PDC block. When low it resets all receiver machine and counters.","Bits ,,,, are reserved.","Status Register:","Bits ,  are read only; bits , , , , ,  are read\/cleared by 1 writing","Default value of the register\u20140x00","Bit \u2014Transmitter FIFO is not full. It is set when transmitter FIFO contains at least 1 empty byte. It is cleared when amount of bytes written to the Data register and not yet transmitted by PDC block equals to the transmitter FIFO size.","When bit  (PDC transmitter enable) of the Control register is low then bit  of the Status register is always zero.","Bit \u2014Transmitter FIFO  is overrun.","It is cleared when bit  of the Control register is low or by \u201c1\u201d writing to bit  of the Status register.","Bit \u2014Transmitter FIFO  is underrun.","It is cleared when bit  of the Control register is low or by \u201c1\u201d writing to bit  of the Status register.","Bit \u2014TCH_FRAME negative front detected.","It is cleared when bit  of the Control register is low or by \u201c1\u201d writing to bit  of the Status register.","Bit \u2014Receiver FIFO  is not empty. It is set when receiver FIFO  contains at least 1 received byte. It is cleared when amount of bytes received by PDC block and not read from the Data register equals zero.","When bit  (PDC receiver enable) of the Control register is low then bit  of the Status register is always zero.","Bit \u2014Receiver FIFO  is overrun.","It is cleared when bit  of the Control register is low or by \u201c1\u201d writing to bit  of the Status register.","Bit \u2014Receiver FIFO  is underrun.","It is cleared when bit  of the Control register is low or by \u201c1\u201d writing to bit  of the Status register.","Bit \u2014TCH_FRAME positive front detected.","It is cleared when bit  of the Control register is low or by \u201c1\u201d writing to bit  of the Status register.","Data Register","Always write in order: Data Register high byte\u2014first; Data Register low byte\u2014second. Always read in order: Data Register high byte\u2014first; Data Register low byte\u2014second. Default value of the register\u20140x0000","For Writing:","Bits \u2013\u2014Byte of data to be transmitted itself.","Bit \u2014\u201cFirst byte in the frame\u201d marker. It is high if the byte (bits \u2013) is considered as the first byte is in PDC frame. If bit  is low the byte will be transmitted as not the first byte in the PDC frame.","Bits \u2013\u2014reserved, ignored by PDC transmitter.","Bit \u2014\u201cValid byte\u201d marker. If this bit is low the byte in bits \u2013 will be ignored already at transmitter FIFO  level. When bit  is high the byte written to the bits \u2013 will be transmitted.","Note that when there is no data in transmitter FIFO  the high level is generated on transmitter output.","For Reading:","Bits \u2013\u2014Byte of data received itself.","Bit \u2014\u201cFirst byte in the frame\u201d marker. It is high if the byte (bits \u2013) received was the first byte is in PDC frame. If bit  is low the byte was not the first byte in the PDC frame.","Bits \u2013\u2014reserved, always return zeros.","Bit \u2014\u201cValid byte\u201d marker. It is low when receiver FIFO  is empty and read operation from the Data register was useless (additionally bits \u2013 of Data Register will be 0xFF when read). When bit  is high the byte in the bits \u2013 really was received by PDC block and placed in the receiver FIFO .","Interrupt Mask Register","Read\/write register on all bits","Default value of the register\u20140x00","Bit 7:0\u2014Interrupt request enable bits. When bit \u2018i\u2019 is high it allows for bit \u2018i\u2019 of the Status register to be propagated to the Interrupt Request output pin.",{"@attributes":{"id":"p-0145","num":"0159"},"figref":["FIG. 8","FIG. 8"],"b":["1","151","154","156"]},"In this example, the operating system used to describe an embodiment of the present invention is the Microsoft Windows 9x operating system. It is noted that this operating system is just one example of an operating system that can be used to implement the present invention. In other embodiments, different operating systems can be used such as Windows NT, MAC operating systems, UNIX operating systems and the like. In fact, as described below, the modular software design architecture of the present invention supports the ability to port to different operating systems with minimal effort. The use of the Windows 9x operating system to implement the embodiment of the present invention described in the examples presented herein should not be construed to limit the scope and breadth of the present invention.","The first module represented in  is the application program component . An example of an application program  is a web browser, such as the Internet Explorer or Netscape Navigator. Another example of the application program is a data terminal emulation program, such as HyperTerminal. The application program  is also referred to as the \u201cDTE\u201d or data terminal emulation program.","The last block in  is a hardware component, namely the USB controller . The software modules between the application program  and the USB controller  are described below.","Block  represents two components of the present invention, namely the communication control stack (CCS) and the external protocol stack. As described below, in this example embodiment, the CCS is a generic \u201cmodem\u201d controller that can be used with numerous communication hardware devices. The external protocol stack can be viewed as a plug-in module (PIM) to the CCS. In this fashion, different external protocol stacks can be added by simply creating new modules. Thus, the core software in the CCS does not need to be altered when new \u201cexternal\u201d protocols are added.","As described below, the communication control stack  supports AT-style commands, off-line and on-line data modes, data and facsimile capabilities, and other necessary functions generally associated with network communications.","In general, the external wireless stack  is used to generate and\/or receive data and control frames in accordance with the implemented wireless protocol. For example, the external wireless stack  receives data from the application program  and creates data frames to be sent to the wireless telephone  in accordance with the PDC protocol.","As shown, the CCS and the external protocol stack  interfaces with the hardware , through the hardware access driver (HAD) . The HAD  is described in detail below. The HAD  is used to control the flow of data to and from the USB stack associated with the USB controller  and the MPI .","As shown, the HAD  interfaces between CCS and external protocol stack  and the USB Endpoint Interface module . The USB Endpoint Interface module  is used to interface with a USB driver  and adds USB frames to the data sent to the USB controller  in accordance with USB protocol standards. Similarly, the USB Endpoint interface module  removes USB frame information from the data sent from the USB controller . The block  represents a USB driver that is typically provided by the operating system. The operating system USB driver  interfaces between the USB controller  and the USB Endpoint Interface module .",{"@attributes":{"id":"p-0154","num":"0168"},"figref":"FIG. 9","b":"183"},"The CCS  comprises an AT parser , a call control module , a V.42bis protocol stack  and numerous plug-in modules . It is noted that each of the components described in the present specification, such as the v42bis  component and the plug-in modules , may be implemented as a separate executable program. Alternatively, one or more of the components may be combined within a single executable program.","The particular arrangement of the software modules is somewhat arbitrary and will generally vary with different embodiments of the present invention. Thus, the arrangements of the software modules in the examples herein, are used for exemplary purposes only to particularly point out and describe the general functionality of the present invention. As such, the arrangement and division of software components used to describe these examples should not be construed to limit the scope and breadth of the present invention.","The AT parser  is used to parse AT commands in accordance with the standard Hayes AT command set. The V.42bis module is used to implement compression and error correction algorithms, etc. in accordance with the V42bis standard. The call control module  is used to generate messages and to control the flow of data in accordance with the present invention.","As shown, the plug-in modules  may comprise one or more particular protocols that can be used with an embodiment of the present invention. In this fashion, the modular architecture of the CCS  allows for additional protocols to be added without affecting existing modules. For example, many different protocols can be supported by an embodiment of the present invention. This feature is illustrated in  by the different protocols P, P, . . . PN  coupled with the PCI bus . For example, when a new hardware device is supported, a new PIM can be added to  to implement such support.","In addition to the plug in modules , the external plug-in module or \u201cexternal PIM\u201d (also referred to as external or wireless protocol stack)  can be used to implement additional protocols without effecting modules within the CCS . In this example, the wireless PDC protocol is implemented in this fashion. Accordingly, the external PIM  is viewed as an additional PIM supported by the CCS . As shown, the CCS  and the external PIM  communicate through a pre-defined application programming interface (API). An example of a particular API that can be used in a preferred embodiment of the present invention is described in detail below.","As shown, the external PIM  comprises an AT parser and control module  and a protocol stack . Details of the protocol stack  are described below with reference to . In this example, the AT parser & control module  is an optional component that is used to parse AT commands when an external PIM  is active. That is, if this option is used the AT parser and control module  is used instead of the AT parser  and control modules  in the CCS , while the external PIM  is active. Thus, all AT commands, after the initial AT command used to load the external PIM , and up to and including the AT command used to unload the external PIM , are processed by the AT Parser and control module . Alternatively, if a separate AT parser  is not required by the specific implementation of the present invention, the AT parser  and control module  in the CCS  is used for all purposes.",{"@attributes":{"id":"p-0161","num":"0175"},"figref":"FIG. 10","b":["171","150","183","183","180","182","184","181"]},"Details of the external PIM  are shown in . In particular, the external PIM comprises an initialize and terminate module  and a protocol stack . The protocol stack  comprises the following components. As stated, the PDC protocol comprises a data channel and a control channel. In this example, the three modules ,  and  are used to implement the control channel. Similarly, the three modules , , and  are used to implement the data channel.","The two modules  and  at the top of the PIM  are referred to as \u201chigh level modules\u201d and the two modules  and  at the bottom are referred to as \u201clow level\u201d modules. These designations are based on the module's relative distance to the MPI hardware . That is, the low level modules  and  are closest to the hardware  relative to the high level modules  and . As will be described below, the low level modules  and  are hardware-interrupt-driven, and the high level modules  and  are timer driven.","The high level modules used to implement the control channel and data channel are referred to as PIM HCTL  and PIM HDATA , respectively. Similarly, the low level modules used to implement the control and data channels are referred to as the PIM LCTL  and PIM LDATA , respectively.","The PIM HCTL  is called by the call control module  in the CCS . The control stack  is used to store formatted control data in accordance with the particular wireless protocol being implemented, in this example, PDC. Thus, the control stack  is used to temporarily store data frames that are to be sent to the cellular telephone  via the MPI .","The PIM low level modules  and  are interrupt driven by the components in the MPI . For example, when the Tx FIFO  is ready to accept data, an interrupt signal is generated. This causes the HAD  to call the PIM LCTL  to determine if there is any data waiting on the control stack . If data is available, the PIM LCTL  fetches the framed data from the control stack  and sends it to the MPI  via the USB controller .","The PIM HDATA  is called periodically to exchange data with the application program . For example, in one implementation, PIM_HDATA  is called by the call control module  every 10 milliseconds to transmit and receive data. Data that is sent from the application program  is formatted in accordance with PDC protocol standards and queued in the data protocol stack . From there, based on hardware interrupts that are controlled through an interrupt service routine in the HAD module , the data is transferred to the Tx FIFO . Additional details of example data and control mechanisms in accordance with a preferred embodiment of the present invention are described below.","In addition, the external PIM  comprises an initialize module  and a termination module . The CCS  initializes and terminates the external PIM  by calling the  and  modules. Details of the initialize and terminate functions are described below.",{"@attributes":{"id":"p-0169","num":"0183"},"figref":"FIG. 11","b":["16","150"]},"Data sent from the DTE  gets stored in the DTE's TX buffer . This buffer is used whenever the application program  sends data. From the TX Buffer, the data is moved to the qTxQ  in the CCS . As stated, in a typical implementation, the CCS  calls the PIM_HDATA  (also referred to as PIM_HEX) periodically. For example, once every 10 milliseconds, the CCS  calls the PIM_HDATA .","If data is stored in the qTxQ  in the CCS  it is moved to the qDTEtxEPQ queue  when PIM_HDATA is called and the transmit operation is active (as distinguished from a PIM_HDATA receive call, as described below). Next, as indicated, the data is stored in the clnCompressBuffer , if data compression is enabled. If data compression is not enabled, the data is instead stored directly in the qTxqueue  within the data protocol stack , as described below.","If compression is enabled, the V42bis  module is called to encode the data as indicated by the encode logic block . The encoded data is then moved to the cOutCompressBuffer  and then stored in the cOutCompQ queue . Next as indicated, the data is sent to the data protocol stack .","Specifically, the data is first stored in the qTXqueue . From there the data frames are constructed by the ARQ error control protocol block  in accordance with the PDC protocol standards. Next the data is stored in the TxFrameBuffer .","The TCH data flow between the TxFrameBuffer  and the MPC  is interrupt driven. Accordingly, when the Transmit buffer  in the MPC  is ready to accept additional data, an interrupt is generated by the hardware. An interrupt service routine (not shown) in the HAD  is used to determine the cause of the interrupt (i.e. data or control, transmit or receive). Accordingly, in this example, the HAD  determines that the interrupt is caused by a data transmit ready condition (i.e. the FIFO  is ready to receive data). Thus, the HAD  moves the data from the TxFrameBuffer  into the QTxEPQ . From there, the data frame is buffered in the HAD  buffers, namely the HALTXBuffer  and the TX ISR Buffer , before being moved to the MPC  transmit FIFO .","The TX ISR Buffer is coupled with an interrupt service routine (ISR) within the HAD . As stated, the ISR (not shown) is used to determine the source of each interrupt so that the data is stored accordingly.","It is noted that in a preferred embodiment, the qTxEPQ  is at least 63 by 28 bytes in size. This size is required so that the queue  can hold at least 63 frames of data (at 28 bytes per frame) for supporting PDC error correcting routines that may require re-sending one or more of the past 62 data frames.","The data flow from the MPC  to the DTE  occurs as follows. First, an interrupt is generated when the Rx FIFO  receives data. This causes the HAD  to send the data fame through the Rx ISR Buffer  to the HALRxBuffer . Next, PIML_DATA is called and the data is moved to the qRxEPQ . From there, the data is stored in the RxFrameBuffer  within the data stack . The ARQ error control protocol block  operates on the data to remove the PDC header and frame information. This de-framed data is then stored in the qRXqueue .","Next, if data compression not enabled, the data is moved directly to the qDTErxEPQ . If data compression is enabled, V42bis  is called and the decode module  is used to decompress the data. The decompressed data is then stored in the cDeCompressBuffer . Next the data is stored in the qDTErxEPQ . The data remains there until the call control module  calls the PIM_HDATA module  to receive data. This typically occurs ones every 10 milliseconds. Once this function is called, the data frame is moved to the qRxQ  in the CCS  and sent to the RX Buffer  for receipt by the DTE .",{"@attributes":{"id":"p-0179","num":"0193"},"figref":"FIG. 12","b":["174","192","250","150","3"]},"This message is received by the CCS  and parsed by the AT parser , as indicated by step . Next, in step , the CCS  calls the initialize routine  in the PDC PIM . In step , the process determines if an error loading the PDC module  had occurred. If so, the process returns an error condition and ends, as indicated by step . If an error has not occurred and the PDC was loaded, then control continues with step , where the initialization routine  continues. Specifically, in step , the process initializes all software queues and stacks necessary for the data transfer operations, as described above. For example, memory allocation procedures and the like are performed for creating and reserving the data buffers and queues as described above with reference to .","Next, as indicated by step  all of the registers in the MPC ASIC  are set in accordance with the register tables described above. For example, the USART , the GPIOs , the TCH receiver\/transmitter  and the timer generators  are all initialized with the appropriate values. The process ends, as indicated by step  and returns with a value to indicate that no errors had occurred.",{"@attributes":{"id":"p-0182","num":"0196"},"figref":["FIGS. 13A and 13B","FIG. 13B"],"b":["266","150","150","267","180","268","182","185","269","186","186"]},"Referring now to , step  indicates the HAD  is notified of an interrupt request generated by the hardware in the MPC . An interrupt service routine in the HAD  determines the cause of the interrupt, which could be caused by a control or data channel, transmit or receive operation. In this example, it is assumed that the interrupt service routine has determined that the interrupt request is associated with the control path. Accordingly, step  determines whether the interrupt is associated with a transmit or receive operation.","For example, when the transmit control FIFO  is ready to receive data, it generates an interrupt. Similarly, when the receive control FIFO  receives data, it generates an interrupt. Thus, as indicated, if the interrupt from step  is associated with the control transmit path, step  is executed. In step  the HAD  calls the PIM_LCTL  to ask if any data is available. As indicated by step , if data is available, the PIM_LCTL  module moves the data from the control queue  to the HAD control buffer (not shown). If data is not available, the process ends as indicated by step .","If the interrupt from step  is associated with a control path receive operation, step  is executed. In step , the HAD  calls the PIM_LCTL  and the received data from the FIFO  is passed to the control stack . As indicated the process ends with step .",{"@attributes":{"id":"p-0186","num":"0200"},"figref":"FIG. 14A","b":["321","322","188","323","203","204","174","203","183"]},"In step , the process calls PIM_HDATA  again, but this time with \u201creceive\u201d mode enabled (see API description below). Next, in step , if any data is available in the external PIM queue (namely qTETrxEPQ ), it is moved to the DTE's  receive buffer , via the CCS queue .","Next, as indicated by step , the timer is checked to determine if 10 milliseconds or more have elapsed since the last call to PIM_HDATA in step . In this example, the timer is used to assure that PIM_HDATA  is called every 10 milliseconds. As indicated, once this time period has elapsed, the process repeats itself by looping back to step . As described above, the low level flow of the communication data is interrupt driven. A flowchart depicting this process is described below with reference to .",{"@attributes":{"id":"p-0189","num":"0203"},"figref":"FIG. 14B","b":["351","154","16","154","352"]},"For example, when the transmit data FIFO  is ready to receive data, it generates an interrupt. Similarly, when the receive data FIFO  receives data, it generates an interrupt. Thus, as indicated, if the interrupt from step  is associated with a transmit operation, step  is executed. In step  the HAD  calls the PIM_LDATA  to ask if any data is available. As indicated by step , if data is available, the PIM_LDATA  module moves the data from the data queue  to the HAD data buffer (specifically, HALTXBuffer ). If data is not available, the process ends as indicated by step .","If the interrupt from step  is associated with a data receive operation, step  is next executed. In step , the HAD  calls the PIM_LDATA  and the received data from the FIFO  is moved to the data stack . As indicated the process ends with step .","The architecture of the present invention provides a set of interfaces that facilitate the development of external PIMs , such as PDC, that preferably use a standard modem interface. In the case of the external PIM  interface API for the PDC example implementation, the AT parser is split into two stacks (see  and  in ). In this example, the first stack  is used to support a standard wired modem and the second AT parser  is used to support the MPI .","Using this approach, any effort to match function of both AT parsers  and  can be eliminated. COM port mode can be selected by issuing, for example, an \u201cAT+WS46\u201d command. A default mode for each COM port is preferably selected by setting a parameter in the Windows INF file.","Below are descriptions of the software architecture and a preferred method of access for the external PIM . Accordingly, the following describes entry points for the external PIM  stack including the interface between the external PIM  and the HAD . An example implementation of the command\/status interface between the CCS  and the external PIM  is also included.","The external PIM  is preferably developed as a VxD, when the Windows 9x operating system is used. The protocol stack  is loaded and enabled by the CCS  when required. In this example embodiment, the external PIM  is implemented as a virtual device driver for Windows 9x. Knowledge of writing virtual device drivers is obtained from the Windows 95 or 98 DDK.","When the external PIM  is no longer needed it is preferably unloaded by the CCS  by calling the operating system function VXDLDR_UnloadDevice.","Details of the External PIM  Functions","Activation\/Deactivation Functions","Preferably, the external PIM  provides at least the following functions:","EP_GetVersion: The first function in this table is EP_Get Version. It preferably returns the version of the external PIM .","EPInitialize: EPInitialize is an example of an initialize module  shown in . The module  establishes a new instance of the data and control data structure for the external PIM . It preferably returns a handle to be used by the CCS  on subsequent calls to the external PIM . It also gets the address of a callback function within the CCS . This address should be called by the external PIM  to signal status changes occuring within the external PIM ","EPTerminate: EPTerminate is an example of a terminate module  shown in . The CCS  preferably calls the terminate module  to deactivate the external PIM . This function should be used by the external PIM  to free any allocated instance data. This message should also return the previously defined handle to the external PIM .","Data Movement Functions for the External PIM  Data","As shown in  the external PIM  preferably implements the following interfaces in accordance with preferred embodiment of the present invention.","1. Interface to the data flow coming from (and going to) the CCS  (PIM_HDATA ).","2. Interface to the data flow coming from (and going to) the hardware (PIM_LDATA )","3. Interface to the control information from (and to) the CCS  (PIM_HCTL ).","4. Interface to the control information from (and going to) the hardware (via the HAD ) (PIM_LCTL )","PIM_HDATA Module : This module is preferably called regularly (based on timer or event) by the CCS  to send data to the external PIM  and to poll for data from the external PIM ","PIM_LDATA Module : This module is preferably will be called regularly (based on hardware activity) by the HAD  when a predefined size of data is required or when a predefined size of data becomes available. The predefined size of data is 28 bytes in case of the PDC high speed example, and 32 Bytes in the case of the PDC Packet mode example.","PIM_HCTL Moudle : The CCS  calls PIM_HCTL  for specific control data.","PIM_LCTL Module : The CCS  calls PIM_LCTL  based on status changes","Function Table Example","In this example, when the external PIM  VxD is loaded, the following function table is exported to the CCS  code.",{"@attributes":{"id":"p-0215","num":"0229"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct tagEXTPROTO_FN_TABLE"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DWORD (*EP_GetVersion)( );"]},{"entry":[{},"DWORD (*EPInitialize)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(WINAC_HANDLE PSYS,"]},{"entry":[{},"EPCALLBACK pfnCallback,"]},{"entry":[{},"DWORD DevNode,"]},{"entry":[{},"WORD Mode);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DWORD (*EPTerminate)(EP_HANDLE hEP);"]},{"entry":[{},"BOOL (*PIM_HDATA)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(EP_HANDLE hEP,"]},{"entry":[{},"BYTE eDir, \\\\To or From DTE"]},{"entry":[{},"BYTE far *pBuff,"]},{"entry":[{},"WORD *pwCount);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Void (*PIM_LDATA)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(EP_HANDLE hEP,"]},{"entry":[{},"BYTE eDir,"]},{"entry":[{},"BYTE *pBuff,"]},{"entry":[{},"WORD *pwCount,"]},{"entry":[{},"WAC_PIM_STATUS *peStatus);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"BOOL (*PIM_HCTL)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(EP_HANDLE hEP,"]},{"entry":[{},"PDC_EVENT CmdType),"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Void (*PIM_LCTL)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(EP_HANDLE hEP,"]},{"entry":[{},"BYTE eDir,"]},{"entry":[{},"BYTE *pBuff,"]},{"entry":[{},"WORD *pwCount,"]},{"entry":[{},"WAC_PIM_STATUS *peStatus)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} ExtProtocolFunctionTable;"]},{"entry":[{},"typedef DWORD WINAC_HANDLE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"External Protocol Example Design Specification","The following section describes the interface between the CCS  and the external PIM .","To start a connection, the CCS  loads the external PIM  as a Virtual Device Driver (VxD). The CCS  first fetches the version number from the external PIM . If the version matches, the CCS  calls the external PIM  initialization routine . After a successful initialization, the CCS  and the external PIM  communicate with each other using the routines described in this section, for example. These routines consist of a series of calls from the CCS  to the external PIM , and one call from the external PIM  to the CCS .","When the CCS  calls the external PIM , it passes a handle that contains the current instance context for the external PIM . This is referred to herein as the \u201chEP\u201d. When the external PIM  calls the CCS , it passes a handle that contains the current instance context for the CCS . This handle is referred to herein as the \u201cPSYS.\u201d","The CCS  creates one HANDLE each time the CCS  opens a new COM port. The PSYS identifies a data structure that holds all of the data for that instance of the CCS  driver. The external PIM  creates a hEP each time the CCS  initializes it. Preferably, the external PIM  use hEP in the same way that CCS  uses DP_HANDLE of PSYS structure, that is as a data structure to hold all of the data for a single wireless COM port.","PSYS is passed to allow the external PIM  to pass its status to the correct instance of the CCS  driver. Similarly, the hEP is passed to allow the code to handle more than one external PIM .","External PIM  Activation","EPInitialize (initialize the external PIM , called by the CCS  code)","This function will cause the external PIM  to instantiate and initialize itself to communicate with the CCS  code. During the initiate stage the CCS  code passes a callback pointer and instance context for this callback. This pointer is called by the external PIM  to signal status changes (HAD  status changes) or events happening within the external PIM . The instanced context is not used by the external PIM  but is simply passed back to the CCS  as a parameter within this call. The external PIM  instance context or \u201chandle\u201d (which is different to the CCS  code instance context) is returned by the EPInitialize function. This newly created instance context will be used in a similar manner by the controller code. This instance context will be passed as a parameter in all other CCS  controller code interface functions.",{"@attributes":{"id":"p-0225","num":"0239"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Inputs:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Parm1: PSYS (contained the CCS 183 code instance context)"]},{"entry":[{},"(typedef DWORD WINAC_HANDLE)"]},{"entry":[{},"Parm2: Pointer to callback function pfnCallback (Status changes)"]},{"entry":[{},"typedef void * EPCALLBACK)(WINAC_HANDLE hWinAC,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PDC_CALLBACK_EVENT event,"]},{"entry":[{},"DTE_Param *DTEParam,"]},{"entry":[{},"WORD Value)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Parm3: The Device node within the windows registry so the external"]},{"entry":[{},"PIM 174 can store its own parameters and\/or profile within the"]},{"entry":[{},"registry."]},{"entry":[{},"Parm4: PDC mode. This parameter indicates which PDC mode is"]},{"entry":[{},"selected. The value passed is 20 if PDC high speed is selected and"]},{"entry":[{},"27 if PDC packet mode is selected."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Return:","EP_HANDLE (typedef DWORD EP_HANDLE) is the instance context return by the external PIM .","EP_HANDLE EPInitialize (WINAC_HANDLE PSYS, EPCALLBACK pfnCallback, DWORD DevNode, BOOL DefaultSwitch, WORD Mode);","Version Identification","EP_GetVersion ( ) (called by the CCS  code)","This function returns a version identification number. This is required for the CCS  to identify which version of the external PIM  specification has been implemented. The CCS  knows by checking the value return by EP_GetVersion if the function table was changed. The number returned is the version number of the protocol. The external PIM  returns a version number lower than one before production and higher than one after production. The DWORD returned by the external PIM  to CCS  should preferably follow the following format:","for example Hex 00000090 for version 0.9, Hex 00000100 for version 1.0 and 1.05 is Hex 00000105.","Return: DWORD EP_GetVersion ( )","Deactivate the External PIM ","EPTerminate (destroy the communication channel with the external PIM . This function is called by the CCS  code)","This function should deactivate the external PIM  and close the communication channel with the CCS . The external PIM  instance context is returned to the CCS  code to inform it to close the external PIM  channel. After this call, the hEp handle is no longer valid. It is important to call this function when the external PIM  is no longer needed.\n\n","Data Flow","PIM_HDATA is called to transmit and receive data to\/from the application . PIM LDATA  is called regularly (based on hardware activity) by the CCS  when a frame of data is required or when a frame of data becomes available. The CCS  calls PIM_HDATA  twice every 10 ms, once for data going to the application  (TO_DTE) and once for data coming from the application (FROM_DTE). If all data in the buffer cannot be transferred at once, PIM_HDATA  is called continuously. The first call is to PIM_HDATA  with the FROM_DTE direction set, and the second call is to PIM_HDATA  call with TO_DTE direction set.","RX\/TX Data to\/from DTE","The CCS  calls the PIM_HDATA function to inform the external PIM  that data must be moved from the external PIM  buffer to the DTE buffer or that data must be moved from the DTE buffer to the external PIM  buffer. The direction parameter within the PIM_HDATA call will define the direction of the data movement.","The data moved from DTE to external PIM  or the data moved from the external PIM  to DTE will require the following parameters within the PIM_HDATA function call.","Inputs:","Parm1: handle to external PIM  returned by the EPInitialize function","Parm2: Direction, indicate in which direction the data is moving (DTE to external PIM  or external PIM  to DTE)","For instance:\n\n","Parm3: Pointer to the data buffer. Points to a data area in the driver data space that the PIM will use to read or write information specific to the PIM type (TO_DTE or FROM_DTE).","Parm4: The number of byte to be read by the external PIM  or the number of bytes written to the buffer when the call returns.","If the external PIM  cannot accept data (for example the external PIM  buffer is full), the call will return false. This return value will be used to handle the flow control between the DTE and the external PIM .","Return: True or False","Returns a Boolean corresponding to whether the PIM type (FROM_DTE and TO_DTE) specific operation should be considered a success by the driver, and mirrored to the caller in some cases. For example, in case of TO DTE if the buffer is empty, the return value will be False.","BOOL PIM_HDATA (EP_HANDLE hEP, BYTE eDir, BYTE far *pBuff, WORD *pwCount)\n\n","To implement the data transfer function the modem driver registers the data transfer routines with the timer services provided by the driver. FromHostTxfr and ToHostTxfr are the registered routines and are called based on a timer referred to as \u201cWINAC_WIRELESS_STARTUP_RESOLUTION.\u201d","The WINAC_WIRESLESS_STARTUP_RESOLUTION is typically set to 10 milliseconds. FromHostTxfr will call PIM_HDATA (FROM_DTE) upon any data event coming from the application. The following function call is an example:",{"@attributes":{"id":"p-0253","num":"0274"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"osRegister(&ModemController,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"&FromHostTxfr,"]},{"entry":[{},"&ToHostTxfr,"]},{"entry":[{},"WINAC_STARTUP_RESOLUTION)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The FromHostTxfr routine will call PIM_HDATA  with the following information:\n\n","The PIM_HDATA  (FROM_DTE) is typically called in every 10 ms.","The PIM_HDATA  (FROM_DTE) moves data, based on the room in its own internal buffer, from the linear data buffer to its own internal queue. The number of bytes actually transferred is assigned to the location pointed to by the variable pwCount passed in the call.","The ToHostTxfr routine will call PIM_HDATA  with the following information:\n\n","PIM_HDATA  (TO_DTE) moves data from its own internal queue to the linear output buffer. PIM_HDATA  also assigns the actual number of bytes written to the buffer in the pwCount variable. The number of bytes actually transferred during each call is one (pwCount=1). ToHostTxfr passed data one character by one character to PIM_HDATA.","Transmit\/Receive Data to\/from Hardware Access Driver","The hardware access driver (HAD ) calls the PIM_LDATA function  to transmit data from the external PIM  to the HAD  or to send the data received from the MPC  to the external PIM . The direction parameter within the PIM_LDATA call defines the direction of the data transfer. This call also indicates whether a buffer has been transmitted from the HAD  or a buffer has been received from the HAD .","The HAD , based on the received buffer threshold, will generate an interrupt. Data received from the MPC  is passed to the external PIM  by the PIM_LDATA function call. The HAD , based on the transmit buffer threshold, will generate an interrupt. Data will be sent from the external PIM  to the HAD  by the PIM_LDATA function call.","The following parameters can be used when data is moved from or to the HAD :","Inputs:\n\n","For example\n\n","Return:\n\n","Void PIM_LDATA (EP_HANDLE hEP, BYTE eDir, BYTE *pBuff\n\n","#define FROM_HAD 0","#define TO_HAD 1","Calls to PIM_LDATA  will be triggered by hardware events (e.g. when a frame is received).","FROM_HAD:","PIM_LDATA  will move data from the hardware receive buffer  to its own internal queue (based on availability) and will return the number of bytes actually moved. Again, the number of bytes moved will be assigned to the location pointed to by pwCount. It will also return the WAC_PIM_STATUS. PIM_LDATA  will set WAC_PIM_STATUS to HOSTTOHAL_BUFFER_FULL if the number of bytes moved from the HADRxBuffer to it own queue is less than the number of bytes provided by the HADRxBuffer. In the normal processing case the peStatus will return HOSTTOHAL_RX_OK. PIM_LDATA (FROM_HAD) is called only when the device receives data for the external PIM . The HAD  is generally data driven and not timer driven.","TO_HAD:","PIM_LDATA  will move the number of bytes (the default number of bytes is one, if more than one Byte need to be passed, Pwcount should be set with the new number of character put on the buffer) requested from the external PIM s to the hardware transmit buffer . If the internal queue does not have the requested amount of bytes, then PIM_LDATA  will a return a transmit buffer empty indication along with the number of bytes actually moved. In this case PIM_LDATA shall set WAC_PIM_SATTUS to HOSTTOHAL_BUFFER_EMPTY. By convention, the normal return value when the number of bytes requested is successfully transferred is ilt and maintained","Control Flow","The user (or application program ) issues one of the AT commands specified below to select between the CCS  and one of the external PIM  data transfer modes. The default mode is typically the CCS  data transfer mode.",{"@attributes":{"id":"p-0276","num":"0312"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 11"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example of the AT command mode switch"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"AT command","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"AT + WS46 = 1","Enable The CCS 183\/HSF mode"]},{"entry":[{},"AT + WS46 = 20","Enable the PDC High Speed mode"]},{"entry":[{},"AT + WS46 = 27","Enable the PDC Packet mode"]},{"entry":[{},"AT + WS46 = 12","Enable the GSM mode"]},{"entry":[{},"AT + WS46 = 7","Enable the AMPS mode"]},{"entry":[{},"AT + WS46 = <X>","Enable the X mode"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Once a connection is established, all the data will be passed to the external PIM .","Call Back Function","The external PIM  passes control information to the CCS  by calling the callback function, ExtProtoCallback, which was passed as a parameter in the EPInitialize call.\n\n","The following parameters are example requirements for the ExtProtoCallback:\n\n","This callback function will be called when the external PIM  needs to reset the device. This function resets whole basic device including control serial channels  and TCH frame channels .","This function call can be used when the system is terminating calls and starting calls to clear and reset the TCH frame data buffers  and .\n\n","This callback requests that the CCS  pass the current DTE port parameters to the external PIM . In this case a pointer is passed to a DTE_PARAMETER structure. The CCS  will fill this structure. The structure is defined as follows.\n\n","The following setting is an example requirement for the PDC example.\n\n",{"@attributes":{"id":"p-0285","num":"0340"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 12"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"DTE_Speed value"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DTE_SPEED","Speed"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","300"]},{"entry":[{},"1","600"]},{"entry":[{},"2","1200"]},{"entry":[{},"3","2400"]},{"entry":[{},"4","4800"]},{"entry":[{},"5","7200"]},{"entry":[{},"6","9600"]},{"entry":[{},"7","1200"]},{"entry":[{},"8","14400"]},{"entry":[{},"9","19200"]},{"entry":[{},"10","38400"]},{"entry":[{},"11","57600"]},{"entry":[{},"12","115200"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Parm 4: The default value will be zero when there is no Value to return.","Control Data from DTE to External PIM ","The CCS , in calling the PIM_HCTL  function, will inform the external protocol about the control data such as DIAL, NASWER, ONHOOK etc . . . In addition, certain other signals are defined. The return message will be passed to CCS  through the call back function ExtProtoCallback.","The following parameters can be used when PIM_HCTL  is called:\n\n","Two examples of commands:\n\n","Control Data from Hardware Access Driver to External PIM ","The HAD  calls the PIM_LCTL function  to transfer status changes between the MPC  and the external PIM . The direction parameter within the PIM_LCTL call defines the direction of the transfer. PIM_LCTL (FROM_HAD ) is called only when the device receives data for the external PIM . The HAD  is data driven.","The PIM_LCTL function call requires the following parameters.\n\n","For example:\n\n","Return:\n\n","Void PIM_LCTL (EP_HANDLE hEP, BYTE eDir, BYTE *pBuff,\n\n","#define FROM_HAD 0","#define TO_HAD 1","Flow Control","The application  will stop sending data when the host queue is full. The CCS  handles the XON\/XOFF flags. The external PIM  does not need to process any XON\/XOFF flags. Because the CCS  stack has the knowledge of the local configuration, it will process either XON\/XOFF or RTS\/CTS flow control transparently.","The CCS  code sets XOFF and XON thresholds arbitrarily. These thresholds are determined by the application buffer size given to the CCS . The XOFF threshold is set at 80% of its buffer size. The XON threshold is typically set at 40% of its buffer size.","The XOFF char will be sent to the application  if the TX buffer level is at or above the high water mark. The XON char will be sent to the application if TX buffer level is at or below the low water mark.","The CCS  code will send XOFF to the DTE and\/or drops CTS, if the local hardware flow control is enabled, when transmit buffer queue reaches the XOFF threshold.","The CCS  will send XON to the DTE and\/or raise CTS, if the local hardware flow control is enabled, when transmit buffer queue reaches the XON threshold (40% of the buffer size).","The user can typically switch between the software flow control and the hardware flow control with an appropriate AT command.","Ladder Tables","The following ladder tables are useful for describing example sequences of events that can be used to implement a typical embodiment of the present invention. The following ladder tables depict an example of sequenced events that can occur within the DTE , the CCS  and the external PIM  modules.","Calling Sequence",{"@attributes":{"id":"p-0309","num":"0384"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"center"}},"thead":{"row":{"entry":"TABLE 14"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example of External Protocol (PDC) messages"},{"entry":"(Dialing mode and switching mode)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Step","DTE 150","CCS 183","External PIM 174"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","AT + WS46 = n<CR>\u2192",{},{}]},{"entry":["2",{},"EP_GetVersion( )\u2192"]},{"entry":["3",{},"Load PDC","Initialize stack"]},{"entry":[{},{},"EPInitialize (PSYS, PFnCb,n)\u2192"]},{"entry":["4",{},"Instance context =hEP","Return External protocol"]},{"entry":[{},{},{},"\u2190 instance context"]},{"entry":["5",{},"Init HAD"]},{"entry":["6","OK \u2190"]},{"entry":["7","ATDTxxxx<CR>"]},{"entry":["9",{},"Parse commandCall"]},{"entry":[{},{},"PIM_HCTL(hEP, \u201cDIAL\u201d, <xxxx>,4)"]},{"entry":["9",{},"HAD call","Get the Ctl Data"]},{"entry":[{},{},"PIM_LCTL(hEP, 0, <CtlData>,"]},{"entry":[{},{},"n, NULL)\u2192"]},{"entry":["10",{},{},"\u2190"]},{"entry":[{},{},{},"ExtProtoCallback(hWinAC,"]},{"entry":[{},{},{},"CARRIER, NULL, 9600)"]},{"entry":"11"},{"entry":["12","CARRIER 9600\u2190"]},{"entry":["13",{},"Data phase DTE interface","Read data \/ Return Data"]},{"entry":[{},{},"PIM_HEX(hEP, 0, <data>, n, 1)\u2192"]},{"entry":["14",{},"Data phase PHONE interface","Read data \/ Return Data"]},{"entry":[{},{},"PIM_LEX(hEP, 1, <data>, n, 1)\u2192"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0310","num":"0385"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"center"}},"thead":{"row":{"entry":"TABLE 15"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example of External Protocol (PDC) messages (No Dial Tone mode)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Step","DTE 150","CCS 183","External PIM"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","AT + WS46 = n<CR>\u2192",{},{}]},{"entry":["2",{},"EP_GetVersion( )\u2192"]},{"entry":["3",{},"Load PDC","Initialize stack"]},{"entry":[{},{},"EPInitialize (PSYS, PFnCb, n)\u2192"]},{"entry":["4",{},"Instance context = hEP","Return External protocol"]},{"entry":[{},{},{},"\u2190 instance context"]},{"entry":["5",{},"Init HAD"]},{"entry":["6","OK \u2190",{},"Set the protocol mode"]},{"entry":["7","ATDTxxxx<CR>\u2192"]},{"entry":["8",{},"Parse command"]},{"entry":[{},{},"Call"]},{"entry":[{},{},"PIM_HCTL(hEP, \u201cDIAL\u201d, <xxxx>4)\u2192"]},{"entry":["9",{},"HAD call","Get the Ctl Data"]},{"entry":[{},{},"PIM_LCTL(hEP, 0, <CtlData>, n,"]},{"entry":[{},{},"NULL)\u2192"]},{"entry":["10",{},{},"\u2190"]},{"entry":[{},{},{},"ExtProtoCallback(hWin"]},{"entry":[{},{},{},"AC, NO_DIAL_TONE,"]},{"entry":[{},{},{},"NULL, NULL)"]},{"entry":["11","NO DIAL TONE \u2190"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Answering Sequence",{"@attributes":{"id":"p-0312","num":"0387"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"center"}},"thead":{"row":{"entry":"TABLE 17"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example of External Protocol (PDC) messages (Answering data mode)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Step","DTE 150","CCS 183","External PIM 174"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","AT + WS46 = n<CR>\u2192",{},{}]},{"entry":["2",{},"EP_GetVersion( )\u2192"]},{"entry":["3",{},"Load PDC","Initialize stack"]},{"entry":[{},{},"EPInitialize (PSYS, PFnCb)\u2192"]},{"entry":["4",{},"Instance context = hEP","Return External protocol"]},{"entry":[{},{},{},"\u2190 instance context"]},{"entry":["5",{},"Init HAD"]},{"entry":["6","OK \u2190",{},"Set the protocol mode"]},{"entry":["7",{},"HAD call"]},{"entry":[{},{},"PIM_LCTL(hEP, 0, <Ctl Date>,"]},{"entry":[{},{},"n, NULL)\u2192"]},{"entry":["8",{},{},"Decode the \u201cCtl Data\u201d"]},{"entry":[{},{},{},"\u2190"]},{"entry":[{},{},{},"ExtProtoCallback(hWin"]},{"entry":[{},{},{},"AC, RING, NULL,"]},{"entry":[{},{},{},"NULL)"]},{"entry":["9","RING \u2190"]},{"entry":["10","ATA<CR>\u2192"]},{"entry":["11",{},"Call PIM_HCTL (hEP, 3, NULL,"]},{"entry":[{},{},"NULL)\u2192"]},{"entry":["12",{},"HAD call","Get the Ctl Data"]},{"entry":[{},{},"PIM_LCTL(hEP, 0, <CtlData>, n,"]},{"entry":[{},{},"NULL)\u2192"]},{"entry":["13",{},{},"\u2190"]},{"entry":[{},{},{},"ExtProtoCallback(hWin"]},{"entry":[{},{},{},"AC, CARRIER, NULL,"]},{"entry":[{},{},{},"9600)"]},{"entry":["14","CARRIER 9600 \u2190"]},{"entry":["15",{},"Data phase DTE interface","Read data \/ Return Data"]},{"entry":[{},{},"Call PIM_HEX(hEP, 0, <data>, n, 1)"]},{"entry":["16",{},"Data phase PHONE interface","Read data \/ Return Data"]},{"entry":[{},{},"Call PIM_LEX(hEP, 1, <data>, n, 1)"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0313","num":"0388"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":{"entry":"TABLE 19"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Port close in CCS mode"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Step","DTE 150","CCS 183","External PIM 174"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["1","AT + WS46 = 20<CR>\u2192",{},{}]},{"entry":["2",{},"Load PDC VxD"]},{"entry":["3",{},"EP_GetVersion( )\u2192","Initialize stack"]},{"entry":[{},{},"EPInitialize (PSYS,"]},{"entry":[{},{},"PFnCb, 20)\u2192"]},{"entry":["4",{},"Instance context = hEP","Return External protocol"]},{"entry":[{},{},{},"\u2190 instance context"]},{"entry":["5",{},"Init HAD"]},{"entry":["6","OK \u2190",{},"Set the protocol mode"]},{"entry":["7","AT + WS46 = 1<CR>\u2192"]},{"entry":["8",{},"Terminate PDC"]},{"entry":["9","OK"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"While various embodiments of the present invention have been described above, it should be understood that they have been presented by way of example only, and not limitation. Thus, the breadth and scope of the present invention should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents."],"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":["The present invention is described with reference to the accompanying drawings, wherein:","In the figures, like reference numbers generally indicate identical, functionally similar, and\/or structurally similar elements.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2","b":"1"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 4","b":"16"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 13A"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 13B"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 14A"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 14B"}]},"DETDESC":[{},{}]}
