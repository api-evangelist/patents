---
title: Method and apparatus for encoding decision diagrams
abstract: An approach is provided for reducing decision diagram related communication traffic and cost by encoding decision diagrams. A hash identifier application constructs a reduced ordered binary decision diagram from a resource description framework graph, computes a hash identifier corresponding to the decision diagram, and stores the hash identifier with the decision diagram.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08332624&OS=08332624&RS=08332624
owner: Nokia Corporation
number: 08332624
owner_city: Espoo
owner_country: FI
publication_date: 20090826
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SOME EXAMPLE EMBODIMENTS","DESCRIPTION OF SOME EMBODIMENTS"],"p":["Service providers (e.g., wireless and cellular services) and device manufacturers are continually challenged to deliver value and convenience to consumers by, for example, providing compelling network services and advancing the underlying technologies. One area of interest has been in ways to reduce data traffic on the existing networks while maintaining a level of service acceptable to users. Search queries and the results of search queries have substantially increased congestion on networks. The number of systems and platforms performing a search query using a decision diagram is increasing. Such a decision diagram is used to organize data in a search query into a tree-type data structure that permits identification of a result by traversing various branches of the structure. As users continue to increase their reliance on data retrieved from networks, the number of search queries and the results of search queries transmitted in decision diagram form increase. Consequently, service providers and device manufacturers face the challenge of providing sufficient communication and network resources to support queries based on or related to decision diagrams.","According to one embodiment, a method comprises constructing a reduced ordered binary decision diagram from a resource description framework graph. The method also comprises computing a hash identifier corresponding to the decision diagram. The method further comprises storing the hash identifier with the decision diagram.","According to another embodiment, an apparatus comprising at least one processor, and at least one memory including computer program code, the at least one memory and the computer program code configured to, with the at least one processor, cause the apparatus to construct a reduced ordered binary decision diagram from a resource description framework graph. The apparatus is also caused to compute a hash identifier corresponding to the decision diagram. The apparatus is further caused to store the hash identifier with the decision diagram.","According to another embodiment, a computer-readable storage medium carrying one or more sequences of one or more instructions which, when executed by one or more processors, cause an apparatus to construct a reduced ordered binary decision diagram from a resource description framework graph. The apparatus is also caused to compute a hash identifier corresponding to the decision diagram. The apparatus is further caused to store the hash identifier with the decision diagram.","According to another embodiment, an apparatus comprises means for constructing a reduced ordered binary decision diagram from a resource description framework graph. The apparatus also comprises means for computing a hash identifier corresponding to the decision diagram. The apparatus further comprises means for storing the hash identifier with the decision diagram.","Still other aspects, features, and advantages of the invention are readily apparent from the following detailed description, simply by illustrating a number of particular embodiments and implementations, including the best mode contemplated for carrying out the invention. The invention is also capable of other and different embodiments, and its several details can be modified in various obvious respects, all without departing from the spirit and scope of the invention. Accordingly, the drawings and description are to be regarded as illustrative in nature, and not as restrictive.","A method and apparatus for encoding decision diagrams are disclosed. In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the embodiments of the invention. It is apparent, however, to one skilled in the art that the embodiments of the invention may be practiced without these specific details or with an equivalent arrangement. In other instances, well-known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the embodiments of the invention.","As used herein, the term \u201cdecision diagram\u201d refers to a compact graphical and\/or mathematical representation of a decision situation, sets, or relations. A decision diagram, for example, may be a binary decision diagram (BDD) or a reduced ordered binary decision diagram (ROBDD). A BDD is \u201cordered\u201d if different variables appear in the same order on all paths from the root. A BDD is \u201creduced\u201d if any isomorphic subgraphs of its graph are merged and any nodes whose two child nodes are isomorphic are eliminated. Isomorphic subgraphs of the same decision diagram have similar appearance but originated from different sources. A ROBDD is a group of Boolean variables in a specific order and a directed acyclic graph over the variables. A directed acyclic graph (DAG) contains no cycles. This means that if there is a route from node A to node B then there is no way back. Although the term BDD almost always refers to reduced ordered binary decision diagram (ROBDD), this application refers to ROBDD separately from BDD to avoid confusion.","A decision diagram may be used to organize any data, including search queries, into a tree-type data structure that permits identification of a result by traversing various branches of the structure. Although various embodiments are described with respect to search queries, it is contemplated that the approach described herein may be used with other data that can be organized into a tree-type data structure. The term \u201cAugBDD\u201d refers to an augmented ROBDD which is augmented information including the ROBDD and at least one of a header with a hash ID, a construction history of the ROBDD, and cardinality information (e.g., relationships between data tables, constraints on the types and number of class instances a property may connect with respect to a given ontology, etc.).","As used herein, the term \u201cconstruction history information\u201d of a hash identifier of interest includes at least one or more other hash identifiers corresponding to a respective one or more other decision diagrams used to construct a decision diagram corresponding to the hash identifier of interest. The construction history also includes identification of one or more Boolean operators applied to the other hash identifiers listed in history.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 1","FIG. 1"],"b":["100","100"]},"One significant consideration is the encoding scheme used to generate a hash identifier for a decision diagram. There are some traditional encoding schemes that can result in hash identifiers that are actually larger in size than the unencoded decision diagram itself. The system  addresses this problem by using either a parameterized or heuristic approach for determining a maximum size for a hash identifier while maintaining uniqueness of the hash identifier such that any two decision diagrams will not have identical hash identifiers. For example, upon receiving a search query, the system  serializes the decision diagram into variables and then feeds the variables into a hash function thereby obtaining unique hash identifiers corresponding to the decision diagram. In addition, the system truncates the hash identifiers to a specific bit size while maintaining their uniqueness, thereby saving communication resources while transmitting the same information.","By way of example, the system  is applied to freely formed resource description framework (RDF)-graphs or RDF-graphs generated by ontology based information sharing systems over the semantic web. In one embodiment, RDF graphs represent decision diagrams and describe resources with classes, properties, and values. Sets of properties are defined within RDF Vocabularies (or Schemas). A node\/resource is any object which can be pointed to by a uniform resource identifier (URI), properties are attributes of the node, and values can be either atomic values for the attribute, or other nodes. RDF Schema provides a framework to describe application-specific classes and properties. Classes in RDF Schema are like classes in object oriented programming languages. This allows resources to be defined as instances of classes, and subclasses of classes. The RDF graphs are represented or encoded in decision diagrams which describe the properties and relations of different classes. For example, information about a particular web page (a node), includes the property \u201cAuthor\u201d. The value for the Author property could be either a string giving the name of the author, or a link to a resource describing the author. One typical example of an rdfs:Class is foaf:Person in the Friend of a Friend (FOAF) vocabulary. An instance of foaf:Person is a resource linked to the class using an rdf:type predicate, such as in the following formal expression \u201cJohn rdf:type foaf:Person\u201d of the natural language sentence.","Ontology has notions of a property\/attribute, which has a range and a domain (both of which define classes). A class has a name and potentially several associated properties, and it may be a subclass of another class. A class can be instantiated to a graph so that it is represented by a node in the graph. Possible properties are represented as arcs from one class node to other class nodes. These property-arcs can be properties of the object which have values (that are the nodes targeted by the property arcs). For instance, in person ontology, a Person class has a name property and an ID property, which places a restriction on the domains of both properties: e.g., define both properties as a Person class. Constraints may be added on the range of properties. For example, the range of ID is a number (a data value) and the range of name is another class, such as FullName. A class instance typically also has an arc that connects it to its class type.","A query can be performed against the originally received query result decision diagram, using criteria included in the query instruction, to generate a second query result decision diagram. In this regard, the second query result decision diagram can be a subset of the originally received query result decision diagram. To generate the second query result decision diagram, various logical operations, such as the logical-and operation, can be utilized. The query result data associated with this subsequent query may be decoded using the same dictionary that was used to decode the originally received query result decision diagram. The query result data can also be output to a user. Further, subsequent queries may also be performed, that further narrow the results, in the same manner.","Each RDF-graph includes a set of unique triples in a form of subject, predicate, and object, which allow expressing graphs. For example, in this piece of information \u201cJenna is Matti's friend,\u201d the subject may be Jenna, the predicate may be friend, and the object may be Matti. The simplest RDF-graph is a single triple. Any node or entity can store unconnected graphs. As later explained in more detail, the approach described herein can be adapted in a smart space that includes the semantic web and has distributed nodes and entities that communicate RDF-graphs (e.g., via a blackboard or a shared memory).","The smart space is interoperable over different information domains, different service platforms, and different devices and equipment. For example, the smart space accommodates transmission control protocol\/Internet protocol (TCP\/IP), Unified Protocol (UniPro) created by the Mobile Industry Processor Interface (MIPI) Alliance, Bluetooth protocol Radio Frequency Communication (RFCOMM), IPv6 over Low power Wireless Personal Area Networks (6LoWPAN), etc. The smart space also covers technologies used for discovering and using services, such as Bluetooth\/human interface device (HID) services, web services, services certified by the Digital Living Network Alliance (DLNA), the Network on Terminal Architecture (NoTA). In addition, the smart space constitutes an infrastructure that enables scalable producer-consumer transactions for information, and supports multiparts, multidevices and multivendors (M3), via a common representation of a set of concepts within a domain and the relationships between those concepts, i.e. ontologies. The smart space as a logical architecture has no dependencies on any network architecture but it can be implemented on top of practically any connectivity solution. Since there is no specific service level architecture, the smart space has no limitation in physical distance or transport.","The smart space allows cross domain searches and provides a uniform, use case independent service application programming interface (API) for sharing information. As an example, the smart space allows a mobile platform to access contextual information in, e.g., a car, home, office, football stadium, etc., in a uniform way and to improve the user experience, without compromising real-time requirements of the embedded system. The smart space uses an ontology governance process as the alternative to using case-specific service API standardization. The ontology governance process agrees and adopts new vocabularies using Resource Description framework (RDF) and RDFS (RDF schema). When RDFS is not sufficient for defining and instantiating the ontologies, web ontology language (OWL) or the like is used.","In one embodiment, the RDF is used to join data from vocabularies of different domains (such as business domains), without having to negotiate structural differences between the vocabularies. In addition, the RDF allows the smart space to merge the information of the embedded domains with the information in web, as well as to make the vast reasoning and ontology theory, practice and tools developed by the semantic web community available for developing smart space applications. The smart space is an aggregation of individual smart spaces of private, group or public entities and the smart space makes the heterogeneous information in embedded domains available for semantic web tools. The smart space architecture expands the concept of a deductive closure towards a distributed deductive closure. The smart space architecture addresses values in application development by abolishing the need for a prior use case standardization such as those in the Digital Living Network Alliance (DLNA) domain and the Bluetooth domain. Furthermore, the smart space architecture abolishes design time freezing of the address of any used service API, such as in the case of WebServices.","The smart space architecture is different from university-driven RDF-store based approaches in getting information of embedded systems as an integral part of the search extent. The space-based approach of the smart space architecture also provides an alternative to surrendering personal data to a search engine or a service provider. The smart space architecture applies to the semantic web an end-to-end design principle which is widely applied in the Internet, since communication media can never know the needs of endpoints as well as the endpoints themselves.","The smart space architecture allows a user's devices purchased at different times and from different vendors to work together. For example, the user can listen\/watch\/etc. to music\/movies\/etc. and have the sound output directed to a set of high quality speakers and\/or display whenever the user is using a personal device in the vicinity of the high quality speakers\/display. The smart space architecture allows application developers to mash-up services in different domains, instead of trying to port one application to all platforms and configurations. The smart space architecture allows device manufacturers to make interoperable products, so that consumers have no concerns about compatibility of different products and accessories.","Each individual smart space within the smart space architecture can be constructed by physically distributed information stores. For example, the personal information of a family is stored at home linked with one information store, while it is augmented with non-personal information at a website (e.g., a social networking website) linked with the same or a different information store. In this example, the website operator prefers augmenting rather than merging the information due to, for instance, copyright and\/or privacy concerns.","One of the problems of sharing information in the semantic web is to share the graphs or parts of the graphs (i.e., subgraphs) among distributed nodes and entities via information stores with sufficient identification of the graphs (especially the subgraphs) while minimizing communication traffic.","To address this problem, a system  of  introduces the capability to encode decision diagrams. The RDF graphs can be encoded to decision diagrams to be communicated between the nodes and entities. To further reduce communication traffic, the system  encodes (e.g., hashes) the decision diagrams into hash IDs, and avoids sending decision diagrams by sending the hash IDs and optionally a construction history of the decision diagrams. By way of example, a reduced ordered binary decision diagram (ROBDD) is used as an efficient representation for a binary decision diagram representing an information set and hashed with a hash function into a hash identifier (hash ID). ROBDD is essentially a group of Boolean variables in a specific order and a directed acyclic graph over the variables. A depth-first search of the ROBDD yields all possible values of the information set described by the ROBDD.","Each ROBDD is constructed from a binary decision diagram (representing a set of bits and their relationship) by means of reduction rules. The basic logical operations: and, or, not, equivalence, existential and universal abstractions are defined for ROBDDs as reduction rules. In other words, the system  constructs a new ROBDD by means of logical operations over a BDD. The constructed ROBDD is canonical for the set of bits it represents and for the order of its variables. The order of variables affects the size of the constructed ROBDD.","From a constructed ROBDD, the system  obtains a possible solution to the logical formula the ROBDD represents by traversing the ROBDD. This can be done in polynomial time (i.e., the running time is upper bounded by a polynomial in the size of the input for the algorithm). The problem of finding the best variable ordering is NP-hard (NP stands for Nondeterministic Polynomial time), i.e., inherently difficult to provide algorithms that are efficient for both general and specific computations. Since the problem of finding a satisfying assignment to variables in a logical formula is known to be NP complete (the class of NP-complete problems contains the most \u201cdifficult\u201d problems in NP), the construction of the ROBDD is difficult. However, in practice ROBDDs have proved to be a very efficient way of encoding and operating on large sets, although it may be challenging to find a satisfying assignment of variables in a logical formula to construct a ROBDD.","As shown in , the system  comprises a user equipment (UE) having connectivity to a personal computer , a web service platform and a communication platform via a communication network . Each of the UE , the personal computer , the web service platform and the communication platform has a hash identifier application  and a database  for storing hash identifier and decision diagram information. By way of example, the communication network  of system  includes one or more networks such as a data network (not shown), a wireless network (not shown), a telephony network (not shown), or any combination thereof. It is contemplated that the data network may be any local area network (LAN), metropolitan area network (MAN), wide area network (WAN), a public data network (e.g., the Internet), or any other suitable packet-switched network, such as a commercially owned, proprietary packet-switched network, e.g., a proprietary cable or fiber-optic network. In addition, the wireless network may be, for example, a cellular network and may employ various technologies including enhanced data rates for global evolution (EDGE), general packet radio service (GPRS), global system for mobile communications (GSM), Internet protocol multimedia subsystem (IMS), universal mobile telecommunications system (UMTS), etc., as well as any other suitable wireless medium, e.g., microwave access (WiMAX), Long Term Evolution (LTE) networks, code division multiple access (CDMA), wideband code division multiple access (WCDMA), wireless fidelity (WiFi), satellite, mobile ad-hoc network (MANET), and the like.","The UE is any type of mobile terminal, fixed terminal, or portable terminal including a mobile handset, station, unit, device, multimedia tablet, Internet node, communicator, desktop computer, laptop computer, Personal Digital Assistants (PDAs), or any combination thereof. It is also contemplated that the UE can support any type of interface to the user (such as \u201cwearable\u201d circuitry, etc.).","By way of example, the UE , the personal computer , the web service platform and the communication platform communicate with each other and other components of the communication network  using well known, new or still developing protocols, such as Smart Space Access Protocol (SSAP). In this context, a protocol includes a set of rules defining how the network nodes within the communication network  interact with each other based on information sent over the communication links The protocols are effective at different layers of operation within each node, from generating and receiving physical signals of various types, to selecting a link for transferring those signals, to the format of information indicated by those signals, to identifying which software application executing on a computer system sends or receives the information. The conceptually different layers of protocols for exchanging information over a network are described in the Open Systems Interconnection (OSI) Reference Model.","Communications between the network nodes are typically effected by exchanging discrete packets of data. Each packet typically comprises (1) header information associated with a particular protocol, and (2) payload information that follows the header information and contains information that may be processed independently of that particular protocol. In some protocols, the packet includes (3) trailer information following the payload and indicating the end of the payload information. The header includes information such as the source of the packet, its destination, the length of the payload, and other properties used by the protocol. Often, the data in the payload for the particular protocol includes a header and payload for a different protocol associated with a different, higher layer of the OSI Reference Model. The header for a particular protocol typically indicates a type for the next protocol contained in its payload. The higher layer protocol is said to be encapsulated in the lower layer protocol. The headers included in a packet traversing multiple heterogeneous networks, such as the Internet, typically include a physical (layer 1) header, a data-link (layer 2) header, an internetwork (layer 3) header and a transport (layer 4) header, and various application headers (layer 5, layer 6 and layer 7) as defined by the OSI Reference Model.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 2","b":["107","107","107","201","203","205","207","109","107","107","107","107"],"i":["a","a ","a ","a","b","c","d ","a. "]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 3","FIG. 12"],"b":["107","300","301","107","107","303","305"],"i":["a ","a ","a "]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIGS. 4A-4B","FIG. 3"],"b":["400","420","1","2","3","4","5","6","7","8","9"]},"The success of the system  relies on the uniqueness of ROBDDs. For example, a BDD constructed for a given information set is unique for a chosen variable order. An ROBDD independently constructed with the same variable order for the same information set is always the same over the semantic web or the smart space. The system  keeps an internal index of constructed ROBDDs. The values of the internal index depend on the order of local ROBDD constructions.","In addition, the system  creates an external index table (a \u201chash table\u201d; see  for more details) in which each constructed ROBDD is given an ID (hereinafter \u201chash ID\u201d) by operating a hash function over its ROBDD graph structure. Ideally, the hash function would never produce the same hash ID for two different ROBDDs. The system  maintains the external index table to store each new, unique ROBDD in a column .  is a partial diagram of an external index table  utilized in the process of , according to one embodiment. This table further contains owner and access control information in a column  as well as the construction history of the ROBDD in a column .","The \u201caccess control\u201d column  in the external index table  may be a simple implementation of allowing\/disallowing access, or may be used as a link to an access control system of the underlying architecture, such as the credentials used in the semantic web. In one embodiment, hash is accessible for all, while hash is accessible only for Matti. Since hash is set as accessible for all group members, only group members can reconstruct a ROBDD corresponding to hash based on the construction history (e.g., BDD_OR(hash,hash)) of the ROBDD, since only group members have a decryption key from Matti regarding hash and hash. If a non-group member receives hash and the construction history, the non-group member does not have sufficient information to reconstruct ROBDD corresponding to hash based on the construction history because the non-group member does not have the appropriate key. In another embodiment, the control access function sends only hash IDs while using some other mechanisms to communicate the corresponding ROBDD.","The system  further extends the external index table  by augmenting each ROBDD with keyed hash IDs (e.g., <hash, keyid>) as shown in the column  of the external index table . In this embodiment, a keyed hash function is used instead of the hash function. Algorithms such as HMAC-SHA1, HMAC-SHA-256, etc. can be used to calculate keyed hash IDs. To create a keyed hash, the system  serializes data of the ROBDD so that it is suitable for inputting to the keyed hash function. The system  then stores the keyed hash ID with the key ID in the external index table . There may be, for instance, several keyed hash IDs that correspond to the same plain hash ID in the table .","The system  encrypts the AugBDD graph as well as calculates the corresponding keyed hash ID. In other words, the system  uses two separate keys for ID calculation and for encryption. There are existing techniques for deriving keys from secrets. In one embodiment, there is a single group-specific key, where the members of the group share the group key. The separate keys can be derived from the group key with a key derivation function such as ANSI-X9.63-KDF. In one embodiment, the system  maps the key IDs to the single group key, and derives the hash or encryption functions when needed.","When communicating the different hash IDs, a plain hash ID forms the basis for the communication. A keyed hash ID may then be added in the communication along with a key ID, or even the AugBDD graph. This allows the recipient to ensure that the keyed hash ID can be created from the corresponding graph (or the plain hash ID) by using the produced key.","A keyed hash function allows entities to share the same secret key and to independently ensure that the resulting hash IDs were created by an entity having the secret key. For anti-replay protection, timestamp information is included in the key or the content. The keyed hash ID always includes a key ID, which corresponds to a previously shared key. When the system  receives an unknown key ID, the system  requests the graph (e.g., decision diagram) for the hash ID accompanied with the key ID. The sending party of the original ID can encrypt the graph with a previously known key. A group specific key is used to generate runtime distinct keys for both keyed hashing as well as for encryption. The keyed hash ID anonymizes the ROBDD, which allows this key ID be eavesdropped without compromising the sending party even if the eavesdropper has the corresponding ROBDD.","When the system  receives a keyed hash with a key ID, which is unknown, the system  initiates a separate authenticated key exchange procedure. The system  may mix in the communication both keyed hash IDs and plain hash IDs (i.e., not-keyed hash IDs). When constructing a hash ID, the system  includes whether a hash ID is \u2018keyed\u2019 or \u2018plain\u2019 (e.g., <hash, plain>, <hash, keyid>). Key IDs may correspond to different groups, such as different social networks. A key ID together with an ROBDD graph constitutes a proof that the ROBDD has been constructed by the owner of the key ID.","With plain ROBDD graphs, the system  can provide keyed hash IDs calculated from that graph and the key IDs. This allows anyone with the key corresponding to the key ID to ensure that the ROBDD graph was generated by the owner of the key ID.","The \u201chistory\u201d column  shows that a new ROBDD can be constructed by an internal BDD core operation bdd_apply (which constructs the BDDs based on different operations: and, or, not, implication, forall, exists, xor, if-then-else and their possible combinations). The new ROBDD is then hashed to form a hash ID, and this hash ID is maintained in the external index table in a column . As shown in , an ROBDD corresponding to hash  can be constructed or reconstructed by applying a BDD operation (e.g., BDD_OR) on the ROBDDs corresponding to hash IDs (e.g., hash, hash) listed in the construction history.","Since the ROBDD may be constructed by BDD operations from other ROBDDs, the system  sends a succinct representation of the ROBDD by sending this history of BDD operations (i.e., the construction history of the ROBDD) along with a hash ID. Sending only the succinct representation (e.g., hash ID) of the ROBDD and history reduces potential data traffic especially in cases where the construction of the ROBDD has been performed based on general components that are expected to be commonly available and unchanging (such as a representation of an ontology or typical search for (Matti, a, person) which constitutes a partial ROBDD). The construction history may be complete or partial (up to a parameterized number).","For each incoming ROBDD graph, the system  repeats the same operations of generating a hash ID and storing the hash ID and a corresponding construction history in the external index table (e.g., hash table). For each incoming hash ID, the system  searches in the external indexing table for the incoming hash ID. When a matching hash ID is found in the ID column of the external index table, the system  associates the received hash ID with the ROBDD graph corresponding to the marched hash ID. Otherwise, the system  requests a sending party to send the ROBDD graph corresponding to the received hash ID or missing information for reconstructing the ROBDD graph. In one embodiment, this implementation can be added to the smart space, or built on top of the smart space.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 6A","FIG. 12","FIG. 6A","FIG. 6B","FIG. 6A"],"b":["107","600","600","601","107","107","621","623","625","627","629"],"i":["a ","a ","a "]},"To simplify the discussion, there are only two vertices extending from instance  \u201c0x12D\u201d and there is no subtree below the node  \u201cPerson\u201d or the node  \u201cMatti.\u201d However, it is contemplated that there can be any number of vertices and\/or subtrees below any of the nodes (e.g., nodes  or ) of the RDF graph . In addition, there are many ways or conditions for encoding the encode this RDF graph  into bit vectors. For instance, the bit size can be three as discussed previously, or four as discussed below. Different bit sizes result in, for instance, different numbers of variables which lead to ROBDD graphs of different sizes and shapes. In addition, different combinations of values can be assigned to the variables. In the example of , the RDF graph  is represented by the following two triples:","0x12D, a, Person","0x12D, name, \u201cMatti\u201d","Returning to , the hash identifier application then determines a bit size of the variables by calculating sizes of the variables or using a fixed size (Step ). In one embodiment, the bit size is fixed at a predefined size across the system  to, for instance, ensure the consistency of encoding. In the example of , the hash identifier application sets five BDD variables representing the subject (e.g., the instance  \u201c0x12D\u201d), the predicates (e.g., process  \u201ca\u201d and process  \u201c, name\u201d) and the objects (e.g., node  \u201cPerson\u201d and node , \u201cMatti\u201d). The hash identifier application then selects a number of bits for representing and encoding the subject, the predicates, and the objects.","As shown below, the bit size for the example of  is fixed as three bits across the system . Accordingly, the hash identifier application encodes these variables in three bits and saves the encoding information in a dictionary as follows:","0x12D<=>101","a<=>001","Person<=>011","name<=>010","\u201cMatti\u201d<=>100","The hash identifier application constructs a representation of the ROBDD from the variables (Step  of ). With respect to the example of , the hash identifier application uses the encoded variables to create a ROBDD graph consisting of nine one-bit variables, where the first three variables are interpreted as a variable encoding the first field of the triple, the second three variables are interpreted as a variable encoding the second field, and the last three variables are interpreted as a variable encoding the third field of the triple. This ROBDD graph is unique for the chosen triples and variable ordering, resulting in representation of the following encoded triples:","101 001 011","101 010 100","As another example, when the bit size is fixed at four as 4 bits across the system , The hash identifier application encodes these variables in four bits and saves the encoding information in a dictionary as follows:","0x12D<=>0000","a<=>0001","Person<=>0010","name<=>0011","\u201cMatti\u201d<=>0100","Accordingly, the hash identifier application uses the encoded variables to create a ROBDD graph consisting of 12 one-bit variables, where the first four variables represent the first field of the triple, the second four variables represent the second field of the triple, and the last four variables represent the third field of the triple. The ROBDD graph representing the following encoded triples is as follows:","0000 0001 0010","0000 0011 0100","As shown in , the hash identifier application selects a hash function for obtaining unique hash identifiers (Step ), and feeds the representation into the hash function thereby computing the hash identifier (Step ) thereby computing the hash identifier corresponding to the decision diagram (Step ). Like the size of the bit encoding, the hash function is usually chosen beforehand to be adhered to by all users and\/or components of the system . However, if the relevant information for choosing the hash function is not available, the hash identifier application chooses the hash function heuristically as in the embodiment.","Optionally, the hash identifier application shortens the computed hash identifier by truncating a result of the hash function while obtaining unique hash identifiers (Step ). The hash identifier application then stores the hash identifier with the decision diagram (Step ), for example, in the external index table  shown in .",{"@attributes":{"id":"p-0086","num":"0085"},"figref":["FIGS. 7A-7B","FIG. 12"],"b":["107","710","720","711","107","107","713","721","107","107","723","725"],"i":["a ","a ","a ","a ","a "]},"The processes for handling incoming hash IDs are shown diagrammatically in , in various embodiments. The first scenario is that the received hash ID is found in the ID column of the external indexing table (Step ). The system  uses the received hash ID from the sending party, and proceeds directly to retrieve the ROBDD graph from the external index table or perform any other action relating to the ROBDD (Step ).","The second scenario is that the received hash ID is not found in the ID column of the external indexing table (Step ) and the hash ID does not exist in the construction history of the external indexing table (Step ). The system  requests the corresponding ROBDD graph of the AugBDD from the sending party (Step ), and then proceeds to other actions (Step ).","The third scenario is either that the hash ID exists in the construction history of the external indexing table (Step ), or the hash ID (e.g., hash) is received with the construction history (e.g., BDD_OR(hash,hash)) of the ROBDD (i.e., [optional history]). When the available construction history (optionally including received construction history) is determined as complete or sufficiently complete enough (e.g., all hash ID(s) involve in the construction history of the unknown ROBDD have complete entries in the external indexing table) (Step ), the system  reconstructs the ROBDD from its construction history and the associated hash ID(s). The system  saves the reconstructed ROBDD graph in the external indexing table (Step ) and then proceeds to other actions (Step ).","In another scenario, the system  may determine that the construction history is available but is not complete (e.g., does not identify all hash IDs or Boolean operations needed to reconstruct the ROBDD). For example, some other hash IDs (e.g., hash, hash) involved in the construction history (via hash) of the unknown ROBDD have no complete entries in the external indexing table (Step ). As such, the unknown ROBDD corresponding to the hash ID (e.g., hash) cannot be constructed from the available construction history (optionally including received construction history) due to the missing hash ID(s): hash, hash.","The system  then determines whether to try to reconstruct the unknown ROBDD (Step ). As a receiving party, the system  has a choice to request any missing hash ID(s) included in the construction history of the received hash ID to enable reconstructing the unknown ROBDD, or to request the unknown ROBDD graph corresponding to the hash ID. For example, the decision may depend on whether the system  wants to use its own computing resources over network resources. However, if the relevant information is not available, the choice is heuristic (i.e., experience-based, such as a rule of thumb).","If deciding to query for the unknown ROBDD, the system  queries for the corresponding ROBDD graph of the AugBDD from the sending party (Step ), and then proceeds to other actions (Step ). When choosing to request the unknown ROBDD graph, the sending party can either send the ROBDD graph, or not to send it in order to push the system  to construct the ROBDD graph itself. In another embodiment, the sending party communicates only a part or parts of the ROBDD graph so as to distribute the workload between itself and the system . Both the sending partying and the system  can freely turn off the sending or accepting of hash IDs and the consecution history, and communicate full ROBDD graphs instead. In other words, the history information allows the sending party and the system  to divide the AugBDDs and to recompose them from partly existing sources, which can be used as means of delegating computation to the parties.","If deciding to reconstruct the unknown ROBDD, the system  queries for the missing hash ID(s) from the sending party (Step ), reconstructs the ROBDD from the available construction history and the involved hash IDs (including received missing hash ID(s)), and saves the reconstructed ROBDD graph in the external indexing table (Step ), and then proceeds to other actions (Step ). When the system  chooses to request the missing hash ID(s), it shoulders the computation and network resources and cost to reconstruct the ROBDD.","The embedding of an ROBDD in an AugBDDs means that the ROBDD graph is converted to some representation in known ways. This representation is then augmented with a header (or postfix) which contains the hash ID and a section describing the construction history of the ROBDD. The system  can choose any encoding for this, such as a simple implementation that writes out the hash IDs and operations in a reverse Polish notation (\u201cRPN\u201d) which is a mathematical notation wherein every operator follows all of its operands. An example of this notation is: \u201cab123 34cd3 AND 23dfg OR.\u201d","This example expresses (1) taking two ROBDDs represented by hash IDs ab123, 34cd3, (2) performing the BDD AND operation on them, and then (3) using that result to OR with an ROBDD represented by a hash ID 23dfg. In another example, the system uses only one hash ID instead of the two ANDed hash IDs.","For adding the implementation to the smart space, the system  augments the smart space protocol with a specific get_graph message which has the hash ID as a parameter and which is a return message to get the actual ROBDD graph representation. Alternatively, the get_graph message triggers another smart space message (recursively, if necessary) to get the complete ROBDD graph.","In practice, the system  accepts a hash function with a sufficiently low probability of producing same hash IDs for different ROBDDs. The hash function can be parameterized so that the resulting hash IDs have a very high probability to be unique. Instead of communicating representations of ROBDD graphs, the system  communicates the hash IDs. The receiving party can then compare the hash IDs with the hash IDs stored in the receiving party's external index table. For those received hash IDs that are unknown to the receiving party (i.e., which are not found in the external index table of the receiving party), the receiving party can request the actual ROBDD graphs to be sent thereto. The receiving party then updates its external index table to contain the hash IDs and the corresponding ROBDD graphs.","In one embodiment, the hash function operates one-way such that the information of the ROBDD graph cannot be reconstructed based only on the hash ID. As such, the system  builds an access control mechanism for the hash IDs. For example, certain hash IDs are not allowed to be communicated with particular parties or not allowed at all to be communicated externally. In another embodiment, the system  further tracks whether a ROBDD graph or other information has been sent out and whether the information has been sent via a potentially insecure channel or network.","The \u201cFinal Technical Report\u2014Specification Of A Security Architecture For Distributed Terminals\u201d (\u201cFinal Technical Report,\u201d incorporated herein by reference in its entirety) published by the Information Society Technologies in November 2002 (p. 40-41) described on pages 40-41 estimates about the probability of the collision of keyed hashes (Message Authentication Codes\u2014MACs), when the key was fixed. The Final Technical Report mathematically proved collision resilience of the keyed hashes. Instead of MACs, the system  generates hash IDs and reduces a probability of identical hash IDs for different ROBDDs to be as low as possible. The Final Technical Report used a Reed-Solomon based hash function by first applying a one-way hash function (such as SHA-1) to the data and then inputting the outputs from the hash function to a Reed-Solomon code, to provide sufficient security. In one embodiment of the invention, the hash function is composed of a one-way hash function and a Reed-Solomon based hash function. In some other embodiments, the hash functions do not need to be composed with a Reed-Solomon based hash function. Well known Reed-Solomon codes are rather long with very high minimum distance. If IDs are 4 hexadecimal digits long, the probability for two different ROBDDs to have the same ID is approximately 2^-12. By increasing the length of the IDs to 5 hexadecimal digits long, the probability becomes approximately 2^-17. The Final Technical Report assumed that 128-bit truncated SHA-1 provides a sufficient security level. This approach keeps a low probably of ROBDD collision without considerably increasing the key length or the length of the hash IDs. This means that if ROBDD is given, it is extremely difficult (in cryptographic sense) to find another ROBDD such that f(ROBDD)=f(ROBDD). To further reduce the possibility of providing two different ROBDDs with the same hash ID, the system  deploys SHA-256, which means that hash IDs are 256-bit long. Using suitable truncation of a hash function provides decent length hash ID. For example, 16-bytes long hash IDs sufficiently ensure that it is nearly impossible to create ROBDD such that ID_BDD=ID_BDD and that the occurrence of communicating an ambiguous hash ID is very unlikely.","The system  sends and receives hash IDs (i.e., hash values of ROBDDs), instead of the ROBDDs. Since the hash values are shorter than the values representing the ROBDD graphs, data traffic is significantly reduced at an acceptable rate of false positives. In another embodiment, short hash values (e.g., truncated hash values) are used, when there is a large amount of ROBDDs. For a RDF graph containing a large amount of data, the system  may process only a part or parts of the RDF graph that are feasible to be constructed as an AugBDD.","A primitive, which mirrors the get_graph (in earlier IPR), allows any entity to request signing of a given ROBDD graph by a key of the recipient. The resulting message will be a keyed hash ID for the ROBDD graph, and the key ID used for generating the keyed hash. This allows an entity to obtain a signed keyed hash from a trusted third party based on the content of the ROBDD graph and its construction history. Upon receiving a request for signing, a web service platform may examine the ROBDD graph and its construction history to decide whether it signs the graph or with what key it signs the graph. This encapsulates the trust level between the requester and the web service platform. The decision of whether the web service platform signs the AugBDD can be based on (1) the content of the AugBDD, (2) whether the signer has the hash ID in its own index table (so it already knows that the AugBDD is valid), (3) the smart space login credentials of a requester node are trustworthy, and combination of the above.","When the web service platform signs the AugBDD with a keyed hash ID and returns the corresponding key ID, the original requestor cannot regenerate the keyed hash ID since it has no key corresponding to the key ID, but it can always deliver the keyed hash ID and the key ID to a third party who then may have the key corresponding to the key ID. Alternatively, the third party may request the web service platform to validate the hashed ID and the key ID.","For efficiency reasons, the system  uses hash IDs that are as short as possible. Rather than using the hash IDs generated based upon a standard hash function like SHA-1, the system  truncates the hash IDs, for example to 128-bits. In another embodiment, the system  uses another standard hash function implementation such as SHA-256, and truncates the results. As discussed, 128-bit is adequate. Nevertheless, if truncating the hash IDs into lower values, other countermeasures may be adapted in order to prevent the forgery of the ROBDDs. When security and privacy are secured via other means, the system  only needs to ensure that two ROBDDs do not accidentally collide with each other, and 64-bit truncation is adequate. The implementation of the truncation size can be parameterized. By way of example, the simple Reed-Solomon based hash function implementation described in the Final Technical Report is used. The keyed hash IDs can be truncated by applying suitable truncation to keyed-Hash Message Authentication Code (HMAC or KHMAC) functions. However, the more the keyed hash IDs are truncated, the easier they can be forged (e.g., a hostile party can create a hash ID for a previously known AugBDD just by guessing suitable keys).","In one embodiment, the system  is adapted to a social network. Considering a situation shown in , users (e.g., Jenna and Matti) want to participate in the social network with their mobile terminals , . In other embodiments, the users participate via personal computers or different kinds of devices or equipment. In this example, both Jenna and Matti have information that is public (such as their moods) and information that is private (such as their bank account balances). The private and public information are constructed as AugBDDs and given unique hash IDs. The AugBDDs can be combined to form more complete information of the users and given another unique hash ID.","The social network has friendship relations and public information of its participants. These relations and information are formed into RDF graphs, which can be constructed as AugBDDs and published at a central location. The AugBDDs may contain history information of its construction. An ROBDD encoding dictionary may be available for all participants. A decision diagram compression value, i.e., the data size of a decision diagram based on the query result data, may be determined by considering the data size of the query result data. The above-mentioned triple set can then be concatenated to generate a bit sequence, which may be a query result bit sequence. In this regard, the discussed encoding keys, i.e., a=101, b=001, and c=011, can be stored in a dictionary. If necessary, the dictionary is transmitted along with the ROBDDs or the AugBDDs.","A representation for Matti's information is provided as follows:\n\n","Where :mood is public information and :bankaccount is private information. The same information exists for other participants. The system  constructs ROBDDs (\u201cBDDs\u201d) from RDF triples\/graphs representing a piece of information (e.g., :Matti a :Person.) and assigns them with IDs (e.g., BDD_ID ) as follows:\n\n","The BDD_IDs are results of a hash function and thus are unique and longer than one digit. The integers (e.g., 1, 2, etc.) are used here to simplify the discussion. The system  creates public and private information and the associated construction history as follows:\n\n","The public and private AugBDDs are divided in a way to share the private information independently from the public information. Meanwhile, the private information BDD and public information BDD of Matti are combined as BDD as shown in the upper portion of . In another embodiment, the system  traverses the history information deeper so that the #Matti_all is:\n\n","The system  repeats this procedure for Jenna:\n\n","The system  then creates a social network for some participants:\n\n","The fact that :Matti :friend :Jenna implies :Jenna :friend :Matti. Although Jenna :friend :Matti should be assigned with its own ID, the relevant assignment and discussion are omitted to simplify the discussion. The system  adds the social relation information to the public information:\n\n","The same procedure is repeated for other participants. The description of a protocol of agreeing to be friends in the social network is also omitted here. The system  goes straight to generate BDD_IDs for #Jenna_public and #Mervi_public. The procedure is the same as discussed above. The ID values are assigned in the sequence of discussion.","Since all of the mentioned participants belong to the same social network, the system  generates an aggregate BDD that corresponds to the social network in which Matti, Jenna and Mervi belong along with their public information as follows:\n\n","When participating in a social network, the public information is shared and can reside anywhere (e.g., any information stores) in the smart space, and at least at the central location (e.g., a centralized information store). In another embodiment, the #Nykanen_social () with its history information is sent to all participants if determined as necessary.","A change in public information, such as the mood of Matti, triggers construction of a new AugBDD and a new hash ID, which is then communicated to at least the central location. If the resulting change produces a ROBDD graph that has been generated before, only the hash ID is sent to the central location. In the smart space, the information stores usually query for the hash IDs and the construction history, and rarely ask for a complete ROBDD graph due to its size. Now considering a change in a status of Matti, i.e., he changes his mood from :happy to :hungry, and then later back to :happy. The system  generates a new ID as follows:\n\n","The system  then updates Matti's public information as follows:\n\n","When :Matti switches back to :happy :mood, the old ID becomes valid (provided no other changes have occurred) and only the old IDs are sent to the central location. The central location can use the old IDs as was before the mood change.","Since the original #Matti_public was included in the social graph #Nykanen_social, the system  can remove the original public ID from a local copy of the #Nykanen_social information and adds the new #Matti_public to it (both using BDD operations). The resulting BDD is hashed to a new BDD_ID (assuming it is truly new). The system  can publish that BDD_ID at the central location along with its construction history. When an information store does not recognize the hash ID (i.e., not available in the ID column of the external index table), it asks the central location or other information stores for the complete ROBDD graph. Another way of dealing with the unrecognized\/unknown ID is to look at the construction history of the ROBDD (i.e., tracking a chain of construction events back and forth between the history column and the ID column of the external index table for each hash IDs involved in the construction events) and only ask for the missing elements (e.g., hash, hash) in the graph and construct the ROBDD graph at the information store. The missing elements refer to hash IDs involving in construction events of other hash IDs in the table, but their own construction history is not available in the external index table.","In another embodiment, Jenna uses Matti's public information BDD (e.g., which is combined from BDD: Matti is a person or BDD: Matti is happy as mentioned) to create a hash ID: BDD_ID  (i.e., ID_DD in ) for her private information BDD (i.e., Jenna's bank account balance is $5,000). As shown in the lower portion of , the construction history of BDD thus includes BDD_ID, BDD_ID and BDD_ID . When Matti's mode changes, BDD changes according to data store in a database  containing construction history of BDD IDs. Both public information and private information can be available at a social network but under different level of access control as shown in the column  of the external index table and discussed previously.","The system  can be use in a semantic web, or in a smart space architecture to be available in all locations to all nodes and entities.  is a diagram of a smart space structure, according to one embodiment. Each smart space  includes smart space nodes\/objects , ,  and  and semantic information brokers (SIB) ,  which form the nucleus of the smart space . Each SIB is an entity performing triple governance in possible co-operation with other SIBs for one smart space. A SIB may be a concrete or virtual entity. Each SIB also supports the smart space nodes\/objects , ,  and  e.g., a user, a mobile terminal, or a PC) interacting with other SIBs through information transaction operations. The devices , may be any devices (e.g., a mobile terminal, a personal computer, etc,) or equipment (e.g., a server, a router, etc.). By way of example, RDF is used in the smart space . The triple governance transactions in the smart space  uses a smart space Access Protocol (SSAP) to, e.g., join, leave, insert, remove, update, query, subscribe, unsubscribe information (e.g., in a unit of a triple). A subscription is a special query that is used to trigger reactions to persistent queries for information. Persistent queries are particular cases of plain queries.","The physical distribution protocol of a smart space (i.e., SSAP) allows formation of a smart space using multiple SIBs. With transactional operations, a node\/object produces\/inserts and consumes\/queries information in the smart space . As distributed SIBs belong to the same smart space , query and subscription operations cover the whole information extent of a smart space.",{"@attributes":{"id":"p-0123","num":"0148"},"figref":["FIG. 10","FIG. 10"],"b":["100","1000","1000","1001","931","931","1002","1031","1031"],"i":["a","b ","a","b "]},"In this embodiment, the internal and external indexing tables are embedded in the SSAP protocol at SIB_IF or ISIB_IF upon an \u201cinsert\u201d protocol message. To build itself on top of the smart space protocol, the system  uses ontological constructs for the hash IDs, which is, for instance, a predefined smart_space_robdd_id concept. The SIB_IF is an interface between the SIBs and a device, and the ISIB_IF is an interface between two SIBs.","In one embodiment, the approach described herein is implemented at the interfaces SIB_IF and ISIB_IF of the system  to transmit the hash IDs. In other embodiments, one or more application programming interfaces (APIs) (e.g., third party APIs) can be used in addition to or instead of SIB_IF and ISIB_IF. The approach described herein provides performance gains while allowing multiple proprietary implementations of information stores in the smart space  according to . The decoding complexity for developing an application is buried below a convenience API (CONV_API) according to . Similarly, the tools for a local (at the node level) information search are provided as a part of a convenience library. However, if a malicious node produces metadata that exponentially increases a graph size (e.g., ROBDD size), the system  takes countermeasures such as conditional BDD encoding, and conventional node authentication methods, etc.","The augmentation of construction history and other information related to the ROBDD defines the ID of the data set described by the ROBDD (e.g., an ROBDD that has been embedded in the AugBDD). In one embodiment, the smart space protocol messages are checked for hash ID consistency by (1) checking for the correct (according to ontology) types of hash IDs in term of a range and a domain of the instances that have a defined property between them, and (2) checking for a correct number of hash IDs connected by the defined properties. In other words, the (1) and (2) mechanisms are applied to detect the smart_space_robdd_id concept within the smart space messages and then perform the checking for the availability of hash IDs from the external index table. The request for a missing hash ID can then be executed via a smart space query. This query relies upon the ROBDD graphs being available in a SIB in the smart space. The AugBDDs can be sent over to a remote system that uses the AugBDDs locally to check the consistency of the hash IDs or other properties in local information stores, which allows checking for ontology conformance without direct access to the ontology description.","The processes described herein for encoding decision diagrams may be advantageously implemented via software, hardware (e.g., general processor, Digital Signal Processing (DSP) chip, an Application Specific Integrated Circuit (ASIC), Field Programmable Gate Arrays (FPGAs), etc.), firmware or a combination thereof. Such exemplary hardware for performing the described functions is detailed below.",{"@attributes":{"id":"p-0128","num":"0153"},"figref":"FIG. 11","b":["1100","1100","1110","1100","1100"]},"A bus  includes one or more parallel conductors of information so that information is transferred quickly among devices coupled to the bus . One or more processors  for processing information are coupled with the bus .","A processor  performs a set of operations on information as specified by computer program code related to encode decision diagrams. The computer program code is a set of instructions or statements providing instructions for the operation of the processor and\/or the computer system to perform specified functions. The code, for example, may be written in a computer programming language that is compiled into a native instruction set of the processor. The code may also be written directly using the native instruction set (e.g., machine language). The set of operations include bringing information in from the bus  and placing information on the bus . The set of operations also typically include comparing two or more units of information, shifting positions of units of information, and combining two or more units of information, such as by addition or multiplication or logical operations like OR, exclusive OR (XOR), and AND. Each operation of the set of operations that can be performed by the processor is represented to the processor by information called instructions, such as an operation code of one or more digits. A sequence of operations to be executed by the processor , such as a sequence of operation codes, constitute processor instructions, also called computer system instructions or, simply, computer instructions. Processors may be implemented as mechanical, electrical, magnetic, optical, chemical or quantum components, among others, alone or in combination.","Computer system  also includes a memory  coupled to bus . The memory , such as a random access memory (RAM) or other dynamic storage device, stores information including processor instructions for encoding decision diagrams. Dynamic memory allows information stored therein to be changed by the computer system . RAM allows a unit of information stored at a location called a memory address to be stored and retrieved independently of information at neighboring addresses. The memory  is also used by the processor  to store temporary values during execution of processor instructions. The computer system  also includes a read only memory (ROM)  or other static storage device coupled to the bus  for storing static information, including instructions, that is not changed by the computer system . Some memory is composed of volatile storage that loses the information stored thereon when power is lost. Also coupled to bus  is a non-volatile (persistent) storage device , such as a magnetic disk, optical disk or flash card, for storing information, including instructions, that persists even when the computer system  is turned off or otherwise loses power.","Information, including instructions for encoding decision diagrams, is provided to the bus  for use by the processor from an external input device , such as a keyboard containing alphanumeric keys operated by a human user, or a sensor. A sensor detects conditions in its vicinity and transforms those detections into physical expression compatible with the measurable phenomenon used to represent information in computer system . Other external devices coupled to bus , used primarily for interacting with humans, include a display device , such as a cathode ray tube (CRT) or a liquid crystal display (LCD), or plasma screen or printer for presenting text or images, and a pointing device , such as a mouse or a trackball or cursor direction keys, or motion sensor, for controlling a position of a small cursor image presented on the display  and issuing commands associated with graphical elements presented on the display . In some embodiments, for example, in embodiments in which the computer system  performs all functions automatically without human input, one or more of external input device , display device  and pointing device  is omitted.","In the illustrated embodiment, special purpose hardware, such as an application specific integrated circuit (ASIC) , is coupled to bus . The special purpose hardware is configured to perform operations not performed by processor  quickly enough for special purposes. Examples of application specific ICs include graphics accelerator cards for generating images for display , cryptographic boards for encrypting and decrypting messages sent over a network, speech recognition, and interfaces to special external devices, such as robotic arms and medical scanning equipment that repeatedly perform some complex sequence of operations that are more efficiently implemented in hardware.","Computer system  also includes one or more instances of a communications interface  coupled to bus . Communication interface  provides a one-way or two-way communication coupling to a variety of external devices that operate with their own processors, such as printers, scanners and external disks. In general the coupling is with a network link  that is connected to a local network  to which a variety of external devices with their own processors are connected. For example, communication interface  may be a parallel port or a serial port or a universal serial bus (USB) port on a personal computer. In some embodiments, communications interface  is an integrated services digital network (ISDN) card or a digital subscriber line (DSL) card or a telephone modem that provides an information communication connection to a corresponding type of telephone line. In some embodiments, a communication interface  is a cable modem that converts signals on bus  into signals for a communication connection over a coaxial cable or into optical signals for a communication connection over a fiber optic cable. As another example, communications interface  may be a local area network (LAN) card to provide a data communication connection to a compatible LAN, such as Ethernet. Wireless links may also be implemented. For wireless links, the communications interface  sends or receives or both sends and receives electrical, acoustic or electromagnetic signals, including infrared and optical signals, that carry information streams, such as digital data. For example, in wireless handheld devices, such as mobile telephones like cell phones, the communications interface  includes a radio band electromagnetic transmitter and receiver called a radio transceiver. In certain embodiments, the communications interface  enables connection between the communication network  to the UE  for encoding decision diagrams.","The term computer-readable medium is used herein to refer to any medium that participates in providing information to processor , including instructions for execution. Such a medium may take many forms, including, but not limited to, non-volatile media, volatile media and transmission media. Non-volatile media include, for example, optical or magnetic disks, such as storage device . Volatile media include, for example, dynamic memory . Transmission media include, for example, coaxial cables, copper wire, fiber optic cables, and carrier waves that travel through space without wires or cables, such as acoustic waves and electromagnetic waves, including radio, optical and infrared waves. Signals include man-made transient variations in amplitude, frequency, phase, polarization or other physical properties transmitted through the transmission media. Common forms of computer-readable media include, for example, a floppy disk, a flexible disk, hard disk, magnetic tape, any other magnetic medium, a CD-ROM, CDRW, DVD, any other optical medium, punch cards, paper tape, optical mark sheets, any other physical medium with patterns of holes or other optically recognizable indicia, a RAM, a PROM, an EPROM, a FLASH-EPROM, any other memory chip or cartridge, a carrier wave, or any other medium from which a computer can read. The term computer-readable storage medium is used herein to refer to any computer-readable medium except transmission media.","Logic encoded in one or more tangible media includes one or both of processor instructions on a computer-readable storage media and special purpose hardware, such as ASIC .","Network link  typically provides information communication using transmission media through one or more networks to other devices that use or process the information. For example, network link  may provide a connection through local network  to a host computer  or to equipment  operated by an Internet Service Provider (ISP). ISP equipment  in turn provides data communication services through the public, world-wide packet-switching communication network of networks now commonly referred to as the Internet . A computer called a server host  connected to the Internet hosts a process that provides a service in response to information received over the Internet. For example, server host  hosts a process that provides information representing video data for presentation at display .","At least some embodiments of the invention are related to the use of computer system  for implementing some or all of the techniques described herein. According to one embodiment of the invention, those techniques are performed by computer system  in response to processor  executing one or more sequences of one or more processor instructions contained in memory . Such instructions, also called computer instructions, software and program code, may be read into memory  from another computer-readable medium such as storage device  or network link . Execution of the sequences of instructions contained in memory  causes processor  to perform one or more of the method steps described herein. In alternative embodiments, hardware, such as ASIC , may be used in place of or in combination with software to implement the invention. Thus, embodiments of the invention are not limited to any specific combination of hardware and software, unless otherwise explicitly stated herein.","The signals transmitted over network link  and other networks through communications interface , carry information to and from computer system . Computer system  can send and receive information, including program code, through the networks ,  among others, through network link  and communications interface . In an example using the Internet , a server host  transmits program code for a particular application, requested by a message sent from computer , through Internet , ISP equipment , local network  and communications interface . The received code may be executed by processor  as it is received, or may be stored in memory  or in storage device  or other non-volatile storage for later execution, or both. In this manner, computer system  may obtain application program code in the form of signals on a carrier wave.","Various forms of computer readable media may be involved in carrying one or more sequence of instructions or data or both to processor  for execution. For example, instructions and data may initially be carried on a magnetic disk of a remote computer such as host . The remote computer loads the instructions and data into its dynamic memory and sends the instructions and data over a telephone line using a modem. A modem local to the computer system  receives the instructions and data on a telephone line and uses an infra-red transmitter to convert the instructions and data to a signal on an infra-red carrier wave serving as the network link . An infrared detector serving as communications interface  receives the instructions and data carried in the infrared signal and places information representing the instructions and data onto bus . Bus  carries the information to memory  from which processor  retrieves and executes the instructions using some of the data sent with the instructions. The instructions and data received in memory  may optionally be stored on storage device , either before or after execution by the processor .",{"@attributes":{"id":"p-0141","num":"0166"},"figref":["FIG. 12","FIG. 11"],"b":["1200","1200","1200"]},"In one embodiment, the chip set  includes a communication mechanism such as a bus  for passing information among the components of the chip set . A processor  has connectivity to the bus  to execute instructions and process information stored in, for example, a memory . The processor  may include one or more processing cores with each core configured to perform independently. A multi-core processor enables multiprocessing within a single physical package. Examples of a multi-core processor include two, four, eight, or greater numbers of processing cores. Alternatively or in addition, the processor  may include one or more microprocessors configured in tandem via the bus  to enable independent execution of instructions, pipelining, and multithreading. The processor  may also be accompanied with one or more specialized components to perform certain processing functions and tasks such as one or more digital signal processors (DSP) , or one or more application-specific integrated circuits (ASIC) . A DSP  typically is configured to process real-world signals (e.g., sound) in real time independently of the processor . Similarly, an ASIC  can be configured to performed specialized functions not easily performed by a general purposed processor. Other specialized components to aid in performing the inventive functions described herein include one or more field programmable gate arrays (FPGA) (not shown), one or more controllers (not shown), or one or more other special-purpose computer chips.","The processor  and accompanying components have connectivity to the memory  via the bus . The memory  includes both dynamic memory (e.g., RAM, magnetic disk, writable optical disk, etc.) and static memory (e.g., ROM, CD-ROM, etc.) for storing executable instructions that when executed perform the inventive steps described herein to encode decision diagrams. The memory  also stores the data associated with or generated by the execution of the inventive steps.",{"@attributes":{"id":"p-0144","num":"0169"},"figref":["FIG. 13","FIG. 1"],"b":"1300"},"Pertinent internal components of the telephone include a Main Control Unit (MCU) , a Digital Signal Processor (DSP) , and a receiver\/transmitter unit including a microphone gain control unit and a speaker gain control unit. A main display unit  provides a display to the user in support of various applications and mobile terminal functions that perform or support the steps of reducing communications traffic on networks by encoding decision diagrams. The display unit  includes display circuitry configured to display at least a portion of a user interface of the mobile terminal (e.g., mobile telephone). Additionally, the display unit  and display circuitry are configured to facilitate user control of at least some functions of the mobile terminal. An audio function circuitry  includes a microphone  and microphone amplifier that amplifies the speech signal output from the microphone . The amplified speech signal output from the microphone  is fed to a coder\/decoder (CODEC) .","A radio section  amplifies power and converts frequency in order to communicate with a base station, which is included in a mobile communication system, via antenna . The power amplifier (PA)  and the transmitter\/modulation circuitry are operationally responsive to the MCU , with an output from the PA  coupled to the duplexer  or circulator or antenna switch, as known in the art. The PA  also couples to a battery interface and power control unit .","In use, a user of mobile terminal  speaks into the microphone  and his or her voice along with any detected background noise is converted into an analog voltage. The analog voltage is then converted into a digital signal through the Analog to Digital Converter (ADC) . The control unit  routes the digital signal into the DSP  for processing therein, such as speech encoding, channel encoding, encrypting, and interleaving. In one embodiment, the processed voice signals are encoded, by units not separately shown, using a cellular transmission protocol such as global evolution (EDGE), general packet radio service (GPRS), global system for mobile communications (GSM), Internet protocol multimedia subsystem (IMS), universal mobile telecommunications system (UMTS), etc., as well as any other suitable wireless medium, e.g., microwave access (WiMAX), Long Term Evolution (LTE) networks, code division multiple access (CDMA), wideband code division multiple access (WCDMA), wireless fidelity (WiFi), satellite, and the like.","The encoded signals are then routed to an equalizer  for compensation of any frequency-dependent impairments that occur during transmission though the air such as phase and amplitude distortion. After equalizing the bit stream, the modulator  combines the signal with a RF signal generated in the RF interface . The modulator  generates a sine wave by way of frequency or phase modulation. In order to prepare the signal for transmission, an up-converter  combines the sine wave output from the modulator  with another sine wave generated by a synthesizer  to achieve the desired frequency of transmission. The signal is then sent through a PA  to increase the signal to an appropriate power level. In practical systems, the PA  acts as a variable gain amplifier whose gain is controlled by the DSP  from information received from a network base station. The signal is then filtered within the duplexer  and optionally sent to an antenna coupler  to match impedances to provide maximum power transfer. Finally, the signal is transmitted via antenna  to a local base station. An automatic gain control (AGC) can be supplied to control the gain of the final stages of the receiver. The signals may be forwarded from there to a remote telephone which may be another cellular telephone, other mobile phone or a land-line connected to a Public Switched Telephone Network (PSTN), or other telephony networks.","Voice signals transmitted to the mobile terminal  are received via antenna  and immediately amplified by a low noise amplifier (LNA) . A down-converter  lowers the carrier frequency while the demodulator  strips away the RF leaving only a digital bit stream. The signal then goes through the equalizer  and is processed by the DSP . A Digital to Analog Converter (DAC)  converts the signal and the resulting output is transmitted to the user through the speaker , all under control of a Main Control Unit (MCU) \u2014which can be implemented as a Central Processing Unit (CPU) (not shown).","The MCU  receives various signals including input signals from the keyboard . The keyboard  and\/or the MCU  in combination with other user input components (e.g., the microphone ) comprise a user interface circuitry for managing user input. The MCU  runs a user interface software to facilitate user control of at least some functions of the mobile terminal  to encode decision diagrams. The MCU  also delivers a display command and a switch command to the display  and to the speech output switching controller, respectively. Further, the MCU  exchanges information with the DSP  and can access an optionally incorporated SIM card  and a memory . In addition, the MCU  executes various control functions required of the terminal. The DSP  may, depending upon the implementation, perform any of a variety of conventional digital processing functions on the voice signals. Additionally, DSP  determines the background noise level of the local environment from the signals detected by microphone  and sets the gain of microphone  to a level selected to compensate for the natural tendency of the user of the mobile terminal .","The CODEC  includes the ADC  and DAC . The memory  stores various data including call incoming tone data and is capable of storing other data including music data received via, e.g., the global Internet. The software module could reside in RAM memory, flash memory, registers, or any other form of writable storage medium known in the art. The memory device  may be, but not limited to, a single memory, CD, DVD, ROM, RAM, EEPROM, optical storage, or any other non-volatile storage medium capable of storing digital data.","An optionally incorporated SIM card  carries, for instance, important information, such as the cellular phone number, the carrier supplying service, subscription details, and security information. The SIM card  serves primarily to identify the mobile terminal  on a radio network. The card  also contains a memory for storing a personal telephone number registry, text messages, and user specific mobile terminal settings.","While the invention has been described in connection with a number of embodiments and implementations, the invention is not so limited but covers various obvious modifications and equivalent arrangements, which fall within the purview of the appended claims. Although features of the invention are expressed in certain combinations among the claims, it is contemplated that these features can be arranged in any combination and order."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The embodiments of the invention are illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings:",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 4A-4B"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 5","FIG. 3"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 6A","FIG. 6B","FIG. 6A"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 7A-7B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 9","FIG. 3"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
