---
title: System, method and computer program product for using an arbitrary quantity as texture address
abstract: A system, method and computer program product are provided for programmable pixel processing in a computer graphics pipeline. In one embodiment of the present invention, a computed arbitrary quantity is applied as texture address.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07136070&OS=07136070&RS=07136070
owner: NVIDIA Corporation
number: 07136070
owner_city: Santa Clara
owner_country: US
publication_date: 20030523
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENTS","APPENDIX A"],"p":["This application is a continuation-in-part of U.S. application Ser. No. 09\/885,382, now U.S. Pat. No. 6,870,540 filed Jun. 19, 2001, which is a continuation-in-part of an application entitled \u201cSYSTEM, METHOD AND ARTICLE OF MANUFACTURE FOR A PROGRAMMABLE VERTEX PROCESSING MODEL WITH INSTRUCTION SET\u201d filed May 31, 2000 under Ser. No. 09\/586,249, and an application entitled \u201cMETHOD, APPARATUS AND ARTICLE OF MANUFACTURE FOR TRANSFORMING, LIGHTING AND RASTERIZATION ON A SINGLE SEMICONDUCTOR PLATFORM\u201d filed Dec. 6, 1999 under Ser. No. 09\/454,516 now U.S. Pat. No. 6,198,488. These applications are herein incorporated by reference.","The present invention relates to computer graphics, and more particularly to providing programmability in a computer graphics processing pipeline.","Graphics application program interfaces (API's) have been instrumental in allowing applications to be written to a standard interface and to be run on multiple platforms, i.e. operating systems. Examples of such graphics API's include Open Graphics Library (OpenGL\u00ae) and Direct 3D\u2122 (D3D\u2122) pipelines. OpenGL\u00ae is the computer industry's standard graphics API for defining 2-D and 3-D graphic images. With OpenGL\u00ae, an application can create the same effects in any operating system using any OpenGL\u00ae-adhering graphics adapter. OpenGL\u00ae specifies a set of commands or immediately executed functions. Each command directs a drawing action or causes special effects.","Thus, in any computer system which supports this OpenGL\u00ae standard, the operating system(s) and application software programs can make calls according to the standard, without knowing exactly any specifics regarding the hardware configuration of the system. This is accomplished by providing a complete library of low-level graphics manipulation commands, which can be used to implement graphics operations.","A significant benefit is afforded by providing a predefined set of commands in graphics API's such as OpenGL\u00ae. By restricting the allowable operations, such commands can be highly optimized in the driver and hardware implementing the graphics API. On the other hand, one major drawback of this approach is that changes to the graphics API are difficult and slow to be implemented. It may take years for a new feature to be broadly adopted across multiple vendors.","With the integration of transform operations into high speed graphics chips and the higher integration levels allowed by semiconductor manufacturing, it is now possible to make part of the pipeline accessible to the application writer. There is thus a need to exploit this trend in order to afford increased flexibility in visual effects. In particular, there is a need to provide a new computer graphics programming model and instruction set that allows convenient implementation of changes to the graphics API, while preserving the driver and hardware optimization afforded by currently established graphics API's.","A system, method and computer program product are provided for programmable pixel processing in a computer graphics pipeline. In one embodiment of the present invention, a computed arbitrary quantity is applied as texture address.","Specifically, the present invention discloses a programmable pixel processor that is able to fetch an instruction set, e.g., an instruction set for texture lookup. The instruction set can be stored in a storage that can be accessed by the pixel processor. In fact, the instruction set can be written at a later time and loaded into a storage to be fetched by the pixel processor, thereby allowing the pixel processor to be fully programmable. This novel approach addresses the criticality where texture coordinates are limited to a small set of possible inputs, e.g., interpolated values and predefined simple functions. Removal of the restriction increases by a very large quantity the number of interesting pixel shader programs (instruction sets) that can be written. Additionally, this programmable approach will allow such programs to be written in a more efficient and flexible manner to produce a particular effect.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1","b":["50","52","54","56","57","58"]},"As an option, each of the foregoing modules may be situated on a single semiconductor platform. In the present description, the single semiconductor platform may refer to a sole unitary semiconductor-based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi-chip modules with increased connectivity which simulate on-chip operation, and make substantial improvements over utilizing a conventional CPU and bus implementation. Of course, the present invention may also be implemented on multiple semiconductor platforms and\/or utilizing a conventional CPU and bus implementation.","During operation, the buffer  is included for gathering and maintaining a plurality of attributes. Completed vertices are processed by the transform module  and then sent to the lighting module . The transform module  generates parameters for the lighting module  to light. The output of the lighting module  is screen space data suitable for the set-up module which, in turn, sets up primitives. Thereafter, rasterization module  carries out rasterization of the primitives. In particular, the rasterization module  passes on pixel data including, but not limited to a position, a pixel diffuse color, a specular color, a fog value, a plurality of texture coordinates, and\/or any other information relating to the pixels involved with the processing in the graphics pipeline.","A pixel processing module  is coupled to the rasterization module  for processing the pixel data. The pixel processing module  begins by reading the pixel data generated by the rasterization module . In operation, the pixel processing module  outputs a color and a depth value. Pixel processing module  can be implemented in accordance with application specific requirements. For example, pixel processing module  can be implemented as disclosed in US patent application entitled \u201cProgrammable Pixel Shading Architecture\u201d, filed on Jun. 19, 2001 with Ser. No. 09\/885,242, which is also assigned to the assignee of the present application. This patent application is herein incorporated by reference.","Table 1 illustrates operations that may be done after the pixel processing module  is finished. A standard application program interface (API) state may be used as appropriate, as will soon become apparent.",{"@attributes":{"id":"p-0023","num":"0022"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Scissor"]},{"entry":[{},"Color Format Conversion"]},{"entry":[{},"Alpha Test"]},{"entry":[{},"Zbuffer\/Stencil"]},{"entry":[{},"Blendfunction"]},{"entry":[{},"Logicop"]},{"entry":[{},"Dither"]},{"entry":[{},"Writemask"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 2","FIG. 1"],"b":["200","58","202","204"]},"When disabled, the present invention allows increased or exclusive control of the graphics pipeline by the standard graphics API, as indicated in operation . In one embodiment, states of the standard graphics API may not be overruled by invoking the programmable pixel mode of the present invention. In one embodiment, no graphics API state may be directly accessible by the present invention, with the exception of the bound texture state.","In one embodiment, the standard graphics API may include Open Graphics Library (OpenGL\u00ae) and\/or D3D\u2122 APIs. OpenGL\u00ae is the computer industry's standard API for defining 2-D and 3-D graphic images. With OpenGL\u00ae, an application can create the same effects in any operating system using any OpenGL\u00ae-adhering graphics adapter. OpenGL\u00ae specifies a set of commands or immediately executed functions. Each command directs a drawing action or causes special effects. OpenGL\u00ae and D3D\u2122 APIs are commonly known to those of ordinary skill, and more information on the same may be had by reference to the OpenGL\u00ae specification Version 2.1, which is incorporated herein by reference in its entirety.","As is well known, OpenGL\u00ae mandates a certain set of configurable computations defining transformation, texture coordinate generation and transformation, and lighting. Several extensions have been developed to provide further computations to OpenGL\u00ae.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3","b":["300","58","300"]},"As shown in , the pixel processing module  includes a functional module  that is capable of carrying out a plurality of different types of operations. The functional module  is equipped with three inputs and an output. Associated with each of the three inputs are a swizzling module  and a negating module  for purposes that will be set forth hereinafter in greater detail. Data swizzling is useful when generating vectors. Such technique allows the efficient generation of a vector cross product and other vectors.","The functional module  is capable of carrying out programmable operations and supporting multiple levels of precision. Such levels of precision may include full floating point (i.e. 32-bit), half floating point (i.e. 16-bit), and fixed point. More information regarding the programmable operations and the various levels of precision will be set forth hereinafter in greater detail.","Coupled to the output of the functional module  is an input of a register file  having three outputs. The register file  is also equipped with a vector component writemask module . The register file  has single write and triple read access. The contents of the register file  are initialized to (0,0,0,0) at the start of program execution.","Also included are a pixel source buffer  and a constant source buffer . The pixel source buffer  stores data in the form of pixel data, and may be equipped with write access and\/or at least single read access. The constant source buffer  stores data in the form of constant data, and may also be equipped with write access and\/or at least single read access. It may be read using an absolute address.","In one exemplary embodiment, the pixel source buffer  is twelve (12) quad-floats in size (12*128 bits). Operation of the pixel processor module  may be commenced when all pixel attributes are valid. The position contains x and y in integer (D3D\u2122) and +0.5 (OpenGL\u00ae) window coordinates, z is normalized to the range (0,1), and 1\/w is in homogeneous clip space. Such attributes may be mandatory in the current exemplary embodiment. The pixel attributes may also be perspective correct. The colors and fog value may be generated at a lower precision, while the texture coordinates may be generated in high precision, i.e. 32-bit floating point.  is a detailed table  showing various attributes handled by the pixel source buffer .","Each of the inputs of the functional module  is equipped with a multiplexer . This allows the outputs of the register file , pixel source buffer , and constant source buffer  to be fed to the inputs of the functional module . This is facilitated by buses .","While not shown, the functional module  may also be coupled to a texture fetch module (not shown) for fetching texture data. Such texture fetch module may also be coupled to the register file . It should be noted that frame buffer contents are only visible to the pixel processing module  via texture fetches.","There need not necessarily be an explicit connection between texture coordinates and the textures that they may access. It is possible to use the same coordinate, or generated coordinates, to access any of the active textures as many times as desired and in any sequence desired. Programs are allowed access to sixteen (16) active textures. If an accessed texture is not bound, the texture fetch may return (0,0,0,0). The texture fetch instruction specifies the texture identifier desired (i.e. between 0 and 15). In one embodiment, texture components that are in fixed point form may have a bias (0.0,\u22120.5) and a multiply operation (2x,1x) applied to them before they are returned to the pixel processing module . This capability need not necessarily apply to floating point texture components. A texture fetch may return the data at the destination precision.","The pixel processing module  of  works well with hardware accelerators. In use, pixels are processed independently. Only one pixel is visible to the pixel processing module . As an option, there may be one 4-bit condition code register initialized as equal to 0 at program start.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 4","FIG. 3"],"b":["400","402","312","312"]},"Thereafter, in operation , programmable operations, i.e. pixel processing , are performed on the data in order to generate output. The programmable operations are capable of generating output that may be stored in the register file  in operation . During operation , the output stored in the register file  is used in performing the programmable operations on the data. Thus, the register file  may include any type of memory capable of allowing the execution of the programmable operations on the output.","By this design, the present invention allows a user to program a portion of the graphics pipeline that handles pixel processing. This results in an increased flexibility in generating visual effects. Further, the programmable pixel processing of the present invention allows remaining portions of the graphics pipeline to be controlled by the standard API for the purpose of preserving hardware optimizations.","During operation, only one pixel is processed at a time in the functional module  that performs the programmable operations. As such, the pixels may be processed independently. Further, the various foregoing operations may be processed for multiple pixels in parallel.","In one embodiment of the present invention, a constant may be received, and the programmable operations may be performed based on the constant. During operation, the constant may be stored in and received from the constant source buffer . Further, the constant may be accessed in the constant source buffer  using an absolute or relative address. Asian option, there may be one or more address registers for use during reads from the constant source buffer . It may be initialized to \u201c0\u201d at the start of program execution in operation  of . Further, the constant source buffer  may be written with a program which may or may not be exposed to users.","The register file  may be equipped with single write and triple read access. Register contents may be initialized to (0,0,0,0) at the start of program execution in operation  of .",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 6","FIG. 6"],"b":["600","600"]},"An exemplary assembly language will now be set forth in the context of which the foregoing operations may be executed. Such language refers to a plurality of resources delineated in Table 2. Note the correspondence with the various components of the model  of .",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Pixel Source","p[*]","of size 12 vectors"]},{"entry":"(192B)"},{"entry":["Constant Memory","c[*]","of size 32 vectors"]},{"entry":"(512B)"},{"entry":["Data Registers\/Output","R0\u2013R7, H0\u2013H15, I0\u2013I7","of size 8, 16, 8 vectors"]},{"entry":"(128B)"},{"entry":["Condition Codes","RC, HC, IC","of size 4 bits"]},{"entry":["Instruction Storage",{},"of size 128 instructions"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The data registers and memory locations include four component floating point precision. Further, the registers may be accessed as full floating point precision (fp32:R0\u2013R7), half floating point precision (fp16:H0\u2013H15), or signed 12-bit fixed point precision (s12:I0\u2013I7). These overlap as follows: R0\/H0\u2013H1\/I0\u2013I1, R1\/H2\u2013H3\/I2\u2013I3, R2\/H4\u2013H5\/I4\u2013I5, etc.","Vector components may be swizzled before use via four subscripts (xyzw). An arbitrary component re-mapping may be done. Some examples are shown in Table 3.",{"@attributes":{"id":"p-0049","num":"0048"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},".xyzw means source(x, y, z, w) \u2212> input(x, y, z, w)"]},{"entry":[{},".zzxy means source(x, y, z, w) \u2212> input(z, z, x, y)"]},{"entry":[{},".xxxx means source(x, y, z, w) \u2212> input(x, x, x, x)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Shortcuts: no subscripts refers to .xyzw (same as writemask)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},".x is the same as .xxxx"]},{"entry":[{},".y is the same as .yyyy"]},{"entry":[{},".z is the same as .zzzz"]},{"entry":[{},".w is the same as .wwww"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"All source operands (except condition codes) may be negated by putting a \u2018\u2212\u2019 sign in front. The condition codes can be changed whenever data is written (by adding a \u2018c\u2019 to the op-code) and sharing the writemask with the destination. If there is no other destination, RC or HC or IC may be used as a dummy write register. When data is written, each component may compared to 0.0 and its status recorded if the writemask for that component is enabled.","The condition codes are sourced as EQ(equal), NE(not equal), LT(less), GE(greater or equal), LE(less or equal), GT(greater), FL(false), and TR(true), which generates four (4) bits of condition code by applying the specified comparison. As a source (for KIL and writemask modification), the condition codes may be swizzled.","Writes to the register, condition codes, and RC are maskable. Each component is written only if it appears as a destination subscript (from xyzw). Specifying no writemask is the same as a writemask of xyzw. No swizzling may be possible for writemask, and subscripts may be ordered (x before y before z before w). It is also possible to modify the write mask by the condition codes (at the beginning of the instruction) by an \u2018AND\u2019 operation as set forth in Table 4. It should be noted that condition codes here have swizzle control.",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 4"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"destination(GT.x)","\/\/writemask[4] = 1111 & GT.xxxx"]},{"entry":[{},"destination.xw(EQ.yyzz)","\/\/writemask[4] = x00w & EQ.yyzz"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"An exemplary assembler format is set forth in Table 5.",{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"OPCODE DESTINATION, SOURCE(S)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Valid sources are the pixel source, constants, and registers. Valid destinations are registers, RC, HC, and IC. Output data is taken from the register file . It should be noted that vertex programs use the functional module  for output. A particular API mode allows selection of an output format for the color and depth values, and whether the program will generate a new depth value.","A blend function and alpha testing may or may not be available based on the color output format. For example, a blend function and alpha testing may be available if the selected color format is four (4) unsigned bytes. The final color is taken from register R, H, or I. The final color vector, regardless of the precision format, may be stored into a frame buffer assuming a similarly sized color buffer.","If a depth value is to be generated, the final value of R1.x, H1.x, or I1.x holds the new depth value. If depth is not to be generated, the standard pipeline depth is used. Depth is normalized to a (0,1) range which is clamped and scaled by hardware to fit the final depth buffer test format. The depth writemask may apply.","As mentioned earlier, three formats are supported for vector components. More information regarding precision will now be set forth in the context of an exemplary embodiment. Table 6 illustrates each of the various formats.",{"@attributes":{"id":"p-0060","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 6"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Floating point: fp32 (s.e8.m23)"]},{"entry":[{},"Floating point: fp16 (s.e5.m10)"]},{"entry":[{},"Signed fixed point: s12 (2.10 in 2's complement,"]},{"entry":[{},"range of \u22122 to +2047\/1024),"]},{"entry":[{},"where:"]},{"entry":[{},"fp32 refers to a 32-bit floating point precision"]},{"entry":[{},"fp16 refers to a 16-bit floating point precision"]},{"entry":[{},"s12 refers to fixed point precision"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"It may not necessarily be possible to mix formats inside a vector. Further, in one embodiment, no floating point exceptions or interrupts may be supported. Denorms may be flushed to zero, and NaN may be treated as infinity. Negative 0.0 may also be treated as positive 0.0 in comparisons.","In 32-bit floating point mode, the RCP and RSQ instructions may deliver mantissa results accurate to 1.0\/(2**22). Moreover, the approximate output (.z) in the EXP and LOG instructions only have to be accurate to 1.0\/(2**11). The LIT instruction output (.z) allows error equivalent to the combination of the EXP and LOG combination implementing a power function.","In 16-bit floating point mode, the RCP, RSQ, LOG, and EXP instructions deliver results accurate to within one least significant bit of the correct answer. LIT has at least the accuracy of a LOG, multiply, and EXP sequence in 16-bit floating point mode. In fixed point mode, all calculations are performed and then clamped into the valid range.","Since distance is calculated as (d*d)*(1\/sqrt(d*d)), 0.0 multiplied by infinity may be 0.0. Since if\/then\/else evaluation is done by multiplying by 1.0\/0.0 and adding the values set forth in Table 7. However, if\/then\/else evaluation can also be done via condition codes.",{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 7"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0.0 * x = 0.0","for all x (including infinity and NaN)"]},{"entry":[{},"1.0 * x = x","for all x (including infinity and NaN)"]},{"entry":[{},"0.0 + x = x","for all x (including infinity and NaN)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In one embodiment, the registers may be grouped into 128-bit chunks, each of which may be used as a single 4*fp32 quad-float, two 4*fp16 quad-floats, or two 4*s12 quad-fixed point. There are eight (8) such chunks allowing a maximum of eight (8) registers in fp32 mode and sixteen (16) registers in fp16. It should be noted that there are only eight (8) s12 registers.","The present invention is allowed to use mixed precision registers as sources and destination to an instruction. In this case, conversion to destination precision is done before the instruction is executed. The instruction itself is performed at the destination precision.","If a 128-bit chunk is read in a different format from which it was last written, 0.0 is returned. Pixel source and constants may be in 32-bit floating point precision, but may be reduced to lower precision by the destination.","More information will now be set forth regarding each of the programmable operations  of .","No Operation (NOP)","Format:","NOP","Description:","No Operation.","Examples:","NOP","Texture Fetch (TEX,TXP,TXD)","Format:\n\n","Description:","The contents of the source vector are used as a texture coordinate indexing into the specified (via tid:0\u201315) texture map. The filtered vector resulting is placed into the destination as a quad-float. TEX generates a texture fetch of (x,y,z) while TXP generates a texture fetch of (x\/w,y\/w,z\/w). TXD allows specification of the derivative in x (S1) and y (S2). These may be used for LOD\/anisotropic calculations. TXD generates a texture fetch of (x,y,z).","Operation:","Table 8 sets forth an example of operation associated with the TEX, TXP, and TXD instructions.",{"@attributes":{"id":"p-0083","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 8"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0 ***c;"]},{"entry":[{},"if (\u2212source0)"]},{"entry":[{},"\u2002t = \u2212t;"]},{"entry":[{},"q = TextureFetch (t,texid);"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Examples:\n\n","Derivative X (DDX)","Format:\n\n","Description:","DDX operates to ensure that the rate of change of the components of the source with respect to the horizontal axis \u2018X\u2019 are placed into the destination.","Operation:","Table 9 sets forth an example of operation associated with the DDX instruction.",{"@attributes":{"id":"p-0091","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 9"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]},{"entry":[{},"\u2002t = \u2212t;"]},{"entry":[{},"q.x = d(t.x)\/dx;"]},{"entry":[{},"q.y = d(t.y)\/dx;"]},{"entry":[{},"q.z = d(t.z)\/dx;"]},{"entry":[{},"q.w = d(t.w)\/dx;"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Examples:\n\n","Derivative Y (DDY)","Format:\n\n","Description:","DDY operates to ensure that the rate of change of the components of the source with respect to the vertical axis \u2018Y\u2019 is placed into the destination.","Operation:","Table 10 sets forth an example of operation associated with the DDY instruction.",{"@attributes":{"id":"p-0099","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 10"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]},{"entry":[{},"\u2002t = \u2212t;"]},{"entry":[{},"q.x = d(t.x)\/dy;"]},{"entry":[{},"q.y = d(t.y)\/dy;"]},{"entry":[{},"q.z = d(t.z)\/dy;"]},{"entry":[{},"q.w = d(t.w)\/dy;"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Examples:\n\n","Move (MOV)","Format:\n\n","Description:","MOV operates to move the contents of the source into a destination.","Operation:","Table 11 sets forth an example of operation associated with the MOV instruction.",{"@attributes":{"id":"p-0107","num":"0115"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]},{"entry":[{},"\u2002t = \u2212t;"]},{"entry":[{},"q.x = t.x;"]},{"entry":[{},"q.y = t.y;"]},{"entry":[{},"q.z = t.z;"]},{"entry":[{},"q.w = t.w;"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Examples:\n\n","Multiply (MUL)","Format:\n\n","Description:","MUL operates to multiply sources into a destination. It should be noted that 0.0 times anything is 0.0.","Operation:","Table 12 sets forth an example of operation associated with the MUL instruction.",{"@attributes":{"id":"p-0115","num":"0127"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 12"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]},{"entry":[{},"\u2002t = \u2212t;"]},{"entry":[{},"u.x = source1.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"u.y = source1.*c**;"]},{"entry":[{},"u.z = source1.**c*;"]},{"entry":[{},"u.w = source1.***c;"]},{"entry":[{},"if (\u2212source1)"]},{"entry":[{},"\u2002u = \u2212u;"]},{"entry":[{},"q.x = t.x*u.x;"]},{"entry":[{},"q.y = t.y*u.y;"]},{"entry":[{},"q.z = t.z*u.z;"]},{"entry":[{},"q.w = t.w*u.w;"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Examples:\n\n","Add (ADD)","Format:\n\n","Description:","ADD serves to add sources into a destination.","Operation:","Table 13 sets forth an example of operation associated with the ADD instruction.",{"@attributes":{"id":"p-0123","num":"0138"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 13"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]},{"entry":[{},"\u2002t = \u2212t;"]},{"entry":[{},"u.x = source1.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"u.y = source1.*c**"]},{"entry":[{},"u.z = source1.**c*;"]},{"entry":[{},"u.w = source1.***c;"]},{"entry":[{},"if (\u2212source1)"]},{"entry":[{},"\u2002u = \u2212u;"]},{"entry":[{},"q.x = t.x+u.x;"]},{"entry":[{},"q.y = t.y+u.y;"]},{"entry":[{},"q.z = t.z+u.z;"]},{"entry":[{},"q.w = t.w+u.w;"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Examples:\n\n","Multiply And Add (MAD)","Format:\n\n","Description:","MAD serves to multiply and add sources into a destination. It should be noted that 0.0 times anything is 0.0.","Operation:","Table 14 sets forth an example of operation associated with the MAD instruction.",{"@attributes":{"id":"p-0131","num":"0150"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 14"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]},{"entry":[{},"\u2002t = \u2212t;"]},{"entry":[{},"u.x = source1.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"u.y = source1.*c**;"]},{"entry":[{},"u.z = source1.**c*;"]},{"entry":[{},"u.w = source1.***c;"]},{"entry":[{},"if (\u2212source1)"]},{"entry":[{},"\u2002u = \u2212u;"]},{"entry":[{},"v.x = source2.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"v.y = source2.*c**;"]},{"entry":[{},"v.z = source2.**c*;"]},{"entry":[{},"v.w = source2.***c;"]},{"entry":[{},"if (\u2212source2)"]},{"entry":[{},"\u2002v = \u2212v;"]},{"entry":[{},"q.x = t.x*u.x+v.x;"]},{"entry":[{},"q.y = t.y*u.y+v.y;"]},{"entry":[{},"q.z = t.z*u.z+v.z;"]},{"entry":[{},"q.w = t.w*u.w+v.w;"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Examples:\n\n","Reciprocal (RCP)","Format:\n\n","Description:","RCP inverts source scalar into a destination. The source may have one subscript. Output may be exactly 1.0 if the input is exactly 1.0.\n\n","Operation:","Table 15 sets forth an example of operation associated with the RCP instruction.",{"@attributes":{"id":"p-0139","num":"0165"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 15"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]},{"entry":[{},"\u2002t = \u2212t;"]},{"entry":[{},"if(t.x == 1.0)"]},{"entry":[{},"\u2002q.x = q.y = q.z = q.w = 1.0;"]},{"entry":[{},"else"]},{"entry":[{},"\u2002q.x = q.y = q.z = q.w = 1.0\/t.x; where |q.x \u2212"]},{"entry":[{},"IEEE(1.0\/t.x)| < 1\/(2**22) for all 1.0 <= t.x<2.0"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Examples:\n\n","Reciprocal Square Root (RSQ)","Format:\n\n","Description:","RSQ performs an inverse square root of absolute value of source scalar into a destination. The source may have one subscript. Output may be exactly 1.0 if the input is exactly 1.0.\n\n","Operation:","Table 16 sets forth an example of operation associated with the RSQ instruction.",{"@attributes":{"id":"p-0147","num":"0178"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 16"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]},{"entry":[{},"\u2002t = \u2212t;"]},{"entry":[{},"if (t.x == 1.0)"]},{"entry":[{},"\u2002q.x = q.y = q.z = q.w = 1.0;"]},{"entry":[{},"else"]},{"entry":[{},"\u2002q.x=q.y=q.z=q.w=1.0\/sqrt(abs(t.x)); with |q.x \u2212"]},{"entry":[{},"IEEE(1.0\/sqrt(t.x))| < 1\/(2**22) for 1.0 <= t.x<4.0"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Examples:\n\n","Three Component Dot Product (DP3)","Format:\n\n","Description:","DP3 performs a three component dot product of the sources into a destination. It should be noted that 0.0 times anything is 0.0.","Operation:","Table 17 sets forth an example of operation associated with the DP3 instruction.",{"@attributes":{"id":"p-0155","num":"0189"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 17"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0 ***c;"]},{"entry":[{},"if (\u2212source0)"]},{"entry":[{},"\u2002t = \u2212t;"]},{"entry":[{},"u.x = source1.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"u.y = source1.*c**;"]},{"entry":[{},"u.z = source1.**c*;"]},{"entry":[{},"u.w = source1.***c;"]},{"entry":[{},"if (\u2212source1)"]},{"entry":[{},"\u2002u = \u2212u;"]},{"entry":[{},"q.x = q.y = q.z = q.w = t.x*u.x + t.y*u.y + t.z*u.z;"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Examples:\n\n","Four Component Dot Product (DP4)","Format:\n\n","Description:","DP4 performs a four component dot product of the sources into a destination. It should be noted that 0.0 times anything is 0.0.","Operation:","Table 18 sets forth an example of operation associated with the DP4 instruction.",{"@attributes":{"id":"p-0163","num":"0200"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 18"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]},{"entry":[{},"\u2002t = \u2212t;"]},{"entry":[{},"u.x = source1.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"u.y = source1.*c**;"]},{"entry":[{},"u.z = source1.**c*;"]},{"entry":[{},"u.w = source1.***c;"]},{"entry":[{},"if (\u2212source1)"]},{"entry":[{},"\u2002u = \u2212u;"]},{"entry":[{},"q.x = q.y = q.z = q.w = t.x*u.x + t.y*u.y + t.z*u.z + t.w*u.w;"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Examples:\n\n","Distance Vector (DST)","Format:\n\n","Description:","DST calculates a distance vector. A first source vector is assumed to be (NA,d*d,d*d,NA) and second source vector is assumed to be (NA,1\/d,NA,1\/d). A destination vector is then (1,d,d*d,1\/d). It should be noted that 0.0 times anything is 0.0.","Operation:","Table 19 sets forth an example of operation associated with the DST instruction.",{"@attributes":{"id":"p-0171","num":"0211"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 19"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"t = \u2212t;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"u.x = source1.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"u.y = source1.*c**;"]},{"entry":[{},"u.z = source1.**c*;"]},{"entry":[{},"u.w = source1.***c;"]},{"entry":[{},"if (\u2212source1)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"u = \u2212u;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"q.x = 1.0;"]},{"entry":[{},"q.y = t.y*u.y;"]},{"entry":[{},"q.z = t.z;"]},{"entry":[{},"q.w = u.w;"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Examples:\n\n","Minimum (MIN)","Format:\n\n","Description:","MIN serves to move a minimum of sources into a destination.","Operation:","Table 20 sets forth an example of operation associated with the MIN instruction.",{"@attributes":{"id":"p-0179","num":"0221"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 20"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"t = \u2212t;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"u.x = source1.c***; \/*c is x or y or z or w *\/"]},{"entry":[{},"u.y = source1.*c**;"]},{"entry":[{},"u.z = source1.**c*;"]},{"entry":[{},"u.w = source1.***c;"]},{"entry":[{},"if (\u2212source1)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"u = \u2212u;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"q.x = (t.x < u.x) ? t.x : u.x;"]},{"entry":[{},"q.y = (t.y < u.y) ? t.y : u.y;"]},{"entry":[{},"q.z = (t.z < u.z) ? t.z : u.z;"]},{"entry":[{},"q.w = (t.w < u.w) ? t.w : u.w;"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Examples:\n\n","Maximum (MAX)","Format:\n\n","Description:","MAX moves a maximum of sources into a destination.","Operation:","Table 21 sets forth an example of operation associated with the MAX instruction.",{"@attributes":{"id":"p-0187","num":"0233"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 21"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"t = \u2212t;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"u.x = source1.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"u.y = source1.*c**;"]},{"entry":[{},"u.z = source1.**c*;"]},{"entry":[{},"u.w = source1.***c;"]},{"entry":[{},"if (\u2212source1)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"u = \u2212u;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"q.x = (t.x >= u.x) ? t.x : u.x;"]},{"entry":[{},"q.y = (t.y >= u.y) ? t.y : u.y;"]},{"entry":[{},"q.z = (t.z >= u.z) ? t.z : u.z;"]},{"entry":[{},"q.w = (t.w >= u.w) ? t.w : u.w;"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Examples:\n\n","Pack2 (PK2)","Format:\n\n","Description:","PK2 packs two source components (.xy after swizzle) into a destination. The destination may be a fp32 \u201cR\u201d register. The source components are converted into fp16 format and packed into a destination.","Operation:","Table 22 sets forth an example of operation associated with the PK2 instruction.",{"@attributes":{"id":"p-0195","num":"0244"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 22"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"t = \u2212t;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = fp16(t.x);"]},{"entry":[{},"t.y = fp16(t.y);"]},{"entry":[{},"q.x = q.y = q.z = q.w = ((t.x) | (t.y<<16)); \/* raw bit packing *\/"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Examples:\n\n","Pack4 (PK4)","Format:\n\n","Description:","PK4 packs four source components into a destination. The destination may be a fp32 \u201cR\u201d register. The source components are clamped to the range (\u22121.008,1.0) before being packed into a destination as unsigned 8 bit bytes.","Operation:","Table 23 sets forth an example of operation associated with the PK4 instruction.",{"@attributes":{"id":"p-0203","num":"0254"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 23"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"t.x = source0.c***; \/* c is x or y or z or w *\/"},{"entry":"t.y = source0.*c**;"},{"entry":"t.z = source0.**c*;"},{"entry":"t.w = source0.***c;"},{"entry":"if (\u2212source0)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"t = \u2212t;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"q.x = t.x; if (q.x > 1.0) q.x = 1.0; else if (q.x < \u22121.008) q.x = \u22121.008;"},{"entry":"q.y = t.y; if (q.y > 1.0) q.y = 1.0; else if (q.y < \u22121.008) q.y = \u22121.008;"},{"entry":"q.z = t.z; if (q.z > 1.0) q.z = 1.0; else if (q.z < \u22121.008) q.z = \u22121.008;"},{"entry":"q.w = t.w; if (q.w > 1.0) q.w = 1.0; else if (q.w < \u22121.008) q.w = \u22121.008;"},{"entry":"ub.x = 127.0*q.x + 128; \/* ub is unsigned byte vector *\/"},{"entry":"ub.y = 127.0*q.y + 128;"},{"entry":"ub.z = 127.0*q.z + 128;"},{"entry":"ub.w = 127.0*q.w + 128;"},{"entry":"q.x = q.y = q.z = q.w = ((ub.x) | (ub.y<<8) | (ub.z<<16) |"},{"entry":"(ub.w<<24)); \/* raw bit packing *\/"},{"entry":"if (destination.x) R.x = q.x;"},{"entry":"if (destination.y) R.y = q.y;"},{"entry":"if (destination.z) R.z = q.z;"},{"entry":"if (destination.w) R.w = q.w;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Examples:\n\n","Unpack2 (UP2)","Format:\n\n","Description:","UP2 unpacks source component into a destination. The source may be a fp32 \u201cR\u201d register scalar. The source component is assumed to be a packed fp16 pair.","Operation:","Table 24 sets forth an example of operation associated with the UP2 instruction.",{"@attributes":{"id":"p-0211","num":"0264"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 24"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"t = \u2212t;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"q.x = q.z = (t.x>> 0) & 0xffff; \/* use raw bits of t.x *\/"]},{"entry":[{},"q.y = q.w = (t.x>>16) & 0xffff; \/* use raw bits of t.x *\/"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Examples:\n\n","Unpack4 (UP4)","Format:\n\n","Description:","UP4 unpacks source component into a destination. The source may be a fp32 \u201cR\u201d register scalar. The source component is assumed to be a packed unsigned 8-bit quartet and all are biased and scaled back into the range (\u22121.008,1.0) before assignment to destination.","Operation:","Table 25 sets forth an example of operation associated with the UP4 instruction.",{"@attributes":{"id":"p-0219","num":"0274"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 25"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"t = \u2212t;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"q.x = (t.x>> 0) & 0xff; \/* use raw bits of t.x *\/"]},{"entry":[{},"q.y = (t.x>> 8) & 0xff; \/* use raw bits of t.x *\/"]},{"entry":[{},"q.z = (t.x>>16) & 0xff; \/* use raw bits of t.x *\/"]},{"entry":[{},"q.w = (t.x>>24) & 0xff; \/* use raw bits of t.x *\/"]},{"entry":[{},"q.x = (q.x \u2212 128)\/127.0;"]},{"entry":[{},"q.y = (q.y \u2212 128)\/127.0;"]},{"entry":[{},"q.z = (q.z \u2212 128)\/127.0;"]},{"entry":[{},"q.w = (q.w \u2212 128)\/127.0;"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Examples:\n\n","Set On Less Than (SLT)","Format:\n\n","Description:","SLT sets the destination to 1.0\/0.0 if source0 is less_than\/greater_or_equal to source1. The following relationships should be noted:\n\n","Operation:","Table 26 sets forth an example of operation associated with the SLT instruction.",{"@attributes":{"id":"p-0227","num":"0288"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 26"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"t = \u2212t;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"u.x = source1.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"u.y = source1.*c**;"]},{"entry":[{},"u.z = source1.**c*;"]},{"entry":[{},"u.w = source1.***c;"]},{"entry":[{},"if (\u2212source1)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"u = \u2212u;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"q.x = (t.x < u.x) ? 1.0 : 0.0;"]},{"entry":[{},"q.y = (t.y < u.y) ? 1.0 : 0.0;"]},{"entry":[{},"q.z = (t.z < u.z) ? 1.0 : 0.0;"]},{"entry":[{},"q.w = (t.w < u.w) ? 1.0 : 0.0;"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Examples:\n\n","Set on Greater or Equal than (SGE)","Format:\n\n","Description:","SGE sets the destination to 1.0\/0.0 if source0 is greater_or_equal\/less_than source1.","Operation:","Table 27 sets forth an example of operation associated with the SGE instruction.",{"@attributes":{"id":"p-0235","num":"0299"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 27"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"t = \u2212t;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"u.x = source1.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"u.y = source1.*c**;"]},{"entry":[{},"u.z = source1.**c*;"]},{"entry":[{},"u.w = source1.***c;"]},{"entry":[{},"if (\u2212source1)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"u = \u2212u;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"q.x = (t.x >= u.x) ? 1.0 : 0.0;"]},{"entry":[{},"q.y = (t.y >= u.y) ? 1.0 : 0.0;"]},{"entry":[{},"q.z = (t.z >= u.z) ? 1.0 : 0.0;"]},{"entry":[{},"q.w = (t.w >= u.w) ? 1.0 : 0.0;"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Examples:\n\n","Floor (FLR)","Format:\n\n","Description:","FLR set the destination to floor of source.","Operation:","Table 28 sets forth an example of operation associated with the FLR instruction.",{"@attributes":{"id":"p-0243","num":"0310"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 28"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"t = \u2212t;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"q.x = floor(t.x);"]},{"entry":[{},"q.y = floor(t.y);"]},{"entry":[{},"q.z = floor(t.z);"]},{"entry":[{},"q.w = floor(t.w);"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Examples:\n\n","Fraction (FRC)","Format:\n\n","Description:","FRC sets a destination to a fractional part of a source. The fraction is 0.0<=fraction<1.0.","Operation:","Table 29 sets forth an example of operation associated with the FRC instruction.",{"@attributes":{"id":"p-0251","num":"0320"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 29"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"t = \u2212t;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"q.x = t.x \u2212 floor(t.x);"]},{"entry":[{},"q.y = t.y \u2212 floor(t.y);"]},{"entry":[{},"q.z = t.z \u2212 floor(t.z);"]},{"entry":[{},"q.w = t.w \u2212 floor(t.w);"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Examples:\n\n","Kill Pixel (KIL)","Format:\n\n","Description:","KIL kills the pixel based on any of the RC bits (post swizzle) being TRUE. KIL cannot set the condition codes.","Operation:","Table 30 sets forth an example of operation associated with the KIL instruction.",{"@attributes":{"id":"p-0259","num":"0330"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 30"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"b.x = RC.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"b.y = RC.*c**;"]},{"entry":[{},"b.z = RC.**c*;"]},{"entry":[{},"b.w = RC.***c;"]},{"entry":[{},"if (b.x | b.y | b.z | b.w)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Kill pixel;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Examples:\n\n","Exponential Base 2 (EXP)","Format:\n\n","Description:","EXP generates an approximate answer in dest.z and allows for a more accurate answer of dest.x*FUNC(dest.y) where FUNC is some user approximation to 2**dest.y (0.0<=dest.y<1.0). EXP accepts a scalar source0. Reduced precision arithmetic is acceptable in evaluating dest.z.\n\n","Operation:","Table 31 sets forth an example of operation associated with the EXP instruction.",{"@attributes":{"id":"p-0267","num":"0344"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 31"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"t = \u2212t;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"q.x = 2**TruncateTo\u2212Infinity(t.x);"]},{"entry":[{},"q.y = t.x \u2212 TruncateTo\u2212Infinity(t.x);"]},{"entry":[{},"q.z = q.x * APPX(q.y); where |exp(q.y*LN2)\u2212APPX(q.y)|"]},{"entry":[{},"< 1\/(2**11) for all 0<=q.y<1.0"]},{"entry":[{},"q.w = 1.0;"]},{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Examples:\n\n","Logarithm Base 2 (LOG)","Format:\n\n","Description:","LOG generates an approximate answer in dest.z and allows for a more accurate answer of dest.x+FUNC(dest.y) where FUNC is some user approximation of log2(dest.y) (1.0<=dest.y<2.0). LOG accepts a scalar source0 of which the sign bit is ignored. LOG provides reduced precision arithmetic is acceptable in evaluating dest.z.\n\n","Operation:","Table 32 sets forth an example of operation associated with the LOG instruction.",{"@attributes":{"id":"p-0275","num":"0356"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 32"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t.x = source0.c***; \/* c is x or y or z or w *\/"]},{"entry":[{},"t.y = source0.*c**;"]},{"entry":[{},"t.z = source0.**c*;"]},{"entry":[{},"t.w = source0.***c;"]},{"entry":[{},"if (\u2212source0)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"t = \u2212t;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (abs(t.x) != 0.0) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"q.x = exponent(t.x) (\u2212128.0 <= e < 127)"]},{"entry":[{},"q.y = mantissa(t.x) (1.0 <= m < 2.0)"]},{"entry":[{},"q.z = q.x + APPX(q.y) where |log(q.y)\/LN2\u2212APPX(q.y)| <"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"1\/(2**11) for all 1.0<=q.y<2.0"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"q.w = 1.0;"]},{"entry":[{},"}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"q.x = \u2212inf; q.y = 1.0; q.z = \u2212inf; q.w = 1.0;"]},{"entry":[{},"}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if (destination.x) R.x = q.x;"]},{"entry":[{},"if (destination.y) R.y = q.y;"]},{"entry":[{},"if (destination.z) R.z = q.z;"]},{"entry":[{},"if (destination.w) R.w = q.w;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Examples:\n\n","Light Coefficients (LIT)","Format:\n\n","Description:","LIT provides lighting partial support. LIT calculates lighting coefficients from two dot products and a power. Source vector is:\n\n","Reduced precision arithmetic is acceptable in evaluating dest.z. Allowed error is equivalent to a power function combining the LOG and EXP instructions (EXP(w*LOG(y))). An implementation may support at least 8 fraction bits in the power. It should be noted that since 0.0 times anything may be 0.0, taking any base to the power of 0.0 yields 1.0.","Operation:","Table 33 sets forth an example of operation associated with the LIT instruction.",{"@attributes":{"id":"p-0284","num":"0371"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 33"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"t.x = source0.c***; \/* c is x or y or z or w *\/"},{"entry":"t.y = source0.*c**;"},{"entry":"t.z = source0.**c*;"},{"entry":"t.w = source0.***c;"},{"entry":"if (\u2212source0)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"t = \u2212t;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"if (t.w < \u2212127.9961) t.w = \u2212127.9961; \/* assuming power is s8.8 *\/"},{"entry":"else if (t.w > 127.9961) t.w = 127.9961;"},{"entry":"if (t.x < 0.0) t.x = 0.0;"},{"entry":"if (t.y < 0.0) t.y = 0.0;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["q.x = 1.0;","\/* ambient *\/"]},{"entry":["q.y = t.x;","\/* diffuse *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["q.z = (t.x > 0.0 ? EXP(t.w*LOG(t.y)) : 0.0);","\/* specular *\/"]},{"entry":"q.w = 1.0;"},{"entry":"if (destination.x) R.x = q.x;"},{"entry":"if (destination.y) R.y = q.y;"},{"entry":"if (destination.z) R.z = q.z;"},{"entry":"if (destination.w) R.w = q.w;"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Examples:\n\n","Appendix A sets forth a plurality of programming examples.","Although the above description discloses a plurality of predefined programs, e.g., as shown in , the present invention is not so limited. Specifically, the examples provided above illustrated an exemplary approach where a texture lookup is followed by the execution of one or more predefined instruction sets and then is followed by another texture lookup based on the calculations performed by the predefined instruction sets. This iterative approach can be repeated in accordance with a particular implementation requirement.","However, the present invention can be more broadly applied. Namely, the present invention allows any instructions that employ an arbitrary computed quantity or parameter as texture address. To state in another manner, the hardware that implements the shader is not limited to a predefined set of instruction sets. Instead, the shader can be implemented to be fully programmable such that any arbitrary computed quantity can be employed as texture address.",{"@attributes":{"id":"p-0289","num":"0377"},"figref":"FIG. 7","b":["700","700","705","710"]},"In step , method  fetches a program, e.g., a program for texture lookup. The program can be stored in a storage that can be accessed by pixel processor . In fact, the program can be written at a later time and loaded into a storage to be fetched by the pixel processor , thereby allowing pixel processor  to be fully programmable. This novel approach addresses the criticality where texture coordinates are limited to a small set of possible inputs, e.g., interpolated values and predefined simple functions. Removal of the restriction increases by a very large quantity the number of interesting pixel shader programs that can be written. Additionally, this programmable approach will allow such programs to be written in a more efficient and flexible manner to produce a particular effect.","In step , the pertinent data is read, e.g., from a register. The pertinent data is defined by the fetched program.","In step , method  computes or performs a texture address calculation in accordance with a function defined by the fetched program. The calculation produces an arbitrary quantity that is stored in a storage, e.g., in a register or memory. It should be noted that step  can execute any functions, including one of the plurality of instruction sets as disclosed above. For example, the functions may include the result from one or more previous texture lookups, any mathematical function computable by a shader program including pseudorandom noise, solutions of partial differential and integral equations, and so on.","In step , method  queries whether a texture fetch operation or a texture look-up operation is performed. If the query is positively answered, then method  proceeds to step , where the computed arbitrary quantity is applied as texture address, i.e., texture information is retrieved during a texture look-up operation using the computed arbitrary quantity. If the query is negatively answered, then method  proceeds to step .","In step , method  queries whether another calculation is to be performed, e.g., whether additional shading operation  is to be performed. If the query is positively answered, then method  proceeds to step , where another iteration (steps \u2013) is executed. If the query is negatively answered, then method  proceeds to step .","In step , method  queries whether another or new instruction set is to be fetched. If the query is positively answered, then method  proceeds to step , and the steps \u2013 are repeated in accordance with the new program. If the query is negatively answered, then method  ends in step .","It should be noted that method  and\/or some of the steps of method  may be represented by one or more software applications (or even a combination of software and hardware, e.g., using application specific integrated circuits (ASICS)), where the software is loaded from a storage medium, (e.g., a magnetic or optical drive, a diskette or a ROM) and operated by the CPU in the memory of a computing device. As such, the methods (including associated steps and data structures) of the present invention can be stored on a computer readable medium, e.g., RAM memory, ROM, magnetic or optical drive or diskette and the like.","While various embodiments have been described above, it should be understood that they have been presented by way of example only, and not limitation. Thus, the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents.","The #define statements are meant for a cpp run.","1)",";Absolute Value H4=abs(R0)",{"@attributes":{"id":"p-0299","num":"0000"},"ul":{"@attributes":{"id":"ul0117","list-style":"none"},"li":{"@attributes":{"id":"ul0117-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0118","list-style":"none"},"li":["MAX H4,R0,\u2212R0;\n\n2)\n\n;Cross Product | i j k | into R2\n\n; |R0.x R0.y R0.z|\n\n; |R1.x R1.y R1.z|\n","MUL R2,R0.zxyw,R1.yzxw;","MAD R2,R0.yzxw,R1.zxyw,\u2212R2;\n\n4)\n\n;reduce R1 to fundamental period\n\n#define PERIOD 70; location PERIOD is 1.0\/(2*Pl),2*Pl,0.0,0.0\n","MUL R0,R1,c[PERIOD].x;\/\/divide by period","FRC R2,R0;","MUL R2,R2,c[PERIOD].y;\/\/multiply by period\n\n5)\n\n;H4=p\u2192weight.x*H2+(1.0\u2212p\u2192weight.x)*H3\n\n#define IWGT 8; source weight\n","ADD H4,H2,\u2212H3;\/\/LERP","MAD H4,p[IWGT].x,H4,H3;\n\n6)\n\n;R0=(GT.x \u2225 LT.y) ? R1: R2;\n","MOV R0,R2;","MOV R0(GT.x),R1;","MOV R0(LT.y),R1;\n\n7)\n\n;R0.y=(EQ.xzw && LT.y) ? R1.z: R2.w;\n","MOV R0.y,R1.z;","MOV R0.y(NE.xzww),R2.w;","MOV R0.y(GE.y),R2.w;"]}}}}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing and other aspects and advantages are better understood from the following detailed description of a preferred embodiment of the invention with reference to the drawings, in which:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
