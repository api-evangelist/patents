---
title: Programming interface for data communications
abstract: In embodiments of a programming interface for data communications, a request queue and a completion queue can be allocated from a user-mode virtual memory buffer that corresponds to an application. The request queue and the completion queue can be pinned to physical memory and then mapped to kernel-mode system addresses so that the request queue and the completion queue can be accessed by a kernel-mode execution thread. A request can be received from an application for the kernel to handle data in the request queue, and a system issued to the kernel for the kernel-mode execution thread to handle the request. The kernel-mode execution thread can then handle additional requests from the application without additional system calls being issued.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08752063&OS=08752063&RS=08752063
owner: Microsoft Corporation
number: 08752063
owner_city: Redmond
owner_country: US
publication_date: 20110623
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Current application programming interfaces (APIs), that interface high-performance networking applications with the kernel of a computing device, are not well equipped to handle the increased data processing demands of networking applications. For example, the \u201cWindows Socket\u201d API, known as \u201cWinsock\u201d, is configured to facilitate operations issued by applications to send and receive data to and from the kernel layer which communicates with a physical network device. Send and receive operations are generally issued multiple times over the course of the socket's lifetime. Accordingly, the send and receive processing overhead can constitute the majority of the network processing and perhaps of the application as a whole.","In the traditional Winsock API, for example, initiating the send and receive operations involve making a system call to pin user-mode virtual memory to physical memory and to initiate the transfer of data into the kernel. Then an additional system call is typically required to get the completion status of the transfer and to unpin the user-mode virtual memory from the physical memory. Accordingly, existing Winsock send and receive APIs may incur redundant memory pinning and unpinning if the application uses the same memory over and over again for sending and receiving data.","This Summary is provided to introduce simplified concepts of a programming interface for data communications, and the concepts are further described below in the Detailed Description and\/or shown in the Figures. This Summary should not be considered to describe essential features of the claimed subject matter, nor used to determine or limit the scope of the claimed subject matter.","A programming interface for data communications is described. In embodiments, a request queue can be allocated from a user-mode virtual memory buffer that corresponds to an application. The request queue can be pinned to physical memory and then mapped to a kernel-mode system address so that the request queue can be accessed by a kernel-mode execution thread. A request can be received from an application for the kernel to handle data in the request queue, and a system call issued to the kernel for the kernel-mode execution thread to handle the request. The kernel-mode execution thread can then handle additional requests from the application without additional system calls being issued. For example, I\/O requests will be one system call, but will not require any memory pinning overhead, and the I\/O completion will occur without any system call overhead. A socket can be registered that provides a data request from the application to the kernel. In embodiments, registering the socket includes identifying a completion queue to the socket, allocating the request queue from the user-mode virtual memory buffer, and pinning the request queue to the physical memory.","In other embodiments, a user-mode virtual memory buffer is registered as corresponding to an application. A completion queue is allocated from the user-mode virtual memory buffer and pinned to physical memory. The completion queue is then mapped to a kernel-mode system address in a kernel. The completion queue receives completion notifications from a kernel-mode execution thread via the kernel-mode system address, and enables access to the completion notifications by the application via the user-mode virtual memory buffer without the overhead of any kernel to user system calls.","A programming interface for data communications is described. A \u201ccommunication stack\u201d can be implemented in software in a computing device to communicate data via a network. A typical communication stack includes an application layer where networking applications are implemented and a kernel layer where the operating system kernel is implemented. The application layer exposes an interface to applications that is abstracted away from the underlying details of the communication stack. The kernel layer interfaces with networking devices configured to communicate data over the network.","Typically, to send data over a network, an application pushes data through a user-mode application programming interface (API) which is then processed by the networking stack to frame the protocol in both the user-mode and the kernel-mode. As described herein, user-mode refers to an execution mode where access to system resources such as physical memory and I\/O devices is protected by the operating system in order to provide isolation between multiple applications running on the same system. Kernel-mode, as described herein, refers to an execution mode which provides access to all system resources but only allows certain parts of operating system code to run in the kernel-mode. The data is then moved to a networking device, such as a network interface card (MC), in the kernel layer which facilitates communication of the data over the network. An NIC is a hardware device that is used by the system for sending and receiving data over a network.","It should be noted, therefore, that in order for an application to communicate data over a network, the application must first transmit data from the application layer to the kernel layer. A programming interface (such as \u201cWindows Socket\u201d, known as \u201cWinsock\u201d, by Microsoft Corporation) is configured to interface the application layer with the kernel layer and can be used to facilitate the transfer of data between the application layer and the kernel layer.","In the traditional Winsock API, initiating send and receive operations involve making a system call to pin user-mode virtual memory to physical memory and to initiate the transfer of data into the kernel. As described herein, a \u201csystem call\u201d refers to a mechanism for user-mode code to issue a request to the system code running in kernel-mode. This is how user-mode applications gain access to and use system resources in a protected fashion. In addition, an additional system call is typically used to get the completion status of the transfer and to then unpin the user-mode virtual memory from the physical memory. Accordingly, existing Winsock send and receive APIs may incur redundant memory pinning and unpinning if the application uses the same memory over and over again for sending and receiving data.","The high frequency of system calls to the kernel often creates a heavy processing load on the kernel which may not be equipped to handle a high volume of networking data processing requests, and particularly for the high-speed data processing demands of networking applications. Accordingly, communication delays, also known as latency, often result from the communication of data between the application layer and the kernel layer. In addition, networking applications may experience jitter, the variation in latency, during data communications.","In embodiments, a programming interface that is compatible with existing communication stacks, applications, and network protocols is described. Prior attempts at enabling high-speed data communications have attempted to modify the whole communication stack. It should be appreciated then, that the programming interface described herein can be implemented as a modification of existing programming interfaces, and does not affect the communication stack. Embodiments of the programming interface improves processor load, reduces the latency of network communication, and reduces jitter by reducing the number of system calls to the kernel.","The programming interface separates the pinning and unpinning of user-mode virtual memory buffers to physical memory from data transfer request initiation and completion handling. A user-mode application, therefore, can register a user-mode virtual memory buffer once (which would involve pinning of the memory buffer to the physical memory location), and can then use the registered user-mode virtual memory buffer for multiple data transfer requests without re-registering or unpinning the memory buffer. By separating the pinning and unpinning of memory from data transfer initiation and completion, the programming interface enables data transfer initiation and completion handling without making multiple system calls.","In embodiments, the programming interface uses a request queue for request initiation and a completion queue for retrieving request completions. The request queue and the completion queue can be allocated from a user-mode virtual memory buffer corresponding to the application and pinned in physical memory. The request queue and the completion queue can then be mapped to kernel-mode system addresses to enable the request queue and the completion queue to be accessed by a kernel-mode execution thread.","This configuration enables a user-mode application to continuously queue requests into the request queue while the kernel-mode execution thread (such as a system thread or interrupt) continuously drains the requests from the request queue to handle the requests. As requests are completed in the kernel-mode, completion notifications can be queued to the completion queue by a kernel-mode execution thread. These completion notifications can then be de-queued by the user-mode application directly from the completion queue. Note then that the programming interface only needs to issue a system call when there are no kernel-mode execution threads already assigned to handle the queued request from the request queue.","While features and concepts of a programming interface for data communications can be implemented in any number of different devices, systems, environments, networks, and\/or configurations, embodiments of a programming interface for data communications are described in the context of the following example devices, systems, and methods.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 1","FIG. 5"],"b":["100","100","100","100"]},"Computing device  can communicate data via a network , which can be implemented to include a wired and\/or a wireless network that facilitates data communication. The network can also be implemented using any type of network topology and\/or communication protocol, and can be represented or otherwise implemented as a combination of two or more networks. The network may also include mobile operator networks that are managed by mobile operators, such as a communication service provider, cell-phone provider, and\/or Internet service provider. A mobile operator can facilitate mobile data and\/or voice communication for any type of a wireless device or mobile phone (e.g., cellular, VoIP, Wi-Fi, etc.).","Computing device  can include one or more processors  (e.g., any of microprocessors, controllers, and the like) which process various computer-executable instructions to control the operation of the device. The device also includes one or more memory devices  (e.g., computer-readable storage media) that enable data storage. A memory device can be implemented as any type of memory, storage media, and\/or suitable electronic data storage.","Computing device  can also include a programming interface  that is configured to interface various applications  (e.g., networking applications) with the underlying details of a communication stack. The applications can be implemented to send and receive data via the network. The programming interface  is also configured to interface a kernel  (e.g., the operating system kernel) with networking devices , such as a network interface card, to communicate data over the network. The programming interface can be implemented as computer-executable instructions, such as a software application, and executed by the one or more processors of the computing device to implement the various embodiments described herein.","In an embodiment, the programming interface  is implemented to receive a registration request, such as from an application , to communicate data over the network . In order to communicate data over the network, the data is handled by the kernel , which is implemented to facilitate communication of the data to the networking devices  for communication over the network. The programming interface  is implemented to receive the registration request and then register a user-mode virtual memory buffer  that corresponds to an application , by registering both a user-mode virtual address and a length. Registering the user-mode virtual memory buffer can also include sending a registration identifier to the application that can be used by the application during data transfer requests.","The programming interface  is also implemented to allocate a completion queue from the user-mode virtual memory buffer . The completion queue is allocated large enough to hold the number of completion entries specified by the application  in the registration request. After allocating the completion queue, the programming interface can pin the completion queue to physical memory  and map the completion queue to a kernel-mode system address (e.g., in the virtual memory space) in the kernel .","By mapping the same region of physical memory  to both the user-mode virtual memory buffer  and to the kernel-mode system address, the programming interface  enables simultaneous access to the completion queue by the application  and by the kernel . The completion queue can receive completion notifications from a kernel-mode execution thread initiated by the kernel  via the kernel-mode system address, and enable access to the completion notifications by the application  via the user-mode virtual memory buffer. The completion queue can be implemented as a circular FIFO queue, which enables the kernel to post completions to the completion queue that can then be retrieved by the application.","The programming interface  can also register a socket that provides data requests from the application  to the kernel . In an embodiment, the programming interface registers an existing socket, such as a Winsock API. Registering the socket includes allocating a request queue from the user-mode virtual memory buffer . The request queue is allocated large enough to hold the number of request entries specified by the application. Registering the socket also includes pinning the request queue to the physical memory , and mapping the request queue to a kernel-mode system address. By mapping the same region of physical memory to both the user-mode virtual memory buffers and to the kernel-mode system address, the programming interface enables simultaneous access to the request queue by the application  and by the kernel .","The request queue can receive data from the application via the user-mode virtual memory buffer, and enables access to the data by the kernel-mode execution thread via the kernel-mode system address. The request queue can also be implemented as a circular FIFO queue, which enables the application to post requests in the request queue that can then be retrieved by the kernel. As part of the registration process, the programming interface is also implemented to identify the completion queue to the socket, such as by passing a location and a length of the completion queue to the socket.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 2","FIG. 1","FIG. 2"],"b":["200","200","110","116","120","110","116","202","120","204"]},"In this example, and in accordance with the discussion above, the programming interface  has already registered a socket that can provide data requests from the application to the kernel. For example, the programming interface can allocate a request queue  from the user-mode virtual memory buffer  and map the request queue to a corresponding request queue  in the kernel-mode virtual memory  (e.g., at a kernel-mode system address). In addition, the programming interface can allocate a completion queue  from the user-mode virtual memory buffer and map this completion queue to a corresponding completion queue  in the kernel-mode virtual memory (e.g., at a kernel-mode system address).","In an embodiment, the programming interface  is implemented to receive a request from application  for the kernel to handle data in the request queue . The request can be generated by the application by placing data in the request queue  and then identifying the request queue  to the programming interface, such as by including the registration identifier of the request queue  which was previously sent to the application by the programming interface.","The programming interface  is implemented to determine whether a kernel-mode execution thread , such as a system thread or an interrupt, is assigned to handle the request. The programming interface can issue a system call to the kernel for the kernel-mode execution thread  to handle the request. Once the kernel-mode execution thread is initiated to handle the request, the application can continuously queue requests into the request queue while the kernel-mode execution thread obtains the requests from the request queue to handle the requests. Therefore, if a kernel-mode execution thread has already been assigned to handle requests placed in the request queue, then the programming interface does not need to issue subsequent system calls because the kernel-mode execution thread is implemented to automatically handle the requests.","The kernel-mode execution thread  is implemented to handle a request by retrieving the data from the request queue  via the kernel-mode system address (e.g., in the virtual memory space). For example, as indicated by the arrows in , data placed in the request queue  by the application  is mapped to the request queue  in the kernel-mode virtual memory  where it can be retrieved and handled by the kernel-mode execution thread. After handling the data, the kernel-mode execution thread  is implemented to post a completion notification in completion queue  in the kernel-mode virtual memory . For example, the kernel-mode execution thread can post a completion notification after handling the data by processing the request and providing the request to a networking device (such as a network interface card) which facilitates communication of the data over the network.","Application  is implemented to monitor the completion queue  via the user-mode virtual memory buffer  to detect the completion notification posted by the kernel-mode execution thread. For example, as indicated by the arrows in , a completion notification placed in the completion queue  by the kernel-mode execution thread is mapped to the completion queue  in the user-mode virtual memory buffer  where it can be detected by application . The completion notification indicates to the application that the request has been handled by the kernel-mode execution thread. After detecting the completion notification, the application can then de-queue the completion notification from the completion queue and re-use the request queue  (that was just in use by the recently completed request) for an additional request. In an embodiment, the kernel-mode execution thread is implemented to send a signal directly to the application after handling the request if the application has previously requested that a signal be sent after the request is handled.","In an embodiment, the programming interface  is implemented to receive an additional request from the application  for the kernel to handle additional data in the request queue . For example, after the application detects the completion notification, the application can place additional data into the request queue. In this instance, the kernel-mode execution thread  is already assigned to handle the request, and the kernel-mode execution thread can then handle the additional request without an additional system call being issued to the kernel.","In an embodiment, the programming interface can be implemented to check on data that has been placed in the request and completion queues to avoid system-level corruption (e.g., avoid corrupting other applications or a system state). For example, note that when user-mode application code accesses the request or completion queues directly, it may have the ability to corrupt the integrity of the queues by changing the content of the queues. Accordingly, by performing checks, the programming interface ensures that a user-mode application can at most corrupt its own integrity, but can not impact the integrity of other applications or the integrity of the system.","Example methods  and  are described with reference to respective  in accordance with one or more embodiments of a programming interface for data communications. Generally, any of the services, functions, methods, procedures, components, and modules described herein can be implemented using software, firmware, hardware (e.g., fixed logic circuitry), manual processing, or any combination thereof. A software implementation represents program code that performs specified tasks when executed by a computer processor. The example method(s) may be described in the general context of computer-executable instructions, which can include software, applications, routines, programs, objects, components, data structures, procedures, modules, functions, and the like. The program code can be stored in one or more computer-readable storage media devices, both local and\/or remote to a computer processor. The methods may also be practiced in a distributed computing environment by multiple computer devices. Further, the features described herein are platform-independent and can be implemented on a variety of computing platforms having a variety of processors.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 3","FIGS. 1 and 2"],"b":["300","108"]},"At block , a user-mode virtual memory buffer that corresponds to an application is registered. For example, the programming interface  () registers a user-mode virtual memory buffer  that corresponds to an application . At block , a completion queue is allocated from the user-mode virtual memory buffer and the completion queue is pinned to physical memory. For example, the programming interface  allocates a completion queue  () from the user-mode virtual memory buffer  and pins the completion queue to physical memory .","At block , the completion queue is mapped to a kernel-mode system address in a kernel. For example, the programming interface  maps the completion queue  to a kernel-mode system address in the kernel . The completion queue can receive completion notifications from the kernel-mode execution thread  via the kernel-mode system address and enable access to the completion notifications by the application via the user-mode virtual memory buffer. At block , a socket is registered that provides data requests from the application to the kernel. For example, the programming interface  registers a socket that provides data requests from the application  to the kernel . In embodiments, registering the socket can include the features described at blocks , , and .","At block , a request queue is allocated from the user-mode virtual memory buffer and pinned to the physical memory. For example, the programming interface  allocates the request queue  from the user-mode virtual memory buffer  and pins the request queue to the physical memory . At block , the request queue is mapped to a kernel-mode system address in the kernel. For example, the programming interface  maps the request queue  to a kernel-mode system address in the kernel . The request queue is implemented to receive data from the application via the user-mode virtual memory buffer and to enable access to the data by the kernel-mode execution thread via the kernel-mode system address. At block , the completion queue is identified to the socket. For example, the programming interface  identifies the completion queue  to the socket.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 4","FIGS. 1 and 2","FIG. 4","FIG. 3"],"b":["400","108","314"]},"At block , a request is received from an application for the kernel to handle data in a request queue. For example, the programming interface  () receives a request from an application  for the kernel  to handle data in the request queue. The request can include a registration identifier. At block , a system call is issued to the kernel for the kernel-mode execution thread to handle the request. For example, the programming interface  issues a system call to the kernel  for the kernel-mode execution thread  to handle the request.","At block , a completion notification is received in the completion queue. For example, a completion notification can be posted in the completion queue  by the kernel-mode execution thread  via the kernel-mode virtual memory buffer  when the request from the application is handled.","At block , an additional request is received from the application for the kernel to handle additional data in the request queue, and at block , the kernel-mode execution thread handles the additional request without a system call being issued. For example, the programming interface  receives an additional request from the application  for the kernel  to handle additional data in the request queue , and the kernel-mode execution thread  is assigned to handle the additional request. The kernel-mode execution thread is implemented to handle additional requests without an additional system call being issued to the kernel.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 5","FIGS. 1-4"],"b":"500"},"The device  includes communication devices  that enable wired and\/or wireless communication of device data , such as received data, data that is being received, data scheduled for broadcast, data packets of the data, etc. The device data or other device content can include configuration settings of the device, media content stored on the device, and\/or information associated with a user of the device. Media content stored on the device can include any type of audio, video, and\/or image data. The device includes one or more data inputs  via which any type of data, media content, and\/or inputs can be received, such as user-selectable inputs, messages, communications, music, television content, recorded video content, and any other type of audio, video, and\/or image data received from any content and\/or data source.","The device  also includes communication interfaces , such as any one or more of a serial, parallel, network, or wireless interface. The communication interfaces provide a connection and\/or communication links between the device and a network by which other electronic, computing, and communication devices communicate data with the device.","The device  includes one or more processors  (e.g., any of microprocessors, controllers, and the like) which process various computer-executable instructions to control the operation of the device. Alternatively or in addition, the device can be implemented with any one or combination of software, hardware, firmware, or fixed logic circuitry that is implemented in connection with processing and control circuits which are generally identified at . Although not shown, the device can include a system bus or data transfer system that couples the various components within the device. A system bus can include any one or combination of different bus structures, such as a memory bus or memory controller, a peripheral bus, a universal serial bus, and\/or a processor or local bus that utilizes any of a variety of bus architectures.","The device  also includes one or more memory devices (e.g., computer-readable storage media)  that enable data storage, such as random access memory (RAM), non-volatile memory (e.g., read-only memory (ROM), flash memory, etc.), and a disk storage device. A disk storage device may be implemented as any type of magnetic or optical storage device, such as a hard disk drive, a recordable and\/or rewriteable disc, and the like. The device may also include a mass storage media device.","Computer readable media can be any available medium or media that is accessed by a computing device. By way of example, and not limitation, computer readable media may comprise storage media and communication media. Storage media include volatile and non-volatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer-readable instructions, data structures, program modules, or other data. Storage media include, but are not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store information and which can be accessed by a computer.","Communication media typically embody computer-readable instructions, data structures, program modules, or other data in a modulated data signal, such as carrier wave or other transport mechanism. Communication media also include any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media include wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared, and other wireless media.","A memory device  provides data storage mechanisms to store the device data , other types of information and\/or data, and various device applications . For example, an operating system  can be maintained as a software application with a memory device and executed on the processors. The device applications may also include a device manager, such as any form of a control application, software application, signal processing and control module, code that is native to a particular device, a hardware abstraction layer for a particular device, and so on. In this example, the device applications  include a programming interface  that is shown as a software module and\/or computer application. Alternatively or in addition, the programming interface can be implemented as hardware, software, firmware, fixed logic, or any combination thereof.","The device  also includes an audio and\/or video processing system  that generates audio data for an audio system  and\/or generates display data for a display system . The audio system and\/or the display system may include any devices that process, display, and\/or otherwise render audio, video, display, and\/or image data. Display data and audio signals can be communicated to an audio device and\/or to a display device via an RF (radio frequency) link, S-video link, composite video link, component video link, DVI (digital video interface), analog audio connection, or other similar communication link. In implementations, the audio system and\/or the display system are external components to the device. Alternatively, the audio system and\/or the display system are integrated components of the example device.","Although embodiments of a programming interface for data communications have been described in language specific to features and\/or methods, the subject of the appended claims is not necessarily limited to the specific features or methods described. Rather, the specific features and methods are disclosed as example implementations of a programming interface for data communications."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of a programming interface for data communications are described with reference to the following Figures. The same numbers are used throughout to reference like features and components that are shown in the Figures:",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
