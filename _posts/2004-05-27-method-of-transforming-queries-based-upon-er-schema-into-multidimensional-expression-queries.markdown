---
title: Method of transforming queries based upon E/R schema into multi-dimensional expression queries
abstract: A method of transforming queries based upon an entity/relationship schema into multi-dimensional expression queries is provided. The method comprises matching an object referenced in an entity/relationship schema based report specification to a corresponding object in the entity/relationship schema, the corresponding object adorned with associated multidimensional metadata; adding the associated multi-dimensional metadata to the object referenced in the entity/relationship schema based report specification; translating the entity/relationship schema based report specification into a multi-dimensional expression query; and retrieving directly all data required to populate a report output of the entity/relationship schema report specification.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07945575&OS=07945575&RS=07945575
owner: International Business Machines Corporation
number: 07945575
owner_city: Armonk
owner_country: US
publication_date: 20040527
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF INVENTION","Example"],"p":["The invention relates to a system and method of transforming queries based upon E\/R schema into multi-dimensional expression queries.","Data warehouses store data in one of two primary locations\u2014relational databases and multi-dimensional, on-line analytical processing (OLAP) data sources. Typically, reporting tools that generate tabular\/grouped list, or cross-tabulated reports work with relational databases, or extract data from an OLAP data source and process the data locally. This sort of product architecture is imposed due to the semantic differences between the relational and OLAP data models and the query languages used to access each type of data source. Whereas the relational query language, SQL, is well suited to producing tabular and grouped-list reports, multi-dimensional query languages are more suited to producing cross-tabulated reports for the purpose of analysis and exploration.","Processing OLAP data locally to provide the data for a particular report introduces several less than ideal side effects, including:\n\n","Authoring tabular and cross-tabulated reports based upon OLAP (dimensional) metadata is problematic as well since it introduces concepts not apparent in more common tabular\/relational data sources. These concepts include dimensions, hierarchies, levels, properties, and measures.","From the end user's point of view, it is desirable to deal with the more familiar entity\/relationship (or the relational) concepts of entities (tables), attributes (columns), and relationships loins) instead of the more complex dimensional constructs. The entity\/relationship model provides a simpler and easier to understand paradigm, as well as consistency in representation regardless of the type of underlying data source.","It is an object of the present invention to solve one or more of the problems described above.","In accordance with an embodiment of the present invention, there is provided a system for transforming queries based upon entity\/relationship schema into multi-dimensional expression queries. The system comprises a binding module for matching an object reference in a report specification to a corresponding entity\/relationship schema object and adding associated multi-dimensional metadata information from the entity\/relationship schema to a corresponding report specification object, and a query translation module for translating the report specification into a single multi-dimensional query.","In accordance with another embodiment of the present invention, there is provided a method of transforming queries based upon entity\/relationship schema into multi-dimensional expression queries. The method comprises the steps of analyzing a query based upon an entity\/relationship schema, generating translations of the entity\/relationship schema to dimensional expressions, and generating a multi-dimensional query based upon the translations.","In accordance with another embodiment of the present invention, there is provided a computer data signal embodied in a carrier wave and representing sequences of instructions which, when executed by a processor, cause the processor to perform a method of transforming queries based upon entity\/relationship schema into multi-dimensional expression queries. The method comprises the steps of analyzing a query based upon an entity\/relationship schema, generating translations of the entity\/relationship schema to dimensional expressions, and generating a multi-dimensional query based upon the translations.","In accordance with another embodiment of the present invention, there is provided a computer-readable medium having computer readable code embodied therein for use in the execution in a computer of a method of transforming queries based upon entity\/relationship schema into multi-dimensional expression queries. The method comprises the steps of analyzing a query based upon an entity\/relationship schema, generating translations of the entity\/relationship schema to dimensional expressions, and generating a multi-dimensional query based upon the translations.","In accordance with another embodiment of the present invention, there is provided a system for transforming queries based upon entity\/relationship schema into multi-dimensional expression queries. The system comprises a binding module for matching an object reference in a report specification to a corresponding entity\/relationship schema object and adding associated multi-dimensional metadata information from the entity\/relationship schema to a corresponding report specification object, and a query translation module for translating the report specification into a single multi-dimensional query.",{"@attributes":{"id":"p-0028","num":"0031"},"figref":"FIG. 1","b":["10","11","12","11","12","12","11","14","13","13","15"]},"One embodiment of the present invention provides a manner in which tabular and cross-tabulated reports may be executed using an online analytical programming (OLAP) query language using an entity\/relationship (E\/R) representation of the OLAP metadata without the necessity of local processing, thus obtaining the benefit of the OLAP aggregation engine, the data source's complex aggregation rules, and minimal data transfer from the OLAP data source to the client reporting application. In addition, a mechanism may be provided by which the results of the OLAP query are processed such that their format and contents accurately reflect the semantics of the original report specification.",{"@attributes":{"id":"p-0030","num":"0033"},"figref":"FIG. 2","b":["20","20","21","22","23","24","25","22","21","24","23","22","21","24","25"]},{"@attributes":{"id":"p-0031","num":"0034"},"figref":"FIG. 3","b":["30","31","32","33","34"]},"Tabular and cross-tabulated reports have characteristics that are independent of the manner in which they are produced and are described below.","Layout.\n\n","Sorting.\n\n","Calculations.\n\n","Filters.\n\n","Grouping.\n\n","Association.\n\n","Dimensionality.\n\n","Aggregation.\n\n","Summary values.\n\n","Set operations.\n\n","These constructs are then applied in combinations to the entities and attributes in an entity\/relationship (E\/R) model  to produce a report (query) specification.","The multi-dimensional constructs can be mapped to the E\/R model  such that an E\/R schema derived from an OLAP data source may act as the basis for the production of tabular and cross-tabulated reports. One example of such a mapping is defined as follows and presents the OLAP metadata as a star schema. Though other mappings are possible, all mappings can be shown to be equivalent representations of what is described below.",{"@attributes":{"id":"p-0045","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Dimensional","E\/R",{}]},{"entry":["Construct","Construct","Notes"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Cube","Schema",{}]},{"entry":["Dimension","<None>","Represents a logical grouping of entities."]},{"entry":["Measure","Entity","One fact entity for each set of identically"]},{"entry":["Dimension",{},"scoped measures."]},{"entry":["Hierarchy","Entity"]},{"entry":["Level","Attribute"]},{"entry":["Property","Attribute","Associated with a level attribute."]},{"entry":["Measure","Attribute","Attribute in entity representing the fact"]},{"entry":["(member of the",{},"table (entity) in a star schema."]},{"entry":"measure"},{"entry":"dimension)"},{"entry":["<None>","Relationship","Represents the manner in which the fact"]},{"entry":[{},{},"entity is related to the other entities"]},{"entry":[{},{},"(dimensional hierarchies) in the schema."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"An E\/R schema derived from an OLAP data source associates with the objects in the schema additional physical metadata providing the mapping from logical E\/R objects to their corresponding objects in the OLAP data source. Some of this information is required, while other pieces of it are optional and are applicable for query optimization (discussed later), as indicated below.",{"@attributes":{"id":"p-0047","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["E\/R Construct","Associated OLAP Metadata","Mandatory?"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Schema","Cube unique name","Yes."]},{"entry":["Entity (Non-Fact)","Dimension\/Hierarchy","Yes."]},{"entry":[{},"unique name"]},{"entry":[{},"Balanced hierarchy?","No."]},{"entry":[{},"Ragged hierarchy?","No."]},{"entry":[{},"Multiple members","No."]},{"entry":[{},"at root level?"]},{"entry":["Entity (Fact)","Fact table indication","Yes."]},{"entry":["Attribute (Level,","Level identifier indication","Yes."]},{"entry":["Non-Fact)","Level number","Yes."]},{"entry":[{},"Level unique name","Yes."]},{"entry":["Attribute (Property,","Level number","Yes."]},{"entry":["Non-Fact)","Property unique name","Yes."]},{"entry":["Attribute (Fact)","Aggregator","Yes."]},{"entry":[{},"Semi-aggregator","Yes."]},{"entry":[{},"Measure unique name","Yes."]},{"entry":[{},"Data type","Yes."]},{"entry":[{},"Parent unique name","Yes, if measure"]},{"entry":[{},{},"dimension contains"]},{"entry":[{},{},"hierarchies."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Once a report has been authored using the E\/R schema as its basis, the report specification is converted, using the same E\/R schema, to produce a single OLAP (MDX) query containing all of the data associated from which the data to satisfy the original report may be obtained.","Note that though MDX is only one of several methods available for querying multi-dimensional data stores, it is the de facto standard for such operations. Several vendors support their own API, but also provide support for MDX. In those cases where a vendor-supplied MDX interface is not available, it is possible for an MDX interface to be constructed that in translates an MDX query into the native query interface. Hence, using MDX as the basis for specifying OLAP query semantics is applicable to all available OLAP data sources.","One embodiment of the invention provides a system of converting basic business report specifications into a single OLAP (MDX) query that can be issued to an underlying OLAP data source, as well as processing the results of the MDX query to product the results in a format consistent with the original report specification.",{"@attributes":{"id":"p-0051","num":"0064"},"figref":"FIG. 4","ul":{"@attributes":{"id":"ul0023","list-style":"none"},"li":["1. Translation Module \n    \n    ","2. Execution Module \n    \n    ","3. Result Processing Module \n    \n    "]}},"The report specification conversion system  may be implemented as a stand-alone module or system that can be added to a reporting application on the application server , the report server , the query engine , or the database server .","One aspect of the report specification conversion system  provides a multidimensional query tool (or system) for converting queries in one type of data model schema into another type of data model schema. One example of a multidimensional query tool is the translation module  that translates a report query based upon an E\/R schema into a multidimensional data query that can be run on an OLAP engine. The multidimensional query tool may be implemented as a stand-alone module or system that can be added to the application server , the report server , the query engine , or the database server . Alternatively, the multidimensional query tool may be implemented as a module of the report specification conversion system .",{"@attributes":{"id":"p-0054","num":"0075"},"figref":"FIG. 5","b":["41","41"],"ul":{"@attributes":{"id":"ul0027","list-style":"none"},"li":["1. Binding Module \n    \n    ","2. Error Detection Module \n    \n    ","3. Query Translation Module \n    \n    ","4. Result processing information generation module \n    \n    "]}},{"@attributes":{"id":"p-0055","num":"0084"},"figref":"FIG. 6","b":["60","41","60","61","61","62","62","63"]},"Other steps may be added to the method () including determining if there are any interactions of report constructs and multi-dimensional metadata that preclude the generation of a single MDX query, producing a dataset that can be used to produce a result set consistent with the original report specification, and generating a collection of information used to translate the output of the MDX query into the result set.","Further description of concepts and examples of algorithms or methods used by the translation module  are described below.","Binding","A report specification  is comprised of a collection of report constructs applied to objects from a metadata schema, or to report constructs which in turn have been applied, in the end, to one or more metadata schema objects. The binding module  of the translation module  examines the report specification  and augments each metadata schema object with its corresponding multi-dimensional metadata in the E\/R schema , as described earlier. This bound version of the report specification  forms the basis for all further translations and transformations performed by the translation module .","The report specification  may be represented in a different manner within the translation module  than as it was originally specified, but this does not affect the methods or algorithms described below.","Error Detection","The MDX query language imposes certain restrictions upon the semantics that can be expressed. Since these restrictions cannot be expressed in an E\/R schema , it is possible to author a report against an E\/R schema  based upon a multi-dimensional data source that exceed the capabilities of the MDX query language. Aside from errors that are independent of the underlying data source, the error detection module  rejects a report prior to query translation if it detects any of the following conditions:\n\n","Dimension\/Hierarchy Entity to Fact Entity Relationships","Each relationship between a dimension\/hierarchy entity and a fact entity represents either an inner or outer join relationship. This relationship is part of the E\/R schema  definition, though it may be changed within a report specification , if so desired. Regardless, this relationship is translated into a corresponding MDX construct.","Inner join relationships may be replicated in MDX by placing a dimension on a separate edge of an MDX query and applying null suppression (NON EMPTY clause) to the edge. The absence of the NON EMPTY clause equates to an outer join between a dimension and fact entity.","In the algorithm presented, all non-fact dimensions are nested along a single edge of an MDX query and all facts appear on a separate edge, thus all dimension-to-fact relationships are either inner or outer joins due to the absence or presence of the NON EMPTY clause being applied to the non-fact dimension edge of the MDX query.","Single Entity No Filters, No Sorting, All Attributes","In this scenario, all of the attributes of single non-fact entity are projected in a tabular report. No other semantics are applied to the report. In addition, in terms of the underlying OLAP metadata model, there are no \u201cgaps\u201d in the hierarchy associated with the entity. For example, in a geography dimension with the levels country, state, and city, a gap would exist if the state level were not represented in the report.","In such a report, there are no measures (facts). In MDX terms, this means that no measure \u201cslicer\u201d needs to be specified since it is irrelevant as to which values are returned in the cross-tabulated result set since they are completely ignored in this particular instance. The single hierarchy that is referenced by the report is projected along a single edge of the query. It is the collection of members (and their associated property values) that are converted by a post-processing method into a tabular result set.","To obtain the necessary information to satisfy the tabular report, an MDX expression is generated that, in this case, obtains the collection of members from all levels referenced by the report and in addition projects all member properties also referenced by attributes in the report.","The MDX expression would be of the form",{"@attributes":{"id":"p-0072","num":"0110"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT"]},{"entry":[{},"HIERARCHIZE( UNION( [LEVEL01].MEMBERS,"]},{"entry":[{},"[LEVEL02].MEMBERS ) )"]},{"entry":[{},"ON AXIS(0)"]},{"entry":[{},"FROM [CUBE]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The HIERARCHIZE operator is ensures that parent\/child relationships are represented in the axis rowset so that the post-processing method has the information it requires to generate the final tabular report. Note that the LEVEL.MEMBERS construct is the equivalent of projecting a column from a relational table.","In the case that a hierarchy contains level properties that are part of an entity's definition, those properties are projected in the MDX statement:",{"@attributes":{"id":"p-0075","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT"]},{"entry":[{},"HIERARCHIZE( UNION( UNION( [LEVEL01].MEMBERS ),"]},{"entry":[{},"[LEVEL02].MEMBERS))"]},{"entry":[{},"DIMENSION PROPERTIES [MyDimension].[Property #1],"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"[MyDimension].[Property #2]"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ON AXIS(0)"]},{"entry":[{},"FROM [CUBE]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Single Entity, with Filters, No Sorting, All Attributes","In this scenario, a filter is applied to one or more of the attributes.","In the case, a single filter is applied to a single attribute. If the filter is applied to an attribute at level N in a hierarchy with X levels, the method of generating the equivalent MDX query comprises the following steps as shown in :\n\n","In MDX terms, this appears as follows:",{"@attributes":{"id":"p-0080","num":"0122"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"WITH SET [FilterSet] as"},{"entry":"\u2018FILTER( [MyDimension].[LEVEL N].MEMBERS, <some filter expression>)\u2019"},{"entry":"SELECT"},{"entry":"GENERATE ( [FilterSet],"},{"entry":"\u2003UNION (UNION (..."},{"entry":"\u2003\u2003{ANCESTOR( [MyDimension].CURRENTMEMBER, [LEVEL 0] )}, ..."},{"entry":"\u2003\u2003{ANCESTOR( \u2003[MyDimension].CURRENTMEMBER, [LEVEL N \u2212 1] )},"},{"entry":"\u2003\u2003{[MyDimension].CURRENTMEMBER},"},{"entry":"\u2003\u2003\u2002DESCENDANTS([MyDimension].CURRENTMEMBER, [LEVEL N + 1], SELF),..."},{"entry":"\u2003\u2003\u2002DESCENDANTS ([MyDimension].CURRENTMEMBER, [LEVEL X], SELF)"},{"entry":") ) ...) ON AXIS(0)"},{"entry":"FROM [MyCube]"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"A filter expression containing AND\/OR logic upon attributes (key and property items) from a single level in a hierarchy can be expressed as either a single FILTER expression, or as a series of nested FILTER expressions.","All filters are correlated (based on AND\/OR logic) at the lowest filtered level. The more general algorithm described earlier in this section is then applied as if only the filter at the lowest level was applied to the query.","In a hierarchy with X levels and a filter expression containing the AND'ing of two filters, one to level N and the other to level S (where N is a higher level than S), the generated MDX would appear as follows:",{"@attributes":{"id":"p-0084","num":"0126"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"WITH"},{"entry":"SET [Filter Set N] as \u2018<filter expression for level N>\u2019"},{"entry":"SET [Filter N Descendants at Level S] as"},{"entry":"\u2018GENERATE( Filter Set N], DESCENDANTS( [MyDimension].CURRENTMEMBER,"},{"entry":"[Level S], SELF))\u2019"},{"entry":"SET [Filter Set S] as \u2018INTERSECT(<filter expression for level S>,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003[Filter N Descendants at Level S])\u2019"},{"entry":"SELECT"},{"entry":"GENERATE( [Filter Set S],"},{"entry":"\u2003UNION("},{"entry":"\u2003\u2003{ANCESTOR( [MyDimension].CURRENTMEMBER, [LEVEL 0] )}, ..."},{"entry":"\u2003\u2003{ANCESTOR( [MyDimension].CURRENTMEMBER, [LEVEL S \u2212 1] )},"},{"entry":"\u2003\u2003{[MyDimension].CURRENTMEMBER},"},{"entry":"\u2003\u2003\u2002DESCENDANTS([MyDimension].CURRENTMEMBER, [LEVEL S + 1], SELF),..."},{"entry":"\u2003\u2003\u2002DESCENDANTS ([MyDimension].CURRENTMEMBER, [LEVEL X], SELF)"},{"entry":") ) ON AXIS(0)"},{"entry":"FROM [MyCube]"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"An OR expression is handled in a fashion similar to an AND expression, except that sets of the various filtered sets are UNION'ed together instead of INTERSECT'ed.","Single Entity, No Filters, No Sorting, Not All Attributes","This categorization of reports may result in the following (possibly overlapping) scenarios:\n\n","In the first scenario, the post-processing method does not include the member unique name as a column in the tabular result set.","In the second scenario, the generated OLAP (MDX) query only refers to the dimension properties specified in the query. The post-processing method is not required to perform any different processing than what is described above.","In the third scenario, the generated OLAP (MDX) query may refer to the missing level(s) in terms of filters applied to the result set (as described below), but none of the members from those levels are projected along the edge of the OLAP (MDX) query. For reasons described below, different method steps are used in the presence of \u201cgaps\u201d in the hierarchy (assuming the absence of any filters\u2014their presence would be similar to that above, but is ignored since it would complicate the description of the current method):\n\n","The OLAP (MDX) would appear as follows:",{"@attributes":{"id":"p-0092","num":"0140"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"WITH"},{"entry":"SET [Set N] as \u2018[LEVEL N].MEMBERS\u2019"},{"entry":"SET [Set N + 1] as"},{"entry":"\u2018GENERATE ( [Set N], DESCENDANTS ( [MyDimension].CURRENTMEMBER, [Level"},{"entry":"N + 1], SELF)\u2019..."},{"entry":"SET [Set N + X] AS"},{"entry":"\u2018GENERATE( [Set N], DESCENDANTS( [MyDimension].CURRENTMEMBER, [Level"},{"entry":"N + X], SELF)\u2019"},{"entry":"SELECT"},{"entry":"HIERARCHIZE( UNION( [Set N], UNION( [Set N + 1], ... UNION( [Set N + X \u2212"},{"entry":"1], [Set N + X]))))"},{"entry":"ON AXIS(0)"},{"entry":"FROM [MyCube]"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Single Entity, No Filters, Sorting, All Attributes","There are different scenarios for sorting attributes of a single entity:\n\n","In all cases, the basic rule is the same\u2014set generation begins with the first sorted level.","In the first scenario, the ORDER operator is applied to the members of the highest level. For each member in this sorted set of members, the hierarchized set of the descendants at the other levels in the report is generated. The generated OLAP (MDX) query would appear as follows:",{"@attributes":{"id":"p-0097","num":"0149"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"WITH SET"]},{"entry":[{},"[Ordered Level 0] as"]},{"entry":[{},"\u2018ORDER( [Level 0].MEMBERS, <some sort expression>)\u2019"]},{"entry":[{},"SELECT"]},{"entry":[{},"GENERATE( [Ordered Level 0],"]},{"entry":[{},"UNION( {[MyDimension].CURRENTMEMBER},"]},{"entry":[{},"HIERARCHIZE("]},{"entry":[{},"UNION("]},{"entry":[{},"DESCENDANTS([MyDimension].CURRENTMEMBER,"]},{"entry":[{},"[Level 1], SELF),..."]},{"entry":[{},"DESCENDANTS([MyDimension].CURRENTMEMBER,"]},{"entry":[{},"[Level N], SELF)))"]},{"entry":[{},")"]},{"entry":[{},"ON AXIS(0)"]},{"entry":[{},"FROM [MyCube]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In the third scenario (sort applied at a non-root level in the hierarchy), the sorted set of members at the specified level is created and the set of ancestors pre-pended to each member from this set and each member followed by its descendants at the lower levels of the hierarchy in the report. The OLAP (MDX) query is as follows:",{"@attributes":{"id":"p-0099","num":"0151"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"WITH SET"},{"entry":"[Ordered Level N] as"},{"entry":"\u2018ORDER( [Level N].MEMBERS, <some sort expression>)\u2019"},{"entry":"SELECT"},{"entry":"GENERATE( [Ordered Level N],"},{"entry":"UNION("},{"entry":"{ANCESTOR( [MyDimension].CURRENTMEMBER, [Level 0], SELF)},"},{"entry":"..."},{"entry":"{ANCESTOR( [MyDimension].CURRENTMEMBER,"},{"entry":"[Level N \u2212 1], SELF)},"},{"entry":"{[MyDimension].CURRENTMEMBER]}),"},{"entry":"HIERARCHIZE (UNION("},{"entry":"DESCENDANTS([MyDimension].CURRENTMEMBER,"},{"entry":"[Level N + 1], SELF),..."},{"entry":"DESCENDANTS([MyDimension].CURRENTMEMBER,"},{"entry":"[Level X], SELF)))"},{"entry":"))"},{"entry":"ON AXIS(0)"},{"entry":"FROM [MyCube]"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Again, there is no special rule required in the post-processing method to deal with the output of the MDX query.","In the final scenario (sort applied to two or more levels), the sorts are applied in a top-down order based upon the level in the hierarchy upon which the sorts are applied. For the highest level at which a sort is applied, any ancestors from higher levels are pre-pended to the each member from the sorted level. If there are intervening, unsorted levels between two sorted levels, the intermediate level's members are appended to their parent in the sorted level. At a sorted level that is within another, higher level sort, the lower level descendants at the second sorted level are sorted and place after the member from the higher level.","In the following example, the hierarchy is continent, country, state, and city. A sort is applied to the country and state levels.",{"@attributes":{"id":"p-0103","num":"0155"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"SELECT"},{"entry":"\u2003GENERATE("},{"entry":"\u2003\u2003ORDER([Geography].[Country].MEMBERS,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<some sort expression>, BASC),"},{"entry":"\u2003\u2003\u2003UNION("},{"entry":"\u2003\u2003\u2003\u2003{ANCESTOR([Geography].CURRENTMEMBER,"},{"entry":"[Geography].[Continent]},"},{"entry":"\u2003\u2003\u2003\u2002{[Geography].CURRENTMEMBER},"},{"entry":"\u2003\u2003\u2003\u2003GENERATE("},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002ORDER("},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003DESCENDANTS( [Geography].CURRENTMEMBER,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003[Geography].[State]),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<some sort expression>, BASC),"},{"entry":"\u2003\u2003\u2003\u2003\u2003UNION( {[Geography].CURRENTMEMBER},"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002DESCENDANTS( [Geography].CURRENTMEMBER,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002[Geography].[City]) ) ) )"},{"entry":")"},{"entry":"ON AXIS(0)"},{"entry":"FROM [MyCube]"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Single Entity, Filters, Sorting, All Attributes","This scenario merges the MDX query generation rules above for filters and sorting. The sorting rule prevails, but the filter rule is applied to the first sorted level instead of the lowest filtered level. In addition, when descendant sets are computed (based on the sorting rule), they are intersected with the members of the current level based on the remaining members at all lower levels.","Assuming the previous example on sorting with an additional filter on City level, the MDX is as follows:",{"@attributes":{"id":"p-0107","num":"0159"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"SET S3 AS \u2018FILTER( [Geography].[City].MEMBERS,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<filter expression for [City]"},{"entry":"level> )\u2019"},{"entry":"SET S2 AS \u2018GENERATE( S3, {ANCESTOR( [Geography].CURRENTMEMBER,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003[Geography].[State]})\u2019"},{"entry":"SET S1 AS \u2018GENERATE( S3, {ANCESTOR( [Geography].CURRENTMEMBER,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002[Geography].[Country]})\u2019"},{"entry":"SELECT"},{"entry":"\u2003GENERATE("},{"entry":"\u2003\u2003ORDER( S1 , <some sort expression>, BASC),"},{"entry":"\u2003\u2003\u2003UNION("},{"entry":"\u2003\u2003\u2003{ANCESTOR([Geography].CURRENTMEMBER,"},{"entry":"[Geography].[Continent]},"},{"entry":"\u2003\u2003\u2003{[Geography].CURRENTMEMBER},"},{"entry":"\u2003\u2003\u2003\u2003GENERATE("},{"entry":"\u2003\u2003\u2003\u2003\u2003ORDER("},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003INTERSECT(DESCENDANTS( [Geography].CURRENTMEMBER,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003[Geography].[State]) , S2),"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002<some sort expression>, BASC),"},{"entry":"\u2003\u2003\u2003\u2003\u2002UNION( {[Geography].CURRENTMEMBER},"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002\u2009INTERSECT(DESCENDANTS( [Geography].CURRENTMEMBER,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2002[Geography].[City]), S3 ) ) )"},{"entry":")"},{"entry":"ON AXIS(0)"},{"entry":"FROM [MyCube]"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Multiple Entities, No Facts","In a query that references multiple dimension entities, but no facts from the \u201cpseudo\u201d fact table, the equivalent relational query semantics would be to implicitly join the dimension tables via the fact table over an arbitrary fact.","In order to represent these semantics, each entity (dimension\/hierarchy) is treated as a separate entity and MDX generated as described above. The resulting MDX set expressions are then crossjoin'ed on a single axis. The NON EMPTY clause is applied to the edge to remove all intersections from dimensions for which there is no corresponding fact value.","The OLAP query (MDX) generation method does not account for sort specifications in which the sort applied to multiple levels in a single dimension is interspersed with sorts to attributes from other dimensions.","One or More Dimension Entities, One or More Facts, No Summarization, No Grouping, No Sorting","This type of report is a simple list report that provides the values of a fact corresponding to the lowest level projected from the dimension contained in the report. In this simple case, an MDX query is generated that projects the dimension members along a single edge (as described above) and the single measure along a second edge. The fact values are implicitly rolled up along all other dimensions in cube in reference to their default member (typically, the \u201cALL\u201d member). Ideally, the leaf-level members from all other dimensions should be crossjoin'ed along another edge to ensure that the lowest-level values are obtained from the cube for the attributes in the report.","In the presence of multiple facts, all facts are projected along a single edge.","In the following scenarios, it is assumed that they all address the case of one or more dimensions.","One or More Facts, No Summarization, No Grouping, Sorting","In a report containing one or more facts, the presence of a sort that is applied only to the dimensional attributes is handled as described above since the sort is contained entirely in the MDX set expression involving the members.","If a sort is applied to a fact, this sort must also be applied to the dimensional set expression\u2014there is no way in MDX to sort the fact values. Consequently, the sort expression is the fact upon which the sort is applied in the business\/tabular report.","If a sort is applied to level of a hierarchy and to a fact, then the MDX generation method behaves as follows (as shows in ):\n\n","If a sort is applied to multiple facts, then the innermost sort is applied as described above. All subsequent sorts are applied to the results of the previous sort in an innermost to outermost order. Because of the MDX specification, the results are equivalent to the multiple sort specifications in a tabular report.","That is, a business report specification of","SORT([FACT #1]), SORT([FACT #2]), . . . SORT([FACT #N])","is equivalent to the MDX expression",{"@attributes":{"id":"p-0123","num":"0178"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ORDER("]},{"entry":[{},"\u2003ORDER("]},{"entry":[{},"\u2003\u2003ORDER( <original set>,"]},{"entry":[{},"\u2003\u2003\u2003\u2003[FACT #N]"]},{"entry":[{},"\u2003\u2003),"]},{"entry":[{},"\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2002[FACT #2]"]},{"entry":[{},"\u2003),"]},{"entry":[{},"\u2003[FACT #1]"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"One or More Facts, Summarization, No Grouping, No Sorting","A summarized tabular report with facts is equivalent to the same report without summarization (grouping on all non-fact columns) due to the manner in which the non-summarized report is generated as MDX. Effectively, both are summarized reports and there is no actual \u201cdetail\u201d report.","One or More Facts, No Summarization, Grouping, No Sorting, No Filters","Grouping can be performed in the absence of facts, but it is their presence that grouped reports are most often found. Grouping an attribute in a client reporting tool typically causes the following behavior in a report:\n\n","In the absence of filters, all of the rollup values contained in an OLAP cube are consisent with the detail rows portrayed at lower levels in a hierarchy. The OLAP (MDX) query generation method requires that:\n\n","With these restrictions, the MDX generation is unaffected, but the post-processing code must be informed of which attributes are grouped in the report specification and produced likewise groupings of values. The stack-based approach is still used, but instead of producing complete rows for each unique combination, sub-sets are produced for each complete row. As well, the summarization value associated with each grouped attribute is included in the output to the client application.","The order of grouped items against an OLAP data source is the \u201cnatural\u201d order of the items in the data source.","One or More Facts, No Summarization, Grouping, Sorting, No Filters","Sorts may be applied to attributes to the left and\/or right of grouped attributes. In either case, sorts are applied as in tabular, non-grouped reports. The difference again is that the post-processing method must apply the same logic as described above for providing grouped list result set information.","One or More Facts, No Summarization, Grouping, Sorting, Filters","Pre-Filter Aggregation","Aggregated (rolled up) values in an OLAP cube (typically) represent pre-filtered aggregated values; in some cases, specific calculations may be applied to determine the aggregate value of a particular cell or group of cells within an OLAP cube.","When a filter is applied to a report, it may be applied before or after aggregation. To this point, the assumption has been that all filters have been applied post-aggregation (equivalently, that the aggregation has been applied pre-filter). This requires no specific MDX generation.","Post-Filter Aggregation","On the other hand, the specification of a pre-aggregation filter implies that one or more rows of fact values must be filtered prior to the calculation of any report aggregate values. This requires that the OLAP (MDX) query generation method create the necessary calculated members to calculate these values.","The indication that a filter is to be applied prior the calculation of aggregate values only imposes special MDX generation rules if the filter is applied to a level of a hierarchy for which an ancestor level is also projected in the report or referenced by an expression.","The general method of calculating post-filter aggregation values () comprises the following steps (as shown in ):\n\n","In this example, assume a country\/state\/city geography dimension that is filtered (pre-aggregation) to only include the top 5 cities by sales and reports on the unit sales based on country\/state\/city.",{"@attributes":{"id":"p-0142","num":"0207"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"WITH"},{"entry":"SET S0 AS"},{"entry":"\u2018TOPCOUNT( [Geography].[City].MEMBERS, 5, [Sales] )\u2019"},{"entry":"SET S1 AS"},{"entry":"\u2018GENERATE( S0, {ANCESTOR( [Geography].CURRENTMEMBER,"},{"entry":"[Geography].[State])})\u2019"},{"entry":"SET S2 AS"},{"entry":"\u2018GENERATE( S0, {ANCESTOR( [Geography].CURRENTMEMBER,"},{"entry":"[Geography].[Country])})\u2019"},{"entry":"MEMBER [Measures].[Unit Sales Post-Filter] AS"},{"entry":"\u2018IIF([Geography].CURRENTMEMBER.level.ordinal<3,"},{"entry":"AGGREGATE("},{"entry":"\u2003INTERSECT("},{"entry":"\u2003\u2003DESCENDANTS( [Geography].CURRENTMEMBER,"},{"entry":"\u2003\u2003\u2003\u2003\u2003[Geography].[City]"},{"entry":"\u2003\u2003),"},{"entry":"\u2003\u2003S0"},{"entry":"\u2003),"},{"entry":"\u2003[Unit Sales]"},{"entry":"), \u2003[Unit Sales] )\u2019"},{"entry":"SELECT"},{"entry":"{[Measures].[Unit Sales Post-Filter]} ON AXIS(0),"},{"entry":"GENERATE("},{"entry":"\u2003ORDER( S2, <order criteria for Country>),"},{"entry":"\u2003UNION("},{"entry":"\u2003\u2003{[Geography].CURRENTMEMBER},"},{"entry":"\u2003\u2003GENERATE("},{"entry":"\u2003\u2003\u2003ORDER( INTERSECT("},{"entry":"\u2003\u2003\u2003\u2003DESCENDANTS("},{"entry":"\u2003\u2003\u2003\u2003\u2003[Geography].CURRENTMEMBER,"},{"entry":"\u2003\u2003\u2003\u2003\u2003[Geography].[State]"},{"entry":"\u2003\u2003\u2003\u2003),"},{"entry":"\u2003\u2003\u2003\u2003S1"},{"entry":"\u2003\u2003\u2003), <order criteria for State> ),"},{"entry":"\u2003\u2003\u2003UNION("},{"entry":"\u2003\u2003\u2003\u2003{[Geography].CURRENTMEMBER},"},{"entry":"\u2003\u2003\u2003\u2003INTERSECT("},{"entry":"\u2003\u2003\u2003\u2003\u2003DESCENDANTS("},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003[Geography].CURRENTMEMBER,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003[Geography].[City]"},{"entry":"\u2003\u2003\u2003\u2003\u2003),"},{"entry":"\u2003\u2003\u2003\u2003\u2003S0"},{"entry":"\u2003\u2003\u2003\u2003)"},{"entry":"\u2003\u2003\u2003)"},{"entry":"\u2003\u2003)"},{"entry":"\u2003)"},{"entry":") ON AXIS(1)"},{"entry":"FROM [MyCube]"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Interaction of Summary Values and Post Filter Aggregations","In a report that contains both summary values and post filter aggregations, the generated MDX contains both calculated members (non-measure dimension) and calculated measures. In the instances where these calculated members\/measures intersect, it is necessary to ensure that the calculated measure prevails because these calculated members represent the aggregation of the measure post aggregation at specific levels in the hierarchy.","In the presence of pre-filter aggregation, the priority of the calculated members\/measures is reversed.","The SOLVE_ORDER construct of MDX is used to convey the priority of the cell calculations.","In the following example, assume the previous example with the following modifications:\n\n","Whenever, two or more dimensions are encountered and at least one has multiple levels, the algorithm for MDX generation for post-filter calculations is to apply the general approach for multiple dimensions, but only if the aggregation is neither COUNT nor AVERAGE. In those two particular cases, a cross join of the dimensions is performed first to ensure proper calculation of the aggregated values.",{"@attributes":{"id":"p-0149","num":"0218"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"WITH"},{"entry":"SET S0 AS"},{"entry":"\u2018TOPCOUNT( [Geography].[City].MEMBERS, 5, [Sales] )\u2019"},{"entry":"MEMBER [Year].[m1] AS \u2018AGGREGATE ([Year].[LEVEL01].MEMBERS)\u2019"},{"entry":"SOLVE_ORDER = 1"},{"entry":"MEMBER [Geography].[m2]AS \u2018AGGREGATE( S0 )\u2019 SOLVE_ORDER = 2"},{"entry":"MEMBER [Measures].[m3] AS \u2018IIF( [Unit Sales]>5000, [Unit Sales],"},{"entry":"NULL)\u2019"},{"entry":"MEMBER [Measures].[m4] AS"},{"entry":"\u2018IIF([Geography].CURRENTMEMBER.level.ordinal<3,"},{"entry":"SUM("},{"entry":"\u2003INTERSECT("},{"entry":"\u2003\u2003DESCENDANTS( [Geography].CURRENTMEMBER,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003[Geography].[City]"},{"entry":"\u2003\u2003),"},{"entry":"\u2003\u2003S0"},{"entry":"\u2003),"},{"entry":"\u2003[Measures].[m3]"},{"entry":"), \u2003[Measures].[m3])\u2019"},{"entry":"MEMBER [Measures].[Total Unit Sales Post-Filter] AS"},{"entry":"\u2018IIF([Year].CURRENTMEMBER.level.ordinal<1,"},{"entry":"SUM( DESCENDANTS( [Year].CURRENTMEMBER,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003[Year].[LEVEL01] ), [Measures].[m4]"},{"entry":"), \u2003[Measures].[m4] )\u2019"},{"entry":"MEMBER [Measures].[m5] AS"},{"entry":"\u2018IIF([Geography].CURRENTMEMBER.level.ordinal<3,"},{"entry":"MAX("},{"entry":"\u2003INTERSECT("},{"entry":"\u2003\u2003DESCENDANTS( [Geography].CURRENTMEMBER,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003[Geography].[City]"},{"entry":"\u2003\u2003),"},{"entry":"\u2003\u2003S0"},{"entry":"\u2003),"},{"entry":"\u2003[Measures].[m3]"},{"entry":"), \u2003[Measures].[m3])\u2019"},{"entry":"MEMBER [Measures].[Max Unit Sales Post-Filter] AS"},{"entry":"\u2018IIF([Year].CURRENTMEMBER.level.ordinal<1,"},{"entry":"MAX( \u2003DESCENDANTS( [Year].CURRENTMEMBER,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003[Year].[LEVEL01] ), [Measures].[m5]"},{"entry":"), [Measures].[m5] )\u2019"},{"entry":"SELECT"},{"entry":"{[Measures].[Total Unit Sales Post-Filter],"},{"entry":"\u2002[Measures].[Max Unit Sales Post-Filter]} ON AXIS(0),"},{"entry":"UNION( CROSSJOIN({[Year].[m1]} ,"},{"entry":"{[Geography].[m2]}),"},{"entry":"CROSSJOIN( [Year].[LEVEL01].MEMBERS,"},{"entry":"UNION({[Geography].[m2]},"},{"entry":"GENERATE( S0,"},{"entry":"\u2003UNION("},{"entry":"\u2003\u2003{ANCESTOR([Geography].CURRENTMEMBER, [Geography].[Country])},"},{"entry":"\u2003\u2003{ANCESTOR([Geography].CURRENTMEMBER, [Geography].[State])},"},{"entry":"\u2003\u2003{[Geography].CURRENTMEMBER}"},{"entry":")))))"},{"entry":"ON AXIS(1)"},{"entry":"FROM [MyCube]"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Pre & Post Filter Aggregation","The presence of both pre and post filter aggregation simply requires that the generated MDX query contain multiple measures\u2014the default measures in the cube and the calculated measures as described above.","Multiple Root Members in a Hierarchy","In the majority of hierarchies, there is a single \u201croot\u201d (or \u201cALL\u201d) member at the highest level of the hierarchy (ordinal zero). In the case of a report that requires a summary value for the entire hierarchy, and in which no filter has been applied in the report to any attribute associated with the hierarchy, the aggregate value of a fact that is associated with the \u201cALL\u201d member represents the summary value.","In the case of a hierarchy in which the root level contains two or more members (i.e., there is no single \u201cALL\u201d member), there is still an expectation of a report author to be able to obtain an overall summary\u2014the absence or presence of a single \u201cALL\u201d member is irrelevant when authoring a report based on an E\/R schema.","To produce the overall value for a hierarchy, the translation module generates a calculated member for the measure that aggregates the members of the root level (using the AGGREGATE function) and assigns a pre-defined name to the measure such that the result-processing module can identify it as such.","It should be noted that this is a specific application of the method used to calculate aggregate values in the presence of filters.","Summary Values","Calculated members are introduced in each dimension for which summary values are required. These are given a fixed name that can be recognized by the post-processing code as summary values.","Filter on Entities not in the Query","In all previous examples, filters have been applied to entities that appear in the actual query. It is quite typical, however, that filters are applied to entities that do not appear in the report. This has the effect of reducing the data that appears within the report.","In the case of a filter that is applied to an entity that represents the key identifier of a level within a multi-dimensional data source, if that filter consists of a single equality comparison, the filter can appear in the \u201cslicer\u201d (WHERE clause) of the generated MDX statement.","In the following example, entities from the [Geography] dimension are projected in the report, but a filter is applied to an entity from the [Product] dimension. The filter appears in the WHERE clause.",{"@attributes":{"id":"p-0163","num":"0232"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"SELECT"},{"entry":"HIERARCHIZE(UNION(UNION([Geography].[Country].MEMBERS,"},{"entry":"[Geography].[State].MEMBERS), [Geography].[City].MEMBERS))"},{"entry":"DIMENSION"},{"entry":"PROPERTIES PARENT_UNIQUE_NAME ON AXIS(0),"},{"entry":"{[(Measures].[Cost]}"},{"entry":"ON AXIS(1)"},{"entry":"FROM [Cube]"},{"entry":"WHERE ([Product].[Vacuum])"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In the case of a similar filter that applies to multiple equality comparisons (or equivalently, an IN clause), a single calculated member (measure) is created for each measure that aggregates the measure for the set of members in the filter. Depending upon the logic (AND\/OR) in the original filter, appropriate IF-THEN-ELSE logic is encapsulated in a calculated member to determine the value of the fact entity in the report. For an OR clause, the value of each calculated member of each of the OR'ed filters is compared to null and the first non-null value is taken as the value of the measure.","In the following example, only entities from the [Geography] dimension appear in the report, but the filter, \u201c[Product code] in (\u2018a\u2019, \u2018b\u2019, \u2018c\u2019)\u201d is applied to the report.",{"@attributes":{"id":"p-0166","num":"0235"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"WITH"},{"entry":"MEMBER [Measures].[ m1] AS \u2018SUM(FILTER([Product].[LEVEL01].MEMBERS,"},{"entry":"[Product].[Product code] = \u201ca\u201d), [Measures].[Cost])\u2019"},{"entry":"MEMBER [Measures].[ m2] AS \u2018SUM(FILTER([Product].[LEVEL01].MEMBERS,"},{"entry":"[Product].[Product code] = \u201cb\u201d), [Measures].[Cost])\u2019"},{"entry":"MEMBER [Measures].[ m3] AS"},{"entry":"\u2018IIF([Measures].[ m1] <> NULL, [Measures].[ m1], [Measures].[ m2])\u2019"},{"entry":"MEMBER [Measures].[ m4] AS \u2018SUM(FILTER([Product].[LEVEL01].MEMBERS,"},{"entry":"[Product].[Product code] = \u201cc\u201d), [Measures].[Cost])\u2019"},{"entry":"MEMBER [Measures].[ Cost] AS"},{"entry":"\u2018IIF([Geography].CURRENTMEMBER.LEVEL.ORDINAL < 3,"},{"entry":"SUM(DESCENDANTS([Geography].CURRENTMEMBER, [Geogrpahy].[City]),"},{"entry":"IIF([Measures].[ m3] <> NULL, [Measures].[ m3], [Measures].[ m4])),"},{"entry":"IIF([Measures].[ m3] <> NULL, [Measures].[ m3], [Measures].[ m4]))\u2019"},{"entry":"SELECT"},{"entry":"FILTER(HIERARCHIZE(UNION([Geography].[Country].MEMBERS,"},{"entry":"[Geography].[City].MEMBERS)), [Measures].[ Cost] <> NULL) ON"},{"entry":"AXIS(0),"},{"entry":"{[Measures].[ Cost]} ON AXIS(1)"},{"entry":"FROM [$ZD1AUTC01]"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Result Information Generation","Once a report specification has been successfully translated into an OLAP (MDX) query, the following information may be produced by evaluating the generated query and the relationship between report constructs and their corresponding construct in the MDX query:","Type of report (tabular, grouped, cross-tabulated).","Do all report columns represent facts?","Do any of the report columns represent facts?","Does the report contain overall summary rows?","For each column in the report:\n\n","Query information:\n\n","Another aspect of the report specification conversion system  provides a post-processing tool having reporting capabilities to provide universal data access that is transparent to the end user. That is, the person using such a reporting tool does not need to be aware where of the data is located or how the data is stored. The end user should not care about the manner in which data is physically stored (e.g., relational database, network database) or the manner in which it is logically stored (e.g., separate tables, networked constructs).","One example of a post-processing tool is the result processing module  that converts a multi-dimensional data set into a result set that reflects the semantics of an E\/R report specification. The post-processing tool may be implemented as a stand-alone module or system that can be added to the application server , the report server , the query engine , or the database server . Alternatively, the post-processing tool may be implemented as a module of the report specification conversion system .","The post-processing tool provides a singular view of a collection of heterogeneous data sources. A user can then author reports in a consistent fashion without regards to the physical or logical constraints or differences of the underlying data sources. Such reports require the execution of one or more data source specific queries, each possibly specified in a language\/semantics specific to that data source.","The results of the data source specific queries can be returned in a variety of formats, depending upon the capabilities and characteristics of the underlying data sources. The results of these queries must be formulated into a single result set that reflects the original semantics of the user's query.","Three software components can be produced individually, each performing a specific task, that combined provide the backbone of a heterogeneous reporting application. Those components are:\n\n","Each of these components can be devised to deal with one or more of the possible combinations of data sources, model representations, and report types. For example:\n\n","With the use of an agreed upon set of application programming interfaces (APIs) for each of these components (or barring that, the introduction of software to perform the necessary transformations from one API to another), these components may form the basis of a post-processing reporting tool. The more capabilities supported by a particular component, or the more variety of such tools used by a particular application, the larger the variety of data sources, models, queries and results supported by the application.","One example of a post-processing tool is the result processing module . Described below is the result transformations to convert the results of a single OLAP (MDX) query into a tabular or cross tabulated report based upon a set of supplied directives on how to process the results of the OLAP query.",{"@attributes":{"id":"p-0183","num":"0272"},"figref":"FIG. 10","b":["43","43"],"ul":{"@attributes":{"id":"ul0058","list-style":"none"},"li":["1. Result Set Description Generation Module \n    \n    ","2. Tabular Row Generation Module \n    \n    ","3. Tabular Summary Level Calculation Module \n    \n    ","4. Tabular Header Row Generation Module \n    \n    ","5. Cross-Tabulated Result Generation Module \n    \n    "]}},{"@attributes":{"id":"p-0184","num":"0283"},"figref":"FIG. 11","b":["110","43","110","111","41","112","113","114","115","116","110"]},"Further description of concepts and examples of algorithms or methods used by the result processing module  are described below.","Data for tabular reports may be returned in a variety of formats, all of which return the same information. The following specification is representative of the format in which data is returned for tabular and cross-tabulated queries and forms the basis for the description of how data from multi-dimensional queries (which return data in a the cross-tabular format themselves) is converted into a representation that reflects the semantics of the original report specification.","Tabular","The data of a tabular query may be represented by a single rowset that contains zero or more rows of data, each containing  or more columns. In addition, each row provides:\n\n","Cross-Tabulated","The data of a cross-tabulated query may be represented by:\n\n","Each row in the rowset has associated with an ordinal position along the edge, starting at 0.","The cell rowset contains a column containing a cell's value, and a column for each edge of the report specification, containing the ordinal position for that edge that corresponds to the cell value in each row.","If any dimension in the underlying data source is not specified in the report specification, the default member from each dimension appears in a special edge, commonly referred to as the \u201cslicer\u201d, in an edge rowset constructed exactly the same as the other edges in the result set.","Use the metadata from query generator and the result set metadata (not data) to construct the metadata for the result set returned to the client:\n\n","Tabular Report Processing","The result set processing module, when processing tabular reports, operates upon a multi-dimensional dataset in which all non-fact dimensions are nested along a single dimension and all facts, if any, involved in the query appear along a separate edge. Overall summary values for any grouping level within the report specification appear in the result set as members with a pre-defined name known to the result set processing module. For the purposes of discussion, call it \u201coverall value\u201d.","In the presence of non-fact attributes in a report, the tabular report-processing module traverses the non-fact edge of the multi-dimensional result set and pushes level identifiers (members) onto a stack in the manner described below. When the stack contains the same number of members as the number of levels referenced by the original report specification (upon its initial binding to the multi-dimensional metadata), a row of data is available for possible inclusion in the final result set and for calculation of its summary level.",{"@attributes":{"id":"p-0198","num":"0321"},"figref":"FIG. 12","b":["43","120"],"ul":{"@attributes":{"id":"ul0074","list-style":"none"},"li":["1. From the current position within the multi-dimensional edge rowset, push the highest-level member onto a stack ().","2. Traverse the parent\/child relationships within a dimension along the edge (). At each level (), push the member at that level (which includes references to its member property values) onto the stack ().","3. A ragged path within the hierarchy of a result set is one in which the difference in the level ordinals of a parent\/descendant pair is more than expected based on the query specification.\n    \n    ","4. An unbalanced path within the hierarchy of a result set is one in which the path does not descend to the lowest level of the dimension as specified in the report specification.\n    \n    ","5. Perform steps 2, 3 and 4 for each dimension nested along the edge () until there are no more dimensions to traverse ().","6. When the last nested dimension has been reached () and its members pushed on the stack, this represents a row of data that can possibly be included in the final result set and its summary value calculated (), as described below.","7. Pop the top member off the stack (). If there is a sibling of the member just popped off the stack (), push the sibling onto the stack () and perform step 6 ().","8. Perform step 7 until all siblings have been processed at that level ().","9. When all of the siblings at level N are exhausted (), the member at level N\u22121 is popped of the stack (). If there is another sibling at level N\u22121 (), this member is pushed on the stack () and steps 6 to 8 ( to ) are repeated until there are no members remaining in the edge rowset."]}},"Summary Values","Summary values for rows are calculated by the following mechanism:","Each element in the stack contains the following information:\n\n","Elements go through the following state sequences. The states within in braces are optional.","[CheckHeaderNested\u2192CheckHeaderCurrent\u2192CheckHeaderDone]\u2192CheckChildren\u2192CheckNested\u2192CheckCurrent[\u2192CheckSiblings]\u2192CheckAncestor","The various CheckHeader states are not in effect if no headers are required.","CheckSiblings is not performed if CheckCurrent determines that all of the siblings would result in the same unwanted summary level.","Only the CheckHeaderCurrent and CheckCurrent states can result in the stack representing a desired row.","To determine header information and summary level, the stack is logically divided into dimensions.",{"@attributes":{"id":"p-0207","num":"0347"},"chemistry":{"@attributes":{"id":"CHEM-US-00001","num":"00001"},"img":{"@attributes":{"id":"EMI-C00001","he":"13.12mm","wi":"74.93mm","file":"US07945575-20110517-C00001.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},"Rule 1","If there are only \u2018Normal\u2019 elements in the stack which match the number of columns in the report (not including generated overall nodes), it is a detail row. (Summary Level=\u22121).","Rule 2","If every dimension has only a single \u2018Normal\u2019 element, this is the overall row (Summary Level=0)","Rule 3","Determine the summarization of each dimension. A dimension is summarized if there are Nested Dimension Fillers in the dimension set.\n\n","Consider the following Stacks (Nested Dimension Fillers represented by X):","No dimensions are summarized. This is a detail row (Summery Level=\u22121) (by Rule 1)",{"@attributes":{"id":"p-0216","num":"0358"},"chemistry":{"@attributes":{"id":"CHEM-US-00002","num":"00002"},"img":{"@attributes":{"id":"EMI-C00002","he":"13.04mm","wi":"73.66mm","file":"US07945575-20110517-C00002.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},"Overall Summary Level (One \u2018Normal\u2019 element per dimension) (by Rule 2)",{"@attributes":{"id":"p-0218","num":"0360"},"chemistry":{"@attributes":{"id":"CHEM-US-00003","num":"00003"},"img":{"@attributes":{"id":"EMI-C00003","he":"12.95mm","wi":"73.66mm","file":"US07945575-20110517-C00003.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},"Dimension 2 is summarized (inner-most summarized dimension) (By Rule 3a)",{"@attributes":{"id":"p-0220","num":"0362"},"chemistry":{"@attributes":{"id":"CHEM-US-00004","num":"00004"},"img":{"@attributes":{"id":"EMI-C00004","he":"12.95mm","wi":"73.66mm","file":"US07945575-20110517-C00004.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},"Dimension 1 is summarized, but the row doesn't represent a desired row since dimension 3 is also summarized. (By Rule 3b)",{"@attributes":{"id":"p-0222","num":"0364"},"chemistry":{"@attributes":{"id":"CHEM-US-00005","num":"00005"},"img":{"@attributes":{"id":"EMI-C00005","he":"12.95mm","wi":"73.66mm","file":"US07945575-20110517-C00005.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},"Once the summarized dimension is determined, The MDX Dim and MDX Level of the inner-most non-Nested Dimension Filler within the dimension is looked up in the post-processing rules to determine the Summery Level for this column.","If the column is grouped, the stack represents a row of interest. If not, and the inner-most Non Nested Dimension Filler is a generated overall node, check the Post Processing Rules for the previous dimension.","Header Rows",{"@attributes":{"id":"p-0226","num":"0368"},"figref":"FIGS. 13 and 14","b":["170","140","43"]},"Stack states are represents as follows:","HN","Check Header Nested","HC","Check Header Current","HD","Check Header Done","CH","Check Children","NE","Check Nested","CU","Check Current","SI","Check Siblings","AN","Check Ancestor","Step 1","Header Nested (): Set the state to Header Nested () and check for nested dimensions () until there are no more.",{"@attributes":{"id":"p-0245","num":"0387"},"chemistry":{"@attributes":{"id":"CHEM-US-00006","num":"00006"},"img":{"@attributes":{"id":"EMI-C00006","he":"11.01mm","wi":"7.03mm","file":"US07945575-20110517-C00006.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},"Step 2","Check Header Nested (): Continue to check nested dimensions () until there are no more. Set the state to Check Header Current () when there is no more nested to be done. The dimension is filled with the required number of Nested Dimension Fillers () to ensure the dimension is \u2018full\u2019 before moving onto the next inner dimension.",{"@attributes":{"id":"p-0248","num":"0390"},"chemistry":{"@attributes":{"id":"CHEM-US-00007","num":"00007"},"img":{"@attributes":{"id":"EMI-C00007","he":"11.09mm","wi":"44.11mm","file":"US07945575-20110517-C00007.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},"Step 3","Check Header Current (): Determine the summary level () in the same manner as described below. If the summary level is >=0 (), the row represents a header and must be identified as such () in the tabular result in some manner, possibly a Boolean property. Otherwise, discard row () and continue. Set the element state to Header Done ().",{"@attributes":{"id":"p-0251","num":"0393"},"chemistry":{"@attributes":{"id":"CHEM-US-00008","num":"00008"},"img":{"@attributes":{"id":"EMI-C00008","he":"11.09mm","wi":"43.18mm","file":"US07945575-20110517-C00008.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},"Step 4","Check Header Done (): This state is transitory. It is only possible to move to the next state after the client has issued a Next( ) to move from the header row. It simply deletes itself (), if there are other Check Header Current states in the stack () or sets the last element to Check Children () if not ().",{"@attributes":{"id":"p-0254","num":"0396"},"chemistry":{"@attributes":{"id":"CHEM-US-00009","num":"00009"},"img":{"@attributes":{"id":"EMI-C00009","he":"11.09mm","wi":"43.10mm","file":"US07945575-20110517-C00009.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},"Step 5","Since all Nested Dimension Fillers are removed from stack, remove this Check Header Done element () will cause all but the first element to remain on the stack. It's header summary level will be determined and state set to Check Children () when completed (See Steps 3 and 4).",{"@attributes":{"id":"p-0257","num":"0399"},"chemistry":{"@attributes":{"id":"CHEM-US-00010","num":"00010"},"img":{"@attributes":{"id":"EMI-C00010","he":"11.01mm","wi":"7.03mm","file":"US07945575-20110517-C00010.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},"Step 6","Check Children (): All children are check () until there are no more children (). The state is then set to Check Nested (). This process is repeated until the dimension is full.",{"@attributes":{"id":"p-0260","num":"0402"},"chemistry":{"@attributes":{"id":"CHEM-US-00011","num":"00011"},"img":{"@attributes":{"id":"EMI-C00011","he":"11.01mm","wi":"7.03mm","file":"US07945575-20110517-C00011.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},"Step 7","Check Nested (): Determine if there are any Nested Dimensions (). Fill the current dimension to the required depth with Nested Dimension Fillers () before moving onto the inner dimension (as in Step 2).",{"@attributes":{"id":"p-0263","num":"0405"},"chemistry":{"@attributes":{"id":"CHEM-US-00012","num":"00012"},"img":{"@attributes":{"id":"EMI-C00012","he":"11.43mm","wi":"30.23mm","file":"US07945575-20110517-C00012.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},"Step 8","Check Current (): Once there are no more children () and no more nested dimensions (), the next state is Check Current (). Along with Check Header Current, these are the only two states that can produce a row back to the client. The summary level is determined (), as per below. \u22121 indicates a detail row. 0 or above indicate a footer row. All other values indicate that this stack does not represent a desired row and the process continues.",{"@attributes":{"id":"p-0266","num":"0408"},"chemistry":{"@attributes":{"id":"CHEM-US-00013","num":"00013"},"img":{"@attributes":{"id":"EMI-C00013","he":"11.09mm","wi":"45.72mm","file":"US07945575-20110517-C00013.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},"Step 9","Check Siblings (): This is a transitory state after the Check Current () is completed. The underlying MDDS Iterator is moved to the next sibling (), a row copy is kept (), and the state is set to Check Header Nested (). If there are no more siblings ( and ) the state is set to Check Ancestor ().",{"@attributes":{"id":"p-0269","num":"0411"},"chemistry":{"@attributes":{"id":"CHEM-US-00014","num":"00014"},"img":{"@attributes":{"id":"EMI-C00014","he":"11.09mm","wi":"45.55mm","file":"US07945575-20110517-C00014.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},"Step 10a (More Siblings)","Check Header Nested (): The process starts over again at Step 1 ( and ).",{"@attributes":{"id":"p-0272","num":"0414"},"chemistry":{"@attributes":{"id":"CHEM-US-00015","num":"00015"},"img":{"@attributes":{"id":"EMI-C00015","he":"11.09mm","wi":"45.64mm","file":"US07945575-20110517-C00015.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},"Step 10b (No More Siblings)","Check Ancestor (): A transitory state where the last element in the stack is deleted (). It allows triggers the end of the dataset when there are no more elements left in the stack.",{"@attributes":{"id":"p-0275","num":"0417"},"chemistry":{"@attributes":{"id":"CHEM-US-00016","num":"00016"},"img":{"@attributes":{"id":"EMI-C00016","he":"11.09mm","wi":"45.55mm","file":"US07945575-20110517-C00016.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},"All Facts","If a report contains only fact columns (the \u201call facts\u201d indicator is true), then the result set contains only a single row of data containing the various cell (measure) values from the multi-dimensional dataset.","There is no necessity of performing any traversal of dimension members, or the production of any summary rows.","No Facts","If a report contains no facts, it then only contains detail rows and no summary or header rows are produced. All row summary values indicate a detail row.","Multi-Dimensional Value to Column Values","Once a row of data has been identified for being appropriate for inclusion in the final result set, each member and property represented by the stack is matched, if possible, with its corresponding item in the result processing information generated by the translation module. If a matching item is found, this provides the information required to determine where an item appears in the final result set (i.e. column position).","Currently not handling 2 data source dimensions put into 1 (problem with additional summary values), nor splitting 1 into 2\u2014missing expected summary values.","Cross Tabulated Results","In the case of a cross tabulated report, no transformations are applied to the actual data returned by the data source result set. However, it may be necessary to modify the metadata description of the result set itself so that it aligns with the semantics of the original query:\n\n","The report specification system , translation module , and result processing module  according to the present invention, and the methods described above, may be implemented by any hardware, software or a combination of hardware and software having the functions described above. The software code, either in its entirety or a part thereof, may be stored in a computer readable memory. Further, a computer data signal representing the software code that may be embedded in a carrier wave may be transmitted via a communication network. Such a computer readable memory and a computer data signal are also within the scope of the present invention, as well as the hardware, software and the combination thereof.","While particular embodiments of the present invention have been shown and described, changes and modifications may be made to such embodiments without departing from the true scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Other advantages of the present invention will be readily appreciated as the same becomes better understood by reference to the following detailed description when considered in connection with the accompanying drawings wherein:",{"@attributes":{"id":"p-0014","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0023"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0021","num":"0024"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0022","num":"0025"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0023","num":"0026"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0024","num":"0027"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0025","num":"0028"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0026","num":"0029"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0027","num":"0030"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
