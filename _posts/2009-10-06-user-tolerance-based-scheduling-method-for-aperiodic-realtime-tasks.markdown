---
title: User tolerance based scheduling method for aperiodic real-time tasks
abstract: An apparatus comprising at least one processor configured to implement a method comprising analyzing a plurality of tasks, determining a privilege level for each of the task, determining a schedule for each of the tasks, and scheduling the tasks for execution based on the privilege level and the schedule of each task. Included is a memory comprising instructions for determining a privilege level for each of a plurality of tasks, wherein the privilege levels comprise periodic real-time, aperiodic real-time, and non-real time, determining an execution time for each of the tasks, and scheduling the tasks for execution on a processor based on the privilege level and the execution time of each task.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08397235&OS=08397235&RS=08397235
owner: Futurewei Technologies, Inc.
number: 08397235
owner_city: Plano
owner_country: US
publication_date: 20091006
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT","REFERENCE TO A MICROFICHE APPENDIX","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present application claims priority to U.S. Provisional Patent Application 61\/103,476, filed Oct. 7, 2008 by Xuesong Dong, Yang Yu, Renwei Li, and Ming Li, and entitled \u201cUser Tolerance Based Scheduling Method for Aperiodic Real-Time Tasks,\u201d which is incorporated herein by reference as if reproduced in its entirety.","Not applicable.","Not applicable.","There are numerous devices in the market that use real-time operating systems. The operating systems may generally be divided into hard real-time systems and soft real-time systems. Soft real-time systems, such as BSD, LINUX, VXWORKS, and SOLARIS, typically use priority-based scheduling to schedule the tasks, which may be done on a preemptive or non-preemptive basis. In preemptive systems, a thread is forcibly removed from a processor when the timeslot for the thread expires. In non-preemptive systems, threads run a predetermined time and then yield and go to the end of the queue. These models are not precise and may potentially cause deadline misses. Other newly developed methods, for example, EDF, pfair, etc., are too complicated and deemed impractical.","In one embodiment, the disclosure includes an apparatus comprising at least one processor configured to implement a method comprising analyzing a plurality of tasks, determining a privilege level for each of the task, determining a schedule for each of the tasks, and scheduling the tasks for execution based on the privilege level and the schedule of each task.","In another embodiment, the disclosure includes a system comprising a processor, a plurality of tasks for execution on the processor, at least one run queue comprising an arrangement and specified timing of the tasks for execution by the processor, and a scheduler configured to classify each of the plurality of tasks as one of a periodic task, an aperiodic task, and a non-real time task, determine an execution time and a latest start time for each of the tasks, and determine an order in which the tasks are arranged in the at least one run queue based on the classification of the tasks, the execution time of the tasks and the latest start time for the tasks.","In a third embodiment, the disclosure includes a memory comprising instructions for determining a privilege level for each of a plurality of tasks, wherein the privilege levels comprise periodic real-time, aperiodic real-time, and non-real time, determining an execution time for each of the tasks, and scheduling the tasks for execution on a processor based on the privilege level and the execution time of each task.","These and other features will be more clearly understood from the following detailed description taken in conjunction with the accompanying drawings and claims.","It may be understood at the outset that although an illustrative implementation of one or more embodiments are provided below, the disclosed systems and\/or methods may be implemented using any number of techniques, whether currently known or in existence. The disclosure may in no way be limited to the illustrative implementations, drawings, and techniques illustrated below, including the exemplary designs and implementations illustrated and described herein, but may be modified within the scope of the appended claims along with their full scope of equivalents.","Described herein is a method and system for scheduling real-time tasks in one or more processors. The scheduling system allows a user to specify the thread time tolerance associated with a thread, which allows the scheduler to more intelligently decide when to schedule threads on the processor.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","102","104","106","108","112","112","114","116","114","116","100","110","102","104","106","108","102","104","106","108","114","116"]},"The kernel  may include a scheduler . The kernel  may also include at least one run queue, for example Run Queue A  and Run Queue B  are illustrated in . Run Queue A  may contain jobs for execution on Core A  and Run Queue B  may contain jobs for execution on Core B . The scheduler  may determine whether to place each of tasks , , ,  in Run Queue A  or Run Queue B . The scheduler  may also determine the order that each task , , ,  may be placed in the respective queue. To efficiently use processing time, the scheduler  classifies each of tasks , , ,  into categories, such as non-real-time tasks, aperiodic tasks, and periodic tasks, and uses these categories to determine the order in which to place tasks , , ,  into one of Run Queue A  and Run Queue B . The scheduler  may also determine the execution time for each task , , ,  and the expiration time for each task , , , . The execution time may be defined as the duration of time that the task uses the processor before the task is complete. The expiration time may be defined as the time by which the task must begin to run or the time by which the task must be completed. The scheduler may compute the expiration times or they may be included with the tasks when the scheduler receives the tasks. In some embodiments, the expiration time may also be referred to as the yield time.","Non-real-time (NRT) tasks may be defined as tasks with no time constraints. Typically, most of the threads in the router may be NRT tasks. Since NRT tasks may not have any time constraints, these tasks may have lower privilege level than aperiodic tasks and periodic tasks. A such, NRT tasks may run in a first-in, first-out (FIFO) order and may be run to completion before quantum expiry. NRT tasks may be preempted by the other two types of tasks (e.g. aperiodic and periodic tasks). The quantum for an NRT task may be long enough to allow most of the code for the task to finish without calling yield to another task. The scheduler  may schedule NRT tasks to run when no expiration is imminent for another higher privilege level task. In an embodiment, the quantum may be the amount of processor time allocated to a task.","Aperiodic tasks may be tasks that have time constraints defining the time period in which the task must execute. Aperiodic tasks may have a higher privilege level than NRT tasks, but a lower privilege level than are periodic tasks. Aperiodic tasks are typically soft real-time tasks, such as routing protocols. Execution time of an aperiodic task may vary with each run. Aperiodic tasks run to completion when the yield time is before the quantum expiry time. The scheduler  may preempt NRT tasks to schedule an aperiodic task. With the execution time Ei and expiration time Ti, the scheduler  may schedule a newly arriving aperiodic task according to the capacity of the run queues , . A run queue has no capacity for a new task j with start time Tj and execution time Ej if there exists a task i in the queue with (Ti, Ei) in which Ti<Tj<Ti+Ei as illustrated in . In that case, the task j  needs to begin before the previous task  has completed even though the task j  may complete before it is time for task  to begin. A run queue also has no capacity for a new task j  with start time Tj and execution time Ej if there exists a task k  in the queue with (Tk, Ek) where Tk<Tj+Ej<Tk+Ek as illustrated in , since the task j will not complete until time Tj+Ej (the start time plus the execution time) which is after the time Tk at which task k  must begin executing. This may be true even though the start time Tj for task j  is after the completion of task .","If a task , , ,  is not schedulable on one of the cores , , then the scheduler  moves the task , , ,  to another one of the cores , . If none of the cores ,  have the capacity for the task , , , , the scheduler  may run a defragmentation on at least one of the cores ,  so that the cores' processing time is more efficiently used, thereby freeing time on at least one of the cores. An example of such is depicted in , which illustrates the rescheduling of tasks  and  from the queue for core B  to the queue for core A , which frees processor time on core B  for scheduling other tasks. If after defragmenting the cores ,  none of the cores have sufficient capacity for the desired task , , , , the system limit for the task , , ,  has been reached. The scheduler  may then add the task , , ,  to whichever Run Queue ,  has the earliest fit, and may log a warning to indicate the task , , ,  is delayed and indicate how long the delay is for. If a number of constraint misses exceeds a specified threshold, the scheduler  may readjust the queues ,  and migrate tasks , , ,  to any other cores ,  that have capacity.","An upper time limit may be specified for a task by the application creating the task at thread creation to indicate the delay within which the thread has to run after being wakened. When a thread is wakened and added to a run queue ,  by the scheduler , the scheduler  uses this upper limit to put the task in the right place in the run queue , . If no slot is available in a run queue ,  ahead of the upper limit, the scheduler  squeezes the task in one of the run queues ,  before the limit, if permitted.","To calculate execution time (Ei), the threads may use thread_may_timeyield and yield only when this time exceeds the predefined CPU time. As a result, once a thread starts yielding, the execution time during each run will be known and almost the same, with the exception that the first run may be different. When the thread is wakened, the execution time for the first run is estimated by scheduler , and may be based on the worst execution time for the particular thread. The execution time Ei for the last run before the thread goes to sleep may be longer than actual execution time. The extra time may be spent on executing NRT tasks.","If NRT tasks are not scheduled for a period of time, the scheduler  reserves a time slot for these tasks for fairness and to avoid starvation, thereby ensuring that the NRT tasks are also run. When running in the time slots, an NRT task is run from the NRT queue for that particular core , . These slots may be interleaved among the two cores ,  so that aperiodic tasks may find an available slot.","In some embodiments, an additional argument, delayed start time Tj, may be added to the task , , ,  to inform the scheduler  that the task , , ,  would like to run at start time Ti, but may be delayed until delayed start time Tj. When the system is busy, the scheduler  may delay existing tasks , , ,  according to the delayed start time.","Periodic tasks may be defined as tasks that are performed periodically, and may have time constraints. Periodic tasks may typically be soft real-time tasks, such as timers. Periodic tasks are often high frequency tasks with fixed execution times. Typically, the execution time is low. The time constraints for periodic tasks are typically less flexible than aperiodic tasks. Thus, periodic tasks have the highest privilege level and the scheduler may preempt both NRT tasks and aperiodic tasks to schedule periodic tasks. It is preferable that the execution time for periodic tasks be small to guarantee soft real-time scheduling of aperiodic tasks. The scheduler  may employ an oversight component to enforce task execution quantum and ensure that the quantum for periodic tasks is significantly smaller than that of the NRT tasks and the aperiodic tasks.","Although the system has been described with reference to a dual-core processor, the system is not limited to dual core processors, but may be applied to processors of any number of cores. Furthermore, the system is not limited to a single processor, but may be implemented with two or more processors ,  as depicted by system  in . Processors ,  may be single core or multi-core processors. Additionally, the system is not limited to multi-core processors or to multi-processor systems, but may be implemented on a single processor such as the processor  in system  illustrated in .","Kernel  and scheduler  may be implemented as a computer readable set of instructions stored on a non-transient computer readable storage media and executable by a processor. Run queues ,  may be stored on a non-transient computer readable storage media. Examples of non-transient computer readable storage media include RAM, DRAM, and SDRAM memory components.","In some embodiments, the threads may be required to run to completion and yield before their quantum expires. When the threads yield, a new set of application programming interfaces (APIs) may be used instead of the available thread yield APIs. For example, a new user land thread library API may be used to supply the kernel scheduler with the time Ti that specifies when the task would like to run again, e.g. an expiration time constraint. The new user land thread library API may be embodied as: \u201cint thread_timedyield (const struct timespec*Ti)\u201d. The new user land thread library API may allow the scheduler to plan ahead according to user's tolerance. With this API, the threads may yield without leaving the run queue and the scheduler will try to find a slot using Ti.","Another new API may be a wrapper API of thread_timedyield, which may be defined as \u201cthread_may_timedyield (const struct timespec*cpu_tv, const struct timespec*Ti)\u201d, and may contain the following pseudocode: \u201cif (thread_time_exceeded(cpu_tv), then thread_timedyield (Ti)\u201d. Alternatively, the wrapper API of thread_timedyield may be defined as \u201cthread_timedyield (const struct timespec*Ti, const struct timespec*Tj)\u201d to tell the scheduler that the task would like to run at time Ti but can be delayed up to time Tj. Thread_time_exceeded may determine whether the processor time spent for the thread run exceeds the predefined processor time limit cpu_tv. If it does, the thread calls thread_timedyield to tell the scheduler when it would like to run for the next time. The real-time threads may be required to call thread_may_timedyield so that it can yield after running a fixed amount of time. Hence, the scheduler can predict the execution time for each run accurately based on previous executions. With the execution and expiration time, the scheduler can schedule a yielding task according to its capacity. On a multi-processor system, if the current processor cannot find a slot for this task, the task should be migrated to another processor who has the capacity to accommodate the task. If none of the processors has the capacity, a defragmentation should be triggered among the processors. If still none of the processors has the capacity, the system limit has been reached for the task. The task is added to a processor's run queue that has the earliest fit and a warning should be logged.","A timed yield API can potentially take an additional parameter to allow user threads to specify the absolute maximum time tolerance so that the scheduler can make better decisions on which threads to delay when the system is heavily loaded. When a thread is waken up and added to the run queue, the scheduler can use a predefined user tolerance of time. Aperiodic real-time tasks may preempt non real-time tasks in the system. If there is no imminent expiration for real-time tasks, then non real-time tasks should run. The expiration time constraints of the tasks may be used to order the tasks with a single privilege level. Different time constraint values specified by a thread when yielding causes its execution order to shift at run time achieving the same goal as priority manipulations.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 6","b":["602","604","606","608","610"]},"If no run queue has availability consistent with the constraints of the task, then at block  the scheduler determines whether the run queues may be defragmented and other tasks migrated from one run queue to another run queue to make room for the task. If the run queues may be defragmented, then at block , the scheduler defragments the run queues and moves selected ones of the other tasks from one queue to another queue, and places the task in the earliest available slot in one of the run queues that is consistent with the constraints imposed on the task. If, however, the run queues cannot be defragmented, then at block  the scheduler determines whether one of the existing tasks may be preempted and moved to another place in the queue. If one or more tasks may be preempted, then at block  the scheduler moves the preempted tasks to another position in the run queue and places the task in the position of the preempted task(s). If no tasks may be preempted, then at block  the scheduler places the task at the earliest available position in the run queues and logs an error in an error log indicating that the task has been delayed and the amount of time that the task is delayed.","The systems and methods disclosed herein offer numerous advantages over preemption based scheduling. For example, developers do not have to play with conceptual numbers like priorities and may use time constraints which are native to routing protocols. Depending on embodiments, the scheduling of a task may largely be determined by two or three parameters\u2014start time Ti, execution time Ei, and delayed start time Tj\u2014rather than the numerous (e.g. tens or hundreds) of priorities used in priority-based scheduling methods. The disclosed systems and methods provide high predictability on multiprocessor systems. Furthermore, the disclosed systems and methods provide that high privilege level new tasks may run with reasonable delay if desired.","The network components described above may be implemented on any general-purpose network component, such as a computer or network component with sufficient processing power, memory resources, and network throughput capability to handle the necessary workload placed upon it.  illustrates a typical, general-purpose network component  suitable for implementing one or more embodiments of the components disclosed herein. The network component  includes a processor  (which may be referred to as a central processor unit or CPU) that is in communication with memory devices including secondary storage , read only memory (ROM) , random access memory (RAM) , input\/output (I\/O) devices , and network connectivity devices . The processor  may be implemented as one or more CPU chips, or may be part of one or more application specific integrated circuits (ASICs).","The secondary storage  is typically comprised of one or more disk drives or tape drives and is used for non-volatile storage of data and as an over-flow data storage device if RAM  is not large enough to hold all working data. Secondary storage  may be used to store programs that are loaded into RAM  when such programs are selected for execution. The ROM  is used to store instructions and perhaps data that are read during program execution. ROM  is a non-volatile memory device that typically has a small memory capacity relative to the larger memory capacity of secondary storage . The RAM  is used to store volatile data and perhaps to store instructions. Access to both ROM  and RAM  is typically faster than to secondary storage .","At least one embodiment is disclosed and variations, combinations, and\/or modifications of the embodiment(s) and\/or features of the embodiment(s) made by a person having ordinary skill in the art are within the scope of the disclosure. Alternative embodiments that result from combining, integrating, and\/or omitting features of the embodiment(s) are also within the scope of the disclosure. Where numerical ranges or limitations are expressly stated, such express ranges or limitations may be understood to include iterative ranges or limitations of like magnitude falling within the expressly stated ranges or limitations (e.g., from about 1 to about 10 includes, 2, 3, 4, etc.; greater than 0.10 includes 0.11, 0.12, 0.13, etc.). For example, whenever a numerical range with a lower limit, R, and an upper limit, R, is disclosed, any number falling within the range is specifically disclosed. In particular, the following numbers within the range are specifically disclosed: R=R+k*(R\u2212R), wherein k is a variable ranging from 1 percent to 100 percent with a 1 percent increment, i.e., k is 1 percent, 2 percent, 3 percent, 4 percent, 5 percent, . . . , 50 percent, 51 percent, 52 percent, . . . , 95 percent, 96 percent, 97 percent, 98 percent, 99 percent, or 100 percent. Moreover, any numerical range defined by two R numbers as defined in the above is also specifically disclosed. Use of the term \u201coptionally\u201d with respect to any element of a claim means that the element is required, or alternatively, the element is not required, both alternatives being within the scope of the claim. Use of broader terms such as comprises, includes, and having may be understood to provide support for narrower terms such as consisting of, consisting essentially of, and comprised substantially of Accordingly, the scope of protection is not limited by the description set out above but is defined by the claims that follow, that scope including all equivalents of the subject matter of the claims. Each and every claim is incorporated as further disclosure into the specification and the claims are embodiment(s) of the present disclosure. The discussion of a reference in the disclosure is not an admission that it is prior art, especially any reference that has a publication date after the priority date of this application. The disclosure of all patents, patent applications, and publications cited in the disclosure are hereby incorporated by reference, to the extent that they provide exemplary, procedural, or other details supplementary to the disclosure.","While several embodiments have been provided in the present disclosure, it may be understood that the disclosed systems and methods might be embodied in many other specific forms without departing from the spirit or scope of the present disclosure. The present examples are to be considered as illustrative and not restrictive, and the intention is not to be limited to the details given herein. For example, the various elements or components may be combined or integrated in another system or certain features may be omitted, or not implemented.","In addition, techniques, systems, subsystems, and methods described and illustrated in the various embodiments as discrete or separate may be combined or integrated with other systems, modules, techniques, or methods without departing from the scope of the present disclosure. Other items shown or discussed as coupled or directly coupled or communicating with each other may be indirectly coupled or communicating through some interface, device, or intermediate component whether electrically, mechanically, or otherwise. Other examples of changes, substitutions, and alterations are ascertainable by one skilled in the art and may be made without departing from the spirit and scope disclosed herein."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a more complete understanding of this disclosure, reference is now made to the following brief description, taken in connection with the accompanying drawings and detailed description, wherein like reference numerals represent like parts.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIGS. 4A and 4B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
