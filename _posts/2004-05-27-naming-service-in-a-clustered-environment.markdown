---
title: Naming service in a clustered environment
abstract: Within a cluster, when a new server node joins the cluster, an indication of the new server node has joined is received by at least one server node in the cluster. Global naming operations are disabled within the cluster. While the global naming operations are disabled, the global naming objects are replicated to the new server node. Once the replication is complete, global naming is reenabled for the cluster. In one embodiment of the invention, subsequent naming data from subsequent global naming operations is replicated in all server nodes in the cluster. One embodiment of the invention redirects naming operations directed to a down server node to a different server node within the cluster. One embodiment of the invention performs security checks responsive to a first access to the naming service.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09122686&OS=09122686&RS=09122686
owner: SAP SE
number: 09122686
owner_city: Walldorf
owner_country: DE
publication_date: 20040527
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","Embodiments of the invention relate to naming. More specifically, embodiments of the invention relate to extensions to naming systems to increase robustness of the naming system.","2. Background","Naming service broadly refers to the mechanism by which an object is associated with a name and by which objects may be found given their names. Each name is generated by a set of syntactic rules called, \u201cnaming convention.\u201d An atomic name is an indivisible component of a name as defined by the naming convention. The association of the atomic name with an object is called, \u201cbinding.\u201d Some objects cannot be stored directly so they are put in the system as references. A \u201creference\u201d is an object, which contains one or some addresses of objects which themselves are not directly bound to the naming system. Every name is interpreted relative to some context, and every naming operation is performed in a context object. A \u201ccontext\u201d is a set of bindings in which names are relative to a certain naming convention. A client may obtain an initial context object that provides a starting point for resolution of names in the naming system. Every naming system consists of contexts of a certain type (one and the same naming convention) that provide the same identical set of operations. Every operation is relative to a certain namespace. A \u201cnamespace\u201d is the set of names in the naming system. The naming service organization of the namespace is a treelike structure of naming context objects that can be traversed to locate a particular name.","A directory service is a naming service that allows each bound object to be associated with attributes and provides a way to retrieve an object by looking up some of its attributes rather than its name (search). The \u201cattributes\u201d are object characteristics. Both the attributes and the object itself form a directory object. A \u201cdirectory\u201d is a linked set of directory objects.","In a Java context, basic support for the naming and directory service is provided by a Java Naming and Directory Interface (JNDI) such as specified in , Version 1.2, published by Sun Microsystems of Mountain View, Calif. and subsequent revisions thereof (the JNDI Specification). The JNDI Specification meets the system requirements of Java 2 Enterprise Edition (J2EE). These requirements are defined in the Java 2 Enterprise Edition Specification 1.3, published Jul. 27, 2001 or subsequent versions thereof (the J2EE Standard). JNDI is defined to be independent of any specific directory service implementation. This permits a variety of directories to be accessed in a common way.","Within a cluster, when a new server node joins the cluster, an indication that new server node has joined is received by at least one server node in the cluster. Global naming operations are disabled within the cluster. While the global naming operations are disabled, the global naming objects are replicated to the new server node. Once the replication is complete, global naming is reenabled for the cluster. In one embodiment of the invention, subsequent naming data from subsequent global naming operations is replicated in all server nodes in the cluster. One embodiment of the invention redirects naming operations directed to a down server node to a different server node within the cluster. One embodiment of the invention performs security checks responsive to a first access to the naming service.","The results of naming operations are retained in a non-persistent memory local to the creating server. Responsive to the reboot of the server all preexisting naming relationships are removed from the naming system. By using local memory, the speed of naming operations increases relative to the speed of operations in other existing naming services with persistent data storage.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1","b":["100","110","120","110","120","114","116","118","124","126","128","112","122","114","116","118","124","126","128","160","163","170","173","100","102","104","110","120","100","110","120"]},"Server nodes , ,  within instance  provide the business and\/or presentation logic for the network applications supported by the system. Each application server, for example  and , provides a set of core services ,  to the business and\/or presentation logic. Among the services provided is naming service , . In one embodiment, the naming service ,  stores data and objects resulting from naming operations, referred to collectively as \u201cnaming data\u201d, in the memory implementation ,  of its respective virtual machine , . The memory implementation ,  by its nature is non-persistent. As a result, when a server goes down and reboots the naming data is not retained. Accordingly, on reboot, the server is assured of a clear name space. Moreover, because the naming operations are not reliant on a DBMS, efficiency and reliability of the naming service is improved.","Another of the core services is cross service , . The cross service is used to provide redirection of naming operations from remote clients in the event that a server node fails. This redirection as discussed in greater detail below improves failover within the cluster.","Each of the server nodes , ,  within a particular instance  may be configured with a redundant set of application logic and associated data. In one embodiment, dispatcher  distributes service requests from clients to one or more of server nodes , ,  based on the load on each of the servers. For example, in one embodiment, a dispatcher implements a round-robin policy of distributing service requests (although various alternate load-balancing techniques may be employed). In one embodiment, the dispatcher performs load balancing on naming service requests from remote clients. However, once a remote client has received an initial context from a certain server node, the subsequent naming requests from that client are directed to the same server node.","In one embodiment of the invention, server nodes , ,  are Java 2 Platform, Enterprise Edition (\u201cJ2EE\u201d) server nodes which support Enterprise Java Bean (\u201cEJB\u201d) components and EJB containers (at the business layer) and Servlets and Java Server Pages (\u201cJSP\u201d) (at the presentation layer). A J2EE platform complies with the j2EE Standard. In one embodiment, the naming service is compliant with the JNDI Specification. Of course, certain aspects of the embodiment of the invention described herein may be implemented in the context of other software platforms including, by way of example, Microsoft .NET platforms and\/or the Advanced Business Application Programming (\u201cABAP\u201d) platforms developed by SAP AG, the assignee of the present application. Microsoft .Net Platforms implement the Active Directory Service Interfaces (ADSI) such as Active Directory Service Interfaces Version 2.5 published by Microsoft Corporation of Redlands, Wash. or other versions thereof (the ADSI Standard). Thus, in the context of a Net platform, the naming service would be compliant with the ADSI Standard.","In one embodiment, communication and synchronization between each of instances  and  is enabled via central services instance . As illustrated in , central services instance  includes messaging service  and locking service . Message service  allows each of the servers within each of the instances to communicate with one another via a message passing protocol. For example, messages from one server may be broadcast to all other servers within the cluster via messaging service . In addition, messages may be addressed directly to specific servers within the cluster (e.g., rather than being broadcast to all servers).","In one embodiment, locking service  disables access to (i.e., locks) certain specified portions of program code and\/or configuration data stored within a central database . Locking managers  and  employed within the server nodes lock data on behalf of various system components which need to synchronize access to specific types of data and program code (e.g., such as the configuration managers  and ). In one embodiment, messaging service  and locking service  are each implemented on dedicated servers. However, messaging service  and the locking service  may be implemented on a single server or across multiple servers while still complying with the underlying principles of embodiments of the invention.","As illustrated in , each server node (e.g., , ) includes a lock manager ,  for communicating with locking service ; a cluster manager ,  for communicating with messaging service ; and a configuration manager ,  for communicating with central database  (e.g., to store\/retrieve configuration data). Although lock managers  and , cluster managers  and , and configuration managers  and  are illustrated with respect to particular server nodes,  and , in , each of the server nodes , ,  and  and\/or on the dispatchers ,  may be equipped with equivalent lock managers, cluster managers, configuration managers, and services.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2","b":["180","182","186","204","206"]},"The security service  is used to facilitate authorization of remote client accesses to the naming service . In one embodiment, the naming service  has only a weak reference to a security interface. Accordingly, if the security service  fails to provide the security interface the naming service  will run anyway. If running without the security interface, all clients have access to get an initial context in the naming hierarchy and may perform all possible operations within that context. However, if the security service  provides the security interface, security services are then available within the naming service . In one embodiment, a policy configuration context is acquired to manage the security roles. This management may include, for example, mapping and unmapping clients to security roles, checking legality of an operation and checking the existence of a mapping between a client and a security role.","JNDI defines two security roles, one in which complete access is granted to the naming hierarchy (sometimes referred to as the \u201cadministrator\u201d role and one in which only lookup access is permitted (sometimes referred to as the \u201cguest\u201d role). If a client falls into neither role, no access to the naming hierarchy is permitted. Other embodiments may have multiple security roles rather than just two.","In one embodiment, an authentication context may be acquired from the security context. Authentication may be performed when a client attempts to get a new initial context. Once authenticated, the client is associated with a thread which gets the initial context. In one embodiment, authentication occurs on the client side. In one embodiment, authorization checks are performed on the server side for remote clients attempting to get an initial context. This authorization check may merely amount to checking the policy configuration context to determine the security role mapped to the client. The client is then returned an initial context with naming operations enabled consistent with its security role. In one embodiment, no authentication or authorization is performed for local clients.","Connection service  provides the naming service remote method invocation (RMI) to facilitate communication with remote clients. In one embodiment, to perform naming operations using the naming service  a client must first obtain a context instance. Calling a getInitialContext method of a desired factory returns a context instance.","For remote clients, the connection service  provides the connection to the naming service  within the server node. The remote client is provided a stub to a skeleton of the server node to be used to connect to the server node for all naming operations. The connection service ensures proper handling of remote objects. The cross service  specifies remote objects in the cluster and permits access to those objects. To accomplish this, the cross service  retains remote resources (referred to as \u201cinitial\u201d objects) that are accessible with certain names. At start up, the naming service  gets the interface for the cross service . By getting JNDIProxyImpl as the initial object when a remote client attempts to get an initial context, the JNDI Proxy provides a stub that serves at the connection to naming functionality in a server node. The cross service  facilitates redirection as discussed above and also below with respect to . The redirection ensures that a remote client will be able to perform naming operation even though one server goes down. This improved reliability is important in a high availability system.","Naming service  includes an ID generator  which may be used to generate globally unique identifiers (GUIDS) for use in global naming operations. Naming service  also includes replication engine  to facilitate replication of global objects to other server nodes in the system. Referring back to , the same services shown as  may also occur in the other server nodes such as services  in server node .",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 3","FIG. 1","FIG. 1"],"b":["302","304","306","118","104","128","228","320","322","308","310","312","314"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 4A","FIG. 5","FIG. 4B"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 4B","FIG. 4A"]},"As noted above, where the basic object forms part of a context, the link identifier is equal to the container identifier of the container object, which the basic object is linked to form the context. However, where the object is merely a basic object not forming a context, the link identifier is selected to be a value that cannot be a container identifier. In one embodiment of the invention, the link identifier for all objects not forming a context is negative one (\u22121).",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 5","b":"500"},"At start up of the naming service, an initial context factory builder is established as a default factory builder in the javax.naming.spi.NamingManager such that a JNDI Application Programming Interface (API)  will access the initial context factory builder implementation when an initial context is requested by a client . The initial context factory builder will provide a proper initial context factory implementation  depending on the environment properties supplied by the client. The initial context factory implementation  will return either offset client context  or client context  depending on the properties of the environment. Client Context always returns the root context, which is an abstraction that forms a starting point for all subsequent naming operations. The returned context may then be organized under the root context or any subcontext within the naming tree dependent on the rights of the client. In one embodiment, only applications will be provided an instance of offset client context . Offset client context  is an extension of client context  and indicates that the context is other than the root context. This prevents application from accessing or creating objects higher up the naming tree. Applications are allowed to perform naming operations only in their own namespace, e.g. the context returned as initial context and the subcontexts created under it.","Client context  has an instance of server context interface which will be either server context implementation , if a client is local or a stub to the server context implementation if the client is remote. Remote clients may use Remote Method Innovation (RMI) to pass messages to the server context implementation. Local clients can communicate directly without using RMI. In one embodiment, the connection service provides the RMI. Local clients can obtain an initial context without using the connection service or RMI.","Server context implementation  is connected to the JNDI memory implementation , which functions as the naming repository in one embodiment of the invention. Also, in some embodiments of the invention, server context implementation  may be connected to a naming cache . Naming cache  may be used to increase the speed of lookup operations in the naming system. In one embodiment, the naming cache  holds object instances for application clients running on the server and byte arrays of the objects for all other clients.","In one embodiment, the naming cache includes two concurrent hash tables and a cache communicator. A first hash table keeps every cached object as byte array and name. Elements are added in this hash table any time a client performs a lookup operation. The second hash table keeps every cached object as an object instance and name. Elements are added in this hash table only if an application running on a local server performs a lookup operation. The cache communicator (CC) is registered as a message listener and performs the communication among the naming services in the different server nodes in the cluster. The CC is used to notify the cluster about the changes in cache, which concern global objects. If an unbind, rebind or rename operation is performed over a global object, the object will be removed from cache on the current server and a message with object name will be sent to all other servers to inform them of the invalid global object.","In one embodiment, JNDIMemoryImpl  is the implementation of the non-persistent naming data management within the naming service. JNDIMemoryImpl  keeps the hash tables of the containers stored by name and by ID and a handle to the root container object, which keeps hash tables of all the objects and subcontexts that can be found in the root context of the naming system stored by name and ID. All other containers have the same structure as the root container but are available for direct access. Thus the whole hierarchical tree like structure of objects and contexts in a naming system may be organized in hash tables with only two levels of nesting.","The following example of operation in one embodiment of the invention illustrates operations in response to local and global objects. For example, client performs a bind (String name, Object object) operation. First in ClientContext  the object parameter is wrapped in a directory object (DirObject) instance, serialized, if possible, and the byte array is sent to ServerContextImpl  where the type and correctness of the operation are evaluated.","In ServerContextImpl , if the operation involves a local object: the object is passed to a bind method of JNDIMemoryImpl . An object ID that is unique to the server is generated. The byte array representation of the object, the object ID, the type of the operation and the link ID identifying the container object linked to this object are wrapped in an Obj object and placed against the object name in the hash table instance of the container corresponding to the context in which the object has to be placed. In one embodiment, the link ID is the container ID (if the object represents a context) or \u22121 otherwise.","If the operation involves a global object: the object is still passed to the bind method of JNDIMemoryImpl . But the method generates an object ID of type long that is unique for the entire cluster. In one embodiment, this ID is generated from two integers\u2014the server ID of the current server node and the consecutive number of the global bound object. The byte array representation of the object, the object ID, the type of the operation and the link ID form an Obj object, which is put against the object name in a hash table instance of a container corresponding to the context in which the object should be placed. Using the messaging service, (see ), messages containing the ID, the name and the byte array representing the object, a byte parameter which shows whether the object is remote or not, and the name of the container in which the object should be placed are sent to all server nodes in the cluster. The name of the container is unique in the cluster and shows the full path name from the root context to the requested context. In one embodiment, the sender server does not wait to receive answers from the other server nodes whether the bind operation is performed successfully.","When a new server node is connected to the cluster it sends a message with a specific ID via the messaging service to an arbitrary server node with a request\u2014information for all global objects and context to be sent to it. This message \u201carrives\u201d in the CacheCommunicator instance of the receiver server and calls a method of JNDIMemoryImpl. Naming tree is recursively searched for global objects and contexts and if such are found they are sent as messages with all additional information to the server from which the request has been sent. The other server receives the messages and executes the operations locally. If the container in which the global object must be place does not exist, it is created and the object is put in it. If a part of the path of contexts from the root context to the context in which the object must be placed does not exist, all the missing intermediate contexts from the path are created. The names for the contexts are taken from the name of the container in which the object must be placed\u2014it contains the whole path. In one embodiment, no responses are returned to the server, which sends the messages whether the replication is executed correctly or not.","Before every lookup operation, a check is made whether the looked up object is a global remote object, e.g. it is a global object created by a remote server node. If the object is a global remote object, the creating server is checked to insure the server remains in the cluster, e.g. has not shut down or crashed. If the creating server remains in the cluster, the object is returned as a result from the operation. Otherwise, the object is deleted from the hash table of the corresponding container and a message is sent to all other server nodes to delete the object from the hash table in their respective containers. If the object is not a global remote object, it is returned as a result from the operation.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 6","b":"602"},"At decision block , a determination is made if an object is serializable. If it is, at block  a serialized directory object is received from a client at the server side naming implementation. At block , the naming service generates a basic object from the serialized directory object. At block , the basic object is placed in a designated container within the naming hierarchy. This may take the form of placing the object in the hash table of the container objects. As previously noted, such hash table is retained in non-persistent storage. A determination is made at decision block  if the subcontext is to be created with the object. If so, at block , the naming service creates a new container instance. At block , the basic object is linked to the new container instance to form a context. At block , the container of the context is stored in the table of containers in nonpersistent memory. In one embodiment, this non-persistent storage may be a memory implementation of a Java virtual machine. If at decision block  no context was to be created, the routine ends. If at decision block  no serialized directory object is received (implying that the created object is non-serializable), naming system handles non-serializable object at block . One embodiment of the invention permits non-serializable objects to be bound within the naming system, but requires all data for such objects to be maintained on the client side. In such embodiments, the non-serializable objects are only available to the client which has bound them and all the clients running on the same VM.","By virtue of the fact that this storage is non-persistent, in the event that a reboot of the system or the server occurs, objects and context stored in the non-persistent storage are guaranteed to be removed from the naming system. As a result, naming service rebuilds the naming hierarchy on reboot without concerns of conflict from any preexisting naming hierarchy.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 7","b":["702","704","706","706"]},"Thus, if no server node is specified, a server node is deemed available or if the specified server node is up a stub to be placed in the returned, context is provided at block . The naming service accesses the security service to perform authorization of the client at block . After getting an initial context, no further authorizations are required for subsequent naming operations within that context. By limiting authorization to only the get initial context operation accesses the naming service the speed of naming operations for remote client can be increased.","At block , the client is provided an initial context, including a stub to the providing server node, based on the outcome of the authorization. This may result in the client being provided an initial context in which the client can perform all naming operation, only lookup operations or not being provided an initial context at all. On the client side, authentication may be performed using a user identification and password. The authenticated client is authorized on the server side by determining what security role is assigned to that authenticated client. In one embodiment, authentication is thread based and only performed if a context requested is a first context gotten by the thread as long as the first context has not been closed. In one embodiment, roles include an administrator role and a guest role. As a result going forward, all the naming operations that this client performs will be directed to this server.","If at decision block  the operation is not a get initial context operation, a determination is made at decision block  whether the server is up e.g., has not crashed or shut down. For example, if at some point the server has gone down and not come back up, the remote client not knowing the server is down, may try to execute a naming operation with the ServerContext stub, which exists on the client side, from the returned initial context as discussed above. The stub will try to invoke the corresponding operation of the ServerContext skeleton which is found on the server side. But when the server node is down, the corresponding skeleton is no longer available. Accordingly, in one embodiment, the connection service will redirect the naming operation to another server node at block .",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 7A","b":["742","744","746"]},"Returning to , after redirection or if the server node is up, at block , the naming operation is performed. At block , the resulting object is placed in a hash table in a container corresponding to the context in which the naming operation took place. At decision block , the determination is made if the naming operation and\/or context provided is global. The determination may be made by checking the type variable of the basic object. If the naming operation is global, the objects created are replicated at other server nodes at block . In one embodiment, replication is performed as described above with reference to .",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 7B","b":["752","1","2","754"]},"Elements of embodiments may also be provided as a machine-readable medium for storing the machine-executable instructions. The machine-readable medium may include, but is not limited to, flash memory, optical disks, CD-ROMs, DVD ROMs, RAMs, EPROMs, EEPROMs, magnetic or optical cards, propagation media or other type of machine-readable media suitable for storing electronic instructions. For example, embodiments of the invention may be downloaded as a computer program which may be transferred from a remote computer (e.g., a server) to a requesting computer (e.g., a client) by way of data signals embodied in a carrier wave or other propagation medium via a communication link (e.g., a modem or network connection).","It should be appreciated that reference throughout this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Therefore, it is emphasized and should be appreciated that two or more references to \u201can embodiment\u201d or \u201cone embodiment\u201d or \u201can alternative embodiment\u201d in various portions of this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures or characteristics may be combined as suitable in one or more embodiments of the invention.","In the foregoing specification, the invention has been described with reference to specific embodiments thereof. It will, however, be evident that various modifications and changes can be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. It should be noted that references to \u201can\u201d or \u201cone\u201d embodiment in this disclosure are not necessarily to the same embodiment, and such references mean at least one.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7B"}]},"DETDESC":[{},{}]}
