---
title: Method and apparatus for high-performance rendering and hit testing of a window tree
abstract: A method and apparatus for high-performance rendering and hit-testing of a window tree is provided. A window tree may be rendered using an application programming interface provided by the present invention. The application programming interface provides support for world-transforms, enabling entire sub-trees of the window tree to be rotated and scaled during rendering. In order to quickly render and hit-test the transformed nodes of the window tree, a stack-based implementation of the “painter's algorithm” is utilized to achieve fast rendering. By storing all state information on a stack regarding each node in the window tree and building new data structures containing rendering information for each node and its children, any portion of the sub tree may be rendered on demand.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07453473&OS=07453473&RS=07453473
owner: Microsoft Corporation
number: 07453473
owner_city: Redmond
owner_country: US
publication_date: 20050114
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCES TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["This application is a continuation of U.S. application Ser. No. 09\/885,350, filed Jun. 20, 2001, the benefit of the filing date of which is hereby claimed under 35 U.S.C. \u00a7 120. U.S. application Ser. No. 09\/885,350 claims the benefit of U.S. Provisional Application No. 60\/244,287, filed Oct. 30, 2000, under 35 U.S.C. \u00a7 119, which benefit is also claimed for this application. Both of these applications are expressly incorporated herein by reference.","This invention generally relates to the field of computing devices with graphical user interfaces. More specifically, this invention relates to rendering and hit-testing windows within a graphical user interface environment.","Graphical user interfaces typically employ some form of a window manager to organize and render windows. Window managers commonly utilize a window tree to organize windows, their child windows, and other objects to be displayed within the window such as buttons, menus, etc. To display the windows on a display screen, a window manager parses the window tree and renders the windows and other objects in memory. The memory can then be displayed on a video screen. A window manager may also be responsible for \u201chit-testing\u201d input to determine the window in which input was received. For instance, when a user moves a mouse cursor into a window and mouse \u201cclicks,\u201d the window manager must determine the window in which the click was made and generate a message to that window.","Current window managers suffer from a number of drawbacks that limit their ability to manage a large number of windows and to perform advanced functions. For instance, current window managers suffer from severe performance limitations when rendering thousands of windows, children, or other objects. Moreover, these performance limitations impede current window managers from supporting advanced functions on windows, such as alpha-blending, rendering composition, and world-transforms, such as scaling and rotation of sub-trees of the window tree.","Therefore, in light of the above, there is a need for a method and apparatus for rendering a window tree that is optimized to manage a large number of windows and child window objects. There is a further need for a method and apparatus for rendering a window tree that allows advanced functions, such as world-transforms, to be applied to sub-trees of the window tree without an impact on system performance.","The present invention solves the above-problems by providing a method and apparatus for high-performance rendering and hit-testing of a window tree. According to an actual embodiment of the present invention, an application programming interface (\u201cAPI\u201d) is provided through which a window tree may be rendered. The method and apparatus provides support for world-transforms, enabling entire sub-trees to be rotated and scaled during rendering. This is accomplished by emulating the math done by the rendering component when computing both invalidation intersection and hit-testing rectangles. Reusable user interface components, otherwise known as Visual Gadgets, are implemented without any special knowledge of the transforms. Moreover, by programming in \u201cvirtual pixels,\u201d the present invention can translate these on demand into physical pixels at the point of rendering, invalidation and hit-testing.","The present invention also provides support for multiple rendering surfaces. The present invention supports a variety of rendering surfaces, including, but not limited to, Graphics Device Interface (\u201cGDI\u201d) HDC's, GDIplus Graphics, DirectDraw Surfaces, and Direct3D objects. By providing an extensible architecture that abstracts out the differences between surfaces, the present invention can natively support a variety of different surfaces without requiring that they all support a common denominator. The surface is passed through the rendering pipeline, customizing at key places for specific operations, and is then passed in the callback to the surface type requested by a Visual Gadget. This allows the present invention to be utilized on platforms other than Microsoft Windows\u00ae, such as Linux or Macintosh\u00ae, which do not support any of these surface types.","The present invention also provides support for origin zeroing. A specific Visual Gadget may request that the present invention zero the origin on the rendering surface. This style may be dynamically changed on any Visual Gadget before and after creation. Although some window managers support either zeroing or not-zeroing the origin, the present invention supports both dynamically. This provides significant performance gains when zeroing the origin is not required by the Visual Gadget. The ease of programming when zeroing also greatly simplifies control rendering.","The present invention also provides support for \u201ctrivial painting.\u201d Trivial painting allows the present invention to highly optimize the rendering of entire sub-trees that meet certain criteria. By examining a single bit on each Visual Gadget when the tree is manipulated, the present invention is able to detect \u201ctrivialness\u201d at render time and use an optimized rendering path to render the child sub-trees.","The present invention additionally provides stack-based painting and read-only callback. The present invention utilizes a stack-based implementation of the \u201cpainter's algorithm\u201d to achieve very fast rendering. By storing all state on the stack, and building new data structures containing rendering information for the node and its children, the present invention can render any portion of the sub-tree on demand.","Because the present invention calls back to each control to render while traversing the window tree, special precautions must be taken to ensure that the tree's state is not changed during the callback. To accomplish this, the present invention is implemented in the user mode, provided by Microsoft Windows\u00ae in an actual embodiment of the present invention. This prevents the possibility that the tree's state may change if deadlocks were utilized in Microsoft Windows\u00ae kernel mode. The present invention also marks the window tree \u201cContext\u201d as \u201cread-only,\u201d allowing only \u201cread-only\u201d API functions to be called and failing any \u201cread\/write\u201d API functions. The present invention also does not release the window tree \u201cContext Lock,\u201d preventing other threads from coming into the Context and failing because the Context is marked \u201cread-only.\u201d This provides the added benefits of avoiding the overhead of continuously grabbing and releasing the critical section of the window tree, reduces thread contention, and improves rendering performance.","The present invention also provides a method, computer-controlled apparatus, and a computer-readable medium for providing high performance rendering and hit-testing of a window tree.","The present invention is directed to a method and apparatus for providing high-performance rendering and hit-testing of a window tree. Aspects of the invention may be embodied in a computer executing an operating system capable of providing a graphical user interface. Referring now to the figures, in which like numerals represent like elements, an actual embodiment of the present invention will be described.","Referring now to , an illustrative personal computer  will be described. The personal computer  comprises a conventional personal computer, including a processing unit , a system memory , and a system bus  that couples the system memory to the processing unit . The system memory  includes a read only memory (\u201cROM\u201d)  and a random access memory (\u201cRAM\u201d) . A basic input\/output system  (\u201cBIOS\u201d) containing the basic routines that help to transfer information between elements within the personal computer , such as during start-up, is stored in ROM . The personal computer  further includes a hard disk drive , a magnetic disk drive , e.g., to read from or write to a removable disk , and an optical disk drive , e.g., for reading a CD-ROM disk  or to read from or write to other optical media such as a Digital Versatile Disk (\u201cDVD\u201d).","The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer-readable media provide nonvolatile storage for the personal computer . Although the description of computer-readable media above refers to a hard disk, a removable magnetic disk and a CD-ROM disk, it should be appreciated by those skilled in the art that other types of media that are readable by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, ZIP disks, and the like, may also be used in the illustrative operating environment. A number of program modules may be stored in the drives and RAM , including an operating system , such as Windows 98\u00ae, Windows 2000\u00ae, or Windows NT\u00ae from Microsoft\u00ae Corporation. As will be described in greater detail below, aspects of the present invention are implemented within the operating system  in the actual embodiment of the present invention described herein.","Those skilled in the art should appreciate that the term \u201ccomputer-readable media\u201d as defined herein may include any available media that can be accessed by the personal computer . By way of example, and not limitation, computer-readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EPROM, EEPROM, flash memory or other solid-state memory technology, CD-ROM, DVD or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium that can be used to store the desired information and that can be accessed by the personal computer .","A user may enter commands and information into the personal computer  through input devices such as a keyboard  or a mouse . Other input devices (not shown) may include a microphone, touchpad, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus , but may be connected by other interfaces, such as a game port or a universal serial bus (\u201cUSB\u201d). A monitor  or other type of display device is also connected to the system bus  via a display interface, such as a video adapter . In addition to the monitor, a personal computer  may include other peripheral output devices, such as speakers  connected through an audio adapter  or a printer (not shown).","As described briefly above, the personal computer  may operate in a networked environment using logical connections to one or more remote computers through the Internet . The personal computer  may connect to the Internet  through a network interface . Alternatively, the personal computer  may include a modem  and use an Internet Service Provider (\u201cISP\u201d)  to establish communications with the Internet . The modem , which may be internal or external, is connected to the system bus  via the serial port interface . It will be appreciated that the network connections shown are illustrative and other means of establishing a communications link between the personal computer  and the Internet  may be used.","Referring now to , additional aspects of the operating system  will be described. According to the actual embodiment of the invention described herein, the operating system  comprises the Microsoft Windows\u00ae2000 operating system. The operating system  comprises a number of components for executing applications  and communicating with the hardware that comprises the personal computer . At the lowest level, the operating system  comprises device drivers  for communicating with the hardware . The operating system  also comprises a virtual machine manager , an installable file system manager , and a configuration manager . Each of these managers may store information regarding the state of the operating system  and the hardware  in a registry . The operating system  also provides a 32-bit shell , which includes user interface tools. An operating system core  is also provided that provides low-level functionality and hardware interfaces. According to the embodiment of the present invention described herein, aspects of the present invention are implemented in the operating system core . The operating system core  is described in greater detail below with respect to .","Turning now to , an illustrative operating system core  will be described. As mentioned above, the Microsoft Windows\u00ae 2000 operating system provides an illustrative operating environment for the present invention. The operating system core  of the Microsoft Windows\u00ae2000 operating system comprises three main components: the kernel ; the Graphical Device Interface (\u201cGDI\u201d) ; and the user component . The GDI  is a graphical system that draws graphic primitives, manipulates bitmaps, and interacts with device-independent graphics drivers, including those for display and printer output devices. The kernel  provides base operating system functionality, including file I\/O services, virtual memory management, and task scheduling. When a user wants to start an application, the kernel  loads the executable (\u201c.EXE\u201d) and dynamically linked library (\u201cDLL\u201d) files for the application. The kernel  also provides exception handling, allocates virtual memory, resolves import references, and supports demand paging for the application. As an application runs, the kernel  schedules and runs threads of each process owned by an application.","The user component  manages input from a keyboard, mouse, and other input devices and output to the user interface (windows, icons, menus, and so on). The user component  also manages interaction with the sound driver, timer, and communications ports. The user component  uses an asynchronous input model for all input to the system and applications. As the various input devices generate interrupts, an interrupt handler converts the interrupts to messages and sends the messages to a raw input thread area, which, in turn, passes each message to the appropriate message queue. According to the actual embodiment of the invention described herein, each thread may have its own message queue.","In order to manage the output to the user interface, the user component  maintains a window manager . The window manager  comprises an executable software component for keeping track of visible windows and other viewable objects, and rendering these objects into video memory, such as that provided by a video adapter . The present invention may be implemented as a part of the window manager , or may be implemented in a manner so as to provide window manager  functionality through an API. Also, although the invention is described as implemented within the Microsoft Windows\u00ae 2000 operating system, those skilled in the art should appreciate that the present invention may be advantageously implemented within any operating system that utilizes a windowing graphical user interface.","Referring now to , additional aspects of the window manager  will be described. The window manager  maintains a window tree  to keep track of open windows and other visible objects. The window tree  describes the window hierarchy in a tree-like fashion. According to the actual embodiment of the invention described herein, the operating system owns the root of the window tree  and reserves the root for the \u2018desktop\u2019 window. The branches and leaves of the window tree  represent windows and the viewable objects that comprise the windows. The window tree  is organized so that a correct window hierarchy will be rendered when the window tree  is \u201cwalked\u201d using the painter's algorithm. The painter's algorithm renders objects as a painter would, depth first, back to front. The painter's algorithm is well-known to those skilled in the art.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 4A","FIG. 4B"],"b":["80","86","88","98","100","102","84","90","96","92","94","82","80","84","96","92","94","82","74","80","82","80"]},"Referring now to , an illustrative Routine  for rendering a window tree will be described. Generally described, the Routine  provides the beginning of the rendering pipeline. The Routine  initializes all states necessary to \u201cwalk\u201d the window tree and initiates a recursive descent of the window tree. More specifically described, the Routine  begins at block , where a read-only \u201clock\u201d is placed on the window tree. The lock prevents other objects from modifying the window tree while the render is in progress.","The Routine  continues from block  to block , where the rendering surfaces are prepared. This may include clipping to a specified invalidation rectangle to help improve performance by reducing unnecessary painting. This process includes identifying the portion of the screen that needs to be redrawn and limiting the redraw to that portion of the screen. Preparing the rendering surface may also include initializing a translation size. This process comprises determining the portion of the window tree that needs to be redrawn. More particularly, this process includes calculating the appropriate node of the window tree at which to begin rendering. In this manner, only a portion of the window tree needs to be rendered. Preparing the rendering surface may also include setting up palettes and initializing transformation routines. The Routine  then continues from block  to block .","At block , the Routine  determines whether invisible controls, or Visual Gadgets, should be drawn. If, at block , it is determined that invisible Gadgets are to be drawn, the Routine  branches to block , where the Gadgets are made visible. The Routine  then continues to block . If, at block , it is determined that invisible Gadgets are not to be drawn, the Routine  continues from block  to block . At block , the Routine  calls the DRAW_FULL routine. The DRAW_FULL routine is recursively called for each node to render the sub-tree to the given surface. The DRAW_FULL routine will be described below with respect to .","From block , the Routine  continues to block , where the visible state of the Visual Gadgets is restored. Routine  then continues from block  to block , where a clean-up procedure takes place that may include releasing unused memory, etc. The Routine  then continues to block , where it ends.","Referring now to , an illustrative Routine  will be described for implementing the DRAW_FULL routine described above. The DRAW_FULL routine is recursively called for each node, with exceptions for trivialness, to render the sub-tree to the given surface. The Routine  begins at block , where a determination is made as to whether the control, or Visual Gadget, at the current node in the window tree is visible. If the gadget is not visible, it does not need to be painted. Therefore, if the gadget is not visible, the Routine  branches to block , where it returns. If the gadget is visible, the Routine  continues to block , where a PAINT_INFO data structure is created to maintain information about the sub-tree of the current node in the window tree. The PAINT_INFO data structure contains data describing aspects of each sub-tree in the window tree. An illustrative PAINT_INFO data structure is shown in Table 1, below.",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Struct PAINT_INFO {"]},{"entry":[{},"const RECT* prcCurInvalid Pxl;"]},{"entry":[{},"const RECT* prcOrgInvalid Pxl;"]},{"entry":[{},"DuSuface* pscf;"]},{"entry":[{},"Matrix3 * pmatCurInvalid;"]},{"entry":[{},"Matrix3 * pmatCurDC;"]},{"entry":[{},"BOOL FBUFFERED;"]},{"entry":[{},"# if ENABLED_OPTIMIZEDDIRTY"]},{"entry":[{},"BOOL FDIRTY;"]},{"entry":[{},"#endif"]},{"entry":[{},"SIZE SIZEBUFFEROFFSETPXL;"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The PRCCURINVALIDPXL element referenced in Table 1 comprises a pointer to a RECT structure for defining the coordinates of the upper-left and lower-right corners of a rectangle. The PRCCURINVALIDPXL element is utilized to store the coordinates of the invalidation rectangle fully transformed into coordinates relative to the current node of the window tree. As will be described in greater detail below, these coordinates may be utilized by intersection calculations to determine whether the sub-tree of the current mode needs to be repainted.","The PRCORGINVALIDPXL element referenced in Table 1 also comprises a pointer to a RECT structure. The PRCORGINVALIDPXL element is utilized to store the invalidation rectangle in coordinates relative to the current node. For instance, if the Visual Gadget located at the current node has been transformed, the PRCORGINVALIDPXL element is used to store the coordinates of the invalidation rectangle in a similarly transformed space. As will be described below, a transformation matrix is utilized to transform PRCORGINVALIDPXL into PRCCURINVALIDPXL.","The PSRF variable referenced in Table 1 comprises a pointer to the current surface being rendered into. Each time a buffer is created, a new surface is also created for that buffer to render into. The PMATCURINVALID matrix referenced in Table 1 is a matrix created using \u201canti-\u201d transformations and is utilized in transforming PRCORGINVALIDPXL into coordinates relative to the current node of the window tree. Similarly, the PMATCURDC matrix referenced in Table 1 comprises a matrix created using \u201cregular\u201d transformations to determine the world-transforms to be applied to the PSRF variable when rendering the sub-tree of the current node. The FBUFFERED element comprises a Boolean variable specifying whether at least one buffer has been created. The FBUFFERED variable is used to determine when a double-buffer has been set up.","The Boolean variable FDIRTY referenced in Table 1 is utilized when \u201cdirty-state\u201d optimizations have been enabled to determine whether the current sub-tree is \u2018dirty\u2019 as the result of a \u2018dirty\u2019 ancestor node. The variable SIZEBUFFEROFFSETPXL holds the current translation offset to factor in, accounting for buffers set up by ancestors.","Still referring to , the Routine  continues from block  to block , where known values are copied into the PAINT_INFO structure, including the surface, the original invalid rectangle, and other buffering information. The PAINT_INFO structure is then allocated on the stack. This allows fast rendering because memory does not have to be allocated while painting. Moreover, this allows state information from a parent node to be inherited by the children of the node. This also advantageously provides a performance boost since this information does not have to be recreated at each child node.","The Routine  then continues from block  to block , where a determination is made as to whether a new buffer will be utilized to render the sub-tree. A buffer is an off-screen memory area that may be modified and later painted into screen memory. Buffering allows flicker-free drawing, applying alpha for fading, and applying bitmap transformations after rendering, such as convolution filters. If a new buffer will be used, the Routine  branches to block , where a new buffer is created. The Routine  then continues from block  to block , where the contents of the portion of the screen memory corresponding to the buffer is copied into the buffer. The Routine  then continues from block  to block .","If, at block , it is determined that a new buffer will not be used, the Routine  continues from block  to block . At block , the bounds of the invalidation rectangle are computed in client coordinates. Although a window should be prepared to update the entire window whenever it receives the appropriate message, it often only needs to update a smaller area. This area is most often a rectangular area within the client area. For example, this portion of the client area may need to be repainted when the area is overlaid by a dialog box. Repainting is required when the dialog box is removed. This area is known as an \u201cinvalidation rectangle.\u201d The presence of an invalid region in a client area is what prompts the operating system to transmit a message to the window indicating that a repaint is necessary. An illustrative Routine  is described below with respect to  for computing the bounds of the invalidation rectangle in client coordinates.","The Routine  continues from block  to block , where the intersection between the Visual Gadget located at the current node and the transformed rectangle defined by the PRCCURINVALIDPXL variable is computed. The Routine  then continues to block , where a determination is made as to whether the gadget needs to be painted based on the results of the intersection. If the gadget does not need to be painted, the Routine  branches to block , where it returns. If the gadget needs to be painted, the Routine  continues to block , where a surface transformation matrix is created. The transformation matrix is utilized to transform the gadget by rotating, scaling, changing the center location, or zeroing the gadget's origin. In this manner, the window manager may provide support for world-transforms, enabling entire sub-trees to be rotated and scaled while rendering. This is accomplished by performing the math done by the rendering component when computing both invalidation intersection and hit-testing rectangles. The Routine  then continues to block , where a clipping region is prepared for the sub-tree that will be inherited by the children of the current node.","The Routine  continues from block  to block  where \u201cdeep state\u201d information is stored on the stack. Deep state information comprises information that should be inherited only by children from a parent. The Routine  then continues from block  to block , where the DRAW_CORE routine is called. The DRAW_CORE routine provides a common callback for both DRAW_FULL and DRAW_CORE to perform the actual rendering of a specific node. An illustrative DRAW_CORE routine is described in detail below with respect to .","From block , the Routine  continues to block , where a determination is made as to whether the current gadget is trivial. The trivialness of a gadget is determined by examining a bit associated with the gadget. The bit is set depending upon other properties of the gadget. So, for instance, the bit may be set if the gadget and its children do not require transformation. According to the actual embodiment of the invention described herein, \u201ctrivialness\u201d is defined as a gadget and any of its children having the \u201cGS_ZEROORIGIN,\u201d \u201cGS_CLIPSIBLINGS,\u201d \u201cGS_BUFFERED,\u201d and \u201cGS_CACHED\u201d parameters set to off, and not having any transforms applied. If the gadget is trivial, the Routine branches to block , where the DRAW_TRIVIAL routine is called for each child of the current node. The DRAW_TRIVIAL routine provides an optimized code path when rendering the children of trivial Visual Gadgets that eliminates the computationally expensive world-transforms that are required to zero the origin. An illustrative DRAW_TRIVIAL routine is described in greater detail below with respect to .","If, at block , it is determined that the gadget is not trivial, the Routine  branches to block , where the DRAW_FULL routine is called for each child of the current node. In this manner, each node of a non-trivial sub-tree is recursively processed by the DRAW_FULL routine. From blocks  and , the Routine  continues to block , where the original state information is restored. From block  the Routine  continues to block , where a buffer, if created, is copied to the destination surface in video memory. From block , the Routine  continues to block  where the buffer is released and the clipping region is cleaned up. At block , the Routine  returns.","Turning now to , an illustrative Routine  will be described for computing the bounds of an invalidation rectangle in client coordinates. As described briefly above with respect to , in order to determine when a transformed Visual Gadget is within the bounds of an invalidation rectangle, the invalidation rectangle must be transformed into coordinates relative to the Visual Gadget. In order to accomplish this task, the Routine  begins at block , where a determination is made as to whether any transformations have been applied at the current node of the window tree. If no transformations have been applied at the current node, the Routine  branches from block  to . At block , the current contents of the PRCCURINVALIDPXL variable are utilized for the bounding box. Because no transforms have been applied to the Visual Gadget at the current node, the invalidation rectangle for the parent node may be utilized. The Routine  then branches to block , where it returns to block , shown in .","If, at block , it is determined that transformations have been applied at the current node of the window tree, the Routine  continues to block . At block , the cumulative invalidation matrix PMATCURINVALID is updated using the antitransform of the transform applied to the Visual Gadget at the current node. The Routine  then continues from block  to block , where the invalidation matrix is applied to the PRCORGINVALIDPXL variable to obtain the client coordinates of the new bounding polygon. The Routine  then continues to block , where a bounding rectangle of the computed bounding polygon is identified. The bounding polygon is then intersected with the bounding rectangle of the Visual Gadget at the current node in the window tree at block . This intersection defines the new invalidation rectangle for the Visual Gadget at the current node of the window tree and is stored in the PRCCURINVALIDPXL variable at block . From block , the Routine  returns to block , shown in .","Turning now to , an application of the Routine  to an illustrative window tree  will be described. As shown in , the window tree  comprises a root node A , a child node B , a child node C , and a child node D . When the window tree  is rendered, the Visual Gadget  corresponding to the root node A  is first rendered. The Visual Gadget  corresponding to the child node B  is then rendered. Subsequently, the Visual Gadget  corresponding to the child node C  is rendered. Finally, the Visual Gadget  corresponding to child node D  is rendered. As shown in , the Visual Gadget  corresponding to child node D  has been rotated 45\u00b0. As will be described in greater detail below, the rotation of Visual Gadget  must be taken into account when computing the bounds of an invalidation rectangle and when hit-testing.","Once the Visual Gadgets shown in  have been rendered, they may be displayed. Subsequently, a window or other Visual Gadget, such as the window , may be displayed over the top of all or a portion of the Visual Gadgets. For instance, the window  completely overlays the Visual Gadget  and partially overlays the Visual Gadget . When the window  is closed, or otherwise removed, it is necessary to determine a portion of the screen which should be redrawn. To make this determination, the Routine  described above with reference to  is applied at each node of the window tree . With respect to the root node A , the child node B , and the child node C , the bounds of the window  may be utilized as the invalidation rectangle because no transformations have been applied to these nodes. However, with respect to the child node D , the bounds of the invalidation rectangle must be computed in coordinates relative to the Visual Gadget , because the Visual Gadget  has been rotated.","Although the Visual Gadget  is shown visually as having been rotated, the Visual Gadget  is unaware of the rotation. Instead, the Visual Gadget  believes that it has been rendered in a normal orientation as shown in . Accordingly, an antitransform of the transformation applied to Visual Gadget  must be applied to the bounding box defined by the window . In order to accomplish this, a cumulative invalidation matrix is created using each of the antitransforms applied at the current node and at any of its parent nodes. This invalidation matrix has been applied to the bounding box for the parent node to obtain the client coordinates of a new bounding polygon . Subsequently, a bounding rectangle  of the bounding polygon  is obtained. The bounding polygon  is then intersected with the bounding rectangle of the Visual Gadget  to obtain the new invalidation rectangle for the current node. The results of this computation are then stored in the PRCCURINVALIDPXL variable and pushed on the stack. This invalidation rectangle may then be used by children of the current node in order to calculate the transformed invalidation rectangle at those children nodes. The invalidation rectangle may also be passed to the Visual Gadget to determine whether and what portion of the Visual Gadget should be rendered.","Referring now to , an illustrative Routine  will be described for implementing the DRAW_TRIVIAL routine mentioned above. The Routine  begins at block , where a determination is made as to whether the current Visual Gadget intersects the invalidation rectangle. If the current Visual Gadget does not intersect the invalidation rectangle, the Routine  branches to block , where it returns. If the Visual Gadget intersects the invalidation rectangle, the Routine  continues block , where the clipping region is prepared for the sub-tree. The Routine  then calls the DRAW_CORE routine to perform the actual rendering of the Visual Gadget of the specific node. The Routine  then continues to block , where the DRAW_TRIVIAL routine is again called for each child of the node. At block , the clipping region is cleaned up. At block , the Routine  returns.","Referring now to , an illustrative Routine  for implementing the DRAW_CORE routine will be described. The Routine  begins at block  where the background is drawn as the intersection of the Visual Gadget bounds and the invalidation rectangle. From block , the Routine  continues to block , where the control is called to perform the customized drawing of the gadget. The Routine  then continues to block , where it returns.","In addition to rendering the window tree, the window manager  also provides functionality for hit-testing input. When movement of a mouse cursor, or a mouse click, is received, a message is generated comprising the coordinates of the movement or click and transmitted to the window manager . In order to relay the message to the appropriate window and\/or Visual Gadget, the window manager  must make a determination as to which Visual Gadget should receive the message. Because the window manager  provides for the translation and\/or transformation of nodes in the window tree that is unknown to the corresponding Visual Gadget, the window manager  must take these translations into account when determining which gadget should be notified of the input. The FIND_FROM_POINT routine described below with reference to  provides this functionality. The window manager  must also be able to convert container coordinates into client coordinates relative to another Visual Gadget. The DIRECT_POINT routine provides this functionality and is described below with reference to . It may also be necessary to convert coordinates relative to one Visual Gadget into coordinates relative to another Visual Gadget. The MAP_POINTS routine provides this functionality and is described below with reference to .","Referring now to , an illustrative Routine  will be described for implementing the FIND_FROM_POINT routine mentioned above. As discussed briefly above, the FIND_FROM_POINT routine takes the coordinates of a point and returns the identity of the Visual Gadget in which the point is located, taking transformations and translations into account. The Routine  begins at block , where the location of the input point is received in container coordinates. The Routine  then continues to block , where the CURRENT_NODE variable is set to the node at the top of the window tree or sub-tree. From block , the Routine  continues to block , where a determination is made as to whether the point is in the Visual Gadget identified by the current node. If the point is not in the Visual Gadget identified by the current node, the point is also not in any of the Visual Gadgets identified by the node's children, so the Routine  branches to block , where it ends. If the point is in the Visual Gadget identified by the current node, the Routine  continues from block  to block , where any translation or transformation required at the node is applied to the input point. In this manner, the input point is translated or transformed into the same space as the visual object identified at the current node.","From block , the Routine  continues to block , where a determination is made as to whether the current node has children. If the current node does not have any children, the Routine  branches to block . Arrival at block  indicates that the point must be in the current node and, therefore, the current node is returned. The Routine  then continues to block  to block , where it ends.","If, at block , it is determined that the current node has children, the Routine  continues to block , where a test is made of a child of the current node. The Routine  then continues from block  to block , where a determination is made as to whether the point is located within the child of the current node. If the point is not located within the child, the Routine  branches to block , where a determination is made as to whether the current node has additional children. If the current node has no additional children, the Routine  branches to block . Arrival at block  indicates that the point is in the child node and the identity of the child node is returned. The Routine  then continues from block  to block , where it ends. If, at block , it is determined that the current node has additional children, the Routine  continues to block , where the next child is identified. The next child is then tested at blocks , , and  in a similar fashion as that described above.","If, at block , it is determined that the point is within the child node, the Routine  continues to block  where the CURRENT_NODE variable is set to the child node. The Routine  then returns to block , where the child node is tested in a similar manner to its parent. In this manner, the window tree is iteratively parsed to identify the child that contains the input point.","Referring now to , an illustrative Routine  will be described for implementing the DIRECT_POINT routine. As mentioned briefly above, the DIRECT_POINT routine converts container coordinates that are in a known Visual Gadget into coordinates relative to the Visual Gadget. The Routine  begins at block , where the identity of the node containing the Visual Gadget and the container coordinates are received. From block , the Routine  continues to block , where the window tree is traversed from the identified node to the root, pushing each node on the stack. From block , the Routine  continues to block , where the window tree is traversed from the root back down to the identified node. At each node, the properties relating to the node are \u201cpopped\u201d off of the stack and the coordinates of the point are converted into coordinates relative to the node. In this manner, the container coordinates are converted into coordinates relative to the identified Visual Gadget. The Routine  ends at block .","Referring now to , an illustrative Routine  for implementing the MAP_POINTS routine will be described. As mentioned briefly above, the MAP_POINTS routine converts coordinates relative to one Visual Gadget in the window tree into coordinates relative to another Visual Gadget in the window tree. The Routine  begins at block , where the coordinates are received. The Routine  continues to block , where the window tree is traversed from the node identifying the Visual Gadget from which the coordinates are to be converted to the parent of the Visual Gadget to which the coordinates are to be converted. At each node, any necessary translation or transformation is applied.","From block , the Routine  continues to block  where the window tree is traversed from the nearest parent to the node identifying the Visual Gadget to which the coordinates are to be converted. At each node appropriate translations and transformations are applied. In this manner, the coordinates of a point relative to one Visual Gadget in the window tree may be converted to coordinates relative to another Visual Gadget taking translations and transformations into account.","In light of the above, it should be appreciated by those skilled in the art that the present invention provides a method, apparatus, and computer-readable medium for providing high-performance rendering and hit-testing of a window tree. While an actual embodiment of the invention has been illustrated and described, it will be appreciated that various changes can be made therein without departing from the spirit and scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing aspects and many of the attendant advantages of this invention will become more readily appreciated as the same become better understood by reference to the following detailed description, when taken in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 6A and 6B"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6C"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 6D and 6E"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
