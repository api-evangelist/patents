---
title: Protection domains for a computer operating system
abstract: A protection domain system is implemented to provide protection for applications executing in a computing environment. Protection domains are allocated system resources and may contain executing tasks. The protection domain system may allow tasks to access resources in other protection domains to which attachments have been made. Attachment is transparent to the software developer. The protection domain system provides flexibility in implementing operating system services and defining protection hierarchies.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08359575&OS=08359575&RS=08359575
owner: Wind River Systems, Inc.
number: 08359575
owner_city: Alameda
owner_country: US
publication_date: 20070430
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["PRIORITY CLAIM","BACKGROUND INFORMATION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application is a Divisional application of U.S. patent application Ser. No. 09\/480,309 filed on Jan. 10, 2000 now U.S. Pat. No. 7,213,247 entitled \u201cProtection Domains for a Computer Operating System.\u201d The entire disclosure of this prior application is considered as being part of the disclosure of the accompanying application and hereby expressly incorporated by reference herein.","Traditional multitasking operating systems (e.g., UNIX, Windows) have been implemented in computing environments to provide a way to allocate the resources of the computing environment (e.g., CPU, memory, Input\/Output (I\/O) devices) among various user programs that may be running simultaneously in the computing environment. The operating system itself comprises a number of functions (executable code) and data structures that may be used to implement the resource allocation services of the operating system.","Operating systems have also been implemented in a so-called \u201cobject oriented\u201d manner. That is, when a particular function and\/or data structure (defined by a \u201cclass\u201d definition) is requested, the operating system creates (\u201cinstantiates\u201d) an \u201cobject\u201d that uses executable code and\/or data structure definitions specified in the class definition. Such objects thus may contain executable code, data structures, or both. Objects that perform actions are typically referred to as \u201ctasks\u201d (also known as \u201cthreads\u201d), and a collection of tasks may be referred to as a \u201cprocess.\u201d Upon loading and execution of the operating system into the computing environment, system tasks and processes will be created in order to support the resource allocation needs of the system. User applications likewise upon execution may cause the creation of tasks (\u201cuser tasks\u201d), processes (\u201cuser processes\u201d), and other objects in order to perform the actions desired from the application.","In order to protect the operating system and each task running in the computing environment from interference from other tasks also running in the computing environment, typical operating systems apportion the computing environment's execution \u201cspace\u201d (e.g., its memory) into a \u201csystem\u201d space and a \u201cuser\u201d space. The system space includes the operating system tasks, while the user space includes any user tasks. Typically, operating systems are designed so that user tasks cannot directly access the memory apportioned to system tasks (and also may not access the memory allocated to other user tasks). The operating system itself, however, can access all portions of memory.","Conceptually, this \u201cprotection model\u201d is illustrated by . In a computer system  controlled by an operating system , there may be any number of user processes  and system tasks  executing at one time. User processes  each include a number of user tasks . Because each user process  is only allocated a portion of the system memory, the operating system  may restrict access by any user task  affiliated with a particular user process  to the memory allocated to another process. Typically, however, system tasks  have unrestricted access to each other and each user process  (indicated by direct connections ).","Additional protection may be provided by the CPU of the computing environment through the use of protected processing modes. For example, a CPU may provide \u201csupervisor\u201d and \u201cuser\u201d modes of operation, where supervisor mode allows full use of all CPU instructions and facilities and user mode restricts the use of certain system critical instructions and facilities. Typical operating systems designate system processes to run in supervisor mode and user processes to run in user mode.","There may be instances, however, when a user task desires access to facilities controlled by the operating system. For example, a user task may want access to a network I\/O connection, the control of which is delegated to a system task. In order to make such access, the user task is required to request execution of the system functions that perform the desired actions via a \u201csystem call\u201d, typically implemented via a special instruction used to cause the processor executing the code to \u201ctrap\u201d to a trap routine (implemented in the system software) that makes a function call to the desired facilities of the operating system. Thus, the user task executing the system call cannot directly access the instructions and data structures of the system functions it wishes to execute, but rather must employ a special access procedure (represented in  as connections ). Furthermore, since the user task is not permitted access to system resources, another task must be created by the operating system in the system space in order to perform the requested action. While this procedure protects the operating system from potential interference caused by user tasks, it increases system processing overhead (and thus increases execution time).","There may also be instances where it is desirable to allow a user process to access functions provided in other user processes. For example, it is desirable to implement applications in a modular fashion, and to re-use modules already implemented by other applications. Under traditional operating system implementations, such re-usable code modules (called \u201cshared libraries\u201d) may be implemented in one of two ways. First, the shared library can be implemented in the user space, and any task that desires access to a function of the shared library may be allowed to directly call the function. This first implementation may be undesirable because it allows errant or malicious tasks to make changes to the shared library that may permanently corrupt the library. Second, the shared library can be implemented within the operating system space, and any user task that desires access to a function of the shared library must perform an indirect call to the system (the system call described above). Although implementing the shared library within the system provides protection from corruption, execution time is increased due to the overhead incurred from the system trap. Moreover, if the shared library software is not carefully designed and implemented, erroneous shared library functions can interfere with other system processes, potentially causing damage to the operating system.","Certain operating systems, called \u201creal-time operating systems,\u201d have been developed to provide a more controlled environment for the execution of application programs. Real-time operating systems are designed to be \u201cdeterministic\u201d in their behavior\u2014i.e. , responses to events can be expected to occur within a known time of the occurrence of the event, without fail. Determinism is particularly necessary in \u201cmission-critical\u201d applications, although it is generally desirable for all operating systems. Real-time operating systems are therefore implemented to execute as efficiently as possible with a minimum of overhead. As a result, prior real-time operating systems have typically employed relatively simplistic protection models for system and user process\u2014typically all processes execute in the same space, thus allowing direct access to all system resources by all user tasks (system calls can be made directly, without a trap instruction). This protection model provides the fastest execution speed, but is deficient in providing system protection.","Certain operating systems have also been implemented in so-called \u201cembedded\u201d computing environments\u2014for example, an electronic device that includes a computer system embedded within the device (e.g., automobiles, medical devices, cellular phones).","Embedded computing environments tend to include less resources than standard \u201cdesktop\u201d PC-type computing environments, for example, less memory may be used and a limited set of I\/O devices may be supported. Embedded computing environments also tend to vary widely, using different CPUs and other hardware. As a result, operating systems used in embedded computing environments are designed to be portable across multiple processor environments and scalable to the particular hardware and functionality of the electronic device. The need for portability and scalability make its beneficial to implement the operating system using as little system space as possible and in a modular fashion. Real time operating systems (such as VxWorks\u00ae from Wind River Systems, Alameda, Calif.) are particularly suitable for use in the embedded computing environment.","While the simple protection model used in real-time operating systems was adequate for simple controlled implementations, the simple protection model impairs the use of real-time operating systems in more demanding computing environments. Such capability is desirable for use of the real-time operating system in the growing field of so-called \u201cinformation appliances\u201d\u2014electronic devices that provide desktop PC-type applications in smaller, non-desktop PC-type devices (mobile phones, personal digital assistants, television set-top units, etc.) These information appliances can allow for the execution of application programs from vendors other than the maker of the appliance (which may be more complex than typical embedded applications), and may also allow for networking between the appliance and other systems. Users of such devices have a lower tolerance for system delays and failures as are prevalent in desktop PC systems. In such an environment, the ability to provide a protection model that prevents interference by malfunctioning and\/or malicious tasks while maintaining high execution speeds, portability and system scalability is desirable.","According to an exemplary embodiment of the present invention, a computer system is described, comprising a system space having a number of memory locations and a number of protection domains, at least one of the number of protection domains owning a portion of the system space. Also according to the exemplary embodiment according to the present invention a protection domain is described, comprising a memory space and a protection view designating a set of protection domains for unrestricted memory access.","A first method is also described as part of the exemplary embodiment according to the present invention. The method includes loading a code module into a memory space of a first domain, the code module including an instruction having a symbol reference, and determining if the reference symbol is to an external location outside of the memory space. The method also includes generating a link stub for the symbol reference when the symbol reference is to an external location to access the external location, and redirecting the instruction to the link stub.","A second method is also described as part of the exemplary embodiment according to the present invention. The second method includes the steps of creating a task in a first domain, the task executing a number of instructions, executing a jump instruction in the number of instructions that refers to a link stub corresponding to an external location in a second domain, and executing the link stub.","A method for debugging a code module is also described as part of the exemplary embodiment according to the present invention. The method for debugging including the steps of loading a developmental code module into a protection domain in a computing environment, the protection domain having a protection view, the protection view being set to a first setting, and changing the protection view to a second setting to isolate the protection domain in the computing environment. The method also including the steps of performing a debugging operation using the developmental code module, and changing the protection view back to the first setting.","According to an embodiment of the present invention, a system is provided that implements a \u201cprotection domain\u201d system. The protection domain system segregates the computing environment into a number of \u201cprotection domains.\u201d Each protection domain is a \u201ccontainer\u201d for system resources, executable code and data structures, as well as for executing tasks and system objects (such as semaphores and message queues). Each resource and object in the system is \u201cowned\u201d by exactly one protection domain. The protection domain itself is a self-contained entity, and may be isolated from other system resources and objects to prevent tasks executing in the protection domain from potentially interfering with resources and objects owned by other protection domains (and vice versa).","The protection domain system also, however, provides mechanisms by which tasks executing in one protection domain may access resources and objects contained in a separate protection domain. Each protection domain includes a \u201cprotection view\u201d that defines the system resources and objects to which it has access (i.e., the resources and objects which it can \u201csee\u201d). By default, each protection domain has a protection view that includes only the system resources and objects contained within that protection domain. However, a protection domain may acquire access to the resources of other protection domains by \u201cattaching\u201d to these protection domains. When a first protection domain has obtained \u201cunprotected attachment\u201d to a second protection domain, the second protection domain is added to the protection view of the first protection domain. Executable code in the first protection domain may use \u201cunprotected links\u201d to selected functions in the second protection domain, allowing tasks executing in the first protection domain to use the resources and access the objects of the second protection domain with a minimum of execution overhead. Executable code in the first protection domain may also be linked to data structures or specific memory addresses in the second protection domain without restriction.","Unrestricted access by all tasks executing in one protection domain to all the resources and objects of another protection domain may not be desirable, however, for reasons of system protection and security. The protection domain system provides a further mechanism whereby individual tasks executing in a first protection domain may access resources or objects contained in a second protection domain, but without adding the second protection domain to the protection view of the first protection domain. This access is achieved by \u201cprotected attachment\u201d of the first protection domain to the second protection domain via a \u201cprotected link\u201d between executable code in the first protection domain and selected functions in the second protection domain. Using the protected link, a task running in the first protection domain may, for example, make a direct function call to a function existing in the second protection domain, without the need to alter the protection view of the first protection domain. Tasks in the first protection domain are prevented from accessing the second protection domain except through this protected link, thus preventing unauthorized accesses of functions and data in the second protection domain. As will be described below, protected linking can be achieved without the need to use different code instructions for protected and unprotected accesses (increasing implementation flexibility), and without the need to create separate tasks in the protected protection domain to perform the desired actions.","This protection domain system according to the present invention allows the operating system to dynamically allocate system resources among processes and flexibly implements and enforces a protection hierarchy. This protection hierarchy can be formulated to control the impact of poorly written or malicious applications on the operating system and other applications running in the computer system, in a manner that is transparent to applications developers and incurs minimal execution overhead. The protection domain system can also enable modular software implementations and development without sacrificing system protection or incurring extensive overhead.","An exemplary embodiment of a computing environment implementing a protection domain system according to the present invention is illustrated by .  is a block diagram of an exemplary computer system . Computer system  includes a CPU , which is coupled to a physical memory system  and a number of I\/O systems . Connection of the CPU  to the physical memory system  and the number of I\/O systems  may be according to any of the well known system architectures (e.g., PCI bus) and may include additional systems in order to achieve connectivity. I\/O systems  may comprise any of the well known input or output systems used in electronic devices (e.g., key pad, display, pointing device, modem, network connection). Physical memory system  may include RAM or other memory storage systems operational memory, and read only memory and\/or other non-volatile storage systems for storage of software (an operating system, other applications) to be executed in computer system . Alternately, software may be stored externally of computer system  and accessed from one of the I\/O systems  (e.g., via a network connection). CPU  may also include a memory management unit (MMU, not shown) for implementing virtual memory mapping, caching, privilege checking and other memory management functions, as is well known.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 3","FIG. 3"],"b":["110","100","110","100","100","110","110","110","110","110"]},"System space  includes an operating system , which controls access to all system resources (such as physical memory system  and I\/O systems ). Operating system  includes executable code and data structures, as well as a number executing tasks and system objects that perform system control functions (e.g., context switching between tasks). Operating system  may be loaded into system space , for example, upon power up of the computer system , via a \u201cbootstrap\u201d loader.","Exemplary operating system  according to the present invention implements a protection domain system in which all resources and objects are contained within protection domains. The exemplary protection domain system is object oriented: each protection domain itself is actual a system object. The structure of each protection domain is defined through a protection domain \u201cclass\u201d definition. A protection domain may be created, for example, by instantiating a protection domain object based on the protection domain class. Only the operating system  can create or modify (or destroy) a protection domain, although user tasks can request such actions through a protection domain application programming interface (API) provided by the operating system . A protection domain object is owned by the protection domain that requested its creation.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 4","b":["120","120"],"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["a memory space ,","a protection view ,","a zero or more code modules  containing executable code and\/or data structures (including memory mapped I\/O locations),","a collection of protection domain \u201cattributes\u201d ,","a linking table  and a symbol table  including a list of entry points ,","zero or more tasks , and","zero or more system objects  (e.g., semaphores, file descriptors, message queues, watchdogs).\n\nMemory space  comprises a number of virtual memory locations from system space . These memory locations need not be contiguous, and may include memory mapped I\/O locations. The amount of memory allocated to memory space  by operating system  may be specified at the time protection domain  is created. Additional memory may be dynamically allocated to memory space  by operating system  as needed from any free memory in system space .\n"]}}}},"Upon creation of protection domain , the protection view  of the protection domain  will be established. The protection view  represents the protection domains to which tasks executing in the protection domain  may have access. An exemplary protection view data structure  that may be used to represent the protection view  is illustrated in . Protection view data structure  is a bit map, in which each protection domain in system space  is represented by a single bit. Where a bit is set, the protection domain  has unprotected access to the corresponding protection domain in system space . Where a bit is not set, unprotected access is not permitted. Operating system  may maintain information for mapping each bit to an existing protection domain. The size of the bit map defines the maximum number of protection domains supported in the system space ; in this example, sixty-four protection domains are possible. Note that other data structures could also be used to represent the protection view  which avoid this limitation.","The default condition for protection domain  is a protection view  that includes only the resources and objects of protection domain , and no other protection domains. In the exemplary bit map of protection view data structure , this default condition may be represented by setting the bit corresponding to protection domain , while leaving the remaining bits cleared (value zero). Protection domain  may expand its protection view  by being \u201cattached\u201d to other protection domains during the linking process when code modules or other objects are loaded into protection domain , which will be further described below.","Also upon creation of protection domain , a set of protection domain attributes  may be specified. These attributes may be used to control the actions allowed by tasks executing in protection domain , the linking permitted between protection domain  and other protection domains in the system space , and other characteristics of the protection domain . Among the protection domain attributes  supported by protection domain  are:\n\n","Also upon creation of protection domain , memory space  may be loaded with a number of code modules  (this loading may also be deferred until a later time). A code module  may contain executable code, data structures and\/or other information to be used by a loader application during the loading process. The executable code will include a number of instructions, which may include instructions that reference other executable code or data structures outside of code module  (e.g., via a \u201cjump\u201d or \u201cbranch\u201d instruction to execute a function). These references may be made using \u201csymbols\u201d that are intended to represent the memory location of the desired code or data structure. In order to determine (\u201cresolve\u201d) the memory address value of these symbols, the loading of code modules  may include a linking process (described below) that attempts to resolve symbol references by searching for other occurrences of the symbol either in other code modules  already loaded into the protection domain , or in code modules loaded into other protection domains. Note that symbols may also include the memory address itself (in which case no resolution is needed, although other linking activities may still be performed, as described below).","Symbols that reference locations external to protection domain  indicate that a \u201clink\u201d is needed between protection domain  and the protection domain that owns the external location referenced by the symbol. Inter-protection domain linking is achieved through the use of linking table  and symbol table . An exemplary linking table  is shown in . A linking table entry  is provided for each symbol that requires an inter-protection domain link. The linking table entry includes the symbol itself, and a link stub , which comprises a number of executable instructions used to access the external location. A simple link stub may comprise only a jump instruction to cause a jump to the address of the external location, although additional instructions may be included in the link stub as needed to implement the protection goals of the system. As part of the loading and linking process (described below), instructions that include symbols referencing external locations are \u201credirected\u201d to the linking table entry  corresponding to the symbol (and specifically to the link stub  corresponding to the symbol).","Symbol table  is used in conjunction with linking table . An exemplary symbol table  is shown in . A symbol table entry is provided for each symbol used in protection domain . The symbol table entry includes the symbol itself, the address for the memory location referenced by the symbol, and whether the symbol may be used as an entry point. Symbol table  may be used for linking within protection domain , as well as for inter-protection domain linking. Symbols that are permitted to be linked by code modules outside of protection domain  are indicated to be entry points , by specifying such in the entry point field of symbol table .","The linking table  and entry points  enable a number of beneficial features of the protection domain system. First, executable code does not have to be written to take into account any protection facilities, and can simply call external functions as if those functions were internal to the protection domain. The distinction between protected and unprotected accesses is not forced onto the code writer, but rather is a function of the protection domain. Second, addressing limitations of some instructions of some CPUs can be avoided, because all inter-protection domain function calls are handled through the linking table , not the instruction making the call. Third, the protection scheme can be enforced both when code modules  are linked (in the process of creating the linking table ) and while tasks are running (using the link stubs ).","Protection domain  may also include authorization information  that may be used, for example, in permission checking for attachment of protection domains and other security checking operations, as will be further described below.","Protection domain  may also own tasks  and system objects . Protection domain  may include no tasks (purely a data buffer or \u201cpassive shared library\u201d of functions) or a number of tasks that either have been created (\u201cspawned\u201d) in the protection domain  (\u201cnative\u201d tasks) or are \u201cvisiting\u201d protection domain  (i.e., native to another protection domain). Tasks may be spawned, for example, upon completion of loading and linking code modules  (described below). System objects  are created by the operating system  at the request of a task executing in protection domain . Such system objects  may include semaphores, message queues, and watchdog timers (as are well known), as well as other protection domains. The structure and operation of tasks in the protection domain system will be described in more detail below.","As mentioned previously, all system resources and objects are owned by a protection domain. The system space  will therefore include at least one protection domain\u2014a protection domain that owns the code modules and other objects associated with the operating system .  shows operating system  contained within a single \u201csystem protection domain\u201d . Upon loading and execution of the operating system , one of the first actions performed during loading is to create the system protection domain. The system protection domain initially owns all system resources and objects, and ultimately owns all other protection domains created within the system space . The system protection domain may have a protection view that includes all protection domains in the system, so that any task executing in the system protection domain may access executable code and data in any protection domain.","In the current example, all protection domains  are objects that are created and maintained by the operating system . Accordingly, operating system  maintains a \u201cprotection domain list\u201d data structure that tracks all protection domains currently in existence in the system space .  illustrates an exemplary protection domain list data structure . The protection domain list  includes a record  for the system protection domain object, and records for any other protection domain objects in existence. An exemplary record  in the protection domain list  may include entries for: the protection domain name (entry ), memory mapping information for the protection domain (entry ), a list of code modules downloaded into the protection domain (entry ), a list of system objects owned by the protection domain (entry ), the protection domain attributes  (entry ), a list of global symbols provided by the protection domain (entry ), and a count of the number of tasks executing in the protection domain (entry ). Other information may be stored in the protection domain list , depending on the specific implementation of the protection domain system. Protection domain list  allows the operating system to reclaim resources used by a protection domain when the protection domain is no longer needed (\u201cdestroyed\u201d).","As mentioned above, the protection view represents the system resources available to objects in a particular protection domain (i.e., the resources and objects that can be \u201cseen\u201d in the protection domain). Each protection domain has a protection view that by default includes only its own memory space and system objects. In this default condition, the protection domain cannot access any resources or objects that exist in other protection domains. Thus, this limited protection view prevents direct linking of executable code to the resources and objects of other protection domains and prevents tasks executing in the protection domain from accessing the resources and objects of other protection domains, preventing possible corruption of the resources and objects of other applications or the operating system.","There may be instances when access to other protection domains is desirable. For example, an application may want to place a library of commonly used functions or a common data structure in a separate protection domain in order to allow other applications to access these functions and data structures (without allowing access to the application's own protection domain). Also, applications will need to access the system protection domain in order to access resources and objects controlled by the operating system . The protection domain system permits such access through a mechanism called \u201cattachment,\u201d which may be employed when a code module is loaded into a protection domain and needs to link to executable code and other objects located outside the protection domain. Attachment may be unprotected, where the protection view of the protection domain is changed to include the attached protection domain, or may be protected, where only particular protected links are permitted between each protection domain.","The following discussion will illustrate some exemplary attachment mechanisms and exemplary processes by which unprotected links and protected links may be established between protection domains. The discussion will be directed to the general case of the implementation of the exemplary protection domain system, and to a specific example of an application  being loaded into system space  where operating system  has already been loaded and is executing in system protection domain ","The specific example of the loading of application  is shown in . Application  comprises two code modules , (each having a size of 10000 h bytes), which are each intended to use separate protection domains , one for application-specific functions (executable code) and data structures, and one for storage of common functions and data (a \u201cshared library\u201d) that will be used by the application  and possibly other applications later loaded. Code module includes executable code that includes instructions that reference functions called \u201cfoo( )\u201d and \u201cgoo( ),\u201d neither of which are part of code module . Code module includes executable code for the function \u201cfoo( ).\u201d Operating system  includes executable code for the function \u201cgoo( ).\u201d Since these functions \u201cfoo( )\u201d and \u201cgoo( )\u201d are not present in code module , their calls are represented by a symbol (for example, the function name) that acts as a surrogate for the address of the memory location of the entry point for the function. Code module will allow other code modules to link to its functions (such as \u201cfoo( )\u201d), provided they provide proper authorization. Function \u201cfoo( )\u201d has as its entry point a relative address of \u201c00001110h\u201d (i.e., relative to the first instruction in code module ), and code module includes a symbol for foo( ) indicating this relative address. Operating system  will not permit access to its protection domain, but will allow calls to \u201cgoo( )\u201d through protected linkage. Function \u201cgoo( )\u201d has as its entry point an address of \u201c00001000h\u201d.",{"@attributes":{"id":"p-0060","num":"0070"},"figref":"FIG. 8","b":["302","112","110","112","114","304","102","103","126","114","102"],"i":"b "},"In step , the protection domain  into which the code module will be loaded is determined. Code modules can be loaded into existing protection domains, or newly created protection domains (or protection domains built in the development system), which may be indicated by the instruction provided to perform the loading process or as part of the code module itself. Where a code module is being loaded into an existing protection domain, this determination may also include checking the protection domain attributes  to determine whether the target protection domain permits code module loading. In this example, new protection domain is created for code module by requesting that the operating system  create a new protection domain object.  shows protection domain , indicating it has been allocated addresses 0001000h to 0001FFFFh. The addresses for this protection domain are provided to the loader. Protection domain is created with protection domain attributes (not shown) that indicate that other protection domains may make unprotected attachment to the resources and objects of protection domain ","In step , the memory allocation of the protection domain's memory space  is compared to the code module to determine if enough memory has been allocated. If additional memory is needed, a request is made to the operating system to allocate additional memory to the protection domain. In the present case, where protection domain has been created as part of the loading of code module , the memory needed can be specified as part of the protection domain creation request.","In step , the code module is loaded into the memory space  of the protection domain. The actual memory locations that will receive the executable code and data structures of code module can be determined based on the size of the memory space, the presence of other code modules in the memory space, and other system-specific factors. In this example, code module is loaded into protection domain such that the executable code for function foo( ) begins at address 00011110h.","Loading also causes the protection domain's symbol table  to be updated to include symbols identified in the code module. A symbol table used in the present example for protection domain is shown in . In this case, the symbol for the function \u201cfoo( )\u201d is loaded into symbol table , along with its corresponding address (which at this point is still its relative address\u2014\u201c00001110\u201d) and an indication that it is an entry point for external linking.","In step , the executable code of the code module is \u201crelocated\u201d based on its actual memory address. When the code module is loaded into the protection domain's memory space , address \u201coffsets\u201d are generated that represent the quantity that should be added to memory references in the executable code in order to reflect the actual memory locations of the referenced items. Alternately, a code module may specify it can only be loaded into particular memory locations (unrelocatable code), which can be indicated to the operating system in step  so that the desired memory locations can be allocated. The protection domain symbol table  is updated to include the actual addresses of the symbols of the code module. In this example, an offset of \u201c00010000\u201d is added to each memory reference in code module and to each entry in symbol table (including \u201cfoo\u201d, which now has a corresponding address of \u201c00011110\u201d, matching its actual entry point).","In step , the executable code of the loaded code module is \u201clinked.\u201d Linking involves resolving addresses for symbols referenced in the executable code of the code module. The executable code is parsed and symbols are compared against the protection domain symbol table . When a symbol is found in the symbol table , the corresponding address for the symbols is substituted for the symbol in the executable code. When the symbol is not found in the protection domain symbol table , a linking table entry  is created in the protection domain linking table , indicating that the executable code is referencing an external location outside of the protection domain . The address of the linking table entry  is then substituted for the symbol in the executable code. If a linking table entry  for the unresolved symbol already exists, that linking table entry may be used. In this case, no external function calls are made by the executable code of code module , so no linking table entries are made in linking table ","In step , inter-protection domain links are created using the protection domain linking table . The details of this procedure are discussed below (in the discussion of the linking of code module ).","Once the code module has been loaded and linked, the loader determines whether additional code modules need to be loaded (step ). If not, the loader execution is complete (step ). Alternatively, the loader can be instructed to begin execution of the loaded code modules by requesting the creation of a task (step ). In such a case, the operating system  can create a task owned by the protection domain, executing in the protection domain using the executable code of the loaded code module. In this example, code module still needs to be loaded, so the loader repeats steps - in order to load code module ","The loading of code module (the application specific executable code and data structures) begins by retrieving code module from non-volatile memory system of physical memory system  (step ). In this example, since code module specifies that creation of a new protection domain is needed to hold it, protection domain is created (step ) via request to operating system . This protection domain is allocated memory addresses \u201c00090000\u201d to \u201c0009FFFF\u201d (step ), corresponding to the size of code module . The executable code and data structures of code module are loaded into memory space of protection domain (step ), and any internal symbols are entered in symbol table . No entry points are provided by code module , so none of the entries in symbol table are designated as entry points . Memory references and symbol corresponding addresses are adjusted using the offset \u201c00090000\u201d (step ).","In step , the executable code of code module is linked to resolve symbol addresses. References to internal symbols are resolved based on the symbol table . Symbols not found in symbol table generate linking table entries  in linking table for inter-protection domain references, and the addresses for the entries in linking table are substituted for the symbols in the executable code.","In step , inter-protection domain links are created using the protection domain linking table . The sub-steps of this process are shown in the flow chart of , and will be first explained as applied to a generic protection domain  and then as applied to the example of . In step , the symbol name from an unresolved entry in a protection domain's linking table  is used to search the symbol tables  of each protection domain  for a matching symbol. This search may be simplified by maintaining a \u201cglobal\u201d symbol table for all entry points exposed by protection domains in the operating system. If no match is found (step ), a default address is entered for the symbol in the link stub  of the linking table entry  for the symbol, indicating that no link has been established (step ), and any remaining linking table entries  are processed. Alternately, an error may be generated causing the loading process to abort or, if the linking process is being performed on an development system, a notification can be provided indicating that no link has been established for the symbol.","When a match is found, the protection view  of the protection domain is checked to determine if the corresponding address for the symbol is within the protection view of the protection domain (step ). If so, the corresponding address for the symbol is inserted into the link stub  of the linking table entry  for the symbol (step ). If the symbol address is outside the protection view of the protection domain, a request is made to the operating system  to permit attachment to the protection domain containing the symbol (step ). This request may include protection domain authorization information , which can be used to verify the authority to make an attachment. The operating system  consults the protection domain list  to determine the protection domain attributes  of the protection domain to which attachment is being requested (step ). If no attachment is permitted, a default address is entered for the symbol in the link stub for the symbol's linking table entry, indicating that no link has been established (step ), and any remaining linking table entries are processed. Alternately, an error may be generated causing the loading process to abort or, if the linking process is being performed on an development system, a notification can be provided indicating that no link has been established for the symbol.","If the protection domain containing the symbol permits unprotected attachment by the requesting protection domain, the protection view  of the requesting protection domain is altered to include the symbol's protection domain (step ). The corresponding address for the symbol is then inserted into the link stub of the linking table entry for the symbol (step ), and any remaining linking table entries are processed. If the protection domain containing the symbol permits only protected attachment by the requesting protection domain, the protection views of the protection domains are not altered, but the corresponding address for the symbol is still inserted into the link stub of the linking table entry for the symbol (step ), and any remaining linking table entries are processed. Note that by not adding the protection domain of the symbol to the protection view of the calling code module, the memory address for the symbol will be outside of the memory accessible by the protection domain of the calling code module.","Applying the inter-protection domain linking steps described above to the linking of code module , the entry points  for all protection domains are searched for the symbol \u201cfoo\u201d (step ), which is the first entry in linking table (see ). \u201cFoo\u201d is found (step ) in the symbol table of protection domain (the shared library, see ), which has not yet been added to the protection view of protection domain (step ). Attachment of protection domain to protection domain is requested (step ), and unprotected attachment is granted. (step ). Protection domain is added to the protection view of protection domain (step ). The corresponding address for the symbol \u201cfoo\u201d is inserted into the link stub of the linking table entry for the symbol \u201cfoo\u201d (step ), such that the link stub for the linking table entry for the symbol \u201cfoo\u201d will now perform a jump to the corresponding address \u201c00011110\u201d (which is the location of the function \u201cfoo\u201d in the memory space of protection domain ).","The process is repeated for the linking table entry for symbol \u201cgoo\u201d in linking table . The entry points  for all protection domains are searched for the symbol \u201cgoo\u201d (step ). \u201cGoo\u201d is found (step ) in the symbol table of protection domain (the system protection domain), which has not been added to the protection view of protection domain (step ). Attachment of protection domain to protection domain is requested (step ), however system protection domain does not permit unprotected attachment to its resources, and will only grant protected attachment (step ). As a result, the corresponding address for the symbol \u201cgoo\u201d is inserted into linking table (step ), such that the link stub for the linking table entry for the symbol \u201cgoo\u201d will perform a jump to the corresponding address \u201c00001000\u201d (which is the location of the function \u201cgoo\u201d in the memory space of system protection domain ). The protection view of protection domain , however, is not altered.","Once the code module has been loaded and linked, the loader determines whether additional code modules need to be loaded (step ). Since no more code modules are specified by application , the loader execution is complete (step ). Alternatively, the loader can be instructed to begin execution of the loaded code modules by requesting the creation of a task (step ). In such a case, the operating system  can create a task owned by the protection domain, executing in the protection domain using the executable code of the loaded code module (step ).","The exemplary loading and linking process provides system protection by using the protection domain system to prevent improper or unauthorized linking against the contents of protection domains. Thus the loading and linking process provides a method to enforce the system protection provided by the protection domain system at the time of the loading and linking of applications.","The protection domain system also provides beneficial system protection during the course of application execution. Tasks executing in the system space  using the protection domain system are prevented from making unpermitted accesses of memory locations outside of the specified protection view, thus further protecting the system from erroneous or malicious accesses that may not have been eliminated during the linking process.",{"@attributes":{"id":"p-0079","num":"0089"},"figref":"FIG. 14","b":["124","124","134","124","135","123","134","123","135","134","136","137"]},"The following example will illustrate the execution of an exemplary task spawned in protection domain to execute application . Task spawning may occur at the completion of the loading and linking process for application , or at a later time through a request to the operating system  to create a task object. Task is initialized to execute the executable code of code module Task is also initialized with a task protection view equal to the protection view  of protection domain , which in this case includes protection domain ","Eventually, execution of task will reach the instruction that references the function foo( ). The linking process has redirected this reference to the link stub  for the symbol \u201cfoo\u201d in linking table , which causes a direct jump to the location \u201c00011110\u201d (see ), which is the entry point for the function \u201cfoo( ).\u201d Since protection domain is within the protection view of protection domain , the jump to the memory location for function \u201cfooo\u201d is within the permissible address range for memory accesses (which may be enforced, for example, by the MMU of CPU ). Task continues execution in protection domain , executing the function \u201cfoo( ).\u201d When execution of the function \u201cfoo( )\u201d has completed, task returns to protection domain and continues executing the executable code of code module . Note that the only additional overhead that has been incurred using the protection domain system has been the additional link stub, which is minimally a single jump instruction.","Execution of task will eventually reach the instruction that references the function \u201cgoo( ),\u201d which will cause a redirection to the linking table , and execution of the link stub for the symbol \u201cgoo.\u201d The link stub for \u201cgoo\u201d attempts a jump to location \u201c00001000\u201d (see. ). However, memory location is allocated to the system protection domain , which is not in the protection view of task . As a result, the jump to address \u201c00001000\u201d causes the generation of a processor exception for a memory fault. This exception causes the execution of an exception handling routine in the operating system  to deal with the memory fault exception. This exception handling routine implements the instructions that allow the task to \u201cswitch\u201d to a protection domain outside of the task's protection view.",{"@attributes":{"id":"p-0083","num":"0093"},"figref":"FIG. 15","b":["124","402","124","136","404","135","137","406","136","112"],"i":["a","a ","a ","a ","a ","a"]},"In step , the task protection view is changed to include the protection view of protection domain owning the memory location to access\u2014in this case, the protection view of the system protection domain . The privilege mode of task is also changed, if the privilege mode of the called protection domain is different that the task's native privilege mode. In step , the exception handler sets the context information in task control block so that the next instruction executed by the task is the requested entry point\u2014in this case, memory location \u201c00001000,\u201d the entry point for function \u201cgoo( ).\u201d In step , execution of task recommences at the requested entry point\u2014here the function \u201cgoo( ).\u201d","Once execution of function \u201cgoo( )\u201d is completed, the reverse protection switch may employed to return the task to its previous protection domain. The protection switch stack is unwound, popping the return address for the function call and the pre-exception state information (task protection view, protection domain, processor privilege mode). The pre-exception state information is used to restore the task state information to pre-exception values, and execution is passed to the return address for the function call (for example, an instruction subsequent to the function call).","The exemplary protection switching mechanism described above allows a single task  to execute between any number of protection domains\u2014whether a protected or unprotected attachment exists\u2014without the use of different calling instructions in the executable code for either type of attachment. There is no need to instantiate additional tasks in each protection domain, since tasks may \u201cvisit\u201d each protection domain having resources to which access is needed. No complex and lengthy message passing schemes need to be implemented. Furthermore, because the protected link only causes the task protection view to be switched to include the protection domain of the called function, any other tasks also executing in the task's protection domain still cannot access the protection domain of the called function without using the protected link, thus protecting against unrestricted accesses.","Among the many implications of the protection domain system according to the present invention is that the operating system need not be implemented as a single, monolithic entity for protection purposes. The operating system itself can be divided into a number of protection domains, each of which employs protected links to allow access by user tasks, and system tasks.  illustrates an example of an operating system  which employs two protection domains: a kernel protection domain and a graphics protection domain . Kernel protection domain owns the core operating system code and objects (e.g., interrupt service routines), while graphics protection domain owns the executable code and other objects related to a graphical user interface (GUI) of the operating system . Kernel protection domain may provide access to its features via protected linking to entry points (which correspond to a kernel API provided by the operating system ). Likewise, graphics protection domain may provide access to its features via protected linking to entry points (which corresponds to a GUI API provided by the operating system ).","Separating operating system tasks is beneficial in a number of ways. It is possible to design the operating system in a modular fashion, such that only those modules which are needed in the computer system are implemented, which reduces the operating system's \u201cfootprint\u201d for those computer systems that are small and do not require certain operating system services. Also, by dividing the operating system into smaller protection domains, erroneous code executing in one portion of the operating system is less likely to corrupt other areas of the operating system that are in separate protection domains.","Another implication of the protection domain system according to the present invention is the ability to dynamically define the linkages (and thus the level of protection) between protection domains. The exemplary attachment mechanisms described above\u2014unprotected linking and protected linking\u2014both use the same calling instruction for function calls in any executable code written for use in the protection domain system. For example, executable code written in the protection domain system described above can use, for example, a jump instruction to a called function, regardless of whether an unprotected link or protected link is allowed. One of the ways in which the protection feature is enforced is at run time (i.e., when tasks are executing) is by comparing the function call against a protection view of the task executing the function call. Thus, whether the link is protected or unprotected may be dependent on the protection view of the particular task which is making the call.",{"@attributes":{"id":"p-0090","num":"0100"},"figref":"FIG. 17","b":["700","701","704","701","703","704","702","703","704","703","701","703","702","703","702","704","701","704","703","704"]},"A task  is created in protection domain  to run the executable code of the second application. Task  has a task protection view identical to that of protection domain ; that is, task  has a task protection view that includes protection domains  and . Task  may call a function in the shared library of protection domain , which is then executed over the unprotected link between protection domain  and protection domain . If the called function in the shared library then calls a function in protection domain  (i.e., a system function), the protection view of task  is checked as part of the function call. Because task  has a task protection view that includes protection domain , the function call to protection domain  is by unprotected link (e.g., no exception is generated), rather than by protected link as was the case before task  executed. Note that if the executable code of protection domain  was required to use different instructions to implement protected or unprotected linkage, task  would either be forced to use the linkage existing at link time (in this example, a protected linkage), or a separate protection domain (using a copy of the shared library of protection domain ) would need to be created to provide the unprotected link for task  (thereby increasing system resource usage).","Another implication of the protection domain system according to the present invention is the ability to flexibly configure the protection hierarchy of various protection domains in a computer system. Certain applications running in a computing environment may be more \u201ctrusted\u201d than others\u2014for example, applications written by certain programmers or vendors may be considered more \u201cfault-proof\u201d than others. Trusted applications, which are less likely to cause system corruption, may be allowed to make unprotected access, for example, to operating system functions, thus allowing these trusted applications to execute with low overhead in as fast a manner as possible. Untrusted applications may be allowed to make only protected access to system functions. The level of protection that is enforced against a particular application can be realized using the features of the protection domain system. Trusted applications can be described as being \u201cprivileged,\u201d in the sense that the application is privileged to make unprotected accesses to sensitive system resources (not in the sense of processor protection mode, although privileged applications may execute using a privileged processor mode as well).",{"@attributes":{"id":"p-0093","num":"0103"},"figref":"FIG. 17","b":["701","702","701","704","702","704"]},"Software development is another situation that benefits from the flexible protection hierarchy feature. Software development is typically performed in a development environment that includes a debugging tool that allows executable code under development to be examined for errors. During this development process, it may be desirable to have the maximum protection possible from programming errors in the code being developed, both as a way to uncover hidden programming errors and to prevent damage to other applications in the computer system (including the operating system). In such a case, the protection view of the protection domain(s) containing the executable code under development may be set such that their linkage to other (more stable) protection domains in the system is restricted to protected links.",{"@attributes":{"id":"p-0095","num":"0105"},"figref":"FIG. 18","b":"1002"},"In step , a debugging operation is performed for the code module. This debugging operation may use a debugging tool to allow run-time observation of the code module under development and other known debugging operations. Since the protection view of the protection domain of the code module under development does not include all other protection domains, tasks executing in the protection domain will only be permitted to make calls to functions outside the protection view via protected links. Although protected links in the present example incur additional execution overhead (due to the exception handling routine), during the debugging process this overhead is likely not to be critical. When debugging is complete, the protection view can be set to a privileged level to allow calls using unprotected links to those protection domains which are intended to be in the protection view (step ). This may be achieved, for example, using the protection level facility to manipulate the linking permissions of affected protection domains, either during system execution or prior to system execution (as part of a \u201cre-load\u201d of the affected protection domains).","Note that the protection domain system allows variation in the level of system protection for debugging purposes without the need to alter code modules during debugging. Because the exemplary protection system is implemented by managing the linkage between object modules and not by using specific instructions for protected calling methods, the same code module may be executed as is debugged, without the need for recompilation.","In the preceding specification, the invention has been described with reference to specific exemplary embodiments thereof. It will, however, be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims that follow. The specification and drawings are accordingly to be regarded in an illustrative rather than restrictive sense."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 9","FIG. 4"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 11","FIG. 4"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 12","FIG. 7"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 13","FIG. 7"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 14","FIG. 4"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 18"}]},"DETDESC":[{},{}]}
