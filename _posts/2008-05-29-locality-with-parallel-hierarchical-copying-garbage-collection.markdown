---
title: Locality with parallel hierarchical copying garbage collection
abstract: A garbage collection algorithm that achieves hierarchical copy order with parallel garbage collection threads. More specifically, the present invention provides a garbage collection method and system for copying objects from a from-space to a to-space. The method comprises the steps of (a) having multiple threads that simultaneously perform work for garbage collection (GC), (b) examining the placement of objects on blocks, and (c) changing the placement of objects on blocks based on step (b). Preferably, the method includes the additional step of calculating a placement of object(s) based on step (b), and using the result of the calculation for step (c). For example, the calculation may be used to increase the frequency of intra-block pointers and/or to increase the frequency of siblings on the same block.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08024379&OS=08024379&RS=08024379
owner: International Business Machines Corporation
number: 08024379
owner_city: Armonk
owner_country: US
publication_date: 20080529
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This application is a continuation application of application Ser. No. 11\/450,946, filed Jun. 9, 2006 now abandoned.","1. Field of the Invention","This invention generally relates to automatic memory management, and more specifically, the invention relates to methods and systems for copying garbage collection.","2. Background Art","In operation, computer programs spend a lot of time stalled in cache and Translation Lookaside Buffer (TLB) misses, because computation tends to be faster than memory access. For example, Adl-Tabatabai et al. report that the SPECjbb2000 benchmark spends 45% of its time stalled in misses on an Itanium processor [Ali-Reza Adl-Tabatabai, Richard L. Hudson, Mauricio J. Serrano, and Sreenivas Subramoney. Prefetch injection based on hardware monitoring and object metadata. In (PLDI), 2004]. Better locality reduces misses, and thus improves performance. For example, techniques like prefetching or cache-aware memory allocation improve locality, and can significantly speedup the performance of a program.","Locality is in part determined by the order of heap objects in memory. If two objects reside on the same cache line or page, then an access to one causes the system to fetch this cache line or page. A subsequent access to the other object is fast. Copying garbage collection (GC) can change the order of objects in memory. To improve locality, copying GC should strive to colocate related objects on the same cache line or page.","Copying GC traverses the graph of heap objects, copies objects when it reaches them, and recycles memory of unreachable objects afterwards. Consider copying a binary tree of objects, where each cache line can hold three objects. When the traversal uses a FIFO queue, the order is breadth-first and results in the cache line layout in . When the traversal uses a LIFO stack, the order is depth-first and results in the cache line layout in . In both cases, most cache lines hold unconnected objects. For example, breadth-first order colocates oand owith o, even though owill usually not be accessed together with oor o.","Intuitively, it is better if an object occupies the same cache line as its siblings, parents, or children. Hierarchical copy order achieves this (). Moon invented a hierarchical GC in 1984, and Wilson, Lam, and Moher improved it in 1991 [Paul R. Wilson, Michael S. Lam, and Thomas G. Moher. Effective \u201cstatic-graph\u201d reorganization to improve locality in a garbage-collected system. In (PLDI), 1991], calling it \u201chierarchical decomposition\u201d. The algorithms by Moon and by Wilson, Lam, and Moher use only a single GC thread. Using multiple parallel GC threads reduces GC cost, and most product GCs today are parallel.","An object of this invention is to reduce cache and TLB misses by changing the order in which a parallel garbage collector copies heap objects.","Another object of the present invention is to provide a garbage collection algorithm that achieves hierarchical copy order with parallel garbage collection threads.","A further object of this invention is to improve locality with parallel hierarchical copying garbage collection.","Another object of the invention is to provide a garbage collection algorithm that both reduces cache and TLB misses through hierarchical copying and also maintains good scaling on multiprocessors.","These and other objectives are attained with a garbage collection algorithm that achieves hierarchical copy order with parallel garbage collection threads. More specifically, the present invention provides a garbage collection method and system. The term \u201cblock\u201d as used herein refers to a cache line or page or other unit of OS+HW support for memory hierarchy.","The preferred embodiment of the invention, described in detail below, reduces cache and TLB misses and, in this way, improves program run time. Also, parallel garbage collection improves scaling on multi-processor machines.","Further benefits and advantages of the invention will become apparent from a consideration of the following detailed description, given with reference to the accompanying drawings, which specify and show preferred embodiments of the invention.","In accordance with the present invention, a garbage collection algorithm is provided that achieves hierarchical copy order with parallel garbage collection threads.  illustrate, as an example, one suitable computer system in which the present invention may be used. This computer system , according to the present example, includes a controller\/processor , which processes instructions, performs calculations, and manages the flow of information through the computer system . Additionally, the controller\/processor  is communicatively coupled with program memory . Included within program memory  are a garbage collector , operating system platform , Java Programming Language , Java Virtual Machine (JVM) , glue software , a memory allocator , Java application , a compiler , and a type profiler . It should be noted that while the present invention is demonstrated using the Java Programming Language, it would be obvious to those of ordinary skill in the art, in view of the present discussion, that alternative embodiments of the invention are not limited to a particular computer programming language.","The operating system platform  manages resources, such as the data stored in data memory , the scheduling of tasks, and processes the operation of the garbage collector  in the program memory . The operating system platform  also manages a graphical display interface (not shown) that directs output to a monitor  having a display screen , a user input interface (not shown) that receives inputs from the keyboard  and the mouse , and communication network interfaces (not shown) for communicating with a network link (not shown). Additionally, the operating system platform  also manages many other basic tasks of the computer system  in a manner well known to those of ordinary skill in the art.","Glue software  may include drivers, stacks, and low level application programming interfaces (API's) and provides basic functional components for use by the operating system platform  and by compatible applications that run on the operating system platform for managing communications with resources and processes in the computing system .","Each computer system  may include, inter alia, one or more computers and at least a computer readable medium . The computers preferably include means  for reading and\/or writing to the computer readable medium . The computer readable medium  allows a computer system  to read data, instructions, messages or message packets, and other computer readable information from the computer readable medium. The computer readable medium, for example, may include non-volatile memory, such as Floppy, ROM, Flash memory, disk drive memory, CD-ROM, and other permanent storage. It is useful, for example, for transporting information, such as data and computer instructions, between computer systems.","The present invention, as mentioned above, provides a garbage collection algorithm that achieves hierarchical copy order with parallel garbage collection threads. The prior art has not been able to achieve this. In order to best understand the significance and advantages of the present invention, several prior art garbage collection algorithms, shown in , are discussed below.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 4","i":["Communications of the ACM ","CACM"]},"Cheney's algorithm copies in breadth-first order (see ), because it scans gray objects first-in-first-out. One advantage of Cheney's algorithm is that it requires no separate stack or queue to keep track of its progress, saving space and keeping the implementation simple. Cheney's algorithm uses only one thread for garbage collection, it is not parallel.","Moon modified Cheney's algorithm to improve locality by copying in hierarchical order instead of breadth-first.  illustrates Moon's algorithm [David A. Moon. Garbage collection in a large Lisp system. In (), 1984]. To-space is now divided into blocks. As before, objects are copied by bumping the free pointer, which separates gray objects from empty space. But instead of just one scan pointer, Moon maintains two scan pointers. The primary scan pointer is always in the same block as the free pointer. For example, in , both the primary scan pointer and the free pointer point into block D.","If there are gray objects at the primary scan pointer, Moon scans them. If the free pointer reaches the next block (for example E), Moon advances the primary scan pointer to the start of that block, even though there may still be gray objects in the previous block (for example D). The secondary scan pointer keeps track of the earliest gray objects (for example, in block B). If the primary scan pointer catches up with the free pointer, Moon scans from the secondary scan pointer, until the primary scan pointer points to gray objects again. If the secondary scan pointer catches up with the free pointer as well, GC is complete.","Moon's algorithm copies objects in hierarchical order. For example, in , Moon's algorithm first copies oand its children, oand o, into the same block. Next, it copies o(the first child of o) into a different block. At this point, the block with ohas a gray object at the primary scan pointer, so Moon proceeds to copy the children of ointo the same block as o. Only when it is done with that block does it continue from the primary scan pointer, which still points into o.","The mutator is the part of an executing program that is not part of the GC: the user program, and run time system components such as the JIT compiler. Moon's GC is concurrent to the mutator, but there is only one active GC thread at a time, no parallel GC threads.","One problem with Moon's algorithm is that it scans objects twice when the secondary scan pointer advances through already black objects (for example in block C in ).","Wilson, Lam, and Moher, [Paul R. Wilson, Michael S. Lam, and Thomas G. Moher, \u201cEffective: \u201cstatic-graph\u201d reorganization to improve locality in a garbage-collected system\u201d In (), 1991] improve Moon's algorithm by avoiding re-scanning of black objects.  illustrates Wilson, Lam, and Moher's algorithm. It keeps track of the scan pointers in all partially scanned blocks. When the block with the free pointer contains gray objects (for example block D), scanning proceeds in that block; otherwise, it proceeds from the earliest block with gray objects (for example block B). The copy order of Wilson, Lam, and Moher's algorithm is identical to that of Moon's algorithm (see ). The hierarchical copying GC algorithm by Wilson, Lam, and Moher is neither parallel nor concurrent.","In 1985, Halstead published the first parallel GC algorithm [Robert H. Halstead, Jr. Multilisp: A language for concurrent symbolic computation. (), 7(4), 1985]. It is based on Baker's GC [Henry G. Baker, Jr. List processing in real time on a serial computer. (), 21(4), 1978], which is an incremental variant of Cheney's GC [C. J. Cheney. A nonrecursive list compacting algorithm. (), 13(11), 1970]. Halstead's GC works on shared-memory multiprocessor machines with uniform access time to the shared memory. The garbage collector works in SIMD (single instruction, multiple data) style: each worker thread performs the same GC loop on different parts of the heap. The mutator may be SIMD or MIMD (multiple instruction, multiple data). As illustrated in , at any given point in time, either GC threads are running or mutator threads are running, but not both. The GC is parallel, but not concurrent.","Halstead's algorithm partitions to-space into n equally sized parts on an n-processor machine.  illustrates the heap organization for n=2. Worker thread i has a scan pointer scans and a free pointer frees, which point to gray objects and empty space in their respective parts of to-space. Termination detection is simple: when scan=freefor all i, then there are no more gray objects to scan anywhere. Since each thread has its own private part of to-space, the threads do not need to synchronize when scanning objects in to-space or allocating memory in to-space. But they do need to synchronize on individual objects in from-space: if two worker threads simultaneously encounter pointers to the same object in from-space, only one of them should copy it and install a forwarding pointer.","Like Cheney, Halstead has the advantage of requiring no separate queue or stack to keep track of gray objects, because within the part of to-space that belongs to a thread, the objects themselves are laid out contiguously and form an implicit FIFO queue. The algorithm therefore copies in breadth-first order (). Unfortunately, the static partitioning of to-space into n parts for n processors leads to work imbalance. This imbalance causes two problems: overflow and idleness. Overflow occurs when a worker thread runs out of empty space to copy objects into. Halstead solves this problem by providing additional empty space to worker threads on demand. Idleness occurs when one thread runs out of gray objects to scan while other threads are still busy. Halstead does not address the idleness problem caused by work imbalance.","In 1993, Imai and Tick published the first parallel GC algorithm with load balancing [Akira Imai and Evan Tick. Evaluation of parallel copying garbage collection on a shared-memory multiprocessor. 4(9), 1993]. Their algorithm extends Halstead's algorithm by over partitioning: on an n-processor machine, it partitions to-space into m blocks, where m>n.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 9","b":["1","2"]},"The aliasing between copy and scan blocks avoids a possible deadlock where the only blocks with gray objects also have empty space. In addition, it reduces contention on the shared work queue when there are many GC threads. Imai and Tick's GC only checks for an aliasing opportunity when it needs a new scan block because the old scan block is completely black. Inai and Tick evaluated their algorithm on 14 programs written in a logic language. They report parallel speedups of 4.1\u00d7 to 7.8\u00d7 on an 8-processor machine. Their metric for speedup is not based on wall-clock time, but rather on GC \u201cwork\u201d (number of cells copied plus number of cells scanned); it thus does not capture synchronization overhead or locality effects. The present invention effectively achieves hierarchical copy order with parallel GC threads.","Baseline Garbage Collector","The implementation of parallel hierarchical copying GC is based on the generational GC implemented in the International Business Machines Corporation's (IBM's) J9 Java Virtual Machine (JVM). It uses parallel copying for the young generation and concurrent mark-sweep with occasional stop-the-world compaction for the old generation. This is a popular design point in products throughout the industry. The baseline GC has exactly two generations, and young objects remain in the young generation for a number of birthdays that is adapted online based on measured survival rates. We are only concerned with copying of objects within the young generation or from the young generation to the old generation.","The baseline GC uses Imai and Tick's algorithm for the young generation. To accommodate tenuring, each worker thread manages two copy blocks: one for objects that stay in the young generation, and another for objects that get tenured into the old generation. Either block may be aliased as scan block.","Parallel Hierarchical GC","Parallel hierarchical GC achieves hierarchical copy order by aliasing the copy and scan blocks whenever possible. That way, it usually copies an object into the same block that contains an object that points to it. This is the parallel generalization of the single-threaded algorithm by Wilson, Lam, and Moher that uses the scan pointer in the block with empty space whenever possible. Blocks serve both as the work unit for parallelism and as the decomposition unit for hierarchical copying. It may be noted that the term \u201cblock\u201d, as used herein including the claims, refers to a cache line or page or other unit of Operating System (OS) and Hardware (HW) support for memory hierarchy.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 10"},"For example, a copy block must have room to copy objects into; therefore, all incoming transition labels to state copy are at least partially empty. If the copy block has some gray objects and some empty space, then it can serve both as copy block and as scan block simultaneously, and the GC aliases it; therefore, the transition from state copy to state aliased is labeled with colorings that include both gray and empty. The state machine in  is non-deterministic: the state and coloring of a block alone do not determine which transition it takes. Rather, the transitions depend on the colorings of both the copy block and the scan block of the worker thread.",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Transition logic in GC thread."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"chemistry":{"@attributes":{"id":"CHEM-US-00001","num":"00001"},"img":{"@attributes":{"id":"EMI-C00001","he":"42.25mm","wi":"74.51mm","file":"US08024379-20110920-C00001.TIF","alt":"embedded image","img-content":"table","img-format":"tif"}}}}},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Table 1 shows the actions that the GC thread performs after scanning a slot in an object. For example, if the copy block contains both gray slots and empty space, and the scan block is already aliased with the copy block (column scan=aliased), no action is necessary before the next scanning operation. If the copy block contains gray and black and no empty space, or is completely gray, and the scan block is not aliased, the thread transitions the copy block to the aliased state, and either puts the scan block back on the scanlist if it still has gray slots, or transitions it to the done state if it is completely black.","As described in Table 1, parallel hierarchical GC leads to increased contention on the scanlist. To avoid this, the preferred implementation caches up to one block from the scanlist with each thread. Thus, if there is a cached block, the action scanlist\u2192scan really obtains that cached block instead. Likewise, the transition scan\u2192scanlist really caches the scan block locally, possibly returning the previously cached block to the scanlist in its stead.","Presented below is an evaluation of parallel hierarchical copying GC (PH), compared to parallel breadth-first copying GC (BF).","Like Cheney's algorithm and the other Cheney-based algorithms, parallel hierarchical GC requires no separate mark stack or queue of objects. Instead, the gray objects are consecutive in each block, thus serving as a FIFO queue. On the other hand, like Imai and Tick's algorithm, the GC of this invention requires a shared work pool of blocks to coordinate between GC threads. In addition, it requires per-block data to keep track of its state and coloring.","After scanning a gray slot, parallel hierarchical GC checks immediately whether it became possible to alias the copy block and the scan block. Since this check happens on the innermost loop of the GC algorithm, it must be fast. The immediacy of this check is what leads to hierarchical order like in the algorithms by Moon and by Wilson, Lam, and Moher.","The goal of hierarchical copy order is improved mutator locality. But of course, it also affects GC locality and load balancing. This effect can be positive or negative.","As mentioned earlier, in the preferred implementation, each GC thread actually manages two copy blocks, one each for young and old objects. Only one of them can be aliased at a time.","Experimental Setup","Experiments were conducted with a modified version of the International Business Machine Corporation Java 2 Platform Standard Edition (J2SE) 5.0 J9 GA Release (IBM's product Java Virtual Machine, running on real hardware in common desktop and server operating systems. This section discusses the methodology.","The platform for the following four sections was a dualprocessor IA32 SMT system running Linux operating system. The machine has two 3.06 GHz Pentium 4 Xeon processors with hyperthreading. The memory hierarchy consists of an 8 KB L1 data cache (4-way associative, 64 Byte cache lines); a 512 KB combined L2 cache (8-way associative, 64 Byte cache lines); a 64 entry data TLB (4 KB pages); and 1 GB of main memory. The platforms for other sections are described there.",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Benchmarks."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","Suite","Description","MB"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SPECjbb2005","jbb05","business benchmark","149.3"]},{"entry":["antlr","DaCapo","parser generator","1.4"]},{"entry":["banshee","other","XML parser","84.6"]},{"entry":["batik","DaCapo","movie renderer","15.0"]},{"entry":["bloat","DaCapo","bytecode optimizer","11.5"]},{"entry":["chart","DaCapo","pdf graph plotter","25.0"]},{"entry":["compress","jvm98","Lempel-Ziv compressor","8.8"]},{"entry":["db","jvm98","in-memory database","13.6"]},{"entry":["eclipse","other","development environment","4.8"]},{"entry":["fop","DaCapo","XSL-FO to pfd converter","8.5"]},{"entry":["hsqldb","DaCapo","in-memory JDBC database","22.6"]},{"entry":["ipsixql","Colorado","in-memory XML database","2.5"]},{"entry":["jack","jvm98","parser generator","1.5"]},{"entry":["javac","jvm98","Java compiler","13.3"]},{"entry":["javalex","other","lexer generator","1.0"]},{"entry":["javasrc","Ashes","code cross-reference tool","61.3"]},{"entry":["jbytemark","other","bytecode-level benchmark","6.5"]},{"entry":["jess","jvm98","expert shell system","2.3"]},{"entry":["jpat","Ashes","protein analysis tool","1.1"]},{"entry":["jython","DaCapo","Python interpreter","2.1"]},{"entry":["kawa","other","Scheme compiler","3.1"]},{"entry":["mpegaudio","jvm98","audio file decompressor","1.0"]},{"entry":["mtrt","jvm98","multi-threaded raytracer","10.4"]},{"entry":["pmd","DaCapo","source code analyzer","7.0"]},{"entry":["ps","DaCapo","postcript interpreter","229.3"]},{"entry":["soot","DaCapo","bytecode analyzer","33.0"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Table 2 shows the benchmark suite, consisting of 26 Java programs: SPECjbb2005, the 7 SPECjvm98 programs, the 10 Da-Capo benchmarks, 2 Ashes benchmarks, and 6 other big Java language programs. Column \u201cMB\u201d gives the minimum heap size in which the program runs without throwing an OutOfMemoryError. The rest of this discussion reports heap sizes as nx this minimum heap size.","All timing numbers herein are relative.","To reduce the effect of noise on the results, all experiments consist of at least 9 runs (Java Virtual Machine process invocations), and usually several iterations (application invocations within one Java Virtual Machine process invocation). For each SPECjvm98 benchmark, a run contains around 10 to 20 iterations at input size 100. Each run of a DaCapo benchmark contains two or more iterations on the largest input.","Speedups","This section shows the effect of hierarchical copying on runtime for 25 Java programs. A 26th program, SPECjbb2005, is discussed in more detail below.",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Speedups for all benchmarks except SPECjbb2005."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":["%","Speedup","at","heap","size"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","mfrac":{"mi":["PH","BF"]}}}}}}},"\u2003 C.I.","\u2003 # GCs"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Benchmark","1.33x","2x","4x","10x","(4x)","(10x)"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"7","colwidth":"28pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["db","+21.9","+22.9","+23.5","+20.5","0.6","40"]},{"entry":["javasrc","0","+3.5","0","+3.0","2.5","110"]},{"entry":["mtrt","0","0","0","+3.4","4.6","482"]},{"entry":["jbytemark","+3.3","0","0","0","1.6","1,761"]},{"entry":["javac","+2.8","+0.9","+1.6","+3.0","0.5","309"]},{"entry":["chart","0","+3.0","0","0","3.0","126"]},{"entry":["jpat","0","0","0","+2.6","0.7","14,737"]},{"entry":["banshee","0","+2.1","0","0","3.7","6"]},{"entry":["javalex","+1.0","+1.0","+1.7","+1.6","0.6","201"]},{"entry":["jython","0","+1.3","0","0","2.3","893"]},{"entry":["eclipse","0","0","+1.2","0","1.0","9"]},{"entry":["mpegaudio","0","0","0","+1.0","0.9","15"]},{"entry":["compress","0","0","0","+1.0","1.8","142"]},{"entry":["fop","0","0","0","0","1.1","391"]},{"entry":["hsqldb","0","0","0","0","1.1","239"]},{"entry":["kawa","0","0","0","0","0.0","13"]},{"entry":["soot","0","0","0","0","1.1","237"]},{"entry":["batik","0","0","0","\u22121.4","0.7","89"]},{"entry":["jack","0","\u22121.4","\u22120.6","0","0.4","1,440"]},{"entry":["antlr","\u22121.9","\u22121.3","\u22121.0","\u22121.1","0.9","3,070"]},{"entry":["jess","\u22122.8","\u22122.4","\u22121.5","0","0.7","3,558"]},{"entry":["ps","\u22123.0","\u22122.7","\u22122.2","\u22121.3","0.8","59"]},{"entry":["bloat","0","\u22121.7","0","\u22124.7","1.1","341"]},{"entry":["pmd","\u22121.8","0","0","\u22125.1","3.3","775"]},{"entry":["ipsixql","\u22126.0","\u22126.5","\u22128.7","\u22125.9","0.7","3,433"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]}}]}}},"The speedup columns of Table 3 show the percentage by which parallel hierarchical copying (PH) speeds up (+) or slows down (\u2212) run time compared to the baseline parallel breadth-first copying (BF). They are computed as",{"@attributes":{"id":"p-0071","num":"0070"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mn":"1","mo":"-","mfrac":{"mi":["PH","BF"]}},"mo":","}}},"br":{}},"None of the benchmarks experienced speedups at some heap sizes and slowdowns at others. The benchmarks are sorted by their maximum speedup or slowdown at any heap size. Out of these 25 programs, 13 speed up, 4 are unaffected, and 8 slow down. The discussion below will show that SPECjbb2005 also speeds up. While speedups vary across heap sizes, we observed no pattern. The program with the largest slowdown is ipsixql, which maintains a software LRU cache of objects. Because the objects in the cache survive long enough to get tenured, but then die, ipsixql requires many collections of the old generation. The program with the largest speedup is db, which experiences similar speedups from depth-first copy order. Depth-first copy order requires a mark stack, hence it is not considered further herein.","Parallel hierarchical copy order speeds up the majority of the benchmarks compared to breadth-first copy order, but slows some down. It may be possible to avoid the slowdowns by deciding the copy order based on runtime feedback.","Mutator vs. Collector Behavior","Parallel hierarchical copying GC tries to speed up the mutator by improving locality. The discussion above showed that most programs speed up, but some slow down. The discussion immediately below explores how mutator and garbage collection contribute to the overall performance.",{"@attributes":{"id":"p-0076","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Mutator and collector behavior at heap size 4\u00d7."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Mutator","Collector"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"63pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Time",{},"Time",{}]},{"entry":["\u2003 \u2003 Benchmark",{"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mn":"1","mo":"-","mfrac":{"mi":["PH","BF"]}}}}},"\u2003 TLB misses \u2002BF \u2003\u2003PH\u2002",{"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mn":"1","mo":"-","mfrac":{"mi":["PH","BF"]}}}}},"\u2003 TLB misses \u2002BF \u2003\u2003\u2002PH\u2003"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["db","+24.3","7.0","5.5 (\u2212)","\u221237.6","0.6","0.6 (0)"]},{"entry":["javasrc","0","1.0","1.0 (0)","0","0.6","0.5 (\u2212)"]},{"entry":["mtrt","0","2.4","2.5 (0)","\u221215.4","0.6","0.5 (\u2212)"]},{"entry":["jbytemark","0","0.3","0.3 (+)","+9.4","0.6","0.6 (0)"]},{"entry":["javac","+2.0","1.6","1.5 (\u2212)","0","0.6","0.5 (\u2212)"]},{"entry":["chart","0","0.8","0.8 (0)","0","0.7","0.6 (0)"]},{"entry":["jpat","0","2.6","2.7 (0)","0","0.8","0.8 (0)"]},{"entry":["banshee","0","0.4","0.4 (0)","\u22123.3","1.0","1.0 (0)"]},{"entry":["javalex","+1.7","0.7","1.2 (+)","0","0.5","0.5 (0)"]},{"entry":["jython","0","1.5","1.5 (0)","\u22129.0","0.7","0.7 (\u2212)"]},{"entry":["eclipse","+3.1","0.9","0.8 (\u2212)","0","0.7","0.5 (\u2212)"]},{"entry":["mpegaudio","0","0.4","0.4 (0)","\u22125.7","0.8","0.7 (\u2212)"]},{"entry":["compress","0","1.2","1.1 (0)","0","1.0","1.0 (0)"]},{"entry":["fop","+1.3","1.4","1.2 (0)","0","0.5","0.4 (\u2212)"]},{"entry":["hsqldb","0","1.2","1.1 (\u2212)","0","0.5","0.5 (0)"]},{"entry":["kawa","+0.4","1.3","1.3 (0)","\u22129.6","0.6","0.5 (\u2212)"]},{"entry":["soot","0","1.7","1.7 (0)","\u22123.9","0.5","0.5 (0)"]},{"entry":["batik","0","0.8","0.8 (0)","0","0.6","0.6 (0)"]},{"entry":["jack","0","1.2","1.2 (0)","\u22129.2","0.6","0.4 (\u2212)"]},{"entry":["antlr","0","0.8","0.8 (0)","\u22126.5","0.6","0.6 (0)"]},{"entry":["jess","0","2.1","2.1 (0)","\u22127.2","0.5","0.4 (\u2212)"]},{"entry":["ps","0","1.3","1.7 (+)","\u221225.6","0.5","0.4 (\u2212)"]},{"entry":["bloat","0","1.2","1.1 (0)","\u22122.7","0.6","0.5 (\u2212)"]},{"entry":["pmd","0","1.6","1.7 (0)","\u221213.5","0.6","0.5 (\u2212)"]},{"entry":["ipsixql","\u22122.9","0.8","0.8 (0)","\u221213.2","0.5","0.4 (\u2212)"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]}}]}}},"Table 4 breaks down the results of running in 4\u00d7 the minimum heap size into mutator and collector. The \u201cTime\u201d columns show improvement percentages of parallel hierarchical copying (PH) compared to breadth-first (BF); higher numbers are better, negative numbers indicate degradation. The \u201cTLB misses\u201d columns show miss rates per retired instruction, in percent (lower is better; which TLB and other hardware characteristics will be discussed below in more detail). A (+) indicates that PH has a higher miss rate than BF, a (\u2212) indicates that it has a lower miss rate, and a (0) indicates that there is no statistically significant difference. The benchmarks are ordered by the total speedup from Table 3.","When there is a measurable change, with few exceptions, the mutator speeds up and the collector slows down. Even fop and kawa, which experienced no overall speedup, experience a small mutator speedup. Usually, TLB miss rates decrease both in the mutator and in the GC. For the mutator, this explains the speedup; for the GC, this does not prevent the slowdown caused by executing more instructions to achieve hierarchical order. The large reduction in mutator TLB misses for db (from 7% to 5.5%) leads to an overall speedup despite having the largest GC slowdown (of 37.6%). Hierarchical copying only slows down collections of the young generation, but since most objects in db die young, collections of the young generation dominate GC cost.","To conclude, parallel hierarchical copying trades GC slowdown for mutator speedup. This is a reasonable tradeoff as long as GC scaling on multiprocessors is not impacted.","Scaling on Multi-Processor Systems","The discussion herein shows how to achieve hierarchical copy order in a parallel GC. The goal of parallel GC is to scale well in multi-processor systems by using all CPUs for collecting garbage. This is necessary to keep up with the mutator, since it uses all CPUs for allocating memory and generating garbage. The present discussion investigates how well parallel hierarchical copying GC scales.",{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 11"},"All numbers in  are mutator transactions per GC time. Higher numbers indicate that the mutator gets more mileage out of each second spent in GC, indicating better GC scaling. There are curves for parallel breadth-first (BF) copying, parallel hierarchical (PH) copying, and PH with no cached block (PHNCB). All numbers are normalized to BF at 1 thread. The error bars show 95% confidence intervals. With 8 GC worker threads, both BF and PH run around 3 times faster than with 1 thread. Without the cached block optimization from the above section, PH would not scale: it would run 46% slower with 8 threads than with only 1 thread (PHNCB).","Whereas  shows how SPECjbb2005's GC time scales,  shows how its total throughput scales on three hardware platforms. SPECjbb2005 measures throughput as transactions per second, which should increase with the number of parallel mutator threads (\u201cwarehouses\u201d). The three platforms are:\n\n","In each of the graphs -, the x-axis shows the number of warehouses (parallel mutator threads), and the y-axis shows the throughput (transactions per second) relative to the BF throughput with 1 warehouse. Higher is better in these graphs, because it means that more transactions complete per second.","On all three platforms, throughput increases until the number of warehouses reaches the number of logical CPUs, which is twice the number of physical CPUs due to hyperthreading. At that point, parallel hierarchical GC has a 3%, 8%, and 5% higher throughput than the baseline GC. Increasing the number of threads further does not increase the throughput, since there are no additional hardware resources to exploit. But hierarchical GC sustains its lead over the baseline GC even as threads are increased beyond the peak.",{"@attributes":{"id":"p-0087","num":"0089"},"figref":["FIG. 13","FIG. 11","FIG. 13"]},"To conclude, parallel hierarchical copying GC scales no worse with increasing load caused by parallel applications than parallel breadth-first copying GC. A single-threaded GC, on the other hand, would have a hard time keeping up with the memory demands of several parallel mutators.","Time-Space Tradeoffs","In a small heap, GC has to run more often, because the application exhausts memory more quickly. This increases the cumulative cost of GC. On the other hand, in a small heap, objects are closer together, which should intuitively improve locality. This section investigates how these competing influences play out.",{"@attributes":{"id":"p-0091","num":"0093"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0092","num":"0094"},"figref":["FIGS. 14","FIGS. 14","FIG. 14","FIG. 14"],"i":["a+d ","b+e ","International Symposium on Memory Management ","ISMM","c","f"]},"This confirms the conclusions from above: parallel hierarchical GC performs well in both small and large heaps.","Cache and TLB Misses","The goal of hierarchical copying is to reduce cache and TLB misses by colocating objects on the same cache line or page. This section uses hardware performance counters to measure the impact of hierarchical copying on misses at different levels of the memory subsystem.","Pentium processors expose hardware performance counters through machine specific registers (MSRs), and many Linux operating system distributions provide a character device, \/dev\/cpu\/*\/msr, to access them. Doing modprobe msr ensures the presence of this device; for experiments in user mode, the files must be readable and writeable for users. The JVM sets up the registers for collecting the desired hardware events at the beginning of the run, and reads them at the beginning and end of GC, accumulating them separately for the mutator and the GC.",{"@attributes":{"id":"p-0097","num":"0099"},"figref":"FIG. 15"},"To conclude, parallel hierarchical copying GC reduces TLB misses most, while also reducing L1 and L2 cache misses significantly. These reduced miss rates translate into reduced run time.","Pointer Distances","The above section already demonstrated that hierarchical copying reduces cache and TLB misses. This section validates that it achieves that by colocating objects on the same cache line or page.","For this experiment, the GC records the distance between the address of a pointer and the address of the object it points to just after a copying or forwarding operation. Pointers with an absolute distance under 64B are classified as \u201cLine\u201d, and pointers with an absolute distance between 64B and 4 KB are classified as \u201cPage\u201d. The numbers only consider pointers from objects in the young generation to other objects in the young generation, and from newly tenured objects in the old generation to other newly tenured objects in the old generation. Among other things, this disregards pointers between young and old objects; those have longer distances, but are rare, and hierarchical copying cannot colocate them on the same page.",{"@attributes":{"id":"p-0102","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Pointer distances."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"14pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"BF",{},"PH",{}]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Benchmark","Line","Page","Line","Page"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"db","0.0","9.4","23.6","65.1"]},{"entry":[{},"SPECjbb2005","0.0","0.5","6.8","72.4"]},{"entry":[{},"javasrc","0.3","20.8","17.6","32.2"]},{"entry":[{},"mtrt","2.2","28.5","24.1","46.7"]},{"entry":[{},"jbytemark","0.1","4.0","11.2","11.6"]},{"entry":[{},"javac","1.2","33.9","33.1","29.1"]},{"entry":[{},"chart","0.1","4.9","58.0","5.6"]},{"entry":[{},"jpat","0.1","7.2","46.3","5.3"]},{"entry":[{},"banshee","0.6","28.1","15.9","46.8"]},{"entry":[{},"javalex","1.6","19.6","21.9","17.2"]},{"entry":[{},"jython","0.2","11.1","4.5","35.6"]},{"entry":[{},"eclipse","1.9","25.9","28.6","37.3"]},{"entry":[{},"mpegaudio","0.0","33.0","16.7","50.8"]},{"entry":[{},"compress","5.4","33.2","23.2","40.1"]},{"entry":[{},"fop","0.2","32.8","11.9","52.0"]},{"entry":[{},"hsqldb","0.1","28.9","20.3","64.9"]},{"entry":[{},"kawa","3.0","28.0","23.4","32.1"]},{"entry":[{},"soot","6.8","30.1","21.5","38.1"]},{"entry":[{},"batik","1.4","32.9","20.5","45.5"]},{"entry":[{},"jack","0.4","35.5","26.4","49.4"]},{"entry":[{},"antlr","2.0","32.8","20.1","44.4"]},{"entry":[{},"jess","0.3","6.7","8.0","6.5"]},{"entry":[{},"ps","0.1","24.1","32.2","33.9"]},{"entry":[{},"bloat","4.0","24.5","34.5","26.5"]},{"entry":[{},"pmd","1.7","28.5","27.4","29.0"]},{"entry":[{},"ipsixql","1.0","20.2","32.6","21.1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]}]}}]}}},"Table 5 shows pointer distances. For example, db with breadthfirst copying yields 9.4% pointers that are longer than 64 bytes but under 4 KB, whereas parallel hierarchical copying improves that to 65.1%. Except for SPECjbb2005, all runs used heaps of 4\u00d7 the minimum size.","These numbers show that parallel hierarchical copying succeeds in colocating objects on the same 4 KB page for the majority of the pointers. This explains the reduction in TLB misses observed in Table 4. Also, parallel hierarchical copying colocates objects on the same 64-byte cache line much more often than the baseline garbage collector. This explains the noticeable reduction in L1 and L2 cache misses observed above.","While hierarchical copying is tremendously successful at improving spatial locality of connected objects, wall-clock numbers from a real system (Table 3) paint a more sober picture. This discrepancy underlines three points: (i) Hierarchical copying trades GC slowdown for mutator speedup. The result of this tradeoff is determined by the concrete benchmark, GC implementation, and platform. (ii) Hierarchical copying aims at decreasing TLB and cache miss rates. When the application working set is small compared to the memory hierarchy of the machine, miss rates are already so low that decreasing them further helps little. (iii) Hierarchical copying optimizes for the \u201chierarchical hypothesis\u201d that connectivity predicts affinity. In other words, it assumes that objects with connectivity (parents or siblings in the object graph) also have affinity (the application accesses them together). Not all applications satisfy the hierarchical hypothesis.","It should be noted that the present invention, or aspects of the invention, can be embodied in a computer program product, which comprises all the respective features enabling the implementation of the methods described herein, and which\u2014when loaded in a computer system\u2014is able to carry out these methods. Computer program, software program, program, or software, in the present context mean any expression, in any language, code or notation, of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following: (a) conversion to another language, code or notation; and\/or (b) reproduction in a different material form.","While it is apparent that the invention herein disclosed is well calculated to fulfill the objects stated above, it will be appreciated that numerous modifications and embodiments may be devised by those skilled in the art, and it is intended that the appended claims cover all such modifications and embodiments as fall within the true spirit and scope of the present invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 1A","b":["1","1"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIGS. 4-9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 12","i":["a","c "],"b":"12"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIGS. 13","i":["a","f "],"b":"13"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 14","i":["a","f "],"b":"14"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 15","i":["a","f "],"b":"15"}]},"DETDESC":[{},{}]}
