---
title: System and method utilizing test notifications
abstract: A system and method utilizing test notifications. An application is able to construct a test notification that is sent to a user context system and which receives back an indication whether the notification would draw or not draw on the screen at the present time, in accordance with the user's current context. In another embodiment, the calling application receives back richer indications, such as details as to whether the notification would have been deferred or routed, the sound level at which it would have played, etc. In a polling implementation, an application may periodically re-send test notifications to re-poll the system to determine if changes have occurred. In a subscription implementation, an application may subscribe to the system to receive updates that are provided when there are changes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07469272&OS=07469272&RS=07469272
owner: Microsoft Corporation
number: 07469272
owner_city: Redmond
owner_country: US
publication_date: 20030326
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE(S) TO RELATED APPLICATION(S)","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["This application is related to U.S. application Ser. No. 10\/692,324, titled \u201cExtensible User Context System for Delivery of Notifications,\u201d filed concurrently with the present application, which is hereby incorporated by reference in its entirety.","The present invention relates to notifications in computing systems, and more particularly, a system and method utilizing test notifications.","In computer systems, a notification may be in the form of a signal from a program that indicates to a user that a specified event has occurred. Such a notification may contain various elements of text, sound, and graphics. Other properties may also be included with the notification, such as priority, the person who sent the notification (for channels such as e-mail or instant messaging), and when the notification expires. Notifications may also include some elements of code such that the user can interact with the notification and launch arbitrary code (e.g., clicking on buttons or text within the notification that can cause new programs to launch or actions to be taken on programs that are currently running).","An operating system may create notifications to let a user know about network connectivity and updates. A instant messaging program that uses \u201ccontact lists\u201d may draw notifications on the screen to let the user know what is happening with the contact list or when a contact initiates an instant message conversation. Other programs may provide similar notifications that draw in similar areas of the display. One issue with these types of notifications is that they aren't generally aware of the other notifications, thus sometimes leading to notifications being drawn on top of other notifications.","Another issue with existing notification systems is that they may cause notifications to be delivered inappropriately, or at inappropriate times. For example, for a user providing a full screen presentation, it may be inappropriate to have other programs draw notifications on the screen during the presentation. An example of a program that might draw such inappropriate notifications is a instant messaging program that runs in the background of the operating system and draws such notifications when contacts in the contact list sign on or initiate an instant message. This type of \u201cinterruption\u201d during a presentation may be undesirable to a user.","The present invention is directed to providing a system and method that overcome the foregoing and other disadvantages. More specifically, the present invention is directed to a system and method utilizing test notifications.","A system and method utilizing test notifications is provided. In accordance with one aspect of the invention, a calling program constructs a test notification that is similar to an actual notification. A key difference from an actual notification is that the test notification will not actually be delivered to the user.","In accordance with another aspect of the invention, in one embodiment the test notification returns an indication of true or false. An indication of true means that an actual notification would have drawn at the present time, while an indication of false means that an actual notification would not have been able to draw at the present time. In another embodiment, richer return values may also be returned by the test notification. Examples of richer return values include whether the notification would have been deferred or routed, the sound level at which the notification would have played, etc.","In accordance with another aspect of the present invention, in one embodiment a polling method is utilized. In this embodiment, the calling program periodically re-polls (sends test notifications) to determine the user's current context and how any broadcast data should be changed that are sent by the calling program. An example of broadcast data could be a instant messaging program broadcasting a busy or free state to a contact. In another embodiment, a subscription callback method is utilized. In this embodiment, the calling program subscribes to receive context changes. In other words, rather than re-polling periodically, as the user's context changes as relevant to the type of information that is broadcast, the context engine calls back to the program with these updates. This latter embodiment has an advantage in that there is no lag between the context changes and what is broadcast. In other cases, the polling method may be more appropriate, such as for one-time events.","It will be appreciated that the testing system and method of the present invention allows the operating system and arbitrary programs to determine when it is appropriate to send notifications to the user. One advantage of utilizing test notifications is that by enabling a program to have a richer view of the user's context, unwanted actual notifications can be prevented from being generated until a user is in a receptive state. In addition, greater flexibility is provided for programs that do not utilize the same user interface for the delivery of notifications, in that by utilizing the test notifications they are still able to obtain information as to the user's context. As an example, a future program may develop a notification with specialized graphics that might not be supported by a present user context system, however the future program would still be able to utilize information obtained from a test notification to determine whether it is appropriate to send or modify its present notification.","In accordance with another aspect of the invention, the test notifications are utilized in a user context system. The user context system brokers and serializes the delivery of notifications from multiple sources. In addition, a shared notion of user context is provided, for determining the appropriate handling for each of the notifications. In accordance with these aspects, the notifications that are delivered by the user context system may be considered to be more valuable in that they are delivered when the user is more receptive to them. These aspects also provide for common rules which help the user to eliminate undesirable notifications. In one embodiment, the use of test notifications in the user context system essentially provides for a system tool or a system provided mechanism that is able to encapsulate a user's aggregated context and expose it to arbitrary processes.","In accordance with another aspect of the invention, in the user context system the contexts are declared by the operating system and arbitrary programs. In one embodiment, a user context comprises a condition that may be true or false, and an instruction that is to be followed if the condition is true. For example, a condition might be \u201cwhen a user is listening to music,\u201d for which the instruction might be \u201cdeliver notifications on the screen but with no sound.\u201d In general, the condition for the user context can be thought of as a state that the system assumes makes the user in some way unavailable for notification delivery or that causes the way that the notification should be delivered to be different from how it was sent by the program that initiated it. The user may be in a state deemed \u201cunavailable\u201d in which case the notification is either not delivered or held until the user becomes \u201cavailable.\u201d For instance, if the user is running a full screen application, where the application is using or being displayed on the full area of a display screen, that user may be deemed unavailable. Or, the user may be \u201cavailable\u201d but in such a state that the notification needs to be modified to be appropriate for the user.","In accordance with another aspect of the invention, in the user context system, in addition to the operating system declaring contexts, programs register with the system and declare the context they provide and the impact it has on notifications (as per if drawing on the screen is appropriate and the level of invasiveness that is appropriate for drawing on the screen and whether or not sound is appropriate or at what relative volume sound should be played at) and then tells the system whether the context is true or false. In one embodiment, the context may also be evaluated as true or false at the time that a notification is to be delivered. In one embodiment, the system may also track the process of the calling program, and if the process is no longer present, the context may be reset to false. By tracking the process, certain undesirable situations can be avoided, such as an application declaring a user as being busy, and then crashing, and then leaving the user stuck in a state in which they have been declared as not being available for receiving notifications.","In accordance with another aspect of the invention, in the user context system, there may be different levels of invasiveness specified for the drawing of notifications. In other words, based on the user context, there may be gradients for the drawing of notifications, such that there may be different levels of invasiveness in the form of the drawn notification. For example, a normal notification may be free to be drawn in the client area and briefly obscure a window. If the user is in a slightly restrictive context, the notification may be free to show, but only in a less invasive manner, such as it might not be allowed to draw on top of another window. As another example, if a user is running a maximized application, the setting may be that the user context is slightly restricted, in that the user has clearly made a statement that they want their current application to get the entire client area. In this circumstance, notifications may still be allowed to draw, but they may be made to only appear within the sidebar. This type of reduced invasiveness in the notification drawing form lessens the impact of the notifications, and lessens the cognitive load.","In accordance with another aspect of the invention, in the user context system the contexts that have been provided are exposed to the user and can either be turned off (e.g., the user doesn't agree with the program's assessment of the context) or changed in terms of the impact on delivery.","In accordance with another aspect of the invention, in the user context system the user may define rules that dictate how notifications that contain specified elements should be delivered. For example, a user rule might dictate that any notifications received from \u201cJohn Doe\u201d and with \u201curgent\u201d in the subject line, should be delivered immediately. In one embodiment, such user rules are given precedence over the user contexts. The user rules are made available to the user for modification in accordance with the user's preferences.","The present invention is directed to a system and method that utilizes test notifications. In one embodiment, the test notifications may be processed by a user context system. The user context system controls the delivery of notifications.","In prior systems, there have typically been numerous competing elements which want to send notifications to a user, each of which designs its own way to send such notifications. None of the competing elements have generally been aware of the other notifications and thus have tended to draw on top of each other and each other's applications, which can lead to conflicts when each chooses to render an indication of their respective notifications at the same time. Additionally, there has been no shared notion of user context, leading to some notifications being delivered inappropriately, or at inappropriate times. The user context system addresses these issues by building notifications as a rich part of the operating system, such that the user interfaces for notifications provided by the user context system become similar and thus stop conflicting with one another because the system appropriately brokers and serializes their on-screen rendering. In addition, the notifications provided by the user context system can be considered to be more valuable because they are delivered when the user is more receptive to them, and in addition the use of common rules helps the user to eliminate undesired notifications.","As noted above, the user context system may be utilized to process the test notifications of the present invention. The test notifications of the present invention are used to determine if actual notifications would be delivered under present conditions. In other words, the test notifications are intended to provide an indication of whether a user is currently available for receiving notifications. This indication, can be used, for example, to prevent a program from attempting to send an actual notification at the present time, or to cause the program to modify the notification.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 1"},"With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a conventional personal computer , including a processing unit , system memory , and a system bus  that couples various system components including the system memory  to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. The system memory includes read-only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS) , containing the basic routines that helps to transfer information between elements within the personal computer , such as during start-up, is stored in ROM . The personal computer  further includes a hard disk drive  for reading from or writing to a hard disk , a magnetic disk drive  for reading from or writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk , such as a CD-ROM or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer-readable media provide non-volatile storage of computer-readable instructions, data structures, program modules, and other data for the personal computer . Although the exemplary environment described herein employs a hard disk , a removable magnetic disk , and a removable optical disk , it should be appreciated by those skilled in the art that other types of computer-readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, random access memories (RAMs), read-only memories (ROMs), and the like, may also be used in the exemplary operating environment.","A number of program modules may be stored on the hard disk , magnetic disk , optical disk , ROM  or RAM , including an operating system , one or more application programs , other program modules  and program data . A user may enter commands and information into the personal computer  through input devices such as a keyboard  and pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus , but may also be connected by other interfaces, such as a parallel port, game port or a universal serial bus (USB). A display in the form of a monitor  is also connected to the system bus  via an interface, such as a video card or adapter . One or more speakers  may also be connected to the system bus  via an interface, such as an audio adapter . In addition to the display and speakers, personal computers typically include other peripheral output devices (not shown), such as printers.","The personal computer  may operate in a networked environment using logical connections to one or more personal computers, such as a remote computer . The remote computer  may be another personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the personal computer . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.","When used in a LAN networking environment, the personal computer  is connected to the local area network  through a network interface or adapter . When used in a WAN networking environment, the personal computer  typically includes a modem  or other means for establishing communications over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the personal computer  or portions thereof may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary, and other means of establishing a communications link between the computers may be used.","The present invention may be implemented on a system of the type illustrated in . As noted above, the test notifications of the present invention may be evaluated by a user context system. A user context system for evaluating the test notifications will primarily be described with respect to  below. The evaluation of the test notifications will be described in more detail in later sections with respect to .","In regard to , a user context system is provided for controlling the delivery of notifications from multiple sources. In one embodiment, the user context system may consist of three elements that are compared for a decision as to how to process a notification. The first element is the user's context (as may be provided by the operating system and arbitrary programs that have extended it). The second element is the user's rules and preferences. The third element is the notification itself (which contains elements such as data and properties that may match the user's rules).","As will be described in more detail below, the user context system operates by the operating system and other programs declaring a user's contexts, after which the system brokers the user's context and rules. Notifications are raised by other programs calling into the system. The user's context, rules, and elements of the notification are compared and then a determination is made as to what should be done with the notification. Examples of various options for what may be done with the notification include denying (if the notification is not allowed to draw or make noise, and the notification is to never be seen by the user), deferring (the notification is held until the user's context changes or the user's rules dictate that it is subsequently appropriate to deliver), delivering (the notification is allowed to be delivered in accordance with the user's context and rules), and routing (the user's rules indicate that the notification should be handed off to another system, regardless of whether the notification is also allowed to be delivered in the present system).","Various routines for delivering a notification are described in more detail below. In general, the user may be in a state deemed \u201cunavailable\u201d in which case the notification is either not delivered or held until the user becomes \u201cavailable\u201d. For instance, if the user is running a full screen application, that user may be deemed unavailable. Or, the user may be \u201cavailable\u201d but in such a state that the notification needs to be modified to be appropriate for the user. For instance, if the user is listening to music or in a meeting, the user may have indicated that the notifications should be delivered to the user's screen but that the sound they make should be either quieter or not made at all.","As noted above, the user context determines in part whether notifications are shown on the user's screen. When a notification is shown, it may be shown based on certain gradients within the user context. In other words, there are different levels of invasiveness of the form of the drawn notification that may be specified. For example, a normal notification is free to pop out into the client area and briefly obscure a window. If the user is in a slightly restrictive context, the notification may be free to show, but only in a less invasive manner, such as it might not be allowed to draw on top of another window. As another example, in one embodiment where the user is running a maximized application, the default setting may be that this means that context is slightly restricted, and that the user has clearly made a statement that they want this application to get the entire client area. In this setting, a notification may still be allowed to draw, but may be made to only appear within the sidebar. In other words, this type of reduced invasiveness in the notification drawing form lessens the impact of the notification, and overall lessens the cognitive load.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 2","b":["200","202","204","206"]},"The user contexts and user rules will be described in more detail below. In one embodiment, a user context consists of a condition that may be either true or false, and an instruction for determining how a notification should be handled when the condition is true. In general, the condition of a user context can be thought of as a state that the system assumes makes the user in some way unavailable for notification delivery or that causes the way that the notification is delivered to be different from how it was sent by the program that initiated it. In other words, in one embodiment a user context can be thought of as a statement that \u201cwhile condition X is true, then this is what should be done with incoming notifications.\u201d An example would be \u201cwhen my music player is playing music for me, incoming notifications should show on the screen but not play sound.\u201d Another example would be \u201cwhile any application is running in full screen mode, incoming notifications should be deferred until later.\u201d","With respect to such user contexts, in one embodiment a user may also define special rules for handling incoming notifications, and thus may provide for special exceptions to the instructions of the user contexts. As an example, a user rule might state \u201cwhen I receive a new e-mail from \u2018John Doe,\u2019 and with \u2018urgent\u2019 in the text, and marked \u2018high priority,\u2019 deliver the e-mail regardless of other user contexts.\u201d In other words, in this example this user rule provides an exception to a user context which would otherwise indicate that it is inappropriate to deliver a notification for an incoming e-mail at this time. With regard to the elements of the notification that the user rules are evaluated with respect to, these may include things like text, sound, graphics, and other properties such as priority, the person who sent the notification (for channels such as email or instant messaging), when the notification expires, and some elements of code such that the user can interact with the notification and launch arbitrary code (e.g., clicking on buttons or text within the notification can cause new programs to launch or actions to be taken [such as deleting email] on programs that are currently running).",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 3","b":["220","222"]},"Returning to , at a block , the operating system or program sets the declared context as true or false. For example, with regard to the music player declaring the context of \u201cwhen the music player is playing music, incoming notifications should show on the screen but not play sound,\u201d the music player program also sets this declared context as currently being true or false. In other words, the music player program indicates whether it is true or false that the music player is currently playing music. As will be described in more detail below, in one embodiment, the determination of whether a context is true or false may also be evaluated at the time the notification API is called, or at the time the user rules and exceptions are re-evaluated. As an additional feature, the system may also track the process handle of the calling program, such that if the process terminates without first resetting the context value to its default \u2018false\u2019 value, the system will reset the context value as soon as it detects that the initial process does not exist any more (in one embodiment, the process handle state is set to signal when the process terminates, and that state change is picked up by the system which watches the process handle). This ensures that if processes terminate unexpectedly or forget to reset the context, then the delivery of further notifications will not be unduly affected. For example, if in the above example the music player program has been closed and the process is no longer present, then the context may automatically be reset to false. As another example, if a program originally declares a user as being busy, but then the program crashes, such that the process is no longer present, the context may automatically be set to false rather than leaving the user stuck in a state where notifications would not be received. In any event, whether or not a context is actively set or is evaluated as a function, in one embodiment the contexts can generally be resolved to be either true or false.","Returning to , at a block , the context information is added to the user contexts that are stored in the system. This process is repeated by additional programs declaring contexts. In addition, as noted above, the state of whether already declared contexts are true or false will change over time as the user opens and closes different programs and undertakes different tasks.","As noted above, in one embodiment registering a context is a declarative process. As will be described in more detail below, in the user context system, by registering the user contexts, the user can be presented with a list of the contexts so that the user can choose to not accept certain contexts or to change what they mean if the user disagrees with the context parameters. As noted above, in one embodiment, a context may consist of a condition that may be true or false, and an instruction for what to do with notifications when the condition is true. In this regard, a user context may comprise specific programming elements, such as: a human readable string (for the end user to know what is meant); a unique identifier (such as a globally unique identifier, aka GUID) so that the program can tell the operating system when this context is true or not; and the instruction which may comprise a statement of what this context means in terms of notifications drawing on screen (as may include invasiveness level, sound, and volume). A context may also be dynamic, as will be described in more detail below.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 4","b":["230","232","234","234"]},"As illustrated by  and as noted above, a context may be proactively set or it may be a function that is evaluated at a relevant time. As an example, a program may actively note that a user is listening to music. As another example, when a notification is evaluated, the program may have registered its callback such that the program is queried by the system at the time the notification is evaluated whether the context is true. One example of a case where this second process can be particularly important is when a user context is combined with a user rule to form a dynamic context. (User rules will be described in more detail below.) A specific example of a user context combined with a user rule would be when a user has set a rule that states \u201cpeople who I'm meeting with right now can always send me notifications irrespective of my busy state.\u201d In this case, the user context of \u201cwhen the user is in a meeting,\u201d must further be evaluated in terms of who the user is in the meeting with. In this example, the program that handles the meetings may register this as a dynamic context, and when a notification is evaluated, the person who sent the notification is evaluated against this context (which otherwise could not be declared as true or false proactively, since the people attending the meeting may change over time). In other words, this particular example requires evaluation of a user's context in light of a user rule that depends on other people's contexts.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 5","b":["240","242","246","244"]},"In one embodiment, the contexts that have been provided may be exposed to a user in a manner which allows the user to either turn the contexts off (e.g., the user doesn't agree with the program's assessment of the context), or to change the context in terms of the impact on delivery of a notification. As more specific examples, user contexts can include things like \u201cwhile any application is running in full screen mode\u201d; \u201cwhen I'm playing music or video\u201d; \u201cwhen my meeting manager shows me in a meeting\u201d; or \u201cwhen my out of office assistant is turned on.\u201d For each of these, the user could be allowed to make selections that specify an instruction that when the given condition is true, the incoming notifications should follow selected procedures. The instructions can specify things like whether or how the notification will draw on the screen, and the sound or volume that the notification will make. For the volume, the user can specify a percentage of desired volume under the given condition. For the options for drawing the notification on the screen, the user can be provided with options such as not drawing the notification at all, or drawing the notification only on a specified external display, or drawing the notification on the present screen. For the drawing of a notification, different levels of invasiveness can be specified. For example, if a user is running a maximized application, such that the context is slightly restricted, the invasiveness setting might be such that notifications can still draw, but might appear only within a sidebar.","Returning to , at decision block , a determination is made whether the user wishes to create new user rules. If the user does not wish to create new user rules, then the routine proceeds to a decision block , as will be described in more detail below. If the user does wish to create new user rules, then the routine proceeds to a block , where new rules are created. In general, user rules dictate how notifications that contain specified elements should be handled. For example, a rule may dictate that notifications from a specified person should always be delivered immediately, and this rule can be applied to all notifications, irrespective of which program initiated the notification as long as it is from the specified person. As more specific examples, other user rules may be directed to things like \u201cMSN auto's traffic alerts for Bremerton, Wash.\u201d and \u201cimportant e-mails from John Doe.\u201d As an example of a user rule for an important e-mail from John Doe, the rule could dictate that any e-mails that arrive from John Doe, and with \u201curgent\u201d in the text, and marked \u201chigh priority,\u201d should follow specified handling conditions. The handling conditions could specify that the notification should be delivered immediately and that the user should be required to acknowledge it. In general, requiring a user to acknowledge a notification means that there is a slightly raised elevation in the form of the notification's invasiveness, in that the notification will stay on-screen until the user specifically dismisses it. In one embodiment, the requiring of a user's acknowledgement is only settable via a user rule. As another example, the rules could also specify a custom sound to be played for the notification, at a specified volume, so as to provide an alert to the user that a special notification has arrived. Different settings may also be selected for how the notification should be handled during \u201cnormal\u201d and \u201cbusy\u201d conditions for the user, as may be determined by the user's context. The handling instructions may also include things like routing options for the notification, such as \u201cdeliver notifications from John Doe to my pager.\u201d In one embodiment, when the context is evaluated, the most restrictive currently true context is the one that is applied. When user rules are evaluated, it means that a particular notification has matched the rule that the user has created, in which case the most invasive setting is applied from the user rules which have matched the notification. In other words, in the user rules, a user has specified something to be of importance, and this procedure is intended to follow the user's preferences. If there is a conflict between two rules, the most invasive is applied.","In one embodiment, the user rules may also be directed to controlling the delivery of notifications from specific notification services. For example, an operating system that provides notifications in accordance with a notification service may provide the user with a way to modify how the notifications are delivered. For example, the specified notification service may provide \u201ctraffic alerts for Seattle\u201d, and the user may edit the delivery to be such that when such notifications are received the system should \u201cshow the notification and play sound.\u201d","Returning to , at decision block , a determination is made whether the user wishes to adjust any of the already existing user rules. If the user does not wish to adjust any of the rules, then the routine ends. If the user does wish to adjust the user rules, then the routine proceeds to a block , where the user makes modifications to the rules.","As described above with respect to , the user contexts and user rules are set by the operating system, programs, and the user. The system appropriately brokers and serializes the delivery of the notifications in accordance with the user's preferences. The user contexts and user rules may be exposed to the user such that the user can modify or adjust the various contexts and rules, or create new rules. This provides the user with a centralized way to manage preferences for how notifications are handled. It will be appreciated that this allows a user to effectively manage the many competing elements in a computing system that may want to send notifications to the user.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 6","b":["300","302","304","306","310"]},"At decision block , a determination is made whether the notification matches any user rules. If the notification matches any user rules, then the routine proceeds to a block , where the user rules are followed (based on the notification content plus the user contexts), and the routine continues to a point A that is continued in . If at decision block  the notification does not match any user rules, then the routine continues to a decision block .","In one embodiment, user rules always outweigh the current user contexts. As noted above, user rules can be based on any element of the notification. For example, a rule that is based on an evaluation of the person who initiated the notification, can be applied to all notifications, irrespective of which program initiated the notification as long as it is from the person on which the rule is based (e.g., \u201cJohn Doe\u201d can always reach me). In addition, notifications may draw on the screen even during contexts that would otherwise cause it not to draw (e.g., \u201cpeople who are in a meeting with me can always send me notifications\u201d, even though the user context generally states that the user is not to receive notifications during a meeting).","Returning to , at decision block , a determination is made whether the notification can draw at the present time (based on the user context only). If the notification can draw at the present time, then the routine continues to a block , where the notification is drawn, and appropriate sound and volume are provided. If it is not appropriate to draw the notification at the present time, then the routine proceeds to a decision block .","At the decision block , a determination is made whether the notification has expired. If the notification has expired, then the routine proceeds to a block , where the notification is destroyed. If the notification has not expired, then the routine proceeds to a block , where the notification is deferred, and the routine continues to a point B that is continued in .",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 7","FIG. 6","FIG. 7"],"b":["350","352","362","354"]},"Some examples of routing instructions include: \u201cForward this notification to an e-mail address\u201d; \u201cforward this notification to another PC\u201d; \u201cforward this notification to a pager\u201d; \u201cforward this notification to a cell phone\u201d; or \u201cforward this notification to an e-mail server.\u201d As will be described in more detail below, if the notification is routed, it may also be delivered and draw on the screen. In addition, the device to which the notification is forwarded may have this same context system implemented, and on that device there may be additional or different knowledge of the user's context, and the context system on that device may choose to do different actions with the notification.","Returning to , at decision block , a determination is made whether to deny the notification. If the notification is not to be denied, then the routine continues to a decision block , as will be described in more detail below. If the notification is to be denied, then the routine proceeds to a block  where the notification is destroyed and not seen by the user. In other words, a notification that is denied is not allowed to draw or make noise. For example, this may occur based on a user rule that states that a certain notification should be denied, or as described above with reference to block  of , when a notification has expired.","Returning to , at decision block , a determination is made whether the notification should be deferred. If the notification is not to be deferred, then the routine proceeds to a decision block , as will be described in more detail below. If the notification is to be deferred, then the routine proceeds to a block , where the notification is held until a user context changes, and the routine continues to a point B that is continued in . In general, deferring a notification indicates that the notification will be allowed to be delivered, but that the user's current context or rules are such that it is deemed inappropriate to deliver the notification at this time. As will be described in more detail below with reference to , once the user's context changes or alternatively when the user's rules indicate that it is subsequently appropriate, the notification will be delivered to the user's screen and allowed to draw and\/or make its sound, as dictated by the user rules and user context.","Returning to , at decision block , a determination is made whether the notification should be delivered. If the notification is not to be delivered, then the routine ends. If the notification is to be delivered, then the routine proceeds to a block , where the notification is drawn in accordance with the appropriate level of invasiveness, and the appropriate sound and volume are provided. In other words, the notification is allowed to be delivered, though it is delivered in accordance with the user's context and rules (e.g., a notification may be allowed to be drawn but required to be silent).",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 8","FIG. 6","FIG. 8","FIG. 6","FIG. 6"],"b":["380","7","382","384","386","382","304"]},{"@attributes":{"id":"p-0072","num":"0071"},"figref":["FIG. 9","FIG. 6","FIG. 7","FIG. 9"],"b":["400","322","372","402","404","406"]},"At decision block , a determination is made whether the notification should be drawn but only externally. If the notification is only to be drawn externally, then the routine proceeds to a block , where the notification is drawn but only on external hardware displays. If the notification is not to be drawn on external hardware displays, then the routine proceeds to a decision block .","At decision block , a determination is made whether the notification should be drawn on the present display. If the notification is to be drawn on the present display, then the routine proceeds to a block , where the notification is drawn in accordance with the appropriate level of invasiveness on the present display. If the notification is not to be drawn on the present display, then the routine ends.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIG. 10","FIG. 9","FIG. 6","FIG. 7","FIG. 10"],"b":["420","322","372","422","424","426"]},"At decision block , a determination is made whether the notification should be provided with some percentage but less than full volume. If some percentage volume is to be provided, then the routine proceeds to a block , where the notification is played at the specified percentage volume. If a specified percentage volume is not to be provided, then the routine proceeds to a decision block .","At decision block , a determination is made whether full volume should be provided for the notification. If full volume is to be provided, then the routine proceeds to a block , where the notification is played at the full volume level. If full volume is not to be provided, the routine ends. In one embodiment, in addition to providing for different volume levels for the notification, different sounds may also be selected for the notification in accordance with the user context and rules.","It will be appreciated that the user context system as described above with respect to , controls the delivery of notifications from various sources such that the notifications stop conflicting with one another because the system appropriately brokers and serializes their on-screen rendering. In addition, the notifications that are processed by the user context system can be considered to be more valuable because they are delivered when the user is more receptive to them, and in addition the use of common rules helps the user to eliminate undesired notifications.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIGS. 11-14"},"As an example, a future user interface may provide rich full screen animations that draw only when the user is not \u201cbusy.\u201d For instance, placing a CD into the CD-ROM drive might present an animation of a CD on the screen, while the CD-ROM spins up (due to technical constraints, there is a period of time from when the CD is first inserted until the CD may be read even though it is known to be in the drive\u2014and during this time period an animation could be used to show the user that the system is aware of the CD, but just can't read from it yet). By using the test notifications of the present invention, the animation program will be able to know about the user's current context and can choose to not show on-screen if the user is not receptive to notifications right now.","As another example, a future instant messaging program may develop a new user interface for notifications that could not be done with the current notification engine. The development of such new user interfaces is needed as part of the flexibility that is required in the current competitive marketplace. In accordance with the present invention, test notifications could continue to be utilized by the instant messaging program to determine whether it should show\/not show its more advanced notifications in accordance with user's current context.","In accordance with another aspect of the present invention, the test notifications can be utilized to prevent unwanted notifications from being generated. This aspect can be applied to any programs that attempt to send notifications to the system. In other words, by enabling a program to have a richer view of the user's context, unwanted notifications can be prevented from being generated by the programs, thus proactively ending the generation of these types of notifications until the user is in a receptive state. The following examples help illustrate this aspect of the invention.","As one example, a instant messaging program may provide a list of contacts. The test notifications are able to tap into the context system on a per-contact basis (e.g., \u201cif Tom were to send you an instant message right now, would it show?\u201d and \u201cif Chris were to send you an instant message right now, would that show?\u201d). On the basis of this information, the instant messaging program can begin broadcasting definite busy or free states to individual contacts. This technique could be used to preemptively stop unwanted notifications from being generated, rather than simply suppressing them once they are received.","As another example, if a user is busy, a mail program could make use of this to provide an automated reply to the sender (either to all senders based on rules that the user has provided, such as \u201cmy direct reports\u201d or \u201cmy manager\u201d). The automated reply could indicate \u201cI am busy right now, but will respond when I have a chance.\u201d In general, the communications of the system as a whole can be improved by exposing the user's context to arbitrary programs.","As described above, in accordance with the present invention, an application is able to construct a test notification and receive back specifically whether or not an actual notification would draw on the screen at the present time. As noted above, this allows programs to continue to use the user context system even after new user interfaces for notifications are developed. In addition, by enabling these new richer scenarios for other programs, all programs that utilize the system can be considered to be richer and more intelligent based on having increased access to information about the user's behavior and preferences.",{"@attributes":{"id":"p-0086","num":"0085"},"figref":["FIG. 11","FIG. 2","FIG. 11"],"b":["500","502","504","506"]},"In one embodiment, the notification test API is called when the operating system or an arbitrary program decides that it needs to understand how busy the user currently is. One example of when this might occur would be when there is a decision point for whether or not to draw a notification on the screen. Another example would be to use this data to inform an action that the program wants to take on the user's behalf.","When the notification test API is called, the calling program constructs a notification that is as close to what it would send if it were using the notification methods of the user context system for sending an actual notification, and then uses an optional method to test (which returns the result and also guarantees that this particular notification will not be shown on-screen). One example of this process would be a instant messaging program wanting to broadcast an appropriate free or busy state to each contact based on the current user's context. The instant messaging program would create a test notification for each contact, and based on the return value broadcast a different free or busy state on a per-contact basis. Another example would be a program wanting to show an animation based on a user context (e.g., the CD-ROM animation example described above). The code that wants to show the animation would construct a notification (in this case, the contents simply being a simple notification with an image or animation sequence as this is just a test as to whether or not the given notification would draw), and then uses the test method, and then the return results could be used as a guide for whether or not the animation should currently be played. In one embodiment, the calling code will generally at least raise the most-generic notification possible as a test notification. If there is richer data available (such as the contact from the contact list), then including this information makes the test notification more accurate as the user may have custom user rules on a per person basis that may affect the returned results.","One implementation that may be utilized for the notification test API is a polling implementation. In the instant messaging program example described above, for the polling implementation the instant messaging program would periodically re-poll the notification test API to determine how to change the broadcast data. Another implementation that can be utilized for the notification test API is a subscription callback implementation. In this implementation, the instant messaging program would \u201csubscribe\u201d to context changes. Then, rather than periodically re-polling, as the user context changes in ways that change what the instant messaging program would be able to broadcast, the context engine can call back to the instant messaging program with appropriate updates. In some scenarios, this is advantageous, in that there is no lag between the context changes and what is broadcast (whereas with the polling implementation, there will tend to be moments when the broadcast state does not match the current user context). For other scenarios, the polling implementation may be more appropriate (as these are responses to one-time events, e.g., a CD being inserted into a CD-ROM).",{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 12","b":["520","522","530","550","540"]},"At decision block , a determination is made whether the user rules indicate that the test notification would draw at the present time. If the test notification would draw at the present time, then the routine proceeds to a block , where an indication of true is provided. If the test notification would not draw at the present time, then the routine proceeds to a block , where an indication of false is provided.","At decision block , a determination is made whether the test notification would be able to draw at the present time (in relation to the user context only). If the test notification would be able to draw at the present time, then the routine proceeds to a block , where an indication of true is provided. If the notification would not be able to draw at the present time, then the routine proceeds to a block , where an indication of false is provided. From blocks , ,  and , the routine returns to the calling application with the designated indication.",{"@attributes":{"id":"p-0093","num":"0092"},"figref":["FIG. 13","FIG. 12","FIG. 13"],"b":["600","520","600"]},"It should also be noted while the return values are being described as part of a function call, in another embodiment this data may be passed as part of a callback. In other words, the calling application can set up a \u201csubscription\u201d to a notification such that when a user's context subsequently changes (as would affect the delivery of notifications from the calling application) then the calling application is notified. This requires no polling, and in some cases is thus better for the robustness and performance of the system.","As illustrated in , at a block  the notification test API is called or a subscription is registered (as related to the polling versus subscription embodiments described above). At a decision block , a determination is made whether the test notification matches any user rules. If the test notification does not match any user rules, then the routine proceeds to a decision block , as will be described in more detail below. If the test notification does match any user rules, then the routine proceeds to a block . At block , the test notification is evaluated according to the user rules (based on the test notification content plus the user contexts), and the routine continues to a point D that is continued in , as will be described in more detail below.","At decision block , a determination is made whether the test notification would be able to draw at the present time (based on user context only). If the test notification would not be able to draw at the present time, then the routine proceeds to a decision block , as will be described in more detail below. If the test notification would be able to draw at the present time, then the routine proceeds to a block . At block , the routine determines what sound level would be appropriate according to the user context. At a block , an indication is provided that the notification would draw, and also including the percentage sound level that would be appropriate for the notification.","At decision block , the determination is made whether the test notification would be held for later delivery (based on the test notification content plus the user rules). If the test notification would be held for later, then the routine proceeds to a block  where an indication is provided of defer. If the test notification would not be held for later delivery, then the routine proceeds to a block , where an indication is provided of deny. From blocks ,  and , the routine returns to the calling application with the specified indication(s).",{"@attributes":{"id":"p-0098","num":"0097"},"figref":["FIG. 14","FIG. 13","FIG. 14"],"b":["650","652","654","662","662"]},"At decision block , a determination is made whether the test notification would be denied. If the test notification would be denied, then the routine proceeds to a block , where an indication of deny is provided. If the test notification would not be denied, then the routine proceeds to a decision block .","At decision block , a determination is made whether the test notification would be deferred. If the test notification would be deferred, then the routine proceeds to a block , where an indication is provided of defer. If the test notification would not be deferred, then the routine proceeds to a decision block .","At decision block , a determination is made whether the test notification would be delivered. If the test notification would be delivered, then the routine proceeds to a block , where an indication of deliver is provided. In one embodiment, the delivery indication may also include a specified invasiveness indication as well as a sound and volume indication. If the test notification would not be delivered, then the routine returns to the calling application. From blocks , , and , the routine returns to the calling application with the specified indications.","It will be appreciated that the present invention as described above with respect to  provides a system and method utilizing test notifications which enable programs to obtain indications as to the availability of a user. By enabling a program to have a richer view of a user's context, the generation of unwanted notifications can be prevented at the source, thus allowing notifications to only be generated when a user is in a receptive state. In addition, a program is able to utilize the test notifications to determine a user's context, even if the program generally utilizes a different user interface for its own notifications. These aspects allow for greater flexibility in the potential uses of the user context system. These aspects also enable new richer scenarios for other programs, such that the system as a whole can become richer and more intelligent based on the user's behavior and preferences.","While the preferred embodiment of the invention has been illustrated and described, it will be appreciated that various changes can be made therein without departing from the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing aspects and many of the attendant advantages of this invention will become more readily appreciated as the same become better understood by reference to the following detailed description, when taken in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
