---
title: System and method of conclusively verifying the correctness of an information system without needing to test every combination of behavior at run-time
abstract: An architecture for the initial development and later adaptation of systems comprising a database, one or more client or user-interface programs whose system data, application data and rule data are stored in the database alongside the content. A framework in the database stores system, application and rule data and frameworks in the user-interface and client programs load the system, application and rule data to generate objects and, in doing so, define an application-specific system. Data integrity checks of the system data, application data and rule data using triggers and/or stored procedures ensure the correctness of the system without having to test every combination of behavior at run-time.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09582531&OS=09582531&RS=09582531
owner: 
number: 09582531
owner_city: 
owner_country: 
publication_date: 20131024
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","DEFINITIONS"],"p":["This application is a continuation of U.S. patent application Ser. No. 12\/520,274, entitled \u201cSYSTEM AND METHOD OF CONCLUSIVELY VERIFYING THE CORRECTNESS OF AN INFORMATION SYSTEM WITHOUT NEEDING TO TEST EVERY COMBINATION OF BEHAVIOR AT RUN-TIME,\u201d filed by Paul Leslie Tomkins, which is a national stage entry under 35 U.S.C. 371 of PCT\/GB08\/00296, filed on Jan. 30, 2008, which claims priority upon UK Patent Application No. 0701915.1 filed on Feb. 1, 2007, the entire disclosures of which are incorporated herein by reference.","1. Field of the Invention","The invention relates to the initial development and later adaption of applications and in particular to information systems which include a database and one or more clients or user-interfaces. The invention goes beyond the simple storage of content data in the database to the storage of system data, application data and rule data required to develop and run an information system. On connecting to the database a client or user-interface program loads the system data, application data and rule data to generate an information system.","2. Relevant Background","Information systems are well-known. Examples include accounting, stock control and contact management systems. At a simple level, each of these systems comprise a database and one or more clients or user-interfaces. At an intermediate level of detail, they comprise tables, content data, data sets, forms and rules. At a more detailed level, an information system is composed of tables, fields, data types, indexes, data sets, entities, columns, joins, filters, data sources, menus, menu widgets, toolbars, tool widgets, forms, form widgets, events, functions, blocks, iterations, conditions, tests and statements.","While a stock control system will clearly have a different set of application tables, fields, data sets, forms, rules and content data to a contact management system both information systems are made up of substantially the same features like tables, content data, data sets, forms and rules. It is in the number and behaviour of these features that information systems differ.","The behaviour of each of these features has to operate in harmony with the behaviour of the other features for the system to work correctly. Assume an information system has a number of tables, fields and rules. It is not uncommon, either during the initial development or later adaptation, for the data structure of an information system to be changed. This means that tables and fields might need to be added, renamed or removed. However, the action of changing the data structure means that anything dependent on that data structure will also need to be updated. For example, any relationship rules between the tables may have to be updated and any validation rules which reference a changed field will have to be updated. As updates are made so the developer has to ensure that those changes do not affect features further up the stack. Clearly, the lower in the stack that a change is made, where the chain of dependencies is longer, the more checks and updates need to be performed and the more time-consuming and error-prone changes become.","What makes the initial development and later adaptation of information systems using the traditional architecture time-consuming and error-prone is that the traditional architecture does not make it easy to identify dependencies or to conclusively verify the correctness of an application.","The way in which features are defined in the traditional architecture do not make it easy for dependencies to be identified. Often in the traditional architecture the definitions of tables and fields are embedded in the database API, Application Programming Interface; rules are defined in a proprietary procedural SQL, Structured Query Language, in the database or in C++ or Basic in the client or user-interface; data sets are defined as SQL strings and user-interface elements are defined in C++ or Basic. It therefore requires the developer to locate and search through the code to identify and update dependencies and to verify that references point to actual objects and that those referenced objects are computationally compatible.","Information systems differ architecturally in where they incorporate different features; the database, the client or user-interface or any combination of these. Content data is always stored in the database and forms are always a feature of the user-interface. But rules and data sets can be defined in the database, the client or user-interface or a combination of any of these and even sometimes reproduced in the database, the client or user-interface. The effect of this distribution of features is that developers can only really demonstrate the correctness of a system by testing every possible combination of behavior at run-time.","Given that information systems are so difficult to build, update and verify it is little wonder that users buy off-the-shelf packages and adapt their processes to the package rather than adapting the package to their processes. It is also the reason why customized systems are so time-consuming, expensive and error-prone and why so much development overshoots schedules and budgets and why so many projects fail altogether.","What is needed is an architecture which allows information systems to be developed and adapted quickly and where the application can be assured of correctness irrespective of whatever changes it is subjected to.","The object of this invention is to provide an architecture for the initial development and later adaption of information systems which includes a database and one or more client or user-interface programs so that applications can be developed and adapted quickly and where the application can be assured of correctness irrespective of whatever changes it is subjected to.","Accordingly, this invention provides a system comprising a database, one or more client or user-interface programs and any number of supporting libraries whose system data, application data and rule data are stored in the database alongside the content data so that the correctness of the system can be ensured.","Preferably the system structures, application structures, system data, application data, rule data and content data are stored in the same relational database but may instead be stored in different relational databases, in non-relational databases, in any persistent store or an in-memory structure; all application-specific properties and events are stored in the database but some properties and events can be stored external to the database; the integrity checking occurs both at the user-interface or client and then again at the database but such checks could occur any number of times at the point of selecting the options in the user-interface, in a middleware application through which data is passed between the user-interface or client and the database, or on committing the changes in the database.","The present invention describes an architecture for an information system which includes a database and one or more client or user-interface programs so that information systems can be developed and adapted quickly and where the application can be assured of correctness irrespective of whatever changes it is subjected to.","The key aspect of the present invention is the storage of system data, application data and rule data in the database alongside content data in such a way that the integrity of the system is ensured. Hence, to understand the description of the present invention we will start with how information systems are traditionally designed and methodically re-architect the process one stage at a time such that a person skilled in the art can follow the logic, appreciate the benefits and replicate the architecture.","The description will provide the opportunity to demonstrate how supplementary features can be added to an information system in the form of extensions and how such extensions are integrated consistently into the architecture of the present invention. The description will then take as an example a basic order entry system which exhibits all the core features of an information system.","A database is in any persistent store or in-memory structure in which data is stored. A program is a generic user-interface or client which provides the framework into which the number and behaviour of system and application-specific features are loaded, which generates instances and customizes the behaviour of application-specific objects and from which system and application rules can be executed. In doing so, generic user-interface and client programs are transformed into application-specific user-interface and clients. In the present invention, a distinction is made between a user-interface program and a client program. The present invention provides a module for the Apache HTTP web server. The module connects to the database like a user-interface program but does not directly provide a user-interface. The user-interface to the module is provided independently by the web browser.","System structures are defined as structures which are consistent across all types of information system. For example, system structures comprise the tables, fields, data types and rules which features common to all types of information systems can be stored in and validated with. Such features include the tables, fields, data types, indexes, data sets, entities, columns, joins, filters, data sources, menus, menu widgets, toolbars, tool widgets, forms, form widgets, events, functions, blocks, iterations, conditions, tests and statements of an information system.","Application structures are defined as structures which are specific to a type of information system. In a basic order entry system application structures might include tables and fields to store products, customers, orders and the individual order lines data.","System data is defined as data which is consistent across all types of information systems. System data lists the system tables, system fields, system data types and system rules which are common to all types of information system. In the present invention the boolean field SYS_IS_SYSTEM is set to 1 to identify system data as opposed to application data in the system structures.","Application data is defined as data which distinguishes one type of information system from another. Application data lists the number and behaviour of the features required by the specific information system. For example, application data lists the application-specific tables, fields, data types, indexes, data sets, entities, columns, joins, filters, data sources, menus, menu widgets, toolbars, tool widgets, forms, form widgets events, functions, blocks, iterations, conditions, tests and statements and the application-specific behaviour of each of these individual features. In the present invention the boolean field SYS_IS_SYSTEM is set to 0 to identify application data as opposed to system data in the system structures.","Content data is defined as data stored in the application-specific structures. In a basic order entry content data might include the list of products, customers, orders and the content of the individual lines of an order.","Rule data is defined as data which is used to ensure the correctness of the system, application and content data. In the present invention the boolean field SYS_IS_SYSTEM is set to 1 to indicate system rules and to 0 to indicate application rules in the system structures.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 1"},"Database architecture generally makes the list of tables accessible through the application programming interface, API, of the database. The API also lists which fields belong to which tables; the data types of the individual fields and the indexes that are applied to those fields.","Some databases, Firebird as an example and the database used in the present invention, go further and provide this meta data in Firebird tables RDB$RELATIONS as illustrated in , RBD$RELATION_FIELDS as illustrated in , RBD$FIELDS as illustrated in and a combination of RDB$INDICES and RDB$INDEX_SEGMENTS as illustrated in . That this information is available in a structured format consistent with the architecture proposed by the present invention provides further reliability as explained below.","Changes to the database, usually expressed in DDL, data definition language, examples of which appear in , ensure that a field can never be assigned to a non-existent table; that a field can never be assigned a non-defined data type and that an index can never be applied to a non-existent field.","The database further ensures that if a table is deleted or renamed, usually expressed in DDL, examples of which appear in , then all the fields assigned to that table are deleted or reassigned to the renamed table. If a field is deleted or renamed any indexes assigned to that field are deleted or reassigned to the newly renamed field. The database will reject a request to delete or rename a data type which is referenced by a field.","Internally, most databases maintain the integrity of their meta data as described above. Relational databases, in particular, go further in providing tools like triggers and stored procedures to developers to maintain the integrity of the content data as well. The present invention uses this feature to provide an environment for the initial development and later adaptation of information systems which ensures the correctness of the system.","The present invention can now use this table, field and data type meta data provided by structures in Firebird illustrated in to provide a further list of tables, fields and data types as system data in system structures.",{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0087","num":"0086"},"figref":["FIG. 5","FIG. 4","FIG. 5"]},{"@attributes":{"id":"p-0088","num":"0087"},"figref":["FIG. 6","FIG. 4","FIG. 5"]},"The reader will notice that indexes are defined in the table SYS_FIELD by the boolean flag fields, SYS_ASC_INDEX and SYS_DESC_INDEX, and that as a consequence there is no need for a separate system table to store this data.","By linking the system data with the Firebird provided meta data this invention can be confident that the tables, fields, data types or indexes listed as the system data do exist and are defined as listed in the actual database. That this meta data provided by Firebird is available in a structured format consistent with the architecture of the present invention provides the architecture with absolute reliability as shown in which illustrates how the data in system table SYS_TABLE maintains integrity with the Firebird meta data provided by RDB$RELATIONS with a join on SYS_TABLE.SYS_NAME and RDB$RELATIONS.RDB$RELATION_NAME; which illustrates how the data in system table SYS_FIELD maintains integrity with the Firebird meta data provided by RDB$RELATION_FIELDS with a join on SYS_FIELD.SYS_NAME and RDB$RELATION_FIELDS.RDB$FIELD_NAME; which illustrates how the data in system table SYS_DATA_TYPE maintains integrity with the Firebird meta data provided by RDB$FIELDS with a join on SYS_DATA_TYPE.SYS_NAME and RDB$FIELDS. RDB$FIELD_NAME and illustrates how indexes defined in system table SYS_FIELD maintain integrity with the Firebird meta data provided by RDB$INDICIES and RDB$INDEX_SEGMENTS with a join on RDB$INDEX_SEGMENTS.RDB$FIELD_NAME and SYS_FIELD.SYS_NAME.","The reader will notice that the definition of system tables, but not Firebird meta data structures, like SYS_TABLE in  and SYS_FIELD in , contain foreign keys. Unless specified otherwise, the foreign key references the field with name SYS_IDENTITY in the table of the same name as the foreign key field. In the present invention, the primary key is always one field with the name SYS_IDENTITY. The illustrations also help identify the foreign keys which show a relationship line joining the foreign key to the primary key. Unless specified otherwise, the value in the foreign key field must contain a value in the referenced table's primary key or 0. Unless specified otherwise, referential integrity between tables is a one-to-many relationship type.","For example, table SYS_FIELD has a foreign key field, SYS_TABLE, which references field SYS_IDENTITY in table SYS_TABLE in a one-to-many relationship. Table SYS_FIELD has a foreign key field, SYS_DATA_TYPE, which references field SYS_IDENTITY in table SYS_DATA_TYPE in a one-to-many relationship. Table SYS_FIELD also has a foreign key, SYS_WIDGET_TYPE, which references field SYS_IDENTITY in table SYS_WIDGET_TYPE in a one-to-many relationship. Table SYS_WIDGET_TYPE is discussed below.","The SYS_TABLE and SYS_DATA_TYPE foreign key references in table SYS_FIELD are further controlled by references in the Firebird meta data, as illustrated in and , which ensure that the field listed in SYS_FIELD is actually a field in the table that SYS_FIELD.SYS_TABLE claims to be a member of and that the field is actually of the type that SYS_FIELD.SYS_DATA_TYPE claims to be.","Integrity is maintained between the present invention's system data and Firebird meta data using procedural SQL in triggers in Firebird such that whenever a table, field, data type or index in Firebird is added, removed or changed a trigger executes and synchronizes the system tables, SYS_TABLE, SYS_FIELD and SYS_DATA_TYPE. Further triggers written in Firebird procedural SQL ensure that data in tables SYS_TABLE, SYS_FIELD and SYS_DATA_TYPE does reflect the meta data in the tables RDB$RELATIONS, RDB$RELATION_FIELDS, RDB$FIELDS, RDB$INDICIES and RDB$INDEX_SEGMENTS.","All other integrity rules, unless otherwise specified, operating on system, application or content data are defined with the present invention's rules which are described below.",{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 8"},"The field SYS_CAPTION in tables SYS_TABLE, SYS_FIELD and SYS_DATA_TYPE stores the user-friendly name of the object which is displayed in the user-interface in contrast to field SYS_NAME which stores the internal name of the object.","The first stages, therefore, in re-architecting the initial development and later adaptation of information systems is to provide system data types in which to store system data and to provide system tables and fields to list the tables, fields, data types and indexes defined in the database. The present invention builds on this foundation as will be described later.",{"@attributes":{"id":"p-0099","num":"0098"},"figref":"FIG. 1"},"Examples of rules in the traditional architecture are illustrated in . When rules are incorporated into the database and multiple clients and user-interfaces, for example, a desktop client, a web server or a web client, it is common for that programming logic to be reproduced and written in different computer languages for each environment. For example, a validation rule written inside the database may be written in a proprietary procedural SQL language; the same validation on a desktop client may be written in C++ or Basic and either compiled into the application or interpreted by the application. On a web server, the same validation may be coded in PHP and, in a web client, the same validation may be re-coded again in JavaScript. In this situation, there is the high possibility of subtle differences in logic creeping into the system because of language differences.","Accordingly, the present invention resolves these two issues by storing all rules in the database, by declaring a rule syntax as XML, extensible mark-up language, and by executing the interpreted rule scripts through the same dynamically linked function libraries. This is illustrated in .","By calling the same dynamically linked function libraries, executed from the database and any client or user-interface, the possibility of subtle differences in logic creeping into the system is substantially reduced. Any difference in logic would then owe its existence to the presence of functions in one environment and absence in another or to different versions of the same functions between environments.","The two potential causes for inconsistency, absence of functions and version differences, could be eliminated by running the database and all clients and user-interfaces on the same machine thereby sharing the same dynamically linked function libraries. This, however, is not always possible in a client-server environment.","The present invention proposes to write, as illustrated in , a rule interpreter class for the Firebird database engine, the database used in the present invention, which will be able to load the rule XML, described below, for the event being executed. The rule interpreter class will not only have access to the transaction context in which the event is being executed but also will be able to call the appropriate functions which are organized into dynamically linked libraries again shown in .  list sets of functions that are frequently shipped with most programming tools and shipped with the present invention.","The present invention also proposes to write, as illustrated in , a rule interpreter class which can be shared by all clients and user-interfaces, which will be able to load the rule XML, described below, from the databases and, like the rule interpreter class in the database, described above, will not only have access to the data source, described below, in which the event is being executed but also will be able to call the appropriate functions which are organized into dynamically linked libraries shown in  and .","The sets of functions listed in  are designed in the present invention to be callable from the rule interpreter engine used by the database or from the rule interpreter engines used by the clients or user-interfaces.","Rules are defined as scripts which comprise variables, conditions, iterations and functions and the present invention provides two types of functions, function wrappers and custom functions.","Function wrappers are scripts that provide direct access to the pre-compiled functions shipped with the system by calling them directly. Examples of such pre-compiled functions, shown in , are shipped with most programming tools and, in the present invention, are organized into dynamically linked function libraries when they need to be called equally by the database and any clients or user-interfaces.  shows function wrappers as they would be defined in C++ in comparison with how they are defined in the present invention's XML format which the end-user calls in custom functions or in event scripts.","Not all function wrappers call pre-compiled functions in dynamically linked libraries. Function wrappers may also call functions defined directly in the database, client, user-interface, operating system or any external application. Defining a function directly in the database, client or user-interface is appropriate when the functionality provided by that function applies only to the database, client or user-interface. An example may be a function to return the current transaction number in the database or a function to maximize the user-interface program.","Custom functions are scripts defined by the end-user of the information system. An example of a custom function in the traditionally architecture is shown in and the same function described in present invention's XML format is shown in . Function wrappers and custom functions can be re-used in as many other custom functions or event scripts as the user chooses.","The programming paradigm of the present invention, like most information systems, uses event-driven programming where code is executed as a result of, for example, clicking a button, updating a record or receiving an HTTP request. On the occurrence of such events scripts are executed.","Most databases provide events of the type BEFORE_INSERT, AFTER_INSERT, BEFORE_UPDATE, AFTER UPDATE, BEFORE_DELETE and AFTER DELETE which are executed whenever records are inserted, updated and deleted from tables. By calling the proposed rule interpreter from within the database on each of these events with the type of event, the sender of the event and the identity of the transaction the interpreter can look up the appropriate event XML script and execute it.",{"@attributes":{"id":"p-0113","num":"0112"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0114","num":"0113"},"figref":"FIG. 5"},"The reason why the same event is executed both on the database and the client or user-interface is that executing the event on the database provides assurance that the validation, taken as the example here, will always be executed thus maintaining the integrity of the data. However, there is network latency between the user requesting that some data should be changed on the database and the response from the database that the request has been received and accepted or rejected by the database. To improve the responsiveness, the same rule may be applied on the client or user-interface to give immediate feedback to the user as to whether the database is likely to accept or reject the input.","User-interfaces tend to have a more comprehensive array of possible events as shown in . As the description progresses the reader will see that the present invention provides handlers which allow client and user-interface events to be bound to scripts in a manner consistent with the way in which table and field events are bound to scripts as described above.","In the present invention, the syntax of function wrappers, custom functions and event scripts is defined in XML. An example of a function wrapper was provided in . An example of a custom function is provided in . An example of an event script is provided in and ","The next stage therefore in re-architecting the design of information systems is to provide functions and scripts in XML format which can be interpreted consistently from the database, user-interface or client.","From the XML definition of function wrappers, custom functions and event scripts, the present invention derives a set of data structures in which to store the constituent parts of a rule. This is shown in  which illustrates how the constituent parts of a rule script are decomposed and organized into tables and fields;  which illustrates how events are bound to scripts;  which illustrates how functions are bound to scripts; and  which illustrates how arguments used in function wrappers, custom functions and event scripts are defined for the scripts. These structures are discussed in more detail below.","Assume from this point in the description that the definition of all system and application tables created will be inserted into system table SYS_TABLE and that the definition of all system and application fields created will likewise be inserted into system table SYS_FIELD as described above. This means that each of the tables and fields in the set of data structures in which the present invention stores the constituent parts of a rule will be inserted into SYS_TABLE and SYS_FIELD respectively.","To produce the XML definitions of rules a stored procedure is employed within the database which collects the rule data from the data structures and generates the XML. The rule interpreter built into the database, illustrated in , can then load this XML, parse the XML and execute the script. Similarly, the rule interpreter in the clients and user-interfaces, also illustrated in , can also load this XML from the database, parse the XML and execute the script.","By decomposing the rules into its constituent parts and storing each part as a discrete entry in the database and imposing integrity constraints the present invention provides the further and more important benefit of ensuring that only those functions which return values of the correct or a compatible type can be used.  shows a field defined in an information system whose value is automatically generated. This is often called a formula field. If the data type of the field were defined as a double data type then, logically, the function which returns the value must return a double or a data type which can be cast to a double. Notice in  how the combination of the value of field UNIT_COST and the value of QUANTITY can be cast to a double.  shows an example of a formula field, DATE, whose data type, DATE, is incompatible with the assignment data type which is a DOUBLE. This would result in unpredictable behaviour. Likewise, a function may take a series of parameters with each parameter being a specific type as illustrated in . If the data type of a parameter were defined DATE data type then, logically, the argument value must be a DATE or a value which can be cast to a DATE. It is possible in interpreted languages for an argument in a function to be of a data type incompatible with the data type as defined by the parameter in the function declaration. In such a scenario, as illustrated in  where the first parameter requires a DATE data type but is inappropriately assigned a DOUBLE data type, this would result in unpredictable behaviour. However, the present invention removes all possibility of such errors from occurring by imposing integrity constraints.","An important feature of the present invention is that the integrity of the data used to define the rules, like all other data, is maintained thereby ensuring the correctness of the application. Because a rule script, decomposed into its constituent parts with each part stored as a discrete entry in the database, is unusual and difficult to achieve the explanation will show how scripts are decomposed, where the constituent parts are stored and the integrity constraints that must be applied.",{"@attributes":{"id":"p-0124","num":"0123"},"figref":"FIG. 16"},"This is illustrated in a more usual way in  which shows the script as it is displayed in the user-interface and which points out the individual blocks in the script identifying the different condition blocks and the iteration blocks. In  there are three blocks with the first block an unconditional block, the second block an iteration block and the third block a conditional block.","In the interpreter, , if SYS_CONDITION is non-zero then the condition referenced will be executed and if SYS_ITERATION is non-zero then the iteration referenced will be executed.","A condition as defined in table SYS_CONDITION, shown in , may be one of two basic types. The first type is a condition in which there are tests which must evaluated and where the result of the evaluation determines whether the condition is passed. Such conditions may have quantifiers like \u201cif all the following are true\u201d or \u201cif any of the following is true\u201d. The second basic type of condition has no tests and is always executed. This is very similar to a final else condition and in the present invention this is how it is executed. SYS_QUANTIFIER has a value corresponding to the type of condition. In the present invention a value of 0 in SYS_QUANTIFIER indicates that the condition has no tests and will always be executed.","This is illustrated in a more usual way in  which shows the script as it is displayed in the user-interface and which points out the conditions in the script. The reader will also see the \u201celse\u201d condition in  which is common to scripts.","When SYS_QUANTIFIER has a value other than 0 SYS_ELSE_CONDITION must be non-zero. As can be see from  SYS_ELSE_CONDITION is a foreign key pointing back to SYS_CONDITION. The meaning of this self-referencing is to identify the next condition in the block. The final \u201celse\u201d condition has a 0 in the SYS_ELSE_CONDITION field. This is illustrated in a more usual way in . Integrity rules not only ensure the rules described above but also that circular references do not occur.","Like modern programming languages, in the interpreter, , the first condition to return a value of true after executing the tests, described later, is the condition whose statements, also described later, will to be executed.","An iteration, as defined in table SYS_ITERATION, shown in , contains a foreign key reference to the dataset as defined in table SYS_DATA_SET. The iteration is executed in the interpreter as a loop over the dataset referenced.  helps to illustrate an iteration over a dataset.",{"@attributes":{"id":"p-0132","num":"0131"},"figref":"FIG. 16"},"This is illustrated in the more usual way in  which shows a series of tests as they are displayed in the user-interface and which identifies the types of tests in the condition. Field SYS_SEQUENCE specifies the order in which the tests must be performed.","In the interpreter, , if SYS_SUBFUNCTION is non-zero then the function referenced will be executed and the boolean test value will be returned to the condition referenced in SYS_CONDITION and if SYS_SUBCONDITION is non-zero then the condition referenced will be executed and the boolean result of that condition will be returned to the condition referenced in SYS_CONDITION.",{"@attributes":{"id":"p-0135","num":"0134"},"figref":"FIG. 16"},"This is illustrated in a more usual way in  which shows a statement as it is displayed in the user-interface within the context of a condition or an iteration. Field SYS_SEQUENCE specifies the order in which the statements must be performed.",{"@attributes":{"id":"p-0137","num":"0136"},"figref":"FIG. 16"},"This is illustrated in a more usual way in  which shows three statements, a function, a condition and an iteration within the context of a condition as they are displayed in the user-interface. Field SYS_SEQUENCE specifies the order in which the statements must be performed.","In the interpreter, , if SYS_SUBFUNCTION is non-zero then the function referenced will be executed; if SYS_SUBCONDITION is non-zero then the condition referenced will be executed; and if SYS_SUBITERATION is non-zero then the iteration referenced will be executed.","In the paragraphs above, the explanation has stated that a function will be executed by the interpreter. A function, whether it is a function wrapper or a custom function has a list of parameters as illustrated in . Each parameter lists only the data type and its position. This is shown in  where table SYS_FUNCTION_PARAMETER has a foreign key field, SYS_INPUT_TYPE, which stores the data type and a field, SYS_SEQUENCE, which stores the position of the parameter in the parameter list. Rules maintain the integrity of the data by ensuring that the value in field SYS_INPUT_TYPE references a data type as listed in table, SYS_DATA_TYPE, and that each parameter in the list of parameters for a function has a unique sequence number as identified by SYS_SEQUENCE.","When a function is called, the parameters are populated by argument values. This is illustrated in  where the parameters of function definitions need to be populated by argument values in the two callable instances of functions. Individual function arguments are listed in table SYS_FUNCTION_ARGUMENT shown in . In table SYS_FUNCTION_ARGUMENT, field SYS_FUNCTION_INSTANCE is a foreign key to the callable instance of the function in which the argument is used. Field SYS_FUNCTION_PARAMETER is a foreign key which identifies the parameter that the argument represents. The value of each argument in each function instance is defined as a reference in table SYS_REFERENCE shown in .","Integrity rules ensure that the data type of the reference as listed in table SYS_REFERENCE is compatible with the data type of the parameter as listed in field SYS_INPUT_TYPE of table SYS_FUNCTION_PARAMETER. This resolves the issue of compatible data types which were described above and illustrated in  and .",{"@attributes":{"id":"p-0143","num":"0142"},"figref":"FIG. 19"},"Fields are listed in the system table, SYS_FIELD. Field SYS_TABLE in table SYS_FIELD identifies the name of the table of the field referenced in SYS_REFERENCE. Context identifies the record that provides the value of the argument. Relationship rules between tables provide the context. The relationships provide a list of the available tables and the links between these tables. With the available links, context is able to navigate the database table structure to access records in tables related to the record being manipulated. This is illustrated in . For example, if an event executing on ORDER where SYS_IDENTITY=4 needs to access the value of the field DISCOUNT in table CUSTOMER then context is aware of the relationship between tables ORDER and CUSTOMER and knows that the current ORDER record is related to the record in CUSTOMER where CUSTOMER.SYS_IDENTITY=1 by the foreign key reference in ORDER.CUSTOMER. Similarly, if an event executing on ORDER where SYS_IDENTITY=4 needs to sum up the value of the fields QUANTITY and UNIT_COST in table ORDER_LINE then context is aware of the relationship between tables ORDER and ORDER_LINE and knows that the current ORDER record is related the list of records in ORDER_LINE where ORDER_LINE.ORDER=4 which in  references three records where ORDER_LINE=5, 6, and 7. Events and the sender argument of the event are described below.","Literal values are stored in the system table, SYS_LITERAL. Table SYS_LITERAL is described in . It stores the data type of the value in field SYS_DATA_TYPE which is a foreign key referencing table SYS_DATA_TYPE and the user-friendly name in field SYS_CAPTION. The value of the literal value is stored in fields SYS_STRING, SYS_NUMBER or SYS_BINARY. If the data type of the literal value is a type of string then the value is stored in field SYS_STRING and fields SYS_NUMBER and SYS_BINARY are left empty. If the data type of the literal value is a type of number then the value is stored in field SYS_NUMBER and fields SYS_STRING and SYS_BINARY are left empty. If the data type of the literal value is a type of binary then the value is stored in field SYS_BINARY and fields SYS_NUMBER and SYS_STRING are left empty. shows some example literal values.","Variable values are stored in the system table, SYS_VARIABLE. Table SYS_VARIABLE, is described in and stores the data type of the variable in field SYS_DATA_TYPE which is a foreign key referencing table SYS_DATA_TYPE, the internal name of the variable in field SYS_NAME and the user-friendly name in field SYS_CAPTION. shows some example variables which are programmatically available within the Firebird database.","Function return values are dynamically calculated when a function is executed.  shows field SYS_OUTPUT_TYPE of table SYS_FUNCTION_DEFINITION which is a reference to the data type of the function's return value. This is also illustrated in .","To perform any useful work a script must call compiled functions. While function wrappers call compiled functions directly, custom functions must call compiled functions indirectly. The task of the interpreter is to parse the function wrapper and custom functions and to call the compiled functions as described in . The library and name of the compiled function is stored in fields SYS_LIBRARY and SYS_ENTRY_POINT in table SYS_FUNCTION_DEFINITION which is illustrated in  A-C. With this information the interpreter is able to call the interpreted function passing the correct arguments and accepting the appropriate return value data type.","Custom functions differ from function wrappers in that they comprise a definition which, in turn, comprises a collection of blocks as illustrated in  where table SYS_BLOCK has a foreign key reference, SYS_FUNCTION_DEFINITION, to the function definition of which they are a member as listed in table SYS_FUNCTION_DEFINITION. Individual blocks are executed as described above. While the same function may appear as multiple instances in multiple events and custom functions the definition of those function instances is identical.",{"@attributes":{"id":"p-0150","num":"0149"},"figref":"FIG. 18"},"Having described functions in detail above the explanation of events follows an identical logic to that of functions as illustrated in  with the exception that, unlike functions, there are no event wrappers to compare to function wrappers. Instead, all events are customized instances which cannot be re-used in other event instances.  illustrates that table SYS_BLOCK contains a foreign key reference field, SYS_EVENT_INSTANCE, to the event instance of which they are a member as listed in table SYS_EVENT_INSTANCE rather than a function definition as explained about functions above.","Because the present invention uses event-driven programming paradigm this means that all scripts are executed as a result of some event as described in . Different types of events have different parameters as is common in event-driven applications. One noteworthy feature of events is the parameter which identifies the sender of the event and the parameter which identifies the identity of the transaction both of which contribute to context and acid compliance, Atomicity, Consistency, Isolation, and Durability.","Other than these differences, the explanation of events in the present invention follows the same path as that of functions and the reader is directed to that explanation for an understanding of event handling.","The modified architecture so far demonstrates that while information systems differ in the types of their rules, all information systems use rules. The present invention therefore discards the concept of embedding or compiling rule scripts in the database and the clients or user-interfaces as illustrated in  in preference for rules decomposed and stored as data in the database as shown in . By providing a rule interpreter to the database which can load and execute rules the present invention nudges the database file from an application-specific file with rules defined in procedural SQL and embedded in the database to a generic database where only rule data differs. By providing rule interpreters to the client and user-interface programs which can load and execute rules the present invention nudges the clients and user-interfaces from an application-specific client with rules embedded in the client and user-interface to a generic information system client or user-interface program where the application-specific logic is stored in the database and loaded from the database when the client or user-interface program connects to the database. That it is unusual to see rule scripts fully decomposed is the reason the description went to such lengths to describe the structures in which the discrete entries are stored and the validations imposed.","By decomposing the rules into discrete values in the database and applying integrity checking to each part of the rules such that the rules can be assured of correctness the present invention, so far, ensures that at least the rules can be assured of correctness irrespective of whatever changes the system is subjected to.",{"@attributes":{"id":"p-0156","num":"0155"},"figref":["FIG. 1","FIG. 32","FIG. 32"]},"Defining data sets in the database is appropriate for static data sets and defining data sets in the client or user-interface is appropriate for dynamic data sets. Both static and dynamic data sets are useful in information systems.","Given that data sets can reasonably be defined in the database or the client or user-interface the issue remains that the correctness of a data set is unknown until runtime if it is defined in the client or user-interface and, in some databases, even when it is defined in the database itself.","To resolve this issue the present invention proposes that instead of defining a data set as a block of text, as shown in , which is parsed out into its constituent parts at runtime by the database API, the definition of a data set be decomposed into its constituent parts with each part stored as a discrete entry in the database.",{"@attributes":{"id":"p-0160","num":"0159"},"figref":["FIG. 32","FIG. 33","FIG. 33"]},"The system field, SYS_FILTER, in system table SYS_DATA_SET is a foreign key to the primary key system field SYS_IDENTITY in system table SYS_CONDITION described above in rules. This is because a filter is a condition and, like other conditions, the results of the tests specified in table SYS_TEST identify which rows in the source table or source data set qualify for inclusion in the data set.","An entity, defined in SYS_ENTITY, identifies the table or data set that the data is to be taken from. The source of the entity may be either a table defined in table SYS_TABLE or a data set defined in table SYS_DATA_SET. The system field SYS_SOURCE_TABLE in system table SYS_ENTITY is a foreign key to the primary key in table SYS_TABLE and the system field SYS_SOURCE_DATA_SET in system table SYS_ENTITY is a foreign key to the primary key in table SYS_DATA_SET. If the source of the data is a table then SYSSOURCE_DATA_SET is set to 0. If the source of the data is a data set then SYS_SOURCE_TABLE is set to 0.","A column, defined in the system table SYS_COLUMN, identifies the field, column or expression that provides the data. The source of the column may be a field defined in SYS_SOURCE_FIELD which is a foreign key to the primary key in table SYS_FIELD; the source may be a column defined in SYS_SOURCE_COLUMN which is a foreign key to the primary key in table SYS_COLUMN or the source may be an expression defined in SYS_SOURCE_EXPRESSION which is a foreign key to the primary key in SYS_FUNCTION_INSTANCE described above. If the source of the data is a field then SYS_SOURCE_COLUMN and SYS_SOURCE_EXPRESSION are set to 0. If the source of the data is a column then SYS_SOURCE_FIELD and SYS_SOURCE_EXPRESSION are set to 0. If the source of the data is an expression then SYS_SOURCE_FIELD and SYS_SOURCE_COLUMN are set to 0.","If the source of an entity is a table then the source of each column in that entity must be either a field or an expression. If the source of an entity is a data set then the source of each column in that entity must be either a column or an expression. Integrity checks enforce these rules.","A join between entities, defined in the system table SYS_JOIN, identifies the two entities comprising the join and the two columns in each of those entities that are joined. The system field SYS_LEFT_ENTITY in system table SYS_JOIN is a foreign key to the primary key in system table SYS_ENTITY and the system field SYS_RIGHT_ENTITY in system table SYS_JOIN is also a foreign key to the primary key in system table SYS_ENTITY. The system field SYS_LEFT_COLUMN in system table SYS_JOIN is a foreign key to the primary key in system table SYS_COLUMN and the system field SYS_RIGHT_COLUMN in system table SYS_JOIN is also a foreign key to the primary key in system table SYS_COLUMN. The column defined in field SYS_LEFT_COLUMN of table SYS_JOIN must be a member of the entity defined in field SYS_LEFT_ENTITY of table SYS_JOIN as listed in table SYS_ENTITY. The column defined in field SYS_RIGHT_COLUMN of table SYS_JOIN must be a member of the entity defined in field SYS_RIGHT_ENTITY of table SYS_JOIN as listed in table SYS_ENTITY. The field, SYS_TYPE identifies the type of join which might be an inner join, a left outer join, a right outer join, a union or one of the many other types of joins. Rules ensure that the integrity described above is maintained.","Before a data set can be run the SQL needs to be generated from the definition stored in the data structures. A stored procedure in the database is used to assemble the constituent parts of the data set and generate the SQL.","Where a data set is required by a rule script, in particular one which comprises an iteration, then the SQL generated by the stored procedure can then executed by the interpreter.","The present invention abandons the concept of static SQL defined in the database and dynamic SQL mixed in with programming code in the client and user-interface and, in their place, provides a data set class in the clients and user-interfaces which loads the SQL from the database. This SQL is passed back to the database API as the data set definition which returns a set of data to the clients and user-interfaces in accordance with the SQL request.","This provision of a class in the user-interface or client which can create instances of objects whose customizable properties are loaded from values loaded from the database is a core architectural characteristic of the present invention and illustrated in and .","The definitions of data sets are no longer stored optionally in the database and the clients or user-interfaces. Instead, the definitions are always stored in the database. Further, that the storage of a data set definition in the database is no longer stored as a block of text as shown in  but decomposed into its constituent parts with each part stored as discrete entries in the database as illustrated in . By imposing integrity constraints the architecture can ensure the correctness of the data sets irrespective of whatever changes the system is subjected to.","A stored procedure exists in the database which assembles the SQL from the structures. If the script interpreter built into the database needs a data set in order to execute a rule then the interpreter can load the generated SQL which can then be executed. Finally, there exists a data set class in the clients and user-interfaces designed to load not only the constituent parts but also the generated SQL of that dataset from database which can be used in a call back to the database API which the database returns as a set of data in accordance with the SQL request called the data set.","The reader will be familiar with the concepts of object-orientated programming with its classes and objects and with the concepts of database design with its tables and records. An important feature of the present invention is that the classes in the client and user-interface have a correlation to the tables in the database. The present invention distinguishes customizable properties from public properties of object orientated classes in that customizable properties are designed to be populated with data loaded from the database whereas public properties are designed to be accessible by other classes.","This is illustrated in which shows a table with fields to store the customizable properties of PushButton object instances. The reader will note the correlation between the table, SYS_PUSHBUTTON, and the class PushButton and, in particular, the correlation between the fields in table SYS_PUSHBUTTON and the public properties of class PushButton. shows how records in table SYS_PUSHBUTTON correlation to object instances of the class PushButton where customizable properties are loaded from the table and set in the object instances. In , such customizable properties include the caption and icon.","By providing a data set class in the clients and user-interfaces which can load any SQL statement the present invention nudges the clients and user-interfaces from an application-specific client to a generic information system client program where the application-specific logic is stored in the database and loaded from the database when the client program connects to the database. The completed client and user-interface program shown in  is compared with the traditional client and user-interface application shown in .",{"@attributes":{"id":"p-0175","num":"0174"},"figref":["FIG. 1","FIG. 35"]},"The list of widgets available in the user-interface is stored in the database in table SYS_WIDGET_TYPE illustrated in . Each record in SYS_WIDGET_TYPE stores the caption, the icon of the widget type and, more importantly, the class name in which that widget type is defined and the library in which the class is made available if the widget definition exists in a library plugged into the user-interface.",{"@attributes":{"id":"p-0177","num":"0176"},"figref":["FIG. 37","FIG. 37"]},{"@attributes":{"id":"p-0178","num":"0177"},"figref":"FIG. 38"},"The user-interfaces of most information systems comprise form, menubar and toolbar features. The list of forms, menubars and toolbars available in the user-interface are stored in the tables, SYS_FORM, SYS_MENU_BAR and SYS_TOOL_BAR respectively. Individual instances of forms of class Form, menubars of class MenuBar and toolbars of class ToolBar available in the user-interface load their customizable property values from records in the tables SYS_FORM, SYS_MENU_BAR and SYS_TOOL_BAR respectively. This is illustrated in .","One application can contain many top-level windows with each top-level window having a separate menu bar. Each menu bar is listed in SYS_MENU_BAR. Each menubar can contain many menus. SYS_MENU, therefore, contains a foreign key field, SYS_MENU_BAR, which references the menubar which the menu belongs to. Referential integrity rules ensure that a menu does belong to an existing menu and that if a menubar is deleted from SYS_MENU_BAR that the menus listed in SYS_MENU and which belong to the menubar being deleted are in turn deleted ensuring that dangling menus never exist.","The list of menus available in the user-interface are stored in the database table, SYS_MENU. Each record in the table SYS_MENU stores the customizable properties for the individual object instances of class Menu, shown in , to be displayed in the user-interface.","Having in the previous paragraphs described widgets separately from menus, toolbars and forms the description will now describe how these are combined. illustrates a menu which contains a number of widgets. shows a toolbar which also contains a number of widgets. likewise shows a form which contains a number of widgets.","The table, SYS_MENU_WIDGET, illustrated in , stores the list of widgets which are contained on individual menus. The foreign key, SYS_WIDGET, is a reference to the widget in table SYS_WIDGET that appears on the menu identified by the field SYS_MENU which is a foreign key referring to the menu in Mable SYS_MENU. The field SYS_SEQUENCE specifies the order that the widgets appear on the menu.","The table, SYS_TOOL_WIDGET illustrated in , stores the list of widgets which are contained on individual toolbars. The foreign key, SYS_WIDGET, is a reference to the widget in table SYS_WIDGET that appears on the toolbar identified by the field SYS_TOOL_BAR which is a foreign key referring to the toolbar in table SYS_TOOL_BAR. The field SYS_SEQUENCE specifies the order that the widgets appear on the toolbar.","The table, SYS_FORM_WIDGET illustrated in , stores the list of widgets which are contained on individual forms. The foreign key, SYS_WIDGET, is a reference to the widget in table SYS_WIDGET that appears on the form identified by the field SYS_FORM which is a foreign key referring to the form in table SYS_FORM. The fields, SYS_LEFT, SYS_TOP, SYS_WIDTH and SYS_HEIGHT specify the position of the widget on the form.","In the architecture of the present invention the customizable properties of widgets are no longer stored in the user-interface but in the database. This does not mean that all the properties of widget instances need be stored in the database. It is only those properties which need to be customized by the application that need be stored in the database. These customizable property values of each widget type instance are stored in fields in the database and there exists widget classes in the user-interface designed to load the customizable properties from the database and create customized object instances of those widgets as illustrated in and ","Likewise, the customizable properties of forms, menubars and toolbars are no longer stored in the user-interface but in fields in the database and there exists form, menubar and toolbar classes in the user-interface designed to load the customizable properties from the database and create customized objects instances of those forms, menubars and toolbars as illustrated in and ","The customizable properties of menus on menubars and widgets on menus, widgets on toolbars and widgets on forms are no longer stored in the user-interface but in fields in the database and there exists a menu class in the user-interface designed to load the customizable properties from the database and create customized object instances of those menus as illustrated in and ","The modified architecture so far demonstrates that while information systems differ in the number and design of their widgets, forms, menubars, menus, and toolbars all information systems use widgets, forms, menubars, menus and toolbars. The present invention therefore discards the concept of embedding the definition of widgets, forms, menubars, menus, and toolbars in the user-interface in preference for decomposing the customizable properties and storing them as data in the database. By providing widget, form, menubar, menu, and toolbar classes in the user-interface which can load their custom property definitions from the database the present invention nudges the user-interface from an application-specific client to a generic information system client program where the application-specific logic is stored in the database and loaded from the database when the user-interface program connects to the database. The completed user-interface program shown in  is compared with the traditional user-interface application shown in .","By imposing rules on the structures, the present invention makes it easy to identify dependencies and to conclusively verify the correctness of an application such that, for example, a column in the dataset entity providing the source of data for a widget will always exist irrespective of whatever changes the system is subjected to.","The architecture of the present invention can be extended to provide further functionality. In an information system, such extended functionality may include specialized widgets or an e-mail module which can be plugged in. If extensions are present then these operate in the same way that shipped features operate.","A possible specialized widget that might be plugged in might be one that provides the display of measurements in feet and inches and we might call this specialized widget type Feetinch. To integrate this widget into the proposed architecture five steps need to be performed.","The first step is to make the FeetInch widget available to any applicable user-interface program because only the user-interface is able to display widgets.","This generally means making the code in which the widget is defined into a dynamically linked library that the user-interface program can load. The second step is to create a table in the database similar to that shown in  which provides a foreign key to the table SYS_WIDGET and lists all customizable properties as fields of a data type appropriate to hold the value and a foreign key field to SYS_EVENT_INSTANCE for each of the customizable events. The third stage is to add entries to SYS_EVENT_DECLARATION and SYS_EVENT_PARAMETER, as illustrated in , to define the number and order of parameters that each customizable event comprises. The fourth stage is to add a record into table SYS_WIDGET_TYPE which provides a user-friendly name and icon for the widget and the path to the dynamically linked library in which the class is defined as well as the name of the class in the dynamically linked library as illustrated in . The fifth and final task is to load into the rule structures all the rules required to enforce integrity of the Feetlnch widget's data. As explained above, extensions are integrated consistently into the architecture of the present invention.","Until this point the description has only briefly mentioned content data and user-defined rules. The description will now explain the steps the user must take to add their own application table, user-defined data type, a form to edit their content data and a button to execute a custom script. While the linear order in which the description may be logical it is not proposed that this will necessarily be the sequence followed in the actual development of the information system which often follows a more iterative pattern.","As explained above, application structures are defined as structures which are specific to a type of information system. In a basic order entry system, which exhibits all the core features of an information system, the user might require application tables and fields to store product, customer, order and the individual order line data.","The first stage is to establish some application specific data types which do not exist in the database. Let us assume that the application requires a specialized data type, not currently available in the database, to store part number data. This new data type shall have name \u201cPart_Number\u201d and the caption \u201cPart Number\u201d.","To create the new data types, the user must issue DDL commands to the database for each new data type as shown in . In Firebird, these statements will cause the database to add records to the meta data table RDB$FIELDS for each new data type as shown in . As explained above, the present invention installs a trigger on table RDB$FIELDS such that an insert into RDB$FIELDS will cause the database to add a record to table SYS_DATA_TYPE, an update RDB$FIELDS will cause the database to update the related record in table SYS_DATA_TYPE and a delete from RDB$FIELDS will cause the database to delete the related record in table SYS_DATA_TYPE. The structure and contents of table SYS_DATA_TYPE is shown in .","The second stage is to create four tables which are specific to the application. Let us assume that the application requires a table to store products, another to store customers, another to store orders and a table to list the individual lines in an order. For each new table to be created, the user must issue a DDL command to the database, an example of which is shown in . In Firebird, these statements will cause the database to add a record to the meta data table RDB$RELATIONS for each new table as shown in . For each field added, a record will be added to the meta data table RDB$RELATION_FIELDS as shown in . The structure and contents of table SYS_TABLE is shown in  and the structure and contents of table SYS_FIELD is shown in .","As explained above, the present invention installs a trigger on table RDB$RELATIONS such that an insert into RDB$RELATIONS will cause the database to add a record to table SYS_TABLE, an update RDB$RELATIONS will cause the database to update the related record in table SYS_TABLE and a delete from RDB$RELATIONS will cause the database to delete the related record in table SYS_TABLE. Likewise, a trigger is installed on table RDB$RELATION_FIELDS such that an insert into RDB$RELATION_FIELDS will cause the database to add a record to table SYS_FIELD, an update RDB$RELATION_FIELDS will cause the database to update the related record in table SYS_FIELD and a delete from RDB$RELATION_FIELDS will cause the database to delete the related record in table SYS_FIELD.","For each table created, a trigger must be installed for each of the events that the database makes available. In the case of Firebird, six events are available. These are BEFORE_INSERT, AFTER_INSERT, BEFORE_UPDATE, AFTER UPDATE, BEFORE_DELETE and AFTER DELETE which are executed whenever records are inserted, updated and deleted from tables. Code is added to each trigger to call the proposed rule interpreter with the type of event, the sender of the event and the identity of the transaction. An example is illustrated in .","The next stage is to change the field SYS_CAPTION in table SYS_DATA_TYPE to a user-friendly name if required using a DML, data manipulation language, commands for each new data type as shown in . The user-friendly names of tables can be changed by updating the value of field SYS_CAPTION in table SYS_TABLE using a DML command for each new table as shown in . Likewise, the user-friendly names of fields can be changed by updating the value of field SYS_CAPTION in table SYS_FIELD using a DML command as shown in ","Indexes must be added using DDL statements as shown in . As explained above, the present invention installs a trigger on table RDB$INDICES and RDB$INDEX_SEGMENTS such that an insert into, update on or delete from RDB$INDICES and RDB$INDEX_SEGMENTS will cause the database to update the related record to table SYS_FIELD by setting the values of fields SYS_ASC_INDEX and SYS_DESC_INDEX.","Relationships between tables can be implemented by updating the appropriate rule structures as illustrated in . Validation rules on fields can similarly be implemented by updating the appropriate rule structures as illustrated in .","If a default widget type needs to be assigned to each new field listed in table SYS_FIELD then the foreign key SYS_WIDGET_TYPE can be edited and a value which exists as the primary key of table SYS_WIDGET_TYPE entered into the field.","The next series of steps will provide the application with a form with which to edit the content data and a button to automate some application-specific process. However, before the form can be defined some data sets and a data source will need to be established.","The manner in which data sets are defined in the architecture of the present invention has been discussed earlier and illustrated in . Creating a new data set is a matter of manipulating those data set structures with DML commands. Data sources, on the other hand, have not been explained.","A data source is used to combine multiple data sets to display on one form in a master-detail arrangement. The structure of table SYS_DATA_SOURCE is illustrated in . Table SYS_DATA_SOURCE has a foreign key field, SYS_MASTER_DATA_SET and another foreign key field, SYS_DETAIL_DATA_SET, which references data sets listed in SYS_DATA_SET. Field SYS_MASTER_COLUMN and SYS_DETAIL_COLUMN are foreign keys which reference columns in SYS_COLUMN. A rule ensures that the column referenced in SYS_MASTER_COLUMN is a member of the data set referenced in SYS_MASTER_SET and that the column referenced in SYS_DETAIL_COLUMN is a member of the data set referenced in SYS_DETAIL_SET. Table SYS_DATA_SOURCE also has a foreign key field, SYS_FORM, which references a form listed in SYS_FORM and which determines which form a data source is the source of data for. Consistent with the present invention if a data set is deleted from table SYS_DATA_SET referential integrity rules will ensure that the data set reference in SYS_DATA_SOURCE is also deleted. If a form is deleted from SYS_FORM referential integrity rules will ensure that all the records in SYS_DATA_SOURCE referencing that form are also deleted.","Taking the example of a basic order entry system, four data sets may be defined with each data set loading all the fields from the four application tables with captions \u201cCustomer\u201d, \u201cProducts\u201d, \u201cOrder\u201d and \u201cOrder Lines\u201d. The data source may be a combination of these tables organized into a master-detail arrangement. This can be visualized in .","To create the form, the user inserts a record into table SYS_FORM with a caption like \u201cCustomer Orders\u201d. For each widget to appear on the form the user must add a record to the table SYS_WIDGET and add corresponding entries to the tables for each widget type, as shown in . If the widget is designed to display data from the database then the field SYS_COLUMN in table SYS_WIDGET must specify a column in the form's data source which provides the data. If the widget is a non-data widget like a push button then the field SYS_COLUMN can be set to 0. As described above, SYS_FORM_WIDGET must be completed with the list of widgets to appear on the form.","Validation rules assigned to fields in the database in table SYS_FIELD, field SYS_ON_VALIDATE are also executable on the client. The initiation rules assigned to fields in the database in table SYS_FIELD, field SYS_ON_INITIATE are valid only on a user-interface and provide what is commonly known as a default value and, like validation rules, are executable on the user-interface.","For widgets like a push button which is not a field editor \u201con click\u201d event rules must be defined in the table SYS_PUSHBUTTON, field SYS_ON_CLICK as described above. If the push button is to appear as a widget on the form, in a menu and on a toolbar then tables SYS_FORM_WIDGET, SYS_MENU_WIDGET and SYS_TOOL_WIDGET must be completed as described above.","In the present invention, the user executes the user-interface program with the architecture as shown in  and connects to a database with the architecture also shown in . On connection to the database, the client or user-interface programs loads the customizable properties, events and scripts from the database and with classes in the clients or user-interfaces generates object instances with those properties thereby constructing the application in the knowledge that the application is assured of correctness. It is not relevant whether the customizable properties, events and scripts need be loaded in their entirety immediately on connecting to the database or whether the customizable properties, events and scripts should be loaded from the database as they are needed.","The reader might have noticed that while the architecture of the present invention maintains the integrity of the system and ensures the correctness of the application, heavy demands are placed on the user in terms of executing valid DDL and DML statements. The description will now address the issue of making the initial development and later adaptation of the application simple, quick and error-free using so called \u201cdrag and drop\u201d and \u201cpoint and select\u201d user-interfaces.",{"@attributes":{"id":"p-0215","num":"0214"},"figref":["FIGS. 50, 50, 50, 50, 50and 50","FIG. 50","FIG. 50","FIG. 50","FIG. 50"]},{"@attributes":{"id":"p-0216","num":"0215"},"figref":["FIG. 50","FIG. 50"]},{"@attributes":{"id":"p-0217","num":"0216"},"figref":["FIG. 50","FIG. 20","FIG. 21","FIG. 10"]},"The traditional architecture of information systems was illustrated in  and makes the initial development and later adaptation of information systems time-consuming and error-prone because it does not make it easy to identify dependencies or to conclusively verify the correctness of an application except by testing every possible combination of behaviour at run-time. That traditional design was methodically re-architected one step at a time until the architecture proposed by the present invention is revealed in . This new architecture not only accelerates the initial development and later adaptation of information systems but also removes any possibility for error, makes dependencies easy to determine and provides within its design the ability to conclusively verify the correctness of an application without having to test every possible combination of behaviour at run-time."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A preferred embodiment of the invention will now be described with reference to the accompanying drawings in which:",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 2A-2D"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIGS. 7A-7D"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 11A-11H"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIGS. 12A-12B"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIGS. 14A-14C"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIGS. 15A-15B"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIGS. 29A-29B"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIGS. 30A-30B"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIGS. 34A-34B"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 39"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIGS. 41A-41C"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 42"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 43"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 44"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIGS. 45A-45B"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIGS. 46A-46C"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 47"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 48"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 49"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIGS. 50A-50F"},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 51"}]},"DETDESC":[{},{}]}
