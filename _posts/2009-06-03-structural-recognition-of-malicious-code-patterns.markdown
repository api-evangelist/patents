---
title: Structural recognition of malicious code patterns
abstract: Various embodiments include an apparatus comprising a detection database including a tree structure of descriptor parts including one or more root nodes and one or more child nodes linked to from one or more parent descriptor parts chains, each of the root nodes representing a descriptor part, and each root node linked to at least one of the child nodes, each root node and each child node linked to any possible additional child nodes, wherein the possible additional child nodes include any possible successor child nodes and a descriptor comparator coupled to the detection database, the descriptor comparator operable to receive data including a plurality of logic entities, once or successively, and to continuously compare logic entities provided to the tree structure of descriptor parts stored in detection database, and to provide an output based on the comparison.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09177144&OS=09177144&RS=09177144
owner: 
number: 09177144
owner_city: 
owner_country: 
publication_date: 20090603
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND INFORMATION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application claims the priority benefit of U.S. Provisional Application Ser. No. 61\/109,666 filed Oct. 30, 2008, the content of which is incorporated herein by reference in its entirety.","The present invention is related to computer network security, and more particularly, to systems and methods for recognition of malicious code patterns.","Increased access to the Internet has had the unintended effect of increasing the reach of software programs that capture personal information of users without their informed consent (\u201cSpyware\u201d) or that corrupt computers without the user's knowledge and informed consent (\u201cMalware\u201d). In addition, a cottage industry has arisen in software that automatically downloads and displays advertising while an application is being used (\u201cAdware\u201d). The terms malicious code pattern and malicious code include any type of software programs or code designed to infiltrate or damage a computer system without the owner's informed consent, regardless of the motivation for the software program, and regardless of the results caused by the software program on the owner's devices, systems, networks, or data.","In the following detailed description, reference is made to the accompanying drawings which form a part hereof, and in which is shown by way of illustration specific embodiments in which the invention can be practiced. It is to be understood that other embodiments may be utilized and structural changes can be made without departing from the scope of the present invention.","Malware authors frequently change (albeit small) parts of their creations, re-pack or re-compile new variants, in order to avoid detection by signature- or checksum based methods. \u201cProven\u201d code patterns found in an older variant of a malware family, or found in a publicly available Proof-of-Concept implementation, are very likely to be reused in later variants of the same malware family or other implementations for exploitation of known vulnerabilities. These variations thus may avoid detection by signature based or checksum based detection methods.","Therefore, systems, particular apparatus, and methods that determine the presence of a known code pattern, that had been found in a malicious code before, in a new, yet unknown file, would improve proactive detection rate on any such malware variants. While a \u201cfingerprint\u201d of a file is expected to be unique, e.g. no two different files should produce the same fingerprint\u2014like, for example, the file's MD5 checksum (128 bit), an algorithm allowing such proactive malware detection clearly needs to avoid any reliance on uniqueness as it would otherwise again be vulnerable to bypassing via slight modifications of the malicious code pattern.","Various embodiments of the systems and methods presented herein utilize two facts to overcome these deficiencies in previous detection systems and methods:\n\n","Various embodiments described herein include methods that target scripting languages, such as JavaScript and Visual Basic Script, and can equally be applied on any mobile code file formats, including native code formats, such as Microsoft's Win32 Portable Executable (PE) file format or Unix\u2032 Executable and Linking format (ELF), and byte code formats, such as the Java\u2122 class file format.","In general, the various methods are beneficial as they allow a system or particular apparatus to\n\n","In various embodiments, low memory footprint, high match lookup performance, and the ability to start match lookup on incomplete data is achieved by using a tree-based lookup algorithm and database. No state or context, other than pending match lookup paths in the database tree, need to be kept about previous findings in the currently scanned code \u201cstream\u201d.","In various embodiments, the detection for a known code pattern is called a \u201cStructural Code Pattern Descriptor\u201d (SCPD). For example, given a malicious script code sample where an obfuscation method has been used (e.g. the payload is encoded, and a decoder loop is attached), an SCPD can be created that describes the decoder loop algorithm. This SCPD will then match all malicious scripts that use the same, or nearly the same, decoder loop algorithm.","Likewise, an SCPD describing exploitation of a known vulnerability can match future variants exploiting the very same vulnerability. In various embodiments, an SCPD is stored as a combination of respective root nodes and child nodes in a detection database tree.","Embodiments described herein include methods that are different to, and better than, a simple rule list-based approach for categorizing known malicious behaviour. The embodiments are faster due to its tree-based nature and because various embodiments check only the (irreversible) checksums rather than full function names. Therefore, the various embodiments described herein fully support streaming as no contextual state list needs to be kept about all the previous findings; and provide more proactively as in that various embodiments of the methods do not match against an exact parameter, but rather, against a parameter's entropy; and still provide better protects against false-positives, as the inclusion of process flow and algorithmic operations into the detection improve the match accuracy (without loosing diffuseness where needed, that is, for the actual parameter values).",{"@attributes":{"id":"p-0021","num":"0031"},"figref":"FIG. 1","b":["100","100","114","116","114","114","116","100","114","100"]},"In various embodiments, protected portion  includes a gateway , although the embodiments are not limited to including a gateway. Gateway  is coupled to external portion  though an interconnect  to a network . Network  is not limited to any particular type or any given number of networks. In various embodiments, network  includes the Internet. In various embodiments, external portion  includes one or more external devices , such as but not limited to one or more external servers A-N. In various embodiments, external devices  includes at least one malicious server . As used herein, a malicious server includes any device, or any other source coupled to a server, that attempts to provide malicious code, or files that include malicious code, to the protected portion .","Devices  represent any number of devices A-N, such as but not limited to computer and servers, as illustrated by dotted line C, that are coupled to and protected within protected portion  of computer network . In various embodiments, devices A-N are coupled by one or more networks , which also couples devices A-N to gateway  through connection . In various embodiments, gateway  couples the plurality of devices A-N to network . The plurality of devices A-N are not limited to any number or types of devices, and can include any devices, such as but not limited to computers, servers, and databases that are coupled to an external network through gateway .","Devices A-N are referred to as being \u201cprotected\u201d because these devices are the devices configured to receive the anti-malware protection provided by gateway . In various embodiments, anti-malware protection includes detection of malicious code in any files that are intended to be sent into protected portion  of computer network . In various embodiments, anti-malware protection includes detection of malicious code in any files that are generated, sent from, or that reside on any of the plurality of devices A-N within protected portion  of computer network .","In various embodiments, gateway  includes an anti-malware engine . In various embodiments, anti-malware engine is operable to provide malicious code detection. In various embodiments, malicious code detection includes use of methods including comparisons using tree structures of one or more Structural Code Pattern Descriptors (SCPDs). In various embodiments, one or more configuration settings are stored in configurations , which is coupled to anti-malware engine . In various embodiments, configurations  is operable to store one or more configuration settings used by anti-malware engine  in the detection of malicious code, as further described herein. In various embodiments, configurations  stores one or more threshold values used in the malicious code detection processes, as further described herein.","In various embodiments, an interconnect  provides communications within gateway . In various embodiments, an interface  is coupled to interconnect  and is operable to allow a user to interface with gateway , including communication of inputs and outputs made between gateway  and interface . In various embodiments, interface  is operable to allow a user to review and to modify one or more of the configuration settings stored in configurations . In various embodiments, interface  is operable to provide information to a user concerning whether or not malicious code has been detected in a file entering into, or resident within, protected portion  of computer network . In various embodiments, when malicious code has been detected within a file entering into or resident on protected portion  of computer network , interface  is operable to provide a user with a single indication, or some combination of information, warning messages, and reports that are generated by anti-malware engine  as a result of the detection of malicious code.","In various embodiments, interface  includes memory  operable to store machine readable instructions that, when read and executed on a computer or by a processor, such as but not limited to anti-malware engine , or on a computer or processor included in interface , executes the functions described herein related to the detection and reporting of malicious code.","In various embodiments, database  is coupled to interconnect  and is communicatively coupled to anti-malware engine . In various embodiments, database  is operable to store any combination of tree structures including one or more Structured Code Pattern Descriptors.","In various embodiments, anti-malware engine  is coupled to comparison module . In various embodiments, comparison module  is operable to access one or more instances of tree structures for use in comparative searches being performed on an arbitrary file being checked to see if the arbitrary file includes malicious code. In various embodiments, comparison module  is operable to provide an output indicating whether or not an arbitrary file being checked for malicious code is determined to have or include malicious code. In various embodiments, the comparison module  provides one or more of the output indications described herein related to whether or not a particular arbitrary file includes malicious code. In various embodiments, any newly discovered malicious code can be processed and provided and stored in database  as modifications to existing tree structures, or as additional tree structures, or both.","In various embodiments, newly discovered malicious code is provided as a result of anti-malware engine  determining that an arbitrary file includes malicious code. In various embodiments, newly discovered malicious code is detected by some other anti-malware detection system or systems (not shown in ) outside protected portion  of computer network . In various embodiments, anti-malware detection systems outside protected portion  will provide the newly discovered malicious code to anti-malware engine  for processing as described herein, and for adding the processed results to database  for storage and later retrieval and use in detecting malicious code.","In this way, protected portion  is operable to automatically update its own database  as new malicious code is discovered, either at gateway , or from external sources. In various embodiments, database  is operable to be used to provide information about newly discovered malicious code detection to other anti-malware detection systems.","It would be understood that anti-malware engine  and the malicious code detection provided is not limited to being resident as part of a gateway. The malicious code detection can be provided in a variety of computing environments, including but not limited to network gateways, desktop computers, servers, back-end analysis systems, and within mobile communication devices such as cell phones and Personal Digital Assistants (PDAs). Malicious code detection can be applied anywhere where a device or a system is potentially exposed to malicious code.",{"@attributes":{"id":"p-0033","num":"0043"},"figref":"FIG. 2","b":["200","200"]},"As shown in , in various embodiments, a code dissector module  is coupled to an input , and is operable to receive at input  incoming data that is associated with one or more input files or input code. In various embodiments, the input file or input code is the arbitrary file referred to herein. In various embodiments, the incoming data includes an input file or input code provide at input  for the purpose of compiling a detection database, as further described herein.","In various embodiments, the incoming data includes an input file or input code provided at input  for the purpose of comparing the incoming data to one or more Structural Code Pattern Descriptors to determine if the input file or input code includes, or is likely to include, malicious code, as further described herein.","In various embodiments, code dissector module  includes an output  coupled to an input  of a code logic identifier . Code logic identifier  includes an output  coupled to an input  of a structural code pattern descriptor generator . Structural code pattern descriptor generator  includes an output  that is coupled to an input  of a detection database . In various embodiments, detection database  includes data representative of one or more tree structures of descriptor parts. In various embodiments, the one or more tree structures includes one or more paths forming Structural Code Pattern Descriptors, as further described herein.","In various embodiments, detection database includes a dictionary . In various embodiments, dictionary  is operable to store one or more string variables. In various embodiments, the dictionary  also contains a dictionary that maps a one or more particular paths through a tree structure into malware names. By way of illustration, a mapping \u201c1.1.3.2.1.1.3\u201d is matched to \u201cJS.SimpleDecoder.A\u201d. The ASN.1 OID-style notation (\u201c1.1.3.2 . . . . \u201d) is used here for illustrative reasons. In various embodiments, an actual implementation should associate a unique value with each node in a tree structure, such as its offset into the database, and the lookup algorithm using the detection database and the tree structure would need to know only about this unique value to continue the lookup at this match path.","In various embodiments, code logic identifier  includes an output  coupled to input  of a structural code pattern descriptor comparator . In various embodiments, detection database  includes and output  coupled to a second input  of the structural code pattern descriptor comparator . Structural code pattern descriptor comparator  includes an output  coupled to input  of a malicious code detector . Malicious code detector  includes an output . In various embodiments, structural code pattern descriptor comparator  is operable to compare one or more outputs provided by code logic identifier  to the one or more tree structures of descriptor parts stored in detection database , and to provide some type of output at output  based on the comparison.","In various embodiments, malicious code detector  is operable to receive, at input , output signals or output data from the structural code pattern descriptor comparator , and based on the received output signals or output data, to generate an output signal or output data at output , the output signal or data including an indication of whether or not malicious code has been detected in one or more of the incoming files received at input . The output signal or output data is not limited to any particular type of signal or data, and can be any signal or any data that includes an indication of whether or not detection of malicious code has occurred for one or more portions of the incoming data provided at input  in functional block diagram . In various embodiments, the output provided at output  includes a single data output, such as a single data bit, indicating whether or not malicious code has been detected, or indicating that the input data received at input  is likely to be malicious code. In various embodiments, the output signal includes, but is not limited to, a single data bit or a plurality of data bits set to values based on the output data, that are stored in one or more memory devices, such as but not limited to one or more memory registers ,  of a detection output module .","In various embodiments, the data output includes a memory register  having a single data bit set to a value indicating whether or not the input file or input code provided at input  includes, or is likely to include, malicious code. In various embodiments, the single data bit stored at memory register  is set (or in some embodiments\u2014cleared) to a first value, such as but not limited to a value of \u201c1\u201d if a input file or input code is determined to (or in some embodiments is determined to likely) include malicious code, and is set (or in some embodiments\u2014cleared) to a second value, for example but not limited to a value of \u201c0\u201d (zero) if a file is determined not to include (or is not likely to include based on some threshold value), malicious code. In various embodiments, a plurality of data bits  is provided to detection output module  and include a value, such as a probability, that indicate to what degree or likelihood of certainty the code received at input  is malicious code. In various embodiments, the plurality of data bits are provided to memory register  and include a value, such as a probability, associated with the status of the setting of the data bit stored in memory register . In various embodiments, a matching descriptor part can set an arbitrarily named set of data bits, such as a probability or counter, and other descriptor parts can query the same arbitrarily named sets of data bits.","In one mode of operation, the apparatus of functional block diagram  is operable to receive incoming data at input , and to operate as, for example but not limited to, a back-end server, that is used to generate a tree structure of descriptor parts related to the incoming data. In various embodiments, the incoming data is known to include malicious code. In such instances, the functional block diagram  is operable to process the incoming data with known malicious code for the purpose of generating one or more tree structures of descriptor parts that are indicative of the presence of the malicious code. In various embodiments, input  can receive an incoming file from a database, such as but not limited to database  as shown in . In various embodiments, the knowledge about the malicious or benign nature of an input file will be translated into a statistic value stored along the descriptor parts generated for the input file.","In various embodiments, the generated one or more tree structures of descriptor parts can be stored in the detection database  for later use in comparison to other incoming files or incoming data to determine if the later incoming files or data contain, or are likely to contain, the malicious code, or a variation of the malicious code, that was included in any of original incoming files or data used to generate the one or more tree structures.","In various embodiments of this mode of operation, after receiving incoming data at input , code dissector module  is operable to parse and normalize the incoming data. Parsing is the dissection of any input files, of parsing through the file, first byte to last, finding the next function call, parameter, process flow statement or likewise, potentially emulating some of the file to make an accurate finding, then delivering the very next finding\u2014the indicator\u2014to the calling module. Normalization is an optional step of translating many different variants, or encoding, of a similar functionality, such as a function call, into one common representation.","While parsing, each parsed data is then output consecutively, one finding at a time, to the code logic identifier . The code logic identifier  is operable to identify logic entities that are determined to be logic entities that are to go into a tree structure as a Structural Code Pattern Descriptors. In various embodiments, the identification of code logic entities, or parts thereof, is performed by the parser implementation itself. In various embodiments, criteria  are used to determine which logic entities are to be processed for inclusion in the tree structure. Criteria  are not limited to any particular type or form of criteria. In various embodiments, specific logic entities can be enumerated and stored in the criteria  to indicate which logic entities should be processed into one or more tree structures of related Structural Code Pattern Descriptors. In various embodiments, criteria  include one or more rules that determine whether or not a particular logic entity should be processed for inclusion in a tree structure. Various embodiments include a combination of different types of criteria for inclusion in criteria .","In various embodiments, criteria  includes any one, or any combination of, the following types of logic entities designated to be identified and included in a tree structure of descriptor parts used to form one or more Structural Code Pattern Descriptors:\n\n","Additional descriptor parts, which are not necessarily generated by a parser, but that can still be used in various embodiments to form one or more Structural Code Pattern Descriptors include:\n\n","Once the code logic identifier  has identified a logic entity that is to be included in a structural code pattern descriptor, the identified logic entity is output at output  to the structural code pattern descriptor generator . The structural code pattern descriptor generator  performs one or more operations on the received logic entity in order to generate, in some embodiments, a tree of descriptor parts chain. In various embodiments, the received logic entity is used as a root node forming the beginning descriptor part for one or more descriptor parts chains. In various embodiments, if the received logic entity is determined to be a root node, one or more additional received logic entities provided in the input file or input code can then be used to continue to build a descriptor parts chain by coupling one or more of the additional received logic entities, in a sequential order, to the logic entity determined to be a root node in order to form a descriptor parts chain having the received logic entity as the root node.","In some embodiments, a descriptor parts chain includes exactly one child node and one root node. In some embodiments, a descriptor parts chain includes at least one root node and a plurality of child nodes. In various embodiments, the order of the descriptor parts in a descriptor parts chain resembles the original order of the logic entities as present in the dissected input code. In various embodiments, each descriptor parts chain ends in a child node, referred to as a terminal node, having no further child nodes proceeding from the terminal node.","There is no fixed limit to the number of child nodes that can be included in a descriptor parts chain proceeding from a given root node. While generating a database, the code logic identifier  and the structural code pattern descriptor generator  can make heuristic decisions on stopping at any node depth based on data context, memory footprint or performance requirements, or anything else. In various embodiments, the heuristics used in these decisions are stored, for example in criteria , and provided by system configuration . In various embodiments, a portion of a tree of descriptor parts is, for example, structured like:",{"@attributes":{"id":"p-0050","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ROOT NODE"]},{"entry":[{},"\u2003\u2003Media Type INDICATOR"]},{"entry":[{},"\u2003\u2003\u2003\u2003INDICATOR (Call, Param, ...)"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003INDICATOR"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003\u2003\u2003INDICATOR"]},{"entry":[{},"\u2003\u2003\u2003\u2003..."]},{"entry":[{},"\u2003\u2003Media Type INDICATOR ]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In various embodiments, the tree structure of descriptor parts is generated by first identifying a logic entity that is to be included in a descriptor parts chain, and then processing additional logic entities provided by code dissector module  and code logic identifier  as received at input  to determine the relationship between the identified logic entity and the sequence and configuration of child nodes to be used in the descriptor parts chain coupled to the identified logic entity.","Once structural code pattern descriptor generator  has generated the tree structure associated with the identified logic, the generated tree structure is provided at output  to input  of the detection database . In various embodiments, the tree structure received at input  is stored the database . In various embodiments, one or more manually crafted trees are merged with one or more generated trees, producing one resulting combined tree. One or more of the stored tree structures in database  are available for retrieval at a later time for use in comparison to other incoming data files to determine if the other incoming data files include malicious code based on a one or more of the stored tree structures in database .","In various embodiments, the one or more stored tree structures can have individual names or numbering that uniquely identifies a given descriptor parts chain within detection database . In various embodiments, one or more same child nodes can be included in one or more descriptor parts chains that originate from different root nodes, or that originate from a same root node but that end in different terminal nodes, or both. Therefore, in various embodiments, a given child node can be included in one more different descriptor parts chains that have different names or numbers identifying the descriptor parts chains in which the child node is included.","In another mode of operation, referred to in various embodiments as the comparison mode, the apparatus of functional block diagram  is operable to receiving incoming data at input , and to generate an output indicative of whether or not the incoming data includes, or is likely to include, malicious code. In various embodiments of this mode of operation, it is not known whether or not the incoming file or data does or does not include malicious code, or is likely to include malicious code. In such instances, the incoming file or data is processed through functional block diagram  to determine, based on an output provided at detection output , if the incoming file includes malicious code, or is likely to include malicious code.","In the comparison mode, the incoming data is received at input , and is parsed and normalized at code dissector module  as described above. As described above, the dissected logic entities from the incoming data are provided, one at a time, to the code logic identifier . Based on the criteria , code logic identifier  is operable to determine when a logic entity received at input  needs to be compared for possible match with a tree structure having one or more Structural Code Pattern Descriptors, or if the logic entity can be ignored. If code logic identifier  determines that the logic entity can be ignored, the logic entity is disregarded, and the next logic entity received at input , if any, is processed.","If code logic identifier  determines, in various embodiments based on criteria , that the logic entities received at input  needs to be processed to see if the logic entity is, or is likely to be associated with malicious code, code logic identifier  is operable to provide the identified logic entity at output  to the structural code pattern descriptor comparator  at input . Structural code pattern descriptor comparator  is operable to access one or more tree structures stored in the detection database  and provided from output , to be received at input  of the structural code pattern descriptor comparator . Structural code pattern descriptor comparator  is operable to compare the received logic entity to the root nodes in any of the tree structures retrieved from detection database , and to determine if a match exists, either full or partial, for any path from any of the root node included in the tree structure.","In various embodiments, finding a match for a compared logic entity includes further processing additional input received at input  to determine if the code patterns being received at input  following or logically related to the identified logic entity corresponds with any of the descriptor parts chains coupled with the root node matching the logic entity that initiated the comparison. In various embodiments, once the code logic identifier  indentifies a particular logic entity that is to be sent to the structural code pattern descriptor comparator  for comparison, the code logic identifier  can continue to process and forward additional logic entity received from the input file in order to allow structural code pattern descriptor comparator  to continue to compare the received logic entities to the tree structures in detection database  until the chain of provided logic entities either results in determination that a match exists, or that the provided sequence of logic entities does not result in a match with any of the tree structures being use in the comparison.","In various embodiments, structural code pattern descriptor comparator  is operable to provide information through feedback  to code logic identifier , to indicate, for example, that the sequence of logic entities being provided and associated with an initial particular logic entity is matching a chain in the tree structure, and therefore to continue to send additional logic entities from the input data. In various embodiments, feedback  can be used to indicate that for a given logic entity provided to structural code pattern descriptor comparator , the comparison process has not resulted in a match. In various embodiments, in such instances, if code logic identifier  is not also providing a sequence of logic entities associated with a different initial logic entity, the code logic identifier  will discontinue providing sequential logic entities to the structural code pattern descriptor comparator  until either the end of the input data is reached, or another logic entity is located that is deemed to be a logic entity that needs to be processed by the structural code pattern descriptor comparator .","In various embodiments, as logic entities are being provided to the structural code pattern descriptor comparator , the code logic identifier  can receive and identify another logic entity that is also determined to be a potential start of a new logic sequence that might be malicious code. In various embodiments, the code logic identifier  is operable to provide this new logic entity to the structural code pattern descriptor comparator  with additional information indicating that this newly identified logic entity is potentially the start of another and different sequence of malicious code. In various embodiments, the structural code pattern descriptor comparator  is operable to process a second, or third, or more additional chains of logic entities, and to individually keep track of the comparisons of these sequences of logic entities as provided by the code logic identifier  in order to individually determine with each of the chains, on an individual basis, if each sequence is or is not determined to be malicious code. In various embodiments, the structural code pattern descriptor  is operable to provide individual outputs for more than one sequence of logic entities indicating, for each of the individual sequences of logic entities, a status, and in some embodiments, a value associated with the status. In various embodiments, these outputs are stored in cache  in malicious code detector  for additional processing, as described herein.","In various embodiments, if a match between a logic entity and associated code and a given one of the descriptor parts chain from the tree structures stored in database  is detected, structural code pattern descriptor comparator  is operable to provide an output at output  to malicious code detector  at input  indicating that a match has been detected. In various embodiments, if a match is not detected by comparator  for the logic entity provided after adequate further processing of the input data related to the logic entity, comparator  does not provide an output to malicious code detector .","In various embodiments, malicious code detector  is operable to store the output from comparator  in a memory, such as a cache . In various embodiments, malicious code detector  is operable to receive from system configuration  one or more system configuration settings that control the detection output of malicious code detector .","In various embodiments, the system is configured to merely provide an indication that a match has been detected in the incoming data received at input , and as soon as comparator  provides such an indication to detector malicious code detector  will provide at output  an indication that malicious code has been detected, or is likely to be included in, the incoming data received at input .","In various embodiments, the system is operable to utilize cache  to store each one or more indications of a match provided to malicious code detector  for a given set of input data. After all of the incoming data to be compared has been received and processed, malicious code detector  is operable to provide an output at  based on the results stored in cache  of the entire set of data received at input . In some embodiments, malicious code detector , after receiving an indication that all incoming data has been processed, reviews the matches stored in cache , and determines how the matches, if any, are to be reported out at output . In various embodiments, the format for the report is determined using one or more of the setting provided by the system configuration .","In various embodiments, malicious code detector  is operable to calculate which of the stored matches has the highest overall match probability, as further described herein, and to provide at output  an indication of the match having the highest overall match probability. In various embodiments, the report out includes set a single bit to a value indicative of where or not any of the matches indicate that malicious code is, or is likely to exist, in the incoming data associated with the comparison preformed. In various embodiments, detector  is operable to report out all the matches stored in cache  related to the comparison of the incoming data included in the comparison.",{"@attributes":{"id":"p-0065","num":"0084"},"figref":["FIG. 3","FIG. 1","FIG. 2"],"b":["300","300","300","144","240"]},"Referring again to , tree structure  includes a plurality of descriptor parts -, -, -, -, -, -, , , , and , arranged in tree structure . In various embodiments, tree structure  includes one or descriptor parts, referred to a root nodes, as shown by descriptor parts - and -, as included in row  of tree structure . The number of root descriptor parts included in row  is not limited to any particular number of descriptor parts, as indicated by dotted line .","In various embodiments, each of the root node descriptor parts - and - are linked to at least one other node, referred to as a child node, in one or more rows . By way of illustration, root node  is linked to child node ; root node  is linked to child node ; root node  is linked to child node ; root node  is linked to child node ; root node  is linked to child node ; and root node  is linked to child node .","In various embodiments, a given root node and any child node or nodes linked to the root node provide a chain of descriptor parts associated with the root node. In various embodiments, a given chain includes a root node linked to a single and only one child node. By way of illustration, root node  is linked to a single and only one child node, the child node represented by child node .","In various embodiments, a given root node can be linked to a serially connected set of child nodes. By way of illustration, root node  is linked to a child node , which in turn is linked to a child node . The number of child nodes linked serially to a given root node is not limited to a particular number of child nodes, and can be any number of child nodes linked serially together. This is illustrated in tree structure  by root node  linked to child node , which in turn is linked to child node , which is linked to additional child nodes, as represented by dotted line  linking child node  to child node , which in turn is linked to child node .","In various embodiments, one or more of the chains within tree structure  have a same number of child nodes linked to the root nodes for each of the chains. In various embodiments, at least one chain within tree structure  has a number of child nodes linked serially that is different from the number of child nodes linked to at least one other chain in tree structure . When talking about comparisons using chains of descriptor parts, it is to be understood that this shall not imply any need for a full match of all the descriptor parts in a given chain in order to produce an overall (probabilistic) match.","In various embodiments, a root node can be linked to more than one child node. By way of illustration, root node  is linked by a first link represented by arrow  to child node , and by a second link represented by arrow  to child node . The first link  and the second link  represent two different paths that can be taken from root node . The first path includes root node  and child node , and then continues with any child nodes linked to child node  only. The second path includes root node  and child node , and then continues with any child nodes linked to child node  only.","In various embodiments, a child node can be linked to more than one other child node. By way of illustration, child node  is linked by a first link represented by arrow  to child node , and is linked by a second link represented by arrow  to child node . The first link and the second link create two different and separate paths leading from child node .","In various embodiments, the links only couple nodes in one direction. For example, link  couples node  to node , which is the direction of the movement during a comparison to move through the chain. In various embodiments, the comparison would not go back to node  from node . Therefore, once arriving at a given node, the process does not care, and does not track, the node taken to arrive at the given node. In other embodiments, the path is tracked, for example in chains for a given node can be arrived at from more than one chain, in order to determine specifically which path, and therefore which associated malicious code, is represented by the given path.","In various embodiments, a given path of descriptor parts within tree structure  starts at a root node, and follows the link, or one of the links if more than one exists for a given root node, to a first serially linked child node. By way of illustration, starting at root node , a path is formed by the link between root node  and . From the first serially link child node, the path can only proceed to another lower level child node linked to the first serially linked child node. If no lower level child nodes are linked to the first serially linked child, the child node is considered to be terminal node. However, in this illustration, child node  is linked to a lower level child node, node . Therefore, the path illustrated by the dashed box enclosing tree lookup path  continues from child node  to child node . Since no lower level nodes are linked to child node , child node  is a terminal child node.","In various embodiments, if during a comparison process using a given path within tree structure , the comparison arrives at a terminal child node, the comparison is considered to have found a potential match between the data being compared and the path within tree structure  being used in the comparison. Based on probabilistic computation, such a match can also be reached already before reaching any terminating child nodes in the tree (leaf nodes). In various embodiments, such a match indicates that the data being compared includes, or is likely to include, the malicious code, or a variation thereof, associated with the path within tree structure  that was used generate the particular path used in the comparison.","In various embodiments, the tree structure , along with any generated data associated with tree structure  such as but not limited to weights for each of the part descriptors included in tree structure , is stored in a database for later use in comparison with incoming data for the purpose of determining if malicious code, or the likelihood that malicious code is present, in the incoming data.","In operation, in various embodiments the tree structure  is used to compare logic entities identified in incoming data to paths within tree structure . In various embodiments, within an incoming file or some part of an incoming file, a given logic entity within the incoming file is identified that matches a root node in tree structure . Starting at the matched root node, the next part descriptor dissected from the incoming data is compared to see if it matches the next child node, or at least one of one node, that is serially linked as a next node linked to the original matching root node.","If there is a match, the comparison (additionally) continues from the matching child node with a comparison of the part descriptor following the last compared part descriptor in the incoming data to the next lower level child node serially connected to the last matching child node. In various embodiments, a mismatch between any of the next lower level child nodes and the next one or more incoming data is ignored until a certain threshold, based on probabilistic assessment of the pending lookup, is reached. Again, if a match is found, the comparison process continues in a like matter, from the now matched lower level child node, and comparing the next following part descriptor in the incoming data to the next lower level serially connected child node in the path linked to the original root node. If a match is determined to exist in a terminal child node linked to the originally matching root node of the chain, an indication that a match has been detected is generated. Based on probabilistic assessment, such a match may also be reached earlier in the comparison process before the terminal node was reached.","In the alternative, if the next part descriptor in the incoming data does not match the next, or any, lower level child node serially connected to the matching root node, in some embodiments a determination that no match exists is made. In various embodiments, a comparator, such as the structural code pattern descriptor comparator  of , is used to perform the comparison between the incoming file (or some part of the incoming file) and the tree structure . In various embodiments, a tracking of the path from the root node that resulted in arriving during a comparison at any given child node is not maintained.","In such embodiments, all that is tracked is whether the sequence of additional logic entities received as part of the comparison being performed result in reaching a terminal child node in any descriptor parts chains in the tree structure . In various embodiments, a probability weighting is calculated and tracked for a comparison based on the path used to arrive at a given child node, including a root node, as part of a comparison. In such embodiments, as the comparison proceeds, the cumulative probability weighting for the comparison currently calculated for arriving at any given node is compared to a threshold value, and if the calculated probability weighting exceeds the threshold value, a determination is made that the comparison has resulted in detection of malicious code. In various embodiments, the determination related to a given comparison initiated at a root node is made only if the comparison reaches a terminal child node in tree structure . In various embodiments, the determination is made if the calculated probability exceeds a threshold value even if the given comparison initiated at a root node has not reached a terminal child node in the tree structure .","In various embodiments, an output indicating that a match was or was not detected is provided by the comparator as a result of comparing the incoming file, or some part of the incoming file, with tree structure . In various embodiments, the output includes a single boolean flag set to a particular status (yes or no, true or false, one or zero) to indicate whether or not a match was determined to exist between the incoming file (or some part of the incoming file) and the tree structure.","By way of illustration, if a match is determined to exist between the incoming data and the tree structure , the boolean flag is set to a value of \u201c1\u201d (one), and if it is determined that no match exists between the incoming file and tree structure , or between some part of the incoming file and tree structure , the bit is set to or cleared to a value of \u201c0\u201d (zero). In various embodiments, a match probability (0% . . 100%) is returned in addition to, or as an alternative to the output associated with the Boolean flag. In various embodiments, the output includes a descriptive malware name label describing the nature, or source, or other characteristic or history of the malicious code finding that generated the positive indication being returned.","In various embodiments, a match of a part descriptor to a root node or to a child node requires an exact match. The requirement for an exact match between part descriptors and nodes is required throughout the entire chain starting at the root node until at least one terminal child node is reached, in order to determining that a match exists. In various embodiments, a probability and\/or weighting is determined for any chain were a match is found in the incoming file to a root node in the tree structure . Starting at the root node, a weighting is assigned to each matching node in the chain until the last match in the chain linked to the originally matching root node is located.","In various embodiments, each descriptor part is assigned a weighting per part type, value type, and value. By way of illustration, each descriptor part has a part type that can be assigned a particular weighting for the descriptor part. In various embodiments, an exact match between a descriptor part and a node is not required, and a fuzzy match between a descriptor part and a node can be accepted, adjusted or disregarded based on the weighting for the descriptor part.","In various embodiments, two descriptor parts match if their part types match, and if their value types match and if their values match. In various embodiments, two descriptor parts match if their part types match, their value types match and if the entropy values assigned to the respective values match within a configurable tolerance threshold. In various embodiments, a configurable tolerance threshold is plus or minus 0.1. This if the stored entropy value assigned to two values for two different description parts being compared to one and other fall within, or in some embodiments fall within or is equal to, a configured tolerance threshold, the two descriptor parts are considered to be a match.","When applied to a search using the tree structure , when comparing a logic entity to a given node in tree structure , the logic entity is determined to be a match for the given node if, in some embodiments, the logic entity has a part type that matches the part type of the given node, and the value type of the logic entity exactly matches the value type of the given node and the values match exactly or nearly. In various embodiments, when comparing a logic entity to a given node in tree structure , the logic entity is determined to be a match for the given node if, in the logic entity has a part type that matched the part type of the given node, and the value type, and the entropy value for the value of the logic entity is within a tolerance threshold of the value for the given node.","In various embodiments, a determination as to whether a match requires an exact match of the value, or whether a match requires that the logic value be within the tolerance threshold, is configurable as part of the system configuration for tree structure . In various embodiments, the choice of these configuration can be made on a node by node basis, wherein one or more nodes on the system are configured to require an exact match, and one or more nodes within a tree structure are configured to require a match based on the tolerance threshold.","In various embodiments, matching any two descriptor parts (that is, a descriptor part and a descriptor part associated with a node in tree structure ) generates a match probability. In various embodiments, an overall match probability is generated for each of the match probabilities generated in a given tree lookup path. By way of illustration, a set of logic entities received in an incoming file are compared to and determined to match a given tree lookup path , represented in  by the dashed rectangle surrounding root node , child node , and terminal child node . For each of the nodes in the tree lookup path , a match probability is generated for the descriptor part of the incoming file that is compared to the given node , , or  in tree lookup path .","Using these three match probabilities, an overall match probability is calculated as the sum of each of the three generated match probabilities for tree lookup path  and the incoming file, for example, using Bayes' formula\u201d Bayes' formula relates the conditional and marginal probabilities of stochastic events A and B:",{"@attributes":{"id":"p-0090","num":"0109"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":"Pr","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["A","B"],"mo":"\u2758"}}},"mo":["=","\u2062"],"mi":{},"mfrac":{"mrow":[{"mrow":[{"mi":"Pr","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["B","A"],"mo":"\u2758"}}},{"mi":"Pr","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"A"}}],"mo":"\u2062"},{"mi":"Pr","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"B"}}]}}}},{"mtd":{"mrow":{"mo":["\u221d","\u2062"],"mi":{},"mrow":{"mrow":[{"mi":"L","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["A","B"],"mo":"\u2758"}}},{"mi":"Pr","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"A"}}],"mo":"\u2062"}}}}]}}},"ul":{"@attributes":{"id":"ul0009","list-style":"none"},"li":["where L(A|B) is the likelihood of A given fixed B. Notice the relationship:\n\n()=().\n","Each term in Bayes' formula has a conventional name:\n    \n    "]}},"As an alternative, or in addition, other statistical methods may be used in computing an individual match probability and\/or in computing an overall match probability. Examples include, but are in no means limited to, usage of Markov Models.","The overall probability provides a percentage probability that an arbitrary file contains malicious code\u2014given the file type and\/or the location of the finding, its existence usually implies it is malicious code. In various embodiments, the overall probability may consist of a threat, or danger, probability and a classification confidence probability. In various embodiments, a comparison of the overall probability to a threshold value M is made to determine if the arbitrary file includes malicious code. For example, if an overall statistical probability for the arbitrary file equals or exceeds a threshold value M, the arbitrary file is considered to include malicious code.",{"@attributes":{"id":"p-0093","num":"0118"},"figref":"FIG. 4","b":"400"},"In various embodiments, compiling a detection database includes at  determining the types of logic entities that can be included in a Structural Code Pattern Descriptor (SCPD). The logic entities that can be included in a Structural Code Pattern Descriptor are not limited to any particular type of logic entity, and can be any logic entity chosen to be included in a Structural Code Pattern Descriptor. The determination as to which logic entities are to be included in any Structural Code Pattern Descriptor generated as part of compiling a detection database can be configured through a set of criteria developed for the system and stored in the system as part of a system configuration.","Examples of logic entities that can be determined to be descriptor parts that can be included in a Structural Code Pattern Descriptor include but are not limited to the following:\n\n","At , method  includes identifying logic entities in input code that are to be included in a Structural Code Pattern Descriptor. In various embodiments, the input code includes a complete input file. In various embodiments, the input code includes a selected portion of an input file that includes less code than the code included in the complete file from which a selected portion of code is taken.","In various embodiments, identifying logic entities in the input code including dissecting the input file into individual logic entities, and feeding the individual logic entities, one at a time, to a code logic identifier operable to determine if the individual logic entity received at the code logic identifier is the type of logic entity that should be included in a Structural Code Pattern Descriptor. In various embodiments, the code logic identifier determines whether or not the logic entity should be included in a Structural Code Pattern Descriptor by comparing the logic entity to the set of types of logic entities determined in method  at  to see of the logic entity is included in the set of types of logic entities that can be included in a Structural Code Pattern Descriptor.","In various embodiments, if the code logic identifier determines that the logic entity is to be included in a Structural Code Pattern Descriptor, the code logic identifier passes the logic entity a module or device, such as a structural code pattern descriptor generation, for further processing.","At , method  includes compiling a descriptor part for the identified logic entity to generate a compiled descriptor part. In various embodiments, comparing the descriptor part for the identified logic entity including normalization of the logic entity.","Various embodiments include compiling a descriptor part for a process flow statement. Process flow statements include such process flow statements such as while( ) or for( ) iteration statements. In various embodiments, both the start of the loop body (open scope), and its end (close scope), shall be denoted as separate descriptor parts.","Various embodiments include compiling a descriptor part for an API Call. A normalization function maps certain function\/API names to normalized values, such as mapping \u201cwriteln\u201d to \u201cwrite\u201d. To reduce memory footprint and increase match performance, only the checksum (CRC32, for example) of an API name, and optionally of the number of actual parameters passed along, is stored. Two different API names could lead to the same checksum, e.g. this checksum can not be used to uniquely identify which input API name and parameters combination was used to create the checksum, thus implying a false-positive risk as the trade-off for improved match performance.","In various embodiments, two subsequent API calls can optionally be stored in just one descriptor part, by Exclusive-OR (XOR) combining their checksums, thereby decreasing memory footprint. Application of Exclusive-OR combination of two successive descriptor parts needs to be stored in the resulting descriptor part.","Various embodiments include compiling a descriptor part for a call to a user-defined function. A call to a user-defined function can either be ignored, or be stored as a descriptor part referring to, for example, the entropy of the code block that implements the referenced function, or to a checksum (such as the Exclusive-OR of each normalized instruction) of a normalized form of the code block (normalized such as removing actual registers or actual immediate values).","Various embodiments include compiling a descriptor part for a variable or a parameter. Various embodiments limit covered variables and parameters to strings and string literals, and in various embodiments, further limit coverage on variables and parameters that exceed a given minimum length (like 30 bytes, at least), and optionally exceed a given minimum entropy, and optionally contain certain characteristic sequences (like NOP slides).","In various embodiments, the length denoted in a descriptor part for a variable or parameter may be shorter than the actual length present in order to facilitate left-side-only matches; in this case, both the entropy and the checksum is calculated (for storage and for comparison) over the length of data as per the length denoted in the descriptor part. For example, one descriptor part could be used to describe both","\u201cC:\\WINDOWS\\system32\\gdi32.dll\u201d","and","\u201cC:\\WINDOWS\\system32\\gdiplus.dll\u201d","By specifying the length in the descriptor part to be 23 bytes (e.g. up to \u201c\\gdi\u201d). The alternative would be to use a regular expression descriptor part. The logic entity's information entropy",{"@attributes":{"id":"p-0108","num":"0137"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"H","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"X"}},{"mo":"-","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"1"},"mi":"n"},"mo":"\u2062","mrow":{"mrow":[{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["x","i"]}}},{"mi":"p","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["x","i"]}}}],"mo":["\u2062","\u2062"],"msub":{"mi":"log","mn":"2"}}}}],"mo":"="}}},"br":{},"sub":"i"},"Various embodiments include compiling a descriptor part for a variable modification. In various embodiments, \u201ccharacteristic\u201d operations on variables, such as string concatenation operations (\u201c+=\u201d), bit-shifting operations or Exclusive-OR operations, are denoted as separate descriptor parts in an SCPD. \u201cCharacteristic\u201d refers to those operations that are indicative of belonging to an obfuscation algorithm, buffer overflow creation loop, or similar suspicious activity.","Still referring to , at , method  includes determining all possible successors from the compiled descriptor part as child nodes of the compiled node.","At , method  includes constructing a Structural Code Pattern Descriptor including the compiled descriptor part linked to all possible successors of a child nodes.","At , method  includes storing the Structural Code Pattern Descriptor in a detection database. In various embodiments, after the storing is complete, method  returns to  to continue to identify logic entities in the input code that are to be include in a Structural Code Pattern Descriptor.","In various embodiments, as the input code is processed, if more code is still present, method  continues to process the input code to identify any logic entities that are to be included in a Structural Code Pattern Descriptor, as indicated by arrow . If the end of the input code is reached, and all of the logic entities in the input code have been identified, method  ends at , as represented by arrow . At any time, the dissector may emit one or more descriptors that are associated with the input file, any of its structures or characteristics, but not to the dissected code itself.",{"@attributes":{"id":"p-0114","num":"0143"},"figref":"FIG. 5","b":"500"},"At , method  includes receiving at least some portion of an input file that is to be processed. In various embodiments, processing includes performing a comparison of one or more portions of the input code to a tree structure including one or more Structural Code Pattern Descriptors. In various embodiments, the tree structure is stored in a detection database, such as database  as shown in , or detection database  as shown in . In various emblements, receiving at least some portion of the input file includes receiving at least some portion of the input file after a comparison of an earlier received portion of the input file has already begun.","Referring again to , at  method  includes identifying a logic entity in the received input code that needs to be compared to a Structural Code Pattern Descriptor. In various embodiments, identifying a logic entity that needs to be compared includes determining if a descriptor part for the logic entity matches any of the descriptor parts included in the root nodes of any Structural Code Pattern Descriptors included in the tree structure being used for the comparison.","In various embodiments, if the descriptor part of the logic entity from the input code matches any of the root nodes from the tree structure being used for the comparison, method  progresses to . If the logic entity received in the input code is not a type of logic entity that is to be compared to a Structural Code Pattern Descriptor, method  continues to look for additional logic entity in any received input code to identify any additional logic entity that are to be compared to a Structural Code Pattern Descriptor, as represented by arrow .","At , method  includes comparing an identified logic entity to a one or more Structural Code Pattern Descriptors to select a particular Structural code pattern descriptor from one or more Structural Code Pattern Descriptors to use in the comparison. In various embodiments, the particular Structural Code Pattern Descriptor used for the comparison is the Structural Code Pattern Descriptor that has a root node matching the descriptor part of the identified logic entity.","At , method  includes determining if the logic entity and the succeeding logic entities in the input code match the chain of nodes included in the root node and a path from the root node linking one or more child nodes in the particular structural code pattern descriptor selected for the comparison. In various embodiments, determining if a match exists includes the comparison reaching a terminal child node in the path. If the logic entity and succeeding code in the input code matches the path of the Structural Code Pattern Descriptor, method  proceeds to .","If the comparison of the logic entity and succeeding code does not match the path of the Structural Code Pattern Descriptor used for the comparison, in various embodiments, no output is generated, and method  returns to , as represented by arrow .","In various embodiments, method  at  includes generating an output indicating that a match was determined to exist between the input code and at least one Structural Code Pattern Descriptor. In various embodiments, the determination of such a match is indicative that the input code includes malicious code, or is likely to include malicious code. In various embodiments, the generated output includes only a single bit set to a value, such as but not limited to a value of \u201c1,\u201d that indicates that a match has been found between some portion of the input code received at  and at least one Structural Code Pattern Descriptor used in the comparison of the input code.","In various embodiments, the generation of the output including generation of an indication of the particular path with the tree structure of the Structural Code Pattern Descriptor that included the match with the input code, such as but not limited to a name or an identification number for the particular path.","In various embodiments, method  at  includes storing the indication of the match for inclusion in a final output. In various embodiments, an indication of a match ends the comparison, and includes generation of a final output at , as indicated by arrow .","In various embodiments, method  at  includes storing the generated indication of a match, and proceeding to , as indicated by arrow . At , method  including determining if the end of the input code has been reached. If a determination is made that the end of the input code has not been reached, method  progresses back to , as indicated by arrow . In various embodiments, if a determination is made that the end of the input code has been reached, method  progresses to .","At , method  includes generating a final output. In various embodiments, a final output can be a single bit indication of whether or not a match was found in the input code as compared to the one or more Structural Code Pattern Descriptors included in a tree structure used in the comparison. In various embodiments, generate the final output, including checking the status of any stored indications from  to see if any matched were indicated.","In various embodiments, generation of a final output includes determining that more than one indication for a match has been identified at , and determining which of the indicated matches has a highest match probability. In various embodiments, the highest match probability is determined by calculating an overall match probability for each indicated path in the tree structure that resulted in a match, and providing an output match probability for the match that resulted in the highest match probability during the comparison.",{"@attributes":{"id":"p-0127","num":"0156"},"figref":["FIG. 6","FIG. 1","FIG. 2","FIG. 2"],"b":["600","600","140","600","600","290"]},"Referring again to , in various embodiments, interface  is a diagrammatic representation of a machine in the form of a computer system within which a set of instructions is stored on a memory device and which, when executed by one or more processors, cause the machine to perform any one or more of the methodologies discussed herein. In some embodiments, the machine operates as a standalone device. In some embodiments, the machine is connected (e.g., using a network) to other machines. In a networked deployment, the machine operates in the capacity of a server or a client user machine in server-client user network environment, or as a peer machine in a peer-to-peer (or distributed) network environment.","In various embodiments, the machine comprises a server computer, a client user computer, a personal computer (PC), a tablet PC, a set-top box (STB), a Personal Digital Assistant (PDA), a cellular telephone, a mobile device, a palmtop computer, a laptop computer, a desktop computer, a personal digital assistant, a communications device, a wireless telephone, a land-line telephone, a control system, a camera, a scanner, a facsimile machine, a printer, a pager, a personal trusted device, a web appliance, a network router, switch or bridge, IP telephone, or any machine capable of executing a set of instructions (sequential or otherwise) that specify actions to be taken by that machine.","Further, while a single machine is illustrated, the term \u201cmachine\u201d shall also be taken to include any collection of machines that individually or jointly execute a set (or multiple sets) of instructions to perform any one or more of the methodologies discussed herein.","In various embodiments, the interface  includes any combination of a processor  (e.g., a central processing unit (CPU), a graphics processing unit (GPU), or both), a main memory  and a static memory , which communicate with each other via a bus . In various embodiments, interface  includes a video display unit  (e.g., a liquid crystal display (LCD), a flat panel, a solid state display, or a cathode ray tube (CRT)). In various embodiments, interface  includes any combination of an input device  (e.g., a keyboard), a cursor control device  (e.g., a mouse), a disk drive unit , a signal generation device  (e.g., a speaker) and a network interface device .","In various embodiments, the disk drive unit  includes a machine-readable medium  on which is stored one or more sets of instructions (e.g., software ) embodying any one or more of the methodologies or functions described herein, including but not limited to those methods illustrated in  and . In various embodiments, the instructions  are stored in, completely or at least partially, within the main memory , the static memory , and\/or within the processor  during execution thereof. In various embodiments, the main memory  and the processor  also constitute a machine-readable media. In various embodiments, the instructions  are further transmitted or received over a network  via the network interface device .","Applications that may include the apparatus and systems of various embodiments broadly include a variety of electronic and computer systems. Some embodiments implement functions in two or more specific interconnected hardware modules or devices with related control and data signals communicated between and through the modules, or as portions of an application-specific integrated circuit. Thus, the example system is applicable to software, firmware, and hardware implementations.","While the machine-readable medium  is shown in an example embodiment to be a single medium, the term \u201cmachine-readable medium\u201d should be taken to include a single medium or multiple media (e.g., a centralized or distributed database, and\/or associated caches and servers) that store the one or more sets of instructions. The term \u201cmachine-readable medium\u201d shall also be taken to include any medium that is capable of storing, encoding or carrying a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the various embodiments described. The term \u201cmachine-readable medium\u201d shall accordingly be taken to include, but not be limited to, solid-state memories, optical and magnetic media, and carrier wave signals.","Various embodiments include an apparatus comprising a detection database including a tree structure of descriptor parts including one or more root nodes and one or more child nodes linked to from one or more parent descriptor parts chains, each of the root nodes representing a descriptor part, and each root node linked to at least one of the child nodes, each root node and each child node linked to any possible additional child nodes, wherein the possible additional child nodes include any possible successor child nodes, and a descriptor comparator coupled to the detection database, the descriptor comparator operable to receive data including a plurality of logic entities, once or successively, and to continuously compare logic entities provided to the tree structure of descriptor parts stored in detection database, and to provide an output based on the comparison.","Various embodiments include a method of comparing input code to one or more structural code pattern descriptors to detect malicious code, comprising receiving at least some portion of an input file including input code that is to be processed, identifying a logic entity in the received input code that is to be compared to at least one structural code pattern descriptor included in a tree structure stored in a detection database, comparing the identified logic entity to one or more structural code pattern descriptors and selecting a particular structural code pattern descriptor to use in the comparison, determining if the identified logic entity and one or more succeeding logic entities included in the input code matches a chain of nodes including the root node and a path from the root node linking one or more child nodes in the particular structural code pattern descriptor selected for the comparison, and if a match exists, generating a single bit output indicating the match.","Various embodiments include a set of instructions stored on a computer memory that, when executed by a processor, perform a method of comparing input code to one or more structural code pattern descriptors to detect malicious code, the method comprising receiving at least some portion of an input file including input code that is to be processed, identifying a logic entity in the received input code that is to be compared to at least one structural code pattern descriptor included in a tree structure stored in a detection database, comparing the identified logic entity to one or more structural code pattern descriptors and selecting a particular structural code pattern descriptor to use in the comparison, determining if the identified logic entity and one or more succeeding logic entities included in the input code matches a chain of nodes including the root node and a path from the root node linking one or more child nodes in the particular structural code pattern descriptor selected for the comparison, and if a match exists, generating a single bit output indicating the match.","Various embodiments include a detection database comprising a plurality of tree structures stored in a detection database, the plurality of tree structures including descriptor parts arranged in one or more descriptor parts chains, each descriptor parts chain including a root node and one or more child nodes linked to the root node, wherein the root node is associated with a compiled descriptor part, and the one or more child nodes each include a different descriptor part that is a possible successor to either the root node or one of the one or more child nodes, and wherein each of the descriptor parts chains represents a structure present in known malware.","Although specific embodiments have been illustrated and described herein, it will be appreciated by those of ordinary skill in the art that any arrangement which is calculated to achieve the same purpose may be substituted for the specific embodiment shown. This application is intended to cover any adaptations or variations of the present invention. Therefore, it is intended that this invention be limited only by the claims and the equivalents thereof.","The Abstract is provided to comply with 37 C.F.R. \u00a7 1.72(b) requiring an abstract that will allow the reader to quickly ascertain the nature of the technical disclosure. It is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims. In the foregoing Detailed Description, various features are grouped together in a single embodiment for the purpose of streamlining the disclosure. This method of disclosure is not to be interpreted to require more features than are expressly recited in each claim. Rather, inventive subject matter may be found in less than all features of a single disclosed embodiment. Thus the following claims are hereby incorporated into the Detailed Description, with each claim standing on its own as a separate embodiment."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
