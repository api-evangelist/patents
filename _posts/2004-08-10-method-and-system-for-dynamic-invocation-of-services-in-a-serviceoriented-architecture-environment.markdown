---
title: Method and system for dynamic invocation of services in a service-oriented architecture environment
abstract: A service-oriented architecture environment system which enables a service to be designed and implemented independently, regardless of the supported protocol and signature requirements of dependent or target services is disclosed. Data type transformation is supported through a context mapping mechanism. The system is configurable during deployment or just before actual invocation of the dependent service(s). The configuration capability is enabled through an XML-based descriptor, and services are invoked based on a given context dynamically during runtime.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08161500&OS=08161500&RS=08161500
owner: Agency for Science, Technology and Research
number: 08161500
owner_city: Centros
owner_country: SG
publication_date: 20040810
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Example"],"p":["The invention generally relates to service-oriented architecture (SOA) environment in a computer network system, and more particularly, to dynamic invocation of services in a SOA environment.","In a typical Service-Oriented Architecture (SOA) environment in a computer network system, the use of third-party services is possible. This is especially so in the use of the SOA environment for web services, where a third-party service is any functionality offered, such as an application or software already existing, and a web service is a software component representing a set of specific functions that can be described, published and invoked over the network (typically the Internet) using open standards. The SOA environment enables software applications to be assembled using third-party or existing services, and only where absolutely necessary, to be built. This promotes reuse of the existing applications, and a paradigm shift in the way software is developed.","With the SOA environment infrastructure, application design and development requires less effort, which leads to less expensive software\/applications. Software may also be built incrementally such that the software application may be developed as and when new services are required. Software may be rolled out with a much shorter lead-time, leading to more responsiveness to customers' needs. Additionally, applications may be customised with relatively little programming effort to an end user's needs. The end user may be an organisation.","The SOA environment provides a suite of services that can be aggregated or assembled, which in turn may require dependent services. The dependent services are usually pre-defined and potentially pre-coded into the source code during implementations, as shown in .  shows a block diagram of a conventional SOA arrangement  with a calling service  with a pre-identified dependency invocation  in communication with dependent services . With this conventional configuration the mapping and binding information are programmed and fixed during the design or implementation of the application. Amongst the elements that are fixed, for example:\n\n","There is a subtle difference between operation signature and data type dependencies. Signature pertains to the declaration of expected inputs (including the number of inputs, sequence, etc) and output. Data type is about the type of parameters, for example, int, String, and the like. For example, in Java, there is a difference between Integer and int.","The concept of assembly of services in a SOA environment requires the dependent services to be available and running when needed. As such, if the dependent service(s)  shown in  are no longer available or are down, then the service in context is also not available. This brings about the problem of flexibility and reliability of the service in question. In other words, the service is only as reliable as the least reliable service(s) that it is dependent upon. Also, if the supported protocol or API signature, for example, changes in a dependent service , the service in context or calling service  needs to be changed as well. Furthermore, in a SOA architecture, the ability to replace a service with another service that is providing similar functionality, but without being tied down by the example of fixed elements specified and listed above is crucial to the concept of reuse and mix-match based on end user requirements.","Recent attempts have been made to address this issue, and to increase the flexibility and robustness of services. U.S. Patent Application Publication No. 2003\/0,070,006 A1 published on 10 Apr. 2003 in the name of Nadler et al describes a development system providing extensible remoting architecture, and U.S. Patent Application Publication No. 2001\/0,037,417 A1 published on 1 Nov. 2001 in the name of Meyer describes a method and system for dynamically dispatching function calls from a first execution environment to a second execution environment. However, both of these systems do not adequately address problems related to having a fixed messaging protocol that is used. U.S. Patent Application Publication No. 2003\/0,070,006 tried to address this problem, but as this solution is based on generating code during runtime, the multi-protocol support must be predefined. U.S. Patent Application Publication No. 2003\/0,070,006 has the problem of being restricted to the pre-defined protocol supported. U.S. Patent Application Publication No. 2001\/0,037,417 is an implementation that is specific to C++ environment only; hence, this system doesn't handle multiple-protocol support issue as discussed in Item 1 at all. U.S. Patent Application Publication No. 2001\/0,037,417 can only run in local environments.","Both of these published patent applications fails to address the problem of defining a virtual interface at design time and bind it to an arbitrary (needed) service at runtime.","However, there is no solution to the problem of providing services that can be mixed-and-matched at runtime instead of being tied-in during design or implementation phases. In this context, \u201cruntime\u201d means:\n\n","There is a need for a solution to the problem of providing a system that enables a calling service to be implementation agnostic as well as insulated from changes of dependent services, preferably in an SOA environment.","In accordance with an aspect of the invention, there is provided a method for dynamic invocation of at least one service in a service-oriented architecture. The method comprises invoking at least one target service in the system dependent upon a calling service; identifying the target service; mapping one or more parameters of the target service with one or more parameters of the calling service if parameters of the target service and of the calling service differ; and invoking the target service.","The mapping may be performed using a context mapper and mapping rules, for instance with the mapping rules used by an XML based rules engine.","The service functionality required by the calling service may be stored, and preferably the mapping maps the functionality of the target service to the functionality required by the calling service.","Invoking a target service may use a context invocation descriptor, for instance having an XML schema based structure.","In accordance with another aspect of the invention, there is provided a system for dynamic invocation of at least one service in a service-oriented architecture. The system comprises: a component for invocation of at least one target service in the system dependent upon a calling service; and a context manager coupled to the calling service for identifying the target service, mapping one or more parameters of the target service with one or more parameters of the calling service if parameters of the target service and of the calling service differ, and invoking the target service.","The system may further comprise a mapping mechanism coupled to the context manager, the mapping mechanism preferably comprising a context mapper and mapping rules, for instance with the mapping mechanism utilising the rules in an XML based rules engine.","The system may further comprise a component interface through which the at least one target service is invoked. Preferably the interface stores a service functionality required by the component. The mapping may map the functionality of the target service to the functionality required by the component.","The component for invocation preferably comprises a context invocation descriptor, usefully with an XML schema based structure.","The component interface may be a dependency interface.","In either above aspect, the target service may be identified during calling service runtime.","In either above aspect, the at least one target service may comprise a plurality of target services.","The embodiments of the invention are particularly effective and useful in SOA environments as software applications are no longer built as huge monolithic systems. Instead, software applications can now by extensively reused (where this technique is extremely powerful) and built only when necessary. Furthermore, in a SOA environment, the services come in many forms and shapes, and the implementation platforms and protocols used can be different. Hence, the applicability of this technique according to the embodiments of the invention.","In an exemplary embodiment, a service-oriented architecture environment in a computer network system enables a web service to be designed and implemented independently, regardless of the supported protocol and signature requirements of dependent or target services. Data type transformation is supported through a context mapping mechanism. The system is configurable during deployment or just before actual invocation of the dependent service(s). The configuration capability is enabled through an XML-based descriptor, and services are invoked based on a given context dynamically during runtime.",{"@attributes":{"id":"p-0030","num":"0036"},"figref":"FIG. 2","b":["20","12","22","26","22","30","16","24","22","26","28","29","26"]},"As shown, this embodiment comprises two main parts: the part to be defined within the calling service  and the part that is external to the calling service . The dependency interface  may be deployed as part of the calling service  and defines a non-fixed interface that the calling service  requires and is present at the design and development of the calling service . The dependency interface  is a virtual interface that is designed and developed together with the calling service . As such this interface  is defined based on the needs\/requirements of this calling service  and stores information as to the functionality of services required by the calling service.","With this, the designer need not know or care about the actual services that are expected to be used during the execution or runtime of this calling service .","Later, during, or after the deployment of the application, when the user finds a service that can provide the functionality that the method in the dependency interface  expects, the user can configure the binding information in the descriptor . The rules-of-thumb or heuristics rules  are stored and upgraded (added to and refined) continuously. Through these rules, the mapping capabilities of this technique can be expanded and can grow over time.","The dependency interface  is part of the calling service . In effect, the calling service  and the dependency interface  are one component and the context manager  and the context mapper  are another component.","The context invocation descriptor  may be an XML schema based structure that may be configured after the design and development of any calling services, based on the needs of the dependency interface  that have been pre-defined. The descriptor  defines the service information such as the protocol of the service, service location, method name and parameters mapping information.","The context mapper  utilises a set of mapping rules  that has been built in (and continuously updated and improved) to provide the capability to be a \u2018matchmaker\u2019 between differing signatures and data types of calling versus invoked services.","When a calling service  invokes a method in the dependency interface , the following overall steps occur:\n\n","The dynamic context manager  performs tasks if an invocation is made through the dependency interface  based on the information described in the context invocation descriptor . This information relates to how to locate a service. In a local environment, this information may be the path of the local service and method name. In a web service environment, this information may be the WSDL (Web Services Description Language) location, service name, and operation name. In an EJB (Enterprise JavaBean) environment, this information may be location information, home class name, and method name. Examples of the type of tasks that are performed may include:\n\n","This configuration allows flexibility to be built into a service's dependencies and delays the need to provide binding information as well as actual binding until runtime. The calling service  has context that may be independent of the context of the target services or applications . For example, an embodiment may have service protocol independence through the mapping capabilities of the context mapper  and the mapping rules . This embodiment is able provide a mechanism to invoke a target service, regardless of the protocol required, as long as the protocol is supported by the execution environment of the service in context or calling service.","The mapping rules are default mapping rules or rules that may be derived through experience. Examples include casting of data type \u201clong\u201d to \u201cdouble\u201d, an \u201cint\u201d to \u201cString\u201d or \u201cInteger\u201d. Others may include conversion of complex data types, for example value objects. All these rules are defined by the user and stored in the rule engine's database. The mapping rules also contain generic heuristic knowledge about combining or breaking parameters between Calling Services and Target Services.","The descriptor  provides specifics for the particular instance of invocation, for example, mapping of Parameter-1 from a Calling Service to Parameter-2 of a Target Service, or even combining\/breaking parameters from a Calling Service to a Target Service and vice-versa. These two sets of information enable the context mapper  to provide the mapping capabilities needed to enable the 3party or target services to be invoked seamlessly by the Calling Service.","As the binding is delayed until runtime, the actual service name being invoked need not be known until runtime. As such, the service name can be configured during deployment or just before invocation, allowing a service to be developed without dependency on pre-identified services or protocols. In a similar approach to service names, operations or APIs also need not be pre-determined until runtime. Typically, any invocation to a given service requires prior knowledge of the expected input parameters and understanding of the expected return values. The user may define\/configure several suitable target services, at runtime the context manager  decides which to invoke, according to the runtime context, such as whether the local or a more efficient service is available, versus a remote or less efficient service, for example. Furthermore, as any service is implemented using a programming language, this is useful for ensuring that errors or exceptions do not occur. This embodiment has a mapping mechanism ,  that is able to map expected inputs from given inputs of calling services and vice-versa, for returned values or parameters. The expected data types between the calling and invoked services match, otherwise errors or exceptions will occur through data incompatibility. The mapping of parameters or values need not be one to one mapping; it may, for instance, be one to two mapping or two to one mapping, or some other type (e.g. other non-one to one mapping).","Using an example set forth hereinafter, the getRate operation returns a value of \u201cfloat\u201d type, but the actual expected return type in the Calling Service is \u201clong\u201d. Hence, a conversion is needed, and this is what the mapping rules are able to provide. This embodiment has the ability to cast or map differing data types, within known constraints. Theoretically, the data types can be any type that is supported within the runtime environment. Where the runtime environments of the Calling Service and the Target Service support different data types, the context mapper  provides mapping capabilities. It is expected, for extreme cases, that some information, such as numbers or decimals, might be lost. In such cases, the mapping rules can be defined specifically to cater for such instances.","Constraints are defined into the mapping rules. For example, \u201cthe length of the new constructed parameter should be less than 10\u201d is a constraint rule. This rule is applied during a parameter reconstruction phase: if the length of the new parameter is greater than or equal to 10, an error is raised before the actual call to the service.","An example is given hereinafter to provide a more full understanding of the embodiment of the invention.","A moneychanger develops a money exchange service (Calling Service). In his service, the moneychanger needs to know the current currency exchange rates of various countries. The moneychanger does not have services that can provide this information directly, so he intends to use some 3party services (Target Services). The moneychanger has several 3party services providers, such as banks, stock exchanges, or some other organisations. The moneychanger has not made his mind up (does not need to) as to which service provider he will actually use. However, he knows he can provide the names of two countries and expects a returned exchange rate between the two countries.","The moneychanger can define a dependency interface in his service, which looks like the following in Table 1 (here Java notation is used, for C++ and other language, this can be changed):",{"@attributes":{"id":"p-0048","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public interface MyMoneyExchanger {"]},{"entry":[{},"\u2002float getCurrencyRate(CountryBean countryInfo);"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0049","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Class CountryBean {"]},{"entry":[{},"\u2002String baseCountryName;"]},{"entry":[{},"\u2002String targetCountryName;"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The expected result of the moneychanger's request is how much One-Unit of the currency of \u201cbaseCountryName\u201d can be exchanged for, in the currency of \u201ctargetCountryName\u201d. For example if one US dollar can exchanged for 1.70 Singapore dollar, the returned result should be 1.70 and \u201cbaseCountryName\u201d is \u201cUS\u201d and \u201ctargetCountryName\u201d is \u201cSingapore\u201d.","After the development is completed, the moneychanger can configure his preferred service provider's information into the descriptor. For example, ABC bank's \u201cgetRate\u201d service is selected. The ABC bank's service has the following signature:\n\n","The meaning of the service is how much  dollars, in the currency of \u201csrcCountryName\u201d, can be exchanged for of the currency of \u201cdesCountryName\u201d. As such, if \u201csrcCountryName\u201d is \u201cUS\u201d and \u201cdesCountryName\u201d is \u201cSingapore\u201d, the expected result of 170 means that 100 US dollars can be exchanged for 170 Singapore dollars.","To make use of the ABC's \u201cgetRate\u201d service, the moneychanger must first define the service information in the descriptor, for example (segment from the complete descriptor in ) as shown in Table 3:",{"@attributes":{"id":"p-0054","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<service-location>http:\/\/abc.com\/rateservice?WSDL<\/service-location>"},{"entry":"<port-type>RateIF<\/port-type>"},{"entry":"<service-method-name>getRate<\/service-method-name>."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The moneychanger also needs to define the following service mapping information in the descriptor. When calling to the method \u201cgetCurrencyRate\u201d in the calling service, the calling is mapped to the method \u201cgetRate\u201d in the called service. The value of the first parameter of the called service is extracted from the value of the attribute \u201cbaseCountryName\u201d in the calling method's parameter. The value of the second parameter of the called service is extracted from the value of the attribute value \u201ctargetCountryName\u201d in the calling method's parameter. The result obtained from the called method is divided by 100. A sample of a complete DESCRIPTOR for this scenario is listed in .","Knowledge as to the way to convert\/map differing data types, such as converting a \u201clong\u201d type to a \u201cfloat\u201d type, how to extract the attributes from a Bean, etc. is defined as RULES, as shown in Table 4.",{"@attributes":{"id":"p-0057","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/specific rules"]},{"entry":[{},"; extract attribute value from bean rule"]},{"entry":[{},"if the command is extraction of attribute"]},{"entry":[{},"then"]},{"entry":[{},"\u2003\u2003\u2003\u2003get the value object"]},{"entry":[{},"\u2003\u2003\u2003\u2003get the attribute name"]},{"entry":[{},"\u2003\u2003\u2003\u2003introspect the bean object and extract the value"]},{"entry":[{},"; calculate formula rule"]},{"entry":[{},"if the command is calculate"]},{"entry":[{},"then"]},{"entry":[{},"\u2003\u2003\u2003\u2003get the formula"]},{"entry":[{},"\u2003\u2003\u2003\u2003get each object on right hand part of the formula"]},{"entry":[{},"\u2003\u2003\u2003\u2003execute the calculation"]},{"entry":[{},"\/\/ constraint rule"]},{"entry":[{},"if the length of first reconstructed parameter of getRate >10"]},{"entry":[{},"then"]},{"entry":[{},"\u2003\u2003\u2003\u2003raise error"]},{"entry":[{},"if the first reconstructed parameter of getRate is not a country"]},{"entry":[{},"then"]},{"entry":[{},"\u2003\u2003\u2003\u2003raise error"]},{"entry":[{},"\/\/generic rules"]},{"entry":[{},"if source is a vector and target is an array"]},{"entry":[{},"then"]},{"entry":[{},"\u2003\u2003\u2003\u2003convert the vector into an array"]},{"entry":[{},"if source is long and target is float then"]},{"entry":[{},"\u2003\u2003\u2003\u2003execute new Long(source).floatValue( )"]},{"entry":[{},"if source is string and target is int then"]},{"entry":[{},"\u2003\u2003\u2003\u2003execute new Integer(source).intValue( )"]},{"entry":[{},"..."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"At runtime, when the calling service calls the method \u201cgetCurrencyRate\u201d in the dependency interface, overall steps 1.-5. (mentioned earlier) are applied. At a later time, if the money exchanger finds another or new service provider, he can define\/configure new mapping information in the descriptor, without re-coding or changing his service.",{"@attributes":{"id":"p-0059","num":"0076"},"figref":["FIG. 4","FIG. 2"]},"In the foregoing manner, a method and system are disclosed. Only one main embodiment, with some potential variations is described. However, it will be apparent to one skilled in the art in view of this disclosure that numerous changes and\/or modifications may be made without departing from the scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["These and other features, objects and advantages of embodiments of the invention will be better understood and readily apparent to one of ordinary skill in the art from the following written description, in conjunction with drawings, in which:",{"@attributes":{"id":"p-0024","num":"0030"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0025","num":"0031"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0026","num":"0032"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0027","num":"0033"},"figref":["FIG. 4","FIG. 2"]}]},"DETDESC":[{},{}]}
