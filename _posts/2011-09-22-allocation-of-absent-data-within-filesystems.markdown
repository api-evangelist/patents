---
title: Allocation of absent data within filesystems
abstract: Systems and methods which provide an absent allocation technique with respect to absent data of a data structure for which data migration in a time-displaced data migration operation has not completed are disclosed. Through use of absent allocated data block states of an absent allocation technique of embodiments, dependency between source and destination data stores may be broken. An absent allocated data block state of embodiments stored within the data structure provides a suggestive indication that data of a data block of a data structure is absent from the data structure. A corresponding absent allocated data block state of embodiments stored external to the data structure provides a determinative indication that the data of the data block of the data structure is absent from the data structure. The absent data block determinative indictor of embodiments is updated as data continues to be migrated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09355119&OS=09355119&RS=09355119
owner: NetApp, Inc.
number: 09355119
owner_city: Sunnyvale
owner_country: US
publication_date: 20110922
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present invention relates generally to management of data within filesystems and, more particularly, to allocation of absent data within such filesystems.","The creation and storage of digitized data has proliferated in recent years. Accordingly, techniques and mechanisms that facilitate efficient and cost effective storage of large amounts of digital data are common today. For example, a cluster network environment of nodes may be implemented as a data storage system to facilitate the creation, storage, retrieval, and\/or processing of digital data. Such a data storage system may be implemented using a variety of storage architectures, such as a network-attached storage (NAS) environment, a storage area network (SAN), a direct-attached storage environment, and combinations thereof. The foregoing data storage systems may comprise one or more data storage devices configured to store digital data within data volumes.","Digital data stored by data storage systems may be frequently migrated within the data storage system and\/or between data storage systems, such as by copying, cutting and pasting, replication, backing up and restoring, etc. For example, a user may move files, folders, or even the entire contents of a data volume from one data volume to another data volume. Likewise, a data replication service may replicate the contents of a data volume across nodes within the data storage system. Irrespective of the particular type of data migration performed, migrating large amounts of digital data may consume appreciable amounts of available resources, such as central processing unit (CPU) utilization, processing time, network bandwidth, etc. Moreover, migrating digital data may involve appreciable amounts of time to complete the migration between the source and destination.","In order to avoid poor user experience and other issues associated with latency in the data migration process of a particular data structure, some storage systems have begun implementing techniques which declare the data migration of a data structure complete, and facilitate access to the digital data of the data structure substantially as if the data migration were complete, prior to actual completion of the data migration. For example, data blocks of the data structure may be migrated as a background task and data blocks may be fetched from the source data store as needed on demand of the data consumer. Accordingly, it may appear to users and other consumers of the digital data that the data migration of the data structure has completed very quickly, thereby avoiding poor user experience and other issues associated with data migration latency. Moreover, by implementing such anachronistic or time-displaced data migration techniques, consumption of available resources by the data migration process may be controlled, such as through judicious operation of background data migration operations.","Although providing advantages with respect to user experience, data availability, available resource consumption control, etc., the foregoing time-displaced data migration techniques may present issues with respect to various data management processes. For example, a point-in-time image process may be utilized to create a read-only copy of all the digital data stored by a data volume or other data structure at a particular point in time (e.g., for use in performing digital data backup operations). Such a point-in-time image of a data store which is a destination of a data structure in a time-displaced data migration process that has not completed the data migration may present may result in data management issues. In particular, a paradox may be presented in which an otherwise apparently migrated data structure has portions of the digital data which are not present in the destination data store (referred to herein as \u201cabsent data\u201d), but instead remain upon the source data store. Accordingly, a point-in-time image of the digital data stored by the source data store may also be needed in order to provide backup data which facilitates data access matching that of the digital data being backed up (e.g., allowing for absent data blocks being fetched from the source data store as needed on demand of the data consumer). That is, in order to provide the same accessibility with respect to absent data, both the source and destination data stores of a time-displaced data migration would be needed (i.e., the source would need to exist for as long as the destination existed). It can be appreciated that where time-displaced data migration techniques are performed across multiple sources and destinations within a data system, point-in-time images and other processes providing for data at particular points in time may be incomplete without other data sources, or even caught in deadlocked situations with other data sources in the presence of absent data.","The present invention is directed to systems and methods which provide an absent allocation technique with respect to absent data of a data structure for which data migration in a time-displaced data migration operation has not completed. Through use of absent allocated data block states (referred to herein as \u201cAA states\u201d) of an absent allocation technique of embodiments herein, the dependency between source and destination data stores is broken with respect to processes providing for data at particular points in time (referred to herein as \u201cpoint-in-time processes\u201d or \u201cPIT processes\u201d). Accordingly, various PIT processes, such as point-in-time images, point-in-time backup, point-in-time restore, etc., are enabled to function in association with time-displaced data migration operations through the use of absent allocation techniques of embodiments herein.","An absent allocation technique using AA states of embodiments constructs a logical view of the migrated data structure (e.g., file, folder, data volume) in the file system such that absent data resulting from a time-displaced data migration (e.g., data migrated to the destination after a particular point in time) can be subsequently migrated. Using such an absent allocation technique, this subsequently migrated data may be accessed using data of a PIT process from a point in time prior to the subsequent migration (e.g., a point-in-time image taken of a destination data volume prior to completion of migration of a data structure), without altering the data of the PIT process (e.g., the data of the point-in-time image remains read-only and unchanged from the original point-in-time image). For example, in a write anywhere file layout (WAFL) filesystem, the buffer tree and container map (also known as a container file) are logically constructed but left physically absent in providing AA states according to embodiments of the invention. Such logically allocated buffer trees captured by PIT processes (e.g., point-in-time images, point-in-time backup, point-in-time restore, etc.) that are physically absent are used in combination with the container map, which continues to be populated as data is subsequently migrated, according to an absent allocation technique herein thereby breaking the dependency between the source and destination data stores.","AA states as implemented according to embodiments of the invention include simultaneous or contemporaneous use of a plurality of AA state indicators for a particular data block. For example, a suggestive AA state provides a non-determinative indication that data of a data block of a data structure is absent from the data structure. Simultaneously, a determinative AA state provides a determinative indication that the data of the data block of the data structure is absent from the data structure. In accordance with embodiments herein, the suggestive AA state indicator is stored in the data structure (e.g., as part of the aforementioned buffer tree), whereas the determinative AA state indicator is stored external to the data structure (e.g., as part of the aforementioned container map). Accordingly, the determinative AA state indictor of embodiments may be updated as data continues to be migrated, and thus the absent status of data of the data block changes.","In operation according to embodiments of the invention, a data structure is reported as migrated from a source data store to a destination data store within a storage system while data of one or more data blocks of the data structure remain to be migrated from the source data store to the destination data store. AA states of embodiments store absent allocated information for an absent data block of the data structure within the data structure and external to the data structure, wherein the absent data block is a data block of the one or more data blocks remaining to be migrated from the source data store to the destination data store. The absent allocated information stored external to the data structure is updated according to embodiments of the invention when the data of the absent data block is subsequently migrated to the destination data store. Accordingly, when accessing data of the absent data block after the data of the absent data block has been migrated from the source data store to the destination data store, the absent allocated information stored in the data structure indicates that the data of the absent data block is absent from the data structure (e.g., proving a suggestion that data may be absent) and the absent allocated information stored external to the data structure does not indicate that the data of the absent data block is absent from the data structure (e.g., providing a determination that data is not absent). The same accessibility with respect to absent data as was available through the data of the source and destination data stores, without dependency between source and destination data stores and without altering the data of the process providing for data at a particular point in time, is provided with respect to data captured by PIT processes (e.g., point-in-time images, point-in-time backup, point-in-time restore, etc.) when a time-displaced data migration technique results in absent data.","The foregoing has outlined rather broadly the features and technical advantages of the present invention in order that the detailed description of the invention that follows may be better understood. Additional features and advantages of the invention will be described hereinafter which form the subject of the claims of the invention. It should be appreciated by those skilled in the art that the conception and specific embodiment disclosed may be readily utilized as a basis for modifying or designing other structures for carrying out the same purposes of the present invention. It should also be realized by those skilled in the art that such equivalent constructions do not depart from the spirit and scope of the invention as set forth in the appended claims. The novel features which are believed to be characteristic of the invention, both as to its organization and method of operation, together with further objects and advantages will be better understood from the following description when considered in connection with the accompanying figures. It is to be expressly understood, however, that each of the figures is provided for the purpose of illustration and description only and is not intended as a definition of the limits of the present invention.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 1","FIG. 1"],"b":["100","102","104","106","102","104","102","104","116","118","128","130","102","104","116","118","120","122","124","126","128","130","132","132"]},"The modules, components, etc. of data storage systems  and  may comprise various configurations suitable for providing operation as described herein. For example, nodes  and  may comprise processor-based systems, such as file server systems, computer appliances, computer workstations, etc. Accordingly, nodes  and  of embodiments comprise a processor (e.g., central processing unit (CPU), application specific integrated circuit (ASIC), programmable gate array (PGA), etc.), memory (e.g., random access memory (RAM), read only memory (ROM), disk memory, optical memory, flash memory, etc.), and suitable input\/output circuitry (e.g., network interface card (NIC), wireless network interface, display, keyboard, data bus, etc.). The foregoing processor-based systems may operate under control of an instruction set (e.g., software, firmware, applet, code, etc.) providing operation as described herein.","Data store devices  and  may, for example, comprise disk memory, flash memory, optical memory, and\/or other suitable computer readable media. Data modules  and  of nodes  and  may be adapted to communicate with data store devices  and  according to a storage area network (SAN) protocol (e.g., small computer system interface (SCSI), fiber channel protocol (FCP), INFINIBAND, etc.) and thus data store devices  and  may appear a locally attached resources to the operating system. That is, as seen from an operating system on nodes  and , data store devices  and  may appear as locally attached to the operating system. In this manner, nodes  and  may access data blocks through the operating system, rather than expressly requesting abstract files.","Network modules  and  may be configured to allow nodes  and  to connect with client systems, such as clients  and  over network connections  and , to allow the clients to access data stored in data storage systems  and . Moreover, network modules  and  may provide connections with one or more other components of system , such as through network . For example, network module  of node  may access data store device  via communication via network  and data module  of node, . The foregoing operation provides a distributed storage system configuration for system .","Clients  and  of embodiments comprise a processor (e.g., CPU, ASIC, PGA, etc.), memory (e.g., RAM, ROM, disk memory, optical memory, flash memory, etc.), and suitable input\/output circuitry (e.g., NIC, wireless network interface, display, keyboard, data bus, etc.). The foregoing processor-based systems may operate under control of an instruction set (e.g., software, firmware, applet, code, etc.) providing operation as described herein.","Network  may comprise various forms of communication infrastructure, such as a SAN, the Internet, the public switched telephone network (PSTN), a local area network (LAN), a metropolitan area network (MAN), a wide area network (WAN), a wireless network (e.g., a cellular communication network, a wireless LAN, etc.), and\/or the like. Network , or a portion thereof may provide infrastructure of network connections  and  or, alternatively, network connections  and\/or  may be provided by network infrastructure separate from network , wherein such separate network infrastructure may itself comprise a SAN, the Internet, the PSTN, a LAN, a MAN, a WAN, a wireless network, and\/or the like.","As can be appreciated from the foregoing, system  provides a data storage system in which various digital data may be created, maintained, modified, and accessed (referred to collectively as data management). A logical mapping scheme providing logical data block mapping information, stored within and stored without the data structures, may be utilized by system  in providing such data management. For example, a filesystem implemented by data store devices  and  may implement a logical data block allocation technique, exemplary embodiments of which are discussed below with reference to , for creating, maintaining, modifying, and accessing data structures.","In one embodiment, data store devices  and  comprise volumes (shown as volumes A and B respectively), which is an implementation of storage of information onto disk drives, disk arrays, and\/or other data stores (e.g., flash memory) as a file-system for data, for example. Volumes can span a portion of a data store, a collection of data stores, or portions of data stores, for example, and typically define an overall logical arrangement of file storage on data store space in the storage system. In one embodiment a volume can comprise stored data as one or more files that reside in a hierarchical directory structure within the volume.","Volumes are typically configured in formats that may be associated with particular storage systems, and respective volume formats typically comprise features that provide functionality to the volumes, such as providing an ability for volumes to form clusters. For example, where a first storage system may utilize a first format for their volumes, a second storage system may utilize a second format for their volumes.","In the exemplary configuration of system , clients  and  can utilize data storage systems  and  to store and retrieve data from volumes . In such an embodiment, for example, client  can send data packets to N-module  in node  within data storage system . Node  can forward the data to data store device  using D-module , where data store device  comprises volume A. In this way, in this example, the client can access storage volume A, to store and\/or retrieve data, using data storage system  connected by network connection . Further, in this embodiment, client  can exchange data with N-module  in node  within data storage system  (e.g., which may be remote from data storage system ). Node  can forward the data to data storage device  using D-module , thereby accessing volume B associated with the data storage device .","The foregoing data store devices each comprise a plurality of data blocks, according to embodiments herein, which may be used to provide various logical and\/or physical storage containers, such as files, container files holding volumes, aggregates, virtual disks, etc. Such logical and physical storage containers may be defined using an array of blocks indexed or mapped either logically or physically by the filesystem using the appropriate type of block number. For example, a file may be indexed by file block numbers (FBNs), a container file by virtual block numbers (VBNs), an aggregate by physical block numbers (PBNs), and disks by disk block numbers (DBNs). To translate an FBN to a disk block, a filesystem (e.g., a WAFL filesystem) may use several steps, such as to translate the FBN to a VBN, to translate the VBN to a PBN, and then to translate the PBN to a DBN. Storage containers of various attributes may be defined and utilized using such logical and physical mapping techniques. For example, volumes such as volumes A and B may be defined to comprise aggregates (e.g., a traditional volume) and\/or flexible volumes (e.g., volumes built on top of traditional volumes as a form of virtualization) using such logical and physical data block mapping techniques.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 2","FIG. 2"],"b":["200","200"]},"It should be appreciated that the hierarchical logical mapping of buffer tree  provides indirect data block mapping using a plurality of levels (shown as levels L0-L2). Data blocks of level L0 comprise the ultimate data (e.g., user data, application data, etc.) and thus provide a data level. Levels L1 and L2 of buffer tree  comprise indirect blocks that provide information with respect to other data blocks, wherein data blocks of level L2 provide information identifying data blocks of level L1 and data blocks of level L1 provide information identifying data blocks of level L0. The illustrated embodiment of buffer tree  comprises a configuration in which data blocks of the indirect levels (levels L1 and L2) comprise both logical data block identification information (shown as virtual block numbers (VBNs)) and their corresponding physical data block identification information (shown as physical block numbers (PBNs)). That is, in the illustrated embodiment, each of levels L2 and L1 have both a VBN and PBN. This format, referred to as dual indirects due to there being dual block numbers in indirect blocks, is a performance optimization implemented according to embodiments herein.","Alternative embodiments may be provided in which the file buffer trees store VBNs without their corresponding PBNs. However, a consequence of such an embodiment is that, for every VBN, the system would have to look up the PBN in another map (e.g., a container map). The illustrated embodiment of buffer tree  avoids this significant amount of work by essentially caching the PBN in the buffer tree itself by storing both numbers. Irrespective of the particular performance optimization techniques implemented, absent allocated states implemented according to embodiments of the invention take advantage of the layer of indirection of a logical mapping to implement on-demand time-displaced semantics.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 3","b":["300","300","200","300","200","300","200","300","0"]},"It should be appreciated that both buffer tree  and container map  may be provided according to embodiments, although each provides data block mapping with respect to a same data structure, because there are 2 objects: one object being the container map inside the flexible volume aggregate and the other object being the actual user files inside the flexible volume. Each of the blocks in a user file's buffer tree may thus have 3 locations according to embodiments (e.g., the FBN in the file's buffer tree, the location in the flexible volume's buffer tree (the FBN of the container map) and a PBN (the block number in the aggregate).","Data management functionality provided by system  using buffer tree  and container map  according to embodiments of the invention includes time-displaced data migration. Accordingly, system  may operate to declare that the data migration of a data structure is complete prior to actual completion of the data migration. For example, a user of client  may initiate migration of a data structure (e.g., a file, folder, data volume, etc.) from data store device  to data store device . The particular data structure may comprise a relatively large amount of digital data (e.g., 200 GB) and thus it's migration from the source (data store device ) to the destination (data store device ) may take an appreciable amount of time (e.g., tens or even hundreds of minutes). System  may thus implement a time-displaced data migration technique to declare the data structure migrated almost immediately after the initiation of the migration process by the user, although data blocks of the data structure may in fact remain to be migrated (e.g., in a background process which has not yet completed). Despite there being data of the data structure absent from the destination, operation of the time-displaced data migration technique by system  of embodiments facilitates access to the data of the data structure as if all data blocks of the data structure were present at the destination.","Operation of the foregoing time-displaced data migration techniques, wherein data is absent with respect to a file structure at a destination for some period of time, may present issues with respect to various data management processes, such as PIT processes. Such PIT processes may comprise processes such as point-in-time images (e.g., SNAPSHOT functionality available from NetApp, Inc.), point-in-time backup (e.g., SNAPVAULT functionality available from NetApp, Inc.), point-in-time restore (e.g., SNAPRESTORE functionality available from NetApp, Inc.), etc. For example, in order to provide the same accessibility with respect to absent data using data captured using a PIT process, both the source and destination data stores of a time-displaced data migration may be needed to provide access to data absent at the destination. Implementation of absent allocation techniques according to embodiments of the invention, however, break the dependency between source and destination data stores with respect to data captured using PIT processes for data structures partially migrated using a time-displaced data migration technique.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 4","FIG. 4"],"b":["400","100","400","108","110","102","104"]},"In operation according to the illustrated embodiment, a data migration process is initiated at block . The data migration process may, for example, comprise copying, cutting, pasting, replication, backing up, and\/or restoring digital data. Such data migration may be initiated by a user (e.g., a user of client  or ), another process (e.g., a backup process or a data mirroring process), etc. The data being migrated comprises a data structure (e.g., file, folder, data volume, etc.) stored by one or more data store of system  (source data store or location) to be written to one or more data store of system  (destination data store or location). It should be appreciated that such migration may comprise a source and destination which are part of the same data store device.","At block  of the illustrated embodiment, system  reports the data as having been migrated from the source (e.g., data store device ) to the destination (e.g., data store device ). However, data of one or more data blocks of the data structure remain to be moved from the source data store to the destination data store. Accordingly, a time-displaced data migration technique is provided wherein it appears as if the data was migrated more quickly than the data was in fact migrated.","In operation according to the embodiment illustrated in , data migration is performed as a background task by system , as represented by block . For example, as resource utilization, quality of service parameters, bandwidth availability, etc. permits, data blocks of the data structure to be migrated may be migrated from the source to the destination. Other processes, such as access to the migrated data and other data, are preferably accommodated by system  during the foregoing migration of the data. Accordingly, various other processes may be performed asynchronously with respect to the data migration at block .","At block , while performing data migration, AA states are set for data of the file structure being migrated which is absent on the destination at that particular point in the migration process. The AA states of embodiments store suggestive absent allocated information for an absent data block of the data structure within the data structure (e.g., as part of buffer tree ) and determinative absent allocated information for an absent data block of the data structure external to the data structure (e.g., as part of container map ). Suggestive absent allocated information provides a non-authoritative or non-determinative indication (i.e., a rebuttable suggestion) that the data of a particular data block may not be present on the destination. Determinative absent allocated information provides an authoritative or determinative indication (e.g., a final determination) that the data of a particular data block is not present on the destination.","AA states may comprise a plurality of states indicated in a variety of ways. For example, a first state (e.g., an absent allocated state) may be indicated through use of a predetermined code entered as the PBN (e.g., at level 0 (L0) of a hierarchical logical mapping) for an absent allocated data block. The absent allocated state may be represented by a particular reserved PBN or other information unlikely to be confused with an actual, valid PBN. Alternatively, this state may be indicated through the use of data stored in or in association with a PBN assigned to an absent allocated data block (e.g., particular metadata to indicate absent allocated or data stored within the data block unlikely to be confused with actual, valid data). A second state (e.g., a present state) may be indicated for a previously absent allocated data block through the use of an actual, valid PBN and\/or data stored thereby. For example, the present state may be represented by the lack of a particular PBN, metadata, or other data used to indicate the absent allocated state.","States in addition to or in the alternative to the aforementioned absent allocated state and present state may be provided by embodiments of the invention. For example, a third state (e.g., an absent state) may be indicated through the use of a predetermined code entered as the PBN for an absent data block. The absent state may be represented by a different reserved PBN than that used for the aforementioned absent allocated state. Such an absent state may be a precursor to an absent allocated state. For example, a data block may be denoted as absent prior to allocation of a level 0 (L0) block for an absent data block in a logical view of the migrated data structure.","In operation according to embodiments of the invention at block , the foregoing AA states are provided as part of a data cleaning process performed by system . For example, as the dirtied data of the buffer is committed to the destination data store through the cleaning process, data blocks of the data structure being migrated which are not present in the buffer and which have not already been committed to the destination data store have AA states of absent allocated set with respect thereto. That is, logical blocks are allocated in the logical view of the migrated data structure for data blocks of the data structure being migrated which are not present when the cleaning process is performed. Logical blocks may be provided in buffer tree  for each of the absent data blocks, wherein these logical blocks comprise AA state information (e.g., a respective VBN and an absent allocated code instead of a PBN at level 0 (L0)). Similarly, logical blocks may be provided in container map  for each of the absent data blocks, wherein these logical blocks comprise AA state information (e.g., a respective VBN and an absent allocated code instead of a PBN).","From the foregoing, it can be appreciated that absent allocation techniques herein may be implemented using the existing virtual and physical block number spaces provided by various data structures (e.g., flexible volumes). In particular, such an absent allocation process may proceed by selecting a VBN for an absent data block, whereas an actual or non-reserved PBN is not selected at absent allocation time. Instead absent allocation information may be written into the indirect block of a buffer file for the absent data block. The container map for the data structure, which maps VBNs to PBNs, present in the parent aggregate may correspondingly be updated to include absent allocation information at the corresponding level 1 (L1) buffer index for the VBN. Accordingly, the level 0 (L0) PBN for an absent allocated data block of embodiments of the invention does not contain valid data while the data block is absent allocated, although it may be later filled with valid data, such as using a fetch and fill process on-demand.","Having provided AA state information for data blocks of the data structure being migrated which is absent on the destination, processing according to flow  of the illustrated embodiment proceeds to block . At block  a determination is made as to whether all the data of the file structure being migrated has been migrated to the destination. If all the data has been migrated, processing according to the illustrated embodiment proceeds to block  wherein the data migration process concludes. However, if data remains to be migrated, processing according to the illustrated embodiment returns to block  wherein data migration is continued.","It should be appreciated that as additional data is migrated to the destination, whether by continued background data migration processing or by other means (e.g., as the result of a data fetch in response to a user accessing the time-displaced data structure at the destination), AA state information provided at block  is updated. For example, the AA state information of logical blocks provided in buffer tree  for the absent data blocks which have now been migrated to the destination may be updated (e.g., a PBN provided to replace the aforementioned absent allocated code). Similarly, the AA state information of logical blocks provided in container map  for the absent data blocks which have now been migrated to the destination may be updated (e.g., a PBN provided to replace the aforementioned absent allocated code).","In understanding the use of the AA states of embodiments of the invention it is helpful to remember that absent data block information is stored in the migrated data structure (e.g., buffer tree ) and external to the migrated data structure (e.g., container map ). It is likewise helpful to remember that other processes are allowed to be performed with respect to the data being migrated. Accordingly, block  of the embodiment illustrated in  shows a PIT process (e.g., point-in-time image) being performed asynchronously with respect to the data migration and absent allocation processing of flow . The PIT process of the illustrated embodiment provides data frozen as of the particular point in time (frozen data ). Accordingly, frozen data  may comprise an incomplete data structure (e.g., have absent data). Moreover, the data structure captured by frozen data  comprises stored absent allocated data block information (e.g., buffer tree ) as of the particular point in time. Accordingly, although operation provided by flow  may update both the absent data block information stored in the migrated data structure and external to the migrated data structure as discussed above, the absent data block information stored in the data structure as captured by frozen data  is not updated. Nevertheless, the formerly absent data blocks may continue to be migrated from the source to the destination (and thus removed from the source) after frozen data  was captured. The aforementioned AA states of embodiments of the invention accommodate this absent data paradox through the use of suggestive and determinative absent allocated data block information.","For example, various PIT processes may be performed after the AA states have been initially set for blocks of a data structure. Thereafter, the suggestive and determinative AA states are referenced to mitigate issues associated with the later migration of absent data. In particular, when absent allocated blocks are accessed inside a data volume after a PIT process data capture providing frozen data, the data blocks can be fetched and filled from the source without having to modify the data volume image captured by the PIT process. This is because the AA state information in the data volume buffer tree of embodiments is only treated as a hint or suggestion as to the absent state of the data block. As discussed in further detail below with reference to , it is the AA state information in the container map file of embodiments which authoritatively or deterministically indicates whether a data block as been fetched and filled subsequent to the capture of the frozen data or not (i.e., remains absent).",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 5","b":["500","100","411","501","411"]},"At block  shown in flow  the data structure of frozen data  is accessed to retrieve a desired block of data. For example, the data access process initiated may serially access the data blocks (e.g., according to their logical and\/or physical mapping) in a process to return a portion of the data stored by system  to its state at the particular point in time data was captured by the PIT process. Likewise, the data access process initiated may access particular data blocks (e.g., data blocks relevant to an operation or a request by a user) in a process to provide some portion of data in its state at the particular point in time data was captured by the PIT process.","In operation according to embodiments of the invention, accessing the data structure at block  comprises accessing logical mapping information (e.g., buffer tree ) which is stored within the data structure captured as part of frozen data . As discussed above, such logical mapping information is adapted according to embodiments herein to provide mapping of logical data block information to AA state information. Such AA state information of embodiments may indicate an absent allocated state for data blocks which had not been migrated, and thus were absent at the destination, at the particular point in time frozen data  was captured. Alternatively, the AA state information may provide mapping of logical data block information to physical data block information for data blocks which had been migrated, and thus were present at the destination, at the particular point in time frozen data  was captured. Because the AA state information stored within the data structure captured as part of frozen data  is not updated after the particular point in time of its capture, it does not reflect subsequent migration of data blocks. Accordingly, embodiments of the invention use this AA state information as a suggestive indication (i.e., a non-authoritative or non-determinative indication) of the absent allocated state of the data block. That is, the AA state stored within the data structure (e.g., as part of the aforementioned buffer tree) of embodiments of the invention is used to provide a suggestive indication that data of a data block of a data structure is absent from the data structure.","At block  of the illustrated embodiment a determination is made as to whether the suggestive AA state information for the data block being accessed as stored by the data structure of the frozen data indicates that the data block is absent. If not, the data block had been migrated, and thus was present at the destination, at the particular point in time frozen data  was captured, and thus was captured by as part of this frozen data. Accordingly, if the suggestive AA state information for the data block being accessed does not indicate that the data block is absent, processing according to flow  proceeds to block  wherein the data block is retrieved (e.g., using the VBN and PBN mapping information of buffer tree  and\/or container map ) and thence to block  wherein it is determined whether additional data blocks are to be accessed for branching to return to access additional data blocks (block ) or to conclude the data block access processing (block ).","If, however, the data block had not been migrated, and thus was not present at the destination, at the particular point in time frozen data  was captured, and thus was not captured by as part of the frozen data the suggestive AA state information will indicate that the data block is absent. As described above, the AA state information stored within the data structure captured as part of frozen data  is not updated after the particular point in time of its capture, and thus does not reflect subsequent migration of data blocks. Accordingly, if the suggestive AA state information for the data block being accessed indicates that the data block is absent, processing according to flow  proceeds to block  for a determinative indication of the absent state of the data block.","At block  of the illustrated embodiment logical mapping information which is stored external to the data structure captured as part of frozen data  (e.g., container map ) is accessed. As discussed above, such logical mapping information is adapted according to embodiments herein to provide mapping of logical data block information to AA state information. Such AA state information of embodiments may indicate an absent allocated state for data blocks which had not been migrated, and thus were absent at the destination, at the particular point in time frozen data  was captured. Alternatively, the AA state information may provide mapping of logical data block information to physical data block information for data blocks which had been migrated, and thus were present at the destination, at the particular point in time frozen data  was captured. However, unlike the suggestive AA state information stored in the data structure as captured by the frozen data, the absent allocated information for the absent data block stored external to the data structure is updated according to embodiments of the invention when the data of the absent data block is subsequently migrated to the destination. Accordingly, the AA state information of the logical mapping information stored externally to the frozen data (e.g., as part of the aforementioned container map) is utilized according to the illustrated embodiment to provide a determinative indication (e.g., an authoritative indication or final determination) that the data of the data block of the data structure is absent from the data structure.","At block  of the illustrated embodiment a determination is made as to whether the determinative AA state information for the data block being accessed as stored by the data structure of the frozen data indicates that the data block is absent. If not, the data block had been migrated subsequent to the point in time frozen data  was captured, and thus is present at the destination. Accordingly, if the determinative AA state information for the data block being accessed does not indicate that the data block is absent, processing according to flow  proceeds to block  wherein the data block is retrieved (e.g., using the VBN and PBN mapping information of container map ) and thence to block  wherein it is determined whether additional data blocks are to be accessed for branching to return to access additional data blocks (block ) or to conclude the data block access processing (block ).","If, however, the data block had not been migrated, and thus remains absent at the destination, the determinative AA state information will indicate that the data block is absent. As described above, the AA state information stored without the data structure captured as part of frozen data  is updated after the particular point in time of its capture, and thus reflects subsequent migration of data blocks. Accordingly, if the determinative AA state information for the data block being accessed indicates that the data block is absent, processing according to flow  proceeds to block  for accessing the data block from the migration source and thence to block  wherein it is determined whether additional data blocks are to be accessed for branching to return to access additional data blocks (block ) or to conclude the data block access processing (block ).","From the foregoing it can be appreciated that, if an AA state of absent allocated is present in both the logical mapping stored within the data structure (e.g., the buffer tree) and the corresponding logical mapping stored without the data structure (e.g., the container map) then flow  of the illustrated embodiment proceeds with fetching the data block from the source (block ). In operation according to embodiments, a fetch reads the data block from the source and then initiates a fill (writes the data block) at the destination. Absent allocated fills of embodiments write to the externally stored logical mapping (e.g., container map) and then awaken client requests that were waiting for the data block. The awoken client request of embodiments will still see the AA state absent allocated hint in the logical mapping stored in the data structure (e.g., buffer tree) but when it checks the logical mapping stored external to the data structure (e.g., container map) it will find the block and complete successfully. The foregoing fetch and fill of absent allocated blocks proceeds without modifying the data structure captured in the frozen data, although read only images inside the captured data structure (e.g. point-in-time images) can be filled subsequent to the capture of the frozen data (e.g., on demand).","The foregoing absent allocation techniques, using AA states of embodiments, construct a logical view of the migrated data structure (e.g., file, folder, data volume) in the file system such that absent data resulting from a time-displaced data migration can be subsequently migrated and the migrated data accessed by a PIT process prior to its migration (e.g., a point-in-time image taken of a destination data volume prior to completion of migration of a data structure), without altering the data of the PIT process (e.g., the data of a point-in-time image remains read-only and unchanged from the original point-in-time image). For example, through embodiments going outside the data structure to determine if particular data blocks have been filled from the source or not, an orthogonal state is created. Such an orthogonal state is orthogonal to various other processes which may be performed asynchronously with respect to the data migration process (e.g., point-in-time images) that are created with respect to the data structure. Such orthogonality allows operation herein to create point-in-time images on a volume, for example, and the absent blocks to be subsequently filled in on the volume at leisure. The AA state that gets captured in the foregoing point-in-time image according to embodiments is only a hint or suggestion, not authoritative or determinative, regarding the absentness of a data block. For example, the absent allocated information in the buffer tree PBN serves as a hint of absentness that is authoritatively answered by a subsequent check of the container map according to embodiments of the invention. If both indicate absent allocated, then a fetch from the source may be performed and fills may be done to the container map. Accordingly, absent allocation techniques as described above enable various processes, including a set of on-demand operations, to be implemented in an existing WAFL ecosystem while maintaining a very high level of compatibility with existing features (e.g., features built upon point-in-time images, etc.).","Having described concepts of the present invention with reference to the high level block and flow diagrams above, operation according embodiments of the invention is described with reference to particular filesystem configuration aspects in the ladder diagrams below. It should be appreciated that the details of the particular filesystem configuration aspects referenced below are provided to aid the reader in better understanding concepts of the present invention and, although embodiments of the invention may incorporate such aspects, the concepts herein are not so limited.","The ladder diagrams of  show various operational cases of a configuration of system  providing absent allocation techniques according to embodiments herein in an exemplary WAFL filesystem. It should be appreciated that functionality of the process flows illustrated in  may be implemented in software whereby elements of embodiments of the present invention are essentially code segments operable upon a processor-based or computer system (e.g., clients ,  and\/or data storage systems , ) to perform tasks as described herein. The program or code segments can be stored in a computer readable medium (e.g., RAM, ROM, disk memory, optical memory, flash memory, etc.).","Frame Dest  shown in the ladder diagrams of  is a process that establishes logical mapping (e.g., establishes a buffer tree), thus framing builds up a data block logical map. Inode AA L0 FBN list  shown in the ladder diagrams of  is a data set that represents a particular data structure (e.g., file, folder, data volume, etc.), wherein for every data structure a list of the level 0 (L0) frame block numbers (FBNs) that have been absent allocated in memory is provided. WAFE (write allocation front end)  and WABE (write allocation back end)  shown in  provide two portions of a cleaner process operable to taking dirty, in memory data and commit that data to a data store, wherein the cleaning process allocates spots for all the different data blocks that have been dirtied.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 6","FIG. 6"],"b":["601","601","602"]},"In the embodiment illustrated in , a cleaning process runs independently of (e.g., in parallel with) the foregoing framing process to clean the various Inodes of the filesystem. Accordingly, at some point the cleaning process will begin with respect to Inode AA L0 FBN list  providing the data set that represents a particular data structure with absent data blocks absent allocated at the L0 level. For a particular Inode that has absent allocated blocks (here Inode AA L0 FBN list ), the absent allocated list is sorted by WAFE  in order to lay out the absent allocated blocks in a contiguous space on the data store, such as for performance reasons. An extent of the contiguous blocks is preferably created from the sorted absent allocated blocks (e.g., providing a contiguous range) by WAFE .","The extents are provided to WABE  of the illustrated embodiment to identify areas of contiguous free data store spaces (referred to as buckets) and match those spaces up with data to be written to data store. For example, buckets of free VBNs (vbkt) and PBNs (pbkt) may be accessed by WABE  for assigning to particular data blocks (e.g., FBNs). VBNs and PBNs may be selected from corresponding ones of the aforementioned VBN buckets and PBN buckets and matched with the data blocks to be allocated. For example, WABE  retrieves a VBN from the VBN bucket for an absent allocated data block and now that particular FBN has a VBN. The Inode and volume block counts are incremented by WABE  of the illustrated embodiment to provide accounting information that tracks how many blocks are used by the file and volume.","WABE  of the illustrated embodiment further sets the parent L1 VBN so that the index in the parent L1 level of the hierarchical logical mapping is set to the VBN selected for the FBN, thereby recording the VBN in the Inode AA L0 FBN list  buffer tree. Additionally, WABE  sets the parent L1 PBN to an absent allocated state indicator. For example, a reserved PBN may be recorded in the PBN in the mode AA L0 FBN list  buffer tree for the FBN. Accordingly, operation of WABE  of the illustrated embodiment sets the parent L1 PBN to the absent allocated state. Similarly, WABE  sets the container L1 PBN to the absent allocated state using the absent allocated state indicator. Once WABE  finishes this process with respect to the blocks of Inode AA L0 FBN list  the absent allocated process is complete as to the present data and the normal cleaning process is performed with respect to all the data (both absent allocated and present data blocks).",{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIG. 7","FIG. 7","FIG. 6"],"b":["601","602","603","603","604","603"]},{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIG. 8","FIG. 8","FIG. 8"]},"In the illustrated embodiment of , a WAFL load buffer process begins for an absent allocated, still absent data block (e.g., a user may have initiated an operation to read the data block at the particular FBN which is absent allocated). Because the data block remains absent (is not on the data store), the process of  is divided into two major steps. There is a fetch step, wherein a request is sent to the source node in order to obtain the data block. Also, there is a fill step, wherein the received data block is inserted into the destination filesystem (e.g., into the container map in the aggregate). Accordingly, the ladder diagram of  illustrates the substeps involved in providing the aforementioned fetch and fill steps for an absent allocated data block which is fully absent.","Because the data block may not be in the data store, but rather may be in memory prior to being committed to the data store, the process of  determines if the data block is in the buffer hash table after the load buffer process begins. The buffer hash table is the in-memory state of all the buffers that are present in memory and is keyed by indirect level (e.g., L0, L1, L2, etc.). Accordingly, the buffer hash table is tested at level 0 (L0) for the FBN of the data block (Test (wip, level 0, FBN)). Here the data block is absent and thus a not present indication is returned. Accordingly, the process of  proceeds to test the Inode buffer tree for the data block (Read L1 at FBN Index). Here, level 1 (L1) in the Inode buffer tree is read at a particular FBN index because, according to absent allocated embodiments herein each L1 has an array of VBNs and PBNs wherein a PBN of an absent allocated data block provides absent allocated information (e.g., a reserved PBN). Again, here the data block is absent and thus an absent allocated state (VBN_ABSENT_ALLOCATED) is returned. However, there is a possibility that the data block may have already been fetched and filled, and thus the process of  also proceeds to test the container map (Read L1 at FBN Index). Because this example situation is assumed to be an absent allocated, still absent situation, the data block is still absent and thus an absent allocated state (VBN_ABSENT_ALLOCATED) is again returned. Thus a fetch and suspend process is initiated to retrieve the absent data block from the source. It should be appreciated that, as discussed above, the substeps of the embodiment of  test both the Inode inside the data structure (e.g., Read L1 at FBN Index; VBN_ABSENT_ALLOCATED) and inside the container map (e.g., Read L1 at FBN Index; VBN_ABSENT_ALLOCATED), wherein the container map is in the aggregate.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 9","FIG. 9","FIG. 9"]},"Having found that the data block remains absent in the destination filesystem, the process of  proceeds to a modify phase. In the modify phase of the illustrated embodiment two different write processes are implemented. One such write process (wafl_write_iombchain) dirties buffers with the data of a network stack (e.g., Mbuffer chain) so that those dirty buffers will eventually be committed to data store by the cleaner process. The other such write process (WAFL_B_NORECYCLE) implements a NORECYCLE process with respect to the buffers of the container map to which the fetched data block is to be written. Since the cleaner process is a parallel system, the buffers of the container map are not dirtied while the cleaner could be dirtying buffers to the container file. Accordingly, the process of  marks them NORECYCLE since they are not dirty yet and the buffer cache should not recycle them because that would mean throwing away data blocks that have not been committed to data store yet. This write process preferably finishes the fill and then initiates a fill sink process, wherein the fill sink process suspends behind the cleaner if the cleaner is processing the container file. If the cleaner is not processing the container file then the write process may simply dirty the appropriate buffers and then those blocks are on their way to data store through the normal cleaning process.",{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 10"},"The process of  begins similar to that of the process of , wherein the buffer hash table, Inode buffer tree, and container map are checked for the data block. However, after the data block is determined to be absent allocated, a check of the buffer table is made for the presence of the data block not yet having a VBN assigned to it (Test (cont_wip, level 0, VVBN)). Here the data block is present in the buffer hash table without yet having had a VBN assigned thereto (the data block is anonymous) and thus a status indicating that the container is dirty is returned (Present, Dirty, Anon). For example, the cleaner is operable asynchronously with respect to other processes which may alter the data, and thus the data block may have been migrated and the cleaner process not have run to commit the data block to data store. Accordingly, the process of  operates to insert an invalid child buffer and to copy the buffer data from the dirty level 0 (L0) for the data block into the Inode buffer tree, wherein the foregoing invalid state of the child buffer refers to how a file system (e.g., WAFL file system) reads blocks from slow data store devices into fast memory (e.g., the read process may begin with putting an invalid buffer in memory and then initiate a read from data store and suspend, wherein the data store read will complete in time and mark the buffer valid and the request that was waiting for the buffer can be restarted and executed). Using such an invalid child buffer, embodiments need not go to data store to validate the buffer, as the needed buffer exists in the container map, and thus the Inode's buffer may be validated by copying the data from the container map.","As can be appreciated from the foregoing, embodiments of the invention provide operation wherein a data structure (e.g., file, folder, data volume, etc.) is reported as migrated from a source to a destination while data of one or more data blocks of the data structure remain to be migrated. AA states of embodiments store absent allocated information for an absent data block of the data structure within the data structure (e.g., in the buffer tree) and external to the data structure (e.g., in the container map). The absent allocated information for the absent data block stored external to the data structure is updated according to embodiments of the invention when the data of the absent data block is subsequently migrated to the destination data store. Accordingly, when accessing data of the absent data block after the data of the absent data block has been migrated from the source to the destination the absent allocated information stored in the data structure indicates that the data of the absent data block is absent from the data structure (e.g., proving a hint or suggestion that data may be absent) and the absent allocated information stored external to the data structure does not indicate that the data of the absent data block is absent from the data structure (e.g., providing a determination that data is not absent). Thus, the same accessibility with respect to absent data as was available through the data of the source and destination data stores, without dependency between source and destination data stores and without altering the data of the process providing for data at a particular point in time, is provided with respect to data captured by PIT processes (e.g., point-in-time images, point-in-time backup, snapvalut, etc.) when a time-displaced data migration technique provides for absent data.","Although the present invention and its advantages have been described in detail, it should be understood that various changes, substitutions and alterations can be made herein without departing from the spirit and scope of the invention as defined by the appended claims. Moreover, the scope of the present application is not intended to be limited to the particular embodiments of the process, machine, manufacture, composition of matter, means, methods and steps described in the specification. As one of ordinary skill in the art will readily appreciate from the disclosure of the present invention, processes, machines, manufacture, compositions of matter, means, methods, or steps, presently existing or later to be developed that perform substantially the same function or achieve substantially the same result as the corresponding embodiments described herein may be utilized according to the present invention. Accordingly, the appended claims are intended to include within their scope such processes, machines, manufacture, compositions of matter, means, methods, or steps."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWING","p":["For a more complete understanding of the present invention, reference is now made to the following descriptions taken in conjunction with the accompanying drawing, in which:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIGS. 6-10"}]},"DETDESC":[{},{}]}
