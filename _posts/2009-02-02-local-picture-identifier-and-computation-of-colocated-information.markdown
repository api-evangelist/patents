---
title: Local picture identifier and computation of co-located information
abstract: Video decoding innovations for using local picture identifiers and computing co-located information are described. In one aspect, a decoder identifies reference pictures in a reference picture list of a temporal direct prediction mode macroblock that match reference pictures used by a co-located macroblock using local picture identifiers. In another aspect, a decoder determines whether reference pictures used by blocks are the same by comparing local picture identifiers during calculation of boundary strength. In yet another aspect, a decoder determines a picture type of a picture and based on the picture type selectively skips or simplifies computation of co-located information for use in reconstructing direct prediction mode macroblocks outside the picture.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08189666&OS=08189666&RS=08189666
owner: Microsoft Corporation
number: 08189666
owner_city: Redmond
owner_country: US
publication_date: 20090202
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Companies and consumers increasingly depend on computers to process, distribute, and play back high quality video content. Engineers use compression (also called source coding or source encoding) to reduce the bit rate of digital video. Compression decreases the cost of storing and transmitting video information by converting the information into a lower bit rate form. Decompression (also called decoding) reconstructs a version of the original information from the compressed form. A \u201ccodec\u201d is an encoder\/decoder system.","Compression can be lossless, in which the quality of the video does not suffer, but decreases in bit rate are limited by the inherent amount of variability (sometimes called source entropy) of the input video data. Or, compression can be lossy, in which the quality of the video suffers, and the lost quality cannot be completely recovered, but achievable decreases in bit rate are more dramatic. Lossy compression is often used in conjunction with lossless compression\u2014lossy compression establishes an approximation of information, and the lossless compression is applied to represent the approximation.","A basic goal of lossy compression is to provide good rate-distortion performance. So, for a particular bit rate, an encoder attempts to provide the highest quality of video. Or, for a particular level of quality\/fidelity to the original video, an encoder attempts to provide the lowest bit rate encoded video. In practice, considerations such as encoding time, encoding complexity, encoding resources, decoding time, decoding complexity, decoding resources, overall delay, and\/or smoothness in quality\/bit rate changes also affect decisions made in codec design as well as decisions made during actual encoding.","In general, video compression techniques include \u201cintra-picture\u201d compression and \u201cinter-picture\u201d compression. Intra-picture compression techniques compress a picture with reference to information within the picture, and inter-picture compression techniques compress a picture with reference to a preceding and\/or following picture (often called a reference or anchor picture) or pictures.","For intra-picture compression, for example, an encoder splits a picture into 8\u00d78 blocks of samples, where a sample is a number that represents the intensity of brightness or the intensity of a color component for a small, elementary region of the picture, and the samples of the picture are organized as arrays or planes. The encoder applies a frequency transform to individual blocks. The frequency transform converts an 8\u00d78 block of samples into an 8\u00d78 block of transform coefficients. The encoder quantizes the transform coefficients, which may result in lossy compression. For lossless compression, the encoder entropy codes the quantized transform coefficients.","Inter-picture compression techniques often use motion estimation and motion compensation to reduce bit rate by exploiting temporal redundancy in a video sequence. Motion estimation is a process for estimating motion between pictures. For example, for an 8\u00d78 block of samples or other unit of the current picture, the encoder attempts to find a match of the same size in a search area in another picture, the reference picture. Within the search area, the encoder compares the current unit to various candidates in order to find a candidate that is a good match. When the encoder finds an exact or \u201cclose enough\u201d match, the encoder parameterizes the change in position between the current and candidate units as motion data (such as a motion vector (\u201cMV\u201d)). In general, motion compensation is a process of reconstructing pictures from reference picture(s) using motion data.","The example encoder also computes the sample-by-sample difference between the original current unit and its motion-compensated prediction to determine a residual (also called a prediction residual or error signal). The encoder then applies a frequency transform to the residual, resulting in transform coefficients. The encoder quantizes the transform coefficients and entropy codes the quantized transform coefficients.","If an intra-compressed picture or motion-predicted picture is used as a reference picture for subsequent motion compensation, the encoder reconstructs the picture. A decoder also reconstructs pictures during decoding, and it uses some of the reconstructed pictures as reference pictures in motion compensation. For example, for an 8\u00d78 block of samples of an intra-compressed picture, an example decoder reconstructs a block of quantized transform coefficients. The example decoder and encoder perform inverse quantization and an inverse frequency transform to produce a reconstructed version of the original 8\u00d78 block of samples.","As another example, the example decoder or encoder reconstructs an 8\u00d78 block from a prediction residual for the block. The decoder decodes entropy-coded information representing the prediction residual. The decoder\/encoder inverse quantizes and inverse frequency transforms the data, resulting in a reconstructed residual. In a separate motion compensation path, the decoder\/encoder computes an 8\u00d78 predicted block using motion vector information for displacement from a reference picture. The decoder\/encoder then combines the predicted block with the reconstructed residual to form the reconstructed 8\u00d78 block.","I. Video Codec Standards.","Over the last two decades, various video coding and decoding standards have been adopted, including the H.261, H.262 (MPEG-2) and H.263 series of standards and the MPEG-1 and MPEG-4 series of standards. More recently, the H.264 standard (sometimes referred to as H.264\/AVC) and VC-1 standard have been adopted. For additional details, see representative versions of the respective standards.","Such a standard typically defines options for the syntax of an encoded video bit stream according to the standard, detailing the parameters that must be in the bit stream for a video sequence, picture, block, etc. when particular features are used in encoding and decoding. The standards also define how a decoder conforming to the standard should interpret the bit stream parameters\u2014the bit stream semantics. In many cases, the standards provide details of the decoding operations the decoder should perform to achieve correct results. Often, however, the low-level implementation details of the operations are not specified, or the decoder is able to vary certain implementation details to improve performance, so long as the correct decoding results are still achieved.","During development of a standard, engineers may concurrently generate reference software, sometimes called verification model software or JM software, to demonstrate rate-distortion performance advantages of the various features of the standard. Typical reference software provides a \u201cproof of concept\u201d implementation that is not algorithmically optimized or optimized for a particular hardware platform. Moreover, typical reference software does not address multithreading implementation decisions, instead assuming a single threaded implementation for the sake of simplicity.","II. Acceleration of Video Decoding and Encoding.","While some video decoding and encoding operations are relatively simple, others are computationally complex. For example, inverse frequency transforms, fractional sample interpolation operations for motion compensation, in-loop deblock filtering, post-processing filtering, color conversion, and video re-sizing can require extensive computation. This computational complexity can be problematic in various scenarios, such as decoding of high-quality, high-bit rate video (e.g., compressed high-definition video). In particular, decoding tasks according to more recent standards such as H.264 and VC-1 can be computationally intensive and consume significant memory resources.","Some decoders use video acceleration to offload selected computationally intensive operations to a graphics processor. For example, in some configurations, a computer system includes a primary central processing unit (\u201cCPU\u201d) as well as a graphics processing unit (\u201cGPU\u201d) or other hardware specially adapted for graphics processing. A decoder uses the primary CPU as a host to control overall decoding and uses the GPU to perform simple operations that collectively require extensive computation, accomplishing video acceleration.","In a typical software architecture for video acceleration during video decoding, a video decoder controls overall decoding and performs some decoding operations using a host CPU. The decoder signals control information (e.g., picture parameters, macroblock parameters) and other information to a device driver for a video accelerator (e.g., with GPU) across an acceleration interface.","The acceleration interface is exposed to the decoder as an application programming interface (\u201cAPI\u201d). The device driver associated with the video accelerator is exposed through a device driver interface (\u201cDDI\u201d). In an example interaction, the decoder fills a buffer with instructions and information then calls a method of an interface to alert the device driver through the operating system. The buffered instructions and information, opaque to the operating system, are passed to the device driver by reference, and video information is transferred to GPU memory if appropriate. While a particular implementation of the API and DDI may be tailored to a particular operating system or platform, in some cases, the API and\/or DDI can be implemented for multiple different operating systems or platforms.","In some cases, the data structures and protocol used to parameterize acceleration information are conceptually separate from the mechanisms used to convey the information. In order to impose consistency in the format, organization and timing of the information passed between the decoder and device driver, an interface specification can define a protocol for instructions and information for decoding according to a particular video decoding standard or product. The decoder follows specified conventions when putting instructions and information in a buffer. The device driver retrieves the buffered instructions and information according to the specified conventions and performs decoding appropriate to the standard or product. An interface specification for a specific standard or product is adapted to the particular bit stream syntax and semantics of the standard\/product.","Given the critical importance of video compression and decompression to digital video, it is not surprising that compression and decompression are richly developed fields. Whatever the benefits of previous techniques and tools, however, they do not have the advantages of the following techniques and tools.","In summary, techniques and tools are described for various aspects of video decoder implementations. These techniques and tools help, for example, to increase decoding speed to facilitate real time decoding, reduce computational complexity, and\/or reduce memory utilization (e.g., for use in scenarios such as those with processing power constraints and\/or delay constraints).","According to one aspect of the techniques and tools described herein, a decoder receives encoded video information in a bitstream and during decoding identifies a temporal direct prediction mode macroblock, where the temporal direct prediction mode macroblock is associated with a reference picture list, and where reference pictures of the reference picture list are identified using local picture identifiers. The decoder then identifies a co-located macroblock of the temporal direct prediction mode macroblock, where the co-located macroblock uses one or more reference pictures. Next, the decoder identifies one or more reference pictures in the reference picture list that match the one or more reference pictures used by the co-located macroblock, where the identifying the one or more reference pictures in the reference picture list uses local picture identifiers. Finally, the decoder uses the identified one or more reference pictures in reconstruction of the temporal direct prediction mode macroblock. In a specific implementation, the local picture identifiers are 8-bit local picture identifiers. In other implementations, different length local picture identifiers are used (e.g., 5-bit and 32-bit local picture identifiers).","In a specific implementation, a table is used to identify matching reference pictures. For example, the decoder creates a table that stores reference picture list index values for reference pictures in the reference picture list, where the stored reference picture list index values are indexed in the table by their respective local picture identifiers. The decoder performs the identification by looking up local picture identifiers of the one or more reference pictures used by the co-located macroblock in the table and retrieving corresponding reference picture list index values, where the retrieved reference picture list index values identify the one or more reference pictures in the reference picture list of the temporal direct prediction mode macroblock that match the one or more reference pictures used by the co-located macroblock.","According to another aspect of the techniques and tools described herein, a decoder receives encoded video information in a bitstream and during decoding performs loop filtering on a macroblock. For example, the loop filtering comprises calculating boundary strength values for plural blocks, where the calculating comprises determining whether reference pictures used by the plural blocks are the same by comparing local picture identifiers of the reference pictures. In a specific implementation, the local picture identifiers are 8-bit local picture identifiers. In other implementations, different length local picture identifiers are used (e.g., 5-bit and 32-bit local picture identifiers).","According to yet another aspect of the techniques and tools described herein, a decoder receives encoded video information in a bitstream and during decoding determines a picture type of a picture and based on the picture type selectively skips or simplifies computation of co-located information for use in reconstructing direct prediction mode macroblocks (e.g., temporal or spatial direct prediction mode macroblocks) outside the picture.","The various techniques and tools can be used in combination or independently. Additional features and advantages will be made more apparent from the following detailed description of different embodiments, which proceeds with reference to the accompanying figures.","The present application relates to innovations in implementations of video decoders. Many of these innovations reduce decoding complexity and\/or increase decoding speed to improve decoding performance. These innovations include the use of local picture identifiers (IDs). Local picture identifiers can be used during computation of co-located information and during deblock filtering. For example, an 8-bit local picture ID can be used in place of a global 64-bit picture ID. These innovations also include improvements in computation of co-located information. For example, a picture type can be used during computation of co-located information to improve computation efficiency (e.g., speed and memory utilization) during video decoding.","The innovations described herein can be implemented by single-threaded or multi-threaded decoders. In some implementations, a multi-threaded decoder uses decoder modules that facilitate multi-threaded decoding. For example, in some implementations a PED module is used. The PED module finds a complete picture from the bit stream and initializes the parameters and data structures that will be used for decoding the picture. The PED module populates some of the initialized parameters and structures with parameters parsed from the bit stream. The PED module also enters the initialized (but as yet un-decoded) picture into a live DPB, which facilitates multithreaded decoding. For additional detail, see U.S. Patent Application Publication No. 2009-0003446-A1, entitled \u201cCOMPUTING COLLOCATED MACROBLOCK INFORMATION FOR DIRECT MODE MACROBLOCKS,\u201d the disclosure of which is hereby incorporated by reference.","Collectively, these improvements are at times loosely referred to as \u201coptimizations.\u201d As used conventionally and as used herein, the term \u201coptimization\u201d means an improvement that is deemed to provide a good balance of performance in a particular scenario or platform, considering computational complexity, memory use, processing speed, and\/or other factors. Use of the term \u201coptimization\u201d does not foreclose the possibility of further improvements, nor does it foreclose the possibility of adaptations for other scenarios or platforms.","With these innovations, efficient decoder implementations have been provided for diverse platforms. The implementations include media players for gaming consoles with complex, special-purpose hardware and graphics capabilities, personal computers, and set-top boxes\/digital video receivers.","Various alternatives to the implementations described herein are possible. For example, certain techniques described with reference to flowchart diagrams can be altered by changing the ordering of stages shown in the flowcharts, by repeating or omitting certain stages, etc., while achieving the same result. As another example, although some implementations are described with reference to specific macroblock formats, other formats also can be used. As another example, while several of the innovations described below are presented in terms of H.264\/AVC decoding examples, the innovations are also applicable to other types of decoders (e.g., MPEG-2, VC-1) that provide or support the same or similar decoding features.","The various techniques and tools described herein can be used in combination or independently. For example, although flowcharts in the figures typically illustrate techniques in isolation from other aspects of decoding, the illustrated techniques in the figures can typically be used in combination with other techniques (e.g., shown in other figures). Different embodiments implement one or more of the described techniques and tools. Some of the techniques and tools described herein address one or more of the problems noted in the Background. Typically, a given technique\/tool does not solve all such problems, however. Rather, in view of constraints and tradeoffs in decoding time and\/or resources, the given technique\/tool improves performance for a particular implementation or scenario.","I. Computing Environment",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 1","b":["100","100"]},"With reference to , the computing environment () includes at least one CPU () and associated memory () as well as at least one GPU or other co-processing unit () and associated memory () used for video acceleration. In , this most basic configuration () is included within a dashed line. The processing unit () executes computer-executable instructions and may be a real or a virtual processor. In a multi-processing system, multiple processing units execute computer-executable instructions to increase processing power. A host encoder or decoder process offloads certain computationally intensive operations (e.g., fractional sample interpolation for motion compensation, in-loop deblock filtering) to the GPU (). The memory (, ) may be volatile memory (e.g., registers, cache, RAM), non-volatile memory (e.g., ROM, EEPROM, flash memory, etc.), or some combination of the two. The memory (, ) stores software () for a decoder implementing one or more of the decoder innovations described herein.","A computing environment may have additional features. For example, the computing environment () includes storage (), one or more input devices (), one or more output devices (), and one or more communication connections (). An interconnection mechanism (not shown) such as a bus, controller, or network interconnects the components of the computing environment (). Typically, operating system software (not shown) provides an operating environment for other software executing in the computing environment (), and coordinates activities of the components of the computing environment ().","The computer-readable storage medium () may be removable or non-removable, and includes magnetic disks, magnetic tapes or cassettes, CD-ROMs, DVDs, or any other tangible medium which can be used to store information and which can be accessed within the computing environment (). The computer-readable storage medium () may also include the memory () and () (e.g., RAM, ROM, flash memory, etc.). The storage () stores instructions for the software (). The computer-readable storage medium () does not include the communication medium () described below (e.g., signals).","The input device(s) () may be a touch input device such as a keyboard, mouse, pen, or trackball, a voice input device, a scanning device, or another device that provides input to the computing environment (). For audio or video encoding, the input device(s) () may be a sound card, video card, TV tuner card, or similar device that accepts audio or video input in analog or digital form, or a CD-ROM or CD-RW that reads audio or video samples into the computing environment (). The output device(s) () may be a display, printer, speaker, CD-writer, or another device that provides output from the computing environment ().","The communication connection(s) () enable communication over a communication medium to another computing entity. The communication medium conveys information such as computer-executable instructions, audio or video input or output, or other data in a modulated data signal. A modulated data signal is a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media include wired or wireless techniques implemented with an electrical, optical, RF, infrared, acoustic, or other carrier.","The techniques and tools can be described in the general context of computer-executable instructions, such as those included in program modules, being executed in a computing environment on a target real or virtual processor. Generally, program modules include routines, programs, libraries, objects, classes, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or split between program modules as desired in various embodiments. Computer-executable instructions for program modules may be executed within a local or distributed computing environment.","For the sake of presentation, the detailed description uses terms like \u201cdecide,\u201d \u201cmake\u201d and \u201cget\u201d to describe computer operations in a computing environment. These terms are high-level abstractions for operations performed by a computer, and should not be confused with acts performed by a human being. The actual computer operations corresponding to these terms vary depending on implementation.","II. Example Organization of Video Frames","For progressive video, lines of a video frame contain samples starting from one time instant and continuing through successive lines to the bottom of the frame. An interlaced video frame consists of two scans\u2014one for the even lines of the frame (the top field) and the other for the odd lines of the frame (the bottom field).","A progressive video frame can be divided into 16\u00d716 macroblocks. For 4:2:0 format, a 16\u00d716 macroblock includes four 8\u00d78 blocks (Y through Y) of luma (or brightness) samples and two 8\u00d78 blocks (Cb, Cr) of chroma (or color component) samples, which are collocated with the four luma blocks but half resolution horizontally and vertically.","An interlaced video frame includes alternating lines of the top field and bottom field. The two fields may represent two different time periods or they may be from the same time period. When the two fields of a frame represent different time periods, this can create jagged tooth-like features in regions of the frame where motion is present.","Therefore, interlaced video frames can be rearranged according to a field structure, with the odd lines grouped together in one field, and the even lines grouped together in another field. This arrangement, known as field coding, is useful in high-motion pictures. For an interlaced video frame organized for encoding\/decoding as separate fields, each of the two fields of the interlaced video frame is partitioned into macroblocks. The top field is partitioned into macroblocks, and the bottom field is partitioned into macroblocks. In the luma plane, a 16\u00d716 macroblock of the top field includes 16 lines from the top field, and a 16\u00d716 macroblock of the bottom field includes 16 lines from the bottom field, and each line is 16 samples long.","On the other hand, in stationary regions, image detail in the interlaced video frame may be more efficiently preserved without rearrangement into separate fields. Accordingly, frame coding (at times referred to coding with MBAFF pictures) is often used in stationary or low-motion interlaced video frames. An interlaced video frame organized for encoding\/decoding as a frame is also partitioned into macroblocks. In the luma plane, each macroblock includes 8 lines from the top field alternating with 8 lines from the bottom field for 16 lines total, and each line is 16 samples long. Within a given macroblock, the top-field information and bottom-field information may be coded jointly or separately at any of various phases\u2014the macroblock itself may be field-coded or frame-coded.","III. Generalized Video Decoder",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 2","b":"200"},"The relationships shown between modules within the decoder () indicate general flows of information in the decoder; other relationships are not shown for the sake of simplicity. In particular, while a decoder host performs some operations of modules of the decoder (), a video accelerator performs other operations (such as inverse frequency transforms, fractional sample interpolation, motion compensation, in-loop deblocking filtering, color conversion, post-processing filtering and\/or picture re-sizing). For example, the decoder () passes instructions and information to the video accelerator as described in \u201cMicrosoft DirectX VA: Video Acceleration API\/DDI,\u201d version 1.01, a later version of DXVA or another acceleration interface. In general, once the video accelerator reconstructs video information, it maintains some representation of the video information rather than passing information back. For example, after a video accelerator reconstructs an output picture, the accelerator stores it in a picture store, such as one in memory associated with a GPU, for use as a reference picture. The accelerator then performs in-loop deblock filtering and fractional sample interpolation on the picture in the picture store.","In some implementations, different video acceleration profiles result in different operations being offloaded to a video accelerator. For example, one profile may only offload out-of-loop, post-decoding operations, while another profile offloads in-loop filtering, fractional sample interpolation and motion compensation as well as the post-decoding operations. Still another profile can further offload frequency transform operations. In still other cases, different profiles each include operations not in any other profile.","Returning to , the decoder () processes video pictures, which may be video frames, video fields or combinations of frames and fields. The bit stream syntax and semantics at the picture and macroblock levels may depend on whether frames or fields are used. The decoder () is block-based and uses a 4:2:0 macroblock format for frames. For fields, the same or a different macroblock organization and format may be used. 8\u00d78 blocks may be further sub-divided at different stages. Alternatively, the decoder () uses a different macroblock or block format, or performs operations on sets of samples of different size or configuration.","The decoder () receives information () for a compressed sequence of video pictures and produces output including a reconstructed picture () (e.g., progressive video frame, interlaced video frame, or field of an interlaced video frame). The decoder system () decompresses predicted pictures and key pictures. For the sake of presentation,  shows a path for key pictures through the decoder system () and a path for predicted pictures. Many of the components of the decoder system () are used for decompressing both key pictures and predicted pictures. The exact operations performed by those components can vary depending on the type of information being decompressed.","A demultiplexer () receives the information () for the compressed video sequence and makes the received information available to the entropy decoder (). The entropy decoder () entropy decodes entropy-coded quantized data as well as entropy-coded side information, typically applying the inverse of entropy encoding performed in the encoder. A motion compensator () applies motion information () to one or more reference pictures () to form motion-compensated predictions () of sub-blocks, blocks and\/or macroblocks of the picture () being reconstructed. One or more picture stores store previously reconstructed pictures for use as reference pictures.","The decoder () also reconstructs prediction residuals. An inverse quantizer () inverse quantizes entropy-decoded data. An inverse frequency transformer () converts the quantized, frequency domain data into spatial domain video information. For example, the inverse frequency transformer () applies an inverse block transform to sub-blocks and\/or blocks of the frequency transform coefficients, producing sample data or prediction residual data for key pictures or predicted pictures, respectively. The inverse frequency transformer () may apply an 8\u00d78, 8\u00d74, 4\u00d78, 4\u00d74, or other size inverse frequency transform.","For a predicted picture, the decoder () combines reconstructed prediction residuals () with motion compensated predictions () to form the reconstructed picture (). A motion compensation loop in the video decoder () includes an adaptive deblocking filter (). The decoder () applies in-loop filtering () to the reconstructed picture to adaptively smooth discontinuities across block\/sub-block boundary rows and\/or columns in the picture. The decoder stores the reconstructed picture in a picture buffer () for use as a possible reference picture.","Depending on implementation and the type of compression desired, modules of the decoder can be added, omitted, split into multiple modules, combined with other modules, and\/or replaced with like modules. In alternative embodiments, encoders or decoders with different modules and\/or other configurations of modules perform one or more of the described techniques. Specific embodiments of video decoders typically use a variation or supplemented version of the generalized decoder ().","For the sake of presentation, the following table provides example explanations for acronyms and selected shorthand terms used herein.",{"@attributes":{"id":"p-0060","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Term","Explanation"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["block","arrangement (in general, having any size) of sample values"]},{"entry":[{},"for pixel data or residual data, for example, including"]},{"entry":[{},"the possible blocks in H.264\/AVC - 4 \u00d7 4, 4 \u00d7 8, 8 \u00d7 4, 8 \u00d7 8,"]},{"entry":[{},"8 \u00d7 16, 16 \u00d7 8, and 16 \u00d7 16"]},{"entry":["CABAC","context adaptive binary arithmetic coding"]},{"entry":["CAVLC","context adaptive variable length coding"]},{"entry":["DPB","decoded picture buffer"]},{"entry":["ED","entropy decoding"]},{"entry":["FIFO","first in first out"]},{"entry":["INTRA","spatial intra-prediction"]},{"entry":["LF","loop filtering"]},{"entry":["MB","megabyte OR macroblock, depending on context; a"]},{"entry":[{},"macroblock is, e.g., 16 \u00d7 16 arrangement of sample"]},{"entry":[{},"values for luma with associated arrangements of"]},{"entry":[{},"sample values for chroma"]},{"entry":["MBAFF","macroblock adaptive frame field"]},{"entry":["MC","motion compensation"]},{"entry":["MMCO","memory management control operation"]},{"entry":["NALU","network abstraction layer unit"]},{"entry":["PED","picture extent discovery"]},{"entry":["PICAFF","picture adaptive frame field"]},{"entry":["PPS","picture parameter set"]},{"entry":["PROG","progressive"]},{"entry":["SEI","supplemental enhancement information"]},{"entry":["SIMD","single instruction multiple data"]},{"entry":["SPS","sequence parameter set"]},{"entry":["stage (of","a set of different passes\/steps to decode a picture, such as"]},{"entry":["decoding)","PED, ED, MC and so on"]},{"entry":["sub-block","a partition of a sub-MB, e.g., 8 \u00d7 4, 4 \u00d7 8 or 4 \u00d7 4"]},{"entry":[{},"block or other size block"]},{"entry":["sub-MB","a partition of an MB, e.g., 16 \u00d7 8, 8 \u00d7 16 or 8 \u00d7 8 block"]},{"entry":[{},"or other size block; in some contexts, the term sub-MB also"]},{"entry":[{},"indicates sub-blocks"]},{"entry":["task","a stage plus input data"]},{"entry":["wave","a set of portions of a picture (e.g., a diagonal set of"]},{"entry":[{},"macroblocks in the picture) such that each portion within one"]},{"entry":[{},"wave can be processed in parallel, without dependencies on"]},{"entry":[{},"the other portions within the same wave; a picture can then be"]},{"entry":[{},"processed as a sequence of waves where each wave is"]},{"entry":[{},"dependent on the data resulting from processing the"]},{"entry":[{},"preceding waves"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"In some embodiments, a decoder uses one or more local picture identifier (ID) innovations when decoding video. Collectively, the local picture ID innovations improve computation efficiency (e.g., speed and memory utilization) during video decoding.","A. Overall Local Picture Identifier Framework","In order to identify a picture in a bitstream, the picture's picture identifier (ID) needs to be known. Initially the picture ID is ((POC<<1)+structure) of the picture, where POC is Picture Order Count, and where structure could be frame, top field, or bottom field. Since POC is a 32-bit variable, generally 33 bits are needed. In a typical computing system, the result is a 64-bit picture ID to identify a picture. In an H.264\/AVC decoder, there are two places where a determination must be made whether two pictures are the same or not. One is in the computation of co-located pictures for obtaining motion vector information of direct MBs in a B slice, and the other is in the strength computation of loop filtering.","Using a local picture ID (e.g., an 8-bit or 5-bit local picture ID), which can also be called a reduced-bit picture ID, in place of a global 64-bit picture ID provides various performance advantages. For example, 8-bit local picture IDs use \u215bthe memory of 64-bit picture IDs. In addition, local picture IDs improve computation efficiency (e.g., using 8-bit comparisons instead of 64-bit comparisons). Use of a local picture ID can also provide efficiency improvements. For example, the x86 architecture handles 64-bit comparisons using two instructions. Reduction of 64-bit to 8 bit data structures allows x86 comparisons to execute in one instruction. In addition, less memory is used. The reduction in bits used to represent the picture ID affects ref_pic_num and co-located remapping data structures. In a specific test scenario, an H.264\/AVC decoder using 8-bit local picture IDs showed 4 to 7 MB memory savings using a multi -threading implementation.","B. Usage of Picture ID","In an H.264\/AVC decoder, there are two places where a determination needs to be made whether two pictures are the same or not. The first place is with the computation of co-located information for direct macroblocks (MBs). In H.264\/AVC, when direct_spatial_mv_pred_flag is 0 (temporal mode is used for direct macroblock), motion vector (MV) and reference picture information needs to be retrieved from the co-located MBs. Specifically, the reference pictures used by the co-located MB of the co-located picture needs to be found in reference list  of the current slice. Therefore, the picture IDs of the reference pictures used by the co-located MB needs to be compared with those in the reference list  of the current slice.","The second place in an H.264\/AVC decoder where a determination needs to be made whether two pictures are the same or not is in the loop filter. In the loop filter, when computing the strength for deblocking, a comparison needs to be made to determine whether two inter blocks are using the same reference pictures or not. In this case, all the pictures used for reference in a picture come from the same Decoded Picture Buffer (DPB), and a DPB can only contain, at most, 16\u00d73 different pictures. If all the pictures in the DPB have different local picture IDs, a determination can be made whether two pictures are the same or not.","C. 8-Bit Local Picture ID","In a specific implementation, an 8-bit local picture ID is used in place of the global 64-bit picture ID. An 8-bit picture ID provides a sufficient number of picture identifiers to perform H.264\/AVC decoding even with the use of large-scale multi-threaded decoding.","Generally, there will be less than 32 pictures (frame, top field, or bottom field picture) in flight at the same time, i.e., less than 32 pPicHolders, even with large scale multi -threading. Assume each of the 32 pictures is a frame picture, and will be split into two fields. The 32 pictures in flight will use 96 (32\u00d73) StorablePicture structures. According to the H.264\/AVC specification, the maximum DPB size is 16. Therefore, DPB will use 48 (16\u00d73) StorablePicture structures at most.","In addition, if two pictures' frame_num have a gap, a function will be called to fill in the frame_num gap. The maximum number of StorablePicture structures used to fill frame_num gap is 48 (16\u00d73). Because a mechanism is used to release those pictures used for fill frame_num gap right after they are bumped out from DPB, in total only 96 (16\u00d73\u00d72) StorablePicture structures are needed, assuming the worst case that the pictures used for fill_frame_num_gap is bumped out by the pictures used for fill_frame_num_gap again.","Overall, there are a maximum of 240 (96+48+96) StorablePicture structures in flight during the lifetime of an H.264\/AVC decoder. When a StorablePicture structure is allocated, a unique 8-bit picture ID can be assigned to it. An 8-bit local picture ID provides 255 unique values, and is thus able to accommodate the maximum of 240 StorablePicture structures. The 8-bit picture ID will be attached to the StorablePicture structure and remain the same during the lifetime of the H.264\/AVC decoder.","This specific implementation of a local 8-bit picture ID assumes there will be up to 32 pictures (frame, top field, or bottom field picture) in flight at the same time. However, a local 8-bit picture ID can support up to 37 pictures in flight at the same time. If more than 37 pictures in flight are required, the local picture ID can be extended beyond 8-bits (e.g., a 16-bit local picture ID can be used).","With the loop filter, because the StorablePicture structures come from the same DPB, different StorablePicture structures in the DPB will have different 8-bit picture IDs. Determining whether two references pictures are the same or not can be done easily with the 8-bit picture ID.","In the computation of co-located information, an 8-bit local picture ID is sufficient to decode content conforming to the H.264\/AVC specification. The fact that an 8-bit local picture ID can be used to decode conforming content may not be initially obvious when considering the process that finds the corresponding picture in reference list  of the current slice for the reference picture used by the co-located MB of the co-located picture. However, it can be proven that this process operates correctly using an 8-bit local picture ID.","Assume there is one slice per picture, without loss of generality. Current picture A is using some pictures as reference in list  and list . Co-located picture B is using some other pictures as reference in list  and list . The corresponding pictures in list  of current picture A need to be found for the reference pictures used by picture B. In decoding order, co-located picture B is decoded first, some pictures in the middle, and then current picture A. During the decoding process from picture B to picture A, some pictures used as reference by co-located picture B may be bumped out from the DPB, get deleted with a picture ID x, POC y, and structure z and reused again with a picture ID x, POC m, and structure n, since the 8-bit local picture ID will keep the same throughout the lifetime of the H.264\/AVC decoder. In this case the two StorablePicture structures have the same 8-bit local picture ID, even though they are actually different pictures. If the StorablePicture structure with a picture ID x, POC y, and structure z is in the reference lists of co-located picture B, and the StorablePicture structure with an picture ID x, POC m, and structure n is in the reference lists of current picture A, they will be treated as the same picture, because now they have the same picture ID x. If this situation ever occurs, it may cause corruption of the decoded content. However, this situation will never occur for conforming content.","According to Section 8.4.1.2.3 of the H.264\/AVC specification, when a picture in list  or list  of the co-located picture is used as reference picture by a co-located MB, the same picture shall be in the list  of current picture. That means in the decoding process from co-located picture B to current picture A, the picture cannot get bumped out from DPB and deleted. It also means that when a picture is used as a reference picture by a co-located MB, the picture found in list  of the current picture must be the correct match. When a direct MB is decoded in current picture A, the location in list  (of current picture A) of the picture used as a reference by the co-located MB is needed. If those reference indices\/positions are correct, the direct MB can be decoded correctly. As for those pictures that get bumped out from DPB, deleted, and reused during the decoding process from co-located picture B to current picture A, they will never be used as reference pictures by co-located MB, and therefore it is irrelevant whether the matching for them is correct or not.","D. 5-Bit Local Picture ID","In another specific implementation, a 5-bit local picture ID is used in place of the 64-bit picture ID. A 5-bit local picture ID can be used, for example, with a single-threaded decoder (e.g., either in a DXVA implementation or a software implementation).","E. Alternative Local Picture ID Implementations","Depending on implementation details, a 5-bit or 8-bit local picture ID may not be the most efficient choice. For example, with the XBox 360 architecture, 32-bit operations are more efficient than 8-bit operations. Therefore, with the XBox 360, a 32-bit local picture ID can be used (in place of a 64-bit picture ID). Such a 32-bit local picture ID only needs to include 8-bits of relevant information (e.g., the upper three bytes of the 32-bit local picture ID are not used).","F. Choice of Invalid Picture ID","The JM reference code sets the invalid picture ID to 0x8000000000000000. In boundary strength computation of the loop filter, a comparison of picture ID with branch is involved. For the 8-bit local picture ID design, the invalid picture ID value is set to 255. This allows the local picture ID to be compared with shifting and logical operations, and in turn speeds up the computation process.","The JM reference code reads as follows:",{"@attributes":{"id":"p-0085","num":"0084"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if ( refidx>=0)"]},{"entry":[{},"\u2003\u2003q0 = ref_pic_num[slice_id][list][refidx)"]},{"entry":[{},"else"]},{"entry":[{},"\u2003\u2003q0 = 0x8000000000000000;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"When modified to support the 8-bit local picture ID, the code reads as follows: (((refidx)>>(sizeof(RefPicNumType)*8\u22121))|(ref_pic_num[slice_id][list][refidx))) Where sizeof(RefPicNumType) is 1.","Depending on the number of bits used for the local picture ID (e.g., 5-bit, 16-bit, 32-bit), a similar invalid picture ID can be used. For example, for a 32-bit local picture ID, 0xffffffff can be used.","G. Table Based Remapping for Co-Located Computation","A reference index (ref_idx in H.264) in a slice is an index to a picture in a reference picture list of the slice. In different slices, reference indices with the same value (e.g., 3) may refer to different pictures because the reference picture lists for the different slices can be different. When the decoder retrieves collocated macroblock information for a direct mode macroblock in a B slice, the decoder determines which picture (if any) in the B slice's reference picture list corresponds to the reference picture used for reference by the collocated macroblock that provides the collocated macroblock information.","In co-located computation, the reference pictures used by co-located MBs in co-located pictures need to be mapped to those in list  of the current slice. In a specific implementation, a table is used in the remapping procedure as follows.","First all the pictures that are not in list  of current slice are initialized.","memset(rgPicIDRefldxMap, \u22121, sizeof(char)*256);","Next, the index of the existing reference picture in list  of the current slice is stored in the table. Note that duplicate reference pictures are skipped in list  of the current slice because the reference picture used by the co-located MB in the co-located picture is mapped to the first matching picture in list  of the current slice.",{"@attributes":{"id":"p-0094","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"for (i=0;i<pSliceHolder->listXsize[LIST_0];i++)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003RefPicNumType StorablePicID ="]},{"entry":[{},"\u2003\u2003\u2003\u2003pSliceHolder->listX[LIST_0][i]->StorablePicID;"]},{"entry":[{},"\u2003\u2003H264_ASSERT(StorablePicID<INVALID_REF_PIC_NUM);"]},{"entry":[{},"\u2003\u2003if (\u22121==rgPicIDRefIdxMap[StorablePicID])"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003rgPicIDRefIdxMap[StorablePicID]= (char)i;"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Using the remapping process, the index in list  of the current slice can be retrieved for the reference picture used by the co-located MB directly with the index table above. The remapping process can improve computation efficiency up to 16 or 32 times.","H. Example Local Picture ID Implementation",{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 3","b":["300","310"]},"At , a co-located macroblock of the temporal direct prediction mode macroblock is identified. The co-located macroblock uses one or more reference pictures.","At , one or more reference pictures are identified in the reference picture list that match the one or more reference pictures used by the co-located macroblock, where the identifying the one or more reference pictures in the reference picture list uses local picture identifiers.","At , the temporal direct prediction mode macroblock is reconstructed using the identified reference pictures.","In the example method , the local picture IDs can be, for example, 5-bit local picture IDs, 8-bit local picture IDs, or 32-bit local picture IDs.","In some implementations, a table can be used to identify matching reference pictures (). For example, a table can be created, where the table stores reference picture list index values for reference pictures in the reference picture list, and where the stored reference picture list index values are indexed in the table by their respective local picture identifiers. Once the table has been created, it can be used in the identification process, where the identification is performed by looking up local picture identifiers of the one or more reference pictures used by the co-located macroblock in the table and retrieving corresponding reference picture list index values, where the retrieved reference picture list index values identify the one or more reference pictures in the reference picture list of the temporal direct prediction mode macroblock that match the one or more reference pictures used by the co-located macroblock.","I. Hardware Acceleration","The local picture ID framework can be implemented with software decoders and hardware accelerated decoders. For example, the local picture ID framework can be implemented with hardware accelerated decoders that support DirectX Video Acceleration (DXVA).","V. Innovations in Computation of Co-Located Information for a Video Decoder","In some embodiments, a decoder uses one or more innovations related to the computation of co-located information when decoding video. Collectively, the computation of co-located information innovations improve computation efficiency (e.g., speed and memory utilization) during video decoding.","A direct mode macroblock uses information from a corresponding macroblock in a collocated picture when determining which motion vectors to apply in motion compensation. The information from the corresponding macroblock is an example of collocated macroblock information. In many encoding scenarios, more than half of the macroblocks in B slices are direct mode macroblocks, and efficient determination of collocated macroblock information is important to performance.","A. Overall Computation Framework","In an H.264\/AVC encoded video bitstream, B slices can contain many direct MBs. For direct MBs, there is no MV or Refldx information encoded in the bitstream. The MV and Refldx information is derived from co-located MBs and their spatial neighbors.","When spatial mode is used for direct MBs, the MV and Refldx information is obtained from spatial neighbors with median prediction. However, a check needs to be made to determine whether the co-located MB is moving or not. If the co-located MB is not moving, the MV will be reset to 0. Otherwise, the MV and Refldx information from median prediction is used.","When temporal mode is used for direct MBs, the MV and Refldx information is obtained from co-located MBs. The reference picture used by a co-located MB is found in list  of the current slice. This reference picture in list  of the current slice is one of the reference pictures for the direct MB. The co-located picture is the other reference picture for the direct MB.","With the setup of MV and Refldx information for direct MBs, the MV and Refldx information needs to be accessed in the co-located picture, and some computation needs to be performed. Various optimizations can be performed depending on the picture type of the co-located picture.","For example, if the co-located picture type is identified as \u201cI picture,\u201d then its side information, motion vectors, macro-block type and reference index do not need to be checked. Therefore, information retrieval and checking operations can be eliminated. Similarly, if the co-located picture type is identified as \u201cP picture,\u201d then only half of the information and retrieval checking\/computation needs to be performed.","B. Definition of Picture Type","There is no picture type in the H.264\/AVC specification. In a specific implementation, in order to support the improvements in computation of co-located information, a picture type is defined as follows. When a picture is encountered in PED, its picture type is assigned to one of the below types, as follows:","I picture (bIPicture): all the slices in the picture are I slices,","P picture (bPPicture): all the slices in the picture are I or P slices but not all the slices are I slices,","B picture (bBPicture): at least one slice in the picture is B slice.","The type of a picture can only be one of the three types defined above. A picture cannot be assigned more than one type according to the above definition.",{"@attributes":{"id":"p-0119","num":"0118"},"figref":"FIG. 4","b":["400","400","410"]},"At , a check is made to determine whether all the slices in the picture are I slices. If yes, the picture type is set to \u201cI Picture\u201d . If not, the technique proceeds to .","At , a check is made to determine whether all the slices in the picture are I or P slices (with at least one P slice). If yes, the picture type is set to \u201cP Picture\u201d . If not, the technique proceeds to .","At , a check is made to determine if at least one slice in the picture is a B slice. If yes, the picture type is set to \u201cB Picture\u201d . If not, the technique proceeds to . Alternatively, if the determination at  is \u201cno,\u201d then the picture can be automatically set to \u201cB Picture\u201d  because that is the only remaining picture type (i.e., the check at  can be skipped).","At , a check is made to see if there are any remaining pictures. If so, the next picture is assigned a picture type . Otherwise, the technique ends.","C. Computation of Co-Located Information","For 16\u00d716 direct MBs with spatial mode, the following four optimizations regarding computation of co-located information can be performed.","First, when the co-located picture (the co-located picture is the picture containing the co-located macroblock of the direct macroblock to be decoded) is a long term picture, the co-located MB is always treated as \u201cmoving\u201d. Therefore, there is no need to retrieve any information from the co-located picture. The whole direct MB has the same MV and Refldx. It can be recast into a 16\u00d716 MB.","Second, when the co-located picture is an I picture, the co-located MB is always treated as \u201cmoving\u201d. Therefore, there is no need to retrieve any information from the co-located picture. The whole direct MB has the same MV and Refldx. It can be recast into a 16\u00d716 MB.","Third, when the co-located picture is a P picture, only the information from list  of the co-located picture (not from list ) needs to be retrieved because list  does not exist for a P picture. The computation for \u201cmoving\u201d detection has to be done for the information from list . A check needs to be made to determine whether the whole direct MB can be recast into a 16\u00d716 MB.","Fourth, when the co-located picture is a B picture, the information from list  and list  of co-located picture needs to be retrieved. The computation for \u201cmoving\u201d detection has to be done for the information from list  and list . A check needs to be made to determine whether the whole direct MB can be recast into a 16\u00d716 MB.","For 16\u00d716 direct MBs with temporal mode, the following three optimizations regarding computation of co-located information can be performed.","First, when the co-located picture is an I picture, the information coming from the co-located MB is fixed (i.e., all invalid Refldxs). Therefore, there is no need to retrieve any information from the co-located picture. The whole direct MB has the same MV and Refldx (i.e., all 0 MVs and 0 Refldxs). It can be recast into a 16\u00d716 MB.","Second, when the co-located picture is a P picture, only the information from list  of co-located picture needs to be retrieved (not from list ) because list  does not exist for a P picture. A check needs to be made to determine whether the whole direct MB can be recast into a 16\u00d716 MB.","Third, when the co-located picture is a B picture, the information from list  and list 1 of the co-located picture needs to be retrieved. A check needs to be made to determine whether the whole direct MB can be recast into a 16\u00d716 MB.","A direct MB is a 16\u00d716 block. By default it is treated as 16 4\u00d74 blocks or 4 8\u00d78 blocks with different side information, including motion vectors and reference frames. However, if all the 16 4\u00d74 blocks or 4 8\u00d78 blocks have the same side information, then the block partition (16 4\u00d74 blocks or 4 8\u00d78 blocks) does not matter, and the direct MB can be treated as one 16\u00d716 block. Performing motion compensation and deblocking operations on a whole 16\u00d716 block is more efficient, in typical scenarios, than performing such operations on 16 4\u00d74 blocks or 4 8\u00d78 blocks.",{"@attributes":{"id":"p-0135","num":"0134"},"figref":"FIG. 5","b":["500","510"]},"At , a picture type is determined for a picture based on slice type of one or more slices in the picture. In a specific implementation, the picture is assigned a picture type according to the flowchart depicted in , and as described in Section V(B) above. The picture can be called a \u201cco-located picture\u201d because it may contain a co-located macroblock of a direct prediction macroblock to be decoded.","At , based on the picture type of the picture, the decoder selectively skips or simplifies computation of co-located information for use in reconstruction of one or more direct prediction mode macroblocks outside the picture.","A direct prediction mode macroblock is identified. The direct prediction mode macroblock can be a temporal direct prediction mode macroblock or a spatial direct prediction mode macroblock. In a specific implementation, the skipping and simplifications described in Section V(C) above are performed.","Depending on the content and encoding parameters used, the above optimizations can save significant resources during computation of co-located information. For example, experimental results using HD-DVD clips result in a large number of direct MB's in B slices (approximately 50% of the MBs are direct MBs in some situations). In addition, B pictures are not used for reference in HD-DVD clips. With such HD-DVD clips, the above optimizations can reduce the computation of co-location information by approximately half","In view of the many possible embodiments to which the principles of the disclosed invention may be applied, it should be recognized that the illustrated embodiments are only preferred examples of the invention and should not be taken as limiting the scope of the invention. Rather, the scope of the invention is defined by the following claims. We therefore claim as our invention all that comes within the scope and spirit of these claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
