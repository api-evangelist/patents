---
title: Random access data compression
abstract: Methods, program products, and systems implementing random access data compression are disclosed. Data can be stored in a data structure in compressed or non-compressed form. The data structure can include a header block, one or more data blocks, and one or more index blocks. Each data block can include data compressed using different compression technology. The header block can include searchable references to the data blocks, which can be located in the data structure after the header block. The searchable references permit non-sequential access to the data blocks. The data blocks can be organized independent of a file system structure. The header block can additionally include references to the one or more index blocks, which can expand the references in the header block.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08433823&OS=08433823&RS=08433823
owner: TIBCO Software Inc.
number: 08433823
owner_city: Delaware
owner_country: US
publication_date: 20110902
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Exemplary File Format","Exemplary Storage Container","Exemplary Block Accessor","Exemplary Storage Unit","Exemplary Storage Blocks","Exemplary Processes Implementing Random Access Data Compression","Exemplary System Architecture"],"p":["This application claims the benefit under 35 U.S.C. \u00a7119(e) of U.S. Patent Application No. 61\/380,164, filed Sep. 3, 2010, entitled \u201cRandom Access Data Compression,\u201d which is incorporated by reference herein in its entirety.","This disclosure relates generally to data management.","Data compression is a process of encoding information that can be represented using fewer bits than an uncompressed representation of the information. Conventional encoding schemes can specify how the information is compressed. Conventional encoding schemes can use adaptive models and generate variable-bit-length codes that are decoded sequentially from beginning to end. To access data within the compressed representation, a user can decompress the compressed representation up to the location of that data. When the compressed representation is a large file, the decompression can include reading gigabytes (GBs) of data.","For an uncompressed file, the user can directly access any offset of data in the file in substantially equal time, skipping past information that the user does not need. When storing data, the user can decide whether or not to compress the data. Storing the data compressed reduces the amount of storage space needed to store the data and increases access time due to the need to decompress. Storing the data uncompressed uses more storage space than compressed data, and allows random, and thus speedier access of information.","Methods, program products, and systems implementing random access data compression are disclosed. Data can be stored in a data structure in compressed or non-compressed form. The data structure can include a header block, one or more data blocks, and one or more index blocks. Each data block can include data compressed using different compression technology. The header block can include searchable references to the data blocks, which can be located in the data structure after the header block. The searchable references permit non-sequential access to the data blocks. The data blocks can be organized independent of a file system structure. The header block can additionally include references to the one or more index blocks, which can expand the references in the header block.","These and other implementations can be utilized to achieve one or more of the following advantages. Random access data compression can allow dynamic compression. The data to be compressed can include log data of various log sources (e.g., devices, operating systems, or applications). The log data can be received continuously. The log data can be compressed as they arrive. The compressed log data can be accessed out of sequence. The access only uses a minimum number of seeks, often no more than one per random access. Reading unwanted data can be minimized or avoided.","Random access data compression permits hardware flexibility. A wide variety of storage systems including external arrays, solid-state drives (SSDs), and distributed storage can be supported concurrently. Random access data compression allows easy data migration. A storage device can become full, causing data to be purged or moved to alternative storage devices. To facilitate the purge and move, random access data compression can provide effective mechanisms for recovering space occupied by expired data.","Random access data compression can support various data purging policies. A user may desire or be required to purge data after a certain time. The length of time can vary by type of data. Random access data compression can provide features to classify the data in such a way that erasing, selective recycling or obfuscating is economical.","Random access data compression can be resilient to unplanned shutdown. Loss of data previously committed to a non-volatile storage device (e.g., a disk) can be minimized or avoided except for failure of the non-volatile storage device. Loss of referential integrity and metadata, including grouping of data as intended by a user, can be likewise minimized or avoided.","The details of one or more implementations of random access data compression techniques are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of random access data compression will become apparent from the description, the drawings, and the claims.","Like reference symbols in the various drawings indicate like elements.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1","b":["100","100","100","100"]},"Data structure  can include header block , which can be stored at the beginning of the data structure  when serialized, or at an entry point of data structure  if data structure  is not serialized. Data structure  can include data blocks , , and . Each of data blocks , , and  can be stored after header block  in serialized data structure . Each of data blocks , , and , can store compressed data. Each of data blocks , , and  can store data compressed using a compression format that is different from another data block.","Header block  can include references , , and  that refer to data blocks , , and , respectively. A reference to a data block can designate a unique point in data structure . The designation can have a byte granularity. The reference can be stored in header block  and associated with information that can identify the data block referenced. The information can include a data offset.","Header block , as well as each of data blocks , , and , can have a configurable block size. The size can be stored in header block . Compressed data can require multiple data blocks when the size of the compressed data is large compared to the size of a data block. The quantity of references to the data blocks, accordingly, can be larger than can be stored in header block . Header block  can store reference  to index block . Index block  can act as an extension of header block . For example, index block  includes reference  to data block . Index block  can include one or more references to other index blocks, forming a tree. In some implementations, reference  to index block  can be a last reference stored in header block .","Data structure  can allow random access to compressed or uncompressed data. In some implementations, the data to be compressed can include log data that, in turn, includes one or more data messages, each data message having an offset to the beginning of the log data or to a marker. If a particular data message is to be accessed, reader  can access header block . Using offset information of the particular data message, reader  can identify a data block (e.g., data block ) where the particular data message is stored in compressed format. Reader  can follow the reference to the identified block and access the data message without having to read and decompress data blocks (e.g., data blocks , , and ) stored before the identified data block.","Compressed data can be stored in storage containers as storage units. The storage containers can include one or more file system directories, or one or more virtual blocks, or both. Storage units can include the various blocks and indices organized using data structure  of . Storage units and storage containers can be associated together by one or more block accessors. Further details on the block containers, block accessors, and storage units will be described below.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2A","b":["200","200","201","201","201","201","201"]},"System  can include one or more storage units . Storage units  can be storage in storage container , along with information for managing and utilizing more storage units . Storage units  stored in storage container  can be identified by their pathnames. Other files can be ignored.","If storage container  is a block device, the list can be stored as a contiguous sequence of blocks. Storage units  can be identified and traversed using offsets from a first block (e.g., a header block). Other types of storage containers are possible.","A directory structure of storage container  can include a single-level hierarchy or a multi-level hierarchy. Names of storage units  can be tracked in subdirectories. Detailed characteristics and roles of each storage unit can be tracked in separate databases, or as file and directory names. To minimize directory search time, storage units  can be configured to be large and few.","System  can include storage directory library . Storage directory library  can manage one or more lists of storage units  within storage container . Storage directory library  can hide differences between types of storage containers  behind a single directory application programming interface (API). The API can allow system  to assign a unique name to a unique storage unit , find a storage unit  by name, and remove an association between a storage unit  and a name. Storage directory library  can depend on storage container library  to allocate space in storage containers  for the directory structure.","System  can include storage container library . Storage container library  can be used to manipulate storage container . Storage container library  can provide mechanisms to allocate and access blocks for the supported classes of storage containers and implement storage units in data layout format  on top of various storage containers. Storage container library  can be used to manipulate an individual storage unit . Storage container library  can be used as a zlib drop-in replacement.","System  can include storage container configuration . Storage container configuration  can include a map of a storage container that a given instance of storage service can use. The map can include a set of records. Each record can include a pathname of storage container , a type of storage container , and an open-ended set of attributes. The type of storage container  can denote which block accessor  and directory handling logic can be used. Storage configuration  can be represented as a block of American Standard Code for Information Interchange (ASCII) text with the following Extended Backus-Naur Form (EBNF) grammar:",{"@attributes":{"id":"p-0036","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"config = { line };"]},{"entry":[{},"line = { whitespace }, pathname, whitespace, type, { whitespace,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"attributes }, { whitespace }\u2018\\n\u2019;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type = \u201cdirectory\u201d | \u201cimage\u201d | \u201cimage-growable\u201d | \u201cbdev\u201d |"]},{"entry":[{},"\u201cbdev-growable\u201d;"]},{"entry":[{},"attributes = attribute, { whitespace, attribute };"]},{"entry":[{},"attribute = key, { whitespace }, \u2018=\u2019, { whitespace}, value;"]},{"entry":[{},"key = allowedchar, { allowedchar };"]},{"entry":[{},"value = allowedchar, { allowedchar };"]},{"entry":[{},"allowedchar = anybyte \u2212 (\u2018=\u2019 | \u2018 \u2019 | \u2018\\n\u2019 | 0 );"]},{"entry":[{},"whitespace = \u2018 \u2019, { \u2018 \u2019 };"]},{"entry":[{},"pathname = pathnamebyte, { pathnamebyte };"]},{"entry":[{},"pathnamebyte = anybyte \u2212 ( \u2018 \u2019 | \u2018\\n\u2019 | 0);"]},{"entry":[{},"anybyte = ? any 8 bit value ?;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Storage unit  and a directory can be configured to function independently of each other. Storage container  can be a source of the storage blocks that are managed by block accessor .","Disk allocation scheme  can support various classes of storage container . The classes can include a block device class and a file directory class. Storage directory library  can store a directory in a manner specific to a storage container class. If storage container  is a directory of a file system, storage unit  can be a file within that directory. If storage container  is a block device or block device image, storage unit  can include one or more continuous blocks of n kilobytes (KB) each, where n is a unit of allocation set by block accessor . Modifications to a storage container's list of storage units can be flushed to a non-volatile storage device (e.g., a disk).",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIGS. 2B-2C","FIG. 2B"],"b":["220","220","220","222","222","222"]},"Header  can include maximum entries value . Maximum entries value  can specify a number of entries of an array of a storage unit array. In some implementations, maximum entries value  can be represented as an eight-byte big-endian value.","Header  can include storage container name . Storage container name  can be a name of the block device storage container. In some implementations, storage container name  can include a null-terminated string of at most a specified length (e.g., 240-bytes) including the final zero. An array of fixed size data records can follow header .",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 2C","b":["240","240","242","242","242"]},"Data record  can include reserved space . Reserved space  can be a fixed-length location (e.g., eight bytes) for extensions. The extension can enable larger offsets when a full storage is copied to a block device that is larger than 2^64 bytes. Additionally or alternatively, the extension can be used to extend storage unit entries to include additional information on another block, or to link to secondary storage units.","Data record  can include storage unit name . Storage unit name  can include a null terminated string of at most a specified length (e.g., 240-bytes) including the final zero. An empty string in storage unit name  can indicate an unused entry.","A storage container can have a file system directory class. Contents of the directory can include a block of ASCII text with the following grammar:",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"directory = header, body;"},{"entry":"header = { whitespace }, name, { whitespace }, \u2018\\n\u2019;"},{"entry":"body = { entry };"},{"entry":"entry = { whitespace }, name, whitespace, pathname, { whitespace }, \u2018\\n\u2019;"},{"entry":"allowedchar = anybyte \u2212 ( \u2018 \u2019 | \u2018\\n\u2019 | 0 );"},{"entry":"whitespace = \u2018 \u2019, { \u2018 \u2019 };"},{"entry":"name = { allowedchar };"},{"entry":"pathname = pathnamebyte, { pathnamebyte };"},{"entry":"pathnamebyte = anybyte \u2212 ( \u2018 \u2019 | \u2018\\n\u2019 | 0 );"},{"entry":"anybyte = ? any 8 bit value ?;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 3A","b":["214","214","202","201","214","214","306","201"]},"A block can include a section of storage space that is regarded as contiguous by storage unit . The block can be, but need not be, a single hard disk block. Block accessor  can provide data access methods to read, write, and seek into blocks. In some implementations, a single block can include underlying physical storage that is not physically contiguous.","Storage unit  can be associated with block accessor . Storage unit  can designate blocks using offset , block size , or both, that are provided by associated block accessor . Storage unit  can assume that the offset-size pair represents a portion of the underlying physical storage that belongs exclusively to storage unit . Storage unit  can use block accessor  to seek to these offsets at specified location, and read and modify bytes at the location. Offset  of a block can be relative to a specified point. The specified point can be the beginning of a file containing only one storage unit, or the beginning of a block device containing many storage units. The knowledge of offset  can belong to block accessor  that is associated with storage unit .","For example, if storage container  is a file in a file system, block accessor  can include the file. Block accessor  can use truncate to add\/remove blocks from storage unit , and use seek, read, and write relative to the beginning of the file to access information in storage unit .","If storage container  is a block device, block accessor  can allocate blocks from the device by maintaining a free list or a bitmap on the block device. Block accessor  can use seek, read, and write relative to the beginning of the block device to access the information in storage unit .","A storage container library can hide differences between types of storage containers behind a single block accessor API to allocate blocks for storage unit , depending upon the type of storage container  associated with storage unit . Block accessor  need not manipulate internal structure of storage unit  during allocation. Storage unit logic can be responsible for maintaining references to all blocks that have been allocated.","Block accessor logic  can include allocation and release functions. In addition, block accessor logic  used for accessing blocks in a file-based storage unit and blocks in a block-device based storage unit can include native file manipulation functions, e.g., seek( ), read( ), or write( ). It is not required, though desirable, that the storage underlying successive blocks of storage unit  be sequential and contiguous. Sequential and contiguous blocks can result from optimizations in a block device block accessor.","Block accessor  can include block size  that block accessor  supports for associated storage container  and how many multiples  of block size  block accessor  can allocate at one time. In some implementations, block accessor  can support any block size and thus can indicate that block size  has a value of 1, and multiple  has a value of 2^64.","In some implementations, block accessor  can choose block size  and multiple  when initializing storage container . Block accessor  can record block size  and multiple  in a manner specific to a class of block accessor . Subsequent instantiations of storage container  can be configured to report the initially chosen block size  and multiple .","Storage container types specified by block accessor  can include the following:\n\n","A block device class of block accessor  can support a single block size (a multiple of 1) for all storage units in a given storage container (e.g., storage container ). When storage unit  is created, block size  can be chosen for storage unit  within constraints indicated by block accessor . The chosen block size can be recorded with storage unit  and can remain constant for storage unit . For file system storage containers, storage units can be moved from a first storage container to a second storage container. For block device storage containers, the block size in the storage unit can be used for error checking, allowing for the possibility that a tool can copy the storage unit from one storage container to another.",{"@attributes":{"id":"p-0058","num":"0062"},"figref":"FIG. 3B","b":["320","320","320","322","322","322"]},"Structure  can include block size . Block size  can represent units of storage allocated in a storage container associated with structure . Block size  can include an eight-byte big-endian number.","Structure  can include first block offset . First block offset  can include an offset of an entry point into stored content. The offset of the entry point can be an offset of a storage unit or a list of storage units associated with a storage container associated with structure . Block accessor logic can provide methods to set\/get first block.","Structure  can include flags . Flags  can include one-byte values, which can include a bitmap. A first bit (e.g., bit ) of the bitmap can store a dirty flag. If the dirty flag is found to be set when opening an associated storage container, the dirty flag can indicate that the storage container was not closed properly. The dirty flag can be cleared when the storage container has been cleaned and the system is shut down properly. A second bit (e.g., bit ) of the bitmap can be a garbage collection (GC) flag. If the GC flag is found to be set when opening an associated storage container, garbage collection can be performed on the associated storage container. The GC flag can be cleared when the storage container has been cleaned and the system is shut down gracefully. Block accessor logic can manage the dirty and GC flags. Block accessor logic can provide functions for checking the GC flag and accomplish garbage collecting.","Structure  can include reserved section . Reserved section  can be set aside to allow a storage unit to store block type and flags at the very beginning of a block. Such arrangement can allow a storage unit format to be recognizable at the beginning of a file.","Structure  can include free list . Free list  can include a bit map of allocatable block in an associated storage container. Let T be the total number of bytes in the storage container; B be the block size; S be a size of free list  in bytes. Then the size of free list  can be calculated using the formula S=T\/(8*B+1). Recovery of free list  can be automatic. Free list  can be brittle. Free list  can be committed to non-volatile storage rarely. If the dirty flag is detected upon startup, free list  can be rebuilt entirely from an owner field of a block accessor block, after which each storage unit can be repaired. Structure  can include blocks , which can include actual space being allocated to data. Blocks  can be aligned on block boundaries.",{"@attributes":{"id":"p-0064","num":"0068"},"figref":"FIG. 3C","b":["340","340","340"]},"Block container block  can include reserved space . Reserved space  can be used by other types of blocks. Reserved space  can be seven-bytes long.","Block container block  can include flags . Flags  can be a one-byte value. A first bit (e.g., bit ) of flags  can be a mark used by both a storage unit and a block accessor during garbage collection. If set, this block can be freed during a sweep.","Block container block  can include owner . Owner  can include a unique identifier supplied by an invoking party during allocation. Owner  can identify a storage unit associated with the block accessor. If the value is \u22121, the storage unit is unallocated. Owner  can include eight-bytes. Block container block  can include data section , which can store any data.",{"@attributes":{"id":"p-0068","num":"0072"},"figref":"FIG. 4","b":["400","400"]},"To reconstruct data, blocks in a storage unit can be traversed in order specified by one or more indices. First block  can be a block that is accessed using directory entry, which can be an offset used to designate the storage unit. First block  can include a block size, a compression dictionary, and a top level index. Within the top level index, entries , , and  can be sorted in order of sections of uncompressed data, which entries , , and  represent. Entries , , and  can include references  and  to index blocks, and reference  to data block . Data block  can include compressed or uncompressed data.","Index blocks  and  can each include entries to smaller portion of the sections of the uncompressed data. For example, index blocks  can include index that includes references  and  to data blocks  and , respectively. Index blocks  can include index that includes references  and  to data blocks  and , respectively.","To find a given chunk of uncompressed data, a reader can perform a dichotomic search on top level index of first block , and then recursively on any index (e.g., indices of index blocks  and ), until a data block is found. To traverse all data from start to finish, the reader can traverse an entire tree in a depth-first and left-to-right order. In some implementations, an entry (e.g., a last entry) of an index can refer to another index block. The size and data offset portion of the entry can be set to zero.",{"@attributes":{"id":"p-0072","num":"0076"},"figref":"FIG. 5","b":"500"},"Block  can include signature . Signature  can include a unique number having a specified length (e.g., two bytes). Signature  can be used for detecting corrupted or un-initialized storage units.","Block  can include version . Version  can include an indication of version of the structure (e.g., version 1).","Block  can include type . Type  can be a value having a specified length (e.g., one-byte) that can indicate how block  should be read. Some example type values are described below in table 1.",{"@attributes":{"id":"p-0076","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Value","Meaning"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","Invalid value"]},{"entry":["1","Block is a storage unit header block. A header block can"]},{"entry":[{},"be the first block of a storage unit."]},{"entry":["2","Block is an index block."]},{"entry":["3","Block is a data block including compressed data (e.g.,"]},{"entry":[{},"ZLIB Compressed Data Format Specification version 3.3"]},{"entry":[{},"(RFC1950) compressed data)"]},{"entry":["4","Block is a data block including uncompressed data."]},{"entry":["5","Block is a data block including no data."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Block  can include reserved space . Reserved space  can be used for future-proofing the structure of block . Reserved space  can have a specified length (e.g., three bytes).","Block  can include flags . Flags  can include a one-byte value, which can include a bitmap. A first bit (e.g., bit ) of the bitmap can store a mark flag. The mark flag can be used during garbage collection. If the mark flag is set to one, block  will be swept at the end of the garbage collection. A second bit (e.g., bit ) of the bitmap can be dirty flag. If the dirty flag is set in a header block, the dirty flag can indicate that the entire storage unit in which the header block is located is dirty.","Block  can include owner . Owner  can specify a storage unit to which block  belongs. A block can be designated by an offset of the first block of the storage unit. The first block (header block) can point to itself. Owner can have a specified length (e.g., eight bytes).","Block  can include reference . Reference  can include an offset to a next block in the storage unit. Reference  can be a big-endian value having a specified length (e.g., eight bytes).","Block  can include second reserved space . Second reserved space  can be used for future-proofing the structure of block . Second reserved space  can have a specified length (e.g., eight bytes).","Block  can include data space . Data space  can occupy remaining portions of block . Meaning of data stored in data space  can vary depending upon type  and flags  of block .",{"@attributes":{"id":"p-0083","num":"0087"},"figref":["FIGS. 6A-E","FIG. 6A"],"b":"600"},"Data section  of a header block can include block size . Block size  can specify a size of all blocks of a storage unit that includes the header block. Block size  can include an eight-byte big-endian value.","Data section  of a header block can include last block reference . Last block reference  can include an offset of a last block in a block sequence in the storage unit. Last block reference  can include an eight-byte big-endian value.","Data section  of a header block can include dictionary . Dictionary  can include a dictionary that can be used as an initial dictionary for decompressing data blocks that specify the dictionary. The dictionary can be an RFC  compressed dictionary. Dictionary  can be empty. A specified size (e.g., 32 kilobytes (KB)) can be allocated to dictionary  in data section .","Data section  of a header block can include top index . Top index  can occupy remaining portions of data section . Top index  can include a list of entries, each entry including a reference to another block in the storage unit. The reference can be an offset. Number of entries in top index  can depend on block size . For example, when block size  is 128 KB, top index  can accommodate 4095 entries. A storage unit using top index  as the only index can store approximately 500 megabytes (MBs) of compressed data.",{"@attributes":{"id":"p-0088","num":"0092"},"figref":"FIG. 6B","b":["610","610","612","612","612"]},"Data section  of the index block can include a data structure  of records. Data structure  can include an array. Records can be stored in sequence in the array. The records that represent valid index entries can be stored at a beginning of the array. Other records having undefined content can follow.",{"@attributes":{"id":"p-0090","num":"0094"},"figref":"FIG. 6C","b":["620","620"]},"Record  can include an offset in uncompressed data . Offset in uncompressed data  can indicate a beginning of a data section in uncompressed data. Offset in uncompressed data  can include an eight-byte big-endian value.","Record  can include uncompressed data size . Uncompressed data size  can indicate a size of the data section in uncompressed data. Uncompressed data size  can include an eight-byte big-endian value.","Record  can include compressed data block offset . Compressed data block offset  can include a reference to a block in storage that contains the data section in compressed form. Compressed data block offset  can include an eight-byte big-endian value.",{"@attributes":{"id":"p-0094","num":"0098"},"figref":"FIG. 6D","b":"630"},"Data section  of a compressed data block can include compression method and flags (CMF) . CMF  can be a one-byte long value that includes method of compression and compression information. Each data block can have a different CMF, allowing blocks of data to be compressed using different compression methods.","Data section  of a compressed data block can include flags . Flags  can include indication on dictionary and compression level. Flags  can occupy one byte.","Data section  of a compressed data block can include dictionary identifier . Dictionary identifier  can be present when a preset dictionary indicator bit of flags  is set. Dictionary identifier  can include a checksum of a dictionary that can be preloaded prior to decompressing data. If dictionary identifier  is present and a header block of the storage unit does not contain a matching dictionary, an error message can be generated, indicating that the storage unit or the data block is broken.","Data section  of a compressed data block can include compressed data  and checksum . Checksum  can include a checksum value of the uncompressed data (excluding any dictionary data) computed according to various algorithms (e.g., Adler-32 algorithm).",{"@attributes":{"id":"p-0099","num":"0103"},"figref":"FIG. 6E","b":["650","650","652","654","656"]},{"@attributes":{"id":"p-0100","num":"0104"},"figref":"FIGS. 7A and 7B"},{"@attributes":{"id":"p-0101","num":"0105"},"figref":"FIG. 7A","b":["700","702"]},"The system can create () a header block and one or more data blocks. Each data block can include a compressed or uncompressed portion of the received data. The header block can include an index to at least one of the one or more data blocks. The header block can include a configurable block size of each data block. The index can include a triplet of value. The indices can include a first index identifying an uncompressed offset value, a second index identifying an uncompressed data size, and a third index identifying an offset of a data block. In some implementations, the header block can include a reference to an index block, the index block including additional triplets of indices. The index block can be stored in the file after the at least one of the data blocks. The index block can include a reference to a next index block. The reference can be an offset value. The reference can be file system independent. A data block can include a compression identifier identifying a compression mechanism used in compressing the data into the data block. In some implementations, the one or more data blocks can include a first data block and a second data block. The first data block can include data compressed using a first compression mechanism. The second data block can include data compressed using a second compression mechanism that is different from the first compression mechanism.","The system can store () the header block in a data structure (e.g., at the entry point of the data structure). In some implementations, the data structure can be a serialized data structure. The data structure can include a file system directory or one or more files.","The system can store () storing the one or more data blocks in the data structure after the header block. Storing the one or more data blocks in the data structure after the header block can include storing the one or more data blocks sequentially after the header block. The index in the header block can indicate a location of each of the one or more data blocks in the data structure, allowing non-sequential access to each of the data blocks.",{"@attributes":{"id":"p-0105","num":"0109"},"figref":"FIG. 7B","b":["720","722"]},"The system can identify () a triplet of indices, the first index of the triplet of indices corresponding to the location specified in the request. Identifying the triplet of indices can include traversing a header block and one or more index blocks of the compressed data, and identifying a top index and indices in the index blocks. Each index can include a collection of triplets of indices.","The system can identify () a data block using a reference in the identified triplet of indices. The reference can include an offset of a data block from the beginning of the compressed file or to the current block.","The system can decompress () the identified data block. Decompressing the identified data block can include decompressing the identified data block using a decompression method corresponding to a compression method as specified in the identified data block. In some implementations, the data block can include uncompressed data. Decompressing the identified data block can include retrieving the data from the data block.","The system can identify () the section of data from the decompressed data block, based on the offset and size specified in the request.",{"@attributes":{"id":"p-0110","num":"0114"},"figref":["FIGS. 8A-8E","FIGS. 8A-8E"]},{"@attributes":{"id":"p-0111","num":"0115"},"figref":"FIG. 8A","b":["800","802","804"]},"The system can determine () that a storage unit is being opened. If a storage unit is being opened, the system can check () if a dirty flag of a header block of the storage unit is clear. If the dirty flag is clear, the system can set the dirty flag, and write and flush the storage unit. In some implementations, indices of a storage unit are kept in memory and updated in memory. The system writes headers of index blocks to record addition or deleting of index blocks.","The system can determine () that a storage container is being closed. If a storage container is being closed, the system can write () a free list and a first sector of the storage container. The system can issue a flush, which can write data that are designated to be written to non-volatile storage, but are still in volatile storage, to the non-volatile storage. The free list is written during closing. The free list can be kept and modified in memory at other time.","The system can determine () that a storage unit is being closed. If a storage unit is being closed, the system can write () indices in the index blocks or header unit or both. The system can issue a write barrier and write the first block of the storage unit.",{"@attributes":{"id":"p-0115","num":"0119"},"figref":"FIG. 8B","b":"818"},"A block accessor can assign () the owner field of the new block a reference to a new owner. The block accessor can assign () the reference field in a currently last block the reference to the new block. The block accessor can assign () the reference field of the new block with a reference to yet another block.",{"@attributes":{"id":"p-0117","num":"0121"},"figref":"FIG. 8C","b":["826","828","830","832"]},"Utilizing processes  and , a block accessor can limit a block B marked with a given owner O to refer only to a block belonging to O at the time block B belonged to O. Any chain of blocks belonging to O can be a chain that exists or has existed in the past. If a given storage unit A is shutdown successfully, where a write barrier caused first all modified sectors and then the header block to be written, A can be guaranteed to refer to all blocks designated to be owned by A. If another storage unit of the storage container's free list are dirty, the dirty flag can indicate that some blocks owned by any storage unit that are marked as free in the free list, or some blocks referred to by the other storage unit have a different owner or no owner.",{"@attributes":{"id":"p-0119","num":"0123"},"figref":"FIG. 8D","b":"834"},"A system can prevent () block accessing operation before recovery is completed. The system can discard () free list of the block accessor. All blocks can be recorded as occupied. The system can set () the garbage collection (GC) flag of the storage container in memory.","The system can inspect (), or sweep, every block of the storage container. Inspecting the blocks of a storage container can be based on the size and alignment of the blocks for ownership. If owned by no one, the block can added to the free list and the block's GC mark can be cleared. If owned by a storage unit, the GC mark of the block can be set. The storage container's dirty flag can be cleared in memory. The clear dirty flag can be written to the storage container header during a proper shutdown.","The system can open () a storage unit. If a storage unit A starts with the dirty flag set, the system can prevent storage unit operation before recovery is complete. The system can clear content in the top index of the storage unit. The system can inspect the blocks of the storage unit, following each block using the reference fields and owner fields. If a block has no owner, then the block can be freed redundantly. If the owner is other than A, then the block can be unlinked from the block's predecessor and can be abandoned, along with all the subsequent ones in the chain. If the owner is A, then the block's GC mark can be cleared. If the block is an index block, the GC mark is cleared. The remaining blocks can be inspected again. The indices can be rebuilt in memory. In some implementations, rebuilding the indices can include uncompressing compressed blocks to determine the amount of uncompressed data that each block represents. The storage unit's dirty flag can be cleared in memory. Since a storage unit can be configured not to use a block that is marked for a different owner, the storage unit can operate normally after being cleaned, even in the presence of dirty storage units. In some implementations, to assure clean recovery, no dirty storage unit is allowed to do anything other than recovering.",{"@attributes":{"id":"p-0123","num":"0127"},"figref":"FIG. 8E","b":["850","850"]},"The system can optionally flush () unwritten data to non-volatile storage. Flushing the data can reduce total amount of work that garbage collection needs to work on. Flushing unwritten data can occur in any stage of process .","A block device block accessor can determine () if a storage container's GC flag is clear. If the GC flag is clear, the block device block accessor needs to do nothing. If the GC flag is set, the block device block accessor can inspect () all non-free blocks for the GC flag. Every block that has a GC flag set can be freed. The GC flag can be reset. The block device block accessor can clear () the GC flag of the storage container.",{"@attributes":{"id":"p-0126","num":"0130"},"figref":"FIG. 9","b":["900","900","902","904","906","908","912","910"]},"The term \u201ccomputer-readable medium\u201d refers to any medium that participates in providing instructions to processor  for execution, including without limitation, non-volatile media (e.g., optical or magnetic disks), volatile media (e.g., memory) and transmission media. Transmission media includes, without limitation, coaxial cables, copper wire and fiber optics.","Computer-readable medium  can further include operating system  (e.g., Mac OS\u00ae server, Windows\u00ae NT server), network communication module , log data interface , compression logic , decompression logic , and compressed data . Log data interface  can provide one or more interfaces to receive log data from one or more log sources. Compression logic  can include mechanism to compress the received log data into randomly accessible data in one or more files. Decompression logic  can include mechanism to read the compressed data, including receiving random access requests and responding to the requests. Compressed data  can include one or more compressed data files. Each compressed data file can include data compressed using various technologies and uncompressed data.","Operating system  can be multi-user, multiprocessing, multitasking, multithreading, real time, etc. Operating system  performs basic tasks, including but not limited to: recognizing input from and providing output to devices  and ; keeping track and managing files and directories on computer-readable mediums  (e.g., memory or a storage device); controlling peripheral devices; and managing traffic on the one or more communication channels . Network communications module  includes various components for establishing and maintaining network connections (e.g., software for implementing communication protocols, such as TCP\/IP, HTTP, etc.). Database interface  can include interface to various databases including relational databases.","Architecture  can be included in any device capable of hosting a database application program. Architecture  can be implemented in a parallel processing or peer-to-peer infrastructure or on a single device with one or more processors. Software can include multiple software components or can be a single body of code.","The described features can be implemented advantageously in one or more computer program products that are executable on a programmable system including at least one programmable processor coupled to receive data and instructions from, and to transmit data and instructions to, a data storage system, at least one input device, and at least one output device. A computer program is a set of instructions that can be used, directly or indirectly, in a computer to perform a certain activity or bring about a certain result. A computer program can be written in any form of programming language (e.g., Objective-C, Java), including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment.","Suitable processors for the execution of a program of instructions include, by way of example, both general and special purpose microprocessors, and the sole processor or one of multiple processors or cores, of any kind of computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memories for storing instructions and data. Generally, a computer will also include, or be operatively coupled to communicate with, one or more mass storage devices for storing data files; such devices include magnetic disks, such as internal hard disks and removable disks; magneto-optical disks; and optical disks. Storage devices suitable for tangibly embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices, such as EPROM, EEPROM, and flash memory devices; magnetic disks such as internal hard disks and removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, ASICs (application-specific integrated circuits).","To provide for interaction with a user, the features can be implemented on a computer having a display device such as a CRT (cathode ray tube), LCD (liquid crystal display), or plasma monitor for displaying information to the user and a keyboard and a pointing device such as a mouse or a trackball by which the user can provide input to the computer.","The features can be implemented in a computer system that includes a back-end component, such as a data server, or that includes a middleware component, such as an application server or an Internet server, or that includes a front-end component, such as a client computer having a graphical user interface or an Internet browser, or any combination of them. The components of the system can be connected by any form or medium of digital data communication such as a communication network. Examples of communication networks include, e.g., a LAN, a WAN, and the computers and networks forming the Internet.","The computer system can include clients and servers. A client and server are generally remote from each other and typically interact through a network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.","A number of implementations of the invention have been described. Nevertheless, it will be understood that various modifications can be made without departing from the spirit and scope of the invention. For example, some values are stored in a big-endian format. Other storage formats are possible. Accordingly, other implementations are within the scope of the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIGS. 2B-2C"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 3A-3C"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIGS. 6A-6E"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 7A and 7B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIGS. 8A-8E"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
