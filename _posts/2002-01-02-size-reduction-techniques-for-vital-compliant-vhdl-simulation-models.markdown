---
title: Size reduction techniques for vital compliant VHDL simulation models
abstract: A method and system select delay values from a VHDL standard delay file that correspond to an instance of a logic gate in a logic model. Then the system collects all the delay values of the selected instance and builds super generics for the rise-time and the fall-time of the selected instance. Then, the system repeats this process for every delay value in the standard delay file () that correspond to every instance of every logic gate in the logic model. The system then outputs a reduced size standard delay file () containing the super generics for every instance of every logic gate in the logic model.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07085701&OS=07085701&RS=07085701
owner: International Business Machines Corporation
number: 07085701
owner_city: Armonk
owner_country: US
publication_date: 20020102
---

{"@attributes":{"id":"description"},"GOVINT":[{},{}],"p":["This invention was made with government support under subcontract B338307 under prime contract W-7405-ENG-48 awarded by the Department of Energy. The Government has certain rights in this invention.","The present patent application is related to co-pending and commonly owned U.S. patent application Ser. No. 10\/038,209, now U.S. Pat. No. 6,817,000, entitled \u201cDelay Correlation Analysis and Representation for VITAL Compliant VHDL Models\u201d, and U.S. patent application Ser. No. 10\/038,689, entitled \u201cVHDL Technology Library Method for Efficient Customization of Chip Gate Delays\u201d, filed on even date with the present patent application, the entire teachings of which being hereby incorporated by reference.","1. Field of the Invention","This invention generally relates to the field of VHDL modeling, and more particularly relates to a system and method for reducing the size of VITAL compliant VHDL simulation models.","2. Description of Related Art","As ASICs (Application Specific Integrated Circuits) have become more complex, emphasis on verification techniques have flourished to assure that a particular ASIC's functionality can be verified prior to manufacture. One of the efforts is the IEEE VITAL (VHDL Initiative Towards ASIC Libraries) standard that allows back annotation of timing data into a simulation model. Part of this standard also defines the methodology required to generate VITAL compliant models. The VITAL standard provides the capability of generating very sophisticated behaviourals of circuit behavior, which incorporate time delays (as determined by other timing tools).","Usually models of this type have the most meaning at the gate level, where a model is synthesized into gates associated with a particular technology. The provider of the technology usually provides a set of VITAL compliant VHDL models for the gates, such that a very detailed behavior of the ASIC can be simulated. An event driven simulator is usually utilized with VITAL compliant models. During model load time, the SDF (Standard Delay Format file) is also read in to initialize a set of VHDL (Very High Speed Integrated Circuit Hardware Design Language) generic variables with the delay values. A naming convention exists for mapping SDF delay constructs to VHDL generic delay variable names, which is the basis of how the delays are back annotated. Due to the detail of the modeling, this type of simulation is most useful for going after specific scenarios where other simulation environments may be less accurate (i.e., clock gating, test logic, asynchronous boundaries, array controls, etc.).","Current state of the art for utilizing VITAL compliant VHDL models for simulation imposes a large size penalty, when modeling current ASIC chips. This size penalty is a consequence of the ever-increasing gate densities of ASIC chips, which require more instantiations of VITAL compliant VHDL gate behaviors. In conjunction with the increased gate counts, the SDF that associates timing delays to gates also increases in size at the same rate. It is the combination of VHDL model size and SDF size that influences the ultimate size of the resulting simulation model.","Even with this size penalty, it is still desirable to simulate a chip in this environment because it most accurately models the chip operation prior to fabrication. Also event simulation, with delays, can accurately model logic implementations that are resistant to other simulation environments, such as cycle simulation. Therefore any mechanism that reduces this type of model, in terms of space or time, is desirable in order to enhance the ability of the model to fit on a host computer platform, or to complete a simulation in a timely manner such that the detailed simulation capabilities provided by VITAL compliant VHDL event simulation may be exploited. A reduction in the size of the model requires less memory in order to store and execute the file. Also, if the reduction is great enough, it could allow the entire model to be stored in RAM (Random Access Memory) memory instead of having to dynamically swap in and out portions of the model from a secondary storage medium such as a hard drive. This would decrease the number of reads from a hard drive during a simulation, which would greatly reduce the simulation time.","The decrease in memory requirements and the runtime decrease could also provide for the simulation to be performed on a lower cost computing system than would normally be required. The necessary computing system could contain less memory and a slower processor, therefore providing a cost savings.","Therefore a need exists to overcome the problems with the prior art as discussed above, and particularly for a method of reducing the size of VITAL compliant VHDL models.","A method and system select delay values from a VHDL standard delay file that correspond to an instance of a logic gate in a logic model. Then the system collects all the delay values of the selected instance and builds super generics for the rise-time and the fall-time of the selected instance. Then, the system repeats this process for every delay value in the standard delay file that correspond to every instance of every logic gate in the logic model. The system then outputs a reduced size standard delay file containing the super generics for every instance of every logic gate in the logic model.","The present invention, according to a preferred embodiment, overcomes problems with the prior art by providing a unique process that unbinds the rise\/fall tuples from the generic variable name, thereby enabling other methods to reduce the size of a VITAL compliant VHDL simulation model. The simulation model reduction is achieved through the significant reduction in size of the SDF file required to back annotate delay values into the model. The reduced size results in significantly reduced memory requirements for a computing system. This reduces costs of the overall computer system required for simulation. The use of this process also has the effect of increasing performance on the computer platform that is host to the simulation model, due to reduced memory paging requirements and reduced file I\/O.","Exemplary embodiments disclosed are for a model written in VHDL, but similar techniques may also be applied to simulation models written in the Verilog language. The techniques involve editing the VHDL model or its associated SDF, based on size reduction observations, to realize a savings in the size of the resulting simulation model.","The SDF size reduction is based on the correlation of disparate delay values, whose scope in prior art was limited to a single instance of a logic gate. These correlated values will tend to cluster around technology dependent values, such that the same delays can be reused regardless of the chip size. This provides the advantage that the SDF size reduction utilizing this technique, will scale well with increased chip size, resulting in a larger percentage size reduction for the larger, and more problematic, chip sizes. All improvements utilize techniques that maintain compliance to the VITAL standard. This has the advantage of allowing any simulation platform that already implements the VITAL standard to easily incorporate this mechanism into its technology library in order to gain the benefits of this invention.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIGS. 1 and 2","b":["100","110","114","116","110","122","110","122","112","112","114","116","118","120","114","208","210","212","214","216","116","202","204","206","118","124","114","116","112","118","106","108","118","110"]},"Glue software  may include drivers, stacks, and low level application programming interfaces (API's) and provides basic functional components for use by the operating system platform  and by compatible applications that run on the operating system platform  for managing communications with resources and processes in the computing system .","Each computer system  may include, inter alia, one or more computers and at least a computer readable medium . The computers preferably include means  for reading and\/or writing to the computer readable medium . The computer readable medium  allows a computer system  to read data, instructions, messages or message packets, and other computer readable information from the computer readable medium. The computer readable medium, for example, may include non-volatile memory, such as Floppy, ROM, Flash memory, disk drive memory, CD-ROM, and other permanent storage. It is useful, for example, for transporting information, such as data and computer instructions, between computer systems.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 3","FIG. 1"],"b":["124","100","124","302","304","306","308","302","304","306","308"]},"The data memory  also contains an SDF (Standard Delay Format) file , an SDF analysis file , and a reduced SDF file . The SDF (Standard Delay Format) file  is an industry standard (IEEE 1076.4) file that specifies delays in a format for simulation tools to back annotate timing delays and is created by the SDF generation tool . The SDF analysis file  is output by the SDF analyzer  and can be used to determine delays used for each VHDL generic or to determine delays associated with each instance of a logic gate. The reduced SDF file  is a file output by the SDF reducer  and contains only two generics per instance of each logic gate.","Also contained in data memory  are a chip VHDL file , a correlation VHDL file , and an object file . The chip VHDL file  is a file output by the VHDL generator  for use by a VHDL event simulator . The correlation VHDL file  has correlation delay information embedded within the file, and the object file  contains the machine language executables used to simulate the chip on a particular workstation platform (e.g. Windows, Unix, etc.) The data memory  may optionally contain files such as a log file  and a checkpoint file  to save the current state of a simulation.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 4","FIG. 1"],"b":["401","420"]},"If path \u201cA\u201d is chosen, the process proceeds, at step , to create an SDF file  for a given synthesized chip netlist . The processing, at step , involves prior art methods as specified in the IEEE VITAL specification. The SDF file , at step , is analyzed by the SDF analyzer , resulting in an SDF analysis file , according to methods to be described later in greater detail. The resulting SDF analysis file  is used, at steps , , to perform an SDF reduction and generate a correlation VHDL file , according to methods to be described later in greater detail. The correlation VHDL file  is compiled, at step , utilizing a VHDL compiler .","If Path B is chosen, the process proceeds, at step , to generate a chip VHDL file  and then compile, at step . The VHDL generation, at step , utilizes a VHDL generation package , which takes a synthesized chip netlist  and generates technology specific VHDL, as illustrated in . The VHDL generation tool  is usually bundled with a synthesis tool. The VHDL compile, at step , utilizes an existing VHDL compiler , which takes IEEE compliant VHDL as input, and generates VHDL object code suitable to be utilized by an associated VHDL simulator .","If Path C is chosen, the technology library  is updated one time, at step , and compiled, at step . The single update, at step , is normally all that is required because the target technology library  is usually constant at the gate level for a particular chip, or family of chips. The update of the technology library  is done in order to provide a mechanism for binding chip specific delay information in a generic fashion, such that a single technology library  can still be utilized for multiple chips. The updated VHDL is compiled, at step , using a VHDL compiler .","At step , a VHDL simulation is executed. All paths (A\u2013C) must be complete at this step, such that the SDF and compiled VHDL files are available for simulation as depicted in . Any simulator that supports IEEE compliant VHDL format is suitable for this step.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 5","FIG. 1"],"b":["310","202","304","302","306","308","310"]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 6","FIG. 1","FIG. 5"],"b":["310","310","310","612"]},"The correlation process produces a reduced set of delays, by performing delay correlation analysis across an entire chip as represented in the SDF file . The correlation process shown correlates delays according to a policy of combining common delays for a common delay generic name. It will be obvious to those of ordinary skill in the art, in view of the present discussion, that alternative embodiments of the invention are not limited to this correlation policy (a set of criteria used to combine delays). Other policies could be utilized to take advantage of common delay properties for a chip, for example, that can be exploited if delay specifications are not bounded by the scope of a single logic gate instance, as discussed in the examples provided herein.","The SDF analyzer  enters the sequence, at step , where it collects all the unique generic variable names specified in an SDF file . For example, tpd_A  (see ) is a generic name (delay name) for the propagation delay from a previous gate to pin A of a logic gate. The SDF file  contains values for all the delays for every gate in the synthesized chip netlist . So, for example, for the gate shown in , the delay  is the delay from the driving gate to this pin (e.g. tpd_B ); delay  is the internal delay from the gate I\/O pad to the internal AND circuit (e.g. tpd_A); and delay  is the delay to the output pin Z due to a change in pin A or pin B input pins (e.g. tpd_A_Z and tpd_B_Z ). Each usage of this particular AND_LOW gate  would have a unique set of delays associated with it (rise and fall times).","A particular generic, such as tpd_A, is selected, at step . Then, at step , all the delays assigned to this generic for the entire chip are extracted from the values in the SDF file . A list of logic gate instances that reference this generic is maintained in data memory and placed in the SDF analysis file  on completion. For example, both gate: AND_LOW and gate: AND_LOW are instances of the AND_LOW usage such that separate indexes would be needed for the tpd_A generic. The delays are preferably sorted in ascending order, at step , and any duplicate delay entries are removed. At step , the sorted delays are grouped into sets of up to 62 entries corresponding to correlation sets (this is explained later in greater detail). At step , the SDF analyzer  determines if all the generics of the SDF file  have been analyzed. The process, beginning at step , is repeated for each generic of the SDF file . At step , an SDF analysis file  is generated. The SDF analysis file  contains delay data for the entire chip, which has been correlated according to a particular correlation policy. This file encapsulates the inherent delay redundancies across the entire chip for a particular policy. An example of a correlation policy would be the correlation of delays with same generic name. The SDF analysis file  is utilized, at step , to generate a reduced size SDF file  (no explicit delays specified), and to bind the technology library  to the set correlated delays, at step . A system implementation could also use this file to generate statistics for a particular correlation policy, such that a plurality of unique correlation policy results could be compared for highest efficiency.","In practice, careful observation has shown that delays are not strictly uniformly distributed. Synchronous logic has a bounded cycle time requirement, where the latch-to-latch propagation delay, through combinatorial logic, must be less than the chip cycle time. Therefore, delays are usually clustered about a range of values, with an upper bound delay equal to the cycle time. In order to allow for transversal of multiple combinatorial logic gates between latches, the majority of the delays are clustered around an even smaller range of values, relative to the cycle time. As shown in , interconnect delays will cluster around certain points dependant upon path lengths. Short delays  are for short path lengths and longer delays  are for long path lengths. Although not indicated in the figure for purposes of clarity, there is a possibility of overlap of the sets of values. For intra-circuit delays, values will cluster around the drive capabilities (such as speed, power).  indicates the distribution of logic gate delays according to power levels (high , medium , and low power ). Again, though not shown in this example, there exists the possibility of overlap.","Assuming the binding of rise\/fall tuples to VHDL generics is broken, coupled with the observation that delay values tend to cluster, there could be a very narrow range of delay values. For example, in the VHDL generic:\n\n_A=(rise time, fall time),\n\nif the rise time were a separate object from fall time, now the worst-case probability for a delay match, in the range 0 ns to 0.999 ns in 1 ps intervals, would be 1 in one thousand. If clustering occurs due to the technology, the probability of a match could be in the range of 1 in one hundred. This decoupling of tuples provides a mechanism for recognizing redundancies across logic gates, which opens up the set of delays that can exploit this technique.\n",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 10","b":["1000","310","1000","1000","314","314","1002"]},"For example, as shown in , the 1x data structure representing the rise times for an AND_LOW gate is a string of 7 digits; the \u201c0\u201d position representing the index position in a correlation set, the \u201c1\u201d position representing the tpd_A delay value position, the \u201c2\u201d position representing the tpd_B delay value position, the \u201c3\u201d position representing the tipd_A position, etc.","It is worthwhile to note that the set of valid characters allowed by VHDL are those defined by the ISO 8859-1 standard, which defines 256 (2) characters. Therefore, the maximum number of delays that could be allowed is 256. However, aside from the 62 alphanumeric characters, the other characters are either messy ($%*@) or unprintable. So, the number 62 was chosen for illustrative purposes, whereas, the maximum number of delays in this example could actually be up to 256.","A separate exemplary data structure , shown in , and that will be utilized in the correlation VHDL , contains the constants (actual delay values) that equal the delays for all of the gates. This data structure  comprises an array (may be also referred to as a matrix) of delay values preferably organized for efficiently indexing and retrieving the values from the data structure . This structure  is also used to bind the correlated delay values to the VHDL technology library  via a VHDL package (a VHDL construct that allows for sharing of common data items). A 3-dimensional variable array structure is utilized to most efficiently specify correlated delays. The z-axis  of the data structure represents a set of common blocks for each logical topology (e.g AND_LOW (low power), AND_MED (medium power), AND_HIGH (high power) are one set of common blocks: AND_NEW). Each entry on this axis depicts logic gates with a common topology (same amount and type of delays). On the x-axis  each position represents a delay value for the gate topology (e.g. slot =tpd_A for AND_NEW). They-axis  contains the actual delays.","The 3D variable array structure  is used for efficient representation of correlation delays for a particular correlation set. The X-axis and Y-axis depths are not necessarily equal to each other, nor are they necessarily equal to the X or Y-axis depths for another Z entry. Expressing the variable dimensions of the 3D array structure  as a set of 3-tuples, where each variable dimension would be an element {Z, X, Y} in the set where:\n\n","Given: 4 bytes per slot entry\n\n","Calculations:","Uniformed Array Size Requirement (2 entries)\n\n2 entries*() slots\/entry*4 bytes\/slot=(2)*(20*60)*4=9,600 bytes\n","Variable Array Structure Size Requirements (2 entries):\n\n","As an example, suppose the correlation profile of AND_LOW, AND_MED, and AND_HIGH are disjoint and resemble the distributions shown in . To represent the delays for all three types of AND_xxx gates in a single generic would look like:\n\n","This procedure can be taken a step further in order to correlate arbitrary logic blocks, such as those shown in , using the Z entry (which is the logic gate topology index). Gates with similar topology (AND, OR . . . ) would have a common Z entry. One can correlate across different topologies when the Z entry becomes \u201cthe generic entry\u201d (e.g. tpd_A). Now any logic gate that uses tpd_A knows to utilize that entry. VHDL allows for associative array indexes (or pointers), such that the technology library  would literally use an index (or pointer) of \u201ctpd_A\u201d, which would map to the proper Z entry. This allows for correlations across a wide range of logic gates, realizing significant savings. The gate structure AO   is actually a combination of two AND gates  (previously discussed) and an OR  gate. This correlation has a much larger set of delays with a higher probability for correlating the data.","In order to optimize delays across functional gates usually requires more capacity than the 1x data structure  can provide. This method likely requires a 2x data structure  (shown in ), where the first set , preferably, indexes to 1 of 62 possible slots and the second structure , preferably, indexes to 1 of 62 possible delay values in that slot. The 2x data structure  is so named because it is approximately twice the size of the original 1x data structure  (e.g. for the AND gate, there are 12 characters vs. 7 characters).","A correlation can be performed on a pin type such as tpd_A. Then, any delays to gates that have a tpd_A pin will be correlated as a group. Now, delays from gates with different functional operations, such as those shown in  can be merged. All of the gates in , and possibly others, would have a commonly named tpd_A and tpd_B pin.","When correlations are performed within a gate topology, the actual VHDL model that would incorporate the delay values knows ahead of time that AND, OR, etc. have a 6-entry 2x format and can pick off the right values in the data structure. If the correlation were performed across gate topologies, the actual VHDL model would still know which generic entries to select. Therefore there are minimal VHDL updates to the existing VHDL. A one time conversion of the technology library  assures that the AND_xxx VHDL models, for instance, point to a fixed location where tpd_A data would reside.","Taken one step further, a 3x data structure  (shown in ) can represent 238, 328 (62) possible delays. This allows all the delays to be uniquely specified, without any correlation, using only data structure conversions and decodes. The tradeoff is that there are more characters in the reduced SDF file , but there would still be a significant SDF reduction that results in size and time savings. The 3x data structure  typically pays a flat storage penalty up front. It is typically larger by 50% over 2x structure per gate. It is still a very efficient representation versus a conventional SDF, yet it can accommodate the range of gate delays for most chips. The 1x and 2x structures pay a smaller price, but also supply a correlation array structure. If the delay correlations are good, the 1x or 2x structures will be more efficient overall (total simulation model size).","The 3x data structure  handles both positive and negative delays, as shown in . So, there will be an efficient representation of negative delays also. A key observation of this 3x data structure  is that the range of negative delays is usually much smaller than positive delays because negative delays involve an \u201coverlap\u201d case that is valid for a short period of time relative to a reference point. The asymmetry in the range of positive vs. negative delays can be utilized in order to keep the structure indexes minimal by not requiring a sign for each delay. A negative \u201cbase delay\u201d, such as \u22120.500 ns, is assigned to the 0 position, and the value of each position is increased by 1 ps per position for 238, 327 increments. So, the entire range of \u22120.500 ns to +237.327 ns can be realized by a single 3x data structure , where the delay is basically a base 62 number plus a signed offset base number.","In actuality, this method allows for a 3x range of (2)=2or 16 million increments, which amounts to a 16 microsecond range at 1 picosecond intervals. This is more than enough of a range of delays to accommodate any chip. However, the 3x structure is a scalable format, where 4x, 5x . . . nX structures could be easily constructed and utilized with potential size savings. Anything beyond a 3x structure should not be needed for most chips.","The VHDL model would have fixed equations such as:\n\nDelay=Base+(1*62)+(2*62)+(_)\n\nwhere, tpd_A_, tpd_A_, and tpd_A_ are the decoded character values (0\u201361) of the first position in each of the three sets of the 3x data structure . The 3x data structure  in  indicates values of tpd_A_=1 (1), tpd_A_=10 (a), and tpd_A_=52 (Q). So, in this case:\n\nDelay=\u2212500 1*62)+(10*62)+52\n\nDelay=\u2212500+3844+620+52 4016 4.016 \n\nNote that the equation is evaluated in ps in order to work with whole numbers.\n","Usually the delays associated with timed synchronous logic are bunched around a particular cycle time. However, for severely disjoint ranges, the 2x structure should be used in order to decrease the overall range of delay values. Also, the SDF analysis file  allows for certain portions of the SDF to remain untouched, for robustness.","After an SDF analysis file  has been created, the SDF reducer , as shown in the operational flow diagram of , uses it to create a reduced SDF file  that is much smaller in size. The reduced SDF file  is still a VITAL compliant SDF with a significantly reduced number of generics (two generics per logic gate instance). The SDF file  is built on a per instance basis and each instance contains tuples of the rise and fall times of each delay in the structure. The SDF reducer  enters the process, at step , and selects an instance of a gate (e.g. gate: AND; gate: AND are two instances of the AND gate with separate delay values) from the SDF file . At step , all the delay values for the selected instance are collected from the SDF analysis file . Then, at step , the SDF reducer  builds the two single super generics tpd_superrise (rise times) and tpd_super_fall (fall times) for the selected instance. It is understood that each super generic will be represented by a collection of pointers into a data structure array (or matrix) containing all the relevant delay values. For each instance, in the SDF file , the collection of pointers, that point into the data structure array (or matrix) for the super generic to be able to resolve the actual delay values for the particular instance, takes up significantly much less storage than a set of conventional generics (storing information to conventionally identify actual delay values) for a similar instance. Advantageously, the size of the pointers for each instance, according to the preferred embodiment of the present invention, will typically be significantly smaller (more efficient) in overall storage requirements than the storage requirements of the information stored for delay values associated with instances in a conventional implementation SDF file. This novel process is repeated for every instance of every gate. Therefore, the storage efficiencies are multiplied by the number of instances in an overall SDF file. If all the instances, at step , have been converted, then a significantly reduced SDF file  is output, at step . Besides the increased storage efficiency by removing duplicate delay values and storing these in an organized fashion in the super generics, the use of the memory efficient pointers in an SDF file will additionally reduce the amount of memory storage used for an implementation. This is an important advantage of the present invention over any known prior art systems.","The process of generating the correlation VHDL file , according to step , is shown in . The VHDL correlation generator  enters the process at step  where the correlation delays are extracted from the SDF analysis file . The VHDL correlation generator , at step , generates a VHDL associative array structure (or matrix structure) such that, for example, character \u201ca\u201d is used as an array index (or index into the matrix). Then, the correlation VHDL file , which is a unique VHDL package file with correlation data embedded, is output, at step .","The overall process of generating a VHDL file , according to step , is shown in . The VHDL generator  uses the synthesized chip netlist  and the technology library  to create a chip VHDL file . The chip VHDL file  is the representation of the chip in the VHDL language.","The technology library , which is VHDL code describing the behavior of the logic gates, is only updated once, at step , and is independent of the actual delays. It can be done prior to building a simulation model for a chip. This allows binding the delays in the VHDL gate description to a specific chip delay profile without requiring unique copies of the Technology Library . This one time update of the Technology Library VHDL , is based on pre-determined gate topologies. The generic value positions in the structure are known ahead of time, and the actual entries are from the tpd_super_xxx generics for the gate.","Current state of the art provides a mechanism to back annotate delays using a VITAL compliant SDF file. The concept of correlating decoupled rise and fall delays, and exploiting this correlation with reduced SDF structures, provides the potential for a much smaller and more efficient event simulation model with delays. To exploit these potential savings, the correlated delay values (1x or 2x formats) must still be communicated to the Technology Library VHDL models , which now only have two generics specified. A unique mechanism provides an efficient VHDL compliant mechanism to automatically customize a Technology Library  at simulation time with actual delay values, using a condensed set of correlated delays, by providing a unique interface to access correlated delays, that eliminates explicit back annotation of delay values. This discussion discloses a preferred embodiment of an interface to exploit the 1x and 2x structures respectively.","Given the 3D correlation structure, the Z-axis entries for 1x structures are typically logic gates with similar topologies that have correlated sets of delays. The set of Z-axis entries could be thought of as a set of arrays Z,Z. . . Zwhere each array is two dimensional, such that array entry Zbe viewed as an array Z(X,Y), where Zis the nth entry in data structure representing a set of delays associated with a common correlation policy. The dimension Xrepresents sets of delay generics, and dimension Yare the correlated delay values. For 1x structures, a delay correlation policy would typically be across gates with a common topology. For 2x structures, a typical correlation policy would be delays associated with a common generic name.","The set of arrays Z\u2013Zwould be defined as a set of VHDL compliant array constants (output of ), which are compiled into a VHDL package body (output of ). VHDL semantics allow independent compilation of VHDL constant declarations and actual values, such that binding can be deferred until simulation time. This is also known as late binding at run time. Utilizing this capability, a unique mechanism can be derived that automatically maps the delays encapsulated by the 1x and 2x data structure to a Technology Library VHDL model  with no explicit delay back annotation.","The VHDL Technology Library modifier  updates the Technology Library  by inserting the tpd_super_rise and tpd_super_fall generic declarations for every VHDL gate model in the Technology Library . For every other generic in each VHDL gate model, the initialized value (usually set to zero in model: tpd_a:VitalDelayType :=(0.000 ns, 0.000 ns); ) is changed to an equation associated with the correlation policy.","The following shows an example of equations for referencing correlation delays for a 1x type data structure:","Given: Type 1x delay correlation on AND_H gate VHDL","Tpd_super_rise:STRING:=\u201c1QABCDE\u201d; (Back Annotated)","Tpd_super_fall:STRING:=\u201c1ABCDEF\u201d; (Back Annotated)","Tpd_a:VitaiDelayType\n\n","In this example, the AND_H_RISE 2D array constant would be the name for all 2-input gate topologies to satisfy a multiple gate correlation policy. Bit  of tpd_super_rise is used to jump to a set of generics for a particular accessed for rise time delay resolution. A name could be aliased to a common correlation set in the 1x structure (for a 2-input topology, there are 6 generics defined). The delays for the tpd_a generic are predefined to be the 1st definition in an AND_H correlation set, so the technology library  knows to use this value to select the proper set of delays. It is also known that tpd_super_rise\/fall are defined to have the generics ordered the same, so bit  (after correlation set selector) is the tpd_a delay index to the actual delay value. The value of tpd_super-rise() is character \u201cQ\u201d which would map to the 52nd delay entry of the correlation set for tpd_a. A similar, but independent, indexing scheme is performed to get the fall time delay value.","The following shows the equation for referencing correlation delays for a 2x type data structure, using a different correlation policy:","Given: Type 2x delay correlation on common generic \u201ctpd_b\u201d","Tpd_super_rise:STRING:=\u201cABCDEFQABCDE\u201d; (Back Annotated)","Tpd_super_fall:STRING:=\u201cGHIJKLABCDEF\u201d; (Back Annotated)","Tpd_b:VitalDelayType\n\n","In this example the equation looks similar, but there are subtle changes that indicate the power of this mechanism using a 2x structure. The VHDL is still updated using 2D array AND_H_RISE, but the name is now aliased to point to a common correlation structure that is based on generic names. The main difference is that the term tpd_a_offset would have a much larger value than 0 (it could be defined as the 22nd entry in the correlation set of all generics for the chip). The same 2x tpd_super_rise and tpd_super_fall values are used to designate a 2x structure of 6 independent correlation sets for 6 independent generics defined for a two input AND gate. While still using local gate level semantics for delay specification, one can take advantage of global chip level correlation optimizations.","In both examples, the two final rise and fall time values would be used to define the rise and fall times for the VHDL constant tpd_a, which would be referenced by the VHDL model when delay values for tpd_a are required. Since tpd_a is now a constant as opposed to a generic, no back annotation of delay values is required, because these equations consist entirely of references to constants, indexed using two generics. The resolution of the actual constant values is performed once at the beginning of simulation.",{"@attributes":{"id":"p-0097","num":"0122"},"figref":"FIG. 21","b":["316","418","212","316","306","320","320","318","306","316"]},{"@attributes":{"id":"p-0098","num":"0123"},"figref":"FIG. 22","b":["100","420","314","320","314","310","214","306","318","306","318","316","316"]},"During the simulation, the super generics are back annotated as in prior art. The equations in the updated technology library  now use the super generics to index into the new array structures defined in package VHDL, at step , to extract the actual delay values. No back annotation is required to do this\u2014just the pointer resolution when VHDL modules are linked together in the elaboration phase of VHDL simulation (the elaboration phase is known to people versed in art of VHDL simulation models). The elimination of the back annotation step saves a considerable amount of time.","The simulation may be initiated by a user, or could alternatively be run in a batch mode process such that no human intervention is required. The simulation may also output certain other files, such as a log file  or checkpoint file , for use by other downstream tools.","The present invention can be realized in hardware, software, or a combination of hardware and software. A system according to a preferred embodiment of the present invention can be realized in a centralized fashion in one computer system, or in a distributed fashion where different elements are spread across several interconnected computer systems. Any kind of computer system\u2014or other apparatus adapted for carrying out the methods described herein\u2014is suited. A typical combination of hardware and software could be a general-purpose computer system with a computer program that, when being loaded and executed, controls the computer system such that it carries out the methods described herein.","The present invention can also be embedded in a computer program product, which comprises all the features enabling the implementation of the methods described herein, and which\u2014when loaded in a computer system\u2014is able to carry out these methods. Computer program means or computer program in the present context mean any expression, in any language, code or notation, of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following a) conversion to another language, code or, notation; and b) reproduction in a different material form.","A computer system may include, inter alia, one or more computers and at least a computer readable medium, allowing a computer system, to read data, instructions, messages or message packets, and other computer readable information from the computer readable medium. The computer readable medium may include non-volatile memory, such as ROM, Flash memory, Disk drive memory, CD-ROM, and other permanent storage. Additionally, a computer readable medium may include, for example, volatile storage such as RAM, buffers, cache memory, and network circuits. Furthermore, the computer readable medium may comprise computer readable information in a transitory state medium such as a network link and\/or a network interface, including a wired network or a wireless network, that allow a computer system to read such computer readable information.","Although specific embodiments of the invention have been disclosed, those having ordinary skill in the art will understand that changes can be made to the specific embodiments without departing from the spirit and scope of the invention. The scope of the invention is not to be restricted, therefore, to the specific embodiments, and it is intended that the appended claims cover any and all such applications, modifications, and embodiments within the scope of the present invention."],"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 5","FIG. 1"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 6","FIG. 1"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7","b":"2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 10","FIG. 1"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 11","FIG. 1"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 12","FIG. 1"],"b":"2"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 13","FIG. 1"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 14","FIG. 1"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 16","FIG. 1"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 17","FIG. 1"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 18","FIG. 1"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 19","FIG. 1"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 20","FIG. 1"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 21","FIG. 1"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 22","FIG. 1"]}]},"DETDESC":[{},{}]}
