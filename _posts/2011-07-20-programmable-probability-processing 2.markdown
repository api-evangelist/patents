---
title: Programmable probability processing
abstract: An inference task is performed using a computation device having a plurality of processing elements operable in parallel and connected via a connectivity system. Performing the task includes accepting at the device a specification of at least part of the inference task. The specification characterizes a plurality of variables and a plurality of factors, each factor being associated with a subset of the variables. Each of the processing elements is configured with data defining one or more of the plurality of factors. At each of the processing elements, computation associated with one of the factors is performed concurrently with other of the processing elements performing computation associated with different ones of the factors. Messages are exchanged via a connectivity system. The messages provide inputs and/or outputs to the processing elements for the computations associated with the factors and provide a result of performing of the at least the part of the inference task.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09626624&OS=09626624&RS=09626624
owner: ANALOG DEVICES, INC.
number: 09626624
owner_city: Norwood
owner_country: US
publication_date: 20110720
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","STATEMENT AS TO FEDERALLY SPONSORED RESEARCH","BACKGROUND","SUMMARY","DESCRIPTION"],"p":["This application claims the benefit of and incorporates by reference each of the following:\n\n","This invention was made with government support under FA8750-07-C-0231 awarded by the Defense Advanced Research Projects Agency (DARPA). The government has certain rights in the invention.","This invention relates to programmable probability processing.","One approach to inference-based computation (e.g., Belief Propagation, BP) makes use of factor graphs, for instance, as described in Loeliger, \u201cIntroduction to Factor Graphs,\u201d , Jan. 2004. One graph-based inference approach is the Sum-Products (SP) approach, as described in the referenced paper. Another approach is the Min-Sum (MS) approach (also referred to as Max-Sum or Max-Product), which can be regarded as an approximation of the SP approach. A description of such algorithms may be found in H. Wymeersch, Cambridge University Press, Cambridge, 2007.","Referring to , an example of a portion of a factor graph  includes factor nodes - and variable nodes -. Factor node  implements a factor (e.g., a constraint) that depends on the variables A , B , and C associated with variable nodes -, respectively. In the SP approach, the factor node  receives messages from the adjacent variable nodes, and uses those messages to compute and emit output messages back to the variable nodes. In the SP approach, we use the notation {right arrow over (\u03bc)}(or more explicitly {right arrow over (\u03bc)}) to represent the message from the variable node  associated with variable A to factor node  associated with factor F . Similarly, the message passing back to the variable node is represented as (or more explicitly . For the factor graph shown in , the messages for factor node  are computed as follows:",{"@attributes":{"id":"p-0007","num":"0009"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"mrow":[{"msub":{"mover":{"mi":"\u03bc","mo":"\u2190"},"mi":"C"},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"c"}},{"munder":{"mo":"\u2211","mrow":{"mi":["a","b"],"mo":","}},"mo":"\u2062","mrow":{"mrow":[{"mi":"w","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["a","b","c"],"mo":[",",","]}}},{"msub":{"mover":{"mi":"\u03bc","mo":"->"},"mi":"A"},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"a"}},{"msub":{"mover":{"mi":"\u03bc","mo":"->"},"mi":"B"},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"b"}}],"mo":["\u2062","\u2062"]}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"\u2062","mi":"a"}}}]},{"mtd":[{"mrow":{"mrow":[{"msub":{"mover":{"mi":"\u03bc","mo":"\u2190"},"mi":"B"},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"b"}},{"munder":{"mo":"\u2211","mrow":{"mi":["a","c"],"mo":","}},"mo":"\u2062","mrow":{"mrow":[{"mi":"w","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["a","b","c"],"mo":[",",","]}}},{"msub":{"mover":{"mi":"\u03bc","mo":"->"},"mi":"A"},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"a"}},{"msub":{"mover":{"mi":"\u03bc","mo":"->"},"mi":"C"},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"c"}}],"mo":["\u2062","\u2062"]}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"\u2062","mi":"b"}}}]},{"mtd":[{"mrow":{"mrow":[{"msub":{"mover":{"mi":"\u03bc","mo":"\u2190"},"mi":"A"},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"a"}},{"munder":{"mo":"\u2211","mrow":{"mi":["b","c"],"mo":","}},"mo":"\u2062","mrow":{"mrow":[{"mi":"w","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["a","b","c"],"mo":[",",","]}}},{"msub":{"mover":{"mi":"\u03bc","mo":"->"},"mi":"B"},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"a"}},{"msub":{"mover":{"mi":"\u03bc","mo":"->"},"mi":"C"},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"c"}}],"mo":["\u2062","\u2062"]}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"\u2062","mi":"c"}}}]}]}}}},"The weights w(a, b, c) represent the factor, for example, as a probability distribution with all the values adding up to 1.0, of as another form of distribution, or as 0\/1 indicator values.","In the Max-Product approach, the summations are effectively replaced with max operations. The Min-Sum approach is effectively a logarithmic version of the Max-Product approach. The messages represent logarithmic messages, for instance, defined as {right arrow over (l)}\u2261\u2212log({right arrow over (\u03bc)}) (taking the logarithm element-wise). Similarly, the weights are defined as W (a,b,c)=\u2212log w(a,b,c). For the MS approach, the messages are computed as follows:\n\n()=min(()+()+()) \u2003\u2003(2a)\n\n()=min(()+()+()) \u2003\u2003(2b)\n\n()=min(()+()+()) \u2003\u2003(2c)\n","In the discussion below, we use the notation |A| to represent the number of values that the variable A can take on. In this notation, the number of terms in the sum for (c) is |A|\u00d7|B|. For instance, if each variable can take on one of 64 values, there are 4096 terms in the sum or min, which must be computed for each of the 64 output values, for a total of over 0.78 million terms to compute three output messages.","There is a need to accelerate computation of the messages for the purpose of accelerating inference computation, for example, based on factor graphs.","In one aspect, in general, a programmable computation device, which is for performing an inference task specified by a plurality of variables and a plurality of factors, each factor being associated with a subset of the variables, includes a plurality of processing elements operable in parallel, a connectivity system coupled to each of the processing elements, and a controller having an interface for a host system for accepting a specification of at least part of the inference task, and being coupled to the processing elements via the connectivity system. Each of the processing elements is configurable by the controller to perform a computation associated with one of the factors concurrently with other of the processing elements performing computation associated with different ones of the factors. Each of the plurality of processing elements is coupled to the connectivity system to exchange messages via the connectivity system. The messages provide inputs and\/or outputs to the computations associated with the factors and providing to the controller a result of performing of the at least part of the inference task.","Aspects can include one or more of the following features.","The specification of the inference task comprises a specification of a graph-based inference task, and each factor is associated with an element of a graph.","The connectivity system is configurable to provide connectivity between processing elements according to the graph.","The connectivity system provides at least one of a grid, a tree, and a chain connectivity between the processing elements.","Each processing element comprises a storage for a definition of a factor, and a storage for data associated with the inputs and\/or outputs of the computations.","Each processing element includes one or more computation units for performing a succession of parts of the computation associated with a factor defined by data in the storage for the definition of the factor.","Each computation unit comprises a combination unit for combining values accessed from the storage for the data associated with the inputs and\/or outputs.","The combination unit comprises numeric computation logic.","The combination unit comprises analog computation circuitry.","Each computation unit further comprises an accumulation unit for accumulating an output of the combination unit into values in said storage.","Each processing element comprises a plurality of the computation units.","Each of the computation units has a separate part of the storage for the data associated with the inputs and\/or outputs.","The storage for the definition of the factor is shared by the computation units.","In another aspect, in general, a method is directed to performing an inference task using a computation device having a plurality of processing elements operable in parallel and connected via a connectivity system. The method includes accepting at the device a specification of at least part of the inference task. The specification characterizes a plurality of variables and a plurality of factors, each factor being associated with a subset of the variables. Each of the processing elements is configured with data defining one or more of the plurality of factors. At each of the processing elements, computation associated with one of the factors is performed concurrently with other of the processing elements performing computation associated with different ones of the factors. Messages are exchanged via a connectivity system. The messages provide inputs and\/or outputs to the processing elements for the computations associated with the factors and provide a result of performing of the at least the part of the inference task.","Aspects can include one or more of the following:","Accepting the specification of the at least part of the inference task includes accepting said specification from a host at a controller of the device, and the method further comprises passing the result of the performing of the at least part of the inference task via the controller to the host.","The specification of the inference task comprises specification of a graph-based inference task, and each factor is associated with an element of a graph.","The inference task comprises a Belief Propagation task.","The messages represent probability distributions of the variables.","The method further comprises configuring the connectivity system is to provide connectivity between processing elements according to the graph.","The method further comprises configuring the connectivity system according to a result of a computation performed using the device.","The method further comprises providing at least one of a grid, a tree, and a chain connectivity between the processing elements via the connectivity system.","Each processing element comprises a storage for a definition of factor, and a storage for data associated with the inputs and\/or outputs of the computations","Configuring each of the processing elements with data defining one or more of the plurality of factors includes storing said data in the storage for the definition of a factor.","Each processing element includes one or more computation units.","Performing the computation associated with one of the factors includes performing using the computation units a succession of parts of the computation associated with a factor defined by data in the storage for the definition of the factor.","Each computation unit comprises a combination unit.","Performing the computation associated with one of the factors includes combining values accessed from the storage for the data associated with the inputs and\/or outputs.","The combination unit comprises numeric computation logic used in performing the succession of parts of the computation.","The combination unit comprises analog computation circuitry used in performing the succession of parts of the computation.","Each computation unit further comprises an accumulation unit.","Performing the computation associated with one of the factors includes accumulating an output of the combination unit into values in the storage for data associated with the inputs and\/or outputs of the computations.","Each processing element comprises a plurality of the computation units and performing the succession of parts of the computation includes performing said parts concurrently on multiple of the computation units.","In another aspect, in general, an apparatus for solving inference problems includes a programmable probability processing platform having a plurality of identical processing elements configured to operate in parallel. The processing elements being interconnected by a reconfigurable connectivity fabric.","In another aspect, in general, a method of solving inference problems includes solving a first inference problem on a programmable probability processing platform having a plurality of identical processing elements configured to operate in parallel and interconnected by a connectivity fabric having a first configuration; reconfiguring the connectivity fabric to have a second configuration, and solving a second inference problem on said programmable probability processing platform using the second configuration.","Other features and advantages of the invention are apparent from the following description, and from the claims.","1 Overview","Referring to , a reconfigurable processing system  includes a host system  (e.g., a conventional digital computer) which is connected via a data bus  to a programmable probability engine . The programmable probability engine  includes a processing unit  and a front end (e.g., a digital controller implemented on a field programmable gate array (FPGA)) , which is coupled to the bus , providing a means of communication between the processing unit  and the host system .","The probability engine  is programmable to implement various types of probability based processing, and in particular, is programmable to implement inference graphs (e.g., factor graphs), for instance to solve Bayesian inference problems. In an example of such a use, a specification of a factor graph  is created on the host system  and all or part of the graph specification  is passed to the probability engine  from the host system . In some examples, the graph is specified using an approach described in the co-pending application titled \u201c\u201d U.S. patent application Ser. No. 13\/006,060, filed Jan. 1, 2011, which is incorporated by reference.","In some examples, the probability engine  includes an analog processing unit  which is configurable to solve the graph , while in other embodiments digital numeric processing is used, or a combination of analog and numeric processing is used. It should also be understood that the graph  is not necessarily implemented and operated on as a whole by the processing unit . Rather, depending on the configuration of the processing unit , various portions (e.g., portion ) of the graph  can be processed at different times and\/or on different subsets of the processing unit  as is described in a later section.","2 Single Probability Processor Element","Referring to , one embodiment of a reconfigurable processing system  includes an processing unit  which includes a single probability processor element . In general, the probability processor element  is a special purpose processor specifically designed to perform computation for the Min-Sum or Sum-Product algorithm on individual factors in a factor graph. The probability processor element  is programmable in that it can perform this computation for an arbitrary factor over discrete variables.","The probability processor element  includes a sequencer  including an instruction memory , a factor table memory , N computation units (referred to herein as slices) , and N first-in-first-out (FIFO) micro-instruction queues  each corresponding to one of the N slices .","In general, the host system  analyzes a problem graph (as shown in , element ) and determines a sequence of computations which are necessary to compute the problem graph as well as necessary factor table records. The analysis can be accomplished, for example, by using an application programming interface (API) and a compiler designed specifically for the programmable probability engine . Based on the determined sequence of computations, the host system  transfers high level instructions into a RAM  along with the necessary factor table records if not already resident (e.g., from an earlier computation or from another prior configuration). The front end  reads the high level instructions from the RAM  using direct memory access (DMA) and provides them to the processing unit  via a host interface . The front end  also reads the factor table records from the RAM  and provides them to the processing unit  via the host interface .","The factor table records accepted from the host interface  are provided to the factor table memory . The high level instructions accepted from the host interface  are provided to the instruction memory  in the sequencer . The sequencer  fetches the high level instructions from the instruction memory  and parses them into micro-instructions which are provided to a local instruction sequencer associated with each of the N slices . In some embodiments, the local sequencer also provides memory addresses of records to the factor memory . The records at the provided memory addresses are fetched from the factor memory  and provided to the appropriate slice .","Collectively, the slices  perform belief propagation for one factor of a factor graph by performing message passing algorithms such as the Min-Sum, Sum-Product, and Mean-Field algorithms. In some examples, a single shared instruction sequencer  causes the slices  perform message passing algorithms while operating in lock step with one another, with each slice  operating on distinct data. In other examples, each slice  has its own instruction sequencer  along with its own instruction memory . In such a case, the slices  may operate more independently of each other, for example, synchronizing with each other for inter-slice communications. A detailed description of how a single slice  performs a message passing algorithm is presented below. The results produced by the slices  are provided to the host interface  which in turn provides the results to the host system  via the front end .","In some examples, the factor table memory  maintains a cache of records such that previously used records do not need to be reloaded from the host system . The cache of records can be maintained as long as adequate space exists in the factor table memory .","2.1 Slice Architecture","Referring to , one example of an architecture of a single slice  is designed to compute the terms of message computations. The slice  includes an address generator , an input message memory , an ALU , and an output message memory .","In general, the slice  receives an instruction from the FIFO micro instruction queue (shown in , element ) along with a record from the factor table memory (shown in , element ). The address generator  provides a mapping between values in the factor memory  and locations in the input and output message memories , .","The input and output message memories ,  store the inputs, intermediate values, and output of the computation of belief-propagations messages. Messages stored in the input message memory  are passed into the ALU  along with messages stored in the output message memory . The ALU  applies an algorithm (e.g., the Min-Sum algorithm) to the messages and produces a result which is stored in the output message memory . After performing a number of iterations of the message passing algorithm, the results stored in the output message memory  are passed back to the host system (shown in , element ) through the host interface (shown in , element ).","In some examples, the input and output message memories ,  use digital logic. In other examples, the memories ,  use store values in analog form.","Referring to , pseudocode is presented which implements an iterative message passing algorithm that solves for the factor F shown in . The pseudocode can be implemented by the detailed slice architecture shown in .","2.2 Detailed Slice Architecture","Referring to , a detailed version of the slice architecture shown in  is shown along with the factor table memory . The slice architecture includes input and output message memories , , and an ALU . An address unit  provides a mapping between values in the factor table memory  and locations in the message memories , . Generally, the factor table memory  includes a set of records . Each record  corresponds to an iteration of the loop over i at lines - in the pseudocode. A sequencer or controller (not shown in ) causes successive records  to be accessed from the factor table memory . For each record , a combination unit  of the ALU  performs the computations of lines - of the pseudocode, and an accumulation unit  performs the computations of lines - of the pseudocode. The address unit  maps each index into two corresponding memory locations in the message memory: an input message location and an output message location. For example, for the factor F shown in , the address unit  maps an index ato the address addr({right arrow over (l)}(a)) for the input message and addr((a)) for the output message (where addr( ) is understood to mean the address of the storage location for that message value). Note that the signal paths between the message memory  and the combination unit  are unidirectional from the memory to the combination unit , while the signal paths between the memory  and the accumulation unit  are bidirectional so that for each record  of the factor table memory , the current values of the output messages are read in, and the minimum of the read value and the newly computed value is written back. By iterating over all the elements (a,b,c) of the factor, the three output messages are computed.","2.2.1 Arithmetic Logic Unit","Referring to , an implementation of the ALU includes a summation unit , which accepts the input message values and the weight and outputs the sum of its inputs. Each of the weights is subtracted in a corresponding adder  so that each of the three outputs of the combination unit effectively excludes a corresponding message input. The accumulation unit makes use of three minimum units , each of which accepts the memory value and provides the minimum of the memory value and the corresponding newly computed value.","Referring to , in some implementations, multiple ALUs are implemented and executed in parallel. For instance ALUs -(i.e., two or more ALUs) each receive a part of (i.e., a disjoint exhaustive subset) the values (a,b,c) for the factor. The input message values are replicated in each copy of the memory -so that each ALU can perform a local read of the input message value. After all the elements of the factor are evaluated, the output messages are typically not fully computed. For example, for a particular entry a, separate partial computations of the output message (a) are present in the message memories -. In one implementation further data paths (not shown) link the accumulation units to the message memory so that in a sequence of iterations (e.g., log(n) where n is the number of ALUs), the absolute minimum is computed across the ALUs.","In some embodiments, a host system controls the operation of the system, including loading the factor memory , configuring the sequencer to coordinate operation of the ALUs and the address units, and loading an unloading message values from the message memory.","In some examples, the factor memory  does not necessarily hold an exhaustive set of tuples (a,b,c,w). For example, a set of tuples (a,b,c) for which a fixed known weight (e.g., 0.0) is encoded, and the sequencer is configured to convert the encoding to the sequence of (a,b,c,w) tuples. Other forms of compressed representation of the factors may also be used.","In some examples, different inputs have different numbers of possible values, and therefore different numbers of bits may be needed to represent the indexes. As an example, a variable that can take on 16 values only requires at most 4 bits to represent each index, but a variable that can take on 1024 values may take 10 bits. Therefore, even with a maximum of three variables per record in the factor memory, different numbers of bits may be allocated for each index.","In the example above, the factor is assumed to have three inputs, which corresponds to the hardware architecture of the ALUs which expect three inputs and a weight. For a factor with only two inputs, one approach is to configure the combination unit to ignore one of the inputs, or alternatively for the message memory to provide an input (e.g., 0.0) that does not affect the combination.","However when a factor has more inputs than the number for which the ALU is configured, one approach is to use an iterative and pipelined approach. For example, consider a factor that has six variables, and therefore each element of the factor is defined by a tuple (a,b, . . . , f,w). Referring to , one approach is to encode such an element in a succession of records ,  in the factor memory . Referring to , operation of the combination unit  can be understood by considering the first cycle in which ((a), (b), (c)) are read from the message memory. These values are summed with the weight wand stored (i.e., added to a zeroed value) in a temporary register. The input message values are added to a FIFO. On the second cycle, values ((d), (e), (f)) are read from the message memory. The values are then added to the value in the temporary register to yield the value  as defined in the single cycle case. The values ((d), (e), (f)) are pushed into the FIFO . In the second cycle, the values ((a), (b), (c)) are read from the output of the FIFO and subtracted from  to produce (, , ). On the third cycle the values ((d), (e), (f)) are read from the FIFO and the values (, , ) are output by the combination unit. Note that in the third cycle, values ((a), (b), (c)) can be processed in a pipelined manner without affecting the outputs (, , ).","Operation of the accumulation unit is delayed so that in the second cycle, the output messages for ((a,b,c) are updated, and in the third cycle the output messages for (d,e,f) are updated.","Note that this same approach can be used for situations in which more than two records per factor element. Generally, for M records per element, the accumulation unit is delayed by M\u22121 cycles in a pipelined manner.","3 Multiple Probability Processor Elements","In some examples, a control graph  can be a specification of another inference graph which is used to optimally determine how the inference graph  is computed by the processing unit .","Referring to , in another embodiment of a reconfigurable processing system , the architecture of the processing unit  is extended to incorporate multiple probability processor elements , with each probability processor element  operating in parallel. The probability processor elements  are connected via a reconfigurable connectivity fabric  over which messages are passed between the data memories of individual probability processor elements . When computing a graphical-model, the set of probability processor elements  operates on a portion of the model at a time (assuming a large model). At any given time, each probability processor element  performs the computation associated with one node in the graph. Each probability processor element  can be used to perform the computation for a number of different nodes as different portions of the model are loaded into the programmable probability engine .","3.1 Interconnect","The connectivity fabric  is configured (e.g., by the host system  or a controller  located on the programmable probability engine ) to correspond directly to the structure of the graphical model. For example, in an image processing application, graphical models typically correspond to a two-dimensional grid, or perhaps a hierarchy of such grids. For this type of processing, the co ectivity fabric  is configured to mimic this structure so that communication bet een probability processor elements  corresponds directly to the communication be ween nodes in the graphical model required for message-passing based inference algorithms. Such a configuration allows for high-bandwidth parallel communication between the probability processor elements  without bottlenecks.","Note that for a given connectivity structure, there may be many distinct inference problems that can be implemented. For example, a linear chain structure can be used to perform inference on a great many models in the form of a time-sequenced Markov model. Or, a hierarchy of two-dimensional grids can be used to perform inference for a wide variety of image processing models.","Some common configurations of the connectivity fabric  are: butterfly network, fully connected, grids, chains, trees, fat trees etc. In some examples, the configurable interconnect plane  includes storage for intermediate analog or digital values.","For some types of graphical models, the connectivity fabric may change frequently when operating on different portions of the graph. For other types of graphical models, such as those representing arrays of image pixels or hidden Markov models, the connectivity may not need to change when operating on different portions of the graph.","In some examples, the processors associated with nodes for which the connectivity changes must complete their processing task and synchronize their data prior to the reconfiguration of connectivity.","In some examples, due to the overhead of reconfiguring the connectivity fabric , it may be necessary to allow changes in connectivity to be preloaded while the previous computation is still underway, allowing a rapid switch to the new configuration.","In some examples, operation of the parallel probability processor elements  is a mixture of asynchronous and synchronous operation. Thus, reconfiguration of the connectivity fabric  needs to be synchronized. In particular, all processing elements  involved with the portions of the connectivity fabric  being modified need to reach an appropriate synchronization point before the reconfiguration can occur.","3.2 Tiled Probability Processor Element Architecture","Generally, the processing unit  may have different sets of probability processor elements , each with different characteristics most suited to different types or topologies of factor graphs. For example, one type of probability processor element  may be best suited to graphs that are generally grid-like, while another type of probability processor element  may be best suited for tree-like graphs. In some examples, certain of the probability processor elements  may be particularly tailored to specific types of problems. An example of such a specific problem relates to LDPC decoding as described in the co-pending application international application number PCT\/US11\/20794 titled \u201cBELIEF PROPAGATION PROCESSOR.\u201d In some examples, the probability processor elements  use log-based representations and implement factor graph message passing. In some examples, certain of the probability processor elements  may be implemented using digital logic, while others of the probability processor elements  may be implemented using analog logic.","3.3 Execution Control","As is common in many parallel systems, it is desirable to ensure that each of the processing elements  is optimally utilized. Controlling execution by scheduling, load balancing, and pipelining are ways in which such an optimization can be accomplished.","In some examples, an overall problem graph may have different parts or regions which are not necessarily addressed concurrently. In some such examples, the controller  or host system  follows a predetermined plan or schedule, for example, performing computation using a first part of a graph, and proceeding to another part of the graph only after an intermediate result is obtained. The sequence of iterations results in a convergence to an overall solution of the problem. For example, one part of a graph represent decoding constraints of an LDPC code, while another part of the graph may represent another form or constraint, for instance, based on inter-symbol interference not addressed by the code, and yet another part of the graph may related to adaptation of a channel model to be used in signal acquisition stage. The plan or schedule is then used to coordinate operation of the parts. In some examples, the control is implemented using programmable logic (e.g., a software program), which may involve numerical computations.","The type of schedule is chosen by the user and defined in the source code that specifies a graphical model (or a default schedule is used). Design software (e.g., DMPL software and compiler) combines the graphical model connectivity with a choice of schedule to indicate the specific order of processing. Since the processing unit  allows parallel processing such that many nodes in the graph may be updated at once, instead of generating a single ordered sequence, the DMPL compiler can define a partially ordered sequence of updates, allowing as many updates as possible to be done in parallel. The choice of schedule type, under the control of the user, affects how much parallelism can be exploited.","For a given schedule, each processing operation must be mapped to a given probability processor element  at a given time. This mapping is also a function of the DMPL compiler. The compiler incorporates knowledge of the number of probability processor elements , the available configurations of the connectivity plane, the amount of local and shared storage, and other factors, to choose the mapping. The mapping determines the sequence of instructions provided to each probability processor element , the sequence that these instructions, as well as the combo tables are preloaded onto the probability processor elements , the necessary connectivity plane configuration changes, and the sequence in which data is transferred to and from the probability processor elements . The mapping is explicitly aware of the caching that can be done, avoiding unnecessary transfers of data.","In some examples, efficiency can be improved by using dynamically updating schedules. For example, the host system  or the controller  may optimally select portions of the graph to assign to different probability processor elements . Intermediate values computed for one portion of a graph can be used as indications of which portions of the graph should be solved next such that optimal progress is made toward the overall solution. In other examples, run-time decision making related to which parts of a graph to address during the course of execution is accomplished using a further graph-based computation which is performed by a controller  located on the programmable probability engine . For instance, a decision of which part of a graph to address may itself be represented as a Bayesian inference control problem  which is assigned to the probability processor elements  under the control of the controller .","Another method for optimally utilizing the probability processor elements  is balancing the computational load on each probability processor element . For example, in an arbitrary factor graph there can be a large disparity in the computational complexity between various nodes. As a result, some probability processor elements  may be given a number of factors with small computation required, while other factors may be given a single factor requiring a large computation. The host system can optimally assign factors to computation elements while taking into account the need to balance the load as much as possible.","Another method for optimizing the utilization of the probability processor elements  is to allow the host system  to treat the processing as a pipeline, where at any given time tasks are being fetched ahead of time, fed to the probability processor elements , other tasks are being executed, and the results of already executed tasks are being read out.","Further details regarding one or more implementations of systems such as those described above are provided in the co-pending provisional application titled \u201cPROGRAMMABLE PROBABILITY PROCESSING PLATFORM WITH RECONFIGURABLE CONNECTIVITY FABRIC.\u201d","3.4 Programming Language\/Compiler","In some examples, inference graphs are specified using an application programming interface (API) referred to as DMPL. DMPL is used to design arbitrary graphical models by specifying variables of the model and the factors that relate the variables.","DMPL allows for the specification of the solver schedule which can be a pre-defined schedule (e.g., Sum-Product, Min-Sum, Gibbs sampling, etc.) or a custom, user-defined schedule.","Some pre-defined schedules are conditional on the topology of the inference graph. For example, a tree\/sequential schedule examines each graph and sub-graph to determine which schedule to use for it. If the graph or sub-graph is a tree, then a tree schedule is used for that portion of the graph (the optimal schedule for a tree), otherwise a sequential schedule is used for that portion of the graph.","Once the inference graph is specified, DMPL compiles the factor graph such that the programmable probability engine  can execute them. The output of the compiler includes control software for the host system  and data\/sequencing instructions for the programmable probability engine .","4 Alternatives","While the above-described reconfigurable processing system architecture utilizes an external host processor to coordinate the programmable probability engine computation and to perform any additional processing beyond the capabilities of the programmable probability engine as currently defined, a more general architecture could include one or more general purpose processors, dedicated to the programmable probability engine. In addition, to simply performing more local coordination of the programmable probability engine's operation and reducing off-chip I\/O, local general purpose processors can facilitate support for a broader class of inference algorithms. Some specific algorithms, and the means by which a general purpose processor can augment the computation by the probability processor elements, are described as follows.","In the examples described above, the host system is external to the programmable probability engine. However, in some examples, one or more CPUs may be integrated into the programmable probability engine, acting as an on-chip host system. Furthermore, in some examples, one host system can serve as a host to multiple programmable probability engines.","Particle belief propagation is a form of belief propagation that can be used to support continuous variables or variables with very large domains. In this case, instead of passing an entire probability distribution as a message, the messages are a series of values that represent the importance-weighted message at points randomly sampled from the domain of the variable. The belief propagation updates using these messages are similar to ordinary belief propagation, and as such could be performed using the programmable processor elements with little change. But there are additional aspects of what must be computed that could benefit from support by a general-purpose processor. Specifically, there are two such aspects of the computation. First is the periodic resampling of the randomly chosen sample points for each variable. This computation can involve repeated evaluation of functions that defines factors in the graph (for example, when resampling using the Metropolis-Hastings algorithm). For a user-specified factor-graph, these functions may be user specified and involve arbitrary computation. Second is the regeneration of the factor table after this resampling. One method of doing this is to recalculate the factor-table for a given factor by evaluating its factor function at the new sample points. This also may involve arbitrary user-specified computation. In both cases, a general purpose processor augmenting the probability processor elements can perform these computations. In one approach, these processors would perform resampling of variables and recalculation of factor tables, and then write the new factor table values into the factor-table memory of the appropriate probability processor element as needed. In one approach, this calculation is performed while a probability processor element continues to perform processing on portions of the factor graph.","Another class of algorithms that could benefit from general purpose computation are sampling-based methods. Common sampling methods are Gibbs sampling and the Metropolis-Hastings algorithm. Sampling based algorithms can be used to perform inference on a factor graph. Typically Gibbs sampling is used in this case (sometimes in combination with the Metropolis-Hastings algorithm). Sampling-based algorithms can also be used to perform inference on models specified by a stochastic generative program. In this case, the Metropolis-Hastings algorithm is used as one aspect of the inference computation. In the case of factor graphs using continuous or large-domain variables, and in the case of stochastic generative programs, inference computation includes performing arbitrary computation based on a user-specified program (either the factor function, in the former case, or the stochastic generative program itself, in the latter case). In both cases, general purpose processors as part of the programmable probability engine can be used to perform these computations. In some cases sampling based methods, such as for performing inference on stochastic generative programs, can be combined with belief propagation, such as performed by the probability processor elements as currently defined. Models that combine both generative programs and undirected graphical models (factor graphs) are possible, and in such cases, it would be appropriate to combine the two approaches, in which case the programmable probability engine belief-propagation computations could operate simultaneously with other computations used for other portions of the model.","Sampling based methods, particle belief propagation, as well as other forms of non-parametric belief propagation (particle belief-propagation is a form of non-parametric belief propagation), all involve random sampling for at least a portion of the computation. Random sampling generally requires mechanisms to generate random or pseudo-random numbers, distributed according to some set of distributions. To efficiently perform these types of computation, one form of probability processor engine would have dedicated hardware for generation of random numbers, or more generally for generating randomly distributed values according to a probability distribution selected among a set of available distributions. Hardware support for this could be a pseudo-random bit-sequence generator, a random bit-sequence generator (based on a form of physical randomness), or could involve direct generation of values from a distribution. Hardware support for uniform distributions, normal distributions, or exponential distributions would facilitate efficient implementation of these algorithms.","For the programmable probability engine including multiple analog processor elements, an alternative embodiment includes direct support for Gaussian messages (parameterized by a mean and variance [or equivalent], or by a joint mean and covariance matrix [or equivalent]). It may also support messages based on mixtures of Gaussians (messages parameterized by a series of Gaussian messages combined with a mixture weight associated with each). It may also support other parameterized message representations. In the case of Gaussian messages, it may support special-purpose processing for Gaussian or linear factors and for variable nodes (linear factors include sum or difference factors, and multiplication by a constant scalar or matrix). For supporting more general factors that are not as easily computed, the programmable probability engine can employ stochastic methods for performing the factor computation. Graphs with such factors would make use of mechanisms similar to those described above for sampling based algorithms, while Gaussian factors, linear factors, and variables, would make use of special-purpose hardware in the probability processor elements.","In the above description some examples of probability processor elements are described as being implemented using analog electronics or a combination of analog and digital logic. However, in some examples, the probability processor elements can be implemented using digital electronics. In an Analog Logic implementation of programmable probability engine, Min-Sum or Sum-Product computations performed by each probability processor element use Analog Logic computation elements. In a digital implementation, this processing uses digital computation elements.","In some examples, the programmable probability engine includes a shared memory for storing factor tables which are shared among a large number of the parallel probability processor elements. In many cases many nodes in a graphical model may use the same factor function. If the associated combination table is sufficiently large, then it would be inefficient to independently store a copy of the table in the local memory of each probability processor element. In this case, it is proposed that a shared memory be available to hold such tables. In operation, all of the probability processor elements making use of a given table in shared memory would be configured to operate in synchrony during the time this table is in use. This allows the data from the table to be read over a shared memory bus and used simultaneously by all probability processor elements that require its value.","The specialized programmable probability engine compiler is responsible for determining the criteria by which shared memory is used to store combo tables. It balances the overall storage requirements with any performance tradeoff associated with reading shared memory or synchronizing probability processor elements. For example, if multiple tables are stored in shared memory that are to be used at the same time by different subsets of probability processor elements, there can be some performance degradation due to contention for the shared memory bus.","In embodiments where at least part of the probability processing engine is implemented using analog electronics, data is converted between digital and analog form. In some examples, a DMA controller included in the front end incorporates a data conversion unit that can translate data between the analog and digital domains. Specifically, the DMA controller can incorporate a bank of DACs for translating data from the digital to the analog domain, and a bank of ADCs for translating data from the analog to the digital domain.","In some examples, each probability processor element includes local operating memory which is maintained by a memory hierarchy scheme, allowing for storage of data at several levels.","The internal representation of messages can be a logarithmic representation of probability; either a log-likelihood ratio (LLR) for binary variables or a potential (log p) for multi-valued variables. By default the corresponding representation of this data for external storage is in the same format. A representation conversion step may also be included to allow representation in other formats.","It is to be understood that the foregoing description is intended to illustrate and not to limit the scope of the invention, which is defined by the scope of the appended claims. Other embodiments are within the scope of the following claims."],"GOVINT":[{},{}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0049","num":"0051"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0050","num":"0052"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0051","num":"0053"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0052","num":"0054"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0053","num":"0055"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0054","num":"0056"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0055","num":"0057"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0056","num":"0058"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0057","num":"0059"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0058","num":"0060"},"figref":"FIG. 9B"},{"@attributes":{"id":"p-0059","num":"0061"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
