---
title: Markup compiler that outputs MIDlets
abstract: A computing application for a mobile information device is generated from An extensible markup language, MIDML, in which different types of tags correspond to different application functions. A command line compiler parses the MIDML specification, reading the tags in specialized readers, which are then accessed by generators of specialized objects for an object model using different generators for each type. A predefined set of tags is extendible by the application developer. The generation process results in Java source code, which is then compiled into a MIDlet and packaged into a JAR file and a JAD file.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07565647&OS=07565647&RS=07565647
owner: Sun Microsystems, Inc.
number: 07565647
owner_city: Santa Clara
owner_country: US
publication_date: 20030123
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","REFERENCE TO COMPUTER PROGRAM LISTING APPENDICES","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","Alternate Embodiment","Appendix 1","Appendix 2","Appendix 3","Appendix 4"],"p":["This Application claims the benefit of Provisional Application No. 60\/366,890, filed Mar. 22, 2002.","This Application is related to the following Applications filed on even date herewith: application Ser. Nos. 10\/349,005, now abandoned, entitled \u201cExtensible Framework for Code Generation from XML Tags\u201d; 10\/348,893 patented (U.S. Pat. No. 7,305,671), entitled \u201cConversion of an Object Model to a Source File Generation Model\u201d; 10\/349,004, patented (U.S. Pat. No. 7,512,932), entitled \u201cLanguage and Object Model for Describing MIDlets\u201d; and 10\/349,010, now abandoned, entitled \u201cOn-Demand Creation of MIDlets\u201d.","Computer program listing appendices are submitted herewith on one compact disc and one duplicate compact disc. The total number of compact discs including duplicates is two. The files on the compact disc are ASCII text files in which the characters are displayed as their corresponding values in hexadecimal format. The root folder contains the file 45439LST (which includes listing #1 through and including listing #43) of Jul. 13, 2006 and of length 46,374 bytes.","The files are referred to herein as listings 1-43 respectively. The material on the compact discs is incorporated by reference herein.","1. Field of the Invention","This invention relates to communication between a host server and a mobile information device. More particularly, this invention relates to improvements in the provision of applications and resources to a mobile information device by a host server.","2. Description of the Related Art","The meanings of acronyms and certain terminology used herein are given in Table 1 and Table 2. Sun, Sun Microsystems, the Sun logo, Java, J2EE, J2ME, and J2SE are trademarks or registered trademarks of Sun Microsystems, Inc. in the United States of America and other countries. All other company and product names may be trademarks of their respective companies.",{"@attributes":{"id":"p-0010","num":"0009"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"API","Application programming interface"]},{"entry":[{},"CISC","complex instruction set computer"]},{"entry":[{},"CLDC","connected, limited device configuration"]},{"entry":[{},"DOM","document object model"]},{"entry":[{},"GSM","global system for mobile communication"]},{"entry":[{},"HTTP","hypertext transfer protocol"]},{"entry":[{},"IDE","Integrated development environment"]},{"entry":[{},"J2EE","Java 2 Enterprise Edition"]},{"entry":[{},"J2ME","Java 2 Micro Edition"]},{"entry":[{},"J2SE","Java 2 Standard Edition"]},{"entry":[{},"JAD","Java application descriptor"]},{"entry":[{},"JAM","Java Application Manager"]},{"entry":[{},"JAR","Java archive"]},{"entry":[{},"JAVAC","Java compiler"]},{"entry":[{},"JAXP","Java API for XML Processing"]},{"entry":[{},"MIDML","mobile information device markup language"]},{"entry":[{},"MIDP","mobile information device profile"]},{"entry":[{},"OTA","over the air user initiated provisioning for MIDP"]},{"entry":[{},"PNG","portable network graphics"]},{"entry":[{},"RISC","reduced instruction set computer"]},{"entry":[{},"RTL","run time library"]},{"entry":[{},"SDK","software development kit"]},{"entry":[{},"URL","uniform resource locator"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0011","num":"0010"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CLASSPATH","A fundamental definition in Java environ-"]},{"entry":[{},"ments, informing the Java virtual machine"]},{"entry":[{},"where to search for Java classes."]},{"entry":["Java Service","An end-user service that is made up of at"]},{"entry":[{},"least one client-side component written"]},{"entry":[{},"in Java. Additional server-side compo-"]},{"entry":[{},"nents, servers, software or otherwise can"]},{"entry":[{},"also be part of the service."]},{"entry":["MIDlet","A MTDP compliant application"]},{"entry":["MIDML Application","A set of MIDML files structured as an ap-"]},{"entry":[{},"plication to be generated as a MIDlet"]},{"entry":["MIDP Device","A device running CLDC with MIDP"]},{"entry":["MIDSP","MIDML Java code embedding extensions"]},{"entry":["use case","A computer software product methodology"]},{"entry":[{},"used in system analysis to identify,"]},{"entry":[{},"clarify, and organize system require-"]},{"entry":[{},"ments."]},{"entry":["Widget","A small program that is written in order"]},{"entry":[{},"to implement the appearance and behavior"]},{"entry":[{},"of an element of a graphical user inter-"]},{"entry":[{},"face."]},{"entry":["JAVAX","Javax is a common package name for stan-"]},{"entry":[{},"dard Java extensions."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The use of mobile and portable wireless devices has expanded dramatically in recent years. Many such devices having varying functions, internal resources, and capabilities now exist, including, but not limited to mobile telephones, personal digital assistants, medical and laboratory instrumentation, smart cards, and set-top boxes. All such devices are collectively referred to herein as mobile information devices. They tend to be special purpose, limited-function devices, rather than the general-purpose computing machines that have been previously known. Many of these devices are connected to the Internet, and are used for a variety of applications, such as banking and financial transactions, ticketing applications, wireless collaboration, and interactive games. Furthermore, in modern networks, such as GSM networks, an increasing variety of mobile information devices supports remote management and configuration. For example, using existing over-the-air protocols, it is possible to download data to memory remotely, and to reconfigure mobile information devices, such as mobile telephones.","A specification known as the Mobile Information Device Profile defines a set of Java application programming interfaces that provide an application run time environment for mobile information devices, such as mobile telephones. MIDP is defined in Mobile Information Device Profile (JSR-37), JCP Specification, Java 2 Platform, Micro Edition, 1.0a (Sun Microsystems Inc., Palo Alto, Calif., December 2000), and is also referred to herein as \u201cMIDP-1.0\u201d.","MIDP builds on the Connected Limited Device Configuration (CLDC) of the Java 2 Platform, Micro Edition (J2ME) (available from Sun Microsystems Inc., Palo Alto, Calif.). CLDC and J2ME specifically address the devices used in the vast market, which covers mobile information devices ranging from small devices, such as smart cards or pagers, to powerful set-top boxes. CLDC technology includes a virtual machine (KVM), which is a small Java virtual machine that is adapted to the constraints of small mobile information devices. CLDC is suitable for devices with 16\/32-bit RISC\/CISC microprocessors\/controllers, having as little as 160 KB of total memory available, as little as 128 KB of which can be reserved for the storage of the virtual machine and its libraries. MIDP applications that use the MIDP and CLDC APIs are known as MIDlets.","Other documents relevant to this invention include the following publications, available from Sun Microsystems, Inc.: Java 2 Platform Micro Edition, Wireless Toolkit; Over The Air User Initiated Provisioning Recommended Practice Addendum to the Mobile Information Device Profile; Connected Limited Device Configuration Specification; Java Servlet Specification; and JavaServer Pages Specification.","Notwithstanding the existing technology of MIDP and CLDC, there remains a need for content and service providers to more easily create, modify and update MIDlet applications that can be requested by mobile information device for download. An unmet need also exists for content providers to easily port their content to the MIDP environment. Existing tools allow programmers to use integrated development environments and compilers to statically generate applications. However, these applications then need to be manually moved to a location accessible by a MIDP platform.","According to the invention, an infrastructure is provided for creating applications for mobile information devices, using a tag-based markup language. Developers can use the markup language to define applications and content based on easily manipulated textual tags, rather than having to write specific code. A compiler, which is controllable via a command line interface, processes the tags in several phases. Initially, the input is parsed in order to check for errors. Next a hierarchical object model of the application is populated with objects. The compiler then creates source code files and supporting resource files (such as images) corresponding to the objects in the hierarchy. The compiler finally produces the application for mobile information devices by compiling, preverifying and packaging the source files and resources in an archive file, along with a corresponding application descriptor file. This archive file can then be downloaded to and run by any suitable mobile information device.","In one embodiment, for each type of tag provided by the extended markup language, the compiler has two specific components: a reader, for reading the tag and appropriate elements accompanying it from the document written in the extended markup language into the objects in memory; and a code-generating class for each object type. The readers and generators are registered in a \u201cfactory\u201d, to be instantiated as required in processing extended markup language files. This model enables the application capabilities of the system to be easily extended, simply by adding new tags, readers and code generators to the existing factory set.","In embodiments of the invention described herein, the extended markup language is based on XML, and is referred to as MIDML.","The invention provides a method for generating a computing application for a mobile information device, which is carried out by receiving a specification of the application in a markup language, wherein the specification includes tags of the markup language that correspond to functions of the application, parsing the tags to create a descriptor object model having objects that implement the functions, and processing the objects to generate executable code for the application.","According to one aspect of the method, a portion of the tags are user-definable.","According to a further aspect of the method the tags and the objects belong to different tag types and different object types respectively, and wherein parsing the tags is carried out by providing a first set of respective readers for the different tag types to populate the objects corresponding to the different object types, and wherein processing the objects is carried out by providing a second set of respective generators for the different object types to generate elements of the executable code corresponding to the different object types.","Another aspect of the method includes adding a new tag type to the set of available tag types, adding a new reader to the first set and adding a new generator to the second set, to enable generation of an element of the executable code corresponding to the new tag type.","Still another aspect of the method processing the objects includes creating a generation object model according to the specification, and generating source code using the descriptor object model and the generation object model.","According to still another aspect of the method, parsing the tags, creating a generation object model, and generating source code, are performed responsively to a command line directive.","According to an additional aspect of the method, processing the objects also includes compiling the source code into object code.","According to yet another aspect of the method, the generation object model is specified by a tag descriptor of a project descriptor object.","According to yet another aspect of the method, compiling the source code is performed using a build tool as a wrapper for a compiler of the source code.","According to an additional aspect of the method, generating source code is performed using a generation object factory that produces generation objects.","According to yet another aspect of the method, generating source code is performed by using the generation objects to generate class files, wherein the source code is Java source code.","One aspect of the method includes preverifying classes of the class files.","Still another aspect of the method includes packaging the executable code into an archive file.","According to an additional aspect of the method, packaging the executable code is carried out by preparing an application descriptor file, and including a portion of the application descriptor file in the archive file.","According to one aspect of the method, the application descriptor file is a JAD file.","According to yet another aspect of the method, parsing the tags includes reading different ones of the tags with different readers.","According to one aspect of the method, parsing the tags is performed using a descriptor element factory.","According to another aspect of the method, parsing the tags also includes generating a plurality of descriptor elements as a composite tree structure using the descriptor element factory.","According to a further aspect of the method, the descriptor element factory operates using a MDOM builder to produce a MDOM tree.","According to another aspect of the method, parsing the tags also includes generating a plurality of descriptor elements by dynamically binding data of the objects and linking the objects as a composite tree structure.","Another aspect of the method parsing the tags includes verifying the specification against schema definitions of the markup language.","According to a further aspect of the method, the descriptor object model is arranged as a hierarchical tree.","According to another aspect of the method, the markup language includes a plurality of schemas, and a root element. The schemas can define widgets, global variable elements, data types that can be used by other data types, and operations that are selected from the group consisting of timer operations, servlet operations, link operations, and signal operations.","According to one aspect of the method, the operations comprise event-handlers.","According to another aspect of the method, one of the schemas defines a resource embedding mechanism including an image element tag, wherein processing the objects also includes generating an archive file, and responsively to the image element tag, statically embedding an image resource in the archive file.","According to a further aspect of the method, the tags comprise an assignment tag that specifies an assignment operation of a MIDML language element.","The invention provides a computer software product, including a computer-readable medium in which computer program instructions are stored, which instructions, when read by a computer, cause the computer to perform a method for generating a computing application for a mobile information device, which is carried out by receiving a specification of the application in a markup language, the specification including tags corresponding to functions of the application, parsing the tags to create a descriptor object model having objects that implement the functions, and processing the objects to generate executable code for the application.","The invention provides a data processing system for generating a computing application for a mobile information device, including a computer readable memory has a data structure stored therein, the data structure including a parser that accepts a specification of the computing application written in a markup language has tags, and outputs a plurality of objects according to a descriptor object model, the objects including a project descriptor object, a code generator linked to the parser that accesses a generation object model according to a specification of a project descriptor object and produces source code, and a compiler accepting the source code for compilation into object code.","According to a further aspect of the data processing system, the compiler includes a verification module for preverifying classes of the source code.","According to still another aspect of the data processing system, the data structure also includes a packer for packaging the object code into an archive file.","According to an additional aspect of the data processing system, the packer is configured to include application descriptor information in a manifest of the archive file.","According to one aspect of the data processing system, the data structure also includes a build tool that wraps the compiler therein.","According to another aspect of the data processing system, the data structure is activated responsively to a command line directive.","According to a further aspect of the data processing system, the data structure also includes a generation object factory that produces generation objects, the generation objects is accepted by the code generator.","According to yet another aspect of the data processing system, the data structure also includes a descriptor element factory that produces a plurality of descriptor elements, the descriptor elements is used by the parser.","According to yet another aspect of the data processing system, the tags belong to different tag types and the objects belong to different object types, and wherein the parser is adapted to construct a first set of respective readers for the different tag types to populate the objects corresponding to the different object types, and the code generator includes a second set of respective code generators for the different object types to generate elements of the source code corresponding to the different object types.","According to still another aspect of the data processing system, the parser is adapted to accept a new tag type in addition to available tag types, and to add a new reader to the first set and to add a new code generator to the second set, to enable generation of an element of the source code corresponding to the new tag type.","According to still another aspect of the data processing system, the descriptor elements are arranged as a composite tree structure.","According to an additional aspect of the data processing system, data structure also includes a MDOM builder, wherein the descriptor element factory operates using the MDOM builder, and the composite tree structure is a MDOM tree.","According to one aspect of the data processing system, the data structure also includes a subprogram for verifying the specification of the computing application against schema definitions of the markup language.","According to another aspect of the data processing system, the project descriptor object also includes a data wrapper object adapted to an application descriptor file.","According to a further aspect of the data processing system, the application descriptor file is a JAD file.","According to yet another aspect of the data processing system, the descriptor object model is arranged as a hierarchical tree.","According to still another aspect of the data processing system, the generation object model is specified by a tag descriptor of the project descriptor object.","According to an additional aspect of the data processing system, the markup language includes a plurality of schemas, and a root element.","According to one aspect of the data processing system, one of the schemas defines a resource embedding mechanism including an image element tag an image resource is statically embedded in the image element tag by the code generator.","According to another aspect of the data processing system, the tags comprise a link tag that specifies a transition from a source event handler to a destination displayable element.","In the following description, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent to one skilled in the art, however, that the present invention may be practiced without these specific details. In other instances well-known circuits, control logic, and the details of computer program instructions for conventional algorithms and processes have not been shown in detail in order not to unnecessarily obscure the present invention.","Software programming code, which embodies aspects of the present invention, is typically maintained in permanent storage, such as a computer readable medium. In a client\/server environment, such software programming code may be stored on a client or a server. The software programming code may be embodied on any of a variety of known media for use with a data processing system. The media include, but are not limited to, computer-readable storage media such as magnetic and optical storage devices such as disk drives, magnetic tape, compact discs (CDs), and digital video discs (DVDs). The media also include computer instruction signals embodied in a transmission medium with or without a carrier wave upon which the signals are modulated. For example, the transmission medium may include a communications network, such as the Internet.","Although the embodiments described herein make use of particular features and vocabulary of the Java and XML languages, operating environments and application programming interfaces, the present invention is not limited to these languages or to the particular implementation tools described here. Rather, the principles of the present invention may be applied using other object-oriented programming languages and markup languages.","In class and sequence diagrams referenced herein, the symbols \u201c+\u201d or \u201c\u2212\u201d preceding an item respectively indicate that the item is public or private.","Overview","Turning now to the drawings, reference is initially made to , which is a block diagram of a core set of software components , which is designed for the dynamic creation of MIDlet applications for devices that support the mobile information device profile in accordance with a disclosed embodiment of the invention. The set of software components  is not static, but is extensible, supporting incremental addition of features. It can best be understood as a layered architecture. A lowermost layer  represents a specification written in a markup language, which in the current embodiment is MIDML. MIDML is an extension of the known markup language XML that facilitates the dynamic creation of MIDlets. It is an easily extensible, strongly typed object-oriented markup language. It is possible to practice the invention using many different markup languages.","As explained in further detail hereinbelow, MIDlets are parsed, compiled, packaged and delivered over-the-air to a client, which typically is a mobile information devices, by other members of the set of software components .","An intermediate layer  includes a library , which includes code for handling MIDlet creation tasks based on a MIDML application created in the layer . The library  is typically an extensible component library, which provides for parsing, code generation, compilation and packing of the generated MIDlet. The layer  also includes an application programming interface  with the layer , and an interface  with a layer . The layer  includes detailed documentation  relating to components of the library . The run time component of the library  is sometimes referred to herein as the run time library. As is disclosed in further detail hereinbelow, the functionality of the library  is exposed to the application developer, which is typically a Java developer.","The MIDML specification may be conveniently regarded as a source code. An upper application layer  includes a standalone compiler  that compiles MIDML applications into an intermediate code, which in the current embodiment is Java source code, from which MIDlets are ultimately generated. It is possible for the intermediate code to be source code of many other computer languages. The compiler  has access to the facilities of the library . A feature of MIDML is the use of tags corresponding to different functions of a MIDML application. For each type of tag provided by MIDML, the compiler  has two specific components: a reader, for reading the tag and appropriate elements accompanying it from the MIDML document into the objects in memory; and a code-generating class for each object type. Typically, the compiler  is a J2SE stand-alone console application. Also included in the layer  is a servlet . The servlet  is a HTTP service interface that extends the functionality of a Web server to handle client requests that result in dynamic creation of MIDlets from MIDML applications. The servlet  can be a J2EE web service application.","It is helpful to regard the layers ,  as an infrastructure  of the set of software components , and the layer  as its application layer. The infrastructure  and the compiler  are intended to function as a software developer's kit for the development of MIDlets. The software developer can exchange MIDML tags with the infrastructure , and can supply pre-compiled descriptors and generators if desired.","The set of software components  can be realized in different development environments, which may support computer languages other than Java. For example, the embodiments disclosed herein can be implemented for use with object-oriented languages, such as C++ as the intermediate code, by appropriately modifying the compiler , the servlet , and the library  to support a particular object-oriented language, using programming techniques known in the art.","System Architecture.","Reference is now made to , which is a block diagram illustrating the architectural relationships of the set of software components  () and logical aspects of the system in further detail, in accordance with a disclosed embodiment of the invention. A content provider or developer, operating from a site , uses a markup language, such as MIDML, to write applications . In the current embodiment, the applications  are expressed as MIDML code, and are intended to be ultimately executed by mobile information devices. The site  has access to other elements of the set of software components  (), typically via a HTTP web server. The site  can be remote from, or co-located with a site housing one or more of the other elements.","The set of software components  () may be physically distributed among sites , , which are linked in a network, typically using one or more HTTP file systems. In the example of , the compiler  is located at the site , and the servlet  is located at the site . The library  is replicated on both sites , . However, many other physical distributions of the set of software components  are possible. Indeed, each element of the set of software components  could be resident at a different site. The network may be the Internet, a corporate intranet, or other suitable network. The sites ,  may be remote from one another, or may be co-located. The site  is typically a Java enabled Web server that is accessible to a mobile information device . The library  typically includes J2SE, J2EE and J2ME components.","Using the infrastructural facilities of the sites , , the MIDML document is compiled by the compiler  into a MIDlet . Upon a request of the mobile information device  for the MIDlet , the servlet , running on the site , finds any required resources, such as MIDML files and resource files, and instructs the compiler  to generate up-to-date archive files, which are typically JAR files, for the MIDlet . JAD files are also prepared, and portions of the JAD files are incorporated into a manifest file of the JAR file. An updated MIDlet  is then assembled, and downloaded to the mobile information device .","The embodiments of  and  are subject to several general requirements. The specification of MIDML, which is disclosed in further detail herein below, is implemented using XML. The library , the compiler , and the servlet  are developed using the Java programming language and relevant Java technologies. The library  requires the J2ME platform and either a J2EE platform or a J2SE platform for its operation. The compiler  requires the library , and runs on a J2SE platform. The servlet  requires the library  and runs on a J2EE platform. The MIDlet  requires a device that is compliant with MIDP Version 1.0a (or higher) and with an over-the-air protocol.",{"@attributes":{"id":"p-0098","num":"0097"},"figref":["FIG. 2","FIG. 2"],"b":["46","34","32","42"]},"A path  (MIDMLServlet), illustrated in the upper portion of , is oriented to MTDP devices, and to some extent to end-users. When the servlet  is triggered to generate a new, dynamically created MIDlet  upon the HTTP request of an end user, the servlet  locates and processes MIDML source code to return the MIDlet  to the requesting mobile information device . If the MIDlet  is already up-to-date, it may simply be downloaded. Otherwise, the facilities of the site  are invoked by the servlet  to generate an up-to-date version of the MIDlet and transfer it to the servlet  for download as an updated MIDlet , as indicated by a path .","Reference is now made to , which is a block diagram illustrating the architecture of the set of software components  () in further detail. In the layer , MIDML is enabled by XML schemas that define the MIDML specification. A schema  (midml.xsd) is a MIDML root element that contains MIDML application data elements, for example, an app-descriptor element, which is the MIDML project descriptor. The MIDML root element also contains the MIDlet application and its contained data, or a screen and its data. The schema  is disclosed in detail in Listing 1.","A schema  (widgets.xsd) defines all MIDML widgets. The widgets are objects, which can be MIDP 1.0 mapped or can be MIDML-specific widget commands. The schema  also defines an item's inheritance and its XML substitution group. The schema  is disclosed in detail in Listing 2.","A schema  (vars.xsd) defines the project's global variable elements. The schema  is disclosed in detail in Listing 3.","A schema  (utils.xsd) defines all general data types that can be used by other MIDML types. The schema  is disclosed in detail in Listing 4.","A schema  (operations.xsd) is an operations types definition file, which supports the following MIDML operations: assign; if; timer (activate\/cancel); servlet (activate); link; signal; and the event-handler type that can contain all these operations. The schema  is disclosed in detail in Listing 5.","A schema  (midmlapp.xsd) describes the MIDML MIDlet type, the top level MIDML element, as the application container. The MIDlet oriented type can contain all tags of the MIDML language. The schema  is disclosed in detail in Listing 6.","A schema  (screens.xsd) defines available screens in MIDML. The schema  defines a screen base type and all derived specific screens, e.g., form, list, textbox, alert, the global element of the screen and its substitution group. The schema  is disclosed in detail in Listing 7. Screens are disclosed in further detail hereinbelow.","A schema  (events.xsd) describes an event type, which contain an event handler as an action sub-element. This type is the base class for future events that can be developed as MIDML evolves. The schema  is disclosed in detail in Listing 8. Events are disclosed in further detail hereinbelow.","A schema  (infra.xsd) describes added components in the infrastructure , such as servlet connection and timer elements. The schema  is disclosed in detail in Listing 9.","A schema  (descriptor.xsd) defines types and a JAD descriptor MIDML element. These derive their properties from the JAD file. The schema  is disclosed in detail in Listing 10.","In the layer , the components of the library  are designed to be highly independent of one another. The library  includes a MIDML parser  for parsing MIDML application files. A project descriptor object  is built during operation of the parser . A generator  accepts the output of the parser  and produces Java source. A generation object model  (GenOM) is created by the generator  during its operation. The library  includes run time support for a Java compiler . The Java compiler  is responsible for compilation and pre-verification of the Java source code, and produces class files. The library  includes a packer , which assembles the class files and associated resources into a MIDlet JAR file and creates an associated JAD file. The various components of the library  are disclosed in further detail hereinbelow.","In the layer , the compiler  (MIDMLc) is designed as a standalone compiler application, having a standard command line user interface. Command line options or directives for the compiler  are disclosed in Table 3. The compiler  is a developer-oriented application, outputting messages relating to parsing, generation, compilation and packing to the user. Using the compiler , dynamic creation of MIDlets is conveniently accomplished, using a single application.",{"@attributes":{"id":"p-0112","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Directive","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"-g","Generate all Java debug info"]},{"entry":[{},"-g: none","Generate no Java debug info"]},{"entry":[{},"-g:{lines,var,source}","Generate debug info according to"]},{"entry":[{},{},"line, variables and source file"]},{"entry":[{},"-intermediate <path>","Save intermediate Java source and"]},{"entry":[{},{},"class files"]},{"entry":[{},"- nowarn","Generate no JAVAC warnings"]},{"entry":[{},"-v:all","Verbose all outputs"]},{"entry":[{},"-v:java","Verbose JAVAC output"]},{"entry":[{},"-v:midml","Verbose MIDML parsing and generator"]},{"entry":[{},{},"output"]},{"entry":[{},"-classpath <path>","Specify user class file location"]},{"entry":[{},"-log <file>","Save log file to the specified file"]},{"entry":[{},"-d <path>","Specify where to place gener-"]},{"entry":[{},{},"ated.jad.jar files.default <pro-"]},{"entry":[{},{},"j ect>\/bin\/"]},{"entry":[{},"-encoding <encoding>","Specify MIDML source code encoding"]},{"entry":[{},"-vm <vm-flags>","Specify Java VM flags"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The servlet  is a web service interface to the library , allowing dynamic MIDlets to be served over the Internet using an over-the-air protocol. The function of the servlet  is to dynamically generate a MIDlet in response to specifications in a HTTP request. The HTTP re?quest contains a URL for the requested MIDlet, and user specific parameters, e.g., a query string, or parameters for a HTTP POST operation. The output of the servlet  is another HTTP response containing the dynamically generated MIDlet application descriptor (JAD file). The servlet  invokes the parser , the generator , the Java compiler , and the packer  in order to generate the MIDlet.","The web server hosting the servlet  supports the above-noted Java Servlet Specification (Ver. 2.3 or higher). The servlet  uses the web server's log file to log its operations and error states. Sessions are managed by the web server, using query string hashing. Using the same mechanism, the servlet  creates user specific JAR files. This prevents multiple requests from overriding one another. The parameters shown in Table 4 define the server side behavior of the servlet .",{"@attributes":{"id":"p-0115","num":"0114"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 4"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Parameter name","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"debug = [all; none; {lines,","Generate all Java debug info to"]},{"entry":[{},"var, source}]","the web server"]},{"entry":[{},"nowarn = [true; false]","Generate no javac warnings:"]},{"entry":[{},"Intermediate = [{true,","Save intermediate Java source"]},{"entry":[{},"path}; false]","files:"]},{"entry":[{},{},"true = generate all intermediate"]},{"entry":[{},{},"files and save to the"]},{"entry":[{},{},"specified path;"]},{"entry":[{},{},"false = do not generate inter-"]},{"entry":[{},{},"mediate files"]},{"entry":[{},"verbose = [all; midml; java]","Verbose to web server log modes:"]},{"entry":[{},{},"all = all outputs"]},{"entry":[{},{},"javac = javac outputs"]},{"entry":[{},{},"midml = midml parsing and gen-"]},{"entry":[{},{},"eration outputs"]},{"entry":[{},"classpath = [URL]","Specify user class file URL"]},{"entry":[{},"Encoding = [encoding-type]","Specify midml source code encod-"]},{"entry":[{},{},"ing"]},{"entry":[{},"Directory = [path]","Specify where to place the gen-"]},{"entry":[{},{},"erated packed MIDlet executable"]},{"entry":[{},{},"(*.jad\/*.jar files), the de-"]},{"entry":[{},"fault is <Project-Dir>\\bin"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Static MIDlet requests are handled in a straightforward manner by a web server. Thus, if a JAD file describing the requested MIDlet or the MIDlet's JAR file already exists on the web server, they are returned to the requesting MIDP device. The JAR file need not be recreated if the application source code has not changed.","Dynamic MIDlet requests are mapped by the web server to the context of the servlet . In form, a dynamic request is similar to a static request, but is modified when the requested JAD file does not physically exist on the server. The dynamic request is then propagated to the servlet , with the file name of the needed JAD file name being an initial generation parameter. Dynamic MIDlet creation then begins. After the MIDlet is created, a newly generated JAD file is returned to the requesting MIDP device. An exemplary static URL request and a dynamic URL request are given in Listing 11. A simple usage example is given in Listing 12. An exemplary query string in a HTTP request is given in Listing 13.","Reference is now made to , which is a class diagram describing the structure of the layer  () in further detail. The disclosure of  should be read in conjunction with  and . Both the compiler  and the servlet  use the same classes in order to construct the parser  and the generator , as indicated for example by a line  and a line . The Java compiler  and the packer  are also constructed, using a build tool . The build tool  can be, for example, the Apache Ant, available from the Apache Software Foundation, 1901 Munsey Drive, Forest Hill, Md. 21050-2747. A wizzle  is a helper class, which is linked with the compiler  and the servlet  in the application layer, that is the layer  (), and with the elements or classes of the library , including the parser , the generator , the Java compiler , and the packer . A private logger class PrivateLogger  is provided to communicate with a logging unit (not shown). A factory class  is an infrastructural class used by DescriptorFactory and the GenFactory classes, which are disclosed in further detail hereinbelow. The factory class  facilitates the creation of other objects and classes. Two exception classes ,  are used by the factory class .","Behavioral Aspects","Reference is now made to , which is a sequence diagram applying to the compiler  and to the servlet  as well, in typical web service. The disclosure of  should be read in conjunction with .  illustrates the program flow of the compiler , and servlet  with the infrastructure . It shows the complete flow from a MIDML application to a dynamically created MIDlet JAR and JAD, including activation of various components, interactions of the components, and data passing. The compiler  and the servlet  interact substantially identically with the infrastructure . Their external interfaces differ, the compiler  usually being invoked via the command line, while the servlet  is typically invoked via a HTTP request. It will be understood by those skilled in the art that references to activities of the library  mean references to processes using library modules or code or processes generated using the library. In some embodiments, the wizzle  is used. In other embodiments, the wizzle  can be omitted.","At the left of , a developer  initiates the program flow in an activation  of an appropriate process in a computer device (not shown). Data is passed to the compiler , as indicated by a message line . As noted above, this can be done using a command line interface. The compiler  operates during an activation . Interaction between the compiler  and other elements of the library  when a method parse( )  of the wizzle  is invoked by the compiler  on a message line . The wizzle  is activated several times along its object lifeline , shown as activations , , , .","During an activation , the wizzle  interacts with the parser . The constructor of the parser  is invoked on a message line  to produce activation . In a subsequent activation , a method parse( )  of the parser  is then invoked on a message line . This is accomplished using method parseJadData( )  (), which operates during the activation , and results in JAD file information. The information is then returned to the wizzle  on a message line , which awaits in the activation , and thereupon relays a result to the compiler  along a message line .","Next, method generate( )  () of the wizzle  is invoked by the compiler  along a message line . During the activation , the wizzle  invokes the method DynaMIDGenerator( )  (), the constructor of the generator  along a message line . An object lifeline  of the generator  indicates activations , , . Upon receiving the message on the message line , the generator  begins operation in activation . Additional invocations of method createNewProject( )  () and method generate( )  () on message lines ,  result in activations , , respectively. Then, in activation , a completion message is returned to the wizzle  on a message line . The wizzle  then reports completion of the generation task to the compiler  on a message line . Java source code for the project is now available.","Next, the compiler  initiates compilation of the Java source code by invoking method compile( )  () of the wizzle  on a message line , which results in activation . The wizzle  then invokes method DynaMIDCompiler( ) , the constructor of the Java compiler  on a message line , which results in activation  of the Java compiler . The wizzle  then invokes the method compile( )  () of the Java compiler  on a message line , resulting in activation . The Java compiler  reports completion of the Java compilation task to the wizzle  on a message line . The wizzle  then reports completion of the Java compilation task to the compiler  on a message line .","Next, the compiler  initiates the assembly of an archive file, which is typically a JAR file. Method archive( )  () of the wizzle  is invoked on a message line , which results in activation . The wizzle  then invokes the constructor of the packer , method DynaMIDPacker( )  () on a message line , which results in activation . The wizzle  then invokes method packageApp( )  () of the packer  on a message line , resulting in activation . The packer  reports completion of the archival task to the wizzle  on a message line . The wizzle  reports completion of the packaging task on a message line .","Finally, the compiler  reports availability of the MIDlet to the developer  on message line  via the servlet .","Interfaces","Reference is now made to , which is a block diagram illustrating software interfaces and certain other aspects of the set of software components  () in further detail. The layered architecture of the set of software components  () mandates three user interfaces for the different users of the infrastructure , each of which involves different functionality. The compiler  provides the MIDML\/MIDSP developers with a command line interface  to a dynamically created MIDlet . The servlet  provides MIDML\/MIDSP developers and end-users with a web service interface  to a MIDlet application  downloaded from the MIDlet . The library  provides the Java developer with a programming API . The command line interface , the API , and the web service interface  are represented by dashed lines in . In this embodiment, the servlet  is implemented using the JAVAX.servlet package, the specification of which is available from Sun Microsystems, Inc., and is optionally adapted for servlet web access service according to requirements of a particular application.","In this embodiment, the library , as part of the infrastructure  (), is a Java based solution, utilizing several Java technologies. The library  provides a XML parser and generator , employing JAXP, which operates using a MIDML specification 200 (Appendix 1). The API , which can be the MIDP 1.0a API JAVAX.microedition, available from Sun Microsystems, Inc., is used for the Java code generation components of the library . Java source code is emitted as an intermediate output . Included in the library  is a J2ME module , which supports the compiler . The compiler , using the intermediate output , emits another intermediate output , which includes binary files and resources. The intermediate output  is packaged and delivered by the compiler  as the MIDlet  as a JAR file and a corresponding JAD file using a library module .","Functional Requirements","Referring again to  and , detailed functional requirements of MIDML are disclosed in Appendix 1. Detailed functional requirements of the library  are disclosed in Appendix 2. Detailed functional requirements of the compiler  are disclosed in Appendix 3. The functional requirements, operation modes and Web application behavior of the servlet  are disclosed in Appendix 4. A MIDlet developed using MIDML has the same look, feel, and power of a statically developed MIDlet.","Application Structure and MIDML Support","MIDML Applications have the following file structure definitions. A MIDML project file (*.mpr) contains the MIDlet application descriptor, and a pointer to an application starting point file. The project file has a valid URI pointer to a project starting point MIDML source file, which contains a <midlet> tag (Listing 15), and defines the MIDML application starting point.","A MIDML source file (*.midml) contains actual MIDML source code. A MIDML application may have additional MIDML source files. However, such additional MIDML source files are typically limited to defining additional application screens using the <screen> tag type, which is disclosed hereinbelow. All MIDML file content, regardless of type, is written within the scope of a MIDML tag, an example of which is shown in Listing 14. The MIDML tags contain sufficient information to enable code for elements such as timers, screens, and events to be generated. For example, a <timer> tag type specifies what occurs after a MIDP timer fires. In another example, mappings of Pause and Resume methods may be mapped to MIDP methods. Such mappings are specified MIDML in tags relating to Pause and Resume events.","The MIDlet application descriptor has the following general structure. A tag <app-start-file> contains the pointer to the application starting point MIDML source file. A tag <descriptor> contains all the related metadata of the MIDlet. An exemplary MIDlet application descriptor is given in Listing 15.","Listing 16 is a code template, which illustrates the general structure of a MIDlet in MIDML. A single instance tag <midml app> is shown. This tag appears at the project starting point. The order of appearance of other MIDML tags is important to the schema validation. Comments in Listing 16 indicate the correct order of appearance of the MIDML tags.","Events","MIDML supports MIDP-1.0 MIDlet native events. An event StartApp occurs upon initiation-of an application. It includes a <link> tag indicating the application's first screen. An exemplary link tag is shown in Listing 17, which directs the parser  to include a specified MIDML source file. In Listing 17, an identifier \u201chref\u201d is a URI indicating a file to be included. Event handler techniques are disclosed hereinbelow.","Event Handling Model","MIDML exposes event handlers related to specific language elements. A MIDML event handler is a special operations placeholder and is defined within the relevant language element. The following disclosure is a summary of the event-handling model applicable to MIDML. Specific details are disclosed in further detail in the discussion of particular language elements.","At the Application level, the following events are adapted from MIDP-1.0. An event \u201cstartApp\u201d is triggered upon starting an application. An event \u201cpauseApp\u201d is triggered before the application changes its state from running to paused. The event \u201cdestroyApp\u201d is triggered before the application changes its state from active or paused to destroyed. An event \u201cresumeApp\u201d is added in MIDML. It is triggered when the application changes its state to running from a paused state.","The following events apply to screens. An event \u201cloadscreen\u201d is triggered before each screen loads, i.e. when the screen object is displayed. An event \u201cunloadScreen\u201d is triggered before a form is ready to unload, i.e. when a screen is about to be removed from the display. An event \u201conSelect\u201d is triggered when a List's screen choices context is updated. Lists are disclosed in further detail hereinbelow.","The following events apply to widgets, and are adapted from MIDP-1. An event \u201cOnItemStateChanged\u201d is triggered upon a change in the state of an item in a widget. An event \u201cCommandAction\u201d is triggered upon activation of a command widget. Widgets are disclosed in further detail hereinbelow.","An event \u201conTime\u201d applies to timers. It is triggered upon expiration of a timer delay interval. The interval can begin upon timer activation or according to a schedule.","Navigation","MIDML Developers require a convenient mechanism for referencing the language elements used in their applications. MIDML defines the following naming conventions. The application tag <midml-app> defines the name attribute of the application. Each MIDML language element has a name attribute. Name-driven navigation is accomplished using the following name attributes for the application, screen, widget, item and variable respectively: application-name; screen-name; widget-name; item-name; and variable-name. The character \u201c.\u201d is used as a reference directive, for example, \u201cMIDlet-Name.Screen-Name.Widget-Name\u201d.","MIDML predefines additional navigation possibilities for particular language elements. This feature exposes certain data to the developer. Servlet response is accessible using the reference MIDlet-Name.Screen-Name.Servlet-Name.response. A property of items is accessible using the reference MIDlet-Name.Screen-Name.Item-Name.Item-Property. Ticker text is accessible using the reference MIDlet-Name.Screen-Name.Item-Name.Item-Data.","Signals","Signals are a feature of MIDML, which enable triggering of certain events in the application. The following signals apply to the application level (layer ; ).","A signal STARTAPP restarts the current application, at the point specified by the tag <onstartapp> in the tag <MIDML-APP> that applies to the current application. The following syntax illustrates this signal:\n\n","A signal PAUSEAPP pauses the current application. Execution resumes at the point specified by the tag <ON-PAUSEAPP> of the tag <MIDML-APP> that applies to the current application. The following syntax illustrates this signal:\n\n","The following signals apply at the screens level.","A signal LOADSCREEN causes reloading of the current screen by a call to the screen's load event handler. The following syntax illustrates this signal:\n\n","A signal UNLOADSCREEN causes the current screen to be unloaded, by a call to the screen's unload event handler. The following syntax illustrates this signal:\n\n","Widgets in The MIDML user interface include command widgets and ticker widgets. MIDML also defines a generic item element with the following attributes. The attribute \u201clabel\u201d defines the item label. The attribute \u201cname\u201d is the programmatic identifier of the item. The attribute \u201cpersist\u201d is a persistence flag, which is disclosed in further detail hereinbelow. An interactive MIDML item has an event handler \u201conItem-StateChanged\u201d, which is triggered upon a change in its the internal state. All currently defined widgets are compliant with MIDP-1.0.","A command widget is the MIDML equivalent of a MIDP-1.0 command. It holds the information concerning an action, and has an attribute \u201clabel\u201d, which is the command label. An attribute \u201ccommandType\u201d defines the command type. This attribute has one of the values BACK, CANCEL, EXIT, HELP, ITEM, OK, SCREEN, and STOP. The attribute \u201cpriority\u201d defines the command priority, and has an integer value. A property \u201ctext\u201d holds text field data. An exemplary command widget is presented in Listing 18.","A ticker widget implements a \u201cticker-tape\u201d display, that is a text display that runs continuously across the screen. A ticker element is attached to a screen element, which is disclosed hereinbelow. The ticker widget has an attribute \u201cmaxSize\u201d, which is the size of the text field. An attribute \u201cconstraint\u201d has one of the MIDP-1.0 text constraint values ANY, EMAILADDR, NUMERIC, PASSWORD, PHONENUMBER, and URL. The ticker widget has a property \u201ctickerText\u201d, which is its text field data. An exemplary ticker widget is presented in Listing 19.","In addition to the above-noted widgets, MIDML features a number of items relating to the user interface.","A gauge class implements a bar graph display of a value intended for use in a form. The gauge class has an attribute \u201cinteractive\u201d, indicating whether the value of the gauge is read-only, or whether it can be changed by the user. The gauge class has a property \u201clabel\u201d, which is the gauge label. A property \u201cmaxValue\u201d holds the bar graph's maximum value. A property \u201cvalue\u201d holds the current value of the gauge. An example of the gauge class is presented in Listing 20.","A text field is an editable text item that may be placed into a screen. The text field has an attribute \u201cmax-Size\u201d, which is the maximum length of the text field. An attribute \u201cconstraint\u201d has one of the MIDP-1.0 text constraint values ANY, EMAILADDR, NUMERIC, PASSWORD, PHONENUMBER, and URL. A property \u201ctext\u201d holds text field data of the text field. An example of the text field is presented in Listing 21.","A date field is an editable component for presenting date and time or calendar information that may be placed into a screen. The date field has a property \u201cdata\u201d, which can be one of the following: \u201cdateTime\u201d, containing date and time information; \u201cdate\u201d, containing only date information; and \u201ctime\u201d, containing only time information. The date field has an additional property \u201ctimeZone\u201d, containing a time zone setting. An example of the date field is presented in Listing 22.","A \u201cChoiceGroup\u201d is a group of selectable elements intended to be placed within a screen. The details of the ChoiceGroup are disclosed below.","A choice element represents an entry within a ChoiceGroup item, a list or in a screen context. A choice element is defined only within the scope of a <choices> tag (Listing 23). A choice element has an attribute \u201cname\u201d, which is the name of the choice. An attribute \u201cselected\u201d is a Boolean value represents the selection status of the element. An attribute \u201cimage\u201d specifies an image that is associated with the choice. A choice element has a property \u201ctext\u201d, representing the text of the choice element.","The ChoiceGroup has an attribute \u201cchoiceType\u201d, which is the context type. It may have one of the values SINGLE, or MULTIPLE. A property \u201cchoices\u201d is a sequence of choices and their respective images. A property \u201cselectedIndex\u201d is an integer, pointing to a currently selected choice element. The value \u22121 indicates that no selection has been made. A property \u201cselectedText\u201d holds the text of the currently selected choice element. An exemplary ChoiceGroup is presented in Listing 23.","An item \u201cStringItem\u201d contains a string. The item StringItem is display only. The user cannot edit the contents. The item StringItem has the property \u201ctext\u201d, which contains the string data. An example of the item StringItem is given in Listing 24.","An item \u201cImageItem\u201d provides layout control when image objects are added to a screen. Images are fetched from local or remote files during the MIDlet generation process, and are placed in a directory specified in a tag <Project-Dir>\\res. The contents of this directory are packaged together with the generated MIDlet JAR file. It is the responsibility of the MIDML developer to make sure that the embedded resource sizes match the target device constraints. The item ImageItem has an attribute \u201clayout\u201d, which represents the image layout type. It has one of the values LAYOUT_CENTER, LAYOUT_DEFAULT, LAYOUT_LEFT, LAYOUT_NEWLINE_AFTER, LAYOUT_NEWLINE_BEFORE, and LAYOUT_RIGHT. A property \u201cimageSource\u201d is an image resource URI, or a relative path to the directory specified in the tag <Project-Dir>. A property \u201caltText\u201d is an alternative image text. An example of the item ImageItem is given in Listing 25.","MIDML provides a facility for threads to schedule tasks for future execution in background threads. A timer element is defined within the scope of a <midlet-app> tag or a <[Type]-screen> tag, for example a login screen, <login-screen> tag. A timer element has an attribute \u201cname\u201d, which is the name of the timer. An attribute \u201cdelay\u201d is the timer delay interval in milliseconds. An attribute \u201cschedule\u201d is the scheduled start time schedule (datetime). A property \u201contime\u201d references an event handler for the timer. An exemplary timer object declaration is presented in Listing 26.","Screens","MIDML defines a generic screen element. A screen element has an attribute \u201cname\u201d, which is the name of the screen. An attribute \u201csource\u201d refers to the source MIDP-1.0\/MIDML. An attribute \u201ctitle\u201d is the title of the screen. An attribute \u201cticker\u201d refers to a ticker element. An attribute \u201cpersist\u201d is a persistence flag. A screen element has an event handler \u201conLoad\u201d, which responds to an indication to load the screen element. An event handler \u201conUnload\u201d responds to an indication to unload the screen element.","An \u201calert screen\u201d is a screen that displays information to the user, and waits for a predetermined period of time before proceeding to a subsequent screen. The alert screen has an attribute \u201ctype\u201d, which is the alert type. It has one of the values ALARM, CONFIRMATION, ERROR, INFO, and WARNING. An attribute \u201ctimeout\u201d determines the display time. A property \u201cmessage\u201d represents a message displayed in the alert screen. A property \u201cimage\u201d holds an image associated with the alert screen. A property \u201csound\u201d represents sound associated with the alert screen. An exemplary alert screen is presented in Listing 27.","A form is a screen that contains an arbitrary mixture of items: images, read-only text fields, editable text fields, editable date fields, gauges, and choice groups. An exemplary form is presented in Listing 28.","A TextBox is a screen that allows the user to enter and edit text. The TextBox has an attribute \u201cmaxSize\u201d, which is the maximum size of the text. An attribute \u201cconstraint\u201d holds MIDP-1.0 text constraints, and has one of the values ANY, EMAILADDR, NUMERIC, PASSWORD, PHONENUMBER, and URL. A property \u201cmessage\u201d holds the screen's message. A property \u201cimage\u201d represents an associated image. A property \u201csound\u201d represents a sound associated with the TextBox. An exemplary TextBox is presented in Listing 29.","A list or list class is a screen containing a list of choices. The list has an attribute \u201ccontext\u201d, which holds one of the MIDP-1.0 choice context values SINGLE, and MULTIPLE. A property \u201cchoices\u201d holds a list of choices. A property \u201cselectedIndex\u201d holds an integer, pointing to a currently selected choice element. The value \u22121 indicates that no selection has been made. A property \u201cselectedText\u201d holds the currently selected choice text. An event \u201conselect\u201d is triggered when the List-Screen choices context is updated, i.e., when the selected choice changes. The event \u201conSelect\u201d can be triggered in both SINGLE and MULTIPLE choice contexts. An exemplary list is presented in Listing 30.","Persistence","By default, application data and variables are not persistent in MIDML. All widgets and data variables are set to their default values unless otherwise specified. MIDML provides for persistent data and other elements within an application. Two types of persistence are supported.","In \u201capplication persistence\u201d, data is persistent between different executions of an application. The data is loaded when the application is started, and is saved when the application is destroyed. This type of persistence uses the device records management system (RMS), for example, non-volatile memory. An instruction specifying a persistent data variable is presented in Listing 31.","In \u201cscreen persistence\u201d, data persists between screen changing events during a single execution of an application. The data is reloaded each time the screen is reloaded, and is saved when the screen is unloaded. This type of persistence uses the device random access memory (RAM). An example of screen persistence is presented in Listing 32.","The persistence mechanism in MIDML applies to data variables, item widgets, screens, and tickers, all of which have a persistence attribute that can be optionally included in the element definition.","Resource Handling","The current embodiment of MIDML includes a resource embedding mechanism for image resources. An image resource is embedded statically. The embedding mechanism is built in the ImageItem element tag (Listing 25).","Data Variables","A MIDML variable can be defined within a <midmlapp> tag or any screen tag definitions. MIDML supports two variable types: variant and Boolean. A variable of type variant is a string based variable. The following tag is exemplary:\n\n","An exemplary tag showing a variable of type Boolean follows:\n\n","Assignment operations in MIDML apply to the following language elements and their respective properties: data variables (variant, Boolean); servlet responses; widgets, both widget items, and tickers; and screen properties. An assignment operation is defined by the following tag:\n\n","The assignment operation argument is a valid MIDML navigation path.","Flow Control","A MIDML link operation is a basic jump operation from a source event handler to a destination displayable element. The destination of a link operation is a screens element. A link is defined by the following tag:\n\n","A MIDML \u201cIf\u201d operation is a basic branch operation. In the If operation, a Boolean expression is evaluated, during which two event handlers are exposed for alternate cases. An If operation is defined in Listing 33.","Timer Support","Activation of a previously defined timer element (Listing 26) is shown in the following exemplary tag:\n\n","Cancellation of the operation of a previously defined timer element is shown in the following exemplary tag:\n\n","MIDML defines a servlet element to enable a developer to create interconnected applications. MIDML is thus able to exploit the Internet. It is possible, too, for the developer to specify execution of remote process, including passing of parameters and retrieving of data.","MIDML currently supports two types of servlets. The design of the servlet mechanism is generic and is reflected in the schema definition of the servlet object (Listing 4).","The generic servlet has an attribute \u201cprotocol\u201d, which defines the protocol used by the servlet. An attribute \u201chttp-method\u201d has one of the values GET, POST, and HEAD, which refer to standard HTTP methods. A URL of the servlet is specified by an attribute \u201cURL\u201d.","This generic mechanism also allows activation of a servlet with no protocol. It is possible to activate the servlet without checking the servlet response, using the value \u201cNONE\u201d as the protocol attribute, and the POST method as the http-method attribute.","A servlet element has dynamic properties representing the servlet parameters, which are defined using a servlet parameter declaration, as shown in the following tag:\n\n","Using the MIDML naming convention scheme, servlet parameters can be accessed and changed at run time. An exemplary servlet definition is presented in Listing 34. A login example for a servlet using a servlet parameter value is given by the following:\n\n","A text servlet is a servlet, which returns simple text that can be displayed to the user using widgets. An exemplary text servlet is presented in Listing 35.","Once a servlet has been defined, it is activated using the following syntax:\n\n","Continuing to refer to  and , the compiler  and the servlet  cooperate to parse, generate, compile, and package MIDML applications into a MIDlet at a scheduled time, which may be application specific, and may be a function of the available hardware and communications bandwidth.","The servlet  allows concurrent multiple activations, in order to function as a reliable Web service.","Statically created and dynamically recreated MIDlets typically look and behave identically.","Detailed Structure of System Components","Parser","Referring again to  and , the parser  employs the Java document object model (JDOM) Java XML interface, developed under the Java Specification Request JSR-102. It is an advantage of the present design that the set of software components  () need not rely on any particular XML parser. The MIDML specification (Appendix 1) defines strict XML schema rules for the validity of the MIDML source code. The parser  enforces these rules using schema validation of the syntax of MIDML source files. The parser  is linked to the wizzle .","The input to the parser  is one or more MIDML application source code files (*.midml). The output of the parser  is the project descriptor object . It is the responsibility of the parser  to validate the MIDML text, to provide a description of the application components for the code generator components, and to expose the project descriptor object  during the parsing task.","Operation of the parser  involves invoking an XML Parser\/Validator to verify the source MIDML files against schema definitions. Once the source is validated, the parser  builds the project descriptor object  (). The project descriptor object  describes a valid and parsed MIDML application using a tree structure. The tree hierarchy is identical to the original MIDML (*.midml) source code structure. The project descriptor object  provides an association between the parser  and the generator , and with application meta-data in the JAD file (*.jad). The project descriptor object  is exposed to the developer  (). The project descriptor object  is thus a wrapper for an entire MIDML project. It consists of two objects: an object AppMetaDescriptor , which is a JAD data wrapper, and a MIDML descriptor object model  (MDOM), which is a tree oriented data structure that is disclosed in further detail hereinbelow. The descriptor object model  includes elements, or readers, that can include objects that are adapted to ultimately induce generation of the following application building blocks by a code generator: MIDlet application structure; screens; widgets; events; operations; variables; and extensible elements. The objects include instance-specific data needed to generate the code. The code generation mechanism includes additional, non-instance specific data. The objects can represent multiple versions of the same building blocks that are parametrically different. For example, parametrically different screens have parameters that may include the position of a label, and the text that is displayed on the screen. These items typically vary among different screens.","The descriptor object model  is the main data structure created by the infrastructure  (). The descriptor object model  is a composite object, built up of several hierarchies of descriptor elements. It describes the MIDML source code to the generator . The MIDML description is specific; each descriptor element exposes its relevant data through public methods. Descriptor elements themselves are composite structures, and a descriptor element may contain another descriptor element.","The methods of the parser  include a method MIDMLParser( ) , which is a class constructor. A private method parseJadData( )  parses the MIDML project file (*.mpr). The method parse( )  parses the MIDML application XML files, and builds a MDOM tree.","Generator","Continuing to refer to  and , the generator  is responsible for aspects of the project related to generation of Java source code. The generator  is linked with the build tool  and the wizzle . Code produced by the generator  is required to handle such matters as application flow, application screens and forms, application events, widget event handling, application data and containers, and the creation of the project directory structure.","The input to the generator  is the project descriptor object . The output of the generator  is a directory structure <Project-Dir>, Java source code files, and embedded resources. During operation, the generator  handles ambiguities and syntax errors in the input, and optimizes the Java source code. A log file is generated, and the generator  also inserts the Java source code files and other embedded resources into the project subdirectories.","The generation object model  is created by the generator  to generate Java source code files. The generation object model  links to the directory tree of the descriptor object model , and handles code generation logic. The generation object model  is specific to the MIDML tag descriptor of a current project descriptor object . During its operation, the generation object model  uses a Java source code generator object.","The generator  has a method DynaMIDGenerator( ) , which is a class constructor. The properties of the constructed class are those which were provided by the parser . The, facilities of the build tool  are invoked by the method DynaMIDGeneratotr( )  to obtain the project directory in which the project structure, source files, and resources are to be created.","A method createNewProject( )  of the generator  constructs the project directory structure, either in a directory that is specified by a path at construction time, or in a temporary directory.","A method generate( )  is the main method of the generator , and is responsible for actual code generation.","Compiler","Continuing to refer to  and , the compiler  is implemented as a compiler abstraction object, which uses the build tool  as a wrapper for the Java compiler . The compiler  compiles the Java source code produced by the generator  according to supplied directives.","The inputs of the compiler  are compiler directives and workspaces, which are J2ME wireless toolkit project workspaces in this embodiment. Other inputs of the compiler  are starting point files and Java source code files. The outputs of the compiler  are class files, which can be J2ME class files, and compilation log files.","The compiler  locates Java source code files using an input starting point. It invokes the Java compiler , which compiles the source code, and stores the result in a directory specified in a tag <Project-Dir>\\tmpclasses. A verification module preverify.exe is then executed using a system call. Verified classes are copied into the directory specified in the tag <Project-Dir>\\classes. Compilation log files are also produced by the compiler .","The compiler  includes a public function main( )  and two private functions: a method printprocessInputLine( ) , which processes the input command line for application flags and parameter values, and a method printUsage( ) , which outputs usage data of the compiler  to a system display, for example System.out.","Packer","Continuing to refer to  and , the packer  creates an application descriptor file (*.jad file), and creates a JAR manifest file. The packer  packages the project classes and resources in a MIDlet JAR file, and is linked with the build tool  and the wizzle . The packer  may package additional classes, e.g., licensee open classes. The input of the packer  is specified in the tag <ProjectDir> directory starting point. In addition, the packer  packages the association object AppDescriptor, obtained from the parser  or another source (not shown). The packer  may operate in response to specific packing directives. By default, the packer  includes class files and resources specified by the MIDML source. The defaults are modifiable as required for a particular application. The output of the packer  is a packed MIDlet with its respective *.jar and *.jad file residing in the directory specified in the tag <Project-Dir>\\bin.","The packer  includes a method DynaMIDPacker( ) , which is a class constructor. A method packageApp( )  creates the JAR file to package the MIDlet using the standard resource java.util.jar. The method packageApp( )  also creates the JAD file, its manifest, and adds the appropriate URL and viewer (QAZ).","Servlet","The servlet  is linked to the wizzle . It has a public function doGet( ) , which accepts a HTTP servlet request from a user, and returns a servlet response, which can be the requested MIDlet. The MIDlet may be returned as a JAR file and a JAD file, or as a file that can be directly executed on the target device. Alternatively, the servlet may return an access code, such as a URL, which can be accessed by the user to obtain the MIDlet.","Wizzle","The wizzle  is a helper class that is linked to several other classes: the compiler ; servlet ; build tool ; parser ; generator ; Java compiler ; and packer . The wizzle  includes several public methods. A method DynaMIDWizzle( )  is a class constructor. A method compile( )  activates the library object responsible for compilation and preverification. A method generate(  activates the library object responsible for code generation for the MIDlet. A method archive( )  activates the library object responsible for packing the generated MIDlet and other objects together in a JAR file. The method parse( )  activates the library object responsible for parsing input.","Build Tool (Ant)","The build tool  provides a number of services and performs various tasks relating to library classes, for example, copying infrastructural files. A method DynaMIDAnt( )  is a class constructor. A method createProjectStructure( )  creates the project's directory structure. A method compileProject( )  activates the Java compiler . A method preverifyProject( )  is responsible for activation of a preverify tool (not shown). A method archiveProject( )  is responsible for activating the packer . The archive process of the project involves writing a manifest, activating the JAR tool (not shown) and writing the project JAD file. A method cleanupProject( )  performs project clean-up and deletion of all temporary files, including Java sources, MIDML sources, Java classes and other resources. A method copyResource( )  facilitates the task of copying resources, typically into a designated resource directory. A method copyInfraFiles( )  copies infrastructure files that may be packaged in the project JAR file, for example files relating to screen navigation, or to servlet connection for the generated code request.","Factory","The factory class  is a basic infrastructural class that is used by two other classes, the descriptor element factory  (), and the generation object factory  (). A factory derived from the factory class  always produces a single product from a single base class.","A method DynaMIDFactory( )  is a constructor for the factory class . A method register( )  is used for registration of factory products. A method lookup( )  checks for the existence of a key in the registration database, and if found, it returns a product class name. A method create( )  is a safe creation function, which calls the method lookup( ) . The method create( )  only returns registered product objects, which are also valid instances of the factory product base class. An unsafe creation method, createNoLookup( ) , executes without checking for valid instances of the factory product base class. It does not call the method lookup( ) . Another creation method, createVerboseConstructor( )  is a private constructor, which enables logging of DescriptorElements. Verbosity of its mode of operation is specified by a parameter productVerboseMode.","Java Compiler","The Java compiler  is linked with the build tool  and the wizzle . It includes a class constructor, which is the method DynaMIDCompiler( ) .","Logger","The class PrivateLogger  has a method PrivateLogger( ) , which is a class constructor.","Library Operations","Parser Classes","Reference is now made to , which is a class diagram of the parser  (), and its associated components. The disclosure of  should be read in conjunction with  and . A descriptor element factory , based on the Java factory design, associates a class DescriptorElement  with a name. The descriptor element factory  includes a mechanism that is used by the parser  for producing the class DescriptorElement . The class DescriptorElement  is the base class for all descriptor elements of the descriptor object model  (). Descriptor elements are the building blocks of a MIDML application. Generation of descriptor elements creates a composite tree structure, which is then prompted for Java source code generation.","A class DynaMIDProjectDescriptor  is a container for the descriptor object model  (), the main data structure used by the parser , and the JAD data object AppMetaDescriptor . The parser  is accessed using the above-noted Java document object model. The class DynamidProjectDescriptor  is the main association class between the parser , the generator , and the packer  (). The class DynamidProjectDescriptor  is responsible for maintaining the data as the operation of the system progresses, and for maintaining system progress status.","The methods of the class DynamidProjectDescriptor  include a method AppMetaDescriptor( ) . This is a class constructor, which constructs a class having default values. A method writeMetaData( )  generates the metadata of the application descriptor.","A class JDOM wrapper  is a wrapper class for the schema interface responsible for facilitating XML parsing and validation. It includes a static parsing method parseXML( ) , and a static method printElementAttributes( ) , which prints the attributes of a JDOM element. A static method printJDOM( )  recursively prints a JDOM tree. A method printOffset( )  prints a JDOM tree offset.","A MIDML project parse exception class MPRParseException  is provided to deal with parsing errors. It includes a method MPRParseException( ) , which is a class constructor, and a method MPRParseException( )  is thrown whenever an error occurs while parsing the MIDML project file.","A class ProjectDescriptor  is linked with the class DynamidProjectDescriptor . The class ProjectDescriptor  is the main association class between the parser , the generator  and the packer  (). The class ProjectDescriptor  is responsible for holding data and status information as the project progresses. The class ProjectDescriptor  is also linked to the class DescriptorElement . It has a method DynaMIDProjectDescriptor( ) , which is a class constructor.","A class MDOMBuilder  is used in some embodiments to build a MDOM tree, which is a composite tree structure of descriptor elements, using a pre-existing JDOM tree. The JDOM tree is used as a XML interface to the project MIDML code. The class MDOMBuilder  is linked with the descriptor element factory . The class MDOMBuilder  has a method MDOMBuilder( ) , which is a class constructor. The class MDOMBuilder  has a method getMIDMLApp( ) , which returns the name of the current MIDML application being generated. A method generateMDOMRoot( )  generates a root for a MDOM tree. A method buildMDOMImpl( )  adds JDOM elements to the MDOM tree. A method buildMDOM( )  sets up internal links within the MDOM tree itself.","The class MDOMBuilder  can be implemented as a separate tool to create the MDOM tree Listing  is a pseudocode fragment that discloses a recursive algorithm employed by the class MDOMBuilder . The input to the algorithm of Listing  is a valid pre-defined XML tree structure, which is traversed. Typically, this tree structure is the JDOM tree. However, other tree structures can be used. Indeed, the algorithm of Listing  may be generalized to any given valid XML tree structure, also known as a XML DOM. The XML DOM is a well-known data structure, and is further disclosed, for example, on the Internet.","In other embodiments the MDOM tree is constructed on-the-fly, by dynamically binding MIDML data during parsing of the MIDML source, and the class MDOMBuilder  is omitted.","A class JAD  extends the class DynamidProjectDescriptor , and produces a JAD implementation of an application descriptor. It has a method JAD( ) , which is a class constructor. A method writeMetaData( )  generates the JAD file for the current MIDlet application.","The descriptor element factory  has a method DescriptorFactory( ) , which is a class constructor. The method DescriptorFactory( )  registers products, which is derived from the class DescriptorElement . A method createDescriptorElement( )  performs a lookup for a requested MIDML tag name, calling a method lookup( ) . If the method lookup( )  is successful a new instance of the corresponding descriptor element is created. A method registerDescriptorElement( )  actually performs the registration of the new descriptor element.","The class DescriptorElement  is linked to the class ProjectDescriptor . It has two methods DescriptorElement( ) , , which are alternative class constructors. A method bind( )  is the main operational method for the class DescriptorElement . Each descriptor element of the descriptor object model  () is capable of parsing itself from a pre-existing JDOM tree and of filling in its specific MIDML data. A method getChildByName( )  returns the first child descriptor element of a current descriptor element having a specified name. If the requested element is not found, then the value null is returned. A method AddChild( )  adds a new descriptor element to a parent\u2014child vector, which is a container holding all descriptor elements at a lower level in the MDOM tree, which are derived from a higher level.","Parser Sequence.","Continuing to refer to , the descriptor element factory  is a specific single product class factory. It is instantiated with the class DescriptorElement . The class DescriptorElement  is the super class for all MIDML descriptors. This factory registers all native MIDML element tags. The registration assigns to each MIDML tag its corresponding DescriptorElement class. New extensible elements of MIDML register themselves in the descriptor element factory , a feature that allows the infrastructure  () to be extended. Upon request of a MIDML tag, the descriptor element factory  factory may perform a lookup and return the requested descriptor element.","The MDOM iterative binding algorithm to MIDML source data (content) is disclosed as pseudocode in Listing 41. Each descriptor element is created from the descriptor element factory  using the current tag name. Each descriptor element is responsible for binding its private data, which resides in its MIDML tag definition. The descriptor element is also responsible for binding all of its MIDML sub-elements. The iterative binding algorithm is activated for each sub-element.","Reference is now made to , which is a sequence diagram showing the main process of the parser . The disclosure of  should be read in conjunction with , , and . In an activation , the compiler  and the servlet  set up the parser  with the aid of the wizzle . The wizzle  begins operation in an activation  upon receipt of a method invoking the method parse( )  () on a message line . The wizzle  then invokes method MIDMLParser( )  (), the constructor of the parser  on a message line , producing an activation . The project starting-point is passed to the wizzle  as an input.","The parser  begins the parsing process by an invocation of a method getmidAppDescriptorPath( )  by the wizzle  on a message line , which produces an activation . The method getmidAppDescriptorPath( )  returns a string that contains the project descriptor file path. The parser  then receives an invocation of the method parse( )  () on a message line , to produce an activation .","In the activation , the class JDOM wrapper  is activated in an activation  by invocation of the method parseXML( )  () on a message line .","Next, the parser  commands the descriptor element factory  to create a descriptor element by invoking the method CreateDescriptorElement( )  () on a message line , which results in an activation . Next, the parser  sends commands resulting in the configuration and binding of the class DescriptorElement  on message lines , , which result in activations , , respectively. This operation culminates in an invocation of the method bind( )  () on a message line , which results in an activation . A completion indication is returned to the parser  from the class DescriptorElement  to the parser  on a message line .","In response to the information received from the class DescriptorElement , the parser parses JAD data during an activation  using the method parseJadData( )  (). Upon completion of the parsing operation, the parser  transmits a message to the wizzle  on a message line . The wizzle  communicates a completion message to the compiler  on a message line .","MIDML Descriptor Object Model Classes","Reference is now made to , which is a class diagram of the descriptor object model  (). The disclosure of  should be read in conjunction with , , and . The descriptor object model  is a tree oriented data structure, which is embodied in the class DescriptorElement  (). Descriptor elements are data objects, which bind to the MIDML language elements, creating a hierarchical description of the application structure. MDOM objects are the source for the code generation process for the MIDlet application  (). Classes that are used for the class DescriptorElement  include the class descriptor element factory  (), events , a widget , and a class screen .","A class MidletApp  is linked with the class DescriptorElement  and the class screen . The class screen  is linked with the widget  and the class DescriptorElement . The class DescriptorElement  is linked with the descriptor element factory , the widget , and the events . The operations and functions relating to the various classes illustrated in  are described in further detail in other sections hereof.","Generator Classes","Reference is now made to , which is an object model class diagram showing the principal components of the working objects of the generator  (). When the generator  is set up, appropriate instances of a class GeneratorObjectModel  are created using a generation object factory . Factory functionality is extended in the design to define the generation object factory . This is a specific single product class factory. The generation object factory  is instantiated with the class GeneratorObjectModel . This is the super class for all source code-generating objects. Each code-generating object is needed in a well-defined time slot in the code generation process. Thus, code generation objects are constantly reused. The generation object factory  registers all native MIDML element tags, assigning each MIDML tag to its corresponding instance of the class GeneratorObjectModel . New elements of MIDML can register with the generation object factory . Upon a request represented by a MIDML tag, the generation object factory  may perform a lookup and return the requested descriptor element. Where a method is referred to herein with respect to different classes by the same name, it will be understood that it performs the same or an analogous function in all such classes.","The generation object factory  and the class GeneratorObjectModel  are interlinked with one another and with the generator .","Each generation object is a generator that is responsible for producing specific MIDML Java source code. The generation object factory  is flexible, and its benefits include efficient source code generation, support for extensions to the code generation capabilities of the system, and the capability of generic code generation. Generic code generation means that the entire class hierarchy of the generator object model is replaced with a new class hierarchy describing a different technology.","The generation object factory  has a method genFactory( ) , which is a class constructor. A method create( )  is the principal creation method in the generation object factory . In operation, the method create( )  initially determines if the requested object was previously created. If so, its reference is returned. If the requested object was not previously created, the generation object factory  creates a new object, providing that the name of the desired object was previously registered. The method create( )  then saves a reference to the new object for future requests.","The class GeneratorObjectModel  has a method genObjectModel( ) , which is a class constructor.","Generator Sequence","Reference is now made to , which is a sequence diagram of the operation of the generator  (). The disclosure of  should be read in conjunction with , , , , and .  shows the main process of the generator .","MIDlet generation assumes a valid MDOM tree as input. Source code generation is incremental and performed in a top-down manner, i.e., the main MIDlet class is generated before its screen or other entities. Generation begins with the descriptor MIDletApp, which is the MDOM root. Generation is a linear process: each step begins upon successful completion of a preceding step, as the steps are dependent. At each generation step the current descriptor element generates itself completely, and then proceeds to generate its independent child elements. The algorithm for the generation procedure is disclosed in pseudocode in Listing 42.","Each of the following entities produces a new class file for its code generation: the descriptor MIDletApp, screens, servlets, and timers. Servlets and timers may be precompiled or may be represented as common classes.","The generator  is created by the compiler  and servlet . In an activation , the generator  invokes a method generate( )  on a message line . The code generation sequence starts here when the root generation object model  is created. The method generate( )  is propagated throughout the object model in order to create all the code needed for a full MIDlet application. Initially the method generate( )  causes creation of the workspace directories specified in a tag <Project-Dir>, and the processing of the project descriptor object  (). A result is eventually returned on a message line  as a Boolean status value. A successful result indicates the presence of generated Java source code files and resources on the disk.","In response to the message on the message line , the generation object model  () is activated and propagates the method generate( )  to a class GenMidletApp  on a message line . The class GenMidletApp  is a class that is responsible for generating the code for three application events that are mapped to the MIDlet abstract class: start, destroy and pause. These events are handled by the methods startApp, destroyApp, and pauseApp. The class GenMidletApp  is a root for further propagation of the method generate( ) .","In a series of activations  the class GenMidletApp  interacts with a class GenHelper , which is a helper class for the code generation task. The class GenHelper  facilitates sharing of objects among other classes that come into play during generation. Its specific responsibilities include rendering new member names, creating new Java source files, sharing the objects of the build tool  () with the generator classes, and sharing the generated MIDlet class name.","Initially, in an activation , invocation of a method getNewJavaClassFile( )  of the class GenHelper  returns a standard Java class PrintWriter for the Java source class file for the current project on a message line .","Next, as shown in a block , the class GenMidletApp , which hold the general MIDlet class definitions, performs a series of subtasks, which include writing the import clause, writing the class definition, writing certain definitions for private members, such as \u201cmyMIDlet\u201d, which is an automatically generated self-reference according to the MIDML specification. The reference myMIDlet is useful for MIDlet tasks, such as the tasks link( ) and back( ), which are disclosed below in further detail. The class GenMidletApp  also writes the screenstack and the display routines.","The class GenMidletApp  interacts with a class GenScreen , which is the base class for a screen generation class hierarchy. The class GenScreen  facilitates the screen generation process and renders services to the underlying implementation derived classes. Each screen has a header and the interface implementation methods, onLoad and onUnload. The screens may contain timers, variables, servlet connections, commands, ticker items and a title. This interaction begins in a sub-activation  when a method GetGenScreens( ) is iteratively invoked by the class GenMidletApp  on a line . This method returns an enumeration of the generated screens that comprise the current MIDlet. The class GenScreen  then undergoes an activation , when the method getGenerateClassName( ) is invoked by the class GenMidletApp  on a message line . The generated MIDlet class name is returned by the class GenScreen  to the class GenMidletApp  on a message line .","Next, an activation  of the class GenHelper  is initiated by the class GenMidletApp , which invokes a method getNewMember( ) on a message line . This method returns an automatically generated member name on a message line  for use during generation. Thus, string members may be returned by the names string, string, etc.","Next, as shown in a block , using an iteration process, the class GenMidletApp , performs a series of subtasks related to the screens. Screen definitions and screen lazy get methods are written.","Next, the class GenMidletApp  iteratively invokes a method getGenServletConnections( ), as shown on a line . This method is responsible for generating an appropriate servlet connection member. It is an aspect of the invention that the class that actually implements the servlet connection is precompiled, and need not to be generated. This begins an interaction with a class GenTextServletConnection , which implements a text protocol for code generation of the method GenServletConnection. The interaction begins in a sub-activation . The class GenTextServletConnection  undergoes an activation  in response to a message from the class GenMidletApp  on a message line , and returns a result on a message line . In the current embodiment a reference to the servlet and all relevant parameters needed to access the are actually generated.","Next, the class GenMidletApp  initiates another activation  of the class GenHelper  by invoking the method getNewMember( ) on a message line . A new member is returned to the class GenMidletApp  on a message line . All the screens, timers, servlets are represented as members during translation from MIDML source to source code. Such members are provided by the class GenHelper .","Next, the class GenMidletApp  initiates another activation  of the class GenTextServletConnection  by invoking a method getURL( ) on a message line . This method returns the URL of a current servlet from the class GenTextServletConnection  to the class GenMidletApp  on a message line .","Next, as shown in block , using an iterative process, the class GenMidletApp  performs a series of subtasks related to the servlet. Servlet definitions and lazy servlet get methods are written.","The class GenMidletApp  now interacts with a class genTimer , which generates event handlers, and in particular is responsible for generating the appropriate code to handle the onTime event. A method getGenTimers( ) is iteratively invoked by the class GenMidletApp  on a line  in a sub-activation . The method getGenTimers( ) returns an enumeration of the timers that are defined in the MIDML file for the project.","The interaction between the class GenMidletApp  and the class genTimer  begins when a method generate( ) is invoked by the class GenMidletApp  on a message line . An activation  is initiated in the class genTimer , and a result is returned from the class genTimer  to the class GenMidletApp  on a message line .","Next, the class GenMidletApp  initiates another activation  of the class GenHelper  by invoking the method getNewMember( ) on a message line . A new member is returned to the class GenMidletApp  on a message line .","Next, as shown in block , using an iterative process, the class GenMidletApp , performs a series of subtasks related to the timers. Timer definitions and timer lazy get methods are written.","The class GenMidletApp  now interacts with a class genApplicationStartEvent . This class is responsible for the generation of code for handling the startApp( ) method of a generated MIDlet descriptor element class, and deals with all operations that are defined in the startApp MIDML tag. An example of a startApp MIDML tag is found, for example in Listing 38.","Interaction between the class GenMidletApp  and the class genApplicationStartEvent  is initiated in a sub-activation  in which the class GenMidletApp  iteratively invokes the method getStartAppGenEvent( ) on line . The method getStartAppGenEvent( ) creates an event GenApplicationStartEvent that returns a method ApplicationStartEvent( ). The method ApplicationStartEvent( ) creates an event for a descriptor element.","A call to the method generate( ) on a message line  by the class GenMidletApp  initiates an activation  of the class genApplicationStartEvent .","As shown in a block , during the activation  the class genApplicationStartEvent  executes an iterative process, which includes write operations of the standard MIDP-1.0 startApp( ) method, which is invoked when a MIDlet enters an active state. An iterative invocation of a method getGenOperations( ) on a line  causes a series of activations of a base class GenOperation . The class GenOperation  generates code for elements, which correspond to operations that occur during run time. An enumeration of objects relating to DescriptorElements of the project is returned by the method getGenOperations( ).","First, a method setCodePrintWriter( ) is invoked by the class genApplicationStartEvent  on a message line  to initiate an activation  of the class GenOperation . The method setCodePrintWriter( ) sets the Java print writer of a generated element to create an object stream to which generated Java code is written.","Next, the method generate( ) is invoked by the class genApplicationStartEvent  on a message line  to initiate an activation  of the class GenOperation , which produces actual code generation. A result is returned from the class GenOperation  to the class genApplicationStartEvent  on a message line .","Next, the class genApplicationStartEvent  interacts with a class genLink . The class genLink  implements a MIDML link operation, which is the navigation operation of MIDML. The class genApplicationStartEvent  invokes a method getDest( ) on a message line  to initiate an activation  of the class genLink . The method getDest( ) returns the destination Screen name of a link on a message line  from the class genLink  to the class genApplicationStartEvent . A completion message is then returned by the class genApplicationStartEvent  to the class GenMidletApp  on a message line .","The class GenMidletApp  now initiates the generation of code for the pauseApp( ) method of a generated MIDlet class, which takes place in a sub-activation . The class GenMidletApp  iteratively invokes a method getPauseAppGenEvent( ) on a line . The method getPauseAppGenEvent( ) creates an event GenApplicationPauseEvent that returns a method ApplicationPauseEvent( ). The method ApplicationPauseEvent( ) creates an event for a descriptor element. The operation is the same as for the method startApp( ) disclosed hereinabove, except for a difference in the initial screen link. The details are not repeated in the interest of brevity.","The class GenMidletApp  now initiates the generation of code for the destroyApp( ) method of a generated MIDlet class, which takes place in a sub-activation . The class GenMidletApp  iteratively invokes a method getEndAppGenEvent( ) on a line . The method getEndAppGenEvent( ) creates an event GenApplicationDestroyEvent that returns a method ApplicationDestroyEvent( ). The method ApplicationDestroyEvent( ) creates an event for a descriptor element. The operation is the same as for the method startApp( ) disclosed hereinabove, except for a difference in the initial screen link. As above, the details are not repeated in the interest of brevity.","Next, as shown in a block , the class GenMidletApp  writes two predefined navigation methods. A method link( ) enables application flow from one MIDML Screen to another. A method back( ) enables flow among MIDML screens in a reverse direction.","The class GenMidletApp  again interacts with the class GenScreen  in a sub-activation , which is begun by another iterative invocation of the method GetGenScreens( ) on a line . An activation  of the class GenScreen  is initiated by an invocation of the method generate( ) on a message line . As shown in a block , the class GenScreen  writes a class definition and a myMidlet member.","The class GenScreen  now invokes a method getNewJavaClassFile( ), requesting the name of the name for a Java source class file from the class GenHelper  on a message line . The method getNewJavaClassFile( ) returns a Java PrintWriter on a message line  directed to the source class file, which is located in the project directory. The method getNewJavaClassFile( ) is invoked iteratively, as each screen requires its own Java source class file.","The class GenScreen  now interacts with a class GenCommand  in a sub-activation . As shown in a block , command definitions and static constructors are iteratively written by the class GenScreen . The class GenCommand  is responsible for generating source code for a command. The interaction begins by the iterative invocation of a method getGenCommands( )by the class GenScreen  on a line . The method getGenCommands( ) returns an enumeration of the commands defined in the current screen.","Next, the class GenScreen  initiates an activation  of the class GenCommand  by invoking a method getGenerateClassName( ) on a message line . The method getGenerateClassName( ) returns a string containing the name of the class being generated on a message line .","Next, the class GenScreen  initiates an activation  of the class GenCommand  by invoking a method getconstructor( ) on a message line . The method getConstructor( ) returns a String representing a constructor call statement on a message line .","The class GenScreen  now invokes the method getNewMember( ) to initiate an activation  of the class GenHelper  on a message line . Upon receipt of a response on a message line , an interaction occurs between the class GenScreen  and an abstract class genMTDPItem . The class genMIDPItem  is the abstract superclass for all MIDP originated Items, for example the items StringItem, ImageItem. All MIDP item generators inherit from this class.","The interaction begins when a method GetGenItems( ) is iteratively invoked by the class GenScreen  on line  in a sub-activation . The method GetGenItems( ) returns an enumeration of servlet connections corresponding to the items defined for the current screen in the project MIDML file. In an iterative process, the class GenScreen  writes item definitions and get\/set methods, as shown in a block .","Next, the class GenScreen  initiates an activation  of the class genMIDPItem  by invoking a method getGenerateClassName( ) on a message line . The method getGenerateClassName( ) returns a string containing the name of the class being generated on a message line .","The class GenScreen  again invokes the method getNewMember( ) to initiate an activation  of the class GenHelper  on a message line . Upon receipt of a response on a message line , the class GenScreen  initiates an activation  of the class genMIDPItem  by invoking a method getSetValueBody( ) on a message line . The method getSetValueBody( ) returns the get and set methods of a user interface object on a message line , and is additionally responsible for generating the body of the set method.","Next, the class GenScreen  initiates an activation  of the class genMIDPItem  by invoking a method getGetStringValueBody( ) on a message line . The method getGetStringValueBody( ) returns the get and set methods of a user interface object on a message line , and is additionally responsible for generating the string identifying the get method.","An interaction now occurs between the class GenScreen  and a class Genticker , which is responsible for generating code for a ticker object. The interaction begins when a method GetGenTicker( ) is iteratively invoked by the class GenScreen  on a line  in a sub-activation . The method GetGenTicker( ) returns the ticker that is defined for the current screen in the project MIDML file. As shown in block , the class GenScreen  writes the screen ticker item.","Next, the class GenScreen  initiates an activation  of the class Genticker  by invoking a method getGenTicker( ) on a message line . The method getGenTicker( ) returns the ticker definitions string from the class Genticker  to the class GenScreen  on a message line . The ticker definitions string is then written to the screen class file.","The class GenScreen  again invokes the method getNewMember( ) to initiate an activation  of the class GenHelper  on a message line . Upon receipt of a response on a message line , the class GenScreen  initiates an activation  of the class Genticker  by invoking the method getSetMethodBody( ) on a message line . The method getsetMethodBody( ) returns on a message line .","Next, the class GenScreen  initiates an activation  of the class Genticker  by invoking the method getGetStringMethodBody( ) on a message line . The method getGetStringMethodBody( ) is responsible in generating the string that is returned by the method getSetMethodBody( ). The method getGetStringMethodBody( ) returns its result on a message line .","Next, the class GenScreen  undergoes a series of operations in a sub-activation . The class GenScreen  initiates an activation  of the class GenHelper  by invoking a method getMyMIDletClassName( ) on a message line . The method getMyMIDletClassName( ) returns a generated MIDlet class name. This name is shared by all generator classes that need a reference to the MIDlet. The result is returned on a message line .","Next, in the sub-activation , the class GenScreen  iteratively invokes a method writeconstructor( ) on a line , which produces a constructor for the current screen. Then, a method writeAddCommands( ) is iteratively invoked on a line , which generates add MIDP widget commands, for example a button, which is used to encapsulate an action. Next, a method writeItemsConstruction( ) is iteratively invoked on a line , which generates constructors for individual items in the current screen.","Next, a method writeAppendItems( ) is iteratively invoked on a line  by the class GenScreen . The method writeAppendItems( ) generates append items. The method writeAppendItems( ) writes the Java code that actually adds an item to a MIDP form screen. MIDP Form screens are disclosed in the above-noted Mobile Information Device Profile (JSR-37), JCP Specification.","Next, a method writeRegisteredListeners( ) is iteratively invoked in a line  by the class GenScreen . The method writeRegisteredListeners( ) generates a \u201cset listeners call\u201d, an operation that sets the current screen to listen to action events resulting from commands issued through its own widgets, and to item state events arising from items related to the screen.","The class GenScreen  now interacts again with the class GenCommand  and with a class genCommandActionEvent  in a sub-activation . The class genCommandActionEvent  is responsible for generating code for MIDP command action events. The sub-activation  begins with an iterative invocation of a method writeCommandActionHandler( ) on a line . The method writeCommandActionHandler( ) generates a command action method for the current screen, and returns a Boolean status.","Next, the method getGenCommands( ) is invoked on a line . Then, interaction with the class GenCommand  begins with an invocation of a method getGenEvent( ) on a message line . The method getGenEvent( ) retrieves an event associated with the current screen. In response, the class GenCommand  undergoes an activation . The event is returned from the class GenCommand  to the class GenScreen  on a message line .","Interaction with the class genCommandActionEvent  now begins by an invocation by the class GenScreen  of the method generate( ) on a message line , resulting in an activation  of the class genCommandActionEvent . During the activation , a command action event is retrieved for each command relating to the current screen. Operational code is generated for the command's action method.","The activation  begins with an iterative invocation of the method getGenOperations( ) on a line . Now a series of interactions occurs between the class genCommandActionEvent  and the class GenOperation . First the method setMsgPrintWriter( ) is invoked by the class genCommandActionEvent  on a message line , resulting in an activation  of the class GenOperation .","Next, the method setCodePrintWriter( ) is invoked by the class genCommandActionEvent  on a message line , resulting in an activation  of the class GenOperation .","Next, the method generate( ) is invoked by the class genCommandActionEvent  on a message line , resulting in an activation  of the class GenOperation . Then, the final result of the activation  is returned from the class genCommandActionEvent  to the class GenScreen  on a message line .","The class GenScreen  now initiates a subactivation  by iteratively invoking a method writeItemStateChangedHandler( ) on a line . The method writeItemStateChangedHandler( ) generates code for a method that handles a change in the state of an item of the current screen, the ItemStateChanged( ) method. Next the method getGenItems( ) is iteratively invoked on a line .","Now the class GenScreen  initiates an activation  of the class genMIDPItem  by invoking the method getGenEvent( ) on a message line . The result is returned on a message line .","The class GenScreen  interacts with a class genItemStateChangedEvent . The class genItemStateChangedEvent  is responsible for the generation of event handling code relating to changes in an item's state, (ItemStateChanged events). In the interaction, the state events for each item are identified, and the code for a corresponding event-handling operation is generated. Invocation of the method generate( ) on a message line  by the class GenScreen  results in an activation  of the class genItemStateChangedEvent . The activation  begins with an iterative invocation of the method getGenOperations( ) on a line .","The class genItemStateChangedEvent  now interacts with the class GenOperation . The interaction begins when the method setMsgPrintWriter( ) is invoked by the class genItemStateChangedEvent  on a message line . The class GenOperation  then undergoes an activation . Next the class genItemStateChangedEvent  invokes the method setCodePrintwriter( ) on a message line  to produce an activation  of the class GenOperation . The class genItemStateChangedEvent  then invokes the method generate( ) on a message line  to produce an activation  of the class GenOperation , which results in actual code generation. A result is then returned by the class genItemStateChangedEvent  to the class GenScreen  on a message line .","The class GenScreen  now initiates a subactivation  by iteratively writing event handler code for the onLoad event of each screen, as indicated by a line . The class GenScreen  interacts with a class genScreenLoadEvent . In this interaction, the state events for each item are identified, and the code for a corresponding onLoad event-handling operation is generated. Invocation of the method generate( ) on a message line  by the class GenScreen  results in an activation  of the class genScreenLoadEvent . The activation  begins with an iterative invocation of the method getGenOperations( ) on a line .","The class genScreenLoadEvent  now interacts with the class GenOperation . The interaction begins when the method setMsgPrintWriter( ) is invoked by the class genScreenLoadEvent  on a message line . The class GenOperation  then undergoes an activation . Next the class genScreenLoadEvent  invokes the method setCodePrintWriter( ) on a message line  to produce an activation  of the class GenOperation . The class genscreenloadevent  then invokes the method generate( ) on a message line  to produce an activation  of the class GenOperation , which results in actual code generation. A result is then returned by the genScreenLoadEvent  to the class GenScreen  on a message line .","The class GenScreen  now initiates a subactivation  by iteratively writing event handler code for the onUnLoad event of each screen, as indicated by a line . The class GenScreen  interacts with a class genScreenUnLoadevent . In this interaction, the state events for each item are identified, and the code for a corresponding onUnload event-handling operation is generated. Invocation of the method generate( ) on a message line  by the class GenScreen  results in an activation  of the class genscreenUnLoadevent . The activation  begins with an iterative invocation of the method getGenOperations( ) on a line .","The class genscreenUnLoadevent  now interacts with the class GenOperation . The interaction begins when the method setMsgPrintWriter( ) is invoked by the class genscreenUnLoadevent  on a message line . The class GenOperation  then undergoes an activation . Next the class genscreenUnLoadevent  invokes the method setCodePrintWriter( ) on a message line  to produce an activation  of the class GenOperation . The class genscreenUnLoadevent  then invokes the method generate( ) on a message line  to produce an activation  of the class GenOperation , which results in actual code generation. A result is then returned by the class genscreenUnLoadevent  to the class GenScreen  on a message line .","The class GenScreen  now completes its execution by returning a status result to the class GenMidletApp  on a message line .","The class GenMidletApp  now interacts with a class genTimer . The method generate( ) is invoked by the class GenMidletApp  on a message line , which initiates an activation  of the class genTimer . In the activation , timer class source files are generated. First, the class genTimer  invokes the method getNewJavaClassFile( ) on a message line , which produces an activation  of the class GenHelper . A new Java PrintStream is returned by this activation.","Next, the class genTimer  iteratively invokes a method getOnTimerEvent( ) on a line , which creates code for each timer event of the MIDlet. The class genTimer  interacts with a class genTimerEvent . The class genTimerEvent  is responsible for code generation relating to timer events. Invocation of the method generate( ) on a message line  by the class genTimer  results in an activation  of the class genTimerEvent . The activation  begins with an iterative invocation of the method getGenOperations( ) on a line .","The class genTimerEvent  now interacts with the class GenOperation . This interaction begins when the method setMsgPrintWriter( ) is invoked by the class genTimerEvent  on a message line  to produce an activation  of the class GenOperation . Next, the class genTimerEvent  invokes the method setCodePrintWriter( ) on a message line  to produce an activation  of the class GenOperation . The class genTimerEvent  then invokes the method generate( ) on a message line  to produce an activation  of the class GenOperation , which results in actual code generation. A result is then returned by the class genTimerEvent  to the class genTimer  on a message line .","The class genTimer  returns a status report to the class GenMidletApp  on a message line . Then the class GenMidletApp  communicates a status report to the generation object model  on a message line . The above-mentioned final status message of the generator sequence is communicated from the generation object model  to the generator  on the message line .","MIDML Compiler Sequence","Reference is now made to , which is a sequence diagram of the main process of a MIDML compiler object , which is created by the compiler  and the servlet  (). The disclosure of  should be read in conjunction with , , , and . In an activation , following a compiler input, which is a source project path specified in a tag <Project-Dir>, the method compile( )  () is invoked to initiate the compilation and pre-verification process on a message line .","The wizzle  () receives the message on the message line , and is activated in an activation . The wizzle  activates the constructor of the MIDML compiler object  on a message line , resulting in an activation . Next, the wizzle  invokes the compile method of the MIDML compiler object  on a message line , which causes an activation .","The compiler uses the build tool  () as a wrapper for the Java compiler  (). During the activation , the MIDML compiler object  invokes the method compileProject( )  () on a message line , which instructs the build tool  to compile the project. This results in an activation .","Upon completion of the compilation, indicated by a message line , the MIDML compiler object  initiates preverification of the result on a message line  by invoking the method preverifyProject( )  (). This results in an activation  of the build tool , shown along its object lifeline . The results of the preverification process are communicated by the build tool  to the MIDML compiler object  on a message line . The MIDML compiler object  reports completion of the Java compilation to the wizzle  on a message line .","Packer Sequence","Reference is now made to , which is a sequence diagram shows the main process of the packer  (). The disclosure of  should be read in conjunction with , , , and . The packer  is created by the compiler  and the servlet  ().","The compiler input is a source project path specified in a tag <Project-Dir>. In an activation , the method archive( )  () initiates the archival process on a message line . The wizzle  () receives the invocation of the method archive( )  on the message line , and is activated in an activation . The wizzle  invokes the constructor of the packer  on a message line , resulting in an activation . Next, the wizzle  communicates an instruction to the packer  that invokes the method packageApp( )  () on a message line . This produces an activation .","The packer  invokes the method archiveProject( )  () of the build tool  () on a message line . The build tool  is used as a wrapper for the JAR utility. In an activation , the build tool  invokes the method writeMetaData( )  () of the class DynamidProjectDescriptor , which results in an activation , and the production of metadata. On completion of this task, a status message is relayed from a JAD descriptor module of the class DynamidProjectDescriptor  to the build tool , the packer , the wizzle , the compiler  and the servlet  on message lines , ,  and , respectively. Upon receiving the status message on the message line , the packer  generates the JAD file.","Extensibility.","Referring again to , , and , the infrastructure  is seen to be extensible. The modules of the infrastructure  provide correlation between a MIDML tag defined by a user, and specific classes of the project descriptor object  and the generation object model . These classes are loosely coupled, and are integrated in run time. The project descriptor object  is integrated with the descriptor object model . The generator  is integrated with the generation object model .","The above-mentioned correlation and integration are performed at run time, and do not require modification or recompilation of the infrastructure .","A XML Schema defines an extension tag, which can be added as an element of a MIDML document. Correlation of a newly defined extension tag with the class DescriptorElement  () and the generation object model  is accomplished using a configuration properties file, when the classes are precompiled. The properties file contains configuration entries, an example of which is shown in Listing 36. The descriptor element factory  () and the generation object factory  () register the name of the extension tag as a key. The descriptor element factory  and the generation object factory  register the class names of the project descriptor object  and the generation object model  as a products class name. These registrations provide correlation between the classes and the tag name. Any needed products can be retrieved from the descriptor element factory .","Polymorphic Generation Extensibility Implementation","Referring again to , , , and , there are important advantages in producing different generation object models for different project descriptors, and registering each model correctly in the generation object factory  (). Each generation object model has a corresponding project descriptor accessible during execution of the method generate( ), as best seen on the message line  (). All necessary MIDML information that needs to be generated is encapsulated within a single associated project descriptor. Every building block of a standard MIDlet application is described in the MIDML file. However, the specific technology to be used is not specified or constrained in the MIDML file. Thus, it is possible to use the same MIDML markup code and the same descriptor object model to generate many versions of a MIDlet application for different technological implementations and for different mobile information devices.","Reference is now made to , which is a flow diagram illustrating a process, wherein a MIDlet appropriate to a particular mobile information device is generated and downloaded in accordance with a disclosed embodiment of the invention. The process begins at initial step  in which a mobile device user is connected to a data network, typically the Internet, and browses an application catalog or contentprovider Web site and requests download of a MIDlet to be executed on the user's particular mobile information device. The request is typically a HTTP request.","Next, in step , a servlet running on the Web site acknowledges the HTTP request. The request normally includes an identification of the mobile information device. However, if information is lacking the servlet queries the requestor for additional information in order to adequately determine the identity and characteristics of the mobile information device. The requester may also be prompted to input personal preferences regarding the desired operational characteristics and appearance of the MIDlet that is to run on the particular mobile information device in question.","Next at decision step  a determination is made whether a MIDlet is found in the cache that is consistent with the HTTP request of step . If the determination at decision step  is affirmative, then control proceeds to final step , where the requested MIDlet is downloaded to the mobile information device.","If the determination at decision step  is negative, then control proceeds to step , where the servlet identifies the characteristics of the mobile information device, and identifies resources that are required to produce an updated MIDlet in order to satisfy the request that was received in step . These resources typically include MIDML files and library resource files.","Next, a compiler and infrastructural resources, such as are disclosed hereinabove, are invoked in step . Here the compiler causes the generation of objects that are adapted to the particular mobile information device, as disclosed in the sections entitled Generator Classes and Generator Sequence. For example, a specialized class (e.g., class GeneratorObjectModel  ()) may be instantiated for a specific device, and generates device-specific Java source code. As an additional example, the generated screen classes produce Java source code that differs for devices having different display capabilities. The requestor's personal preferences, if relevant, are also taken into account here.","When the MIDlet has been generated and packaged, control proceeds to final step , and the process terminates.","Reference is now made to , which is a block diagram illustrating an arrangement in accordance with an alternate embodiment of the invention. A user of a small computer  executes a browser . The computer  is connected to a data network  over a link . The user also operates a mobile information device , for which MIDlet applications are offered by an electronic commerce web site , which is connected to the data network  via a link . The mobile information device  is connected to the data network  via a link . The mobile information device  may also be connected to the computer  over a wired or wireless link .","The user accesses the web site  using the browser  and may determine that it is desirable to evaluate an offered MIDlet application. A request is sent to the web site  via the data network , specifying download of an application having the functionality of the desired MIDlet, but configured as an applet that can be executed on the computer . A server  of the web site  responds by performing the method disclosed in the discussion of . An applet is generated and downloaded to the computer  via the link  and the link .","The user now executes the applet on the computer . If the user decides to acquire the offered MIDlet, a second request, specifying download of the MIDlet appropriate to the characteristics of the mobile information device , is transmitted to the web site . The second request may traverse the link  and the link . Alternatively, the computer  may communicate with the mobile information device  over the link , which can be a wired or a wireless link. In this case, the mobile information device  may then initiate the second request upon receipt of a signal from the computer  over the link . The request reaches the web site  over the link  and the link .","In any case, the server  responds to the second request, again performs the method disclosed in , and generates the MIDlet. Download from the web site  can occur directly to the mobile information device  via the link  and the link . Alternatively, the MIDlet can be downloaded to the computer  over the link  and the link , and can be relayed to the mobile information device  via the link .","Use Cases","Reference is now made to , which is a block diagram illustrating use cases for the system disclosed with reference to  and . The system is indicated generally as an organizational infrastructure . It is believed that understanding of the following use cases will be facilitated by a brief summary of the operation of the system. The developer  initially prepares a specification of a MIDlet using a markup language, and submits it to the compiler . The compiler  parses the specification, and prepares a file in an intermediate code, such as Java source code. This is processed by a code generator, represented as generation components , to produce a MIDlet. The developer  may provide additional content for the MIDlet, even after it has been generated.","The servlet  is a HTTP service interface handles requests of an end user . The end user  requests the MIDlet via the servlet  for download to the mobile information device . As explained above, the servlet  may respond to the request of the end user  by causing the compiler  to regenerate or update the MIDlet.",{"@attributes":{"id":"p-0329","num":"0341"},"figref":"FIG. 7","b":["926","28","924","928","926","929"]},"Use Case 1","In use case 1, it is intended to generate, compile and package a MIDlet from a MIDML Application. A MIDML developer  develops a MIDML Application and deploys it in an accessible web-server or file server. The developer  initiates the use-case by activation of the compiler  () with the URL or file path for the MIDML application starting point and all other applicable compiler directives, e.g., directives relating to saving intermediate files, verbose mode operation, use of a log file, and access to external classes and JAR files.","The compiler  activates its generation components , resulting in the following operations on the MIDML application: parsing, code generation, compilation using a Java compiler, and packaging of the created application. In a successful scenario, the creation of JAR and JAD files for the generated MIDlet is reported to the developer .","The system is capable of recognizing and reporting the following failure scenarios:","Failure scenario 1: The compiler  cannot find the application starting point. The file may not be accessible due to URL or file path error. An error message is returned to the developer .","Failure scenario 2: The compiler  found an invalid MIDML file. A XML parser error is returned to the developer .","Failure scenario 3: The compiler  failed to find the application descriptor in the starting point file. An error message is returned to the developer .","Failure scenario 4: The compiler  found a dead link to another MIDML file. Generation and compilation stops. An error message is returned to the developer  describing the file name and line number of the dead link directive.","Failure scenario 5: The compiler  invoked the Java compiler, and the compilation failed. Appropriate Java compiler error messages are returned to the developer .","Failure scenario 6: The compiler  cannot access the output specified location. The JAD and JAR files cannot be written. An error message is returned to the developer .","Use Case 2","Continuing to refer to , in use case 2 it is intended to service a HTTP request for a MIDML application. A MIDlet is generated, compiled, and packaged from a MIDML application. The MIDlet is sent to the mobile information device .","The developer  develops the MIDML Application and deploys it in an accessible web-server or file server. Either the developer  or the end user  can initiate the servlet  by sending a HTTP request that is associated with the URL of the servlet . The HTPP request parameters indicate the URL for the requested MIDML application, and also includes generation directives for the compiler , so that the updated version of the MIDlet can be recompiled as appropriate.","The servlet  searches for the requested MIDML application in its cache. If the requested MIDlet is found in the cache and is consistent with the HTPP request, it is downloaded to the mobile information device .","Otherwise, the servlet  activates generation components , in order to parse, generate code, compile using the compiler , and package the newly regenerated MIDlet. The servlet  then caches the newly regenerated MIDlet, and initiates a download of the JAR and JAD files to the mobile information device . Installation of the MIDlet is initiated.","The servlet  logs relevant statistical data in the statistics log .","In a successful scenario, JAR and JAD files associated with the previously generated or newly regenerated MIDlet are downloaded to the mobile information device . In the event of failure, an error message is returned to the developer . Except as noted below, generally in the failure scenarios the JAR and JAD files are not created. The system is capable of recognizing and reporting the following failure scenarios:","Failure scenario 1: The servlet  cannot find the application starting point. The file or the URL are not accessible. An error message is returned to the developer  in an error log file.","Failure scenario 2: The servlet  found an invalid MIDML file. A XML parser error is returned to the developer  in the error log file.","Failure scenario 3: The servlet  failed to find the application descriptor in the starting point file. An error message is returned to the developer  in an error log file.","Failure scenario 4: The servlet  found a dead link to the another MIDML file. Generation and compilation stop. An error message is returned to the developer  in an error log file describing the file name and line number of the dead link directive.","Failure scenario 5: The servlet  cannot be accessed, for example, due to difficulties with the Web server. An error message is returned to the developer , indicating that the service is unavailable.","Failure scenario 6: The servlet  has detected a parameter error in the HTTP request. The required parameters are either missing, or have inappropriate values. An error message is returned to the developer  in an error log file, indicating an invalid HTTP request.","Failure scenario 7: The Java Application Manager (JAM) of the mobile information device  is not able to install the MIDlet, for example due to size constraints. However, the JAR and JAD files have nevertheless been created and may be found in the cache of the servlet.","Failure scenario 8: The end user  issues a \u201ccancel and deny installation\u201d instruction for the MIDlet. However, the JAR and JAD files have been created.","Use Case 3","Continuing to refer to , in use case 3 it is intended to successfully install the library  (), and either the compiler , the servlet , or both on a development system available to a software developer, thereby deploying the organizational infrastructure . The deployer  initiates the installation according to a predetermined installation procedure, and the above-noted components of the set of software components  () are deployed in the organizational infrastructure . In a success scenario, an installation testing procedure returns a success message to the deployer .","The system is capable of recognizing and reporting the following failure scenarios:","Failure scenario 1: The organizational infrastructure  could not be deployed. An error occurred during performance of the installation procedure. An error message is returned to the deployer .","Failure scenario 2: The organizational infrastructure  was deployed but the installation testing procedure failed. An error message is returned to the deployer .","Use Case 4","Continuing to refer to , in use case 4 it is intended to maintain the servlet  by evaluation of the server logs . Typically, the deployer  consults the server logs , which have been produced by compiler , and other processes of the organizational infrastructure . In a success scenario, the deployer  or webmaster receives requested log files, log messages, statistic data, e.g., number of requests per MIDlet, number of created MIDlets, number of generation failures, and response time.","The system is capable of recognizing and reporting the following failure scenario: the organizational infrastructure  could not produce the requested logs and statistics.","Example","An exemplary MIDML Application Project file for a MIDML MIDlet is presented in Listing 37. This file contains a single element: an application descriptor tag containing MIDML application location-oriented data, i.e., a pointer to the application starting point MIDML source file. The file also contains JAD-oriented data, i.e., the JAR URL, and MIDlet version information.","An exemplary MIDML Application starting point file for the application is shown in Listing 38. This file contains the mandatory tag <midml-app> for a starting point file. The application predefined start event startApp performs the link to the first application screen. An exemplary notification that an application is exiting is presented in Listing 39. A sample form for the application is shown in Listing 40.","It will be appreciated by persons skilled in the art that the present invention is not limited to what has been particularly shown and described hereinabove. Rather, the scope of the present invention includes both combinations and subcombinations of the various features described hereinabove, as well as variations and modifications thereof that are not in the prior art, which would occur to persons skilled in the art upon reading the foregoing description.","This appendix defines functional requirements of the markup language MIDML. It lists the general structure of a MIDML application and the functionality exposed to the MIDML developer. MIDML tag definitions and event-handling mechanisms follow simple HTML-like principles.","General Requirements","Req. 1: A MIDML file is a well formatted XML file using specific MIDML XML schema definitions.","Req. 2: MIDML may include compiler directives in the application descriptor.","Req. 3: MIDML supports generic extending of the language tags via predefined interfaces. Vendor specific tags are enabled.","Req. 4: MIDML allows MIDP 1.0a compliant Java code embedding within MIDML applications.","Req. 5: MIDML renders a user agent sensitive mechanism, exposing the user agent to the MIDML developer.","Req. 6: MIDML may contain user agent specific sections.","Application Structure","Req. 7: A MIDML application has a XML compliant application descriptor tag, containing the following fields: application name; version; vendor. The descriptor tags are JAD data oriented.","Req. 8: A MIDML application has a starting point file containing the application descriptor tag.","Req. 9: MIDML supports the definition of data variables within the scope of the entire application.","Req. 10: MIDML supports the definition of data variables within the scope of a single application Screen.","Req. 11: MIDML supports reading and assignment operation on data variables.","Req. 12: MIDML data variables can be initialized via external parameters that are supplied once the MIDML application has been parsed and compiled. The external parameters may be supplied using a string initialization mechanism.","Req. 13: MIDML uses a document object model for widgets and data variable access.","Req. 14: MIDML uses a document object model for MIDML document properties access.","Req. 15: MIDML has a mechanism to specify variable persistence storage between independent invocations of the generated MIDlet.","Req. 16: MIDML supports variables persistence storage while the MIDlet is running.","Req. 17: MIDML supports null value initialization for data variables.","Req. 18: MIDML defines the following state events and events handlers: ON_START; ON_PAUSE; ON_DESTROY.","Req. 19: MIDML may allow the addition of user-defined events and event handlers via interfaces. This requirement is supported by the extension mechanism disclosed hereinabove.","Req. 20: MIDML defines a method to activate a link to an application page upon a triggered event.","Req. 21: MIDML defines a method to activate an arbitrary event handler upon a triggered event.","Req. 22: MIDML defines a method to invoke Servlet calls upon a triggered event.","Graphics and User Interface","Req. 23: MIDML supports all MIDP 1.0a widgets including the Canvas widget, and their respective events.","Req. 24: MIDML enables the user to add new widgets and device specific widgets.","Req. 25: MIDML defines anchor navigation within a MIDlet page.","Req. 26: MIDML defines a paragraph text formatting tag.","Req. 27: MIDML supports the following font attributes for text: font type; size (small, medium, large); style (bold, underlined, italic); face (proportional, monospace, system).","Req. 28: MIDML supports page heading formats.","Req. 29: MIDML supports line breaks within a MIDlet screen.","Req. 30: MIDML supports a form tag as a collection of user interface widgets.","Req. 31: The MIDML form supports a SUBMIT operation, which sends all the form's widget data to a specified link.","Resources","Req. 32: MIDML allows the user to embed resources within an application screen.","Req. 33: MIDML allows the user to define remote resources, fetched at run time across a network, such as the Web.","Req.: MIDML supports text document resources.","Req. 34: MIDML supports PNG image resources.","Req. 35: MIDML enables the user to specify a resource location using a URL.","Req. 36: MIDML defines a tag for a simple Boolean servlet activation.","Req. 37: MIDML defines a tag for a text servlet activation.","Req. 38: MIDML defines a mechanism to support definitions of protocols and data-message formats for full servlet interoperability.","The functional requirements of the library [LIB] are disclosed in this Appendix. There are three major functions that the library supports: (1) MIDlet code generation; (2) compiling and packing of the generated code; and (3) a MIDP 1.0a abstraction layer containing utilities.","Req. 39: The library generates the MIDlet Java code from a valid MIDML starting point.","Req. 40: The library generates the MIDlet application descriptor file (JAD).","Req. 41: The library supports invocation of the Java compiler (JAVAC) to compile the generated MIDlet Java code.","Req. 42: The library supports invocation of the Java compiler (JAVAC) to compile with licensee open classes (CLASSPATH), including classes physically located on the target MIDP device.","Req. 43: The library supports invocation of the Java compiler (JAVAC) to compile with external classes. Additional classes are packed with the generated MIDlet.jar.","Req. 44: The library code generator component has an option to operate in a verbose mode.","Req. 45: The library code generator component has an option to initialize data variables with parameters.","Req. 46: The library supports invocation of the Java archive utility (JAR) to package the generated MIDlet and the additional files (resources, external classes etc.)","Req. 47: The library returns mal-formatted MIDML syntax errors (including XML parser errors).","Req. 48: The library returns all Java compiler errors with respect to the MIDML source where applicable.","Req. 49: The library returns J2ME platform exceptions with respect to the MIDML source where applicable.","Req. 50: The library code generator component utilizes logical links to create application flow between MIDlet screens.","Req. 51: The library code generator component is able to identify recursive link definitions in the MIDML source in order to enable looping.","Req. 52: The library defines a document object model for the generated MIDlet from the MIDML source.","Req. 53: The MIDML document object mode may be exposed by The library for MIDP 1.0a Java code embedding.","Req. 54: The library supports reading and assignment operations of data variables from the document object model.","Req. 55: The library supports the MIDP 1.0a event model for events defined in the MIDML source.","Req. 56: The library has customization capabilities according to the user agent information.","Req. 57: The library supports parsing and Java code generation from all the MIDML defined tags.","This Appendix describes the functional requirements of the compiler application. It lists the compiler flags and operation modes and defines the user interface.","General Requirements","Req. 58: The compiler is a Java application using the Library (Appendix 2).","Req. 59: The compiler has a command line user interface.","Req. 60: The compiler generates a packaged (JAR) MIDlet application and its respective application descriptor file (JAD) from a valid MIDML starting point file.","Req. 61: The compiler reports all types of errors messages generated by the RTL layer.","Usage Flags.","Req. 62: The compiler input flag is a URL or a file system path, specifying the MIDML application starting point file.","Req. 63: The compiler output flag is a file system path indicating the location of the resulting MIDlet JAD and JAR files.","Req. 64: The compiler has an operation log flag.","Req. 65: The compiler has a verbose flag echoing the operation log to the standard output.,","Req. 66: The compiler has a CLASSPATH directive.","Req. 67: The compiler has a MIDML parameters directive.","Req. 68: The compiler has a directive to indicate packing of external classes within the generated MIDlet package (JAR).","Req. 69: The compiler has a makefile directive.","Req. 70: The compiler has a flag for saving intermediate compilation files.","This Appendix describes the functional requirements of the servlet application, the servlet operation modes, and Web application behavior.","General Requirements","Req. 71: The servlet renders a Web interface for MIDlet creation on demand.","Req. 72: The servlet reports all types of error messages generated from the Library layer (Appendix 2) to the host server log file.","Req. 73: The servlet uses a caching mechanism that identifies changes in the requested MIDlet.","Req. 74: The servlet does not generate a new MIDlet if the MIDlet requested is consistent with the cached MIDlet. MIDlet consistency is defined in terms of: file timestamp; application descriptor information; MIDML parameters; and user agent information.","Req. 75: The servlet logs the following data: number of requests per MIDlet; number of created MIDlets; and number of MIDlet generation failures; and response time.","Usage Flags","Servlet usage flags have the following type properties:\n\n","Req. 76: [Dynamic] The servlet input flag is a URL or a file system path, specifying the MIDML application starting point file.","Req. 77: [Application] The servlet output flag is a file system path indicating the location of the resulting MIDlet JAD and JAR files.","Req. 78: [Deployment] The servlet has an operation log flag.","Req. 79: [Deployment] The servlet has a verbose flag, and logs its operation to a server log file.","Req. 80: [Application] The servlet has a CLASSPATH directive.","Req. 81: [Dynamic] The servlet has a MIDML parameters directive.","Req. 82: [Application] The servlet has a directive to indicate packing of external classes within the generated MIDlet package (JAR).","Req. 83: [Application] The servlet has a makefile directive.","Req. 84: [Deployment] The servlet has a flag to enable saving of compilation intermediate files."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a better understanding of the present invention, reference is made to the detailed description of the invention, by way of example, which is to be read in conjunction with the following drawings, wherein like elements are given like reference numerals, and wherein:",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIGS. 4A-4D","FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0072","num":"0071"},"figref":["FIGS. 5A and 5B","FIG. 5","FIG. 1"]},{"@attributes":{"id":"p-0073","num":"0072"},"figref":["FIG. 6","FIG. 1"]},{"@attributes":{"id":"p-0074","num":"0073"},"figref":["FIG. 7","FIG. 1","FIG. 2"]},{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIG. 8","FIG. 3"]},{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 9","FIG. 8"]},{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 10","FIG. 3"]},{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 11","FIG. 3"]},{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 12","FIG. 12","FIG. 11"],"b":["12","12"]},{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIG. 13","FIG. 3"]},{"@attributes":{"id":"p-0081","num":"0080"},"figref":["FIG. 14","FIG. 3"]},{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
