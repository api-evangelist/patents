---
title: Method and apparatus for controlling execution of a child process generated by a modified parent process
abstract: A monitoring interface, includes logic responsive to a pre-fork event, the pre-fork event responsive to a vfork system call. The pre-fork event includes indicia that identifies a child process to be created in accordance with the vfork system call. A method for controlling the execution of a child process created from a parent process, where the parent process is monitored by a software tool includes, receiving indicia that a vfork system call will be executed by the parent process, suspending execution of the parent process, extracting a process identifier from the indicia of the vfork system call, the process identifier corresponding to a child process to be generated by the parent process when the parent process executes the vfork system call, setting a process monitor thread to observe the child process, and resuming execution of the parent process to enable the parent process to execute past the vfork system call.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07415699&OS=07415699&RS=07415699
owner: Hewlett-Packard Development Company, L.P.
number: 07415699
owner_city: Houston
owner_country: US
publication_date: 20030627
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The computing community has developed tools and methods to analyze the run-time behavior of a computer program. Many of the tools and methods use statistical sampling and binary instrumentation techniques. Statistical sampling is performed by recording periodic snapshots of the program's state, e.g., the program's instruction pointer. Sampling imposes a low overhead on a program's run time performance, is relatively non-intrusive, and imprecise. For example, it may be difficult to associate a sampled instruction pointer with the particular instruction that caused the latest sampling event.","While binary instrumentation leads to more precise results, the accuracy comes at some cost to the run-time performance of the instrumented program. Traditional binary instrumentation is static. It involves rewriting the whole program before any run to insert data-gathering code. Because the binary code of a program is modified, all interactions with the processor and the operating system can change significantly. Consequently, binary instrumentation is considered intrusive.","Dynamic binary instrumentation allows program instructions to be changed on-the-fly and leads to a whole class of more precise run-time monitoring results. Unlike static binary instrumentation techniques that are applied over an entire program prior to execution of the program, dynamic binary instrumentation is performed at run-time of a program and only instruments those portions of an executable that are executed. Consequently, dynamic binary instrumentation techniques can significantly reduce the overhead imposed by the instrumentation process.","Software development tools can combine statistical sampling and dynamic binary instrumentation methods into a framework that enables performance analysis, profiling, coverage analysis, correctness checking, and testing of a program.","A basic reason for the difficulty in testing the correctness and performance of a program is that program behavior largely depends on the data on which the program operates and, in the case of interactive programs, on the information (data and commands) received from a user. Therefore, even if exhaustive testing is impossible, as is often the case, program testing and performance analysis is preferably conducted by causing the program to operate with some data. The act of executing a program entails the creation of one or multiple \u201cprocesses.\u201d","A \u201cprocess\u201d is commonly defined as an address space, one or multiple control threads operating within the address space, and the set of system resources needed for operating with the threads. Therefore, a \u201cprocess\u201d is a logic entity consisting of the program itself, the data on which it must operate, the memory resources, and input\/output resources. Executing a given program may lead to multiple processes being created. Program verification and performance testing encompasses execution of the program to test if the process or processes develop in the correct way or if undesired or unexpected events occur.","Generally, software development tools use two basic techniques to monitor the execution of a given process, in-process monitoring and out-of-process monitoring. In-process monitoring involves modifying a program to be tested so that select program instructions are preceded and followed by overhead instructions that extract variable information, control execution of the instruction, and monitor program execution. With out-of-process monitoring, a monitoring program executes in a different process and interacts with the monitored processes.","Symbolic debuggers constitute an example of out-of-process monitoring. Symbolic debuggers are interactive programs which allow a software engineer to monitor the execution of a compiled program. The user can follow the execution of a compiled program in a familiar high-level programming language while the program to be tested executes. Symbolic debuggers modify an executable copy of the source by selectively inserting conditional branches to other routines, instruction sequences, and break points. The compiled and instrumented program can then be run under the control of a managing program or a software engineer via a human-machine interface.","Symbolic debuggers also enable the insertion of instruction sequences for recording variables used in execution of the instruction and, on user request, can add and remove break points, modify variables, and permit modification of the hardware environment. These techniques are particularly effective in that they permit step-by-step control of the execution of a program, that is, they allow the evolution of the related process to be controlled by halting and restarting the process at will and by changing parameters during the course of execution of the process. The tools also can display the execution status of the process to the software engineer in detail by means of display windows or other output devices that enable the user to continuously monitor the program. Some tools automate the process of setting break points in the executable version of the source code.","Symbolic debuggers have several limitations. First, they operate on only a single process at a time. Second, the process to be tested must be activated by the parent process (the symbolic analysis process) and cannot be activated earlier. Consequently, the debugging of programs, which are activated at system start up, such as monitors, daemons, etc., is problematic.","Furthermore, because the process to be tested is generated as a child of the symbolic analysis parent, and in a certain sense is the result of a combination of the symbolic analysis function\/program with the program to be tested, the two processes must share or utilize the same resources. As a consequence, interactive programs that use masks and windows on a display device cannot be tested because they compete or interfere with the symbolic debugger in requiring access to the display device.","Moreover, software development tools that use symbolic debuggers can encounter deadlock conditions that result from the standard execution of operating system level instructions.","One operating system that has gained widespread acceptance is the UNIX\u00ae operating system. UNIX\u00ae is a trademark of the American Telephone and Telegraph Company of New York, N.Y., U.S.A. The UNIX\u00ae operating system is a multi-user, time-sharing operating system with a tree-structured file system. Other noteworthy functional features are its logical I\/O capabilities, pipes, and forks. The logical I\/O capabilities allow a user to specify the input and output files of a program at runtime rather than at compile time, thus providing greater flexibility. Piping is a feature that enables buffering of input and output data to and from other processes. Forking is a feature that enables the creation of a new process.","By themselves, these features offer no inherent benefits. However, the UNIX\u00ae operating system command environment (called the SHELL) provides easy access to these operating system capabilities and also allows them to be used in different combinations. With the proper selection and ordering of system commands, logical I\/O, pipes, and forks, a user at the command level can accomplish tasks that on other operating systems would require writing and generating an entirely new program. This ability to easily create application program equivalents from command level is one of the unique and primary benefits of the UNIX\u00ae operating system.","The popularity of the UNIX\u00ae operating system has led to the creation of numerous open source and proprietary variations such as LINUX\u00ae, HP-UX\u00ae, etc. LINUX\u00ae is a trademark of William R. Della-Croce, Jr. (individual) of Boston, Mass., U.S.A. HP-UX\u00ae, is a trademark of the Hewlett-Packard Company, of Palo Alto, Calif., U.S.A. Variants of the UNIX\u00ae operating system inherently use the UNIX\u00ae operating system's logical I\/O capabilities, pipes, and forks.","Software development tools can encounter a deadlock condition when a process under test includes a \u201cvfork\u201d system call. The operation of a \u201cvfork\u201d system call in the UNIX\u00ae operating system involves spawning a new process and copying the process image of the parent (the process making the vfork call) to the child process (the newly spawned process).","Monitoring facilities enable a process or thread to control the execution of threads running in another process. Generally, monitoring facilities control other threads by reading and modifying the state of the process. \u201cThread trace,\u201d also known as \u201cttrace\u201d is a tracing facility for single and multithreaded processes. Ttrace is an evolution of \u201cprocess trace,\u201d also known as \u201cptrace.\u201d A monitoring facility typically allows the monitoring program to declare an interest in the occurrence of particular events associated with any thread or for a specific subset of threads. For example, the monitoring process may want to be informed when a thread receives a signal, invokes a system call, or executes a breakpoint. While under the control of a monitoring facility, the monitored code behaves normally until one of those events occur. At this point, the thread or process enters a stopped or suspended state and the tracing process is notified of the event. In the ttrace facility, the monitoring process receives such notifications by invoking the system call ttrace_wait.","Ttrace_wait can be called in blocking or non-blocking modes. When called in blocking mode, the system call will not return until an event is available. In non-blocking mode the system call will return promptly but may indicate that no event notification is available. When event notification is available, ttrace_wait will provide an indication of the event type encountered.","At a given point in time, a monitoring program may monitor multiple processes, each process including one or multiple threads. Monitoring facilities such as ttrace typically provide a way to separate event notifications from the various processes, or even from the various threads in a given process. In the case of ttrace_wait, the monitoring process will either return events from any process monitored, from any thread in a specified process, or from a specified thread in a specified process. Using the mode where a single ttrace_wait call will provide information about any process monitored can introduce a bottleneck or make run-time analysis too complex.","A vfork system call differs from a fork system call in that the child process created via the vfork system call shares the same address space as the parent until exec or _exit is called, while a child process created via the fork system call gets a copy of the parent address space. In some operating systems, the vfork system call is implemented by having the parent process blocked until the child process calls exec or _exit. This allows for a simple implementation of vfork, as the child process can be created cheaply as it directly uses most of the structures associated with the parent process.","As mentioned above, such an implementation of the vfork system call can present a deadlock condition for debuggers that use known tracing facilities. If the monitoring process is using monitoring facilities that in turn are using per-process notifications, the monitoring process will not be aware of the newly created child process, until the monitoring process is notified that the child process exists. In some existing designs, however, notification is not delivered until the parent process is unblocked. That is, when the child process calls exec or _exit. Furthermore, the child process itself can be blocked as it generates monitoring events. This results in a deadlock, as both the traced parent and child process are blocked while the tracing process waits for an indication of an event that cannot be delivered until the child process is unblocked.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 1","FIG. 1"]},"Deadlock condition  occurs between development tool , parent process , and child process  as described below. Development tool  identifies a process (e.g., parent process ) that the development tool  would like to monitor as indicated in block . Next, development tool  spawns parent process  under trace control as shown in block . A process identifier (PID) is assigned to the parent process  by the operating system when the parent process is created.","Thereafter, in block , development tool  monitors execution of the parent process by monitoring trace events from parent process . Under the UNIX\u00ae operating system and its open source and proprietary variants, development tool  waits for trace events that include the PID of the parent process. Development tool  cannot monitor child process , since child process  has not been created.","Once parent process  is created and started, parent process  is instrumented and runs nominally in accordance with its instructions as shown in block . The parent process  runs until it encounters a vfork system call as shown in block . Next, parent process  spawns child \u201cA\u201d under trace control as shown in block . In accordance with the vfork system call, the operating system copies the current state of the parent process  to spawn child process  and generates a trace event which is received by development tool . Thereafter, as shown in block , parent process  is essentially suspended waiting for an indication that child process  has completed (e.g., indicia of an exec or exit).","Once child process  is created by the vfork system call in parent process , and started, child process  is instrumented and runs nominally in accordance with its instructions as shown in block . The child process  runs nominally in accordance with its instructions until it encounters the vfork system call shown in block . Thereafter, as shown in block , child process  spawns a child \u201cB\u201d process. At this time, the operating system assigns a PID, different from the parent PID and child \u201cA\u201d PID, to identify the subsequent child process. In accordance with the vfork system call, child process  copies itself in its instrumented state to spawn the subsequent child process (not shown) and generates a trace event which is ignored by development tool  because development tool  is only looking for trace events from parent process .","Once the vfork system call is encountered and processed in child process , the deadlock condition has occurred. Parent process  is suspended waiting for an indication that child process  has completed. Child process , which inherited trace control from parent process , waits for a process to handle the trace event generated at the time it executed the vfork system call. Concurrently, development tool  waits for a trace event from parent process .","Consequently, it is desirable to have an improved apparatus, program, and method to avoid deadlock induced by a vfork system call when monitoring application programming interfaces (APIs) to track the execution of computer programs.","An embodiment of a monitoring interface, includes a pre-fork event responsive to a vfork system call wherein the pre-fork event includes indicia that identifies a child process to be created in accordance with the vfork system call.","An embodiment of a method for controlling the execution of a child process created from a parent process, where the parent process is monitored by a software tool includes, receiving indicia that a vfork system call will be executed by the parent process, suspending execution of the parent process, extracting a process identifier from the indicia of the vfork system call, the process identifier corresponding to a child process to be generated by the parent process when the parent process executes the vfork system call, setting a monitoring thread to observe the child process, and resuming execution of the parent process to enable the parent process to execute past the vfork system call.","The improved interface provides system calls to monitor or otherwise control the execution of threads in monitored processes. A thread is that part of a program that can execute independently of other parts of the program. Operating systems such as UNIX\u00ae that support multithreading, enable programmers to design programs whose threaded parts can execute concurrently.","The improved monitoring interface includes a pre-fork event and associated processing that can be adapted to multiple tracing facilities such as ttrace and\/or ptrace. The improved interface and the associated methods described below enable a software tool to control the execution of a child process initiated by an instrumented parent process, where the parent process includes one or more calls to vfork. While the example embodiments described below are directed to examples where a parent process is instrumented, the present apparatus and methods are applicable to any modified parent process that includes a vfork system call.","Turning now to the drawings, wherein like-reference numerals designate corresponding parts throughout the drawings; reference is made to , which illustrates a functional block diagram of a computing device. Generally, in terms of hardware architecture, as shown in , computing device  may include a processor , memory , input\/output device interface(s) , and LAN\/WAN interface(s)  that are communicatively coupled via local interface . The local interface  can be, for example but not limited to, one or more-buses or other wired or wireless connections, as known in the art or that may be later developed. Local interface  may have additional elements, which are omitted for simplicity, such as controllers, buffers (caches), drivers, repeaters, and receivers, to enable communications. Further, local interface  may include address, control, and\/or data connections to enable appropriate communications among the aforementioned components.","In the embodiment of , the processor  is a hardware device for executing software that can be stored in memory . The processor  can be any custom-made or commercially available processor, a central processing unit (CPU) or an auxiliary processor among several processors associated with the computing device , a semiconductor-based microprocessor (in the form of a microchip) or a macroprocessor.","Memory  can include any one or combination of volatile memory elements (e.g., random access memory (RAM, such as dynamic RAM or DRAM, static RAM or SRAM, etc.)) and nonvolatile-memory elements (e.g., read-only memory (ROM), hard drives, tape drives, compact discs (CD-ROM.). Moreover, the memory  may incorporate electronic, magnetic, optical, and\/or other types of storage media now known or later developed. Note that memory  can have a distributed architecture, where various components are situated remote from one another, but accessible by processor .","The software in memory  may include one or more separate programs, each of which comprises an ordered listing of executable instructions for implementing logical functions. In the example of , the software in the memory  includes operating system , one or more application(s) , and a software monitor . Application(s)  and software monitor  function as a result of and in accordance with operating system . Operating system  controls the execution of the other application(s)  and computer programs, such as software monitor , and provides scheduling, input-output control, file and data management, memory management, and communication control and related services.","Software monitor  and application(s)  include one or more source programs, executable programs (object code), scripts, or other collections each comprising a set of instructions to be performed. As will be explained in detail below, software monitor  includes logic that controls the execution of application(s) . More specifically, software monitor  includes logic that controls the execution of a child process or thread generated by a modified parent process found within application(s)  where the parent process or thread includes a vfork system call. As illustrated in , software monitor  includes an instrumentation engine , a process monitor , and a monitoring interface . It should be well-understood by one skilled in the art, after having become familiar with the teachings of the improved interface, that software monitor  and application(s)  may be written in a number of programming languages now known or later developed. Moreover, software monitor  and application(s)  may be stored across distributed memory elements in contrast with the memory  shown in .","The input\/output device(s)  may take the form of human\/machine devices, such as but not limited to, a keyboard, a mouse or other suitable pointing device, a microphone, etc. Furthermore, the input\/output device(s)  may also include known or later developed input\/output devices, for example but not limited to, a printer, a display device, an external speaker, etc.","Network-interface device(s)  may include a host of devices that may establish one or more communication sessions between computing device  and one or more local and\/or wide area networks. Network-interface device(s)  may include but are not limited to, a modulator\/demodulator or modem (for accessing another device, system, or network); a radio frequency (RF) or other transceiver; a telephonic interface; a bridge; an optical interface; a router; etc. For simplicity of illustration and explanation, these aforementioned two-way communication devices are not shown.","When the computing device  is in operation, the processor  is configured to execute software stored within the memory , to communicate data to and from the memory , and to generally control operations of the computing device  pursuant to the software. Operating system , one or more application(s) , and the software monitor , in whole or in part, but typically the latter, are read by the processor , perhaps buffered within the processor , and then executed in accordance with the respective instructions.","It should be understood that software monitor  can be embodied in any computer-readable medium for use by or in connection with an instruction execution system, apparatus, or device, such as a computer-based system, processor-containing system, or other system that can fetch the instructions from the instruction execution system, apparatus, or device, and execute the instructions. A \u201ccomputer-readable medium\u201d can be any methods and resources for storing, communicating, propagating, or transporting a program for use by or in connection with the instruction execution system, apparatus, or device. The computer-readable medium can be, for example but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, device, or propagation medium now known or later developed. Note that the computer-readable medium could even be paper or another suitable medium upon which the program is printed, as the program can be electronically captured, via for instance optical scanning of the paper or other medium, then compiled, interpreted or otherwise processed in a suitable manner if necessary, and then stored in a computer memory.","Those skilled in the art will understand that various portions of software monitor  can be implemented in hardware, software, firmware, or combinations thereof. In a preferred embodiment, software monitor  is implemented using software that is stored in memory  and executed by a suitable instruction execution system. If implemented solely in hardware, as in an alternative embodiment, software monitor  can be implemented with any or a combination of technologies well-known in the art (e.g., discrete logic circuits, application-specific integrated circuits (ASICs), programmable-gate arrays (PGAs), field-programmable gate arrays (FPGAs), etc.), or technologies later developed.","In one embodiment, the software monitor  is implemented via a combination of software and data stored in memory  and executed and stored or otherwise processed under the control of processor . It should be noted, however, that software monitor  is not dependent upon the nature of the underlying processor  or memory  in order to accomplish designated functions.","Reference is now directed to , which presents a functional block diagram of an embodiment of software monitor . In the present embodiment, software monitor  instruments or otherwise modifies code. In other embodiments, software monitor  may employ sampling techniques that do not necessitate modification of a parent process. As illustrated in , software monitor  comprises the instrumentation engine , process monitor , and a monitoring interface . Before software monitor  can collect and analyze performance information regarding a specific thread or process, instrumentation engine  inserts or otherwise modifies code in the target process or thread. Preferably, software monitor  contains logic that in accordance with dynamic binary-instrumentation techniques, instruments or modifies only those portions of parent process  that will be executed by processor .","Instrumentation engine  may receive data via various input\/output devices , data stored in memory  (), as well as various application(s). The data will identify one or more target processes or threads to instrument. In addition, the data may include various parameters and flags that instrumentation engine  uses in generating parent process . Alternatively,instrumentation engine  can be programmed with one or more default parameters to apply when modifying the target process. Instrumentation engine , having received data identifying the target process or thread applies the various parameters and flags and generates parent process . Parent process  is an instrumented or modified version of the identified target process or thread.","As further illustrated in the functional block diagram of , software monitor  includes process monitor . Process monitor  includes logic for coordinating the collection of data during execution of parent process . When parent process  includes one or more vfork system calls, process monitor  ensures that data collected during execution of both the parent process  and its child process  are associated with the process responsible for generating the data. As shown in , process monitor  functions through monitoring interface  and the underlying operating system . Information flows between process monitor  and monitoring interface  can include monitored system calls, events, and signals .","Monitoring interface  includes logic for receiving and responding to the various trace system calls, events, and signals . In addition, monitoring interface  includes instruction generator . Instructions  are in accordance with the underlying operating system . As illustrated in , monitoring interface  receives and responds to trace system calls, events, and signals  generated and sent by parent process , child process , and process monitor .","Operating system  as illustrated in , sends and receives instructions  both to and from monitoring interface  via instruction interface . In addition, operating system  receives a vfork system call via connection  from parent process . As provided in the UNIX\u00ae operating system and many of its proprietary and open source derivatives, a vfork system call suspends execution of parent process  and generates child process  which contains a copy of the instrumented code and trace calls, events, and signals contained within parent process .","However, in addition to the other trace system calls, events, and signals , parent process  communicates a pre-fork event  to monitoring interface . Pre-fork event  includes indicia identifying child process  before it is created by a subsequently executed vfork system call within parent process . The indicia includes at least a process identifier of the child process . Monitoring interface  further includes logic configured to recognize and respond to the pre-fork event .","While the functional block diagram presented in  illustrates software monitor  as having a single centrally-located instrumentation engine  with co-located process monitor  and monitoring interface , it should be understood that the various functional elements of software monitor  may be distributed across multiple locations in memory  and\/or across multiple memory devices (not shown). It should be further understood that instrumentation engine  is not limited to dynamic binary instrumentation techniques and may include logic in accordance with binary instrumentation techniques (i.e., logic that instruments all portions of the identified parent process ) and statistical sampling and other applications that can exploit the pre-fork event .","Reference is now directed to the flow chart illustrated in . In this regard, the various functions shown in the flow chart present a method for controlling the execution of a child process created from a parent process, where the parent process is instrumented by a software toot that may be realized by software monitor . As illustrated in , the method may begin by determining whether it is desired to instrument a parent process as shown in query . When it is determined that it is desirable to instrument the parent process as indicated by the flow control arrow labeled \u201cYES\u201d that exits query , the method responds by acquiring desired monitoring parameters, as indicated in block . Otherwise, as indicated by the flow control arrow labeled \u201cNO,\u201d the method bypasses blocks  through  and waits for an indication of a pre-fork event.","Returning to the condition where it is desired to instrument the parent process, as illustrated in block , a process monitor thread is set to communicate with the parent process. As shown in block , the parent process is executed and instrumented to extract or otherwise record desired parameters.","Thereafter, as indicated in the wait loop formed by query  and wait block , execution of the parent process continues until a pre-fork event is detected. When a pre-fork event is detected, as indicated by the flow control arrow labeled \u201cYES\u201d exiting query , the function indicated in block  is performed. More specifically, the process identifier of the child process that will be created by the subsequent vfork system call is extracted from the pre-fork event. Thereafter, as indicated in block , a process monitor thread is configured to respond to trace events generated by the future child process. Next, as shown in block , execution of the child process resumes.","As described above, a child process that contains a copy of the parent process (including code inserted by an instrumentation process) is generated and executed in accordance with the vfork system call. In addition, the parent process is suspended until the child process calls an exec or an _exit system call. When it is determined that the child process has invoked one of those calls or has been terminated by the operating system, as indicated by the flow control arrow labeled \u201cYES\u201d exiting query , the process monitor is configured to monitor trace events generated by the parent process, as indicated in block , before resuming execution of the parent process.","Execution of the parent process continues, as indicated in the wait loop formed by query  and wait block , until the parent process generates an exec or _exit call or is terminated by the operating system. When it is determined that the parent process has generated one of the exec or _exit calls or has been terminated, as indicated by the flow control arrow labeled \u201cYES\u201d exiting query , the process monitor is suspended as indicated in block  and run-time data observed during execution of the parent process is collected, analyzed, and presented as shown in block .","Those skilled in the art will understand that the method for controlling the execution of a child process created from a parent process illustrated in  can be extended to control any number of processes, for example by using separate threads to monitor each process of interest. Since a given process can only execute a single vfork system call at a time (since it becomes blocked while executing the system call), the design therefore addresses the general case of multiple monitored processes that may call vfork.",{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 5","b":["502","350","502","504","506"]},"Thereafter, as indicated in the wait loop formed by query  and wait block , execution of the parent process is suspended until after the parent receives an indication from the software tool that the pre-fork event has been successfully processed. When the pre-fork event has been processed, as indicated by the flow control arrow labeled \u201cYES\u201d exiting query , the parent is activated and executes the vfork system call as shown in block . Once the vfork system call has been executed, the parent is suspended as indicated in block .","As indicated in the wait loop formed by query  and wait block , the parent process remains suspended until the parent receives an indication that the child process has invoked an exec or an _exit system call, thus generating corresponding events. When the child process has invoked the exec or _exit system call, as indicated by the flow control arrow labeled \u201cYES\u201d exiting query , the parent process resumes as shown in block . As indicated in query , the parent process continues until the process generates an exit event. As shown by the flow control arrow labeled \u201cNO\u201d exiting query , the parent is configured to report any future vfork system call by repeating the functions and queries described above.","Those skilled in the art will understand that the method for executing a parent process monitored by a software tool to ensure execution of a child process when the parent process contains a vfork system call illustrated in  is configured to generate and send a pre-fork event before executing a vfork system call. The parent process or thread may be implemented via multiple threads for controlling the performance of the desired functions. A given thread may be responsible for handling monitoring events generated by a single process or from multiple processes. Multiple such threads may be executed as may be desired by a parent process or thread to implement the various functions illustrated in .","Reference is now directed to the flow chart illustrated in , which illustrates an embodiment of a method for controllably switching a target process of a process monitor thread between an instrumented parent process and a child process generated by the parent process. In this regard, process monitor  begins with query  where it is determined if a target PID has been received. If the result of query  indicates that the PID has not been received, as indicated by the flow control arrow labeled \u201cNO\u201d exiting query , processing continues after wait block . Once query  indicated that a target PID has been received, query  is performed to determine if the child process has started. If the result of query  indicates that the child process has not started successfully, process monitor  is configured to determine if the vfork system call issued by the parent process has failed as indicated in query . When the parent process vfork system call has not failed, query  is repeated after wait block . When the result of query  indicates that the parent vfork system call has failed, as indicated by the flow control arrow labeled \u201cYES\u201d exiting query , the process monitor  is configured to notify the software monitor that the vfork system call failed as indicated in block .","Otherwise, when query  indicates that the child process has successfully started as indicated by the flow control arrow labeled \u201cYES\u201d exiting query , query  is performed to determine if the parent vfork system call failed. When query  indicates that the parent vfork system call has not failed, block  is bypassed. Otherwise, when query  indicates that the parent vfork system call has failed, process monitor  sets a target PID to the child process PID as indicated in block . Thereafter, process monitor  monitors trace events from the target PID as indicated in block . Process monitor  continues to monitor trace events from the child process associated with target PID until the process executes an exec or _exit system call or is otherwise terminated by the operating system.",{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 7","b":["700","702","704","706","708","710","712"]},{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 8","b":["802","806","802","804","802"]},"Once the pre-fork event has been generated, the software tool receives the pre-fork event as shown in block . Thereafter, as indicated in decision block , the software tool determines if the pre-fork event has processed successfully. When it is determined that the pre-fork event has not completed successfully, as indicated by the flow control arrow labeled \u201cNO\u201d exiting block  and wait block , the software tool repeats the query of decision block . It should be understood that this portion of the flow chart assumes that the pre-fork event will eventually terminate successfully. Those skilled in the art may insert additional failure handling mechanisms to recover from a pre-fork instruction execution failure.","Otherwise, when it is determined that the pre-fork event has successfully terminated, as indicated by the flow control arrow labeled \u201cYES\u201d exiting decision block , the software tool suspends execution of the parent process as shown in block . Thereafter, the software tool directs the creation of execution of the child process as shown in block  to enable the software tool to monitor execution of the child process.","Any process descriptions or blocks in the flow charts presented in  should be understood to represent modules, segments, or portions of code or logic, which include one or more executable instructions for implementing specific logical functions in the associated process. Alternate implementations are included within the scope of the disclosed methods in which functions may be executed out-of-order from that shown or discussed, including substantially concurrently or in reverse order, depending on the functionality involved, as would be understood by those reasonably skilled in the art after having become familiar with the improved monitoring interface and the associated methods for controlling the execution of a child process generated by an instrumented parent process."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Systems and methods for controlling execution of a child process generated by a monitored parent process are illustrated by way of example and not limited by the implementations in the following drawings. The components in the drawings are not necessarily to scale, emphasis instead is placed upon clearly illustrating the principles used in controlling the execution of such a child process. Moreover, in the drawings, like reference numerals designate corresponding parts throughout the several views.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 5","FIG. 3"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 6","FIG. 3"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
