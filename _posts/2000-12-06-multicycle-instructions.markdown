---
title: Multi-cycle instructions
abstract: In one embodiment, a pipelined processor is described that includes an execution pipeline having a plurality of stages and a multi-cycle instruction (MCI) controller adapted to assert a stall signal to stall the multi-cycle instruction within one of the stages of the execution pipeline. The MCI controller is adapted to issue a plurality of instructions to subsequent stages in the pipeline while the multi-cycle instruction is stalled.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07472259&OS=07472259&RS=07472259
owner: Analog Devices, Inc.
number: 07472259
owner_city: Norwood
owner_country: US
publication_date: 20001206
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DESCRIPTION"],"p":["This invention relates to executing multi-cycle instructions in a programmable processor.","A programmable processor, such as a microprocessor for a computer or a digital signal processing system, may support one or more \u201cmulti-cycle\u201d machine instructions in which a single machine instructions directs the processor to perform multiple operations. For example, a typical multi-cycle machine instruction is a Load Multiple in which the processors performs a series of load operations in response to a single machine instruction. Another example is a \u201cPush-Pop Multiple\u201d instruction that directs the processor to push or pop multiple registers to or from a stack. Because multi-cycle instructions pack multiple operations into a single machine instruction, they typically reduce code size and improve operational efficiency of the programmable processor.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1","b":["2","2","4","6","6","4","6"]},"Instructions may be loaded into a first stage of pipeline  and processed through the subsequent stages. Each stage typically processes concurrently with the other stages. Data passes between the stages in pipeline  in accordance with the system clock signal. The results of the instructions emerge at the end of the pipeline  in rapid succession.","As described in detail below, processor  supports a number of multi-cycle instructions. In response to a multi-cycle instruction, stall controller  may stall one or more stages of pipeline  by asserting stall signals  in order to prevent pipeline  from fetching and decoding additional instructions. After stalling a portion of pipeline , multi-cycle instruction (MCI) controller  may assert MCI signals  and direct pipeline  to perform additional operations defined by the current multi-cycle instruction.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2","b":["4","4","11","12","13"]},"During the execution stage (EX), execution unit , performs a specified operation, such as adding or multiplying two numbers. Execution unit  may contain specialized hardware for performing the operations including, for example, one or more arithmetic logic units (ALU's), floating-point units (FPU) and barrel shifters. A variety of data may be applied to execution unit  such as the addresses generated by data address generators , data retrieved from memory or data retrieved from data registers . During the final stage (WB), the results pass through a unit  and are written back to data memory or to data registers .","A multi-cycle instruction behaves as multiple instructions being issued from the decode stage of pipeline  over several clock cycles. When an MCI is executing, it remains stalled in the decode stage of pipeline  while multiple \u201csub instructions\u201d are sent down pipeline  under control of MCI controller . MCI controller  operates according to a number of internal state machines in order to direct instruction decode unit  to dispatch a number of operations over a number of clock cycles during the execution of the MCI.","Stall controller  may stall one or more stages of pipeline  by asserting stall signals  in order to prevent pipeline  from fetching and decoding additional instructions. More specifically, the stages of pipeline  include storage circuits, such as stage registers , for storing the results of the current stage. Stage registers  typically latch the results according to the system clock. Stage registers  receive the stall signals , which control whether or not stage registers  latch the results from the previous stage. In this manner, stall controller  may stall one or more stages of pipeline  in a response to a multi-cycle instruction.","Examples of multi-cycle instructions supported by processor  include a PushPopMultiple machine instruction, a Link instruction and an Unlink instruction. The PushPopMultiple instruction directs processor  to push or pop from 1 to N data registers and\/or pointer registers. The PushPopMultiple remains stalled in the decode stage for a number of clock cycles equal to the number of registers being accessed. The following illustrates an example push multiple machine instruction:\n\n[\u2212\u2212(7\u221245\u22120)\n","In this example, a single machine instruction directs processor  to push four data registers (r through r) and six pointer registers (p through p). Generally, a single machine instruction may specify zero or more data registers and zero or more pointer registers, as long as at least one register is specified.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3","b":["30","5","5","30","30","5","7","12","12","5","5","17","8","4"]},"The following table summarizes the conditions that cause the Push Multiple state machine in MCI controller  to transition from one state to another and the corresponding output signals that are asserted, where D is an instruction bit that indicates a data register is to be pushed, P is an instruction bit that indicates a pointer register is to be pushed, DR is an instruction field that indicates a starting data register to push, PR is an instruction field that indicates a starting pointer register to push, D_TAG represents the current data register being pushed, P_TAG represents the current pointer register being pushed, DMAX represents the maximum data register in the range of available data registers, PMAX represents the maximum pointer register in the range of available pointer registers:",{"@attributes":{"id":"p-0025","num":"0024"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["PATH","CONDITIONS","OUTPUT"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["34A","Not a push multiple","None"]},{"entry":[{},"instruction"]},{"entry":["34B","D & !P & DR = DMAX","assert PUSH_DREG"]},{"entry":["34C","!D & P & PR = PMAX","assert PUSH_PREG"]},{"entry":["34D","D & !P & DR = DMAX \u2212 1","assert PUSH_DREG"]},{"entry":[{},{},"assert D_REG_PRESELECT"]},{"entry":["34E","none","assert PUSH_DREG"]},{"entry":["34F","!D & P & PR = PMAX \u2212 1","assert PUSH_PREG"]},{"entry":[{},{},"assert P_REG_PRESELECT"]},{"entry":["34F\u2032","D & P & DR = DMAX &","assert PUSH_DREG"]},{"entry":[{},"PR = PMAX"]},{"entry":["34G","none","assert PUSH_PREG"]},{"entry":["34H","D & !P & DR < DMAX \u2212 1","assert PUSH_DREG"]},{"entry":[{},{},"assert D_REG_PRESELECT"]},{"entry":[{},{},"assert MCI_PRESTALL"]},{"entry":["34H\u2032","D & P & DR < DMAX","assert PUSH_DREG"]},{"entry":[{},{},"assert D_REG_PRESELECT"]},{"entry":[{},{},"assert MCI_PRESTALL"]},{"entry":["34I","((!P & D_TAG < DMAX \u2212 1) |","assert PUSH_DREG"]},{"entry":[{},"(P & D_TAG < DMAX))","assert D_REG_PRESELECT"]},{"entry":[{},{},"assert MCI_PRESTALL"]},{"entry":["34J","!D & P & PR < PMAX \u2212 1","assert PUSH_PREG"]},{"entry":[{},{},"assert P_REG_PRESELECT"]},{"entry":[{},{},"assert MCI_PRESTALL"]},{"entry":["34J\u2032","D & P & DR = DMAX &","assert PUSH_DREG"]},{"entry":[{},"PR < PMAX","assert D_REG_PRESELECT"]},{"entry":[{},{},"assert MCI_PRESTALL"]},{"entry":["34K","PR = PMAX \u2212 1","assert PUSH_PREG"]},{"entry":[{},{},"assert P_REG_PRESELECT"]},{"entry":["34L","P & D_TAG = DMAX &","assert PUSH_DREG"]},{"entry":[{},"P_TAG < PMAX","assert D_REG_PRESELECT"]},{"entry":[{},{},"assert MCI_PRESTALL"]},{"entry":["34M","P & D_TAG = DMAX &","assert PUSH_DREG"]},{"entry":[{},"P_TAG = PMAX","assert D_REG_PRESELECT"]},{"entry":["34N","P_TAG < PMAX \u2212 1","assert PUSH_PREG"]},{"entry":[{},{},"assert P_REG_PRESELECT"]},{"entry":[{},{},"assert MCI_PRESTALL"]},{"entry":["34O","D_TAG = DMAX \u2212 1 & !P","assert PUSH_DREG"]},{"entry":[{},{},"assert D_REG_PRESELECT"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Initially, MCI controller  starts in the WAIT state until an instruction is fetched by fetch unit  and decoded by decode unit . If the instruction is not a PushPopMultiple instruction, the MCI controller  returns to the WAIT state as indicated by path A.","If the instruction is a PushPopMultiple instruction, but only instructs processor  to push a single data register, the state machine asserts a PUSH_DREG signal and returns to the WAIT state via path B. If the instruction is a PushPopMultiple instruction that instructs processor  to push a single pointer register, the state machine asserts the PUSH_PREG signal and returns to the WAIT state via path C.","If the instruction specifies pushing two data registers or two pointer registers, state machine changes states to the state A or state C, respectively. The state machine transitions to these states via path D or F, and asserts the PUSH_DREG signal while transitioning to the state A or the PUSH_PREG signal while transitioning to the state C. In addition, while transitioning along path D, the state machine asserts the D_REG_PRESELECT signal initializing the counter that indicates which data registers to push. Similarly, while transitioning along path F, the state machine asserts the P_REG_PRESELECT signal initializing the counter that indicates which pointer registers to push.","The state machine returns to the WAIT state from the state A via path E. During this transition, MCI controller  again asserts PUSH DREG and deasserts D_REG_PRESELECT, causing decode unit  to dispatch the push of another data register. Similarly, the state machine returns to the WAIT state from the state C via path G. During this transition, MCI controller  asserts PUSH_PREG and deasserts P_REG_PRESELECT, causing execution unit  to push another pointer register.","For a PushPopMultiple instruction that requires instruction decode unit  to dispatch the push of three or more data registers, the state machine transitions from the WAIT state to the state B via path H. During the transition, MCI controller  asserts PUSH_DREG signal and asserts D_REG_PRESELECT, causing execution unit  to push a first data register. In addition, MCI controller  asserts MCI_PRESTALL signal causing stall controller  to stall one or more stages of pipeline  on the following clock. For example, in one embodiment, stall controller  asserts STALL_DEC to stall the decode stage of pipeline . Once in the state B, MCI controller  continues to push data registers until two registers remain to be pushed. For example, if the instruction called for six data registers to be pushed, MCI controller  traverses path I three times, pushing a data register each time, until the current data register to be pushed equals the maximum available data register (DMAX) minus one, i.e., when two data registers remain to be pushed.","While traversing path I, MCI controller  asserts the PUSH_DREG signal, the D_REG_PRESELECT signal and the MCI_PRESTALL signal. When two data registers remain to be pushed, MCI controller  transitions to the state A via path  while pushing one of the remaining data registers. During this transition, MCI controller  deasserts MCI_PRESTALL. Instruction decoder  receives a new instruction on the cycle after MCI controller  has traversed path E and has pushed the remaining data register.","Similarly, for a PushPopMultiple instruction that requires instruction decode unit  to dispatch the push of three or more pointer registers, the state machine transitions from the WAIT state to the state D via path J. During the transition, MCI controller  asserts PUSH_PREG signal and asserts P_REG_PRESELECT, causing execution unit  to push a first pointer register. In addition, MCI controller  asserts MCI PRESTALL signal causing stall controller  to stall one or more stages of pipeline . In the state D, MCI controller  pushes pointer registers by traversing path N until two pointer registers remain to be pushed. While traversing path N, MCI controller  asserts the PUSH DREG signal, the D_REG_PRESELECT signal and the MCI_PRESTALL signal. Once two data registers remain to be pushed, MCI controller  transitions to the state C via path K while pushing a pointer register. During this transition, MCI controller  deasserts MCI_PRESTALL. In this manner, pipeline  resumes operation on the next clock cycle after MCI controller  has transitioned to the WAIT state via pathG and has pushed the remaining pointer register.","In addition to the above functionality, a PushPopMultiple instruction may specify multiple data registers and multiple pointer registers. Generally, state machine  is designed to first push the data registers, followed by the pointer registers, although the invention is not limited as such.","For a Push Multiple instruction that specifies pushing a single data register and a single pointer register, MCI controller  transitions to the state C via path F\u2032 and asserts the PUSH DREG signal to push the data register. Next, MCI controller  transitions back to the WAIT state via path G and pushes the pointer register.","For a Push Multiple that specifies pushing one data register and more than one pointer register, MCI controller  transitions to the state D via path J\u2032 and asserts the PUSH_DREG signal, the D_REG_PRESELECT signal and the MCI_PRESTALL signal to push the data register. Next, MCI controller  pushes all but two of the pointer registers by traversing path N, pushes a pointer register by traversing path K and pushes the last pointer register and returning the WAIT state by traversing path G.","Finally, for a PushPopMultiple instruction that specifies pushing multiple data registers and at least one pointer registers, MCI controller  transitions to the state B via path H\u2032 and asserts the PUSH_DREG signal, the D_REG_PRESELECT signal and the MCI_PRESTALL signal to push a first data register. Next, MCI controller  pushes all but one of the data registers by traversing path I\u2032. If the instruction specifies a single pointer register to be pushed, MCI controller  pushes the final data register by traversing path M and pushing the single pointer register by traversing path G. Otherwise, MCI controller  pushes the final data register by traversing path L and pushes the multiple pointer registers by traversing paths N if necessary, followed by K and G.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 4","b":["40","5","5","40","40","5","7","4","4","5","5","4"]},"The following table summarizes the conditions that cause MCI controller  to transition between state of state diagram  and the corresponding output signals that are asserted, where D is an instruction bit that indicates a data register is to be popped, P is an instruction bit that indicates a pointer register is to be popped, DR is an instruction field indicating the last data register to pop from the stack, PR is a instruction field indicating the last pointer register to pop from the stack, D_TAG represents the current data register being popped, P_TAG represents the current pointer register being popped, DMAX represents the maximum data register in the range of available data registers and PMAX represents the maximum pointer register in the range of available pointer registers:",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["PATH","CONDITIONS","OUTPUT"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["44A","Not a pop multiple","None"]},{"entry":[{},"instruction"]},{"entry":["44B","P & !D & PR = PMAX","assert POP_PREG"]},{"entry":["44C","!P & D & DR = DMAX","assert POP_DREG"]},{"entry":["44D","P & !D & PR = PMAX \u2212 1","assert POP_PREG"]},{"entry":[{},{},"assert P_REG_PRESELECT"]},{"entry":["44E","none","assert POP_PREG"]},{"entry":["44F","!P & D & DR = DMAX \u2212 1","assert POP_DREG"]},{"entry":[{},{},"assert D_REG_PRESELECT"]},{"entry":["44F\u2032","D & P & DR = DMAX &","assert POP_PREG"]},{"entry":[{},"PR = PMAX"]},{"entry":["44G","none","assert POP_DREG"]},{"entry":["44H","P & !D & PR < PMAX \u2212 1","assert POP_PREG"]},{"entry":[{},{},"assert P_REG_PRESELECT"]},{"entry":[{},{},"assert MCI_PRESTALL"]},{"entry":["44H\u2032","D & P & PR < PMAX","assert POP_PREG"]},{"entry":[{},{},"assert P_REG_PRESELECT"]},{"entry":[{},{},"assert MCI_PRESTALL"]},{"entry":["44I","((!D & P_TAG > PR + 1) |","assert POP_PREG"]},{"entry":[{},"(D & P_TAG > PR))","assert P_REG_PRESELECT"]},{"entry":[{},{},"assert MCI_PRESTALL"]},{"entry":["44J","!P & D & DR < DMAX \u2212 1","assert POP_DREG"]},{"entry":[{},{},"assert D_REG_PRESELECT"]},{"entry":[{},{},"assert MCI_PRESTALL"]},{"entry":["44J\u2032","D & P & PR = PMAX &","assert POP_PREG"]},{"entry":[{},"DR < DMAX","assert P_REG_PRESELECT"]},{"entry":[{},{},"assert MCI_PRESTALL"]},{"entry":["44K","D TAG = DR + 1","assert POP_DREG"]},{"entry":[{},{},"assert D_REG_PRESELECT"]},{"entry":["44L","D & P_TAG = PR & DR <","assert POP_PREG"]},{"entry":[{},"DMAX","assert P_REG_PRESELECT"]},{"entry":[{},{},"assert MCI_PRESTALL"]},{"entry":["44M","D & P_TAG = PR & DR =","assert POP_PREG"]},{"entry":[{},"DMAX","assert P_REG_PRESELECT"]},{"entry":["44N","D_TAG > DR + 1","assert POP_DREG"]},{"entry":[{},{},"assert D_REG_PRESELECT"]},{"entry":[{},{},"assert MCI_PRESTALL"]},{"entry":["44O","P_TAG = PR + 1 & !D","assert POP_PREG"]},{"entry":[{},{},"assert P_REG_PRESELECT"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Initially, MCI controller  starts in the WAIT state until an instruction is fetched by fetch unit  and decoded by decode unit . If the instruction is not a PushPopMultiple instruction, MCI controller  returns to the WAIT state as indicated by path A.","If the instruction is a PushPopMultiple instruction that directs processor  to pop a single pointer register and no data registers, MCI controller  asserts a POP_DREG signal and returns to the WAIT state via path B. If the instruction is a Pop Multiple command and instructs processor  to pop a single data register, MCI controller  asserts the POP_DREG signal and returns to the WAIT state via path C.","If the instruction specifies popping two pointer registers or two data registers, MCI controller  changes states to the state A or state C, respectively, via paths D or F. MCI controller  asserts the POP_PREG signal while transitioning to the state A or the POP_DREG signal while transitioning to the state C. In addition, while transitioning along path D, MCI controller  asserts the P_REG_PRESELECT signal initializing a counter whose count indicates which pointer registers to pop. Similarly, while transitioning along path F, MCI controller  asserts the D_REG_PRESELECT signal, initializing a counter whose count indicates which data registers to pop.","After popping the first of the two pointer registers, MCI controller  returns to the WAIT state from the state A via path E. During this transition, MCI controller  again asserts POP_PREG and deasserts P_REG_PRESELECT, causing execution unit  to pop another pointer register. Similarly, after popping the first of the two data registers, MCI controller  returns to the WAIT state from the state C via path G. During this transition, MCI controller  asserts POP_DREG and deasserts D_REG_PRESELECT, causing execution unit  to pop another data register.","For a Pop Multiple instruction that requires instruction decode unit  to dispatch the pop of three or more pointer registers, MCI controller  transitions from the WAIT state to the state B via path H. During the transition, MCI controller  asserts POP_PREG signal and asserts P_REG_PRESELECT, causing execution unit  to pop a first pointer register. In addition, MCI controller  asserts MCI_PRESTALL signal causing stall controller  to stall one or more stages of pipeline  on the following clock. Once in the state B, MCI controller  continues to pop pointer registers until only two pointer registers remain to be popped. For example, if the instruction called for six pointer registers to be popped, MCI controller  traverses path I three times, popping a pointer register each time, until the current pointer register to be popped equals the maximum available pointer register (PMAX) minus one, i.e., when two pointer registers remain to be popped.","While traversing path I, MCI controller  asserts the POP_PREG signal, the P_REG_PRESELECT signal and the MCI_PRESTALL signal. When two pointer registers remain to be popped, MCI controller  transitions to the state A via path  while popping one of the remaining pointer registers. During this transition, MCI controller  deasserts MCI_PRESTALL. Instruction decoder  receives a new instruction on the cycle after MCI controller  has traversed path E and has popped the remaining pointer register.","Similarly, for a PushPopMultiple instruction that requires instruction decode unit  to dispatch the pop of three or more data registers and no pointer registers, MCI controller  transitions from the WAIT state to the state D via path J. During the transition, MCI controller  asserts POP_DREG signal and asserts D_REG_PRESELECT, causing execution unit  to pop a first pointer register. In addition, MCI controller  asserts MCI_PRESTALL signal causing stall controller  to stall one or more stages of pipeline . In state D, MCI controller  pops data registers by traversing path N until two data registers remain to be popped. While traversing path N, MCI controller  asserts the POP DREG signal, the D_REG_PRESELECT signal and the MCI_PRESTALL signal. Once two data registers remain to be popped, MCI controller  transitions to the state C via path K while popping a data register. During this transition, MCI controller  deasserts MCI_PRESTALL. MCI controller  then transitions to the WAIT state via path G and pops the remaining data register.","In addition to the above functionality, a PushPopMultiple instruction may specify multiple data registers and multiple pointer registers to be popped. Generally, state machine  is designed to first pop the pointer registers, followed by the data registers, although the invention is not limited as such.","For a PushPopMultiple instruction that specifies popping a single pointer register and a single data register, MCI controller  transitions to the state C via path F\u2032 and asserts the POP_PREG signal to pop the pointer register. Next, MCI controller  transitions back to the WAIT state via path G, asserts the POP_DREG signal and pops the data register.","For a PushPopMultiple instruction that specifies popping one pointer register and more than one data register, MCI controller  transitions to the state D via path J\u2032 and asserts the POP PREG signal, the P_REG_PRESELECT signal and the MCI_PRESTALL signal to pop the pointer register. Next, MCI controller  pops all but two of the data registers by traversing path N, pops a data register by traversing path K and pops the last data register and returns to the WAIT state by traversing path G.","Finally, for a Pop Multiple that specifies popping multiple pointer registers and at least one data registers, MCI controller  transitions to the state B via path H\u2032 and asserts the POP_PREG signal and the P_REG_PRESELECT signal to pop a first pointer register. Next, MCI controller  pops all but one of the pointer registers by traversing path I. If the instruction specifies a single data register to be popped, MCI controller  pops the final pointer register by traversing path M and popping the single data register by traversing path G. Otherwise, MCI controller  pops the final pointer register by traversing path L and pops the multiple data registers by traversing paths N if necessary, followed K and G.","Additional examples of instructions that direct pipelined processor  to perform multiple operations according to the invention are the Link instruction and the Unlink instruction. The Link instruction is typically used when invoking a subroutine and causes pipeline processor  to push a return address for a subroutine on a stack, push a frame pointer on the stack, move the stack pointer to the frame pointer and update the stack pointer based on a frame size for the subroutine, as specified by the instruction. The Unlink instruction is used when exiting the subroutine and causes pipelined processor  to restore the return address from the stack, restore the stack pointer and restore the frame pointer from the stack.","The following examples illustrate the Link and Unlink instructions:\n\n",{"@attributes":{"id":"p-0053","num":"0054"},"figref":"FIG. 5","b":["50","5","50","5","7","4","5","4"]},"The following table summarizes the output signals that are asserted while MCI controller  transitions through state diagram :",{"@attributes":{"id":"p-0055","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"PATH","OUTPUT SIGNAL"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"54A","None"]},{"entry":[{},"54B","PUSH_RTS, MCI_PRESTALL"]},{"entry":[{},"54C","PUSH_FP, MCI_PRESTALL"]},{"entry":[{},"54D","MOVE_SP_TO_FP"]},{"entry":[{},"54E","UPDATE_SP"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"If the present instruction is not a link command, then state machine directs MCI controller  to return to the WAIT state via path A. If the instruction is a Link instruction, MCI controller  transitions to stage B via path B and asserts the PUSH_RTS signal, causing decode unit  to dispatch a push of the return address on the stack. In addition, MCI controller  asserts MCI_PRESTALL to stall pipeline  on the following cycle.","Next, MCI controller  transitions to state C via path C, asserts PUSH_FP, causing decode unit  to dispatch a push of the frame pointer register onto the stack and asserts MCI_PRESTALL to stall pipeline  on the following cycle. MCI controller  then transitions to state D via path D and asserts MOVE_SP_TO_FP, causing instruction decode unit  to dispatch a move of the contents of the stack pointer register to the frame pointer register. Finally, MCI controller  transitions to the WAIT state via path E and asserts UPDATE SP, causing instruction decode unit  to dispatch a subtract of the frame size from the stack pointer as specified by the instruction.",{"@attributes":{"id":"p-0058","num":"0059"},"figref":"FIG. 6","b":["60","5","5","60"]},{"@attributes":{"id":"p-0059","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 4"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"PATH","OUTPUT SIGNAL"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"64A","None"]},{"entry":[{},"64B","LOAD_RTS, MCI_PRESTALL"]},{"entry":[{},"64C","LOAD_SP"]},{"entry":[{},"64D","UPDATE_FP"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"If the present instruction is not an Unlink command, then state machine  directs MCI controller  to return to the WAIT state via path A. If the instruction is an Unlink instruction, MCI controller  transitions to state B via path B and asserts the LOAD_RTS signal, causing instruction decode unit  to assert control signals that cause a return address to be to retrieved from the stack as follows: RETS=[FP +4]. In addition, MCI controller asserts MCI_PRESTALL to stall pipeline  on the following cycle.","Next, MCI controller  transitions to state C via path C and asserts LOAD_SP, causing instruction decode unit  to assert control signals that cause the setting of the stack pointer as follows: SP=FP+8.","Finally, MCI controller  transitions back to the WAIT state via path D and asserts UPDATE_FP, causing instruction decode unit  to assert control signals that cause the frame pointer to be loaded from the stack as follows: FP=[FP].",{"@attributes":{"id":"p-0063","num":"0064"},"figref":"FIG. 7","b":"8"},"Stall controller  may receive a number of input signals, such as stall_condition1 through stall_condition8, which may be asserted when a respective stall condition has been detected. The input signals are for exemplary purposes only; for example, stall controller  may receive any number of different stall conditions for the various stages of pipeline .","In response to the input stall condition signals, stall controller  may generate stall signals  to stall pipeline . Stall controller  may produce a plurality of stall signals , which correspond to the stages of pipeline . For example, when either stall_condition1 or stall_condition2 is asserted, and processor  is not in reset, stall controller  may assert the stall_wb output signal, resulting in a stall of the WB stage of pipeline . Notably, the stall_wb output signal is used to generate stall output signals for earlier stages of pipeline , such as the stall_ex output signal. More specifically, stall controller  asserts the stall_ex output signal when stall_condition3, stall_condition4 or stall_wb is asserted and processor  is not in reset. In this manner, a stall in the WB stage forces a stall in the EX stage. Stall controller  similarly generates the stall_ac and stall_dec signals based on independent hazard conditions as well as stalls in later stages of pipeline .","When conditions arise that cause the decode stage to stall, stall controller  asserts the stall_dec_mci signal, which causes MCI controller  to stall. More specifically, MCI controller  does not transition from its current state when stall_dec_mci is asserted.","Stall timing circuit  of stall controller  receives the MCI_PRESTALL signal from MCI controller  and, in response, asserts the MCI_STALL signal. OR gate  receives the MCI_STALL signal provided by stall timing circuit  and asserts the STALL_DEC signal, thereby stalling the decode stage and the earlier stages of pipeline .",{"@attributes":{"id":"p-0068","num":"0069"},"figref":"FIG. 8","b":["8","4","4","4","5","5"],"sub":"\u2014"},{"@attributes":{"id":"p-0069","num":"0070"},"figref":"FIG. 9","b":["72","5","92","72","5"]},{"@attributes":{"id":"p-0070","num":"0071"},"figref":"FIG. 10","b":"100"},"For push operations, circuit  counts up from a starting data register to the maximum data register. For pop operations, circuit  counts down through the range of registers to the last data register. More specifically, on the first cycle, multiplexer  selects between a maximum data register (DMAX) or a starting data register from an instruction field (DR), such as data register five, based on whether PPM SELECT, which is asserted for push operations and deasserted for pop operations.","The D_REG_PRESELECT output signal provided by MCI controller  enables multiplexer  to select the output of multiplexer  for the first cycle of an MCI instruction and the output of storage circuit  for the remaining cycles. The output of multiplexer , D_TAG, is incremented or decremented by adder , depending PPM_SELECT, and fed back to storage circuit  The output signal, D_TAG, is fed to instruction decode unit  of pipeline  for pushing or popping registers and is also fed back as an input to the state control logic of MCI controller .",{"@attributes":{"id":"p-0073","num":"0074"},"figref":["FIG. 11","FIG. 10"],"b":["110","100","110"]},"Various embodiments of the invention have been described. For example, a pipelined processor has been described that includes a reset unit that provides an output reset signal to at least one stage of an execution pipeline. The reset unit handles reset requests, such as hard resets, soft resets and emulation resets, as a reset event having an assigned priority.","The processor can be implemented in a variety of systems including general purpose computing systems, digital processing systems, laptop computers, personal digital assistants (PDA's) and cellular phones. In such a system, the processor may be coupled to a memory device, such as a Flash memory device or a static random access memory (SRAM), that stores an operating system or other software applications. These and other embodiments are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIGS. 10 and 11"}]},"DETDESC":[{},{}]}
