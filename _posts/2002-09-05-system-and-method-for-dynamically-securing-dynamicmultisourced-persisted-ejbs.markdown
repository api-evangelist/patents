---
title: System and method for dynamically securing dynamic-multi-sourced persisted EJBS
abstract: Dynamic Multi-sourced Persisted Enterprise Java Bean (EJB) instances are dynamically created on a J2EE compliant Application Server to access data contained in multiple data source systems. This Dynamic Multi-sourced Persisted EJB is a general class responsible for dynamically aggregating source system information and securing it based on a Context definition. Individual EJB attributes that include mapping, caching and security definitions are mapped to individual pieces of data in source systems by the Context definition. A Context definition can be reloaded during execution as desired. Applications can access the Dynamic Multi-sourced Persisted EJB directly, or use a Session EJB to create a static interface to the dynamically mapped, cached and secured data. Using an attribute securing element, a security engine enforces access requirements on a system-wide basis.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06922695&OS=06922695&RS=06922695
owner: Initiate Systems, Inc.
number: 06922695
owner_city: Chicago
owner_country: US
publication_date: 20020905
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","Reference-Applications","BACKGROUND OF INVENTION","SUMMARY OF INVENTION","DETAILED DESCRIPTION"],"p":["This application claims benefit of U.S. Provisional Application No. 60\/317,700, filed on Sep. 6, 2001.","The invention relates generally to electronic business transaction processing, and more particularly to systems for accessing back-end enterprise applications and data from the Internet by providing an intelligent, real-time data and logic cache that is synchronized with back-office systems.","Many business enterprises have collections of enterprise application systems that contain large volumes of disparate applications and data that are not compatible with the real-time, online transaction processing requirements of Internet web-based applications. Many of these systems were designed prior to the availability of the Internet. As a result, there exist many incompatibility issues between the various systems, including interface and synchronization incompatibilities as well as an inability to operate on a 24 hour, 7 days a week basis. For some applications, the data stored in disparate systems are related and requiring linking in a relational manner to provide useful information to customers, other companies and employees of an enterprise.","Because of the lack of a unified, coherent solution to the problems of connecting web-base applications to back office or legacy systems, many enterprises have to hire technical personnel to develop a unique solution to solve their own unique enterprise system problems. This approach oftentimes results in a less than optimum solution to the problem because of evolving technologies and lack of a sufficiently large, skilled workforce. More importantly, the burden with operating and maintaining a unique and usually non-flexible solution consumes large amounts of enterprise resources.","There is a need for a real-time transaction-processing platform that connects online web-based applications to back office enterprise systems while providing control over enterprise data and business rules. The platform must provide synchronization with back office systems to manage performance and enhance security of the online business environment. It must be easily and rapidly applied to a wide range of business environments while minimizing the burden of installing; operating, enhancing and maintaining the system. The system must be capable of providing high performing, reliable, fault tolerant, load balanced and scalable operation.","The present invention provides a real-time transaction-processing platform that connects online web-based applications to back office enterprise systems while providing control over enterprise data and business rules. It provides synchronization with back office systems, enhances security of online transaction processing, and is readily applied to a wide range of business environments. By minimizing the need for customized development through use of reliable, standard, reusable components, the costs associated with installing, operating, enhancing and maintaining the system are minimized. Through use of standard application servers and enterprise application interface technology, the system provides a high performance, reliable, fault tolerant load balanced scalable platform. The system enables consolidation of information from disparate back office systems into one easily manageable, real-time data cache and management services layer to enable complex online transactions across multiple channels.","The present invention relies on the Java 2 Enterprise Edition (J2EE\u2122) standard defined by Sun Microsystems as a software architecture for use in constructing multi-tiered transaction systems. J2EE\u2122 systems generally run on an application server that has been certified to be compliant with the J2EE\u2122 standard specification. The J2EE\u2122 standard is incorporated herein by reference. Several major manufacturers produce J2EE\u2122 compliant application servers. The present invention also makes use of Enterprise JavaBeans\u2122 (EJB\u2122) as a component architecture for the development and deployment of component-based business applications. The Enterprise JavaBeans\u2122 specification was created under the Java Community Process to provide full public participation in the definition and development. This specification is incorporated herein by reference.","The present invention is a unique and novel application of EJB\u2122 in the form of a Dynamic Multi-sourced Persisted EJB. The Dynamic Multi-sourced Persisted EJB executes on a J2EE\u2122 compliant web application server and uses a context definition that is read at runtime to map each EJB\u2122 attribute to specific data in source systems. The Dynamic Multi-sourced Persisted EJB can be invoked from Session EJBs that in turn provide data to JavaServer Pages (JSP\u2122) and\/or servlets for creating a client interface. The Dynamic Multi-sourced Persisted EJB can also be invoked directly from client Java\u2122 applications. The Dynamic Multi-sourced Persisted EJB uses Bean-Managed Persistence (BMP) supported by the J2EE\u2122 architecture to optionally cache data accessed in source systems. The data is synchronized between the cache and source systems. This cache is persisted to disk to allow the application server to respect the standard J2EE\u2122 EJB\u2122 lifecycle. The Dynamic Multi-sourced Persisted EJB also provides a consistent attribute security model to limit unrestricted access to data.","In an embodiment of the present invention, a method for dynamically securing Dynamic Multi-sourced Persisted EJB attributes comprises creating a context definition containing attributes representing collections of source system data, specifying in an attribute securing element access security requirements for each attribute in the context definition, storing the context definition in a persistent data cache, creating an instance of a Dynamic Multi-sourced Persisted EJB, applying the attributes in the context definition to the created instance of the Dynamic Multi-sourced Persisted EJB, accessing secured data by the Dynamic Multi-sourced Persisted EJB instance without requiring EJB compilation and deployment, and sending attribute data from source systems to clients and from clients to source systems in response to client queries that meet the access requirements of respective attribute securing elements. The method may further comprise specifying whether each attribute in the context definition is mapped to a field in a data source, identifying a data source system table where the attribute value is located if the attribute is mapped, and specifying in an attribute caching element whether each attribute in the context definition is to be cached in a persistent data cache. The step of storing the context definition may comprise dynamically creating a persistent cache table containing attribute securing elements in the persistent data cache for managing context attributes during EJB Bean Managed Persistence lifecycle. The step of storing the context definition may comprise dynamically creating a persistent Map\/Cache\/Secure Table in the persistent data cache. The method may further comprise reloading a context definition for updating attribute securing requirements during execution and keeping cache data synchronized and updated with client and back-end data. The reloading of the context definition may be performed during execution on demand. The reloading of the context definition may be performed during execution on a schedule. The step of reloading the context definition may comprise verifying the user requesting reloading has security authorization for executing a reload, detecting differences between the stored context definition and the reloaded context definition for identifying changes in the context definitions, and rebuilding persistent cache database tables containing context definitions, for incorporating changes in the context definition. The method may further comprise authorizing loading attributes of a new context definition based on the attribute securing elements, creating and loading a new context definition containing new attributes, applying the new attributes to the Dynamic Multi-sourced Persisted EJB instance for mapping the new attributes to source system data fields during runtime, recreating the persistent data cache, and immediately sending new attribute data to clients. The method may further comprise representing the context definition as an XML document. The step of creating an instance of a Dynamic Multi-sourced Persisted EJB may comprise creating and accessing an instance of a Dynamic Multi-sourced Persisted EJB from an external application using generic method calls of an application programming interface selected from the group consisting of creates( ), find( ), getAttr( ), getAttrs( ), getGuid( ), setAttr( ), setAttrs( ) and retrieveNewAndDeletedContexts( ). The method may further comprise performing runtime checks prior to executing a method call including querying a security engine to determine if the method call is authorized and querying back-end adapters to determine if there are pending back-end mapped data updates for keeping cache data synchronized and updated with back-end mapped data. The step of creating an instance of a Dynamic Multi-sourced Persisted EJB may comprise creating and accessing an instance of a Dynamic Multi-sourced Persisted EJB from an external application through a Session EJB Wrapper using traditional method calls of an application programming interface selected from the group consisting of create( ), getAttributeName( ) and setAttributeName( ). The method may further comprise performing runtime checks prior to executing a method call including querying a security engine to determine if the method call is authorized and querying back-end adapters to determine if there are pending back-end mapped data updates for keeping cache data synchronized and updated with back-end mapped data. The method may further comprise defining a key attribute element to enable accessing source system data through adapters. Another embodiment of the invention is a computer-readable medium containing instructions for controlling a computer system to implement the method described above.","An alternative embodiment of the present invention is a system for dynamically securing Dynamic Multi-sourced Persisted EJB attributes that comprises means for creating a context definition containing attributes representing collections of source system data, an attribute securing element for specifying access security requirements for each attribute in a context definition, means for storing the context definition in a persistent data cache, means for creating an instance of a Dynamic Multi-sourced Persisted EJB, means for applying the attributes in the context definition to the created instance of the Dynamic Multi-sourced Persisted EJB, means for accessing secured data by the Dynamic Multi-sourced Persisted EJB instance without requiring EJB compilation and deployment, and means for sending attribute data from source systems to clients and from clients to source systems in response to client queries that meet the access requirements of respective attribute securing elements. The system wherein each attribute may comprise an element specifying whether each attribute in the context definition is mapped to a field in a data source, an element identifying a data source system table where the attribute value is located if the attribute is mapped, and an element specifying caching requirements for each attribute in the context definition. The means for storing the context definition may comprise dynamically creating a persistent cache table containing attribute securing elements in the persistent data cache for managing context attributes during EJB Bean Managed Persistence lifecycle. The persistent cache table may comprise a Map\/Cache\/Secure Table. The system may further comprise means for reloading a context definition for updating attribute caching requirements during execution and means for keeping cache data synchronized and updated with client and back-end data. The system wherein the context definition may be reloaded during execution on demand. The system wherein the context definition may be reloaded during execution on a schedule. The system wherein the context definition may be an XML document. The means for creating an instance of a Dynamic Multi-sourced Persisted EJB may comprise means for creating and accessing an instance of a Dynamic Multi-sourced Persisted EJB from an external application using generic method calls of an application programming interface selected from the group consisting of create( ), find( ), getAttr( ), getattrs( ), getGuid( ), setAttr( ), setAttrs( ) and retrieveNewAndDeletedContexts( ). The system may further comprise means for performing runtime checks prior to executing a method call including means for querying a security engine to determine if the method call is authorized and means for querying back-end adapters to determine if there are pending back-end mapped data updates for keeping cache data synchronized and updated with back-end mapped data. The means for creating an instance of a Dynamic Multi-sourced Persisted EJB may comprise means for creating and accessing an instance of a Dynamic Multi-sourced Persisted EJB from an external application through a Session EJB Wrapper using traditional method calls of an application programming interface selected from the group consisting of create( ), getAttributeName( ) and setAttributeName( ). The method may further comprise means for performing runtime checks prior to executing a method call including querying a security engine to determine if the method call is authorized and means for querying back-end adapters to determine if there are pending back-end mapped data updates for keeping cache data synchronized and updated with back-end mapped data. The system may further comprise a key attribute element to enable accessing source system data through adapters.","Yet another embodiment of the present invention is a system for dynamically securing Dynamic Multi-sourced Persisted EJB attributes to source system resources that comprises an application server including contexts connected to JMS adapters, a data cache connected to the contexts in the application server for providing BMP data for mapping Dynamic Multi-sourced Persisted EJB attributes to back-end system data fields, system adapters for connecting JMS adapters to back-end systems, an XML data storage device for providing context definition documents to the contexts and JMS adapters in the application server and to the system adapters, and a security engine for applying system access authorization requirements. The contexts may include Dynamic Multi-sourced Persisted EJB instances and Session EJB Wrappers.","Yet another alternative embodiment of the present invention is a system for dynamically securing Dynamic Multi-sourced Persisted EJB attributes that comprises a context definition containing attributes representing collections of source system data, an attribute securing element for specifying access security requirements for each attribute in the context definition, a persistent data cache for storing the context definition, an instance of a Dynamic Multi-sourced Persisted EJB, the attributes in the context definition applied to the created instance of the Dynamic Multi-sourced Persisted EJB, the Dynamic Multi-sourced Persisted EJB instance accessing secured data without requiring EJB compilation and deployment, and attribute securing elements for enabling sending attribute data from source systems to clients and from clients to source systems in response to client queries that meet the access requirements of respective attribute securing elements.","Turning now to ,  shows a three-tiered client-server architecture  for Internet applications. This architecture  is known to those skilled in the relevant art. Web application servers typically provide the middle tier  of a three-tiered architecture for Internet applications. Tier ,  provides the presentation to the end-user of the application. Typically this consists of a web browser such as Netscape, or Internet Explorer interpreting HTML forwarded by a web server in Tier ,  via a Local Area Network (LAN) . Tier ,  provides the business logic. This business logic typically is written in Enterprise Java Beans (EJBs), Java Server Pages JSPs), and servlets. Usually this tier can be broken down into a Web server and an Application server. The Web server JSPs and servlets \u201cserve up\u201d HTML pages to Tier , . The Application server executes EJBs to respond to JSP and servlet requests. Tier ,  provides data and resources to Tier ,  via a LAN  in the form of databases like DB, CICS, conventional business applications (legacy\/non-web), and possibly large processing power provided by mainframes.","Turning now to ,  shows a functional flow diagram  of an application server . This functional flow  is known to those skilled in the relevant art. A session EJB  is typically created to communicate with a Java Server Page (JSP) or servlet process . The JSP or servlet  is responsible for creating the presentation layout on the clients . The session EJB  usually has the life cycle equal to the client session (user visiting a web page on a browser). The session EJB  also communicates with an Entity EJB . The Entity EJB  encapsulates permanent data and methods to manipulate that data. The life of an Entity EJB  is much longer than a session EJB . The Application Server will persist the Entity EJB and its data to a database or file in case of system failure\/resource constraints. Alternatively, the Entity EJB  can be accessed directly from a client Java application . This simplifies programming by removing several layers of code in JSPs and servlets . The disadvantage is Java applications  do not execute in browsers over the world wide web. Entity EJBs  may also access resources  outside of the Application Server (Tier )  through JDBC calls or other connector interfaces. It is important to note that each resource  may be accessed by very different Application Programming Interfaces (APIs), and that the complexity and maintenance costs of the Entity EJBs  can be very high.","Turning to ,  shows a typical development cycle  with compile-time tools. This process  is known to those skilled in the relevant art. There are many compile-time developer tools are available to aid in generating the Entity EJB code  necessary to access the third tier resources in back office systems. Entity Beans are complex Java\u2122 programs, and powerful tools are available to lead the developer through graphical user interfaces to help map EJB data elements , or attributes, to similar individual records in back-end databases. Once the developer has worked through the mapping, the tool will generate the Entity EJB code , compile it in a Java\u2122 compiler , and in some cases deploy the tool  on an Application Server . These tools are effective for mapping the Entity EJB to Tier  resources, but they produce a static Entity EJB and as such lack an ability to dynamically manage the mapping once the Entity EJB is deployed. For example, highly skilled resources are necessary to simply re-map an Entity EJB attribute to a new column in a database. The entire Entity EJB must be reconstructed and reloaded into the tool set , recompiled , and then redeployed  on the Application Server .","Some tools provide options to \u201ccache\u201d EJBs in the Application Server's Container Managed Persistence (CMP). This results in many lines of code being generated. Often the flexibility of the cache is limited, and debugging is difficult. Furthermore, using CMP as the persistence mechanism limits the flexibility of controlling what is cached. These tools lack the ability to synchronize data between the CMP and back-end systems, and data is persisted either in CMP or back-end systems but not both.","Security mechanisms are typically managed through custom coding for each application, or web application server's mechanisms. The web application server mechanism can protect access to individual applications, or even individual method calls within an application. It is often difficult to manage secure access based on data elements. Any method level or application security is often applied redundantly for each application or set of EJBs.","Turning now to ,  shows an example of a context definition  of a Dynamic Multi-sourced Persisted EJB . Dynamic Multi-sourced Persisted EJBs are the subject of the present invention and are dynamically created on a J2EE compliant Web Application Server to access data contained in multiple back-end systems. The Dynamic Multi-sourced Persisted EJB is a general class that is responsible for mapping, caching, and securing data. The example context definition  is a customer instance, although it could reflect any data or data structure that may be mapped to a back-end system or stored in a cache. The attributes of the Dynamic Multi-sourced Persisted EJBs are defined and mapped to resources in data source systems without requiring compilation. This mapping results in synchronization of Dynamic Multi-sourced Persisted EJB data with data in the source systems. The Dynamic Mapping Context invention comprises a Context definition  that can be dynamically loaded during runtime. The Dynamic Multi-sourced Persisted EJB makes use of an external context definition that is read at runtime. Each Dynamic Multi-sourced Persisted EJB attribute can be:","1. Mapped or Unmapped (mapped to data-source, or only in cache)","2. Cached or non-cached (cached after first read, or always read\/write direct to data source).","3. Secured or unsecured (role based read and write access, or security off)",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 4","FIG. 4","FIG. 4","FIG. 4","FIG. 4"],"b":["420","422","424","426","410","412","414","416","410","420","412","420"]},"When a context definition is initially loaded, each attribute is individually mapped to a field in a data source. A persistent cache table is dynamically created to maintain the context attribute states during the EJB Bean Managed Persistence (BMP) lifecycle. Each Context attribute is persisted in the cache, which is implemented on a relational database. In the case where a \u201ckey\u201d value is required for an adapter, the \u201ckey\u201d is defined as an attribute of the context with a \u201ckey\u201d designation. This allows the context to pass to the data source adapters all keys necessary to obtain data from the source system. Each attribute is typically mapped to a single field in a data source, but the invention allows for attributes to be multiply mapped, where one field is designated as primary. Data is then read from the primary field, and written to all the multiply mapped data source fields. Each data source adapter (i.e. JDBC, CORBA, etc.) is responsible for handling Create, Read, Update, and Delete (otherwise known as \u201cCRUD\u201d) functions of data bi-directionally from context clients to data source systems, and data source systems to context clients. Some adapters may only have a limited subset of functions (e.g., read-only, or create only). Whenever a new Context definition is loaded, Dynamic Multi-sourced Persisted EJBs immediately adapt (if necessary) the mapping of attributes to data source fields and recreates the persistent cache. On subsequent reloads of the Context definition, an application server service is used to detect differences in the Context definition and rebuild the cache database if necessary. To rebuild the cache database, the system must perform the following operations:\n\n","Consuming applications immediately start receiving the new set of attributes.","The present invention is a system that is capable of dynamically aggregating source system information and managing it based on a Context definition without long tooling, compile, deploy development cycle that is typical of custom coded methods. Most Context definition changes can be dynamically adapted at runtime for mapping all the data in an enterprise. Definition of attributes of Dynamic Multi-sourced Persisted EJBs for mapping, caching, and securing, as illustrated in  are stored as XML documents. Table 1 addresses some of the changes to the context XML definition that may be encountered. Certain XML changes may need the cache to be rebuilt, and running applications may be impacted.",{"@attributes":{"id":"p-0040","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Map\/Cache\/Secure",{},"Running"]},{"entry":["change","How adapted","application impact"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Attribute added","Rebuild cache database","No impactNew"]},{"entry":[{},{},"attribute can be"]},{"entry":[{},{},"accessed"]},{"entry":["Attribute deleted","Rebuild cache database","Not found"]},{"entry":[{},{},"exception returned"]},{"entry":[{},{},"if accessing"]},{"entry":[{},{},"deleted attribute"]},{"entry":["Attribute renamed","Rebuild cache database","Not found"]},{"entry":[{},"with new meta","exception returned"]},{"entry":[{},"information","if accessing"]},{"entry":[{},{},"renamed attribute"]},{"entry":["Attribute data type","Rebuild cache database","Cast exception"]},{"entry":["changed","with new meta","returned if"]},{"entry":[{},"information and","accessing the"]},{"entry":[{},"transform data during","attribute for the"]},{"entry":[{},"cache database copy","data type that was"]},{"entry":[{},{},"changed"]},{"entry":["Attribute","Rebuild cache database","No impact"]},{"entry":["java.lang.String","with new meta"]},{"entry":["length exceeds","information"]},{"entry":"string length in"},{"entry":"cache field"},{"entry":["Attribute mapping","Cache synchronizes with","No impact"]},{"entry":["switched to new","new data source system"]},{"entry":["data source system","field"]},{"entry":"field"},{"entry":["Attribute unmapped,","Cache synchronizes with","No impact"]},{"entry":["cached switched to","data source system field"]},{"entry":"mapped, cached"},{"entry":["Attribute unmapped,","Context always goes to","No impact"]},{"entry":["cached switched to","data source system"]},{"entry":"mapped, not cached"},{"entry":["Attribute mapped,","Data source system","No impact"]},{"entry":["cached switched to","synchronization stops"]},{"entry":"unmapped, cached"},{"entry":["Attribute mapped,","Context always goes to","No impact"]},{"entry":["cached switched to","data source system"]},{"entry":"mapped, not cached"},{"entry":["Attribute mapped,","Build cache database","No impact"]},{"entry":["not cached switched","and synchronize with"]},{"entry":["to mapped, cached","data source system"]},{"entry":["Attribute mapped,","Build cache database; no","No impact"]},{"entry":["not cached switched","synchronization required"]},{"entry":"to unmapped, cached"},{"entry":["Attribute that is","Read occurs from new","No impact"]},{"entry":["multiply mapped","data source system field"]},{"entry":"switches field of"},{"entry":"record"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Whenever a new Context definition is loaded, the system immediately changes the mapping of attributes to data source fields and recreates the persistent cache if necessary. Consuming applications immediately start receiving the new set of attributes.","Turning to ,  depicts generic methods  for accessing instances of Dynamic Multi-sourced Persisted EJBs . Dynamic Multi-sourced Persisted EJB instances  are created and accessed using an Application Programming Interface (API) . When an External application needs to create a new Dynamic Multi-sourced Persisted EJB instance, a creates( ) method is exposed . When an external application needs to retrieve a list of context instances  that fit a given set of criteria, the Dynamic Multi-sourced Persisted EJB exposes find( ) methods  for retrieving lists of contexts for this purpose. The application may use the list as a collection of Dynamic Multi-sourced Persisted EJB instances, or may use a single element to reference a specific instance of a Dynamic Multi-sourced Persisted EJB. The Dynamic Multi-sourced Persisted EJB is table driven and \u201ccoded only once\u201d. Instead of writing unique EJB methods for each data type, the Dynamic Multi-sourced Persisted EJB presents a generic API to access the attributes. Attributes of Dynamic Multi-sourced Persisted EJB instances are not accessed with traditional coding patterns of getXxx( ) and setXxx( ), where \u201cXxx\u201d represents the name of specific attributes. The present invention uses generic methods getAttr( )  and setAttr( )  instead of getXxx( ) and setXxx( ). Table 2 lists the generic method calls used by a generic API to access Dynamic Multi-sourced Persisted EJB attributes.",{"@attributes":{"id":"p-0043","num":"0048"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Java.lang.Object","getAttr (java.lang.String method for arbitrary"]},{"entry":[{},"attribute"]},{"entry":["java.util.HashMap","getAttrs (java.util.Vector getter method for arbitrary"]},{"entry":[{},"attributes."]},{"entry":["Java.lang.String","getGuid () unique GUID associated with a Dynamic"]},{"entry":[{},"Multi-sourced Persisted EJB instance."]},{"entry":["java.util.HashMap","retrieveNewAndDeletedContexts"]},{"entry":["[] []","(java.lang.StringxtType) new and deleted instances"]},{"entry":[{},"of a specific type."]},{"entry":["void","setAttr (java.lang.Stringjava.lang.ObjectattrValue)"]},{"entry":[{},"method for arbitrary attribute"]},{"entry":["java.util.HashMap","setAttrs (java.util.HashMap setter method for"]},{"entry":[{},"arbitrary attributes."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Turning to ,  illustrates checks that are conducted before a method call request is executed  via an API involving a Dynamic Multi-sourced Persisted EJB instance . At the time a Dynamic Multi-sourced Persisted EJB instance is created or accessed by an API , two additional runtime checks are made before a method call may be executed. A Security Engine  is queried to determine if the method call request is authorized, and Back-end Adapters  are queried to determine if there are back-end updates. The authorization check validates that the caller has authorization to access the data of particular attributes. If authorization is not validated, an exception is returned. The back-end update check applies or clears any pending back-end data updates to the cache before executing a getAttr( ) or setAttr( ) request.  shows an embodiment of Dynamic Multi-sourced Persisted EJB code for the getAttr( ) method, and illustrates the use of Authorization and Back-end Updates.","Turning now to ,  shows a traditional Session EJB Wrapper  in the method execution process . If an application desires to access a Dynamic Multi-sourced Persisted EJB  with a traditional Session EJB Wrapper , then the generic getAttr( ) and setAttr( ) methods accessed via an API  are exposed to the applications with the traditional getXxx( ) and setXxx( ) method patterns, where \u201cXxx\u201d is the attribute name.  is an example of Session EJB code for invoking methods in a Dynamic Multi-sourced Persisted EJB, as shown in FIG. A.","Turning to ,  shows a functional diagram  of a system implementation of the present invention. It depicts a system capable of dynamically aggregating back-end system information and managing it, without the long tooling, compile, deploy development cycle of other methods. Other benefits include low maintenance of mapping, performance improvements by caching hard to reach data, and a uniform security policy for all the data in an enterprise.  illustrates Dynamic Multi-sourced Persisted EJB instances  executing on a J2EE\u2122 compliant Web Application Server  and uses a Map\/Cache\/Secure Table  that is read in at runtime to control access to each Dynamic Multi-sourced Persisted EJB attribute. The Dynamic Multi-sourced Persisted EJB instances  can be invoked from Session EJBs  that in turn provide data to JSPs and\/or servlets  for creating a client interface to a web Browser . Alternatively, Dynamic Multi-sourced Persisted EJB instances  may be invoked directly from client Java\u2122 applications . The Dynamic Multi-sourced Persisted EJB uses Bean Managed Persistence (BMP) supported by the J2EE\u2122 architecture to optionally cache source system data in a Cache  accessed in Back-end Systems  via Back-end Adapters . Data is synchronized between the Cache  and Back-end Systems . The Cache  is persisted to disk to allow the Application Server  to respect the EJB life cycle. Also, the Dynamic Multi-sourced Persisted EJBs provide a consistent attribute Security Engine  to protect unrestricted access to the data.  depicts an example of an XML document to define a Map\/Cache\/Secure Table  for defining the attributes of a Dynamic Multi-sourced Persisted EJB instance  shown in FIG. .","Once Context attributes of Dynamic Multi-sourced Persisted EJB instances  in the Map\/Cache\/Secure Table  have been designated as cached , the system  synchronizes the cache data  with updates from Client Applications ,  or updates from the Back-end Resources . Communication between the Context runtime and the Back-end Adapters  ensures that any creates, updates or deletes of data from the Context clients ,  are sent to the Back-end Adapters  to keep the data source systems  in synchronization with the Cache . The Back-end Adapters  also notify the Contexts  when create, updates, or deletes occur originate in the data source system . By default, if creates, updates, or deletes occur simultaneously on the client systems ,  and data source systems  for the same data, the client change prevails. However, the Context Definition  can specify that the data source  change prevails. In either case, all conflicts will be logged. Since Context attributes  have been cached into a relational database , the system allows the client applications ,  to query the Cache  for data. This feature provides for higher performance when searching for data that may have originated from slower data source systems, and for joining of query results across multiple data source systems .","Turning to ,  shows an embodiment  of the present invention in a system environment. The \u201cContexts\u201d(Dynamic Multi-sourced Persisted EJBs and Session EJB Wrappers) , \u201cBMP Data\u201d(cache or SMARTcache) , and \u201cJMS Adapters\u201d(back-end adapters)  are at the heart of the present invention. The following terms are useful in the understanding the system model .","Object model\u2014the abstract representation of a set of java classes that together represent an entity such as customer, product, part, or agent. Object models are the beginning point for the creation of Contexts .","Context\u2014the java representation within the system of Dynamic Multi-sourced Persisted EJBs and Session EJB wrappers as object models.","Context Instance\u2014a specific instance of a Context ; e.g., the instance of the customer class pertaining to customer #.","SMARTcache\u2014the collective term for the persistent store of Contexts  as data .","Control Center\u2014 the console within the system  from which the SMARTcache administrator configures, maps, and monitors Contexts .","Mapping\u2014the correlation between a data element (attribute) and a field in a Back-end System .","Adapter\u2014a piece of java code that enables the interchange of data between the system  and other applications (including EAI ).","JMS Adapter\u2014 a connector between the Context EJBs  and a Java Messaging Service API into an EAI layer .","System Adapter\u2014 a connector between the EAI messaging layer and an element of the existing IT infrastructure .","Accelerator\u2014the term for the components of the system that expedite development and refinements of contexts, mappings, and deployments.","A calling application initiates a system transaction, which may be in the form of a Trusted Java Application  in a Client Machine , or a Client Application  in a Web Browser  via a Client Web Application Servlet  within a Web Server . A Control Center  within a Web Browser  contains tools for administering the Context attribute mappings and security roles via a Context Administration Servlet  in a Web Server . Firewalls  maintain security between Web Browsers  and a Web Server , between the Web Server  and a Web Application Server , and between Client Machines  and the Web Application Server . The Web Application Server  is a runtime server in which a set of Context objects  synchronize with Back-end Systems  via JMS Adapters  and System Adapters . A J2EE EJB client application  invokes an EJB method to communicate with Contexts  via RMI over IIOP protocol. RMI\/IIOP is one J2EE standard way of allowing an application developer to code to an RMI interface.","The Control Center  is the development and management environment for the system platform . The Control Center  provides the following capabilities: view a list of defined Contexts; define, change, or delete mappings between data in Back-end systems and Context attributes; designate Context attributes as cached or non-cached; define, change or delete security authorizations for Context attributes; and view the runtime log. The Control Center  also includes toolsets containing log configuration and analysis capabilities, system performance analysis tools, and control over automated features. The Control Center  is a J2EE application comprising JSP, servlets, EJBs, and XML files. The Control Center  is a J2EE browser client application, which enables remote administration of the system . The Control Center  communicates with an Administrative Service EJB  via JSPs and a Context administrative Servlet . The Administrative Service EJB  reads and writes Context configuration data from a set of XML files . The runtime server  uses these same XML files . If necessary, the XML files  can be file system protected so that access is limited to selected applications. The Administrative Service  retrieves roles that map into an LDAP (Lightweight Directory Access Protocol) system . This list of roles is then presented within the \u201cEdit Security\u201d display of the Control Center . Using this facility, specific roles may be associated with given attributes in a Context. The system runtime server  also captures log data , which can be presented on the \u201clog view\u201d display of the Control Center .","The Web Application Server  is the component of the system  shown in  that enforces the rules established through the tools of the Control Center . The runtime server  responds to requests from calling applications, serving up Context instances  on request, according to the security rules that have been established. It coordinates with the EAI solution  to ensure that changes made through Contexts  are coordinated with Back-end Systems , and that changes made to Back-end System data are carried into the Context instance . It stores the data that have been designated for caching in a disk cache  that provides rapid access. It also logs activity data for diagnostic and monitoring purposes .","Applications attach to a remote interface of the Context Session EJB (Dynamic Multi-sourced Persisted EJBs and Session EJB Wrappers) . When a remote method invocation is made, several things occur:\n\n","In addition, updates may occur directly to a Back-end Systems  through another interface, which is independent of the present System . In this case, the data changes are detected by System  and propagated up to the Contexts . Throughout the operations of the Web Application Server , log data  is captured by a logging service. This is useful for diagnostic and debugging purposes.","Central to the security solution for System  are the security services provided by the Application Server  hosting the various components. Most Application Servers provide a complete set of authentication, authorization, and delegation services, which can be configured when deploying the System . Most Application Servers follow the J2EE\u2122 security specifications to varying degrees, depending on the vendor and the release of the Application Server. Within the J2EE\u2122 specification, the System Administrator configures most of the security services during deployment through a combination of deployment descriptors and Application Server configurations. The J2EE\u2122 specification addresses role-based authorization on methods of a resource in the deployment descriptors and authentication mechanisms. However, the J2EE\u2122 specification leaves the details of security enablement, mapping of logical role to installation specific principals, and delegation of credentials to the discretion of the Application Server vendors.","The following is a description of an embodiment of the present invention for providing authentication, authorization and delegation to the various system components that is reflective of the capabilities of a well-known application server. As a convenience, much of the security configuration is performed during the installation of a system.","Regarding authentication, when the application server security is enabled, authentication of system components is supported by a basic authentication challenge mechanism, i.e., user identification and password against an LDAP service. The application server supports various LDAP products. To enable authentication, global security for the entire application server installation must be enabled. Global security can be enabled either though an administration console or through scripts executed from the command line using a configuration utility. When launching the administration console with global security enabled, a user will be prompted for the user identification and password designated when installing the application server. When using an LDAP service to provide authentication, there are several site-specific parameters that need to be configured by an administrator including:\n\n","The configuration of these parameters can be done from the administration console.","Regarding authorization, the J2EE\u2122 specification allows the application developer and the application assembler to define role-based access on a method-by-method basis for EJBs and servlets. Since these are logical roles, there is some vendor-specific way to map the logical role into the principals and groups in the deployment environment. The system administrator is responsible for mapping the logical roles into groups and principals in the target environment. Some systems deviate from the J2EE\u2122 specification when it comes to defining access control or authorization of servlets and EJBs. Role based authorization is enabled by creating an enterprise application that includes all web resources to be protected. Once the web resources have been added to the enterprise application, each method of a resource can be associated with a method group. Each method group is then given a set of principals (groups, roles, or principals) that have the authority to execute the associated methods. In addition, some systems do not directly allow for programmatic authorization. An embodiment of the present invention provides a mechanism for mapping logical roles to LDAP groups via a configuration file in the root system install directory. Each entry in this configuration file maps a system logical role to LDAP groups. For example, to map the system logical role \u201cmktg\u201d to an LDAP group called \u201cMarketing\u201d, the entry would be \u201crole.mktg=cn=Marketing\u201d. A user must configure the entries in this file to match the LDAP configuration. Once completed, the \u201cedit security\u201d context tool will present the system logical roles.","Regarding delegation, at a minimum, the J2EE\u2122 specification says that the client's identity used to connect to the EJB server should be delegated to other EJBs in the same EJB server environment. Some servers allow method requests to be delegated as the client, a system identity, or some other specific identity. The system delegates client credentials across method calls.","Although the present invention has been described in detail with reference to certain preferred embodiments, it should be apparent that modifications and adaptations to those embodiments might occur to persons skilled in the art without departing from the spirit and scope of the present invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":["These and other features, aspects and advantages of the present invention will become better understood with regard to the following description, appended claims, and accompanying drawings wherein:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
