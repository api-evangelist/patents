---
title: Parameter buffer objects for shader parameters in a graphics library
abstract: One embodiment of the invention is a method for accessing and updating data in a buffer object during the execution of a shader program. The method includes loading a plurality of data portions in the buffer object, initiating a first execution of a shader program that accesses a first portion of data in the buffer object, receiving a request to update the first portion of data in the buffer object; updating a version of the first portion of data in the buffer object to reflect the update, initiating a second execution of a shader program that accesses the updated version of the first portion of data in the buffer object, wherein the second execution of the shader program occurs without waiting for the execution of the first shader program to complete.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07839410&OS=07839410&RS=07839410
owner: NVIDIA Corporation
number: 07839410
owner_city: Santa Clara
owner_country: US
publication_date: 20061212
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","Architectural Overview","Parameter Buffer Objects and In-Band Updates","Bindable Uniforms"],"p":["This application claims priority to the U.S. Provisional Application titled, \u201cAPI Extensions for Advanced Graphics Processing Units,\u201d filed on Jul. 28, 2006 and having U.S. patent application No. 60\/833,978.","1. Field of the Invention","Embodiments of the present invention generally relate to computer programming techniques for graphics processing systems. More specifically, embodiments of the invention relate to parameter buffer objects used to store shader program parameters.","2. Description of the Related Art","Over the past decade, the cost of adding on-chip logic to processors has substantially decreased. Consequently, certain types of processors, such as advanced graphics processing units (GPUs), now include functionality not previously available in earlier GPU designs. For example, a GPU may include multiple texture image units used to store references to texture maps used in graphics rendering operations. One benefit of this new capability is that more efficient texture mapping operations and the like may now be performed on the GPU, thereby increasing overall performance in the graphics pipeline.","To fully realize the additional processing capabilities of advanced GPUs, as much GPU functionality as possible needs to be exposed to graphics application developers. Among other things, doing so enables graphics application developers to tailor their shader programs to optimize the way GPUs process graphics scenes and images. Exposing new GPU processing capabilities to graphics application developers requires that the application programming interface (API) be configured with new calls and libraries that make new features and functionalities directly accessible by developers.","Programmable shader programs executing on a GPU repeatedly perform operations accessing attributes of individual inputs (vertices or fragments) and may also access a set of values that are constant over a set of inputs. Such constants are often referred to as \u201cuniforms\u201d or \u201cprogram parameters.\u201d For example, a vertex shader may perform lighting calculations where the position, direction, and intensity of each light source are stored as uniforms and read by the vertex shader. The use of uniforms in a programmable shader allow an application to access a relatively large amount of data describing a given scene without transmitting all the data for each vertex or fragment processed.","When rendering an image, an application may use a variety of shader programs, each performing a different operation. Although each shader program may be configured to perform a specific function, two or more shader programs may rely upon the same constant data. For example, two or more shader programs may perform lighting operations that use the same data (e.g., lighting information). However, current graphics APIs provide very limited ability to share uniforms among multiple shader programs, and may even require that the same uniform data be duplicated for each shader program. Additionally, a single shader program may operate using different sets of uniforms. For example, different portions of a scene may be illuminated by different lights. Using current APIs, combining all uniforms used over the scene into one large collection may run into implementation-dependent limits on the amount of uniform storage. Dynamic updates to a small set of uniform values can reduce uniform storage requirements, but can incur substantial CPU and GPU overhead. Additionally, updates may require a pause in the highly pipelined GPU to wait for threads using the old values of the uniforms to complete before the update can be performed.","Since the computational power of the GPU relative to the CPU has increased dramatically over the years, applications have progressively moved more computation onto the GPU. For example, applications may perform physics simulations (e.g., computing the position of a set of particles) on the GPU, by executing a shader program on one or more of the processing units of the GPU. The results of those simulations may be used in a variety of ways, including as uniform values for subsequent computations. To perform the next sequential processing pass, however, it is often necessary to transmit the results back to the CPU and through the API so that the data can be sent to the appropriate processing unit of the GPU. This process of moving uniform datasets between the CPU and the GPU can result in a substantial performance penalty.","As the foregoing illustrates, what is needed in the art is a mechanism that provides greater efficiency and flexibility for using bindable uniforms and parameter buffer objects relative to current techniques.","One embodiment of the present invention sets forth a method for updating data in a buffer object during the execution of a shader program. The method includes the steps of loading a plurality of data portions in the buffer object, initiating a first execution of a shader program that accesses a first portion of data in the buffer object, receiving a request to update the first portion of data in the buffer object; updating a version of the first portion of data in the buffer object to reflect the update, initiating a second execution of a shader program that accesses the updated version of the first portion of data in the buffer object, where the second execution of the shader program occurs without waiting for the execution of the first shader program to complete.","One advantage of the disclosed method is that using buffer objects as parameter buffer objects enables a number of graphics rendering operations to be performed without requiring intervention by a CPU, thereby increasing the performance of the graphics rendering hardware. Additionally, a graphics API may be used to update data values stored in a buffer object during rendering operations without having to wait until all active shader programs using one version of data in the buffer object have completely executed before the data values stored in the buffer object may be updated, further increasing GPU performance.","Embodiments of the invention allow developers of graphics applications to efficiently and effectively use buffer objects in the local memory of a GPU as the storage space for a bindable uniform variable declared in a shader program or as a parameter buffer object storing one or more parameters used by a shader program. Buffer objects provide a region of memory (i.e., buffers) accessible through an identifier. Buffer objects allow a GPU driver to optimize an internal memory management scheme and choose the best type of memory\u2014such as cached\/uncached system memory or graphics memory\u2014in which to store a buffer object.","Generally, parameter buffer objects may be used by an assembly level shader program, and bindable uniforms may be used by shader programs developed in high-level shader languages, such as the OpenGL Shading Language (GLSL) or the Cg shading language. In either case, the use of buffer objects as parameter buffer objects or as the storage space for a bindable uniform allows a number of graphics rendering operations to be performed without requiring intervention by a CPU, thereby increasing the performance of the graphics rendering hardware.","In one embodiment, a uniform variable in a shader program may be declared as being \u201cbindable.\u201d As used herein, a \u201cbindable uniform\u201d or \u201cbindable uniform variable\u201d is a uniform variable declared in a shader program, where storage for the uniform is not allocated by a compiler\/linker, but instead comes from a buffer object specified by the shader program. Bindable uniforms are a programming construct provided by a high level shader program, such as one composed using the GLSL or Cg shader programming languages. An API call may be used to bind the bindable uniform variable to a particular buffer object. By binding different buffer objects to a bindable uniform, an application may easily switch between different uniform data sets, without having to re-specify the data every time having to pass the data from the CPU to a GPU driver as part of the switch. Further, the same buffer object can be bound to bindable uniforms used by different shader programs. For example, if two shader programs each declare a bindable uniform of the same data type, then accessing a bindable uniform in program object A results in the same data if the same access is made in program object B. Thus, bindable uniforms advantageously allow data sets that may be shared among multiple program objects and shader programs, without storing multiple copies of the data set or requiring multiple updates if the data set is changed.","In one embodiment, a parameter buffer object provides a type of program parameter than can be used as a constant during the execution of vertex, fragment, or geometry shader programs. A graphics hardware device may include a set of parameter buffer binding points to which buffer objects can be attached. This allows a vertex, fragment, or geometry program to read data from an attached buffer objects using a binding like the form \u201cprogram.buffer[a][b]\u201d. This binding reads data from the buffer object attached to binding point <a>. The attached buffer object is treated as an array of 32-bit words or four-component vectors consisting of 32-bit words, and the binding reads the word or vector numbered <b>. The use of buffer objects to store shader program parameters allows applications to change large blocks of shader program parameters at once, simply by binding a new buffer object to a given binding point. A parameter buffer object is a programming construct for shader programs composed using an assembly level programming language such as an assembly harder language or microcode.","Parameter values (i.e., the data values in a parameter buffer object) may be loaded into the buffer object using a variety of mechanisms provided by a graphics API, including, for example, reading back from the frame buffer, transmitting the values through a transform feedback path, or implementing buffer object loading functions used to map data supplied by a graphics application into the buffer object. A transform feedback path may provide and use feedback and record transformed vertices processed by units within a graphics rendering pipeline. Examples of transform feedback are described in the commonly owned U.S. patent application Ser. No. 11\/609,763 titled, \u201cFeedback and Record of Transformed Vertices in a Graphics Library,\u201d filed on Dec. 12, 2006.","The graphics API may include calls specifically provided to load and\/or update data in a parameter buffer object. Thus, parameter buffer objects may provide a great deal of flexibility not available from other assembly language parameter mechanisms. Additionally, in one embodiment, a graphics API may be used to update data values stored in a buffer object during rendering operations without having to wait until all active shader programs using one version of data in the buffer object to complete executing before the data values stored in the buffer object may be updated, thereby increasing GPU utilization.","One embodiment of the invention includes a computer-readable medium that includes program instructions that when executed by a processor cause the processor to update data in a buffer object during the execution of a shader program. The steps may include loading the buffer object with a plurality of data portions, initiating a first execution of a shader program that accesses a first portion of data in the buffer object, and receiving a request to update the first portion of data in the buffer object. The steps may further include updating a version of the first portion of data in the buffer object to reflect the update and initiating a second execution of a shader program that accesses the updated version of the first portion of data in the buffer object. The second execution of the shader program occurs without waiting for the execution of the first shader program to complete.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 1A","b":["100","100","110","115","104","102","102","120","126","125","120","130","110","115","115","120","104","110","120","110","120","104","120","100"]},"GPU  includes at least one rendering engine  that incorporates at least one graphics rendering pipeline . System memory  includes an application program , a GPU driver  and an application program interface (API) . Generally, GPU driver  implements the functions and data structures exposed by API  for a given GPU . The application program  generates calls to the API  in order to produce a desired set of results, typically in the form of a sequence of graphics images.","In one programming model, the application program  transmits one or more high-level shader programs  to the API  for processing within GPU driver  by complier\/linker . The high-level shader programs  are typically source code text of high-level shader language instructions that are designed to operate on one or more processing units within the GPU . In turn, the compiler\/linker  may be configured to compile and link the source code of high-level shader programs . In one embodiment, compiler\/linker  is configured to provide cross-domain linking capabilities. More specifically, compiler\/linker  may be configured to translate high-level shader programs  designated for different domains into distinct compiled software objects. Compiler\/linker  also \u201clinks\u201d the compiled code to generate a single compiled\/linked program object.","The compiled\/linked program object generated by compiler\/linker  may be in the form of assembly code, which would be directed to a GPU microcode assembler , which may generate three software objects of domain-specific microcode for GPU  to execute. Alternately, compiler\/linker  may generate GPU microcode directly. The vertex shader microcode is derived from a vertex shader program, the geometry shader microcode is derived from a geometry shader program, and the fragment shader microcode is derived from a fragment shader program. Additional examples of cross domain compiling and linking of shader programs are described in the commonly owned U.S. patent application Ser. No. 11\/565,566 titled, \u201cMethods and Systems for Processing a Geometry Shader Program Developed in a High-Level Shading Language,\u201d filed on Nov. 30, 2006.","In another programming model, the application may transmit assembly level shader programs for execution on GPU . In addition to the high level shader language discussed above, OpenGL also provides an interface for developing shader programs using an assembly level interface to graphics hardware device . The source code text of an assembly level shader language program may include assembly level commands used to control the operations of the processing units within the graphics rendering pipeline . Further, GPU microcode assembler  may be configured to generate software objects of domain-specific microcode from the assembly level commands for execution on the vertex, geometry, and fragment processing units, as the case may be, of graphics rendering pipeline . In such a scenario, the application  may bypass the compiler\/linker  and provide the assembly level shader language programs directly to microcode assembler . Alternatively, the GPU driver  may not include the compiler\/linker .","Local memory  stores, among other things, a frame buffer , a parameter buffer object , a bindable uniform buffer object , and a memory page pool . Data output from the graphics rendering pipeline  may be stored in frame buffer . When graphics rendering pipeline  completes rendering a display frame, the contents of frame buffer  may be output to display device . Typically, display device  is a CRT or LCD display. However, the output of rendering operations may not be used for immediate display, such as when graphics rendering pipeline  is used to generate frames for an animation sequence or rendered visual effect.","Parameter buffer object  stores the constant data used by the different shader programs running on the processing units of graphics rendering pipeline . Uniform variable buffer object  stores data used by bindable uniform variables declared in shader programs . Hardware binding tables  are used to manage which buffer objects are bound to which parameter buffer object, and which buffer objects are used to provide memory storage for a given bindable uniform variable. As shown, hardware binding tables  includes vertex shader bindings , geometry shader bindings  and fragment shader bindings . In one embodiment, hardware binding tables  are used to map a reference to a parameter buffer object in a shader program to an actual buffer object in local memory . Changing the buffer object bound to one of the binding points for a given processing unit allows an application to bind and unbind large groups of shader program parameters at once and also to specify the buffer object used to load parameters into when using calls provided by a graphics API.","As described in greater detail herein, memory page pool  stores a set of memory pages used to manage multiple versions of a given buffer object, whether the buffer object is used as a parameter buffer object  or as a bindable uniform buffer object . Memory page pool , in conjunction with buffer object version table , allows different versions of a given buffer object to be used concurrently by different shader programs running on the processing units of graphics rendering pipeline .",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 1B","FIG. 1B"],"b":["126","122","135","150","129","129","132","150","5","2","129","129","155","116","117","6","129","2","132","3","129","5","132"],"sub":["1 ","2","1 ","2","1","2"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 2","b":["135","129","131","116","119","120","135","260","266","270","272","210","135","260","266","270","272","135","127"]},"Between vertex processing unit , geometry processing unit  and fragment processing unit  are primitive assembly unit  and primitive assembly and rasterizer unit . The primitive assembly unit  is typically a fixed-function unit that receives processed vertex data from vertex processing unit  and constructs graphics primitives, e.g., points, lines, triangles, or the like, for processing by geometry processing unit . Primitive assembly and rasterizer unit , which is optional in various implementations, may receive the graphics primitives output by geometry processing unit , such as a set of triangles, perform clipping operations to limit the triangles passed to fragment processing unit  to ones that are viewable on display device , and generate fragments for each pixel covered by the primitive. During rendering operations, the processing units of graphics rendering pipeline  may access data from a parameter buffer object  and\/or bindable uniform buffer object , represented in  by an arrow .","The processing performed by vertex processing unit , geometry processing unit , and fragment processing unit  may be defined by shader programs , which may include some combination of a vertex shader program , a geometry shader program , and a fragment shader program . In one embodiment, under the first programming model, these shader programs may be written using a high-level shading language, such as the Cg or GLSL shading languages, and transmitted to API  for processing within GPU driver . Again, the shader programs are then compiled and linked by a compiler\/linker  included with GPU driver  to produce a linked version of the shader programs. In one embodiment, the output of compiler\/linker  may include linked program object . The linked program object  may include multiple shader programs as well as a buffer object binding table  used to manage the bindings between a given shader program and the binding points of hardware binding table .","The code generated by the compiler\/linker  may be in the form assembly code, in which case it is then converted into machine code (also referred to as \u201cmicrocode\u201d) by microcode assembler . Alternately, the compiler\/linker may directly generate machine code, in which case the GPU driver  may not include a microcode assembler . The machine code versions of the shader programs are then transmitted to the vertex processing unit , the geometry processing unit  and the fragment processing unit , as the case may be, for execution. In alternative embodiments, under the second programming model the vertex shader program , the geometry shader program  and the fragment shader program  may be written in assembly code or may be compiled into assembly code externally to GPU driver . In such embodiments, GPU driver  would not necessarily include compiler\/linker , and GPU driver  would receive assembly code versions of the shader programs directly. Assembler  would then convert the assembly code into machine code and transmit the machine code versions of the shader programs to the appropriate processing units of the graphics rendering pipeline , as set forth above.","API  may include calls used to write data generated by one of the processing units of the graphics rendering pipeline  into buffer objects  and\/or . API  may also include calls used to modify the data in buffer objects  and\/or . For example, buffer objects  and\/or  may be loaded or modified using a transform feedback pathway, which captures selected transformed attributes of vertices processed by vertex processing unit  or geometry processing unit ","Additionally, a linked program object  may contain a buffer object bindings table . As described in greater detail in conjunction with , buffer object binding table  is used to store the active bindings for the bindable uniforms in program object . Further, API  may provide calls allowing application  to write data to buffer objects  and\/or . For example, API  may provide an API call that allows a developer to map the buffer object  to a pointer used by application , allowing application  to write to buffer objects  and\/or  directly. In one embodiment, an in-band update mechanism, described below in conjunction with , is used to manage updates to buffer objects  and\/or  made using API calls provided by a graphics library.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 3","b":["118","135","129","129"]},"As shown, the execution of vertex, geometry, and fragment shader programs flows from left to right, and an in-band update occurs to a parameter buffer object  at time t. A vertex shader program  executes a first time using version  of parameter buffer object  (segment ). A geometry shader program  and a fragment shader program  also execute using version  of parameter buffer object  (segments  and ). After the update to parameter buffer object , a second execution of vertex shader program  runs at a second time using version  of parameter buffer object  (segment ). Similarly, geometry shader program  and fragment shader program  also execute using version  of parameter buffer object  (segments  and ). The vertex processing unit , geometry processing unit , and fragment processing unit  are logically arranged in a serial pipeline, and vertex, fragment, and geometry shader programs (e.g., programs , , and ) may execute on the respective processing units of graphics rendering pipeline, concurrently. Thus, as can be seen in , vertex shader program  executes using version  (segment ), while concurrently, geometry shader program  executes using version  (segment ) of parameter buffer object . To support this parallel execution, when a shader program is executed on one of the processing units of graphics rendering pipeline , the shader program may be configured to use a version of parameter buffer object specified in buffer object version table .",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 4A","b":["140","129","128","129","129","140","129","0","128","0","7","140","125","0","129","140","125","129","129","102"],"sub":["0","0","0"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 4B","b":["140","129","128","129","140","1","129","129","1","0","2","7","129","0","1","129","256","512","1","1","129","1","128","1","1","140","0","128"],"sub":["0 ","0 "]},"Buffer object version table  allows multiple shader programs to reference either versions  or version  of buffer object , as appropriate. For example, referring to the timing diagram of , segment  represents an instance of vertex shader program  executing using version  of buffer object . Simultaneously, segment  represents an instance of geometry shader  executing using version  of buffer object . Thus, the in-band update mechanism of the present invention increases the parallel execution capabilities of graphics rendering pipeline . Otherwise, the shader programs represented by segments , ,  would first complete executing before the buffer object  was updated and segment  began executing. In one embodiment, to allow other uses of the buffer object  after the update, the GPU will write the updated version of page , stored in page  of the page pool , back to buffer object  after all vertex, geometry, and fragment shader programs using version  have completed executing. Additionally, as shown, buffer object version table  allows up to three entries of buffer object  to be active at any given time. Of course, the number of concurrent versions may be dependent on the size of buffer object version table , and may be tailored as needed for a particular graphics hardware device.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 5","FIGS. 1-4"],"b":["500","500","500","500","119","116"]},"The method  begins at step , where application invokes a call provided by API  to bind one or more buffer objects  to binding points in the binding tables . In one embodiment, the API may include calls with the following signatures:\n\n","In step , application  invokes a call provided by API  to modify data in a parameter buffer object. In one embodiment, the API may provide calls with the following signatures:\n\n","At step , the memory pages of the buffer object affected by the update may be copied to a memory page pool and modified as specified by the API call received at step . Thereafter, at steps  and , memory addresses for the modified version of the buffer object are stored in the next available version in buffer object version table. At step , addresses for the memory pages of the current version of the buffer object are propagated to the next version of the buffer object. At step , addresses for the pages modified by the update are set to the addresses of the corresponding pages in the page pool. After steps  and , the modified version includes a collection of addresses to pages in the original buffer object, and modified pages in the page pool. At the same time, the previous version of the buffer object includes a complete set of references that describe the buffer object before the modification. Thus, any active shader programs may still access the previous version, and any new instances of a shader program may access the modified version.","At step , once all the active shader programs using a previous version of the buffer object complete executing, the modified pages in the page pool may be copied to the buffer object, overwriting the corresponding unmodified pages, to produce a modified version of the buffer object. Using the example of , once all active shader programs using version  of parameter buffer object  complete executing, the data in page  of the page pool  may be written to page  of buffer object , overwriting original page  and freeing up space in page pool  to store subsequently modified pages. At the same time, the entry for page , version  in buffer object version table  may be updated to store the address of page  of buffer object .",{"@attributes":{"id":"p-0055","num":"0060"},"figref":["FIG. 6","FIGS. 1 and 2"],"b":["214","226","126","131","214","602","604","606","602","604","606"]},"In one embodiment, when program object  is complied and linked by compiler\/linker , the bindable uniforms declared in shader programs ,  and  are set to an unbound state. Thereafter, API calls may be used to bind the \u201ccolor,\u201d \u201csize,\u201d and \u201cposition\u201d bindable uniforms to the storage space of a buffer object. A buffer object has to first be bound to the bindable uniform before being accessed by a shader program, or before an API call may be used to set the data values of the bindable uniform. Buffer object binding table  is used to store the active bindings for the bindable uniforms in program object . That is, buffer object binding table  stores a reference to a binding point  in hardware bindings table  which may be used to store the address of a buffer object for a particular bindable uniform. Illustratively, the bindable uniform named \u201cposition\u201d included in vertex shader program  is bound to binding point  in vertex shader binding table . Similarly, the bindable uniform named \u201ccolor\u201d included in geometry shader program  and fragment shader  is bound to binding point  in both geometry shader binding table  and fragment shader binding table . Lastly, the bindable uniform named \u201csize\u201d included in geometry shader program  and fragment shader program  is bound to binding point  in geometry shader binding table  and binding point  in fragment shader binding table .","Binding points  in hardware bindings table  map to the bindable uniform buffer objects ,  and  in local memory . For the vertex shader bindings , binding point  maps to bindable uniform buffer object . That is, to buffer object storage for the \u201cposition\u201d bindable uniform. For the geometry shader bindings , binding point  maps to bindable uniform buffer object  and binding point  maps to bindable uniform buffer object . That is, to buffer object storage for the \u201ccolor\u201d and \u201csize\u201d bindable uniforms, respectively. And for the fragment shader program , binding point  maps to bindable uniform buffer object  and binding point  maps to bindable uniform buffer object . That is, to buffer object storage for the \u201ccolor\u201d and \u201csize\u201d bindable uniforms, respectively.",{"@attributes":{"id":"p-0058","num":"0063"},"figref":["FIG. 7","FIGS. 1"],"b":["700","700","2","5","500","500","119","116"]},"The method  begins at step , where a linked program object that includes bindable uniforms is transmitted for execution to one of the processing units of GPU . As stated, when a shader program in a program object is complied and linked, any bindable uniforms declared in that shader programs, are set to an unbound state. Thereafter, calls included in API  may be used to bind a buffer object to a bindable uniform variable referenced by the linked shader program.","At step , an API call may be used to determine the location of a specific bindable uniform variable. For example, the OpenGL API includes a call with the following signature:\n\n","At step , an API call may be used to determine the size of a buffer object required for the bindable uniform variable specified at step . For example, the OpenGL API may be extended to include a call with a signature like the following:\n\n","At step , API calls may be used to allocate storage for a buffer object from local memory and to populate the buffer object with data supplied by application . For example, the OpenGL API includes a call with the following signature:\n\n","This call may be used to initialize the data store for a buffer object with data specified by the <data> parameter. Additionally, as described above, other API calls may be used to write to a buffer object.","At step , an API call may be used to bind the buffer object specified in step  to the bindable uniform variable identified in step . For example, the OpenGL API may be extended to include a call with a signature like the following:\n\n","In one embodiment, a buffer object may be bound to, at most, one uniform variable in a given program object. However, a buffer object may be bound to bindable uniform variables in multiple program objects. Furthermore, if those bindable uniforms are all of the same type, then accessing a scalar, vector, a member of a structure, or an element of an array in program object A results in the same data being accessed in program object B.","At step , an API call may be used to update the values of the bindable uniform. The bindable uniform may be updated using one of the well-known API commands used to update the contents of a buffer object. Additionally, well-known API commands may be used to directly update the values of the bindable uniforms used by the active program object. For example, the OpenGL API call with a signature:\n\n","Advantageously, by allowing uniform variables to be bound to storage provided by a buffer object, the API, in effect, allows a mechanism for sharing data sets among multiple program objects and shader programs. Further, the use of buffer objects as parameter buffer objects or as the storage space for a bindable uniform allows a number of graphics rendering operations to be performed without requiring intervention by a CPU, thereby increasing the performance of the graphics rendering hardware. Additionally, a graphics API may be used to update data values stored in a buffer object during rendering operations without having to wait until all active shader programs using one version of data in the buffer object have completely executed before the data values stored in the buffer object may be updated, further increasing GPU performance.","While the foregoing is directed to embodiments of the present invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof, and the scope thereof is determined by the claims that follow."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the present invention can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to embodiments, some of which are illustrated in the appended drawings. Note, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 4A-4B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7","b":"700"}]},"DETDESC":[{},{}]}
