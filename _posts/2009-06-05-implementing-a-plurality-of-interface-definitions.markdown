---
title: Implementing a plurality of interface definitions
abstract: A system and method are provided for implementing a plurality of interface definitions. The system and method provide for a message to be received according to a first definition, sent to a component for processing according to a second definition and returned to the requester according to the first interface definition. The system and method strip information from the return message that is not contained in the first interface definition.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09356805&OS=09356805&RS=09356805
owner: INTERNATIONAL BUSINESS MACHINES CORPORATION
number: 09356805
owner_city: Armonk
owner_country: US
publication_date: 20090605
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND","BRIEF SUMMARY","DETAILED DESCRIPTION"],"p":["The present application claims priority of U.S. provisional patent application No. 61\/059,495, filed Jun. 6, 2008 and entitled \u201cSupport for Multiple Interface Definitions,\u201d the contents of which are incorporated herein by reference in their entirety.","The Service Oriented Architecture (SOA) is a software architecture for implementing web applications. When using the SOA, an application is composed of a set of agents that communicate with each other using a defined set of Application Programming Interfaces (APIs) which may be described using a standard interface definition language (IDL), such as WSDL (Web Service Description Language) or some other language.","An agent that implements an interface is known as a provider or producer agent and an agent that uses an interface is known as a requester or consumer agent. An agent may be both a provider agent and requester agent.","Agents are loosely coupled together. The communication between agents occurs using the defined APIs. Two provider agents may be considered interchangeable if they implement the same set of APIs. Two requester agents may be considered interchangeable if they use the same set of APIs. An agent that is both a provider agent and requester agent may be considered interchangeable if they implement the same set of APIs and use the same set of APIs. An agent may be replaced with an interchangeable agent without requiring changes to other agents in the SOA application.","Developers of an SOA application, that may include both requester and producer agents, may develop the agents separately. The developers may update or modify the producer and requester agents independently, as long as they share a common interface. For example, a developer may update a requester agent by adding a better user interface for displaying information received from the producer agent. This new version of the requester agent can communicate with the producer agent using the same common interface as was used by the old requester agent. Likewise, the developers may update the producer agent, for example, to generate information in a more efficient manner. So long as the new version of the producer agent implements the common interface used by the previous version of the producer agent, the requester agents will be able to communicate with the new producer agent.","Although agents are loosely coupled to other agents, they are tightly coupled to the interfaces. Agents are tightly coupled to the interfaces that they use or implement, since changing an interface requires changing both the producer agent and requestor agent that implement or use the interface. The tight coupling of agents to the interfaces causes a problem for developing new SOA applications or components that may benefit from a different interface. In order to implement and use a new interface definition, both new requester agents and producer agents are required. It may be difficult to distribute all of the new components to update the old versions at the same time. This can result in an old requester agent trying to communicate with a new producer agent, or new requester agents trying to communicate with old producer agents, which will not work since they do not share a common interface.","Attempts to address this limitation have included isolating the core logic of the producer or requester agent from the interface implementation. This allows for different interfaces to be implemented using specific adaptors that compensate for differences between the interface and the core logic APIs. For example, a producer agent could be created with a new version of the core logic and an adaptor for implementing an older interface. The adaptor would be hard-coded and specific to both the new core version and the interface definition it is implementing. Another producer agent may also be created using the same core version but with a different adaptor that implements a new interface definition, for example, for supporting new features in the core version. An old requester agent can connect to the producer agent that includes the adaptor implementing the older interface. A new requester agent could connect to the producer agent that includes the adaptor implementing the new interface.","The use of adaptors for implementing an interface and adapting it to core logic provides flexibility in defining the interface, as well as the core logic, since both the interface and the core logic may change independently. However, whenever a new interface or new version of core logic is developed, a new adaptor needs to be created. Each adaptor is specific to a particular interface definition, and converts received messages into requests that can be handled by the specific core logic, as well as converting messages from the core logic into messages that conform to the particular interface definition. As the core logic evolves, this solution requires that new adaptors be created for bridging the new core logic with the different agent interfaces. This can result in having to develop numerous adaptors to support different versions of interfaces, which may be difficult as the adapter requires specific knowledge of the functions of the new core logic. Each adaptor bridges messages from one version of an interface definition to the new core logic.","Another attempt to address this limitation requires maintaining multiple cores in a single component. Each core implements a particular version of the interface. This allows for the interface definition of the agent to change significantly over time since the older interface definition remains implemented by the core. However, this causes the agent to continually increase in size and complexity, making it more difficult to maintain the agent.","A further solution to the limitation is to force the responsibility of compatibility onto system administrators. This requires systems administrators to ensure that all components in the system use the correct version. While this solution simplifies the design and authoring of the agents, it is a difficult solution for system administrators, especially as the size of the system and number of agents increase.","It is desirable to have a mechanism to provide at least some flexibility to modify interfaces or core logic of agents, while remaining simple to maintain compatibility between versions.","In accordance with an embodiment of the present disclosure there is provided a method of implementing a plurality of interface definitions. The method comprises receiving a message at a version filter of a server, the version filter implementing a first interface definition and the received message conforming to the first interface definition; passing the message to a producer component implementing a second interface definition, the second interface definition constrained to be a superset of the first interface definition; receiving a return message from the producer component at the version filter, said return message conforming to the second interface definition; stripping information from the return message to generate a response message conforming to the first interface definition; and sending the response message in response to the received message.","In accordance with a further embodiment of the present disclosure there is provided a system implementing a plurality of interface definitions, the system comprises a processor executing instructions; and a memory, operatively coupled to the processor, storing instructions. The instructions when executed by the processor providing a version filter receiving a message and implementing a first interface definition, the received message conforming to the first interface definition, the version filter stripping information from a return message to generate a response message conforming to the first interface definition; and a producer component implementing a second interface definition, the second interface definition constrained to be a superset of the first interface definition, the producer component receiving the message from the version filter and generating the return message conforming to the second interface definition.","In accordance with a still further embodiment of the present disclosure, there is provided a computer program product implementing a plurality of interface definitions. The computer program product comprises a computer usable medium having computer usable program code embodied therewith. The computer usable program code comprises computer usable program code configured to receive a message at a version filter of a server, the version filter implementing a first interface definition and the received message conforming to the first interface definition; computer usable program code configured to pass the message to a producer component implementing a second interface definition, the second interface definition constrained to be a superset of the first interface definition; computer usable program code configured to receive a return message from the producer component at the version filter, said return message conforming to the second interface definition; computer usable program code configured to strip information from the return message to generate a response message conforming to the first interface definition; and computer usable program code configured to send the response message in response to the received message.","Illustrative embodiments of the present disclosure are described with reference to producer agents and requester agents. Although the description refers to these agents as distinct components, it is understood that an agent can act as both a producer and requester agent at the same time. For example, it is possible for a producer agent to produce information (to be consumed by a requester agent) by consuming information it requested from a different producer agent. In such a situation, the producer agent may implement an interface for sending and receiving information to a requester agent, and use another interface for communicating with the other agent. For the sake of clarity, the requester agent and producer agent are described as separate agents, and implement only a single interface definition.","An interface definition describes a contract between agents. The interface definition describes a format and semantics for the communication between the two agents. If both agents share a common interface definition, the agents can communicate with each other by sending messages that conform to the common interface definition. An interface definition describes an Application Programming Interface (API). An agent can communicate with an agent that implements an API by sending messages formatted according to the API. For example, the following listing describes a simple interface definition for a producer agent that receives an employee number and returns an employee name associated with the employee number.","Example Interface Definition:","Method name: getEmployee\n\n","Type name: employeeInformation\n\n","A producer agent that implements the interface definition will be able to receive a message containing an integer (the employeeNumber) and return a message containing data of the type employeeInformation, which has a string (the employeeInformation.Name) and an associated integer (the employeeInformation.ID). A requester agent that uses the interface definition may send a message containing an integer (the employee number) and receive in response a message containing data of the type employeeInformation (the employee name and employee ID). The interface definition provides a common language that the agents can use to communicate with each other. The interface definition describes the format of messages, and possibly the format of complex types used in the message.","The above listing of the example interface definition is not described in any particular interface definition language (IDL). It is understood that the interface could be described in a more formal IDL, such as a Web Service Description Language (WSDL).","The following listing lists an implementation of the example interface definition in pseudo code for both a provider agent and a requester agent. It is understood that the listing is only for highlighting the implementation of the interface in the producer agent and requester agent.",{"@attributes":{"id":"p-0034","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"providerAgent:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"employeeInformation {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Name : String"]},{"entry":[{},"ID : Integer"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"employeeInformation getEmployee(employeeNumber : Integer) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"employeeInfo : employeeInformation"]},{"entry":[{},"employeeInfo = infoOfEmployeeNumber(employeeNumber)"]},{"entry":[{},"return employeeInfo"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"requesterAgent:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"employeeInformation {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Name : String"]},{"entry":[{},"ID : Integer"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"displayEmployee(num : Integer){"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"employee : employeeInformation"]},{"entry":[{},"employee = providerAgent.getEmployee(num)"]},{"entry":[{},"display(employee.Name)"]},{"entry":[{},"display(employee.ID)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The implementation of the illustrative requester agent sends a message to the provider agent, using the common interface, requesting the employee information associated with an employee ID number. The provider agent receives the message, retrieves the information, for example from a database, and sends a response back to the requester agent. The requester agent receives the response and may, for example, display the results.","Referring to  there is shown illustrative components of an SOA application . The SOA application  comprises two co-operating agents , . A requester agent  may send and receive messages  to and from a producer agent . The requester agent  may comprise a requester component . The requester component  may include business logic  and interface logic  for using an interface implemented by another agent. The business logic  and the interface logic  do not need to be separate as depicted in . The business logic  is used by the requester agent  to consume information in a desired way. For example, the business logic  may display received information, it may process the received information and generate new requests to other agents, it may produce a response to a different agent based on the information, etc. The requester agent  may comprise further components in addition to the requester component, such as additional requester components for communicating with different agents. The interface definition  describes a required format of messages for sending and receiving information to and from the producer agent . The interface logic  uses the interface definition  to send and receive information to and from the producer agent  using messages . The format of the messages  conform to the interface definition .","In order for the requester agent  to have information to consume, the producer agent  may send information. The producer agent  is similar to the requester agent ; however, it includes a producer component  instead of a requester component . The producer component  may receive, process, and send information to and from the requester agent  in messages . The producer component  includes business logic  for producing the information. For example, the business logic may generate the information internally, it may request the information from external sources, such as, for example, databases, it may produce the information based on information it has received from a different producer agent, etc. In addition to the business logic , the producer component  also includes interface logic  for implementing the interface definition, referred to as an interface implementation  that implements the same interface definition  used by the requester agent . Although the requester agent  and the producer agent  both implement the same interface definition, the implementations are different as each implements one side of the communication interface. In addition to the producer component , the producer agent may include further components, such as, further producer components for communicating with additional requester agents.","In the above pseudo code listing of the requester component of an agent, the business logic  of the requester component  may be considered the pseudo code for receiving a request to display an employee's name associated with an employee number (i.e., \u201cdisplayEmployee(num: Integer)\u201d) and the pseudo code for displaying the employee name (i.e., \u201cdisplay(employee.Name)\u201d and \u201cdisplay(employee.ID)\u201d). The interface logic , for using the interface definition, may be considered the pseudo code for sending the employee ID number to the producer component of a producer agent  and receiving the employee information in response (i.e., \u201cemployee=providerAgent.getEmployee(num)\u201d). Similarly, the business logic  of the producer component  may be considered the pseudo code for determining the employee name associated with the employee ID number (i.e., \u201cemployeeInfo=infoOfEmployeeNumber(employeeNumber)\u201d). The interface logic for implementing the interface definition, that is the interface implementation , may be considered the pseudo code for receiving the employee number (i.e., \u201cemployeeInformation getEmployee(employeeNumber:Integer)\u201d) and the pseudo code for returning the employee information in response (i.e., \u201creturn employeeInfo\u201d).","Referring to , there is shown an SOA application . The SOA application  comprises a producer agent  and two requester agents , . The producer agent  and requester agents ,  may be implemented using computer hardware including a processor for executing instructions stored in memory. The components of the SOA application  may be provided by executing instructions stored in the memory. The requester agent  comprises a requester component  that uses an old version of the interface , described by the interface definition . The requester agent  comprises a requester component  that uses a new version of the interface , described by interface definition . The producer agent  is similar to the producer agent , however, the producer agent  has two interface implementations ,, from which messages for the producer component  may be received. Each interface implementation ,  implements the interface described by the separate interface definitions ,. For the purposes of this description, it is assumed that interface definition  is an earlier version (the old version) of interface definition  (the new version). For example, the old version of the interface definition  may be the example interface described above for returning an employee's information associated with an employee ID number. The new version of the interface definition  may include the getEmployee method; however, it may be modified to return, in addition to the employee name and ID number, the department the employee works in. A new version of the example interface definition is shown in the following listing.","Example Interface Definition V2:","Method name: getEmployee\n\n","Type name: employeeInformation\n\n","The old requester agent  can send and receive information, using the interface logic  of the requester component , to the producer agent , which implements the interface  used by the old requester agent . The producer agent  may pass the received messages to the producer component . The messages sent between the old requester agent  and the producer agent  conform to the old interface definition .","The new requester agent  can send and receive information, using the interface logic  of the requester component , to the producer component , of the producer agent , which implements the interface  used by the requester agent . The messages sent between the requester agent  and the producer agent  conform to the new interface definition .","Referring to , there is shown components for supporting multiple versions of an interface in a producer agent. The producer agent  includes a new producer component  that implements  the new version of the interface definition . The new producer component  does not implement the old interface definition . This may help to simplify the creation and maintenance of the new interface definition , and corresponding implementation  by the producer component .","The new requester agent  can communicate directly with the new producer component  of the producer agent  using the interface implementation  of the new interface definition . Messages sent using the interface  conform to the new interface definition . The old requester agent  includes a requester component  that uses the old interface . The old requester agent  does not communicate directly with the new producer component  since they do not implement the same interface. Support for the old requester agent  is achieved without requiring the new producer component  to implement the old interface definition . A version filter  has been added to the producer agent , and can send and receive messages to and from the new producer component . The messages passed between the version filter  and the new producer component  conform to the interface description . The version filter  implements  the old interface definition , and so can communicate directly with the old requester agent . The version filter  passes messages it receives from the old requester agent  to the new producer component  of the producer agent . The version filter  also passes messages from the new producer component  to the old requester agent ; however, the version filter  first strips any information in the message conforming to the new interface definition  that is not found in the old interface definition . By passing messages received from the old requester agent  to the new producer component , and by filtering new information from messages sent from the new producer component  to the old requester agent , the version filter  provides support for multiple versions of requester agents , to communicate with the new version of the producer component . The use of the version filter  provides flexibility in creating new interfaces since a version filter can be used to maintain support for the older requester agents .","In a broad sense, the version filter  acts as a bridge between message formats, receiving messages of one format and transforming them to another format. However, to overcome the difficulty of writing a new filter for transforming messages from each old version to the new version of the interface definition, an evolution constraint  is introduced. The evolution constraint  is a rule or collection of rules that describes how the old version of the interface definition  can be modified to create the new version of the interface definition . Broadly, the evolution constraint  requires that the new interface definition  be a superset of the old interface definition . This allows messages received from the old requester agent  to be passed directly to the new producer component  using the version filter , and messages to be sent from the new producer component  to the old requester agent  to be passed through the version filter  which filters out any information in the response message that is not defined in the old interface definition .","The evolution constraint  may be more specific. It can specify that the definition of messages sent from the old requester agent  to the new producer component  cannot change, and that the definition of messages that are sent from the new producer component  to the old requester agent  can only be added to, that is, the messages include all of the information of the old interface definition  and may include additional information. The added information in the response message may be removed from response messages sent to the old requester agent  by the version filter  which creates a response message that conforms to the old interface definition . This results in the new producer component  being able to process messages sent from the old requester agent  and provide responses according to the new interface definition , which are stripped of additional information and returned to the old requester agent  in a response message that conforms to the old interface definition. As such, the old requester agent  passes the messages to the version filter , which may pass the message directly to the new producer agent without processing the message. The filter may be designed to add or remove information to the request message; however, the evolution constraint may need to be more complex, for example, defining a default value for new information to be added to the request message, so that the message conforms to the new interface definition implemented by the new producer component . The new producer component  receives the message that conforms to a request message defined by the new interface definition , processes it, and returns a message conforming to the new interface definition to the version filter . The version filter  receives the message and filters out the new information not supported by the old requester agent  and sends the message to the old requester agent . Due to the loose coupling of components in an SOA application, an old producer agent can be replaced with the version filter  without requiring any changes be made to the old requester agent  since both the old producer agent and the version filter  implement the same interface. This can greatly simplify the upgrading, maintenance, and support of SOA applications.","The illustrative new interface definition listed above is a properly constrained evolution of the previous illustrative interface definition. The definition of messages received from requesters has not changed, namely getEmployee still sends an Integer. As such, the old and new versions can communicate this information. However, the response to the message has changed. The employeeInformation type has been augmented to include the additional information for the employee's Department. However, it conforms to the evolution constraint . The version filter  transforms the new version of the message to the old version by stripping the Department information of the employee from the new version of the message.","The version filter  has been described as passing messages received from old requester agent  to the new producer component  without processing them. If, however, the evolution constraint allows the request messages of the new interface definition to have new information, the version filter may process the received messages prior to sending them to the new producer agent. This processing may include, for example, adding default values to the received messages for the new information required by the new interface definition. Similarly, the request message could be processed to strip information from the message not used by the new interface. The evolution constraint may need to specify the default values to be added to request messages if they are allowed to include new information.","Referring to , there is shown the communication between components of the SOA application. The producer agent  comprises a version filter  and a new producer component , as described above with reference to . The SOA application  comprises an old requester agent  and a new requester agent , as described above with reference to  and . For the sake of clarity, the communication between the new producer component  and the old requester agent  and the communication between the new producer component  and the new requester agent  are described as occurring separately. It is understood that the processing of messages may be interleaved, or multiple agents may be supported to process multiple messages concurrently.","The requester component  of the old requester agent  sends a message conforming to the old interface definition (). The old requester agent  sends the message to the location that the old producer component was previously found and which the old requester agent  is configured to use. The old producer component has been replaced at the producer agent  with the version filter , and so, the message arrives at the version filter . The version filter  implements the same interface as the old producer component, and, as such, the old requester agent  does not need to know a change has been made. As a result of the evolution constraint, the new producer component  can process the old request message, and so the version filter  passes the request message on to the new producer component  () without processing it. The new producer component  processes the message to produce a response (). The response message to the request message is sent to the version filter  (). The response message conforms to the new interface definition  and includes additional information not described in the old interface definition . The version filter  processes the received response message (). The processing strips the additional information from the received response message to create a stripped response message conforming to the old interface definition . The version filter  sends the stripped response message conforming to the old interface definition  to the old requester agent  (). The old requester agent  receives the stripped response message and consumes the information (), for example, displaying the information.","The requester component  of the new requester agent  implements the new version of the interface definition , and, as such, can communicate directly with the new producer component . The new requester component  sends a request message to the new producer component  (). The request message conforms to the new interface definition . The new producer component  receives the request message and processes it (). The new producer component  sends a response message back to the requester component  of the new requester agent  (). The new requester agent  receives the message conforming to the new interface definition  and processes it (), for example, displaying the information.","The new requester agent  is able to communicate directly with the new producer component , since both share the same common version of the interface description. In order to communicate with the producer component , the new requester agent requires information about where the new producer component  is located. This information can be included in the interface definition. For example, if the interface definition is described using WSDL, the \u201cservices\u201d section of the WSDL can be included, which describes a Universal Resource Identifier (URI) defining the location of the new producer component . Requester agents may be configured to send request messages to the specified URI.","From the above description, it is clear that if the interface definition changes in accordance with an evolution constraint, support for multiple versions of the interface can be provided efficiently through a version filter. Furthermore, by implementing the version filter  external to the new producer component , only communication between the old requester agent  has to pass through the version filter . Any new requester agents can communicate directly with the new producer component . The new producer component  does not differentiate from the messages received and processed from new requester agents and old requester agents through the version filter . It is possible to remove the version filter  at any time, without disturbing the operations of the new requester agents or the new producer components. For example, support for old, previous versions of an interface can be removed after a sufficient amount of time has passed to allow all requester agents to be upgraded to a newer version by simply removing the version filter .","Referring to , there is shown an illustrative embodiment of a producer agent in accordance with the present disclosure. The producer agent  comprises a servlet  and a servlet filter . The servlet  and the servlet filter of the producer agent  integrate with the facilities provided by a servlet container . The servlet container  provides a framework for servlets to operate in. A producer agent, such as producer agent , may be implemented as a servlet and servlet filter configured and operating within a servlet container. A servlet  can be registered to be run by the servlet container . The registration of a servlet  may include specifying an address or URI that messages are sent to for processing by the servlet. Servlet filter , can be registered with the servlet container  in a similar manner. The servlet filter  may be registered to process messages sent to the URI previously registered to the old producer component.","The servlet container may provide functionality to the servlet and servlet filter that, for example, handles the message passing between senders and the servlet and servlet filter. The servlet filters may be chained together, with each servlet filter in the chain processing the message prior to being processed by the servlet. The servlet container maintains these filter chains as well as the passing of messages between servlet filters of the chain, as the servlet filters typically have no knowledge about other servlet filters.","The servlet filter  implements  the old interface definition. The servlet container  receives the messages destined for an address or URI and passes them on to the servlet , or the servlet filter  registered for processing messages sent to that URI. A message from a servlet filter can be passed onto another servlet filter. A message from a servlet filter may also be passed to a servlet. The passing of messages between servlet filters and servlet may by provided by the functionality of the servlet container .","The servlet container  depicted in  may be implemented using various technologies, such as an Apache Tomcat container. The servlet container  provides the framework for the servlet  and servlet filter . The servlet  is registered with the servlet container , and associated with a location or URI  that messages are received at. The servlet  provides the interface implementation  of the new interface definition . The servlet container  also provides the framework for the servlet filter . The servlet filter  is registered with the servlet container , and associated with a location or URI . The location  may be the same location that the old version of the producer component implemented in the servlet  was associated with. This allows old requester agents to communicate with the servlet filter  which processes the message before being passed to the new servlet  without requiring any changes to the old requester agent. The servlet filter  provides the interface implementation  of the old interface definition  used by the old requester agent.","When a message arrives at the new location  (), the servlet container  passes the message to the servlet  () associated with the address through the servlet registration. The servlet agent  receives the message and processes it () as described above. The response message is returned to the servlet container () and sent to the new requester agent that sent the request message ().","When a message arrives at the old location  (), the servlet container  passes the message to the servlet filter  (). Assuming the evolution constraint of the interface definitions allow the input messages to remain the same, the servlet filter  passes the message to the servlet  () without processing it. The message may be passed from the servlet filter  to the servlet agent  though the servlet container . The servlet agent  processes the message () and prepares a response message. The response message, which conforms to the new version of the interface definition  is sent to the servlet filter  () through the servlet container , which processes the message (). The processing of the message may include stripping additional information not present in the old version of the interface definition . The stripped message is returned to the servlet container () and returned to the old requester agent that sent the request message ().","Referring to , there is shown components of an illustrative version filter  in accordance with an embodiment the present disclosure. The version filter  comprises a message transformer  that sends and receives messages that conform to the old interface definition . The version filter  described is intended to process XML messages, such as, those sent in SOAP messages over HTTP. It is understood that the XML messages do not need to be sent in a SOAP message over HTTP. For example, the XML message could be sent as part of a Multipurpose Internet Mail Extension (MIME) message. In such a case, pre-processing of the MIME message may be required to identify the XML message. The XML message component of the MIME message may be extracted and processed by the version filter. The response message may be inserted into the MIME message and returned.","When the messages are expressed in XML, the filter can use an XSL\/T engine  and a generated XSL\/T document  to transform the messages from one version to another. The message transformer  may then pass received messages to the XSL\/T engine  which processes them to transform them into a message conforming to the appropriate version of the interface definition. The message transformer  then passes the transformed message to the appropriate location, for example, the old requester agent . As described above, messages received from the old requester can be passed directly to the new producer agent, while messages received from the new producer agent are processed by the XSL\/T engine  to produce the stripped message, which is then sent to the old requester agent . The message transformer  may pass request messages to the XSL\/T engine for processing if needed, for example, to add default values to the message. Although the message transformer  may add a default value to a message, it may be more appropriate or efficient to implement the servlet agent or the producer component  to add the default values to the messages.",{"@attributes":{"id":"p-0064","num":"0072"},"figref":"FIG. 7","b":["702","704","706","708","710"]},{"@attributes":{"id":"p-0065","num":"0073"},"figref":["FIG. 7","FIG. 7","FIG. 7","FIG. 7"],"b":["704","704","702","702","706","706","708","710","710"],"i":["b","b","b","b"]},"Although depicts the chaining of multiple version filters together, this approach will add to the processing cost since each filter needs to parse, process, and serialize the response. It would be more efficient to have separate version filters to translate messages from the newest interface definition used by the provider agent to some older interface definition used by one or more requester agents.","The processing of the response message by version filters can use the XSL\/T engine to strip any information present in the new interface definition out of the message that is not present in the old interface definition . The processing results in a stripped message as the response which may be returned from the XSL\/T engine to the message transformer , which passes the message onto the requester agent . To produce a different version filter, it is only necessary to provide a different XSL\/T document  that describes how to transform messages from one version to the other version.","If the messages are expressed in XML, the version filter  may transform the message using the message transformer , the XSL\/T engine  and the generated XSL\/T document  as described above. The message transformer  and XSL\/T engine  may be re-used in different version filters , for example, for transforming a second older version of the interface definition to the new version of the interface definition, or, alternatively, to an intermediary version of the interface. All that is required is a different XSL\/T document  be generated that describes how to process the messages.","By enforcing the evolution constraint on new versions of interface definitions, it ensures that messages formatted according to the new interface definition can be processed using the XSL\/T engine  and generated XSL\/T document  and transformed into the message formatted according to the old interface definition.",{"@attributes":{"id":"p-0070","num":"0078"},"figref":"FIG. 8","b":["800","800","802","812","801","802","812"]},"The processor  of computer  is operationally coupled to a memory  that stores data and instructions for execution by the processor . The memory  stores instructions for providing the computer  with the functionality of a requester agent as described herein, depicted as requester block  in . The processor  may also be operationally coupled to one or more input\/output (I\/O) devices . The processor  may be coupled to either the memory  and\/or the I\/O device  by one or more computer buses.","Similarly, the processor  of computer  is operationally coupled to a memory  that stores data and instructions for execution by the processor . The memory  stores instructions for providing the computer  with the functionality of a provider agent as described herein, depicted as provider block  in . The processor  may also be operationally coupled to one or more input\/output (I\/O) devices . The processor  may be coupled to either the memory  and\/or the I\/O device  by one or more computer buses.","The processors ,  may be a central processing unit (CPU), a microprocessor, an application specific integrated circuit (ASIC), a field programmable gate array (FPGA) or other type of processor capable of executing instructions. The processor may include the hardware and controlling code such as firmware or basic input\/output system (BIOS) used to configure the processors ,  and other components of the computers , . The processors ,  may be implemented in one or more physical packages. Each package may include one or more processor cores for executing instructions. Furthermore, the functionality of the computers ,  may be distributed across multiple computers. In addition to the requester  and provider  instructions stored in the memories , , there may also be instructions for an operating system (OS) for the computers , .","The memories ,  may include different levels of memory, including both volatile and non-volatile memory for storage of information. The memories ,  may include, for example, registers for storing instructions to be executed by the processors , , flash memory, electrically erasable programmable read only memory (EEPROM), random access memory (RAM), hard disk drives (HDD), solid state drives (SSDs), or other types of devices for storing information. The memories ,  may store the instructions to be executed by the processor to provide the system and method described herein. The instructions may be stored in different levels of the memory at the same time. For example, an instruction may be copied from a HDD to RAM to a register of the processors ,  prior to being executed by the processors , . The results of processing the instruction or instructions may be stored in memories , . Storing the instructions of the system and method described herein in the memories ,  alters one or more physical characteristics of the memories, such as the electrical characteristics of one or more cells of the memories , .","The I\/O devices ,  may include input and output devices. Input devices may include devices for inputting information to the computers , , for example, mice, keyboards, keys, switches, cameras, scanners, microphones, touch panels or screens, or other input devices as known by one of ordinary skill in the art. The output devices may display or convey information and may include, for example, monitors, televisions, Braille devices, lights, printers, speakers, actuators and other output devices as known by one of ordinary skill in the art. The I\/O devices ,  may also include network devices for connecting the computer to a network  and communicating with other computers or devices.","The computer buses may include one or more buses for connecting the memories ,  and I\/O devices , with the processors ,, or each other. The buses may be internal or external buses and may include the physical connectors required to connect components to the buses. Different buses are known, and may include, for example, peripheral component interconnect (PCI), PCI express (PCIe), industry standard architecture (ISA), advanced technology attachment (ATA), serial ATA (SATA), small computer system interface (SCSI), universal serial bus (USB), IEEE 1394 (FireWire\u2122). The buses may also include buses for controlling the computer such as a front side bus (FSB), address bus, or control bus.","As will be appreciated by one skilled in the art, the present invention may be embodied as a system, method or computer program product. Accordingly, the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201ccircuit,\u201d \u201cmodule\u201d or \u201csystem.\u201d Furthermore, the present invention may take the form of a computer program product embodied in any tangible medium of expression having computer usable program code embodied in the medium.","Any combination of one or more computer usable or computer readable medium(s) may be utilized. The computer-usable or computer-readable medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, device, or propagation medium. More specific examples (a non-exhaustive list) of the computer-readable medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CDROM), an optical storage device, a transmission media such as those supporting the Internet or an intranet, or a magnetic storage device. Note that the computer-usable or computer-readable medium could even be paper or another suitable medium upon which the program is printed, as the program can be electronically captured, via, for instance, optical scanning of the paper or other medium, then compiled, interpreted, or otherwise processed in a suitable manner, if necessary, and then stored in a computer memory. In the context of this document, a computer-usable or computer-readable medium may be any medium that can contain, store, communicate, propagate, or transport the program for use by or in connection with the instruction execution system, apparatus, or device. The computer-usable medium may include a propagated data signal with the computer-usable program code embodied therewith, either in baseband or as part of a carrier wave. The computer usable program code may be transmitted using any appropriate medium, including but not limited to wireless, wire line, optical fiber cable, RF, etc.","Computer program code for carrying out operations of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the \u201cC\u201d programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).","The present invention has been described below with reference to flowchart illustrations and\/or block diagrams of methods, systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and\/or block diagrams, and combinations of blocks in the flowchart illustrations and\/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","These computer program instructions may also be stored in a computer-readable medium that can direct a computer or other programmable data processing apparatus to function in a particular manner, such that the instructions stored in the computer-readable medium produce an article of manufacture including instruction means which implement the function\/act specified in the flowchart and\/or block diagram block or blocks.","The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","The flowchart and block diagrams in the Figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical functionality. It should also be noted that, in some alternative implementations, the functionality noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and\/or flowchart illustration, and combinations of blocks in the block diagrams and\/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functionality or acts, or combinations of special purpose hardware and computer instructions."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":["Embodiments of the invention will be described with reference to the drawings in which:",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
