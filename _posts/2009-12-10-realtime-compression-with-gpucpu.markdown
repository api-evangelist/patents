---
title: Real-time compression with GPU/CPU
abstract: Example embodiments of the present disclosure provide techniques for efficiently processing and transmitting graphics data when sub-regions of the screen represented by the graphics data are updated at different relative update rates. In an embodiment, when the screen is divided into tiles and a plurality of the tiles have been determined as being changed, some of the sublevels resulting from the image transform may not be encoded and transmitted. The decoding process may use zeroes for any data not received. The rendering subsystem may render the image with the partial data, and the remaining data may be received in subsequent transmissions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09075560&OS=09075560&RS=09075560
owner: MICROSOFT TECHNOLOGY LICENSING, LLC
number: 09075560
owner_city: Redmond
owner_country: US
publication_date: 20091210
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Equation 2","Forward Dwt Filter Coefficient","Equation 3","Inverse Dwt Filter Coefficients"],"p":["Remote computing systems can enable users to remotely access hosted resources. Servers on the remote computing systems can execute programs and transmit signals indicative of a user interface to clients that can connect by sending signals over a network conforming to a communication protocol such as the TCP\/IP protocol. Each connecting client may be provided a remote presentation session, i.e., an execution environment that includes a set of resources. Each client can transmit signals indicative of user input to the server and the server can apply the user input to the appropriate session. The clients may use remote presentation protocols such as the Remote Desktop Protocol (RDP) to connect to a server resource.","In the remote desktop environment, data representing graphics to be transmitted to the client are typically compressed by the server, transmitted from the server to the client through a network, and decompressed by the client and displayed on the local user display. Various schemes may be used to minimize the size of the graphics data that needs to be transmitted. One such scheme may include dividing the graphics data into tiles and sending only the tiles that have changed since a previous transmission. However, the changed tiles still need to be encoded and transmitted, typically requiring significant network bandwidth and a significant number of processor computation cycles to compress and decompress the tiles. Such processing requirements may have a direct effect on the data transmission\/decoding latency from the server to the client and negatively impact the remote user's experience.","Thus, additional techniques are needed in the art to solve the above described problems.","One problem with scalable encoding is the scenario where the changed areas of a screen are not fully aligned on a tile when the tiles are a predetermined size. For example, a tile may comprise both video and text portions or sub-regions. Treating the entire tile as a slow changing text portion may result in the system being unable to provide updates fast enough to keep up with the faster changing video portion. Treating the entire tile as fast changing may result in the text portion being rendered with a lesser quality image. When an algorithm for scalable encoding is performed, the higher fidelity image may appear to be fuzzy because only the high frequency components may be sent as a result of the video being repeatedly updated.","In various embodiments, methods and systems are disclosed for efficiently processing and transmitting graphics data when sub-regions of the screen represented by the graphics data are updated at different relative update rates. In an embodiment, when the screen is divided into tiles and a plurality of the tiles have been determined as being changed, it may not be necessary to perform processing\/encoding for all of the image data. For example, if discrete wavelet transformation is used, then some of the sublevels resulting from the discrete wavelet transform may not be encoded and transmitted. The decoding process may use zeroes for any data not received. The rendering subsystem may render the image with the partial data, and the remaining data may be received in subsequent transmissions. After the remaining data have been decoded and rendered, the image may be completely rendered. Accordingly, a lower latency can be achieved while producing a full image by avoiding performing compression when the image is rapidly changing.","In an embodiment, the GPU may be used as an offload engine to assist in the compression processing tasks. For example, the GPU may be used as a coprocessor to assist in the compression process. The concurrent processing of data on the GPU and CPU may provide for lower latency in the end-to-end process.","In addition to the foregoing, other aspects are described in the claims, drawings, and text forming a part of the present disclosure. It can be appreciated by one of skill in the art that one or more various aspects of the disclosure may include but are not limited to circuitry and\/or programming for effecting the herein-referenced aspects of the present disclosure; the circuitry and\/or programming can be virtually any combination of hardware, software, and\/or firmware configured to effect the herein-referenced aspects depending upon the design choices of the system designer.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter. Furthermore, the claimed subject matter is not limited to implementations that solve any or all disadvantages noted in any part of this disclosure.","Computing Environments in General Terms","Certain specific details are set forth in the following description and figures to provide a thorough understanding of various embodiments of the disclosure. Certain well-known details often associated with computing and software technology are not set forth in the following disclosure to avoid unnecessarily obscuring the various embodiments of the disclosure. Further, those of ordinary skill in the relevant art will understand that they can practice other embodiments of the disclosure without one or more of the details described below. Finally, while various methods are described with reference to steps and sequences in the following disclosure, the description as such is for providing a clear implementation of embodiments of the disclosure, and the steps and sequences of steps should not be taken as required to practice this disclosure.","It should be understood that the various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the disclosure, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the disclosure. In the case of program code execution on programmable computers, the computing device generally includes a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may implement or utilize the processes described in connection with the disclosure, e.g., through the use of an application programming interface (API), reusable controls, or the like. Such programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","A remote desktop system is a computer system that maintains applications that can be remotely executed by client computer systems. Input is entered at a client computer system and transferred over a network (e.g., using protocols based on the International Telecommunications Union (ITU) T.120 family of protocols such as Remote Desktop Protocol (RDP)) to an application on a terminal server. The application processes the input as if the input were entered at the terminal server. The application generates output in response to the received input and the output is transferred over the network to the client","Embodiments may execute on one or more computers.  and the following discussion are intended to provide a brief general description of a suitable computing environment in which the disclosure may be implemented. One skilled in the art can appreciate that computer systems ,  can have some or all of the components described with respect to computer  of .","The term circuitry used throughout the disclosure can include hardware components such as hardware interrupt controllers, hard drives, network adaptors, graphics processors, hardware based video\/audio codecs, and the firmware\/software used to operate such hardware. The term circuitry can also include microprocessors configured to perform function(s) by firmware or by switches set in a certain way or one or more logical processors, e.g., one or more cores of a multi-core general processing unit. The logical processor(s) in this example can be configured by software instructions embodying logic operable to perform function(s) that are loaded from memory, e.g., RAM, ROM, firmware, and\/or virtual memory. In example embodiments where circuitry includes a combination of hardware and software an implementer may write source code embodying logic that is subsequently compiled into machine readable code that can be executed by a logical processor. Since one skilled in the art can appreciate that the state of the art has evolved to a point where there is little difference between hardware, software, or a combination of hardware\/software, the selection of hardware versus software to effectuate functions is merely a design choice. Thus, since one of skill in the art can appreciate that a software process can be transformed into an equivalent hardware structure, and a hardware structure can itself be transformed into an equivalent software process, the selection of a hardware implementation versus a software implementation is trivial and left to an implementer.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1","b":["20","21","22","23","21","23","24","25","26","20","24","20","27","28","29","30","31","24","25","29","31","21","27","28","30","23","32","33","34","20","29","31"]},"A number of program modules may be stored on the hard disk, magnetic disk , optical disk , ROM  or RAM , including an operating system , one or more application programs , other program modules  and program data . A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite disk, scanner or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or universal serial bus (USB). A display  or other type of display device can also be connected to the system bus  via an interface, such as a video adapter . In addition to the display , computers typically include other peripheral output devices (not shown), such as speakers and printers. The system of  also includes a host adapter , Small Computer System Interface (SCSI) bus , and an external storage device  connected to the SCSI bus .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be another computer, a server, a router, a network PC, a peer device or other common network node, a virtual machine, and typically can include many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  can include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  can be connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  can typically include a modem  or other means for establishing communications over the wide area network , such as the Internet. The modem , which may be internal or external, can be connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are examples and other means of establishing a communications link between the computers may be used. Moreover, while it is envisioned that numerous embodiments of the disclosure are particularly well-suited for computer systems, nothing in this document is intended to limit the disclosure to such embodiments.","Referring now to , another embodiment of an exemplary computing system  is depicted. Computer system  can include a logical processor , e.g., an execution core. While one logical processor  is illustrated, in other embodiments computer system  may have multiple logical processors, e.g., multiple execution cores per processor substrate and\/or multiple processor substrates that could each have multiple execution cores. As shown by the figure, various computer readable storage media  can be interconnected by one or more system busses which couples various system components to the logical processor . The system buses may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. In example embodiments the computer readable storage media  can include for example, random access memory (RAM) , storage device , e.g., electromechanical hard drive, solid state hard drive, etc., firmware , e.g., FLASH RAM or ROM, and removable storage devices  such as, for example, CD-ROMs, floppy disks, DVDs, FLASH drives, external storage devices, etc. It should be appreciated by those skilled in the art that other types of computer readable storage media can be used such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges.","The computer readable storage media provide non volatile storage of processor executable instructions , data structures, program modules and other data for the computer . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within the computer system , such as during start up, can be stored in firmware . A number of programs may be stored on firmware , storage device , RAM , and\/or removable storage devices , and executed by logical processor  including an operating system and\/or application programs.","Commands and information may be received by computer  through input devices  which can include, but are not limited to, a keyboard and pointing device. Other input devices may include a microphone, joystick, game pad, scanner or the like. These and other input devices are often connected to the logical processor  through a serial port interface that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or universal serial bus (USB). A display or other type of display device can also be connected to the system bus via an interface, such as a video adapter which can be part of, or connected to, a graphics processor . In addition to the display, computers typically include other peripheral output devices (not shown), such as speakers and printers. The exemplary system of  can also include a host adapter, Small Computer System Interface (SCSI) bus, and an external storage device connected to the SCSI bus.","Computer system  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer. The remote computer may be another computer, a server, a router, a network PC, a peer device or other common network node, and typically can include many or all of the elements described above relative to computer system .","When used in a LAN or WAN networking environment, computer system  can be connected to the LAN or WAN through a network interface card . The NIC , which may be internal or external, can be connected to the system bus. In a networked environment, program modules depicted relative to the computer system , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections described here are exemplary and other means of establishing a communications link between the computers may be used. Moreover, while it is envisioned that numerous embodiments of the present disclosure are particularly well-suited for computerized systems, nothing in this document is intended to limit the disclosure to such embodiments.","A remote desktop system is a computer system that maintains applications that can be remotely executed by client computer systems. Input is entered at a client computer system and transferred over a network (e.g., using protocols based on the International Telecommunications Union (ITU) T.120 family of protocols such as Remote Desktop Protocol (RDP)) to an application on a terminal server. The application processes the input as if the input were entered at the terminal server. The application generates output in response to the received input and the output is transferred over the network to the client computer system. The client computer system presents the output data. Thus, input is received and output presented at the client computer system, while processing actually occurs at the terminal server. A session can include a shell and a user interface such as a desktop, the subsystems that track mouse movement within the desktop, the subsystems that translate a mouse click on an icon into commands that effectuate an instance of a program, etc. In another example embodiment the session can include an application. In this example while an application is rendered, a desktop environment may still be generated and hidden from the user. It should be understood that the foregoing discussion is exemplary and that the presently disclosed subject matter may be implemented in various client\/server environments and not limited to a particular terminal services product.","In most, if not all remote desktop environments, input data (entered at a client computer system) typically includes mouse and keyboard data representing commands to an application and output data (generated by an application at the terminal server) typically includes video data for display on a video output device. Many remote desktop environments also include functionality that extend to transfer other types of data.","Communications channels can be used to extend the RDP protocol by allowing plug-ins to transfer data over an RDP connection. Many such extensions exist. Features such as printer redirection, clipboard redirection, port redirection, etc., use communications channel technology. Thus, in addition to input and output data, there may be many communications channels that need to transfer data. Accordingly, there may be occasional requests to transfer output data and one or more channel requests to transfer other data contending for available network bandwidth.","Referring now to , depicted are high level block diagrams of computer systems configured to effectuate virtual machines. As shown in the figures, computer system  can include elements described in  and components operable to effectuate virtual machines. One such component is a hypervisor  that may also be referred to in the art as a virtual machine monitor. The hypervisor  in the depicted embodiment can be configured to control and arbitrate access to the hardware of computer system . Broadly stated, the hypervisor  can generate execution environments called partitions such as child partition 1 through child partition N (where N is an integer greater than or equal to 1). In embodiments a child partition can be considered the basic unit of isolation supported by the hypervisor , that is, each child partition can be mapped to a set of hardware resources, e.g., memory, devices, logical processor cycles, etc., that is under control of the hypervisor  and\/or the parent partition and hypervisor  can isolate one partition from accessing another partition's resources. In embodiments the hypervisor  can be a stand-alone software product, a part of an operating system, embedded within firmware of the motherboard, specialized integrated circuits, or a combination thereof.","In the above example, computer system  includes a parent partition  that can also be thought of as domain 0 in the open source community. Parent partition  can be configured to provide resources to guest operating systems executing in child partitions 1-N by using virtualization service providers  (VSPs) that are also known as back-end drivers in the open source community. In this example architecture the parent partition  can gate access to the underlying hardware. The VSPs  can be used to multiplex the interfaces to the hardware resources by way of virtualization service clients (VSCs) that are also known as front-end drivers in the open source community. Each child partition can include one or more virtual processors such as virtual processors  through  that guest operating systems  through  can manage and schedule threads to execute thereon. Generally, the virtual processors  through  are executable instructions and associated state information that provide a representation of a physical processor with a specific architecture. For example, one virtual machine may have a virtual processor having characteristics of an Intel x86 processor, whereas another virtual processor may have the characteristics of a PowerPC processor. The virtual processors in this example can be mapped to logical processors of the computer system such that the instructions that effectuate the virtual processors will be backed by logical processors. Thus, in these example embodiments, multiple virtual processors can be simultaneously executing while, for example, another logical processor is executing hypervisor instructions. Generally speaking, and as illustrated by the figures, the combination of virtual processors, various VSCs, and memory in a partition can be considered a virtual machine such as virtual machine  or .","Generally, guest operating systems  through  can include any operating system such as, for example, operating systems from Microsoft\u00ae, Apple\u00ae, the open source community, etc. The guest operating systems can include user\/kernel modes of operation and can have kernels that can include schedulers, memory managers, etc. A kernel mode can include an execution mode in a logical processor that grants access to at least privileged processor instructions. Each guest operating system  through  can have associated file systems that can have applications stored thereon such as terminal servers, e-commerce servers, email servers, etc., and the guest operating systems themselves. The guest operating systems - can schedule threads to execute on the virtual processors - and instances of such applications can be effectuated.","Referring now to , illustrated is an alternative architecture that can be used to effectuate virtual machines.  depicts similar components to those of , however in this example embodiment the hypervisor  can include the virtualization service providers  and device drivers , and parent partition  may contain configuration utilities . In this architecture, hypervisor  can perform the same or similar functions as the hypervisor  of . The hypervisor  of  can be a stand alone software product, a part of an operating system, embedded within firmware of the motherboard or a portion of hypervisor  can be effectuated by specialized integrated circuits. In this example parent partition  may have instructions that can be used to configure hypervisor  however hardware access requests may be handled by hypervisor  instead of being passed to parent partition .","Referring now to , computer  may include circuitry configured to provide remote desktop services to connecting clients. In an example embodiment, the depicted operating system  may execute directly on the hardware or a guest operating system  or  may be effectuated by a virtual machine such as VM  or VM . The underlying hardware , , , , and  is indicated in the illustrated type of dashed lines to identify that the hardware can be virtualized.","Remote services can be provided to at least one client such as client  (while one client is depicted remote services can be provided to more clients.) The example client  can include a computer terminal that is effectuated by hardware configured to direct user input to a remote server session and display user interface information generated by the session. In another embodiment, client  can be effectuated by a computer that includes similar elements as those of computer  . In this embodiment, client  can include circuitry configured to effect operating systems and circuitry configured to emulate the functionality of terminals, e.g., a remote desktop client application that can be executed by one or more logical processors . One skilled in the art can appreciate that the circuitry configured to effectuate the operating system can also include circuitry configured to emulate a terminal.","Each connecting client can have a session (such as session ) which allows the client to access data and applications stored on computer . Generally, applications and certain operating system components can be loaded into a region of memory assigned to a session. Thus, in certain instances some OS components can be spawned N times (where N represents the number of current sessions). These various OS components can request services from the operating system kernel  which can, for example, manage memory; facilitate disk reads\/writes; and configure threads from each session to execute on the logical processor . Some example subsystems that can be loaded into session space can include the subsystems that generates desktop environments, the subsystems that track mouse movement within the desktop, the subsystems that translate mouse clicks on icons into commands that effectuate an instance of a program, etc. The processes that effectuate these services, e.g., tracking mouse movement, are tagged with an identifier associated with the session and are loaded into a region of memory that is allocated to the session.","A session can be generated by a session manager , e.g., a process. For example, the session manager  can initialize and manage each remote session by generating a session identifier for a session space; assigning memory to the session space; and generating system environment variables and instances of subsystem processes in memory assigned to the session space. The session manager  can be invoked when a request for a remote desktop session is received by the operating system .","A connection request can first be handled by a transport stack , e.g., a remote desktop protocol (RDP) stack. The transport stack  instructions can configure logical processor  to listen for connection messages on a certain port and forward them to the session manager . When sessions are generated the transport stack  can instantiate a remote desktop protocol stack instance for each session. Stack instance  is an example stack instance that can be generated for session . Generally, each remote desktop protocol stack instance can be configured to route output to an associated client and route client input to an environment subsystem  for the appropriate remote session.","As shown by the figure, in an embodiment an application  (while one is shown others can also execute) can execute and generate an array of bits. The array can be processed by a graphics interface  which in turn can render bitmaps, e.g., arrays of pixel values, that can be stored in memory. As shown by the figure, a remote display subsystem  can be instantiated which can capture rendering calls and send the calls over the network to client  via the stack instance  for the session.","In addition to remoting graphics and audio, a plug and play redirector  can also be instantiated in order to remote diverse devices such as printers, mp3 players, client file systems, CD ROM drives, etc. The plug and play redirector  can receive information from a client side component which identifies the peripheral devices coupled to the client . The plug and play redirector  can then configure the operating system  to load redirecting device drivers for the peripheral devices of the client . The redirecting device drivers can receive calls from the operating system  to access the peripherals and send the calls over the network to the client .","As discussed above, clients may use a protocol for providing remote presentation services such as Remote Desktop Protocol (RDP) to connect to a resource using terminal services. When a remote desktop client connects to a terminal server via a terminal server gateway, the gateway may open a socket connection with the terminal server and redirect client traffic on the remote presentation port or a port dedicated to remote access services. The gateway may also perform certain gateway specific exchanges with the client using a terminal server gateway protocol transmitted over HTTPS.","Turning to , depicted is a computer system  including circuitry for effectuating remote services and for incorporating aspects of the present disclosure. As shown by the figure, in an embodiment a computer system  can include components similar to those described in  and , and can effectuate a remote presentation session. In an embodiment of the present disclosure a remote presentation session can include aspects of a console session, e.g., a session spawned for a user using the computer system, and a remote session. Similar to that described above, the session manager  can initialize and manage the remote presentation session by enabling\/disabling components in order to effectuate a remote presentation session.","One set of components that can be loaded in a remote presentation session are the console components that enable high fidelity remoting, namely, the components that take advantage of 3D graphics and 2D graphics rendered by 3D hardware.","3D\/2D graphics rendered by 3D hardware can be accessed using a driver model that includes a user mode driver , an API , a graphics kernel , and a kernel mode driver . An application  (or any other process such as a user interface that generates 3D graphics) can generate API constructs and send them to an application programming interface  (API) such as Direct3D from Microsoft\u00ae. The API  in turn can communicate with a user mode driver  which can generates primitives, e.g., the fundamental geometric shapes used in computer graphics represented as vertices and constants which are used as building blocks for other shapes, and stores them in buffers, e.g., pages of memory. In one embodiment the application  can declare how it is going to use the buffer, e.g., what type of data it is going to store in the buffer. An application, such as a videogame, may use a dynamic buffer to store primitives for an avatar and a static buffer for storing data that will not change often such as data that represents a building or a forest.","Continuing with the description of the driver model, the application can fill the buffers with primitives and issue execute commands. When the application issues an execute command the buffer can be appended to a run list by the kernel mode driver  and scheduled by the graphics kernel scheduler . Each graphics source, e.g., application or user interface, can have a context and its own run list. The graphics kernel  can be configured to schedule various contexts to execute on the graphics processing unit . The GPU scheduler  can be executed by logical processor  and the scheduler  can issue a command to the kernel mode driver  to render the contents of the buffer. The stack instance  can be configured to receive the command and send the contents of the buffer over the network to the client  where the buffer can be processed by the GPU of the client.","Illustrated now is an example of the operation of a virtualized GPU as used in conjunction with an application that calls for remote presentation services. Referring to , in an embodiment a virtual machine session can be generated by a computer . For example, a session manager  can be executed by a logical processor  and a remote session that includes certain remote components can be initialized. In this example the spawned session can include a kernel , a graphics kernel , a user mode display driver , and a kernel mode display driver . The user mode driver  can generate graphics primitives that can be stored in memory. For example, the API  can include interfaces that can be exposed to processes such as a user interface for the operating system  or an application . The process can send high level API commands such as such as Point Lists, Line Lists, Line Strips, Triangle Lists, Triangle Strips, or Triangle Fans, to the API . The API  can receive these commands and translate them into commands for the user mode driver  which can then generate vertices and store them in one or more buffers. The GPU scheduler  can run and determine to render the contents of the buffer. In this example the command to the graphics processing unit  of the server can be captured and the content of the buffer (primitives) can be sent to client  via network interface card . In an embodiment, an API can be exposed by the session manager  that components can interface with in order to determine whether a virtual GPU is available.","In an embodiment a virtual machine such as virtual machine  of  or  can be instantiated and the virtual machine can serve as a platform for execution for the operating system . Guest operating system  can embody operating system  in this example. A virtual machine may be instantiated when a connection request is received over the network. For example, the parent partition  may include an instance of the transport stack  and may be configured to receive connection requests. The parent partition  may initialize a virtual machine in response to a connection request along with a guest operating system including the capabilities to effectuate remote sessions. The connection request can then be passed to the transport stack  of the guest operating system . In this example each remote session may be instantiated on an operating system that is executed by its own virtual machine.","In one embodiment a virtual machine can be instantiated and a guest operating system  embodying operating system  can be executed. Similar to that described above, a virtual machine may be instantiated when a connection request is received over the network. Remote sessions may be generated by an operating system. The session manager  can be configured to determine that the request is for a session that supports 3D graphics rendering and the session manager  can load a console session. In addition to loading the console session the session manager  can load a stack instance \u2032 for the session and configure system to capture primitives generated by a user mode display driver .","The user mode driver  may generate graphics primitives that can be captured and stored in buffers accessible to the transport stack . A kernel mode driver  can append the buffers to a run list for the application and a GPU scheduler  can run and determine when to issue render commands for the buffers. When the scheduler  issues a render command the command can be captured by, for example, the kernel mode driver  and sent to the client  via the stack instance \u2032.","The GPU scheduler  may execute and determine to issue an instruction to render the content of the buffer. In this example the graphics primitives associated with the instruction to render can be sent to client  via network interface card .","In an embodiment, at least one kernel mode process can be executed by at least one logical processor  and the at least one logical processor  can synchronize rendering vertices stored in different buffers. For example, a graphics processing scheduler , which can operate similarly to an operating system scheduler, can schedule GPU operations. The GPU scheduler  can merge separate buffers of vertices into the correct execution order such that the graphics processing unit of the client  executes the commands in an order that allows them to be rendered correctly.","One or more threads of a process such as a videogame may map multiple buffers and each thread may issue a draw command. Identification information for the vertices, e.g., information generated per buffer, per vertex, or per batch of vertices in a buffer, can be sent to the GPU scheduler . The information may be stored in a table along with identification information associated with vertices from the same, or other processes and used to synchronize rendering of the various buffers.","An application such as a word processing program may execute and declare, for example, two buffers\u2014one for storing vertices for generating 3D menus and the other one storing commands for generating letters that will populate the menus. The application may map the buffer and; issue draw commands. The GPU scheduler  may determine the order for executing the two buffers such that the menus are rendered along with the letters in a way that it would be pleasing to look at. For example, other processes may issue draw commands at the same or a substantially similar time and if the vertices were not synchronized vertices from different threads of different processes could be rendered asynchronously on the client  thereby making the final image displayed seem chaotic or jumbled.","A bulk compressor  can be used to compress the graphics primitives prior to sending the stream of data to the client . In an embodiment the bulk compressor  can be a user mode (not shown) or kernel mode component of the stack instance  and can be configured to look for similar patterns within the stream of data that is being sent to the client . In this embodiment, since the bulk compressor  receives a stream of vertices, instead of receiving multiple API constructs, from multiple applications, the bulk compressor  has a larger data set of vertices to sift through in order to find opportunities to compress. That is, since the vertices for a plurality of processes are being remoted, instead of diverse API calls, there is a larger chance that the bulk compressor  will be able to find similar patterns in a given stream.","In an embodiment, the graphics processing unit  may be configured to use virtual addressing instead of physical addresses for memory. Thus, the pages of memory used as buffers can be paged to system RAM or to disk from video memory. The stack instance \u2032 can be configured to obtain the virtual addresses of the buffers and send the contents from the virtual addresses when a render command from the graphics kernel  is captured.","An operating system  may be configured, e.g., various subsystems and drivers can be loaded to capture primitives and send them to a remote computer such as client . Similar to that described above, a session manager  can be executed by a logical processor  and a session that includes certain remote components can be initialized. In this example the spawned session can include a kernel , a graphics kernel , a user mode display driver , and a kernel mode display driver .","A graphics kernel may schedule GPU operations. The GPU scheduler  can merge separate buffers of vertices into the correct execution order such that the graphics processing unit of the client  executes the commands in an order that allows them to be rendered correctly.","All of these variations for implementing the above mentioned partitions are just exemplary implementations, and nothing herein should be interpreted as limiting the disclosure to any particular virtualization aspect.","Real-Time Compression","In virtual desktop or remote presentation session, the user graphics and video are rendered at the server for each user. The resulting bitmaps may then be sent to the client for display and interaction. To reduce the bandwidth requirements on the network, bitmaps may be compressed before sending to the client. It is desirable that the compression technique be efficient with low latency.","One issue that may arise is providing efficient bandwidth usage when parts of the screen are updated often such as, for example, when playing back video or animation. Another issue is the tracking of areas of the screen that have different update speeds. It is desirable in such situations to support staged encoding and thus reduce the bandwidth usage. For example, video or animation playback may be embedded in a window that contains high resolution content surrounding the video (e.g., text). If staged encoding is performed on the part of the window that contains both contents, worse quality may result for the high quality image because the algorithm will treat both areas in the same manner even though the high quality part does not update as often as the video playback sub-portion.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 8","b":["800","805","820","825","835","820","815","835"]},"Described herein is a system and method for encoding and decoding electronic information, and may include an encoding system with a tiling module that initially divides source image data into data tiles. A frame differencing module may then output only altered data tiles to various processing modules that convert the altered data tiles into corresponding tile components. In an embodiment, a quantizer may perform a compression procedure upon the tile components to generate compressed data according to an adjustable quantization parameter. An adaptive entropy selector may then select one of a plurality of available entropy encoders to perform an entropy encoding procedure to thereby produce encoded data. The entropy encoder may also utilize a feedback loop to adjust the quantization parameter in light of current transmission bandwidth characteristics. The process of compressing, encoding and decoding graphics data as referred to herein may generally use one or more methods and systems described in commonly assigned U.S. Pat. No. 7,460,725 entitled \u201cSystem And Method For Effectively Encoding And Decoding Electronic Information\u201d and U.S. application Ser. No. 12\/399,302 entitled \u201cFrame Capture, Encoding, And Transmission Management\u201d filed on Mar. 6, 2009, hereby incorporated by reference in their entirety.","In various methods and systems disclosed herein, improvements to the processing and handling of the various processes described above may be used to provide more efficient processing and thus a more timely and rich user experience. The methods and systems also provide for improvements in providing such graphics support when the network and\/or system resources become congested or otherwise less available. The embodiments disclosed herein for rendering, encoding and transmitting graphics data may be implemented using various combinations of hardware and software processes. In some embodiments, functions may be executed entirely in hardware. In other embodiments, functions may be performed entirely in software. In yet further embodiments, functions may be implemented using a combination of hardware and software processes. Such processes may further be implemented using one or more CPUs and\/or one or more specialized processors such as a graphics processing unit (GPU) or other dedicated graphics rendering devices.","Referring to , illustrated is an overview of various functions associated with the rendering and encoding processes discussed herein. Various aspects of the illustrated process may be modified to improve the throughput and efficiency of the processes. Process  illustrates the capturing and buffering of a client frame. Process  illustrates that under certain circumstances it may be advantageous to drop a captured frame. The term dropping may include ignoring the captured data in favor of the next captured frame data, clearing the buffers of the captured data, and the like. Process  illustrates that the captured frame may be analyzed to determine if differences exist compared to the previously captured frame. Process  illustrates the process of encoding the changed tiles of a frame. Process  illustrates that under certain circumstances it may be advantageous to drop a frame that has been encoded and is ready to transmit. The term dropping may include ignoring the encoded data in favor of the next encoded frame, clearing the transmit buffers of the encoded data, and the like. Once transmitted, process  illustrates that the received tiles may be decoded. Process  illustrates that the receive buffers may be managed to track changed tiles. Process  illustrates that the display frame buffers may be used to drive the display controller in an efficient manner.","Various embodiments may incorporate the use of the discrete wavelet transform (DWT) function for transforming individual YUV components of the tiles into corresponding YUV the subbands. A quantizer function may perform a quantization procedure by utilizing appropriate quantization techniques to compress the tile subbands. The quantizer function may produce compressed image data by reducing the bit rate of the tiles according to a particular compression ratio that may be specified by an adaptive quantization parameter received via a feedback loop from an entropy encoder.","An entropy encoder function may perform an entropy encoding procedure to generate encoded data. In certain embodiments, the entropy encoding procedure further reduces the bit rate of the compressed image data by substituting appropriate codes for corresponding bit patterns in the compressed image data received from the quantizer.","In one embodiment, a GPU may be provided a bitmap with changed rectangles that need to be compressed. The bitmap may be further split into logical tiles and only tiles that change within the changed rectangle are encoded and compressed. In this manner, the process effectively implements a caching scheme in concert with the client where the resulting decoded image is maintained and displayed.","For more efficient usage of bandwidth for fast changing areas of the screen, in some embodiments the encoder may be staged so that only the image components that have the most perceivable effect on the resulting image are encoded and transmitted.","In discrete wavelet transformation, the image is typically filtered using high pass and low pass filters and the resulting image may comprise high-high, high-low, low-high, and low-low components. Such a process is depicted in . Each of these components may in turn be filtered to produce set of sub-bands. The process may carried out three times resulting in ten different sub-bands. In one embodiment, entropy encoding can be performed on a selected subset of sub-bands and only the encoded subbands are transmitted. For example, only the level III sub-bands may be transmitted. On the receiving side, the decoding process may use zeroes for any sub-bands not received. While the resulting image may be blurry initially, the remaining sub-bands may be received in subsequent data frames. After the remaining sub-bands have been decoded and rendered, then the image may be completely rendered. In a further embodiment, if the encoded tile is the same tile as in a previous transmission, then the system can encode and send the level II and level III components and skip sending the level I components. By using these techniques the system can only perform the entropy encoding on the most needed components and thus reduce latencies from the encoding process which can a time consuming operation.","In one embodiment, the encoding process may be stopped until the tile is fully updated. Encoding can be resumed only for the parts of the tile that are being updated. In such scenarios it may not be advantageous to update the entire tile. In another embodiment, a mechanism may be provided that tracks the state of the tile. Each tile may be updated fully or partially. In some cases the tile may be in the process of being fully updated but not completed. In this case the text portion of the tile may be fully rendered and then the sub-region with the video component may be rendered.","Various means can be used to determine which areas of a screen are changing. For example, the screen scraper function in Remote Desktop Protocol (RDP) may be used to provide information on which sub-region is changing. Whenever an area of the screen changes, RDP drivers my provide the coordinates of the area that is changing.","In one embodiment, a three part process may be used to track and process screen areas with different update rates. First, the portion of the screen that contains a mix of fast and slow updated images may be identified. Second, the image that is updated more frequently may be tracked as a sub-region of the mixed image tile. Third, the process may ensure that the higher quality image is correctly sent before applying the scaled down sub-region of the fast updated image.","To further reduce bandwidth and computation, components of a tile may be processed and sent in a staged manner, recreating the image in two stages to recreate the tile with full fidelity. Staged encoding may be used on fast changing area of a screen, specifically those that render video or animation for efficient bandwidth usage. Only tiles and sub-regions of the tiles that have changes may be transformed using a DWT and quantization.","In an embodiment, the input image may be a Direct3D texture surface in the XRGB8 format. Video driver calls on a virtual machine may be translated to API calls on the host or parent partition, and a set of APIs may be provided such as the Microsoft DirectX set of APIs for handling tasks related to multimedia, in particular Direct3D which is the 3D graphics API within DirectX. A shader program may be loaded which reads from the input XRGB8 texture and outputs three surfaces, one each for Y, U and V, using the multiple render target (MRT) feature. MRT refers to the ability to render to multiple surfaces with a single draw call. An exemplary matrix used for the conversion is shown in Equation 1.",{"@attributes":{"id":"p-0088","num":"0087"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mstyle":{"mspace":{"@attributes":{"width":"17.2em","height":"17.2ex"}}},"mo":"\u2062","mrow":{"mi":["Equation","RGB","to","YUV","Conversion","Matrix"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mn":"1"}}}},{"mtd":{"mrow":{"mrow":[{"mo":["[","]"],"mtable":{"mtr":{"mtd":[{"mi":"Y"},{"mi":"U"},{"mi":"V"}]}}},{"mrow":[{"mo":["[","]"],"mtable":{"mtr":{"mtd":[{"mi":"R"},{"mi":"G"},{"mi":"B"}]}}},{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"mrow":{"mn":"0.299","mo":"\u2062","mi":"f"}},{"mrow":{"mrow":{"mo":"-","mn":"0.168935"},"mo":"\u2062","mi":"f"}},{"mrow":{"mn":"0.499813","mo":"\u2062","mi":"f"}}]},{"mtd":[{"mrow":{"mn":"0.587","mo":"\u2062","mi":"f"}},{"mrow":{"mrow":{"mo":"-","mn":"0.331665"},"mo":"\u2062","mi":"f"}},{"mrow":{"mrow":{"mo":"-","mn":"0.418531"},"mo":"\u2062","mi":"f"}}]},{"mtd":[{"mrow":{"mn":"0.114","mo":"\u2062","mi":"f"}},{"mrow":{"mn":"0.50059","mo":"\u2062","mi":"f"}},{"mrow":{"mrow":{"mo":"-","mn":"0.081282"},"mo":"\u2062","mi":"f"}}]}]}}],"mo":"\u2061"}],"mo":"="}}}]}}}},"In one embodiment and as illustrated in , two sets of DWT shaders may be provided. One set may be configured for computing the DWT in the Y direction (DWTy) and another set for computing the DWT in the X direction (DWTx). For each level, the output of the DWTy shader may be used as input for the DWTx shader and the output of the DWTx shader may be used as input for the next level DWTy. The intermediate Direct3D surface types used for the DWT computation can be either RGBA16f or RGBA32f. RGBA16f may be used because of its lower memory and bandwidth requirements that nevertheless provides adequate precision. The input to the DWT process may be 8 bits for each component of a pixel and the DWT output coefficient may be at least 16 bits. The low and high pass DWT filter coefficients used in this embodiment are shown in Equation 2.\n\nLowPassFilterCoeffs=\u2212\u215b \u00bc \u00be \u00bc \u2212\u215b\n\nHighPassFilterCoeffs=\u2212\u00bc \u00bd \u2212\u00bc\n","A shader may be provided that performs quantization and packing As discussed above, quantization is a process where each coefficient is scaled down by a predetermined factor. An assumption may be made that the three L1 bands (LH1, HL1, HH1) are scaled down to 8 bits or less. Even with this assumption, the reconstructed image has excellent image quality with PSNR>40 db (a PSNR of 35 db is considered very good). This assumption may be used to pack the output of a quantized tile down to 5 kb for a 64\u00d764 tile and 20 kb for a 128\u00d7128 tile, as shown below in Table 1. Even if these bands require more than 8 bits per coefficient, each quantized tile would still be 8 kb for 64\u00d764 tile or 32 kb for 128\u00d7128 tile. This may be performed to reduce the amount of data that needs to be read back to the CPU since readback is typically slower than upload for an exemplary GPU. The output of the quantization process may be three Direct3D Surfaces of type ARGB8, one for each of Y, U and V.","These surfaces may be read back to the CPU by using the D3d9 API calls GetRenderTargetData( ) and LockedRect( ).",{"@attributes":{"id":"p-0092","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Size of a tile after each encode stage"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Per Component","Rgb|Yuv","Dwt","Quantization"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"Tile Size 128 \u00d7 128","16 kb","32 kb","20 kb"]},{"entry":[{},"Tile Size 64 \u00d7 64","\u20024 kb","\u20028 kb","\u20025 kb"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"After the quantized and packed surfaces are read back, each tile may be extracted and run through an RLGR encoder on the CPU. This may be performed for each of the three components and the encoded tile output can be generated.","In an embodiment, the GPU may be used as an offload engine to assist in the compression processing tasks. Thus in some of the embodiments disclosed herein, the GPU may be used as a coprocessor to assist in the compression process. The concurrent processing of data on the GPU and CPU may provide for lower latency in the end-to-end process.","In one embodiment, the software codec may be implemented across a programmable GPU and CPU. Such a process may enable overlapped processing on the GPU and CPU to complete the compression\/decompression tasks, thus allowing for decreased processing time.","The table below illustrates one example embodiment listing where support for each stage of encoder may be implemented.",{"@attributes":{"id":"p-0097","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"CPU","GPU"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RGB2YUV",{},"\u2713"]},{"entry":[{},"DWT",{},"\u2713"]},{"entry":[{},"Quantization",{},"\u2713"]},{"entry":[{},"Entropy","\u2713"]},{"entry":[{},"Coding"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"Referring to , a block diagram illustrating a decoding process is shown, in accordance with one embodiment of the present disclosure. The encoding process is shown in . The encoded tile may be first run through an RLGR decoder  to generate a quantized tile coefficient. This may be performed on the CPU.","Dequantization  may be implemented on the CPU using SSE2 instructions. After dequantization, the ten subbands of the three components of the tile may be copied into three Direct3D texture buffers of format L16, one for each of Y, U and V. These three textures may be uploaded onto the GPU and can be used by the Inverse DWT stage  as input.","In an embodiment two shader programs may be provided, one for IDWT in the Y direction and one for IDWT in the X direction. For each level, the output of IDWT_X may be used as input for the IDWT_Y. Two surfaces may be used in a ping-pong fashion. Support for RGBA16f, RGBA32f and ARGB8 formats for these intermediate surfaces may be provided. The inverse DWT may use 16 bits of intermediate precision. This may be accomplished by explicitly splitting each output coefficient into the high byte and the low byte and merging them again on input. Equation 3 below indicates low and high pass filter coefficients that may be used.\n\nLowPassFilterCoeffs=\u2212\u00bc 1 \u2212\u00bc\n\nHighPassFilterCoeffs=\u2212\u215b \u00bd \u00be \u00bd \u2212\u215b\n","The output surface which contains the IDWT tiles may then used as input to another shader program YUV2RGB () that may be provided that performs conversion from YUV to RGB. The output of this shader may be a surface in XRGB8|ARGB8 format and is the reconstructed image or tile .","The table below illustrates one example embodiment listing where each of decoder stages may be implemented.",{"@attributes":{"id":"p-0103","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Processor Used Per Decoder Stage."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CPU","GPU"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Entropy","\u2713",{}]},{"entry":[{},"Decoding"]},{"entry":[{},"Quantization","\u2713"]},{"entry":[{},"IDWT",{},"\u2713"]},{"entry":[{},"YUV2RGB",{},"\u2713"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"To reduce bandwidth and computation, components of a tile may be processed and sent in a staged manner, recreating the image in two or more stages to recreate the tile with full fidelity while within each stage, the image quality may be improved. One objective is to provide the user at the client screen with sufficient and timely image information such that the human eye can perceive the image before the full quality image is received. To achieve when the screen has been captured, the corresponding data tiles may be processed and the DWT and the quantization steps described above may be performed. The entropy processing is not performed on all subbands. The encoder may order the components such that the decoder can produce a good quality image with minimal information extracted from the full image. For example, sending the image from level 3 to level 1 and sending the larger part of the chrominance component compared to the colored component can be one way of achieving the goal. In various embodiments, the exact order of components may vary. The following order of components may be considered:",{"@attributes":{"id":"p-0105","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Component","Order"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Subbands levels","level 3, level 2, level 1"]},{"entry":[{},"Color components","Chrominance (Y) first Cr and Cb are equal"]},{"entry":[{},"Subband in a level","LL, HH, LH and HL are considered equal"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"When sending data the entropy encoding may be performed only on those subbands that are to be transmitted. At the decoder, the received data may be entropy decoded, the missing subbands may be filled with zeroes, and the inverse DWT may be applied. Upon completion of these steps, the resulting image may be displayed. If the tile did not change, the encoder may send some or all of the remaining subbands and the process may be repeated until the tile is fully sent or changed. If the tile is changed, the encoder may discard any previous subbands and apply the process from the beginning In that case decoder may also discard all previously received data for that tile and begin the process again.","In some embodiments, areas or sub-regions of the screen with different update speeds may be tracked. When implementing the staged encoding process described above, sub-regions of the screen may be displayed with different quality depending on their update rates.","In one embodiment, one sub-tile or sub-region may be tracked. In other embodiments, any number of sub-tiles or sub-regions may be tracked. Each sub-tile or sub-region may be assigned one of the following states:\n\n","Initially, all tiles may be set to the \u201cFull Tile Complete\u201d state. When a screen is updated, the following state transitions are possible:\n\n","Updates may be sent based on the tile's state. If the tile is statused as \u201cFull tile in progress\u201d or \u201cTile pending\u201d, then the update may be sent for the entire tile. If the tile is statused as \u201csub-tile in progress\u201d then the update may be sent just for the sub-tile.",{"@attributes":{"id":"p-0111","num":"0122"},"figref":["FIG. 13","FIG. 13"],"b":["1300","1302","1304","1306","1300","1302","1304","1306","1308"]},{"@attributes":{"id":"p-0112","num":"0123"},"figref":["FIG. 14","FIG. 14"],"b":["1400","1410","1420","1420","1422","1424","1426","1428","1430","1432"]},"Any of the above mentioned aspects can be implemented in methods, systems, computer readable media, or any type of manufacture. For example, per , a computer readable medium can store thereon computer executable instructions for processing graphics data for transmission to a client computer. Such media can comprise a first subset of instructions for receiving graphics data representing a client screen associated with a virtual machine session and dividing said graphics data into data tiles ; a second subset of instructions for tracking which of said data tiles are changed from a previous set of data tiles ; a third subset of instructions for identifying which of the changed data tiles include stable and changing sub-regions and tracking the sub-regions ; and a fourth subset of instructions for processing and transmitting the changed data tiles as a function of the stable and changing sub-regions . It will be appreciated by those skilled in the art that additional sets of instructions can be used to capture the various other aspects disclosed herein, and that the three presently disclosed subsets of instructions can vary in detail per the present disclosure.","The foregoing detailed description has set forth various embodiments of the systems and\/or processes via examples and\/or operational diagrams. Insofar as such block diagrams, and\/or examples contain one or more functions and\/or operations, it will be understood by those within the art that each function and\/or operation within such block diagrams, or examples can be implemented, individually and\/or collectively, by a wide range of hardware, software, firmware, or virtually any combination thereof.","It should be understood that the various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the disclosure, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the disclosure. In the case of program code execution on programmable computers, the computing device generally includes a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may implement or utilize the processes described in connection with the disclosure, e.g., through the use of an application programming interface (API), reusable controls, or the like. Such programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","While the invention has been particularly shown and described with reference to a preferred embodiment thereof, it will be understood by those skilled in the art that various changes in form and detail may be made without departing from the scope of the present invention as set forth in the following claims. Furthermore, although elements of the invention may be described or claimed in the singular, the plural is contemplated unless limitation to the singular is explicitly stated."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The systems, methods, and computer readable media for altering a view perspective within a virtual environment in accordance with this specification are further described with reference to the accompanying drawings in which:","The systems, methods, and computer readable media for altering a view perspective within a virtual environment in accordance with this specification are further described with reference to the accompanying drawings in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 1 and 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 15","FIGS. 1-14"]}]},"DETDESC":[{},{}]}
