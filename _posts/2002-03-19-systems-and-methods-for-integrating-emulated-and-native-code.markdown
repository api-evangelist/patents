---
title: Systems and methods for integrating emulated and native code
abstract: Systems and methods for integrating emulated and native code are provided. One embodiment comprises a method for emulating code from an original computer system on a host computer system. Briefly described, one such embodiment comprises the steps of: fetching a program instruction associated with program code to be emulated on a host computer system; determining whether the program instruction is to be executed natively on the host computer system or is to be emulated on the host computer system; and if the program instruction is to be executed natively on the host computer system, emitting a native code fragment associated with the program instruction into a dynamic execution layer interface to be executed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06907519&OS=06907519&RS=06907519
owner: Hewlett-Packard Development Company, L.P.
number: 06907519
owner_city: Houston
owner_country: US
publication_date: 20020319
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims priority to now abandoned U.S. provisional application entitled, \u201cSystems and Methods for Integrating Emulated and Native Code,\u201d having Ser. No. 60\/334,234, filed Nov. 29, 2001, which is entirely incorporated herein by reference.","This disclosure generally relates to emulation of an original computer system on a host computer system. More particularly, the disclosure relates to systems and methods for integrating emulated and native code.","Operating system software and user application software are written to execute on a given type of computer system. That is, software is written to correspond to the particular instruction set in a computer system, i.e., the set of instructions that the system recognizes and can execute. If the software is executed on a computer system without an operating system, the software must also be written to correspond to the particular set of components and\/or peripherals in the computing system.","Computer hardware (e.g., microprocessors) and their instruction sets are often upgraded and modified, typically to provide improved performance. Unfortunately, as computer hardware is upgraded or replaced, the preexisting software, which often is created at substantial cost and effort, is rendered obsolete. Specifically, in that the software was written for an instruction set of the original hardware, it contains instructions that a new host hardware will not understand.","Various solutions are currently used to deal with the aforementioned difficulty. One such solution is to maintain obsolete computer hardware instead of replacing it with the upgraded hardware. This alternative is unattractive for several reasons. First, a great deal of expense and effort is required to maintain such outdated hardware. Second, where the new hardware is more powerful, failing to replace the outdated hardware equates to foregoing potentially significant performance improvements for the computer system.","A further solution to the problem, and perhaps most common, it to simply replace all of the software each time the underlying hardware is replaced. This solution is equally unattractive, however, in view of the expense and effort required for such an endeavor as well as the learning curve associated with training the users of the previous software to use the new software.","Another potential solution to the problem is to provide a virtual machine environment in which the original software can be executed on a new host system. This solution has the advantage of neither requiring maintenance of outdated hardware nor complete replacement of the original software. Unfortunately, however, present emulation systems lack the resources to provide a hardware emulation for real world software applications due to the complexity associated with emulating each action of the original hardware. For example, to emulate a computer system for an actual program such as an operating system, the emulation system must be able to handle asynchronous events that may occur such as exceptions and interrupts. Furthermore, current systems are highly customized (e.g., are point solutions) and are therefore platform dependent.","From the foregoing, it can be appreciated that it would be desirable to have improved emulation systems.","The present disclosure relates to systems and methods for integrating emulated and native code. One embodiment comprises a method for emulating code from an original computer system on a host computer system. Briefly described, one such embodiment comprises the steps of: fetching a program instruction associated with program code to be emulated on a host computer system; determining whether the program instruction is to be executed natively on the host computer system or is to be emulated on the host computer system; and if the program instruction is to be executed natively on the host computer system, emitting a native code fragment associated with the program instruction into a dynamic execution layer interface to be executed.","Another embodiment comprises an emulation program embodied on a computer-readable medium and configured to emulate an original computer system for which a program was written. Briefly described, one such embodiment comprises: logic configured to fetch a program instruction associated with program code to be emulated on a host computer system; logic configured to determine whether the program instruction is to be executed natively on the host computer system or is to be emulated on the host computer system; and logic configured to emit a native code fragment associated with the program instruction into a dynamic execution layer interface to be executed in the event the program instruction is to be executed natively on the host computer system.","Another embodiment of the present invention comprises a system for emulating code from an original computer system on a host computer system. Briefly described, in architecture, one such system comprises an emulator, a dynamic execution layer interface, and an application program interface that links the emulator and the dynamic execution layer interface. The emulator may be configured to fetch instructions associated with a program written to be executed on an original computer system. The emulator may comprise an emulation module configured to execute instructions by emulating the original computer system and a native code interceptor module configured to detect instructions that are to be executed natively instead of emulated. The dynamic execution layer interface comprises a core having at least one code cache in which code fragments may be cached and executed.","Disclosed is a system and method for integrating emulated and native code in a virtual machine environment. As is explained below, the integration of the native code with the code to be emulated is facilitated with a dynamic execution layer interface that is utilized via an application program interface (API). To facilitate description of the inventive system and method, example systems are discussed with reference to the figures. Although these systems are described in detail, it will be appreciated that they are provided for purposes of illustration only and that various modifications are feasible without departing from the inventive concept. After the description of the systems, examples of operation of the systems are provided to explain the manners in which system emulation can be facilitated.","Referring to , an embodiment of an emulation system  according to the present invention, which is configured to integrate native and emulated code in a virtual machine environment, will be described. As described in more detail below, in general, emulation system  is configured to execute software written for a computer system, which is different from that of a host computer system, by emulating the original computer system in a virtual machine environment. By way of background, the original computer system, or \u201cemulated system,\u201d may comprise a processor, such as a microprocessor, having one type of instruction set architecture (ISA), while the host computer system, or \u201cnative system,\u201d may comprise a different processor having another type of ISA. The ISA of a processor generally refers to the set or sequence of binary instruction codes that a particular type of processor executes to carry out software instructions. Software written for the emulated system is referred to as \u201cemulated code\u201d and software written for the native system is referred to as \u201cnative code.\u201d In order to execute the emulated code on the native system, an emulation system may be employed to implement what is referred to as a virtual machine environment.","Significantly, emulation system  is also configured to execute native code that is integrated with the emulated code. In the embodiment illustrated in , emulation system  comprises an emulator , a dynamic execution layer interface (DELI) , and hardware . Emulator  is linked to DELI  via interface , to hardware  via interface , and to an emulated application  and\/or an emulated operating system  via interface . DELI  is linked to hardware  via interface .","Generally speaking, DELI  comprises a generic software layer written in a high or low level language that resides between applications (i.e., emulator ), including or not including an operating system (O\/S), and hardware to untie application binary code from the hardware. Through this arrangement, DELI  may provide dynamic computer program code transformation, caching, and linking services that can be used in a wide variety of different applications such as emulation, dynamic translation and optimization, transparent remote code execution, remapping of computer system functionality for virtualized hardware environments program, code decompression, code decrypting, etc. As described in more detail below, DELI  may provide its services while operating in a transparent mode, a nontransparent mode, or combinations of the two. In the transparent mode, DELI  automatically takes control of an executing program in a manner in which the executing program is unaware that it is not executing directly on computer hardware. In the nontransparent mode, DELI  exports its services through an application program interface (API) to the application (client), thereby enabling the application to control how DELI  reacts to certain system events.","Emulator  includes a native code interceptor module  and an emulation module . Generally speaking, emulation module  emulates the hardware of an emulated system. Accordingly, emulation module , from the perspective of a program executed by the emulation system , performs all of the actions that the original hardware would have performed during native execution of the program. One of ordinary skill in the art will appreciate that emulation module  may be configured in a variety of ways. For example, emulation module  may be implemented with any combination of an emulation functionality, an interpreter functionality, an emulator\/translator functionality, and\/or a just-in-time (JIT) compiler. Accordingly, emulation module  may implement an interpreter to provide emulation of the emulated system. As is generally known to persons having ordinary skill in the art, interpreters receive code, interpret it by determining the underlying semantics associated with the code, and carry out the semantic actions. An emulator\/interpreter functionality may comprise an original system description that comprises the information about the instruction set of the original system hardware (i.e., that being emulated) that is needed to properly emulate the original system.","JIT compilers are configured to provide run time compilation (i.e., translation) of software. More particularly, JIT compilers provide binary translation of the program to be executed. In operation, a JIT compiler receives a representation of the program and translates it into an equivalent program (i.e., one having the same semantic functionality) for the target hardware of the host computer system. Similar to emulator\/interpreter functionality, a JIT compiler comprises a system description that comprises information about the instruction set of the original system hardware. The system description, however, comprises the information the JIT compiler needs to properly translate code into the desired form.","As described in more detail below, native code interceptor module  is configured to detect native code  inserted within emulated code  and to execute the native code  on hardware  without the need for emulation.  is a flow diagram illustrating the general operation of emulating system . As shown by block , emulating system  fetches instructions corresponding to emulated code , which includes native code . At decision block , emulating system  determines whether the particular fetched instruction corresponds to code that is to be run natively on hardware . In other words, emulating system  is configured to detect native code . If the fetched instruction corresponds to emulated code , at block , emulating system  emulates the code. When emulating system  detects native code , however, at block , the code is run natively on hardware  without undergoing emulation, interpretation, translation, etc. Native code  may also be executed via DELI .","Although referred to as native code , it will be appreciated that native code  need not comprise the actual native code to be executed. As described in more detail below, native code  may comprise a \u201cspecial\u201d instruction (e.g. an illegal instruction in the emulated system) adapted to enable native code interceptor module  to determine that specified native code  is to be executed natively. For instance, this functionality may be implemented with a wrapper function, native libraries, and\/or an interface configured to bridge calling conventions associated with the native system and the emulated system. One of ordinary skill in the art will appreciate that a variety of other known or later-developed programming conventions may be implemented. For example, an existing compiler toolchain for the emulated system may be integrated with an existing compiler toolchain for the native system. In this manner, postprocessors may produce, in both cases, wrappers that convert one convention (also known as RTA or Run Time Architecture) to the other. An application programmer may specify certain parts of, for example, an application program, to be executed natively on hardware . It may be advantageous for performance purposes to run certain portions of a computer program natively on hardware .","Consider the situation in which the native hardware  is very efficient in running certain kinds of applications in a manner that is faster than the emulated system and\/or faster than emulating, interpreting, and\/or translating the corresponding code. By way of example, the emulated application may comprise a media-based application, such as a video player. In this type of application, a very complex front-end graphical user interface (GUI) may be written in a familiar programming environment (i.e., SDK), while the media-processing portion of the application may be written to cooperate directly with the native hardware . In other words, the GUI-portion of the application may be written as emulated code  and the media-processing portion may be written as native code , which is integrated with the emulated code. As the media-based application is being executed by emulation system , the GUI-based code (emulated code ) is emulated and executed on hardware  and the media-processing code is executed natively.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 3","FIG. 3"],"b":["300","300","301","302","104","106","301","104","114","106","112","302","104","308","106","310","302","301","106","104"]},"As described above, in certain embodiments emulation module  may implement an interpreter to provide emulation of the emulated system. As is generally known to persons having ordinary skill in the art, interpreters receive code, interpret it by determining the underlying semantics associated with the code, and carry out the semantic actions. An emulator\/interpreter functionality may comprise an original system description that comprises the information about the instruction set of the original system hardware (i.e., that being emulated) that is needed to properly emulate the original system.","Generally speaking, an interpreter\/emulator functionality emulates the hardware of the original computer system for which the software (e.g., a program) running on emulation system  was written. Accordingly, the interpreter\/emulator functionality, from the perspective of a program executed by emulation system , performs all of the actions that the original hardware would have performed during native execution of the program.","As is suggested by its name, an interpreter\/emulator functionality implements an interpreter to provide emulation of the original computer system. As is generally known to persons having ordinary skill in the art, interpreters receive code, interpret it by determining the underlying semantics associated with the code, and carry out the semantic actions. As known by those of ordinary skill in the art, an interpreter\/emulator functionality normally comprises an original system description that comprises the information about the instruction set of the original system hardware (i.e., that being emulated) that is needed to properly emulate the original system. Although emulation module  may implement an interpreter\/emulator, it is to be understood that in other embodiments emulation module  may comprise a different type of emulator, such as a translator\/emulator. Furthermore, it is to be appreciated that emulation system  may also include a JIT compiler capable of providing this functionality.","In these embodiments, the interpreter\/emulator functionality may be linked to the JIT compiler with an interface. As its name suggests, the JIT compiler is configured to provide run time compilation (i.e., translation) of software. More particularly, the JIT compiler provides binary translation of the program to be executed. In operation, the JIT compiler receives a representation of the program and translates it into an equivalent program (i.e., one having the same semantic functionality) for the target hardware of the host computer system. Similar to the interpreter\/emulator functionality, the JIT compiler comprises a system description that comprises information about the instruction set of the original system hardware. The system description, however, comprises the information the JIT compiler needs to properly translate code into the desired form. In addition to the system description, the JIT compiler  may comprise a run time manager that, as is described below, permits the DELI  to invoke callback methods into the JIT compiler to, for instance, notify the JIT compiler as to the occurrence of certain events. When such callback methods are invoked, the run time manager is used to implement the callback methods.","Regardless of the particular method employed by emulator  to perform the emulation of the emulated code , emulator  is linked to DELI  with an API. This API facilitates communications between the emulator  and the DELI . Accordingly, the API may be used by the emulator  to access, for instance, code caching and linking services of the DELI  and can be used by the DELI to invoke the callback methods into the emulator . Referring again to , DELI  may comprise an application programming interface (API) manager , a host system description , and an optimization manager . The host system description  comprises the information that the DELI  needs about the host computer system such as its hardware, instruction set, etc. Operation of the API manager  and the optimization manager  is described in detail below.","Although not illustrated in , emulation system  may include a hardware abstraction module (HAM) to assist in the emulation of code to be emulated. In that the details of the configuration and operation of the HAM are not specifically relevant to the present disclosure, a detailed description of the HAM is not provided herein. However, it suffices to say that the HAM is generally configured to manage the hardware-related events (e.g., exceptions and interrupts) taking place on the host computer system and relevant to the execution of the code in the context of the original computer system that are to be emulated on the host computer system. The services of the HAM can be utilized by DELI  via the API.","The general construction of emulation system  having been provided above, an example of operation of the system will now be provided in relation to . Beginning with block  of , one or more program instructions associated with emulated code  are first fetched from memory by emulator . This may comprise accessing the original memory address from the original computer system and using it to identify the actual location of the instruction(s) on the host computer system.","With reference to decision element , emulating system  determines whether the fetched instruction(s) correspond to native code  integrated with emulated code . One of ordinary skill in the art will appreciate that any of a variety of known and\/or later-developed programming techniques may be implemented by emulating system  to detect native code . For instance, this functionality may be implemented with a wrapper function, native libraries, and\/or an interface configured to bridge calling conventions associated with the native system and the emulated system.","By way of example, consider the situation in which the original computer system (emulated system) includes a compiler toolchain. In this situation, emulated system  may include a native compiler toolchain, which may be integrated with the compiler toolchain from the emulated system. This integrated toolchain may be configured to provide an interface or convention for enabling communication between the emulated system and the native system. For example, consider the situation in which a particular function (\u201cFoo\u201d), which is invoked in a program (\u201cMain\u201d) by the emulated system and embedded in emulated code , could be more efficiently implemented natively on the host supporting the emulation (the native system). An illustrative example of the program Main be represented as follows:",{"@attributes":{"id":"p-0040","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Main( )"]},{"entry":[{},"{"]},{"entry":[{},"\/* code compiled for the original system that will be emulated *\/"]},{"entry":[{},". . . ."]},{"entry":[{},". . . ."]},{"entry":[{},". . . ."]},{"entry":[{},"Foo(parameters list);"]},{"entry":[{},". . . . . ."]},{"entry":[{},". . . . ."]},{"entry":[{},". . . ."]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The emulated system compiler may compile this code into a sequence of instructions for the processor of the emulated system by using a well-defined calling convention. The calling convention may specify, among other things, how to pass parameters to functions (e.g., in registers, on the stack, via a combination of the registers and the stack, etc.). An illustrative example of the compiled code may be represented as follows:",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"_Main:"},{"entry":"# machine instructions for the original system that will be emulated"},{"entry":". . . . ."},{"entry":". . . ."},{"entry":". . . ."},{"entry":"Function call prolog instructions (e.g., set-up function parameters in"},{"entry":"certain registers or load them on to the stack as specified by the calling"},{"entry":"convention on the emulated system)"},{"entry":"Call _Foo"},{"entry":"Function call epilog instructions (e.g., load return parameters in certain"},{"entry":"registers or load them from the stack as specified by the calling"},{"entry":"convention on the emulated system)"},{"entry":". . . ."},{"entry":". . . ."},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Typically, if the function Foo was being compiled for the emulated system, it would contain a set of machine instructions, which may be represented as follows:",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"_Foo:"},{"entry":"{"},{"entry":"function prolog instructions (e.g., increment stack pointers, spill used"},{"entry":"registers on to the stack, etc.)"},{"entry":"function body instructions"},{"entry":"function epilog instructions (e.g. load return value in certain registers,"},{"entry":"restore previously spilled registers, restore the stack pointers, etc,)"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"In one embodiment, the emulator\/translator running on the host system may be made aware of the need to take special actions during the process of emulating and\/or translating from the emulated environment by using a special instruction or \u201csentinel\u201d that otherwise has no meaning in the emulated system, (e.g., an undefined instruction code, instruction that is \u201cillegal\u201d to execute, etc.). Together with the special \u201csentinel,\u201d the wrapper may contain a descriptor block that specifies parameters to be passed to the native function from the emulated system and their location (e.g., registers or memory). This description may be embedded in the emulated code as data by using the emulated system toolchain support to do that or otherwise. For example, suppose the emulated system toolchain assembler (the utility that commonly converts assemble level code into machine object code) has a \u201c.data\u201d directive that allows a programmer to define an embedded constant. Following is an illustrative function wrapper for a function Foo:",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"_Foo:"},{"entry":"# .data illegal instruction # for the sentinel or gateway to tell"},{"entry":"# the emulator\/translator which function is to be invoked natively;"},{"entry":"# .data Native_Foo # address of Foo compiled natively"},{"entry":"# .data 3 # number of parameters passed to the function"},{"entry":"# description record for the first parameter"},{"entry":"# .data 4 # size of this parameter (e.g., an integer)"},{"entry":"# .data 5 # index of the register in the emulated system CPU used to"},{"entry":"# pass this parameter"},{"entry":"# .data x # additional information needed to convert the calling"},{"entry":"# convention to the host system"},{"entry":"# .data y"},{"entry":"# .data z"},{"entry":"# description record for the second parameter"},{"entry":". . . ."},{"entry":". . . ."},{"entry":". . ."},{"entry":"# description record for the last parameter, etc."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"300"},"In the wrapper function described above, the record describing the call for the native system to properly translate the code, may contain a reference to the unction (e.g., \u201cNative_Foo\u201d). The reference to the function may be an alias (e.g., a data reference, etc.) that points to a storage area, which would appear as normal data (i.e., similar to global variable storage in memory) to the emulated system. This functionality may again be achieved by way of a simple tool integrated in the emulated compiler toolchain. The tool may be configured such that, when the function has been compiled natively by the native compiler (e.g., in the form of a position independent executable binary code), the compiled code will be packaged like a piece of data for the emulated system linker. In this manner, the reference to the function (Native_Foo) may be replaced with a location in memory in much the same manner as any other reference to data. For instance, the native compiler toolchain may generate a position independent binary containing, among other things, the function (e.g., Foo), which is able to run natively on the native system. Consider the situation in which the function has been compiled and placed in a binary file (e.g., \u201cfoo.bin\u201d). The tool written for the emulated compiler toolchain may take this binary and produce an illustrative source file represented as follows:",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Native_Foo[ ] = {"},{"entry":"\/* native instructions taken from foo.bin are used to initialize this array"},{"entry":"*\/"},{"entry":". . . ."},{"entry":". . . ."},{"entry":". . ."},{"entry":". . ."},{"entry":"};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"This file may then be compiled by the emulated compiler toolchain and linked with the rest of the application together with the function wrapper described above. In this manner, the native code may be stored together with the emulated system application code, or emulated code, in the form of, for example, an executable file. Furthermore, the emulated system linker may resolve the symbol Native_Foo contained in it.","It will be appreciated that other ways of embedding and integrating native code into the original system code may be employed. For example, in another embodiment, another sentinel instruction may be used to inform the emulation system that the instructions following the sentinel are native instructions that need to be executed on the native system hardware . In these embodiments, the emulator  may release control of the hardware  by executing those instructions until such a time as an event return control to the emulator  again. Such an event maybe defined as a particular hardware mechanism on the host computer that is reserved for this purpose. For example, in certain embodiments, the native code embedded in the original system application (emulated code) may use an illegal instruction, a software breakpoint, or a trap instruction when control has to be returned to the emulator  to resume the emulation process.","One of ordinary skill in the art will appreciate that the emulated to native interface may also work in the other direction, with minor modification, when invoking code in the emulated system from the host system being run natively.","In alternative embodiments, where the native code needs to access the emulated system memory, additional care may be taken so that when an exception results from an access to such memory, the exception is resolved in ways that are compatible with the emulated system. Furthermore, after the exception event(s) has been taken care of (e.g. by emulating the exception handler code in the emulated system), control may be returned to the native code that was running when the exception event was triggered.","For example, imaging the emulated system uses virtual memory and enables mapping of a virtual memory address to physical memory address (e.g. by using a hardware TLB (Translation Lookaside Buffer)). In the process of running the native function invoked from the emulated system code through the mechanism previously described, such a code may cause access of virtual memory whose translation may not have been provided by the emulated system. This may result in a missing translation exception, which to be correctly handled, needs to be converted into the emulated system equivalent exception. The problem is that the native code that generated this condition is not a translation from the emulated system code. As a result, the emulated code for the relevant exception handler cannot be handed a proper context for the emulated system. This can be solved by \u201cfaking\u201d a surrogate context for the emulated system, which may be used as a \u201cplaceholder\u201d for the emulated exception handler. This mechanism may be implemented by, for example, saving the native context at the time of the exception and storing it away for later when control is returned to it once the exception condition is resolved. Additionally, if multiple nested exceptions are possible in the emulated system, then multiple copies of the native context may be saved and restored later to handle the reentrancy.","Referring to , during operation of emulating system , emulator  may detect the fetch of the special instruction and, at block , produce a special fragment of code that will convert the calling convention from the emulated system to the calling convention for the native system, along with a native function call to the Native_Foo code loaded in the storage allocated for the emulated memory (e.g., loaded together with the emulated application code by the emulated O\/S).","As represented by decision block  and blocks  and , the special fragment may be emitted and executed in the code cache of DELI , and possibly linked with other fragments already active in the code cache. The operation of DELI  is described in detail below. Before executing the special fragment (which contains the call to the Native_Foo function), emulating system  may also make a call to DELI . The call to DELI  may, for example, activate the DELI transparent mode in such a way as to automatically insert native fragments of code from the function Native_Foo (and other native functions invoked by it) in the code cache. The native fragments of code inserted into DELI  may also be optimized by DELI  as described in detail below.","Referring again to , the emulation portion of emulating system  will be described. At decision block , if the fetched instructions are not associated with native code, emulation module  determines whether emulation system  is currently growing a code fragment by linking various program instructions together. As is known in the art, such linking is typically performed to increase execution efficiency of the code. If the system is not currently growing a code fragment, for instance a machine state exists in which emulator  is not able to grow a fragment, flow continues to decision block  described below. If, on the other hand, the system  is growing a code fragment, flow continues to decision block , at which the emulator  determines whether to continue growing the code fragment (by adding the fetched instruction(s) to the fragment) or stop growing the code fragment. This determination is made in view of certain internal criteria. For example, the emulator  may be configured to grow a fragment until a basic block of code containing a branch (i.e., control flow instructions) is obtained.","If the emulator  determines not to stop growing the fragment (i.e., to continue growing the fragment), flow continues to block , at which the fragment is grown, i.e. where the fetched program instruction(s) is\/are added to the fragment that is being grown. If the emulator  determines to stop growing the fragment, however, flow continues to block , at which a translation for the existing code fragment is emitted into a code cache of the DELI  via the API. A detailed discussion of the manner in which such code fragments can be emitted to the DELI  is provided below. As is explained in that description, once the code fragment has been cached in the DELI , it can be executed natively from the DELI code cache(s) when the semantic function of the original code is required. Such operation permits greatly improved efficiency in executing the program on the host computer in that the overhead associated with translating the original code is avoided the next time the semantic function is required. In addition to emitting code fragment to the code cache(s), the emulator  associates the original instruction(s) with the emitted fragment with an identifier such as a tag so that the emulator will know that a translation for the original program instruction(s) already resides in the code cache(s) of the DELI . Once the code has been cached, it can be linked according to various policies provided to the DELI  to further increase system efficiency.","Irrespective of whether fragment growth is continued or whether a translation for the code fragment is emitted, flow next continues to decision block , at which the emulating system  determines whether a translation of the fetched instruction(s) has been cached, i.e. is contained within a code cache of the DELI . If so, execution then jumps to the code cache(s) of the DELI  and the translated code fragment is executed natively, as indicated in block . Execution continues in the code cache(s) until such time when a reference to code not contained therein (e.g., a cache miss) is encountered. At this point, flow returns to block  and the next program instruction(s) is\/are fetched.","Returning to decision block , if a translation of the fetched instruction(s) has not been cached, flow returns to the emulator , which is illustrated in FIG. B. Beginning with decision block , emulator  determines whether the instruction fetching action that was conducted in block  would have created an exception in the emulated system. By way of example, such an exception could have arisen where there was no permission to access the portion of memory at which the instruction(s) would have been located. This determination is made with reference to the information contained within the system description mentioned above. If such an exception would have occurred, flow continues down to block , at which the exception action or actions that would have been taken by the original computer system is\/are emulated by the emulator  for the benefit of the program.","Assuming no exception arose at decision block , flow continues to block , at which the fetched instruction(s) is\/are decoded by the emulator . Generally speaking, this action comprises interpreting the nature of the instruction(s), i.e. the underlying semantics of the instruction(s). Next, with reference to decision block , it can again be determined whether an exception would have occurred in the emulated system. Specifically, it is determined whether the instruction(s) would have been illegal in the original system. If so, flow continues to block  and the exception action(s) that would have been taken by the original computer system are emulated. If not, however, flow continues to block , at which the semantics of the fetched instruction(s) are executed by the emulator  to emulate actual execution of the instruction(s) by the emulated system. At this point, with reference to decision block , it can once again be determined whether an exception would have arisen in the emulated system. In particular, it can be determined whether it would have been illegal to execute the instruction(s) in the emulated system. If an exception would have arisen, flow continues to block . If no exception would have arisen, however, flow returns to block  and one or more new program instructions are fetched.","Notably, in the initial stages of operation of the system , i.e. when emulation is first provided for the program, most execution is conducted by the emulator  in that little or no code resides within (i.e., has been emitted into) the code cache(s) of the DELI . However, in a relatively short amount of time, most if not all execution is conducted within the code cache(s) of the DELI  due to the emitting step (block ). By natively executing code within the code cache(s), the overhead associated with interpreting and emulating is avoided (in that it has already been performed), thereby greatly increasing emulation efficiency.","As described above, emulation efficiency and\/or the efficiency of executing native code is significantly increased due to the provision of the DELI .  illustrates an example configuration for the DELI . Generally speaking, the DELI  comprises a generic software layer written in a high or low level language that resides between applications, including or not including an operating system (O\/S), and hardware to untie application binary code from the hardware. Through this arrangement, the DELI  can provide dynamic computer program code transformation, caching, and linking services, which can be used in a wide variety of different applications such as emulation, dynamic translation and optimization, transparent remote code execution, remapping of computer system functionality for virtualized hardware environments program, code decompression, code decrypting, etc. Generally speaking, the DELI  can provide its services while operating in a transparent mode, a nontransparent mode, or combinations of the two. In the transparent mode, the DELI  automatically takes control of an executing program in a manner in which the executing program is unaware that it is not executing directly on computer hardware. In the nontransparent mode, the DELI  exports its services through the API  to the application (client), such as emulator , to allow the application to control how the DELI reacts to certain system events.","As depicted in , the DELI  resides between at least one application (program) and computer hardware  of the native system. In that the application was written for the original computer system that is being emulated, the application is unaware of the DELI's presence. Underneath the application resides a client which, in this case, comprises the emulator . Unlike the application, the client is aware of the DELI  and is configured to utilize its services.","The DELI  can include four main components including a core , an API manager , a transparent mode layer , and a system control and configuration layer . Generally speaking, the core  exports two primary services to both the API manager  (and therefore to the API ) and the transparent mode layer . The first of these services pertains to the caching and linking of native code fragments or code fragments which correspond to the instruction set of the hardware . The second pertains to executing previously cached code fragments. The API manager  exports functions to the client (e.g., emulator ) that provide access to the caching and linking services of the core  in the nontransparent mode of operation. The transparent mode layer , where provided, enables the core  to gain control transparently over code execution in the transparent mode of operation as well as fetch code fragments to be cached. Finally, the system control and configuration layer  enables configuration of the DELI  by providing policies for operation of the core  including, for example, policies for the caching, linking, and optimizing of code. These policies can, for example, be provided to the layer  from the client via the API manager . The system control and configuration layer  also controls whether the transparent mode of the DELI  is enabled, thus determining whether the core  receives input from the API manager , the transparent mode layer , or both. As is further indicated in , the system  can include a bypass path  that can be used by the application to bypass the DELI  so that the application can execute directly on the hardware , where desired.","As is shown in , the core  comprises a core controller , a cache manager , a fragment manager , and the optimization manager  (FIG. ). The core controller  functions as a dispatcher that assigns tasks to the other components of the core  that are responsible for completing the tasks. The cache manager  comprises a mechanism (e.g., set of algorithms) that controls the caching of the code fragments within one or more code caches  (e.g., caches  through n) according to the policies specified by the system control and configuration layer , as well as the fragment manager  and the optimization manager . The one or more code caches  of the core  can, for instance, be located in hardware caches on one or more processors of the hardware , or can be created in the main local memory of the hardware. Where the code cache(s)  is\/are mapped in hardware caches onboard the processor(s), greatly increased performance can be obtained due to reduced instruction cache refill overhead, increased memory bandwidth, etc. The fragment manager  specifies the arrangement of the code fragments within the code cache(s)  and the type of transformation that is imposed upon the fragments. Finally the optimization manager  contains the set of optimizations that can be applied to the code fragments to optimize their execution.","As noted above, the API manager  exports functions to the application that provide access to DELI services. More specifically, the API manager  exports caching and linking services of the core  to the client (e.g., emulator ) via the API . These exported services enable the client to control the operation of the DELI  in the nontransparent mode by, for example, explicitly emitting code fragments to the core  for caching and instructing the DELI  to execute specific code fragments out of its code cache(s) . In addition, the API manager  also can export functions that initialize and discontinue operation of the DELI . For instance, the API manager  can initiate transparent operation of the DELI  and further indicate when the DELI is to cease such operation. Furthermore, the API manager  also, as mentioned above, facilitates configuration of the DELI  by delivering policies specified by the client to the core  (e.g., to the fragment manager  and\/or the optimization manager ).","With further reference to , the transparent mode layer  can include an injector  that can be used to gain control over an application transparently. When the DELI  operates in a completely transparent mode, the injector  is used to inject the DELI into the application before the application begins execution so that the application can be run under DELI control. Control can be gained by the injector  in several different methods, each of which loads the application binaries without changing the virtual address at which the binaries are loaded. Examples these methods are described in U.S. patent application Ser. No. 09\/924,260, filed Aug. 8, 2001, entitled \u201cDynamic Execution Layer Interface for Explicitly of Transparently Executing Application or System Binaries\u201d, which is hereby incorporated by reference into the present disclosure. In the emulation context, however, such completely transparent operation is typically not used in that the client is configured to use the DELI's services in an explicit manner.","As noted above, the system control and configuration layer  enables configuration of the DELI  by providing policies for various actions such as the caching and linking of code. More generally, the policies typically determine how the DELI  will behave. For instance, the layer  may provide policies as to how fragments of code are extracted from an application, how fragments are created from the original code, how multiple code fragments can be linked together to form larger code fragments, etc. The layer's policies can be static or dynamic. In the former case, the policies can be hardcoded into the DELI , fixing the configuration at build time. In the latter case, the policies can be dynamically provided by the client through function calls in the API . Implementation of the policies can control the manner in which the DELI  reacts to specific system and\/or hardware events (e.g., exceptions and interrupts). In addition to the policies noted above, the system control and configuration layer  can specify the size of the code cache(s) , whether a log file is created, whether code fragments should be optimized, etc.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 6","FIG. 6"],"b":["506","506","212","510","600","524","506","524","106"]},"The core controller  processes these requests and dispatches them to the appropriate core module. A request  to emit a code fragment with a given identifier can then be passed to the fragment manager . The fragment manager  transforms the code fragment according to its fragment formation policy , possibly instruments the code fragment according to its instrumentation policy , and links the code fragment together with previously cached fragments according to its fragment linking policy . For example, the fragment manager  may link multiple code fragments in the cache(s) , so that execution jumps to another code fragment at the end of executing a code fragment, thereby increasing the length of execution from the cache(s). To accomplish this, the fragment manager  issues fragment allocation instructions  to the cache manager . The fragment manager  then sends a request to the cache manager  to allocate the processed code fragment in the code cache(s) .","The cache manager  controls the allocation of the code fragments and typically is equipped with its own cache policies  for managing the cache space. However, the fragment manager  may also issue specific fragment deallocation instructions  to the cache manager . For example, the fragment manager  may decide to integrate the current fragment with a previously allocated fragment, in which case the previous fragment may need to be deallocated. In some arrangements, the cache manager  and fragment manager  can manage the code cache(s)  and code fragments in the manner shown and described in U.S. Pat. No. 6,237,065, issued May 22, 2001, entitled \u201cA Preemptive Replacement Strategy for a Caching Dynamic Translator Based on Changes in the Translation Rate,\u201d which is hereby incorporated by reference into the present disclosure. Alternatively, management of the code cache(s)  and code fragments may be performed in the manner shown and described in U.S. patent application Ser. No. 09\/755,389, filed Jan. 5, 2001, entitled \u201cA Partitioned Code Cache Organization to Exploit Program Locality,\u201d which is also hereby incorporated by reference into the present disclosure.","Prior to passing a fragment to the cache manager , the fragment manager  may pass () the fragment to the optimization manager  to improve the quality of the code fragment according to its optimization policies . In some arrangements, the optimization manager  may optimize code fragments in the manner shown and described in U.S. patent application Ser. No. 09\/755,381, filed Jan. 5, 2001, entitled \u201cA Fast Runtime Scheme for Removing Dead Code Across Linked Fragments,\u201d which is hereby incorporated by reference into the present disclosure. Alternatively, the optimization manager  may optimize code fragments in the manner shown and described in U.S. patent application Ser. No. 09\/755,774, filed Jan. 5, 2001, entitled \u201cA Memory Disambiguation Scheme for Partially Redundant Load Removal,\u201d which is also hereby incorporated by reference into the present disclosure. Notably, the optimization manager  may also optimize code fragments using classical compiler optimization techniques, such as elimination of redundant computations, elimination of redundant memory accesses, inlining functions to remove procedure call\/return overhead, dead code removal, implementation of peepholes, etc. Typically, the optimization manager  deals with an intermediate representations (IRs) of the code that is to be optimized. In such an arrangement, the client may be aware of that IR code is needed and can call upon the API  to translate code from native to IR for purposes of optimization, and back again to native once the optimization(s) has been performed.","As mentioned above, the fragment manager  transforms the code fragment according to its fragment formation policy . The transformations performed by the fragment manager  can include code relocation by, for instance, changing memory address references by modifying relative addresses, branch addresses, etc. The layout of code fragments may also be modified, changing the physical layout of the code without changing its functionality (i.e., semantics). These transformations are performed by the fragment manager  on fragments received through the API  and from the instruction fetch controller  of the transparent mode layer .","As identified above, the other primary type of request accepted by the DELI core  is a request  to execute a fragment identified by a given identifier (e.g., tag). In such a case, the core controller  issues a lookup request  to the fragment manager , which returns a corresponding code cache address  if the fragment is currently resident and active in the cache(s) . By way of example, the fragment manager  can maintain a lookup table of resident and active code fragments in which a tag can be used to identify the location of a code fragment. Alternatively, the fragment manager  or cache manager  can use any other suitable technique for tracking whether code fragments are resident and active. If the fragment is not currently resident and active in the cache(s) , the fragment manager  returns an error code to the core controller , which returns () the fragment tag back to the initial requester as a cache miss address. If, on the other hand, the fragment is currently resident and active, the core controller  then patches () the initial request to the cache manager  along with its cache address. The cache manager , in turn, transfers control to the addressed code fragment in its code cache(s) , thus executing the addressed code fragment. Execution then remains focused in the code cache(s)  until a cache miss occurs, i.e., until a copy for the next application address to be executed is not currently resident in the cache(s). This condition can be detected, for instance, by an attempt of the code being executed to escape from the code cache(s) . A cache miss is reported () from the cache manager  to the core controller  and, in turn, back () to the initial requester.","Although two primary requests have been identified above in relation to  (i.e., emitting and executing), it is to be understood that many other types of requests may be made, particularly when emulating a computer system as described above.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 7","b":["700","100","300","700","700","702","704","706","708","710","712","714"]},"The processing device  can include any custom made or commercially available processor, a central processing unit (CPU) or an auxiliary processor among several processors associated with the computer system , a semiconductor based microprocessor (in the form of a microchip), a macroprocessor, one or more application-specific integrated circuits (ASICs), a plurality of suitably configured digital logic gates, and other well known electrical configurations comprising discrete elements both individually and in various combinations to coordinate the overall operation of the computing system.","The memory  can include any one of a combination of volatile memory elements (e.g., random access memory (RAM, such as DRAM, SRAM, etc.)) and nonvolatile memory elements (e.g., ROM, hard drive, tape, CDROM, etc.). The memory  typically comprises an operating system , one or more applications , DELI , and an emulator  as described above. One of ordinary skill in the art will appreciate that the memory  can, and typically will, comprise other components which have been omitted for purposes of brevity.","The one or more user interface devices  comprise those components with which the user can interact with the computing system . For example, where the computing system  comprises a personal computer (PC), these components can comprise a keyboard and mouse. Where the computing system  comprises a handheld device (e.g., PDA, mobile telephone), these components can comprise function keys or buttons, a touch-sensitive screen, a stylus, etc. The display  can comprise a computer monitor or plasma screen for a PC or a liquid crystal display (LCD) for a handheld device.","With further reference to , the one or more I\/O devices  are adapted to facilitate connection of the computing system  to another system and\/or device and may therefore include one or more serial, parallel, small computer system interface (SCSI), universal serial bus (USB), IEEE 1394 (e.g., Firewire\u2122), and\/or personal area network (PAN) components. The network interface devices  comprise the various components used to transmit and\/or receive data over a network. By way of example, the network interface devices  include a device that can communicate both inputs and outputs, for instance, a modulator\/demodulator (e.g., modem), wireless (e.g., radio frequency (RF)) transceiver, a telephonic interface, a bridge, a router, network card, etc.","Various software and\/or firmware has been described herein. It is to be understood that this software and\/or firmware can be stored on any computer-readable medium for use by or in connection with any computer-related system or method. In the context of this document, a computer-readable medium denotes an electronic, magnetic, optical, or other physical device or means that can contain or store a computer program for use by or in connection with a computer-related system or method. These programs can be embodied in any computer-readable medium for use by or in connection with an instruction execution system, apparatus, or device, such as a computer-based system, processor-containing system, or other system that can fetch the instructions from the instruction execution system, apparatus, or device and execute the instructions. In the context of this document, a \u201ccomputer-readable medium\u201d can be any means that can store, communicate, propagate, or transport the program for use by or in connection with the instruction execution system, apparatus, or device.","The computer-readable medium can be, for example but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, device, or propagation medium. More specific examples (a nonexhaustive list) of the computer-readable medium include an electrical connection having one or more wires, a portable computer diskette, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM, EEPROM, or Flash memory), an optical fiber, and a portable compact disc read-only memory (CDROM). Note that the computer-readable medium can even be paper or another suitable medium upon which a program is printed, as the program can be electronically captured, via for instance optical scanning of the paper or other medium, then compiled, interpreted or otherwise processed in a suitable manner if necessary, and then stored in a computer memory.","While particular embodiments of the invention have been disclosed in detail in the foregoing description and drawings for purposes of example, it will be understood by those skilled in the art that variations and modifications thereof can be made without departing from the scope of the invention as set forth in the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention can be better understood with reference to the following drawings.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2","b":"1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 4A-4C","b":"3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 5","FIGS. 1 and 3"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6","b":"5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7","b":["1","3"]}]},"DETDESC":[{},{}]}
