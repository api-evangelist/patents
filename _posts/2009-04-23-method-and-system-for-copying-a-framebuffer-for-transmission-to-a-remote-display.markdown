---
title: Method and system for copying a framebuffer for transmission to a remote display
abstract: Remote desktop servers include a display encoder that maintains a secondary framebuffer that contains display data to be encoded and transmitted to a remote client display. The display encoder submits requests to update the display data in the secondary framebuffer to a video adapter driver that has access to a primary framebuffer whose display data is updated according to drawing commands received from applications running on the remote desktop servers. The video adapter driver utilizes a spatial data structure to track changes made to the display data located in regions of the primary framebuffer and copies the display data in those regions of the primary framebuffer to corresponding regions in the secondary framebuffer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08441494&OS=08441494&RS=08441494
owner: VMware, Inc.
number: 08441494
owner_city: Palo Alto
owner_country: US
publication_date: 20090423
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present application is related to U.S. patent application entitled \u201cMethod and System for Identifying Drawing Primitives for Selective Transmission to a Remote Display\u201d Ser. No. 12\/428,949 and filed on the same day as the present application, which is hereby incorporated by reference.","Current operating systems typically include a graphical drawing interface layer that is accessed by applications in order to render drawings on a display, such as a monitor. The graphical drawing interface layer provides applications an application programming interface (API) for drawings and converts drawing requests by such applications into a set of drawing commands that it then provides to a video adapter driver. The video adapter driver, in turn, receives the drawing commands, translates them into video adapter specific drawing primitives and forwards them to a video adapter (e.g., graphics card, integrated video chipset, etc.). The video adapter receives the drawing primitives and immediately processes them, or alternatively, stores them in a First In First Out (FIFO) buffer for sequential execution, to update a framebuffer in the video adapter that is used to generate and transmit a video signal to a coupled external display. One example of such a graphical drawing interface layer is the Graphical Device Interface (GDI) of the Microsoft\u00ae Windows operating system (OS), which is implemented as a number of user-level and kernel-level dynamically linked libraries accessible through the Windows OS.","With the rise of technologies such as server based computing (SBC) and virtual desktop infrastructure (VDI), organizations are able to replace traditional personal computers (PCs) with instances of desktops that are hosted on remote desktop servers (or virtual machines running thereon) in a data center. A thin client application installed on a user's terminal connects to a remote desktop server that transmits a graphical user interface of an operating system session for rendering on the display of the user's terminal. One example of such a remote desktop server system is Virtual Computing Network (VNC) which utilizes the Remote Framebuffer (RFB) protocol to transmit framebuffers (which contain the values for every pixel to be displayed on a screen) from the remote desktop server to the client. In order to reduce the amount of display data relating to the graphical user interface that is transmitted to the thin client application, the remote desktop server may retain a second copy of the framebuffer that reflects a prior state of the framebuffer. This second copy enables the remote desktop server to compare a prior state and current state of the framebuffer in order to identify display data differences to encode (to reduce network transmission bandwidth) and subsequently transmit onto the network to the thin client application.","However, the computing overhead of copying the framebuffer to such a secondary framebuffer can significantly deteriorate performance of the remote desktop server. For example, to continually copy data from a framebuffer that supports a resolution of 1920\u00d71200 and color depth of 24 bits per pixel to a secondary framebuffer at a rate of 60 times per second would require copying of over 3.09 Gb\/s (gigabits per second).","Display data is manipulated to reduce bandwidth requirements when transmitted to a remote client terminal. In one embodiment, a server has a primary framebuffer for storing display data and a display encoder that uses a secondary framebuffer for transmitting display data to a remote client terminal. A bounding box encompassing updates to display data in the primary framebuffer is identified and entries corresponding to the bounding box in a data structure are marked. Each entry of the data structure corresponds to a different region in the primary framebuffer and the marked entries further correspond to regions of the bounding box. Regions of the primary framebuffer are compared with corresponding regions of the secondary framebuffer and a trimmed data structure that contains marked entries only for compared regions having differences is published to the display encoder. In this manner, the display encoder is able to transmit updated display data of regions of the secondary framebuffer that correspond to marked entries in the trimmed data structure.","In one embodiment, the entries in the data structure are cleared after the publishing step to prepare for a subsequent transmission of display data to the remote terminal. In another embodiment, those regions for which the comparing step indicates differences are copied from the primary framebuffer into corresponding regions of the secondary framebuffer to provide the secondary framebuffer with updated display data.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 1","FIG. 1"],"b":["100","102","104","106","108","108","110"]},"A virtualization software layer, also referred to hereinafter as hypervisor , is installed on top of hardware platform . Hypervisor  supports virtual machine execution space  within which multiple virtual machines (VMs -) may be concurrently instantiated and executed. In one embodiment, each VM -supports a different user who is remotely connected from a different client terminal. For each of VMs -, hypervisor  manages a corresponding virtual hardware platform (i.e., virtual hardware platforms -) that includes emulated hardware implemented in software such as CPU , RAM , hard drive , NIC  and video adapter . Emulated video adapter  allocates and maintains a framebuffer , which is a portion of memory used by video adapter  that holds a buffer of the pixel values from which a video display (i.e., \u201cframe\u201d) is refreshed, and a First In First Out (FIFO) buffer , which is a portion of memory used by video adapter  that holds a list of drawing primitives that are used to update framebuffer . In one embodiment, FIFO buffer  is a shared memory buffer that is accessed and shared between video adapter  and video adapter driver .","Virtual hardware platform may function as an equivalent of a standard x86 hardware architecture such that any x86 supported operating system, e.g., Microsoft Windows\u00ae, Linux\u00ae, Solaris\u00ae x86, NetWare, FreeBSD, etc., may be installed as guest operating system (OS)  to execute applications  for an instantiated virtual machine, e.g., VM . Applications  that require drawing on a display submit drawing requests through an API offered by graphical drawing interface layer  (e.g., Microsoft Windows\u00ae GDI, in one embodiment) which, in turn, converts the drawing requests into drawing commands and transmits the drawing commands to a video adapter driver  in device driver layer . As shown in the embodiment of , video adapter driver  allocates and maintains a spatial data structure , referred to hereinafter as a \u201cblitmap\u201d data structure that keeps track of potentially changed regions of framebuffer  of video adapter . Further details on the implementation and usage of blitmap data structures are detailed later in this Detailed Description. Device driver layer  includes additional device drivers such as NIC driver  that interact with emulated devices in virtual hardware platform (e.g., virtual NIC , etc.) as if such emulated devices were the actual physical devices of hardware platform . Hypervisor  is generally responsible for taking requests from device drivers in device driver layer  that are received by emulated devices in virtual platform , and translating the requests into corresponding requests for real device drivers in a physical device driver layer of hypervisor  that communicates with real devices in hardware platform .","In order to transmit graphical user interfaces to the display of a remote client terminal, VM further includes a display encoder  that interacts with video adapter driver  (e.g., through an API) to obtain data from framebuffer  for encoding (e.g., to reduce network transmission bandwidth) and subsequent transmission onto the network through NIC driver  (e.g., through virtual NIC  and, ultimately, through physical NIC ). Display encoder  allocates and maintains a secondary framebuffer  for storing data received from framebuffer  as well as its own blitmap data structure  (hereinafter, referred to as encoder blitmap data structure ) for identifying changed regions in secondary framebuffer . In one embodiment, display encoder  continuously polls video adapter driver  (e.g., 30 or 60 times a second, for example) to copy changes made in framebuffer  to secondary framebuffer  to transmit to the remote client terminal.","Those with ordinary skill in the art will recognize that the various terms, layers and categorizations used to describe the virtualization components in  may be referred to differently without departing from their functionality or the spirit of the invention. For example, virtual hardware platforms -may be considered to be part of virtual machine monitors (VMM) -which implement the virtual system support needed to coordinate operations between hypervisor  and corresponding VMs -. Alternatively, virtual hardware platforms -may also be considered to be separate from VMMs -, and VMMs -may be considered to be separate from hypervisor . One example of hypervisor  that may be used in an embodiment of the invention is included as a component of VMware's ESX\u2122 product, which is commercially available from VMware, Inc. of Palo Alto, Calif. It should further be recognized that embodiments of the invention may be practiced in other virtualized computer systems, such as hosted virtual machine systems, where the hypervisor is implemented on top of an operating system.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 2","FIG. 2","FIG. 2","FIG. 2","FIG. 2"],"b":["154","160","142","162","160","200","205","200","205","210","215","205","200","205"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 3","FIG. 3","FIG. 3","FIG. 3","FIG. 3","FIG. 2","FIG. 3","FIGS. 2 and 3"],"sup":["N","N "],"b":["300","300","305","310","315","320","325","330","335","300","335","300","335","300","300","0","335","300","330","1","335","330","330","320","325","2","320","325","320","325","305","310","315","3","305","310","315","300","205","335","205","335","164","156","164","156"],"sub":["Q ","Q ","Q ","Q ","Q","Q ","Q "]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 4","FIG. 1"],"b":"100"},"According to the embodiment of , in step , during its execution, application  (i.e., one of applications  running on guest OS ) accesses the API of graphical drawing interface layer  (e.g., GDI in Microsoft Windows) to submit drawing requests to a screen, for example, to update its graphical user interface in response to a user action. In step , through guest OS , graphical drawing interface layer  receives the drawing requests and converts them into drawing commands that are understood by video adapter driver . In step , graphical drawing interface layer  transmits the drawing commands to video adapter driver . In step , video adapter driver  receives the drawing commands and marks entries of driver blitmap data structure  to indicate that at least a portion of pixel values in regions of framebuffer  corresponding to the marked entries of driver blitmap data structure  will be updated as a result of executing the drawing commands. In one embodiment, video adapter driver  calculates or otherwise determines an area within framebuffer , such as a rectangle of minimum size that encompasses the pixels that will be updated as a result of executing the drawing commands (i.e., also referred to as a \u201cbounding box\u201d). Video adapter driver  is then able to identify and mark all blitmap entries in driver blitmap data structure  corresponding to regions of framebuffer  that include pixel values in the determined area. In step , video adapter driver  converts the drawing commands to device specific drawing primitives and, in step , inserts the drawing primitives into FIFO buffer  (e.g., in an embodiment where FIFO buffer  is shared between video adapter driver  and video adapter ). In step , video adapter  can then ultimately update framebuffer  in accordance with the drawing primitives when they are ready to be acted upon (i.e., when such drawing primitives reach the end of FIFO buffer ).",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 5","FIG. 1"],"b":"100"},"According to the embodiment of , display encoder  is a process running on guest OS  which continually polls (e.g., 30 or 60 times a second, for example) video adapter driver  to obtain data in framebuffer  of video adapter  to encode and transmit onto the network (e.g., through NIC driver ) for receipt by a remote client terminal. In step , display encoder , via an API routine exposed to it by video adapter driver , issues a framebuffer update request to video adapter driver  and passes to video adapter driver  a memory reference (e.g., pointer) to secondary framebuffer  to enable video adapter driver  to directly modify secondary framebuffer . In step , video adapter driver  receives the framebuffer update request and, in step , it traverses its driver blitmap data structure  to identify marked blitmap entries that correspond to regions of framebuffer  that have changed since the previous framebuffer update request from display encoder  (due to drawing requests from applications as described in ). If, in step , a current blitmap entry is marked, then, in step , video adapter driver  requests the corresponding region (i.e., the pixel values in the region) of framebuffer  from video adapter . In step , video adapter  receives the request and transmits the requested region of framebuffer  to video adapter driver .","In step , video adapter driver  receives the requested region of framebuffer  and, in step , compares the pixel values in the received requested region of framebuffer  to the pixel values of the corresponding region in secondary framebuffer , which reflects a previous state of the framebuffer  upon completion of the response of video adapter driver  to the previous framebuffer update request from display encoder . This comparison step  enables video adapter driver  to identify possible inefficiencies resulting from visually redundant transmissions of drawing requests by applications as described in . For example, perhaps due a lack of focus on optimizing drawing related aspects of their functionality, some applications may issue drawing requests in step  of  that redundantly redraw their entire graphical user interface even if only a small region of the graphical user interface was actually modified by the application. Such drawing requests cause entries in driver blitmap data structure  to be marked in step  of  even if the corresponding framebuffer  regions of the marked blitmap entries need not be updated with new pixel values (i.e., the regions correspond to parts of the graphical user interface that are not actually modified). With such marked blitmap entries, comparison step  will reveal that the regions of framebuffer  and secondary framebuffer  corresponding to the marked blitmap entries are the same since the pixel values of such regions did not change due to un-optimized drawing requests submitted by applications (in step ) after completion of video adapter driver's  response to the previous framebuffer update request from display encoder .","As such, in step , if comparison step  indicates that the regions of framebuffer  and secondary framebuffer  are the same, then in step , video adapter driver  \u201ctrims\u201d driver blitmap data structure  by clearing the marked blitmap entry to indicate that no actual pixel values were changed in the corresponding region of framebuffer  since completion of video adapter driver's  response to the previous framebuffer update request from display encoder .",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 6","FIG. 1"],"b":"100"},"In step , video adapter driver  receives drawing commands from graphical drawing interface layer  and in step , identifies a bounding box in framebuffer  that encompasses all the pixel value updates resulting from executing the drawing commands. In step , video adapter driver  marks the blitmap entries in driver blitmap data structure  that correspond to regions of framebuffer  that are in (or portions of the regions are in) the bounding box. It should be recognized that steps  through  correspond to sub-steps that make up step  of . When a framebuffer update request is received from display encoder in step , video adapter driver  compares the regions of framebuffer  in the bounding box (as indicated by marked blitmap entries in driver blitmap data structure ) to corresponding regions in secondary framebuffer  (which contains the state of framebuffer  upon completion of video adapter driver's  response to the immediately prior framebuffer update request) in step . In step , video adapter driver  publishes to display encoder  a trimmed blitmap data structure whose only marked entries correspond to compared regions in step  where differences actually exist. In step , video adapter driver  clears driver blitmap data structure  of all marked entries. It should be recognized that steps  through  generally correspond to steps , ,  and  of , respectively. In step , display encoder  receives the trimmed blitmap data structure and, in step , it transmits display data in regions corresponding to marked entries in the trimmed blitmap data structure.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 7","FIG. 7","FIG. 7","FIG. 6","FIG. 6","FIG. 5"],"b":["700","142","705","156","600","154","700","700","710","156","154","610","715","154","160","615","154","710","720","710","160","620","625","725","142","545"]},"Returning to , if, however, in step , the comparison step  indicates that the regions of framebuffer  and secondary framebuffer  are different (i.e., actual pixel values in the region of framebuffer  have changed as a result of drawing requests of applications in step  since completing the response to the previous framebuffer update request from display encoder ), then in step , video adapter driver  copies the pixel values in the region of framebuffer  to the corresponding region of secondary framebuffer  to properly reflect in secondary framebuffer  the changed pixel values in the region of framebuffer . In step , if video adapter driver  has not completed traversing driver blitmap data structure , the flow returns to step . If, in step , video adapter driver  has completed traversing driver blitmap data structure , then in step , video adapter driver  provides a copy of driver blitmap data structure  to display encoder , which becomes and is referred to herein as encoder blitmap data structure . To the extent that marked blitmap entries were cleared in driver blitmap data structure  in step , encoder blitmap data structure  reflects a more optimized view of regions in secondary framebuffer  that have actual changed pixel values. In step , video adapter driver  clears all the marked blitmap entries in driver blitmap data structure  in preparation for receiving a subsequent framebuffer update request from display encoder  and indicates to display encoder  that it has completed its response to the framebuffer update request issued in step .","Upon completion of video adapter driver's  response to framebuffer update request issued by display encoder  in step , secondary framebuffer  contains all changed pixel values resulting from drawing requests from applications (from step  of ) since the completed response to the previous framebuffer update request from display encoder  and encoder blitmap data structure  contains marked blitmap entries that indicate which regions within secondary framebuffer  contain such changed pixel values. With such information, in step , display encoder  can traverse encoder blitmap data structure  for marked blitmap entries and extract only those regions in secondary framebuffer  that correspond to such marked blitmap entries for encoding and transmission to a remote client display.","Although  depicts an embodiment where display encoder  executes within virtual machine , it should be recognized that alternative embodiments may implement display encoder  in other components of remote desktop server , for example, within the virtual machine monitor or elsewhere in hypervisor . Similarly, although  depicts an embodiment where display encoder  and video adapter driver  run in a virtual machine that communicates with a virtual video adapter  in a hypervisor , it should be recognized that these components may be deployed in any remote desktop server architecture, including non-virtual machine based computing architectures. Furthermore, rather than having display encoder  and virtual video adapter  as software components of the server, alternative embodiments may utilize hardware components for each or either of them. Similarly, it should be recognized that alternative embodiments may not require any virtual video adapter. Instead, in such alternative embodiments, for example, video adapter driver  may allocate and manage framebuffer  and FIFO buffer  itself. Similarly, in alternative embodiments, video adapter  may not have a FIFO buffer such as FIFO buffer , but may immediately process incoming drawing primitives upon receipt. It should be similarly recognized that various other data structures and buffers described herein can be allocated and maintained by alternative system components. For example, rather than having display encoder  allocate and maintain secondary framebuffer  and pass a memory reference to video adapter driver  as detailed in step  of , video adapter driver  may allocate and maintain secondary framebuffer  (as well as encoder blitmap data structure ) and provide memory reference access to display encoder  in an alternative embodiment. Additionally, it should be recognized that some of the functionality and steps performed by video adapter driver  as described herein can be implemented in a separate extension or component to a pre-existing or standard video adapter driver (i.e., display encoder  may communicate with such a separate extension to the video adapter driver rather than the pre-existing video adapter driver itself). Similarly, it should be recognized that alternative embodiments may vary the amount and types of data exchanged between system components as described herein or utilize various optimization techniques. For example, rather than copying and providing all of driver blitmap data structure  as encoder blitmap data structure  in step  of , an alternative embodiment may provide only relevant portions of driver blitmap data structure  to display encoder  or otherwise utilize an alternative data structure to provide such relevant portions of driver blitmap data structure  to display encoder . Similarly, it should be recognized that caching techniques may be utilized to optimize portions of the teachings herein. For example, video adapter driver  may maintain an intermediate cache of FIFO buffer  to reduce computing overhead, for example, during step  of . Similarly, rather than (or in addition to) continuously polling video adapter driver , in alternative embodiments, display encoder  may receive callbacks or interrupts initiated by video adapter driver  when framebuffer  updates its contents and\/or additionally receive framebuffer update requests from the remote client.","The various embodiments described herein may employ various computer-implemented operations involving data stored in computer systems. For example, these operations may require physical manipulation of physical quantities usually, though not necessarily, these quantities may take the form of electrical or magnetic signals where they, or representations of them, are capable of being stored, transferred, combined, compared, or otherwise manipulated. Further, such manipulations are often referred to in terms, such as producing, identifying, determining, or comparing. Any operations described herein that form part of one or more embodiments of the invention may be useful machine operations. In addition, one or more embodiments of the invention also relate to a device or an apparatus for performing these operations. The apparatus may be specially constructed for specific required purposes, or it may be a general purpose computer selectively activated or configured by a computer program stored in the computer. In particular, various general purpose machines may be used with computer programs written in accordance with the teachings herein, or it may be more convenient to construct a more specialized apparatus to perform the required operations.","The various embodiments described herein may be practiced with other computer system configurations including hand-held devices, microprocessor systems, microprocessor-based or programmable consumer electronics, minicomputers, mainframe computers, and the like.","One or more embodiments of the present invention may be implemented as one or more computer programs or as one or more computer program modules embodied in one or more computer readable media. The term computer readable medium refers to any data storage device that can store data which can thereafter be input to a computer system computer readable media may be based on any existing or subsequently developed technology for embodying computer programs in a manner that enables them to be read by a computer. Examples of a computer readable medium include a hard drive, network attached storage (NAS), read-only memory, random-access memory (e.g., a flash memory device), a CD (Compact Discs) CD-ROM, a CD-R, or a CD-RW, a DVD (Digital Versatile Disc), a magnetic tape, and other optical and non-optical data storage devices. The computer readable medium can also be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.","Although one or more embodiments of the present invention have been described in some detail for clarity of understanding, it will be apparent that certain changes and modifications may be made within the scope of the claims. Accordingly, the described embodiments are to be considered as illustrative and not restrictive, and the scope of the claims is not to be limited to details given herein, but may be modified within the scope and equivalents of the claims. In the claims, elements and\/or steps do not imply any particular order of operation, unless explicitly stated in the claims.","In addition, while described virtualization methods have generally assumed that virtual machines present interfaces consistent with a particular hardware system, persons of ordinary skill in the art will recognize that the methods described may be used in conjunction with virtualizations that do not correspond directly to any particular hardware system. Virtualization systems in accordance with the various embodiments, implemented as hosted embodiments, non-hosted embodiments, or as embodiments that tend to blur distinctions between the two, are all envisioned. Furthermore, various virtualization operations may be wholly or partially implemented in hardware. For example, a hardware implementation may employ a look-up table for modification of storage access requests to secure non-disk data.","Many variations, modifications, additions, and improvements are possible, regardless of the degree of virtualization. The virtualization software can therefore include components of a host, console, or guest operating system that performs virtualization functions. Plural instances may be provided for components, operations or structures described herein as a single instance. Finally, boundaries between various components, operations and data stores are somewhat arbitrary, and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the invention(s). In general, structures and functionality presented as separate components in exemplary configurations may be implemented as a combined structure or component. Similarly, structures and functionality presented as a single component may be implemented as separate components. These and other variations, modifications, additions, and improvements may fall within the scope of the appended claims(s)."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
