---
title: SQL adapter business service
abstract: A Structured Query Language (SQL) adapter business service that converts data from a data set to a common representation format used for all data sets with which the SQL adapter business service interacts. Hence the SQL adapter business service can communicate with various internal and external systems independently of the native format in which those systems maintain and store data. The SQL adapter business service optimizes operations to update data in the data sets by combining operations when possible and by using result sets from executing previous SQL statements to construct subsequent SQL statements. SQL adapter business service takes advantage of parent/child relationships between tables to construct SQL statements in an order such that the SQL statements process only a minimum amount of data, thereby making retrieval of data as efficient as possible.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08489579&OS=08489579&RS=08489579
owner: Siebel Systems, Inc.
number: 08489579
owner_city: San Mateo
owner_country: US
publication_date: 20080512
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application is a continuation of U.S. patent application Ser. No. 10\/751,236, entitled \u201cMethod and System For an Operation Capable of Updating and Inserting Information In A Database\u201d, filed Jan. 2, 2004 now U.S. Pat. No. 7,373,357, naming Arjun Chadrasekar Iyer and Chandrakant Ramkrishna Bhaysar as inventors, which is a continuation of U.S. patent application Ser. No. 10\/001,095 now U.S. Pat. No. 7,552,135, entitled \u201cSQL Adapter Business Service\u201d, filed Nov. 15, 2001 now U.S. Pat. No. 7,552,135. This application is assigned to SIEBEL SYSTEMS, INC., the assignee of the present invention, and is hereby incorporated by reference, in its entirety and for all purposes.","1. Field of the Invention","This invention pertains to computerized information management and processing systems generally, and more particularly to integrating business data from source and destination data sets.","2. Description of the Related Art","Often different data sets contain business data describing the same operations and\/or entities but are not under the control of a single business enterprise. Rather than duplicate data collection and maintenance, sometimes it is more useful for an enterprise to obtain business data from an external data set and use it to update an internal data set, or vice versa. Some adapter software has been developed, but this adapter software is typically tailored for a particular source and destination data set and is not generally useful for finding a common data representation between other data sets.","Even when adapter software can take as input a mapping from a source data set to a destination data set and use the mapping to update the destination data set, such adapter software typically is very resource intensive. For example, updates to the destination data set are often performed one at a time, on a record-by-record basis for the various tables in the data sets. Furthermore, these updates usually do not take advantage of relationships between tables to optimize the updating process.","What is needed is an adapter that can operate for various forms of source and destination data sets. The adapter should optimize the updating process to combine operations on a data set to increase efficiency of the updating process.","The present invention provides a generic SQL adapter business service which can be used to construct and execute SQL statements on a data set, based upon a hierarchical SQL integration object definition. The SQL adapter business service communicates with various internal and external systems independently of the native format in which those systems maintain and store data. The SQL adapter business service optimizes operations to update data in the data sets by combining operations when possible and by using result sets from executing previous SQL statements to construct subsequent SQL statements. The SQL adapter business service takes advantage of parent\/child relationships between tables to construct SQL statements in an order such that the SQL statements process only a minimum amount of data, thereby making processing the data as efficient as possible.","One form of the invention corresponds to a method including obtaining an operation to be performed on a data set and corresponding input data, using a SQL integration object definition to determine a structure of the data set, and constructing at least one SQL statement conforming to the structure to perform the operation on the data set according to the input data. Executing the at least one SQL statement on the data set performs the operation, and the method may include executing the at least one SQL statement.","In another form, a method includes obtaining an operation to be performed on a data set and corresponding input data, constructing at least one SQL statement to perform the operation on the data set according to the input data, and executing each SQL statement on the data set once the SQL statement is constructed. Therefore, each SQL statement is executed prior to constructing a subsequent SQL statement. The method may further include constructing the subsequent SQL statement using a result set of executing a prior SQL statement.","Yet another form of the invention corresponds to a computer system including a processor and memory. The memory includes instructions to obtain an operation to be performed on a data set and corresponding input data, use a SQL integration object definition to determine a structure of the data set, and construct at least one SQL statement conforming to the structure to perform the operation on the data set according to the input data.","In still another form, a computer system includes a processor and a memory. The memory includes instructions to obtain an operation to be performed on a data set and corresponding input data, construct at least one SQL statement to perform the operation on the data set according to the input data, and execute each SQL statement on the data set once the SQL statement is constructed. Therefore, each SQL statement is executed prior to constructing a subsequent SQL statement. The memory may further include instructions to construct the subsequent SQL statement using a result set of executing a prior SQL statement.","Yet another form of the invention corresponds to a computer program product including instructions and a computer-readable memory storing the instructions. The instructions obtain an operation to be performed on a data set and corresponding input data, use a SQL integration object definition to determine a structure of the data set, and construct at least one SQL statement conforming to the structure to perform the operation on the data set according to the input data.","In still another form, a computer program product includes instructions and a computer-readable memory storing the instructions. The instructions obtain an operation to be performed on a data set and corresponding input data, construct at least one SQL statement to perform the operation on the data set according to the input data, and execute each SQL statement on the data set once the SQL statement is constructed. Therefore, each SQL statement is executed prior to constructing a subsequent SQL statement. The instructions may further construct the subsequent SQL statement using a result set of executing a prior SQL statement.","Yet another form of the invention corresponds to a signal embodied in a carrier wave including instructions for obtaining an operation to be performed on a data set and corresponding input data, using a SQL integration object definition to determine a structure of the data set, and constructing at least one SQL statement conforming to the structure to perform the operation on the data set according to the input data. Executing the at least one SQL statement on the data set performs the operation, and the signal may include instructions for executing the at least one SQL statement.","In another form, a signal embodied in a carrier wave includes instructions for obtaining an operation to be performed on a data set and corresponding input data, constructing at least one SQL statement to perform the operation on the data set according to the input data, and executing each SQL statement on the data set once the SQL statement is constructed. Therefore, each SQL statement is executed prior to constructing a subsequent SQL statement. The signal may further include instructions for constructing the subsequent SQL statement using a result set of executing a prior SQL statement.","Still another form of the invention comprises a signal embodied in a carrier wave containing data produced by the instructions described in the previous two paragraphs.","The foregoing is a summary and thus contains, by necessity, simplifications, generalizations and omissions of detail; consequently, those skilled in the art will appreciate that the summary is illustrative only and is not intended to be in any way limiting. Other aspects, inventive features, and advantages of the present invention, as defined solely by the claims, will become apparent in the non-limiting detailed description set forth below.","The use of the same reference symbols in different drawings indicates similar or identical items.","The following is intended to provide a detailed description of an example of the invention and should not be taken to be limiting of the invention itself. Rather, any number of variations may fall within the scope of the invention which is defined in the claims following the description.","In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the invention. It will be apparent, however, to one skilled in the art that the invention can be practiced without these specific details.","References in the specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the invention. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification are not necessarily all referring to the same embodiment, nor are separate or alternative embodiments mutually exclusive of other embodiments. Moreover, various features are described which may be exhibited by some embodiments and not by others. Similarly, various requirements are described which may be requirements for some embodiments but not other embodiments.","A Structured Query Language (SQL) adapter business service is provided that converts data from a data set to a common representation format that is used for all data sets with which the SQL adapter business service interacts. Hence the SQL adapter business service can communicate with various internal and external systems independently of the native format in which those systems maintain and store data. The SQL adapter business service optimizes operations to update data in the data sets by combining operations when possible and by minimizing data that must be maintained about each data set. Furthermore, the SQL adapter business service takes advantage of parent\/child relationships between tables to further optimize the updating process.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 1","b":["110","100","110","130","160","120","150","100","100"],"i":"d"},"Input data  corresponds to data that can be used to update a data set, such as rows of a database table. The term \u201cdata set\u201d is used herein to refer to a set of data, and not to refer to a particular file name or dataset name, as files are called in some operating systems. Input data  may be processed and stored in memory as an object instance or an instance of some other data structure prior to input to SQL adapter business service , in which case the object instance or instance of the other data structure serves as input to the SQL adapter business service . Alternatively, input data  can be in the form of an unformatted byte stream such as an XML document, and SQL adapter business service  can include a converter element to convert the data to an internal data structure.","SQL adapter business service  may produce output data  that is returned to calling program . Output data  may also be provided as an object instance or instance of some other data structure or as an unformatted byte stream such as an XML document. For purposes of simplicity, both input data  and output data  are described herein as conforming to a common data structure.","SQL adapter business service  is called by calling program  for the purpose of performing an operation on data in one or more data sets, at least one of which can be accessed via SQL. These data sets are described herein as databases, such as external database , but other types of data sets that are accessible via SQL are also within the scope of the invention. Calling program  may be either internal or external to system . SQL adapter business service  generates one or more SQL statements for performing the requested operation on a data set such as external database .","SQL adapter business service  can be used to transfer data between a first and second data set. For example, SQL adapter business service  can transfer data from an external database such as external database  to an internal data format and\/or from an internal data format to the external database. SQL adapter business service  may be implemented to interface directly to the internal database or SQL adapter business service  may instead interface to an in-memory business object layer (not shown) provided by system .","Metadata  includes an example of a SQL integration object definition, SQL integration object definition . A SQL integration object definition such as SQL integration object definition defines a structure to and from which data from a data set can be converted. A SQL integration object definition thus provides a common structure for data of both internal and external data sets in any format. In the embodiment shown, SQL integration object definition defines a hierarchical structure of one or more SQL integration component definitions such as SQL integration component definition . Each SQL integration component definition may include one or more SQL integration component attribute definition such as SQL integration component attribute definition , one or more SQL integration field definitions such as SQL integration field definition , and one or more SQL integration component key definitions such as SQL integration component key definition . Each SQL integration component key definition may include one or more key field definition such as key field definition ","SQL integration object instance represents an instance of SQL integration object definition containing data in the structure defined by SQL integration object definition . SQL integration object instance includes elements A, B, C and X. Input data  can be in the form of a Query by Example instance of SQL integration object definition , such as SQL integration object instance , from which SQL adapter business service  generates SQL statements to retrieve data from a data set such as external database .","For example, an Account instance may represent a specific account, such as the account for Company XYZ. All Account instances are associated with one Account integration object definition. By converting data to this common representation format, SQL adapter business service  can manipulate data from different systems independently of the source system and representation.","A SQL integration object definition such as SQL integration object definition permits the development of run-time objects that are independent of specific metadata or data formats. Elements of system  use an internal representation for manipulating objects in memory. For purposes of illustration, the internal representation for system  is described as one or more SQL integration object instances such as SQL integration object instance ; however, another embodiment may include an additional converter element to convert from another internal representation to SQL integration object instances. The external representation varies according to the external application (e.g. SAP or Oracle Applications), which is represented in  as calling program . The external representation is converted to a SQL integration object definition such as SQL integration object definition . Therefore both input data  and output data  are described herein as conforming to the structure of a common SQL integration object definition. Furthermore, if input data  comprises instances of more than one SQL integration object definition, SQL adapter business service  processes each subset of the input data corresponding to a different SQL integration object definition separately.","System  may include an element (not shown) that allows creation of a SQL integration object definition from an external metadata representation of an object. Such an element can be a wizard, in which case a separate wizard may be needed for each metadata format. Some examples of possible wizards include an eXtended Markup Language (XML) Data Type Definition (DTD) wizard; a Systeme, Anwendungen, Produkte in der Datenverarbeitung (German: Systems, Applications & Products in Data Processing) (SAP) Intermediate Document (IDOC) wizard; and a database wizard.","SQL integration object definitions and instances are further explained below with reference to .","SQL integration object instance can be input to and\/or output by data transformation engine . Data transformation engine  transforms data from SQL integration object instance to a form in which other components (not shown) of system  can use the data. Data transformation engine  can change the relationships between records, merge records, remove records, create new fields through functions on the input data fields, etc. Data transformation engine  may be implemented as a program driven by metadata . Alternatively, data transformation engine  may be a program specifically written for two data sets, each having its own data structure(s).","SQL adapter business service  can take data from a memory buffer containing a document or message and transmit it over a network protocol to external database . In addition, SQL adapter business service  can receive a message or document through the network protocol and place it in a memory buffer. Potential external protocols include Hypertext Transfer Protocol (HTTP), the operating system's file system, message queuing systems (e.g. IBM Message Queuing (MQ) Series), and Simple Mail Transfer Protocol (SMTP). Extended Markup Language (XML) documents may be transmitted to external systems as an unstructured byte stream. Alternatively, XML documents may pass through a converter, which is a software component that parses an unstructured byte buffer and creates an SQL integration object instance, or vice versa. Converters perform this parsing or generation using SQL integration object definition . An example of a converter a program that converts between an XML Document stored as a byte buffer and SQL integration object instance ","The embodiment of SQL adapter business service  shown in  assumes that validation of data in external database  is managed by an external system. Therefore, SQL integration object definition does not include validation rules for validating data in instances such as SQL integration object instance . However, in other embodiments, SQL adapter business service  may include a validation element.","SQL adapter business service  communicates using the interfaces, API's or protocols to exchange data with external database  using the native format(s) of external database . In one embodiment, SQL adapter business service  uses ODBC Database Connector API  to communicate with external database .","ODBC Database Connector API","In one embodiment, SQL adapter business service  uses ODBC database connector API  to handle database-specific issues such as cursors, database connections, etc. The ODBC database connector API is database independent and operates with numerous types of databases. In order to retrieve data from and\/or write data to external database , SQL adapter business service  passes the following connection parameters via ODBC database connector API  to connect to external database :","ODBC data source name (DSN) Database password","Database username Table owner","In one embodiment, SQL adapter business service  relies on the calling program to pass these parameters and does not explicitly retrieve values for these parameters. SQL adapter business service  passes the parameters to the ODBC database connector API  connect method for each of its method invocations. SQL adapter business service  does keeps database connection handles and performs caching of database connection handles. SQL adapter business service  also performs connection pooling, so that if a connection to a database already exists, it is reused.","In one embodiment, if an error occurs in external database , ODBC database connector API  reports the error to SQL adapter business service . Errors such as database connectivity problems, invalid table\/view\/column names and so on, are provided by SQL adapter business service  to calling program . In this embodiment, SQL adapter business service  does not attempt to interpret the semantics of these errors or to do any sort of recovery, although this functionality could be incorporated into SQL adapter business service . In this embodiment, the responsibility to pass the correct database parameters falls on the calling program  calling SQL adapter business service .","SQL Integration Object Definitions and Instances",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 2","b":"120","i":"d. "},"Input data  corresponds to instances of one or more database tables and\/or views of a database table, labeled here as database table\/view . An instance of database table\/view  corresponds to a row of data in that table\/view. Each database table\/view may include one or more database column . An instance of database column  corresponds to a data value for a column within the row of data that is an instance of database table\/view .","One database table\/view can serve as a parent table\/view to another table\/view (not shown), called a child table\/view, within the same hierarchy. The arrow from database table\/view  to itself illustrates this concept.","Database table\/view  corresponds to a SQL integration component definition such as SQL integration component definition . One SQL integration component definition such as SQL integration component can serve as a parent to another SQL integration component definition (not shown) within the same integration object definition . Database column  corresponds to a SQL integration field definition such as SQL integration field definition . A SQL integration object instance may include a hierarchy of SQL integration component instances , each of which may contain one or more SQL integration fields such as SQL integration field instance ","A SQL integration field instance can be a scalar data value stored in memory as a string. A SQL integration field definition such as SQL integration field definition may represent textual data, a number, a date, or other scalar permitted within a SQL integration component definition such as SQL integration component definition ","A SQL integration object definition such as SQL integration object definition may also contain rules for forming valid SQL integration object instances ","Referring to the example SQL integration object instance shown in , each of nodes A, B, C and X corresponds to an instance of a different SQL integration component definition. This indicates that SQL integration object definition includes at least four SQL integration component definitions, and that instances of four components are in the hierarchy of SQL integration object ","The following paragraph introduces terminology that will be used in later examples. Node A corresponds to a root component of the hierarchy and is a parent component of components B and C. Components B and C are child components of the root component A and are sibling components. A restriction imposed by SQL adapter business service  is that a given component definition can have only one parent component definition in a SQL integration object definition. Component X is a child of component C, a grandchild of component A, and is a leaf component, indicating that component X has no children.","A child component at any level of the hierarchy is a descendant of its parent and of any node in the path from its parent to the root node, including the root. A parent at any node in the hierarchy is an ancestor of its child and of any node in the path between its child and a leaf level of the hierarchy. A parent component that is not the root component can be a child of another component. The root component cannot be a child component.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 3"},"To distinguish different SQL integration component definitions, each different SQL integration component definition such as SQL integration component definition has a component type (not shown) unique to that SQL integration component definition. The component type may correspond to a table\/view name corresponding to a root database table\/view  of the hierarchy of SQL integration component definitions.","In one embodiment, a SQL integration component definition such as SQL integration component definition includes additional fields related to key fields that uniquely identify data in a data set. A SQL integration component definition such as SQL integration component definition may include one or more SQL integration component key definitions such as SQL integration component key definition , and each SQL integration component key definition may include one or more key field definitions such as key field definition to accommodate composite keys. Composite keys contain more than one database column. To accommodate composite keys, a sequence number can be included in the SQL integration component key field definition.","Each SQL integration component key definition has a key type, which may be a user key, a foreign key, or a target key. Other types of keys may also be included, such as a hierarchy parent key and a hierarchy root key; however, these key types are not used by SQL adapter business service  and are not discussed herein. User, foreign, and target keys are explained below.","User keys are keys consisting of a set of fields (e.g., a set of fields defined by SQL integration field definition ) that uniquely identifies a row in the table\/view  corresponding to a particular SQL integration component definition. User keys are used to ascertain whether a particular row exists in a data set such as external database  prior to either updating or inserting data.","SQL integration component key definition incorporates the primary key\/foreign key relationships that exist between the tables in a data set such as external database , each table being represented by a different SQL integration component definition.","In general, database tables can have foreign keys pointing to any number of other tables. For example, there may be foreign keys to a parent, ancestor, child, descendant, sibling or an arbitrarily related node. However, for a SQL integration object definition such as SQL integration object definition , foreign keys are used to represent parent\/child relationships between SQL integration component definitions only. Other types of foreign keys are not represented.","A target key corresponds to a primary key for the external table\/view corresponding to its respective SQL integration component definition. A target key can be considered to be a primary key for the parent table of a parent\/child relationship. A target key's values are included as values of a foreign key in its child instance, which is an instance of its respective SQL integration component definition.","Parent\/child relationships are ascertained via the target key and foreign key definitions. A SQL integration component definition can have multiple target and user keys but can have only one foreign key defined, as a particular SQL integration component definition can have only one parent.",{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 4","b":["122","1","122","2","122","3","122","1"],"i":["d","d","d","d"]},"Each SQL integration component definition includes SQL integration field definitions and SQL component key definitions. SQL integration component definition CUSTOMER - includes SQL integration field definitions , which defines fields Name , Location , State , Phone , and Organization (abbreviated Org) . SQL integration component definition CUSTOMER - includes SQL component key definitions , which defines Key , Key , and Key . Key is a user key comprising the Name  and Location  fields. Key is a user key comprising the Name  field. Key is a target key comprising the Name  and Location  fields, indicating that the CUSTOMER table is a parent table in a parent\/child relationship.","SQL integration component definition CUSTOMER - also includes SQL integration component attribute definition , which defines a Cascade_Delete attribute  with a value of yes. Cascade_Delete attribute  with a value of yes means that when a record is deleted from the CUSTOMER table, records in the child table are also deleted.","Similarly, SQL integration component definition CONTACT - includes SQL integration field definition , which defines fields ContactID , First Name , Last Name , Phone , Customer Name (abbreviated CustName) , and Customer Location (abbreviated CustLocation) . SQL integration component definition CUSTOMER - includes SQL component key definitions , which defines Key , Key , and Key . Key  is a user key comprising the First Name  and Last Name  fields. Key is a target key comprising the ContactID  field. Key  indicates that the CONTACT table is a parent to another table in a parent\/child relationship. Key  is a foreign key comprising the Customer Name  and Customer Location  fields. Key  indicates that the CONTACT table is a child in a parent\/child relationship.","The CONTACT table is a child to the CUSTOMER table defined in SQL integration component definition -. This parent\/child relationship is shown by arrow  from Key  filed in the CONTACT component definition - to the Key  field in the CUSTOMER component definition -. The values of foreign Key  in a row of the CONTACT table match the values of target Key  in its parent row of the CUSTOMER table.","In the last SQL integration component definition, SQL integration component definition PHONE - includes SQL integration field definition , which defines fields Area Code , Phone Number , Phone Type , and ContactID . SQL integration component definition PHONE - also includes SQL component key definitions , which defines Key  and Key . Key is a user key comprising the Phone Number  field. Key is a foreign key comprising the ContactID  field. Key indicates that the PHONE table is a child to the CONTACT table in a parent\/child relationship. As shown by arrow  from Key  in the PHONE component definition - to Key  of the CONTACT component definition, the values of foreign Key  in a row of the PHONE table match the values of target Key  in its parent row of the CONTACT table.","Note that the name of the SQL integration component to which a foreign key points is implicit by virtue of being included within the same hierarchy defined by SQL integration object definition ",{"@attributes":{"id":"p-0095","num":"0094"},"figref":["FIG. 5","FIG. 4"],"b":["120","120"],"i":["i","d "]},"SQL integration component instance - has corresponding values for each field of the SQL integration component definition. Field Name  has value \u201cCustomer1\u201d, labeled ; Location  has value \u201cSan Mateo\u201d, labeled ; State  has value \u201cCA\u201d, labeled ; Phone  has value \u201c(534)456-8976\u201d, labeled ; and Organization  has value \u201cCustomer1 Org\u201d, labeled ","Three contact records are children of the CUSTOMER instance -, CONTACT --, --, and --. The first instance CONTACT -- has values ContactID - field of \u201c1001\u201d; First Name - of \u201cPeter\u201d; Last Name - of \u201cSellers\u201d; Phone - of \u201c934-9087\u201d; Customer Name - of \u201cCustomer1\u201d; and Customer Location - of \u201cSan Mateo\u201d. The second instance CONTACT -- has values ContactID - field of \u201c1002\u201d; First Name - of \u201cSam\u201d; Last Name - of \u201cMalone\u201d; Phone - of \u201c456-9876\u201d; Customer Name - of \u201cCustomer1\u201d; and Customer Location - of \u201cSan Mateo\u201d. The third instance CONTACT -- has values ContactID - field of \u201c1003\u201d; First Name - of \u201cBette\u201d; Last Name - of \u201cMidler\u201d; Phone - of \u201c345-9876\u201d; Customer Name - of \u201cCustomer1\u201d; and Customer Location - of \u201cSan Mateo\u201d. Note that, for each record, the value of Customer Name and Customer Location (the foreign key Key ) match the values of Name and Location in the parent instance CUSTOMER - (the target key Key ).","Two phone records are children of the CONTACT instance --, PHONE instances -- and --. One phone record is a child of the CONTACT instance --, PHONE instances --. Two phone records are children of the CONTACT instance --, PHONE instances -- and --.","The first instance PHONE -- has values Area Code - of \u201c510\u201d, Phone Number - of \u201c234-7656\u201d, Phone Type - of \u201cFax\u201d, and ContactID - of \u201c1001\u201d. The second instance PHONE -- has values Area Code - of \u201c650\u201d, Phone Number - of \u201c233-4434\u201d, Phone Type - of \u201cPhone\u201d, and ContactID - of \u201c1001\u201d. Note that the ContactID  value of these two records, \u201c1001\u201d, matches the value of ContactID  in their parent record.","The third instance PHONE -- has values Area Code - of \u201c408\u201d, Phone Number - of \u201c232-3322\u201d, Phone Type - of \u201cFax\u201d, and ContactID - of \u201c1002\u201d. The ContactID  value \u201c1002\u201d of this instance matches the ContactID  value of its parent.","The fourth instance PHONE -- has values Area Code - of \u201c640\u201d, Phone Number - of \u201c232-4455\u201d, Phone Type - of \u201cPhone\u201d, and ContactID - of \u201c1003\u201d. The fifth instance PHONE -- has values Area Code - of \u201c223\u201d, Phone Number - of \u201c232-3322\u201d, Phone Type - of \u201cPhone\u201d, and ContactID - of \u201c1003\u201d. Note that the ContactID  value of these two records, \u201c1003\u201d, matches the value of ContactID  in their parent record.",{"@attributes":{"id":"p-0102","num":"0101"},"figref":"FIG. 6","b":["610","620","110"]},"Methods provided by SQL adapter business service  include query method , upsert method , delete method , synchronize method , execute method  and reverse query method . Each of these methods takes as input one or more instance of one SQL integration object definition. For input data sets in which data representing multiple SQL integration object definitions are present, a SQL adapter business service  method is called once for data for each SQL integration object definition.","Some arguments are globally accessible for all methods. For example, a MaxCursorCacheSize parameter is globally accessible for all methods. SQL adapter business service  uses ODBC Database Connector API  to access external database , and ODBC Database Connector API  provides for cursor caching. The maximum cursor cache size can be set using the MaxCursorCacheSize parameter for each of the methods of SQL adapter business service . In one embodiment, the default cursor cache size is set to 50 cursors.","Each of these methods will be described with reference to .","Query Method","In one embodiment, query method  accepts input data  in the form of a hierarchical QBE (Query By Example) instance such as SQL integration object instance . The QBE instance may include, for example, a field value uniquely identifying a record of a table corresponding to a SQL integration component definition of the SQL integration object definition corresponding to the SQL integration object instance. Such a field value is referred to herein as a search specification. Alternatively, the QBE instance may include no data values, in which case query method  queries for all data corresponding to the SQL integration object definition.","In other embodiments, input data  can be in other forms, and SQL adapter business service  or another converter module may convert input data  to one or more QBE instances. In addition, for purposes of simplicity, input data  is described herein as a set of QBE instances of one SQL integration object definition such as SQL integration object definition . However, input data  may include data that corresponds to different SQL integration object definitions. Query method  may process data for each SQL integration object definition separately according to the flowcharts described in  herein.","Query method  returns output data  in the form of one or more SQL integration object instances . A search specification for data to be included in output data  can be specified at any level of the hierarchy of the QBE instance. For example, a search specification may include a unique identifier for a root SQL integration component instance sitting at the root of the hierarchy of the QBE instance, such as root node A of . If calling program  does not specify a search specification, query method  will retrieve all rows from the database table\/view  corresponding to the root SQL integration component definition and all rows of children tables defined as part of the SQL integration object definition corresponding to the SQL integration object definition for the QBE instance.","In the following discussion, the following terminology is used. The term \u201cSQL integration component definition\u201d is sometimes referred to as \u201ccomponent definition\u201d or simply \u201ccomponent.\u201d Similarly, the term \u201cSQL integration component instance\u201d is referred to as \u201ccomponent instance\u201d or \u201cinstance\u201d of a corresponding SQL integration component definition that is clear from the context.",{"@attributes":{"id":"p-0111","num":"0110"},"figref":"FIG. 7","b":["710","110","120","110"],"i":"d"},"In Construct and Execute SQL Statements step , SQL statements to retrieve data corresponding to the search specification for each component are constructed and executed. Construct and Execute SQL Statements step  is further explained with reference to ,  and . Join Result Sets step  joins the results of the execution of each SQL statement to produce output data . In Provide Output Data step , output data  is provided. In one embodiment, output data  is provided in the form of SQL integration object instances. It is contemplated that, in some embodiments, a subset of output data  may be provided.","Query method  can be optimized by setting a parameter called MaxSqlClauses, which can be set to any integer greater than or equal to one (). In one embodiment, the default value of MaxSqlClauses is 100. The MaxSqlClauses parameter is used to limit the number of parent SQL integration component instances that the SQL adapter business service  groups (combines using OR) in creating a SQL statement. If MaxSqlClauses parameter has a value of one (), then SQL adapter business service  executes one query to retrieve each parent SQL integration component instance to be included in output data . The MaxSqlClauses parameter may be used to limit the number of data values that are combined using OR for a particular data field as well.","The MaxSqlClauses parameter is useful in restricting the length of the SQL statements, which have an upper limit imposed by ODBC specifications. According to the Microsoft Developer's Network Library ODBC Programming Reference (January 2001), a limit of 65K characters may be used. Note that, the higher the value of the MaxSqlClauses parameter, the more efficient is the execution of query method , as fewer SQL statements need to be executed.","Query method  can be controlled by another method argument called TemplateQuery. By default one or more SQL integration object instance , with instances for every component in the entire hierarchy, including sibling components, are returned as part of output data . If the TemplateQuery parameter is not set, SQL adapter business service  descends the entire hierarchy and includes output data from each level of the hierarchy defined in SQL integration object definition ","If the TemplateQuery parameter is set, SQL adapter business service  restricts the output hierarchy to the components specified in the QBE instance. For example, if input data  only consists of a root SQL integration component instance, output data  consists of one or more SQL integration component instance for only the root component.",{"@attributes":{"id":"p-0117","num":"0116"},"figref":["FIG. 8","FIG. 7"],"b":"720"},"Constructing SQL statements for a query operation begins at the root component of a SQL integration object definition. As described above, SQL adapter business service  processes one SQL integration object definition at a time; i.e., input data  is provided as instances of one SQL integration object definition and SQL adapter business service  may be invoked multiple times to process all input data . The entire SQL integration object definition is traversed starting at the root component definition, and a complete hierarchy of SQL integration object instances is returned as part of output data . If the input data does not include a parent component instance, but does include a descendant component instance, a SQL statement must be constructed for the parent component as well.","In Select Root Component from SQL Integration Object Definition as Current Component step , the root component is selected. In Does Input Data Include Instance of Current Component or a Descendant decision point , the input data is examined to determine whether it includes an instance of the SQL integration component definition for the currently selected component. If not, the input data is also examined for descendant component instances of descendants of the current component definition (children, grandchildren, and so on).","If no instance of the current component or a descendant appears in the input data, control proceeds to limit hierarchy decision point . If an instance of the current component or a descendant appears in the input data, control proceeds to Generate and Execute SQL for Current Component step .","In Generate and Execute SQL for Current Component step , SQL statements to retrieve records meeting the search specification criteria for the current component are generated and executed. In the preferred embodiment, each SQL statement is executed when it is generated, because the result set of the previous SQL statement can be used to construct a subsequent SQL statement. Generate and Execute SQL for Current Component step  is discussed further with respect to . Control proceeds to Mark Current Component as Complete step , where the current component is marked as complete. Because generation and execution of SQL statements begins with the root component of the SQL integration object definition and traverses children and then sibling components, a component is marked to indicate that SQL has been generated for that component. Only unmarked components are selected for generation and execution of SQL statements, so that no SQL statements are generated when the traversal encounters the component definition again. Other embodiments may include an alternative mechanism to marking to ensure that SQL statements are not generated when a SQL integration component definition is encountered a second time during the traversal of the SQL integration object definition.","Control proceeds from Mark Current Component as Complete step  to Limit Hierarchy decision point . The purpose of the limit hierarchy decision points is to determine whether a parameter is set to limit the output hierarchy to only those components for which instances appear in the input data. Limit Hierarchy decision points are optional and correspond to implementations in which the Template Query parameter, described above, is used. If the Limit Hierarchy parameter is set, only components for which instances appear in the input data, and ancestors of those components, are included in output data . Control proceeds to Child Unmarked decision point .","From Limit Hierarchy decision point  when the Limit Hierarchy parameter is not set, or in an implementation where the output data hierarchy is not limited, control proceeds to Does SQL Integration Object Definition Show Child decision point . By default, an entire hierarchy corresponding to the input data with instances of all components included in the input SQL integration object definition are included in output data . If a child exists in the SQL integration object definition, control proceeds to Child Unmarked decision point . If no child exists in the SQL integration object definition, control proceeds to Sibling Unmarked decision point .","In Child Unmarked decision point , a determination is made whether an unmarked child component exists. As described above, a component is marked as complete in Mark Current Component as Complete step  after SQL for the current component is generated and executed. If an unmarked child exists, then additional SQL needs to be generated for the unmarked child component and control proceeds to Select Unmarked Child Component as Current Component step . If no unmarked child exists at Child Unmarked decision point , control proceeds to Sibling Unmarked decision point .","In Select Unmarked Child Component as Current Component step , the unmarked child component is selected as the current component. Control proceeds to Does Input Data include Instance of Current Component or a Descendant decision point  to process the newly selected current component.","In Sibling Unmarked decision point , a determination is made whether an unmarked sibling component exists. If so, control proceeds to Select Unmarked Sibling Component as Current Component step . Control proceeds to Does Input Data include Instance of Current Component or a Descendant decision point  to process the newly selected current component.","If no unmarked sibling component exists in Sibling Unmarked decision point , generation and execution of SQL statements for all components of the SQL integration object definition corresponding to the input data is complete. Construct and Execute SQL Statements step  of  is complete and control proceeds to Join Results Set step .","If, in Does Input Data include Instance of Current Component or a Descendant decision point , the input data does not include an instance, control proceeds to limit hierarchy decision point . If the hierarchy is not limited, control proceeds to Generate and Execute SQL for Current Component step . An entire hierarchy corresponding to the input data with instances of all components included in the input SQL integration object definition are included in output data . If, in Limit Hierarchy decision point , the hierarchy is limited, control proceeds to Sibling Unmarked decision point , because no SQL statement is needed for the current component.",{"@attributes":{"id":"p-0129","num":"0128"},"figref":"FIG. 9","b":"830"},"One of skill in the art will recognize that there are several possible approaches for generating SQL statements from a SQL integration object instance. For example, a flat denormalized data set can be created by doing a join for all tables corresponding to SQL integration component definitions of the SQL integration object definition, and a SQL statement could be generated for the denormalized data set. However, such an implementation would be unwieldy and would not take advantage of the relationships between the tables.","Alternatively, multiple SQL statements without joins can be created and executed, and the result sets joined. The second approach is preferred because a SQL statement is generated for each table, producing simpler code and allowing a variety of relationships to be represented. Furthermore, SQL statements incorporating joins are subject to variation in syntax and operational results, so that omitting joins within a SQL statement increases the ability to integrate data from a broader range of internal and external data sets.","With the second approach, one of skill in the art will also recognize that a hierarchical SQL integration object definition can be traversed according to either a breadth-first or a depth-first traversal. Because of the hierarchical nature of a parent\/child relationship between tables, a depth-first traversal is preferred.","A new SQL statement is started for each SQL integration component definition in the SQL integration object definition corresponding to the QBE instance. In Start New Current Component SQL Statement step , a new SQL statement for the current component is begun.","In Search Spec Indicates All Records decision point , a determination is made whether all records are to be obtained from the table corresponding to the current component. For example, when the input data does not include a unique identifier for an instance of a given component, then the search specification indicates that all records from the corresponding table are to be obtained. When the search specification indicates all records, control proceeds to Generate SELECT Clause from Current Component for All Records step . For example, a SELECT clause such as","SELECT field, field from TABLE","where TABLE is the table corresponding to the current component may be generated. The SQL integration fields to include, here field and field, may be determined from the SQL integration object definition associated with the QBE instance. No WHERE clause is added to the SQL statement started for the current component so that all records are selected.","Note that selecting all records from the corresponding table produces a result set in which each record from the corresponding table may not have children records specified at a lower level of the SQL integration object instance in the input data. It is within the scope of the invention to later eliminate such \u201cchildless\u201d records from the ultimate output data as appropriate for a given implementation of SQL adapter business service . For example, output data  provided as a result of Provide Output Data step  of  may exclude these childless records.","From Search Spec Indicates All Records decision point , control proceeds to Current Component is Child decision point .","At Search Spec Indicates All Records decision point , if all records are not indicated, a unique identifier for an instance of the current component is included in the input data and control proceeds to Generate SELECT from Current Component and WHERE clauses step . A SELECT clause such as that illustrated above is generated and a WHERE clause, comprising only the WHERE keyword, is concatenated to the SELECT clause. Control proceeds to Room for Another Selection Clause decision point , where a determination is made whether there is room for another selection clause in the current component SQL statement. This determination can be made, for example, by using the MaxSqlClauses parameter described above.","If, in Room for Another Selection Clause decision point , the current component SQL statement has reached its maximum length, control proceeds to Start New Current Component SQL Statement step . Control then returns to Generate SELECT from Current Component and Where Clauses step .","If, in Room for Another Clause decision point , there is room for another clause in the current component SQL statement, control proceeds to Select Unmarked Instance of Current Component as Current Instance step . A SQL integration component instance of the current component definition is selected from the input data. Control proceeds to Generate Selection Clause to Select Current Instance step . For example, a selection clause such as","field=2","may be generated.","In Concatenate Selection Clause to WHERE clause step , the selection clause is concatenated to the WHERE clause of the SQL statement. In the example above, the resulting SQL statement is given below:","SELECT field, field from TABLE","WHERE field=2","In Mark Current Instance step , the current instance in the input data is marked so that a selection clause for that instance will not be generated again.","Unmarked Instances in Search Spec decision point  determines whether additional unmarked instances of the current component appear in the input data. If so, control returns to Room for Another Selection Clause decision point .","If, for the example above, at this point there is room for another clause, an additional selection clause will be generated in Generate Selection Clause to Select Current Instance step , and the additional selection clause is concatenated to the WHERE clause in Concatenate Selection Clause to WHERE Clause step . For example, if the second selection clause were","field=3","the resulting SQL statement is given below:","SELECT field, field from TABLE","WHERE field=2 OR field=3","Note that an OR operator is added between the two selection clauses when the second selection clause is concatenated.","If in Unmarked Instances in Search Specification decision point , no additional unmarked instances are in the input data, control proceeds to Current Component is Child decision point . Current Component is Child decision point  can also be reached directly from Generate SELECT clause from Current Component for All Records step .","In Current Component is Child decision point , a determination is made whether the current component is a child component. At this point, the SQL statement constructed thus far for the current component is referred to herein as the Current Component SQL Statement. If the current component is a child component, an additional parent selection clause is added to the Current Component SQL statement to restrict the selected records to only those that also have parent records selected in the parent component. This additional selection clause is added in Add Parent Selection Clause step , which is explained in further detail with reference to .","Control then proceeds to Unmarked Instances in Search Spec decision point . If unmarked instances remain in the input data, then the previous current component SQL statement exceeded a maximum length before selecting all instances. Control proceeds to Start New Current Component SQL Statement step , where a new SQL statement for the current component is begun to process the remaining instances. If no unmarked instances remain in Unmarked Instances in Search Spec decision point , Generate and Execute SQL for Current Component step  of  is complete and control proceeds to Mark Current Component as Complete step .","In Current Component is Child decision point , if the current component is not a child component, the Current Component SQL statement is executed. Generate and Execute SQL for Current Component step  of  is complete and control proceeds to Mark Current Component as Complete step .",{"@attributes":{"id":"p-0157","num":"0156"},"figref":["FIG. 10","FIG. 4"],"b":["970","120"],"i":"d "},"Assume that the CUSTOMER table has at least the following records:",{"@attributes":{"id":"p-0159","num":"0158"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]},{"entry":[{},"Name","Location","State","Phone","Org"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Peter1","San Mateo","CA","673-9876","Siebel"]},{"entry":[{},"Peter2","Belmont","CA","573-9873","Allied"]},{"entry":[{},"Peter3","Palo Alto","CA","373-9876","BlueCross"]},{"entry":[{},"Peter4","Austin","TX","273-9876","Siebel"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]}]}}}}},"Assume that the input QBE instance for CUSTOMER has a search specification of \u201cState=CA\u201d. The SQL statement for the CUSTOMER table is given below:","SELECT Name, Location, State, Phone, Org","FROM Customer","WHERE State=\u201cCA\u201d","This query will result in the first three Customer records shown above. Three CUSTOMER component instances are created and are referred to herein as Customer component instances 1, 2, and 3, respectively.","Also assume that the CONTACT table has the following records:",{"@attributes":{"id":"p-0166","num":"0165"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["ContactId","FirstName","LastName","CustName","CustLocation"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","Peter","Fong","Peter1","San Mateo"]},{"entry":["2","Mark","Fong","Peter1","San Mateo"]},{"entry":["3","Joe","Fong","Peter2","Belmont"]},{"entry":["4","Doug","Fong","Peter4","Austin"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"Assume that the QBE instance includes a search specification of LastName=Fong for the CONTACT component. To construct the SQL statement for the CONTACT component, only children of the three selected customer records that also have a LastName value of Fong are of interest. The SQL statement constructed for the CONTACT component is given below:",{"@attributes":{"id":"p-0168","num":"0167"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"SELECT ContactId, FirstName, LastName, CustName, CustLocation"},{"entry":"FROM Contact"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["WHERE","LastName = Fong AND"]},{"entry":[{},"((CustName = Peter1 AND CustLocation = San Mateo) OR"]},{"entry":[{},"(CustName = Peter2 AND CustLocation = Belmont) OR"]},{"entry":[{},"(CustName = Peter3 AND CustLocation = Palo Alto))"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"This query results in the first three records of the CONTACT table being fetched and corresponding CONTACT SQL integration object instances constructed, referred to herein as CONTACT component instances 1, 2 and 3, respectively. Note that the fourth record of CONTACT, which also indicates a LastName value of Fong, is not selected because its parent does not meet the CUSTOMER State specification of CA.","Each CONTACT SQL integration component instance is attached to its parent component instance. For example, CONTACT SQL integration component instances 1 and 2 are added as children of CUSTOMER SQL integration component instance 1. Contact SQL integration component instance 3 is added as a child of CUSTOMER SQL integration component instance 2. CUSTOMER SQL integration object instance 3 has no children CONTACT SQL integration component instances because no CONTACT records with a LastName of Fong are its children.","To illustrate the efficiencies made possible by the present invention, if the MaxSqlClauses parameter is specified as 2, then the following two SQL statements would be executed because only 2 parents can be grouped in one SQL statement.",{"@attributes":{"id":"p-0172","num":"0171"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"SELECT ContactId, FirstName, LastName, CustName, CustLocation"},{"entry":"FROM Contact"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["WHERE","LastName = Fong AND"]},{"entry":[{},"((CustName = Peter1 AND CustLocation = San Mateo) OR"]},{"entry":[{},"(CustName = Peter2 AND CustLocation = Belmont))"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"This query would fetch the first three rows from the CONTACT table. The corresponding CONTACT SQL integration component instances are created and attached to their respective parent instances. Thereafter, another SQL statement is generated as follows:",{"@attributes":{"id":"p-0174","num":"0173"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"SELECT ContactId, FirstName, LastName, CustName, CustLocation"},{"entry":"FROM Contact"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["WHERE","LastName = Fong AND"]},{"entry":[{},"((CustName = Peter3 AND CustLocation = Palo Alto))"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"No CONTACT records are retrieved, and no CONTACT SQL integration component instances are created.","Referring to , a flowchart providing steps for creating these SQL statements is given. In Obtain Parent Result Set step , the result set generated by executing the SQL statement corresponding to the parent of the current component is obtained. Because a SQL integration object definition is traversed according to the steps of the flowchart of , SQL statements for a parent component are generated and executed prior to SQL statements for its children. Executing the SQL statements for the parent component produces the parent result set. Therefore, the parent result set is available at the time SQL statements for its children components are generated. In Start Parent Selection Clause step , a new SQL clause specifically for selecting parent records is started. This parent clause is concatenated to the existing Current Component SQL statement. In the example given above, the Current Component SQL Statement appears as follows:",{"@attributes":{"id":"p-0177","num":"0176"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"SELECT ContactId, FirstName, LastName, CustName, CustLocation"},{"entry":"FROM Contact"},{"entry":"WHERE\u2003\u2003LastName = Fong"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The parent selection clause is built incrementally by concatenating parent instance clauses to the WHERE clause of the Current Component SQL Statement. Therefore, at Room for Another Clause decision point , a determination is made whether the Current Component SQL Statement has reached the maximum number of SQL clauses allowed. The maximum number of SQL clauses may be specified in the MaxSqlClauses parameter. If the Current Component SQL statement has reached its maximum length, control proceeds to Concatenate Parent Selection Clause and Current Component SQL Statement as Final SQL Statement step .","If another SQL clause can be concatenated at Room for Another Clause decision point , control proceeds to Select Current Parent Instance from Parent Result Step step . A current parent instance is selected and control proceeds to Generate Parent Instance Clause: Foreign Key Name=Value of Target Key Field in Parent Instance step . When generating the parent instance clause to be concatenated to the Current Component SQL Statement, the foreign key definition for the current component is used. Note that a particular component has only one foreign key definition, as a component can be a child of only one parent. The foreign key defined for the current component is set to a value of the target key field of the parent instance selected.","Control proceeds to Concatenate Parent Instance Clause to Parent Selection Clause step . Control then proceeds to More Parent Instances decision point , where a determination is made whether additional parent instances exist in the parent result set. If so, control returns to Room for Another Clause decision point , discussed previously. If not, control proceeds to Concatenate Parent Selection Clause and Current Component SQL Statement as Final SQL Statement step .","Referring back to the example above and , recall that the target key of the CUSTOMER TABLE is Name, Location and the foreign key of the CONTACT table is CustName, CustLocation. Also recall the following records in the CUSTOMER TABLE:",{"@attributes":{"id":"p-0182","num":"0181"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]},{"entry":[{},"Name","Location","State","Phone","Org"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Peter1","San Mateo","CA","673-9876","Siebel"]},{"entry":[{},"Peter2","Belmont","CA","573-9873","Allied"]},{"entry":[{},"Peter3","Palo Alto","CA","373-9876","BlueCross"]},{"entry":[{},"Peter4","Austin","TX","273-9876","Siebel"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]}]}}}}},"In addition, recall the CONTACT children records:",{"@attributes":{"id":"p-0184","num":"0183"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["ContactId","FirstName","LastName","CustName","CustLocation"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","Peter","Fong","Peter1","San Mateo"]},{"entry":["2","Mark","Fong","Peter1","San Mateo"]},{"entry":["3","Joe","Fong","Peter2","Belmont"]},{"entry":["4","Doug","Fong","Peter4","Austin"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"Assume that CUSTOMER SQL integration component instance 1 is selected as the parent instance. The parent selection clause generated is the following:","(CustName=Peter1 AND CustLocation=San Mateo)","and the resulting SQL Statement after concatenation in Concatenate Parent Instance Clause to Parent Selection Clause step  is the following:",{"@attributes":{"id":"p-0187","num":"0186"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"SELECT ContactId, FirstName, LastName, CustName, CustLocation"},{"entry":"FROM Contact"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["WHERE","LastName = Fong AND"]},{"entry":[{},"(CustName = Peter1 AND CustLocation = San Mateo)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Assume that another iteration of steps  through  occurs, there is room for another clause, and an additional parent instance is selected. When CUSTOMER SQL integration component instance 2 is selected as the parent instance, the parent selection clause generated is the following:","(CustName=Peter2 AND CustLocation=Belmont)","and the resulting SQL statement after concatenation is the following:",{"@attributes":{"id":"p-0190","num":"0189"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"SELECT ContactId, FirstName, LastName, CustName, CustLocation"},{"entry":"FROM Contact"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["WHERE","LastName = Fong AND"]},{"entry":[{},"((CustName = Peter1 AND CustLocation = San Mateo) OR"]},{"entry":[{},"(CustName = Peter2 AND CustLocation = Belmont))"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Parent instance selection clauses are combined using OR to create the parent selection clause. The process of building the parent selection clause by adding parent instance selection clauses is repeated until a limitation of the length of the SQL statement is reached. As many parent instances are concatenated as possible so that fewer SQL statements retrieve all the desired records. In More Parent Instances decision point , whether additional parent instances exists is determined. If so, control returns to Room for Another Clause decision point , where the value of the MaxSqlClauses parameter is tested. If additional parent clauses do not exist, the parent selection clause is complete and control proceeds to Concatenate Parent Selection Clause and Current Component SQL Statement step .","In Concatenate Parent Selection Clause and Current Component SQL Statement as Final SQL Statement step , the parent selection clause is concatenated to the Current Component SQL Statement to form a final SQL statement to be executed. Control proceeds to Mark Parent Instance Complete step , where the parent instances included in the parent selection clause are marked as complete. This step is necessary because all parent instances may not be included in a single final SQL statement due to the MaxSqlClauses parameter, as illustrated with the two SQL statements in the example above. Control proceeds to Execute Final SQL Statement step , where the final SQL statement is executed. Control proceeds to Unmarked Parent Instance Remains decision point . If an unmarked parent instance remains, control proceeds to Start New Parent Selection Clause step . Another final SQL statement will be generated from the new parent selection clause and the Current Component SQL Statement, which remained unchanged in the previous iteration of steps  through . Control then proceeds to Select Current Parent Instance from Parent Result Set step , where an additional parent instance is selected.","If no unmarked parent instance remains in Unmarked Parent Instance Remains decision point , Add Parent Selection Clause step  of  is complete. Generate and Execute SQL for Current Component step  of  is also complete, and control proceeds to Mark Current Component as Complete step .","Other parameters for query method  are shown in Table 1 below.",{"@attributes":{"id":"p-0195","num":"0194"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":[{},{},"Input\/","Data",{}]},{"entry":["Parameter Name","Required?","Output","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["NumOutputObjects","Yes","Output","Number","Number of Output SQL Integration Object Instances"]},{"entry":["OutputIntObjectFormat","No","Input","String","Output SQL Integration Object Definition defines the format"]},{"entry":["Message","Yes","Input\/","Hierarchy","Input\/Output Property set should have a Message as its child"]},{"entry":[{},{},"Output"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"Upsert Method","Upsert method  does an insert or an update depending upon whether the data specified in input data  exists in a destination data set such as external database . To determine whether the data should be updated or inserted, user keys are used to search for the record in the destination data set.","Input data  for the upsert method can be the actual data as the data should appear in the destination data set, such as external database , in the hierarchical form of a SQL integration object instance. SQL adapter business service  optimizes the update or insertion of child record data for a particular parent component instance. This optimization uses the ratio of the number of children database rows in the destination data set related to the parent component instance to the number of SQL integration component instances that are children of the parent component instance in input data . This optimization is turned on by default.","A parameter called OptimizeUpsertOff is used to turn off the optimization. When optimization is turned off, upsert method  queries the data set for each SQL integration component instance in input data . The upsert operation may be very expensive if the number of SQL integration component instances in the input is very large, but will be efficient if the number of rows in the database is very large compared to the number of SQL integration component instances in the input.","Upsert method  supports input in the form of multiple user key specifications to find the matching row in the database. If none of the user keys specified have all the fields set, an error is returned. A null value for any of the user key fields is valid.",{"@attributes":{"id":"p-0201","num":"0200"},"figref":"FIG. 11","b":["1110","1120","1130","1140"]},{"@attributes":{"id":"p-0202","num":"0201"},"figref":"FIG. 12"},"In an upsert data set operation, the calling program such as calling program  provides a complete copy of the source data set to be upserted into the destination data set. In one embodiment, the source data are loaded into one or more SQL integration object instance by calling program . Calling program  provides instances of one SQL integration object definition for each invocation of SQL adapter business service  to perform an upsert data set operation.","In the embodiment of , in Select Root Component as Current Component step , a root SQL integration component definition is selected. The SQL integration object definition is traversed beginning with the root component.","In Current Component Marked decision point , a determination is made whether the current component is marked. If the current component is marked, data corresponding to the current component has already been upserted into the destination data set and control proceeds to Unmarked Descendant Components of Root Remain decision point . If the current component is not marked, control proceeds to Current Component is Child decision point .","In Current Component is Child decision point , a determination whether the current component is the child of another component is made. All components in the hierarchy other than the root component have a parent component. When the current component is a child, control proceeds to Check for Optimized Upsert of Current Component Instances step . Either an optimized upsert or a regular upsert is performed during the execution of Check for Optimized Upsert of Current Component Instances step . Check for Optimized Upsert of Current Component Instances step  is discussed further with regard to .","When the current component is not a child at Current Component is Child decision point , control proceeds to Construct and Execute SQL Statements to Upsert All Instances of Current Component into Destination Data Set step . For each current component instance, the procedure described in  is performed. Note that, in , one query of the destination data set is performed for each component instance in Query Destination Data Set for Record Matching Instance step . Thus the upsert is not optimized.","Returning to , control then proceeds from Construct and Execute SQL Statements to Upsert All Instances of Current Component into Destination Data Set step  to Mark Current Component step .","Mark Current Component step  can be reached from either Construct and Execute SQL Statements to Upsert All Instances of Current Component into Destination Data Set step  or Check for Optimized Upsert of Current Component Instances step . The current component is marked to indicate that corresponding records for the current component have been upserted into the destination data set. Control then proceeds to Select Unmarked Descendant Component as Current Component step . An unmarked descendant component of the root component is selected as the current component and upsert SQL statements are generated and executed for the new current component.",{"@attributes":{"id":"p-0210","num":"0209"},"figref":"FIG. 13","b":["1260","1310"]},"In Determine N=Number of Children Instances of Current Parent Component Instance step , a value for N is calculated as the number of children instances of the current parent component instance. In Retrieve Parent Data Set Record Corresponding to Current Parent Component Instance step , the data set record corresponding to the current parent component instance selected is retrieved.","In Determine M=Number of Children Records of Parent Data Set Record step , a value for M is calculated as the number of children of the parent record retrieved. In N>>M decision point , the values of N and M are compared. The symbol \u201c>>\u201d is used to indicate a \u201cmuch larger\u201d operator. In one embodiment, N is considered to be much larger than M when the ratio of N to M has a value of seven (7) or higher. The comparison of N and M determines provides the check whether the upsert operation can be optimized.","If N is much larger than M, control proceeds to Determine Operations in Memory and Perform Operations step , where an optimized upsert operation is performed. Determine Operations in Memory and Perform Operations step  is described in further detail with reference to .","If the value of N is not much larger than M, control proceeds to Access Destination Data Set for Each Child Instance to Determine and Perform Operations step . Access Destination Data Set for Each Child Instance to Determine and Perform Operations step  is described in further detail with reference to .","From either of Determine Operations in Memory and Perform Operations step  and Access Destination Data Set for Each Child Instance to Determine and Perform Operations step , control proceeds to More Parent Component Instances decision point .","If additional parent component instances remain, control returns to Select Current Parent Component Instance of Parent Component Instances step . If no additional parent component instances remain, Check for Optimized Upsert of Child Component Instances step  is complete and the upsert data set operation of  is complete.",{"@attributes":{"id":"p-0217","num":"0216"},"figref":"FIG. 14A","b":["1360","1410"]},"In Select Child Instance of Source Data Set step , a child instance of the source data set is selected from memory. Control proceeds to Determine Operation to Perform for Child Instance step , where an in-memory test is made to determine whether a corresponding child record should be updated or inserted. Control proceeds to Construct and Execute SQL Statement to Perform Operation on Destination Data Set step , where the child record is either updated or insert according to the operation determined. Control proceeds to More Child Instances decision point , where a determination is made whether additional child instances exist in the source data set. If so, control returns to Select Child Instance of Source Data Set step . If not, the Determine Operations in Memory and Perform Operations step  is complete and control proceeds to More Parent Component Instances decision point  of .",{"@attributes":{"id":"p-0219","num":"0218"},"figref":"FIG. 14B","b":"1370"},"In Select Child Instance of Source Data Set step , a child instance of the source data set is selected. Control proceeds to Construct and Execute SQL Statement to Upsert Child Record into Destination Data Set step , where a child record corresponding to the child instance is upserted (according to the upsert data record operation of ). As described above, in Query Destination Data Set for Record Matching Instance step  of , the data set to be updated is queried using user keys to determine whether the record is present in the data set. Control proceeds to More Child Instances decision point , where a determination is made whether additional child instances in the source data set exist. If so, control returns to Select Child Instance of Source Data Set step . If not, Access Destination Data Set for Each Child Instance to Determine and Perform Operations step  is complete and control proceeds to More Parent Component Instances decision point  of .","Additional parameters for the upsert method  are given in Table 2.",{"@attributes":{"id":"p-0222","num":"0221"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Parameter",{},"Input\/","Data",{}]},{"entry":["Name","Required?","Output","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Message","Yes","Input\/","Hierarchy","Input\/Output Property set"]},{"entry":[{},{},"Output",{},"should have a message as"]},{"entry":[{},{},{},{},"its child."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"Delete Method","Delete method  takes a QBE instance as input and deletes the entire record hierarchy rooted at the specified root SQL integration component instance . In one embodiment, a search specification identifying the data record to be deleted is only allowed at the root component level of an SQL integration object definition. If no search specification is given, all rows from the database table\/view  corresponding to the root component are deleted. A Cascade_Delete component attribute, as shown in SQL integration component attribute  of , can be specified in SQL integration object definition for each SQL integration component definition . If the Cascade_Delete attribute is set, then a given instance of a child SQL integration component is also deleted on deletion of its parent instance. As described above, parent\/child relationships are ascertained by the foreign key and target key defined in SQL integration component key definition ",{"@attributes":{"id":"p-0225","num":"0224"},"figref":"FIG. 15","b":"1505"},"In Query Data Set for Root Record Matching Root Component Instance step , a query of the destination data set is made for the root instance to be deleted. In Root Record Present decision point , a determination is made whether the root record to be deleted exists in the destination data set. If no record is present, control proceeds to Another Root Component Instance decision point .","If the root record is present in Root Record Present decision point , control proceeds to Mark Root Record for step . In the delete record hierarchy operation, records are marked and not deleted during traversal of the SQL integration object definition so that descendant component instances can be located to traverse. The root record is marked for deletion and control proceeds to Root Record has Children decision point . If the root record had no children records, control proceeds to Delete Marked Records step . If the root record had children, control proceeds to Select Current Descendant Component step .","In Select Current Descendant Component step , a descendant component of the root component is selected. Control proceeds to Cascade Delete Set decision point . If the Cascade_Delete attribute is set, control proceeds to Mark Descendant Records of Parent Record for Delete step  and the children records in the current descendant component are also marked for deletion. If the Cascade_Delete attribute is not set, control proceeds to Delete Marked Records step .","In Mark Descendant Records of Parent Record for Delete step , all descendants of the parent record present in the current descendant component are marked for deletion. Control proceeds to Another Descendant Component has Child of Root decision point .","If, in Another Descendant Component has Child of Root decision point , another descendant component of the root component has children records of the parent record, control proceeds to Select Current Descendant Component step . If not, control proceeds to Delete Marked Records step .","In Delete Marked Records step , all records marked for deletion in all tables corresponding to component definitions of the SQL integration object definition are deleted. A separate SQL statement to delete marked records for each component is executed. Control proceeds to Another Root Component Instance decision point .","If, in Another Root Component Instance decision point , another root component instance exists, control returns to Select Root Component Instance step  to select another instance of the root component definition. If not, the delete record hierarchy operation is complete.","Other parameters of delete method  are given below in Table 3.",{"@attributes":{"id":"p-0234","num":"0233"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Parameter",{},"Input\/","Data",{}]},{"entry":["Name","Required?","Output","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Message","Yes","Input","Hierarchy","Child property set."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"Synchronize Method","Synchronize method  is used to ensure that the data in a first and second data set are the same. Synchronize method  is similar to the upsert method , except for the fact that deletes are performed on rows in the database that are not present in the input instance.",{"@attributes":{"id":"p-0237","num":"0236"},"figref":["FIG. 16","FIG. 12"],"b":["1610","1620","1630","1540","1630"]},"Execute Method","Execute method  enables multiple operations to be performed on a SQL integration component. Execute method  allows query, upsert, delete, and synchronize operations to be specified for a particular SQL integration object definition. If either \u201cSynchronize\u201d or \u201cDelete\u201d is specified for a SQL integration component definition, all operations specified for a descendant component of the current SQL integration component are invalid and are ignored.","Parameters for Execute method  are given below in Table 4.",{"@attributes":{"id":"p-0241","num":"0240"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Parameter",{},"Input\/","Data",{}]},{"entry":["Name","Required?","Output","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Message","Yes","Input\/","Hierarchy","Input\/Output Property set"]},{"entry":[{},{},"Output",{},"should have a Message as"]},{"entry":[{},{},{},{},"its child."]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"Reverse Query Method","In reverse query method , SQL adapter business service  can start with the primary key(s) of a component instance at any level of a hierarchy defined in a SQL integration object definition. Reverse querying obtains each ancestor component instance for the input instance up to the root component instance. Foreign key definitions are used to determine the parent component of each traversed component to perform the reverse query. Because each component definition in a SQL integration object definition can include only a single parent component definition, reverse query produces one record for each ancestor from the input component instance to the root.",{"@attributes":{"id":"p-0244","num":"0243"},"figref":["FIG. 17","FIG. 18"],"b":"632"},"In , four component definitions are included, D , E , F , and F . Component definitions F  and F  correspond to the same physical table, table F. Example data for each of Tables D, E and F are given below.",{"@attributes":{"id":"p-0246","num":"0245"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE D"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["DID","Name"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","Peter"]},{"entry":["2","Sam"]},{"entry":["3","Chris"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0247","num":"0246"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE E"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["EID","Color","DID (foreign key)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","Blue","1"]},{"entry":["2","Red","1"]},{"entry":["3","Yellow","2"]},{"entry":["4","Red","2"]},{"entry":["5","Green","3"]},{"entry":["6","Pink","3"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0248","num":"0247"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"70pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE F"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["FID","Country","DID (foreign key)","EID (foreign key)"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","USA","1","\u2014"]},{"entry":["2","France","1","\u2014"]},{"entry":["3","India","\u2014","1"]},{"entry":["4","UK","\u2014","1"]},{"entry":["5","Germany","\u2014","2"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"Referring to , in Obtain Input Data step , input data (a QBE instance) is obtained for performing the reverse query. A search specification can be specified at any level of a SQL integration object definition. A search specification may include one or more values of a unique identifier for a SQL integration component definition; i.e., the search specification may include one or more primary key values for one or more records in a corresponding table. In the example shown in , the search specification includes unique identifier FID=5, which identifies a single record of Table F. The search specification for a reverse query may be provided as part of an SQL integration object instance in which the ancestor component instances are null. In one embodiment, if a single search specification instance includes unique identifiers at more than one level, the search specification of the lowest level component definition is used.","Because reverse query is a bottom-up traversal of the SQL integration object definition, it begins with the search specification. Thereafter, each query for an ancestor begins with the result set of the previous query, called a previous result set, to ensure that only relevant ancestor records are included in the output data.","In Select Instance from Input Data step , the SQL integration object instance having FID=5 is selected.","In Query for Input Result Set step , the selected instance is used to query the corresponding table, Table F. The following SQL statement is generated:","SELECT FID, Country, DID, EID","FROM Table F","WHERE FID=5","All fields of the corresponding table are included in the query. The result set from the above example query produces a result set containing the fifth record from Table F, with the following values:","FID=5, Country=Germany, DID=NULL, EID=2","In Use Input Result Set as Previous Result Set and Output Result Set step , the result set of the query based upon the search specification is designated as the previous result set for building the reverse query in a bottom-up traversal of the SQL integration object definition. The records from the input result set are also designated as the output result set for producing output data.","Foreign key values from the previous result set are used to build a query for the parent table to obtain the ancestor record of the selected instance. Table F includes two foreign keys, DID and EID. Therefore, two possible paths to the root are present from Table F. The first path is from component definition F  to root component definition D . The second path is from component definition F through component definition E  to root component definition D . In Determine Traversal Path in SQL Integration Object Definition step , assume that foreign key DID is selected, identifying the first path to the root. The current component therefore corresponds to F .","In Current Component is Child decision point , if the current component definition is a child of another component definition, control proceeds to Select Parent Component as Current Component step . If the current component definition is not a child, it corresponds to a root of the SQL integration object definition and control proceeds to Produce Output Data from Output Result Set .","In the example, the current component definition corresponds to F . Control proceeds to Select Parent Component as Current Component step , and component definition D  is selected. Control proceeds to Generate SQL to Select Parent Instance with Target Key=Value of Foreign Key from Previous Result Set step .","The value of the foreign key in the previous result set corresponding to the current component, the NULL value of foreign key DID in the current example, is used to generate the following SQL statement for component definition D :","SELECT DID, Name","FROM Table D","WHERE DID=NULL","In Execute SQL Statement to Create New Previous Result Set step , the generated SQL statement is executed. In the example, because no records in Table D have a null DID, the previous result set from executing this SQL statement is null.","Previous Result Set Null decision point  is related to a situation in which a given table corresponds to more than one SQL integration component definition in a SQL integration object definition. This situation may occur when the table appears as a child of more than one SQL integration component definition. For example, a commonly used table, such as the PHONE table of , can be a child table of a number of different tables. While not shown in the example for , the PHONE table can be a child table of the CUSTOMER table as well as of the CONTACT table in the SQL integration object definition.","SQL adapter business service  uses a component attribute, such as SQL integration component attribute , called \u201cSharedExternalName\u201d to handle this situation and improve efficiency. When a SQL integration component definition contains the \u201cSharedExternalName\u201d attribute, another SQL integration component definition in the same SQL integration object definition corresponds to the same external table (the same database table\/view ). For example,  shows that Table F resides in two paths to the root in the same SQL integration object definition, the path with leaf node corresponding to F  and the path with leaf node corresponding to F . In performing a reverse query, SQL adapter business service  exhaustively tries to reach the root component for each path in the SQL integration object definition using the foreign keys that are defined for each component definition. After failure in a first attempt to produce a result of the reverse query, an alternative path is traversed when the SharedExternalName attribute is set.","In Previous Result Set Null decision point , a determination is made whether the result set produced by Execute SQL Statement to Create New Previous Result Set step  is null. A null result set indicates that no parent for the record was found, perhaps indicating that the instance belongs to another SQL integration component definition for the same table, rather than the current component definition. In the example, the result set is null.","When, in Previous Result Set Null decision point , the result set is null, control proceeds to Shared External Name decision point , where a determination is made whether the SharedExternalName attribute is set. As shown in , the SharedExternalName attribute is set for both component definitions F  and F . Control proceeds to Choose Alternative Path in SQL Integration Object Definition step . The path with leaf component definition F  is selected as an alternative path beginning with Table F.","In Shared External Name decision point , if the SharedExternalName attribute is not set, the reverse query did not produce a result, and control proceeds to Set Output Result Set to Null step . Control then proceeds to Produce Output Data from Output Result Set step , where a null SQL integration object instance, or possibly an error message, is produced as output data.","In Shared External Name decision point , if the SharedExternalName attribute is set, control proceeds to Choose Alternative Path in SQL Integration Object Definition step  to start again with the QBE instance to try another path to the root (i.e., another foreign key). In the example, the SharedExternalName attribute is set for component definitions F  and F . Control proceeds to Choose Alternative Path in SQL Integration Object Definition step . For the search specification of FID=5, the alternative path in the SQL integration object definition corresponds to the alternative foreign key EID. The alternate path, including component definitions D , E , and F , is selected to be traversed.","From Choose Alternative Path in SQL Integration Object Definition step , control proceeds to Set Previous Result Set to Input Result Set . In Set Previous Result Set to Input Result Set , the result set from the original search specification is used as a starting point. This result set in the example includes the following record:","FID=5, Country=Germany, DID=NULL, and EID=2","From Set Previous Result Set to Input Result Set step , control proceeds to Clear Output Result Set . In Clear Output Result Set step , the output result set is cleared, as another path to the root is being traversed. Control returns to Select Parent Component as Current Component step .","In this iteration for the example, the parent component of component definition F  is component definition E . The following SQL statement for table E is constructed from the previous result set:","SELECT EID, Color, DID FROM Table E","WHERE EID=2","The result set of this query from the E table is the following:","EID=2, Color=RED, DID=1","The result set is not null, so in Previous Result Set Null decision point , control proceeds to Join Previous Result Set to Output Result Set step . The output result set now includes the following records:","EID=2, Color=RED, DID=1","FID=5, Country=Germany, DID=NULL, EID=2","Control then proceeds to Current Component is Child decision point . Because component definition E  is a child of component definition D , control proceeds to Select Parent Component as Current Component step . D , the parent of component definition E , is selected.","From the result set for component definition E , the resulting SQL statement for component D  is shown below:","SELECT DID, Name","FROM Table D","WHERE DID=1","The result set for this SQL Statement includes the following record:","DID=1, Name=Peter","When the new previous result set is created, control proceeds to Previous Result Set Null decision point . Because the previous result set is not null, control proceeds to Join Previous Result Set to Output Result Set step . The above result set for component definition D  is joined with the output result set to produce the following records:","DID=1, Name=Peter","EID=2, Color=RED, DID=1","FID=5, Country=Germany, DID=NULL, EID=2","Control proceeds to Current Component is Child decision point . Because component D  is not a child component definition, control proceeds to Produce Output Data from Output Result Set step . The output data for the example, in the form of an SQL integration object instance, includes the following data:","COMPONENT D : DID=1, Name=Peter","COMPONENT E : EID=2, Color=RED, DID=1","COMPONENT F : FID=5, Country=Germany, DID=NULL, EID=2","By using a previous result set to construct a subsequent SQL statement, the number of records processed by each SQL statement is greatly reduced, thereby increasing efficiency of retrieving data from the data set.","Control then proceeds to More Instances in Input Data decision point . In More Instances in Input Data decision point , if additional instances remain, control proceeds to Select Instance from Input Data step  and the reverse query is repeated to produce output data for another instance. In More Instances in Input Data decision point , if no instances remain, the reverse query is complete. In the example, no instances remain, so the reverse query is complete.",{"@attributes":{"id":"p-0301","num":"0300"},"figref":["FIG. 19","FIG. 19"],"b":["100","45","25","1","35","1","35","1","25","1","35","1","25","1","35","1"]},"It will be noted that the variable identifier \u201cN\u201d is used in several instances in  to more simply designate the final element (e.g., servers ()-(N) and client computers ()-(N)) of a series of related or similar elements (e.g., servers and client computers). The repeated use of such variable identifiers is not meant to imply a correlation between the sizes of such series of elements, although such correlation may exist. The use of such variable identifiers does not require that each series of elements has the same number of elements as another series delimited by the same variable identifier. Rather, in each instance of use, the variable identified by \u201cN\u201d may hold the same or a different value than other instances of the same variable identifier.","One or more of client computers ()-(N) and\/or one or more of servers ()-(N) may be, for example, a computer system of any appropriate design, in general, including a mainframe, a mini-computer or a personal computer system. Such a computer system typically includes a system unit having a system processor and associated volatile and non-volatile memory, one or more display monitors and keyboards, one or more diskette drives, one or more fixed disk storage devices and one or more printers. These computer systems are typically information handling systems which are designed to provide computing power to one or more users, either locally or remotely. Such a computer system may also include one or a plurality of I\/O devices (i.e., peripheral devices) which are coupled to the system processor and which perform specialized functions. Examples of I\/O devices include modems, sound and video devices and specialized communication devices. Mass storage devices such as hard disks, CD-ROM drives and magneto-optical drives may also be provided, either as an integrated or peripheral device. One such example computer system, discussed in terms of client computers ()-(N) is shown in detail in .",{"@attributes":{"id":"p-0304","num":"0303"},"figref":"FIG. 20","b":["10","35","1","10","12","10","14","16","18","20","22","24","26","28","30","32","33","34","36","38","40","42","46","12","28","47","12","30","48","12"]},"Bus  allows data communication between central processor  and system memory , which may include both read only memory (ROM) or flash memory (neither shown), and random access memory (RAM) (not shown), as previously noted. The RAM is generally the main memory into which the operating system and application programs are loaded and typically affords at least 16 megabytes of memory space. The ROM or flash memory may contain, among other code, the Basic Input-Output system (BIOS) which controls basic hardware operation such as the interaction with peripheral components. Applications resident with computer system  are generally stored on and accessed via a computer readable medium, such as a hard disk drive (e.g., fixed disk ), an optical drive (e.g., CD-ROM drive ), floppy disk unit  or other storage medium. Additionally, applications may be in the form of electronic signals modulated in accordance with the application and data communication technology when accessed via network modem  or interface .","Storage interface , as with the other storage interfaces of computer system , may connect to a standard computer readable medium for storage and\/or retrieval of information, such as a fixed disk drive . Fixed disk drive  may be a part of computer system  or may be separate and accessed through other interface systems. Many other devices can be connected such as a mouse  connected to bus  via serial port , a modem  connected to bus  via serial port  and a network interface  connected directly to bus . Modem  may provide a direct connection to a remote server via a telephone link or to the Internet via an internet service provider (ISP). Network interface  may provide a direct connection to a remote server via a direct network link to the Internet via a POP (point of presence). Network interface  may provide such connection using wireless techniques, including digital cellular telephone connection, Cellular Digital Packet Data (CDPD) connection, digital satellite data connection or the like.","Many other devices or subsystems (not shown) may be connected in a similar manner (e.g., bar code readers, document scanners, digital cameras and so on). Conversely, it is not necessary for all of the devices shown in  to be present to practice the present invention. The devices and subsystems may be interconnected in different ways from that shown in FIG. . The operation of a computer system such as that shown in  is readily known in the art and is not discussed in detail in this application. Code to implement the present invention may be stored in computer-readable storage media such as one or more of system memory , fixed disk , CD-ROM , or floppy disk . Additionally, computer system  may be any kind of computing device, and so includes personal data assistants (PDAs), network appliance, X-window terminal or other such computing device. The operating system provided on computer system  may be MS-DOS\u00ae, MS-WINDOWS\u00ae, OS\/2\u00ae, UNIX\u00ae, Linux\u00ae or other known operating system. Computer system  also supports a number of Internet access tools, including, for example, an HTTP-compliant web browser having a JavaScript interpreter, such as Netscape Navigator\u00ae 3.0, Microsoft Explorer\u00ae 3.0 and the like.","Moreover, regarding the signals described herein, those skilled in the art will recognize that a signal may be directly transmitted from a first block to a second block, or a signal may be modified (e.g., amplified, attenuated, delayed, latched, buffered, inverted, filtered or otherwise modified) between the blocks. Although the signals of the above described embodiment are characterized as transmitted from one block to the next, other embodiments of the present invention may include modified signals in place of such directly transmitted signals as long as the informational and\/or functional aspect of the signal is transmitted between blocks. To some extent, a signal input at a second block may be conceptualized as a second signal derived from a first signal output from a first block due to physical limitations of the circuitry involved (e.g., there will inevitably be some attenuation and delay). Therefore, as used herein, a second signal derived from a first signal includes the first signal or any modifications to the first signal, whether due to circuit limitations or due to passage through other circuit elements which do not change the informational and\/or final functional aspect of the first signal.","The foregoing described embodiment wherein the different components are contained within different other components (e.g., the various elements shown as components of computer system ). It is to be understood that such depicted architectures are merely examples, and that in fact many other architectures can be implemented which achieve the same functionality. In an abstract, but still definite sense, any arrangement of components to achieve the same functionality is effectively \u201cassociated\u201d such that the desired functionality is achieved. Hence, any two components herein combined to achieve a particular functionality can be seen as \u201cassociated with\u201d each other such that the desired functionality is achieved, irrespective of architectures or intermediate components Likewise, any two components so associated can also be viewed as being \u201coperably connected\u201d, or \u201coperably coupled\u201d, to each other to achieve the desired functionality.",{"@attributes":{"id":"p-0310","num":"0309"},"figref":["FIG. 21","FIG. 21"],"b":["50","10","60","70","80","90","60","70","80","90","10","47","48","10","60","10","70","80","90","10","70","80","90","90"]},"Referring to ,  and , a browser running on computer system  employs a TCP\/IP connection to pass a request to server , which can run an HTTP \u201cservice\u201d (e.g., under the WINDOWS\u00ae operating system) or a \u201cdaemon\u201d (e.g., under the UNIX\u00ae operating system), for example. Such a request can be processed, for example, by contacting an HTTP server employing a protocol that can be used to communicate between the HTTP server and the client computer. The HTTP server then responds to the protocol, typically by sending a \u201cweb page\u201d formatted as an HTML file. The browser interprets the HTML file and may form a visual representation of the HTML file using local resources (e.g., fonts and colors).","An advantage of the present invention is that the SQL adapter business service can communicate with various internal and external systems independently of the native format in which those systems maintain and store data. The SQL adapter business service optimizes operations to update data in the data sets by combining operations when possible and by using result sets from executing previous SQL statements to construct subsequent SQL statements. SQL adapter business service takes advantage of parent\/child relationships between tables to construct SQL statements in an order such that the SQL statements process only a minimum amount of data, thereby making retrieval of data as efficient as possible.","Other Embodiments","The present invention is well adapted to attain the advantages mentioned as well as others inherent therein. While the present invention has been depicted, described, and is defined by reference to particular embodiments of the invention, such references do not imply a limitation on the invention, and no such limitation is to be inferred. The invention is capable of considerable modification, alteration, and equivalents in form and function, as will occur to those ordinarily skilled in the pertinent arts. The depicted and described embodiments are examples only, and are not exhaustive of the scope of the invention.","The foregoing described embodiment shows different components contained within other components (e.g., the various elements shown as components of computer system ). It is to be understood that such depicted architectures are merely examples, and that in fact many other architectures can be implemented which achieve the same functionality. In an abstract, but still definite sense, any arrangement of components to achieve the same functionality is effectively \u201cassociated\u201d such that the desired functionality is achieved. Hence, any two components herein combined to achieve a particular functionality can be seen as \u201cassociated with\u201d each other such that the desired functionality is achieved, irrespective of architectures or intermediate components. Likewise, any two components so associated can also be viewed as being \u201coperably connected\u201d, or \u201coperably coupled\u201d, to each other to achieve the desired functionality.","The foregoing detailed description has set forth various embodiments of the present invention via the use of block diagrams, flowcharts, and examples. It will be understood by those within the art that each block diagram component, flowchart step, operation and\/or component illustrated by the use of examples can be implemented, individually and\/or collectively, by a wide range of hardware, software, firmware, or any combination thereof.","The present invention has been described in the context of a fully functional computer system, however those skilled in the art will appreciate that the present invention is capable of being distributed as a program product in a variety of forms, and that the present invention applies equally regardless of the particular type of signal bearing media used to actually carry out the distribution. Examples of signal bearing media include: recordable type media such as floppy disks and CD-ROM, transmission type media such as digital and analog communications links, as well as media storage and distribution systems developed in the future.","The above-discussed embodiments include software modules that perform certain tasks. The software modules discussed herein may include script, batch, or other executable files. The software modules may be stored on a machine-readable or computer-readable storage medium such as a disk drive. Storage devices used for storing software modules in accordance with an embodiment of the invention may be magnetic floppy disks, hard disks, or optical discs such as CD-ROMs or CD-Rs, for example. A storage device used for storing firmware or hardware modules in accordance with an embodiment of the invention may also include a semiconductor-based memory, which may be permanently, removably or remotely coupled to a microprocessor\/memory system. Thus, the modules may be stored within a computer system memory to configure the computer system to perform the functions of the module. Other new and various types of computer-readable storage media may be used to store the modules discussed herein.","The above description is intended to be illustrative of the invention and should not be taken to be limiting. Other embodiments within the scope of the present invention are possible. Those skilled in the art will readily implement the steps necessary to provide the structures and the methods disclosed herein, and will understand that the process parameters and sequence of steps are given by way of example only and can be varied to achieve the desired structure as well as modifications that are within the scope of the invention. Variations and modifications of the embodiments disclosed herein can be made based on the description set forth herein, without departing from the spirit and scope of the invention.","Consequently, the invention is intended to be limited only by the spirit and scope of the appended claims, giving full cognizance to equivalents in all respects."],"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention may be better understood, and its numerous objects, features and advantages made apparent to those skilled in the art by referencing the accompanying drawings.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 6","FIG. 1"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 8","FIG. 7"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 9","FIG. 8"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 10","FIG. 9"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 13","FIG. 12"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 14A","FIG. 13"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 14B","FIG. 13"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 18","FIG. 17"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 21","FIG. 20"]}]},"DETDESC":[{},{}]}
