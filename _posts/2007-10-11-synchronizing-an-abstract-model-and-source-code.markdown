---
title: Synchronizing an abstract model and source code
abstract: A software synchronization system detects a change that modifies an element of the abstract model. The software synchronization system globally modifies references to the element throughout the abstract model. Then the software synchronization system automatically determines elements of the source code that are dependent on the changed model element. The software synchronization system modifies the determined elements of the source code. Thus, the software synchronization system synchronizes the abstract model and the source code, regardless of the one to which the developer makes changes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08996349&OS=08996349&RS=08996349
owner: Microsoft Technology Licensing, LLC
number: 08996349
owner_city: Redmond
owner_country: US
publication_date: 20071011
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["A popular way of creating software is using abstract models. An abstract model defines various aspects of a system's behavior at a design level before a developer writes any source code. For example, the abstract model may define the major components of the design and the interfaces between components. Abstract models can also define finer details of software, such as the names of each class that will be in the design, the variables associated with each class, function names and parameters, and so forth. A recent movement called Model-Driven Engineering (MDE) is the systematic use of models as primary engineering artifacts throughout the engineering life cycle. Engineers can apply MDE to software, system, and data engineering. As it pertains to software development, MDE refers to a range of development approaches that are based on the use of software modeling as a primary form of expression. With the introduction of the Unified Modeling Language (UML), MDE has become very popular with a wide body of practitioners and there are many available supporting tools. More advanced types of MDE have expanded to permit industry standards that allow for consistent application and results. The continued evolution of MDE has added an increased focus on the use of models and their role in software development.","Modeling is not useful without a relationship to the eventual building of software code. Therefore, modeling tools are often capable of generating source code from the model. Model-generated source code gives a developer a head start in developing a software system and reduces the chance for errors since the generated code is a close reflection of the model. However, models are insufficient to completely implement the software system, so the developer must often modify the generated code or add additional code to complete the implementation of the system. Often the product is built in two distinct stages: (1) designing and modeling with a modeling tool that ultimately generates a coding framework, and (2) implementing the product based on the generated code.","Unfortunately, the model and source code can quickly become out of sync. If the developer makes changes to the model, then regenerating the generated code based on the model changes may overwrite changes to the generated code made by the developer or may cause developer-added code to fail to interoperate with the regenerated code. As the developer changes a declaration in his abstract model, he is required to (1) manually change all uses of that declaration in other parts of the model, (2) manually trigger a re-generation of all of the generated source code, and (3) manually update all of the additional source code to reflect the change. If the developer makes changes to the code first, then to keep the model in sync he is required to (1) manually perform the same change in the model that corresponds to the change he made in the developer code, (2) manually change all uses of that declaration in other parts of the model, (3) manually trigger a regeneration of all of the generated source code, and (4) manually update all of the developer source code to reflect the change. The large number of manual steps can lead to errors and consume valuable development time.","A software synchronization system is provided that maintains the association between an abstract software model and source code based on the model. The software synchronization system receives a change that modifies an element of the abstract model. The software synchronization system globally modifies references to the element throughout the abstract model. Then the software synchronization system automatically determines elements of the source code that are dependent on the changed model element. The software synchronization system modifies the determined elements of the source code. Thus, the software synchronization system synchronizes the abstract model and the source code, regardless of the one to which the developer makes changes.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","Overview","A software synchronization system is provided that maintains the association between an abstract software model and source code based on the model. The software synchronization system receives a change that modifies an element of the abstract model. For example, a developer may change the name of a class. The software synchronization system globally modifies references to the element throughout the abstract model. For example, parent and child classes may reference the name of the class, and the software synchronization system renames these references. Then, the software synchronization system automatically determines elements of the source code that are dependent on the changed model element. For example, the source code may contain an implementation of the class, various instantiations of the class, and so forth. The software synchronization system modifies the determined elements of the source code. For example, the software synchronization system may globally rename references to the class name in the source code based on the new name given to the model element by the developer. Thus, the software synchronization system synchronizes the abstract model and the source code, regardless of the one to which the developer makes changes.","In some embodiments, the software synchronization system synchronizes the abstract model and the source code for a variety of types of changes. For example, the developer may rename a variable in the source code that he defined in the model, and the software synchronization system will propagate the renamed variable into the model and throughout the rest of the source code. The developer may also change the return type of a function, a parameter type of a function, add or remove parameters, change the type of a field, change the hierarchical relationship of classes, and so on. In addition, the developer may change the cardinality of a relationship in the model (e.g., from \u201cone\u201d to \u201cmany\u201d). In this case, the software synchronization system changes the developer source code accordingly, such as by replacing a single variable with a collection type (e.g., an ICollection derived class when using .NET). Changes can originate in either the abstract model or the source code. For each type of change, the software synchronization system modifies the appropriate elements of both the abstract model and the source code to keep the two in sync.","In some embodiments, the software synchronization system performs changes within a transaction scope. If many parts of the software need to change because of a modification made by a developer, then the developer may want the software synchronization system to make all of the changes or none of the changes. Otherwise, the system could leave the software in a nonworking state. Therefore, the software synchronization system can enforce transaction semantics such that each change is attempted, and if any of the changes fail, the system rolls back all of the previous changes. The software synchronization system commits the transaction when all of the changes in both the abstract model and the source code succeed.","In some embodiments, the software synchronization system uses partial classes to separate generated source code from developer-added source code. A partial class is a class that is divided into two or more parts (e.g., split over multiple files), making it easier to deal with large quantities of code. At compile time, the compiler groups the elements from each part of the partial class together, thus logically making the output the same as if the class were defined in one place. Partial classes can make automatically generated code easier to interpret by separating the generated code from developer-added code. Version 2.0 of the Microsoft .NET Framework introduced partial class support in both C# and Visual Basic.NET. By using partial classes, the software synchronization system can modify the model and regenerate the generated code without interfering with code that the developer has added. The software synchronization system can then separately propagate a change to the developer-added source code.","Example Environment",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1","b":["110","110","120","120","110","110","110","130","140"]},"A software synchronization system  introduces the ability to keep the model and code in sync when either the model or the code is changed. When the model changes, the synchronization system  detects that an elements has changed in the model tool , for example, by receiving an event from the model tool . The software synchronization system  then instructs the development environment  to update the corresponding elements in the code. For example, if the developer renamed a model element IFoo to IBar, then the software synchronization system  instructs the development environment  to rename instances of IFoo to IBar in the code.","The other direction, reflecting changes to the code in the model, uses an association between the model and code for each element, called a NamingManager, that is generated by the model tool  when the code is generated. For example, the NamingManager may be defined in a C++ attribute within the code that does not affect the compiled software but is accessible during development. When a user loads a project, the development environment  informs the software synchronization system  through a load event. At that time, the software synchronization system  loads each NamingManager to track later changes to code elements. For example, the software synchronization system  can use reflection to identify each NamingManager attribute and instantiate a corresponding class that registers with the development environment  to receive element change events. When an element with a NamingManager changes, the development environment  informs the software synchronization system  through an element change event. Then the software synchronization system  informs the model tool .","Mapping Between Model Elements and Code Elements","The software synchronization system consists of three major components: a component that provides a mapping between model elements and corresponding code elements, a component that listens for changes in the model and triggers updates in the associated code, and a component that performs source code updates. This section describes the operation of the first of these components in further detail.","In some embodiments, an INamingManager interface provides the means to obtain the full name of a code element through a method GetFullName. This interface is defined in part as follows:",{"@attributes":{"id":"p-0021","num":"0020"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"interface INamingManager"]},{"entry":[{},"{"]},{"entry":[{},"\u2003string GetFullName (string namingToken, ModelElement mel,"]},{"entry":[{},"\u2003CodeGenerationLanguage codeGenerationLanguage)"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"To consistently modify elements of the source code, the software synchronization system determines both the old and the new states of the code element. For example, if the change is a rename, then the software synchronization system uses the old name to find elements that need to be modified and uses the new name to modify the found elements. The GetFullName method helps to calculate both old and new names of a given code element. GetFullName takes the following parameters: namingToken\u2014the model element attribute defining the part of the code element name that changed; mel\u2014the model element that is being modified, that defines rules for constructing the code element name, and that contains namespace information; and codeGenerationLanguage\u2014the target language for the code generation. The target language affects how the element name is constructed. For example, in C#, the name of a property and the name of the field backing it differ only in their casing, but in VB.NET, the field name is also suffixed with \u201cValue.\u201d","In some embodiments, a NamingManager abstract base class partially implements INamingManager. Each model element with generated code has an implementation of INamingManager. A given model element need only derive from this class and implement the CalculateFullName method. GetFullName calls CalculateFullName to perform steps specific to a given model element. This abstract class is defined as:",{"@attributes":{"id":"p-0024","num":"0023"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"internal abstract class NamingManager<T> : INamingManager where T :"},{"entry":"ModelElement"},{"entry":"{"},{"entry":"\u2003\/\/ Implementation of INamingManager interface"},{"entry":"\u2003public string GetFullName (string namingToken, T mel,"},{"entry":"\u2003CodeGenerationLanguage codeGenerationLanguage);"},{"entry":"\u2003\/\/ implemented by each concrete NamingManager"},{"entry":"\u2003abstract protected string CalculateFullName(string"},{"entry":"\u2003namingToken, ModelElement mel, CodeGenerationLanguage"},{"entry":"\u2003codeGenerationLanguage) {...}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In some embodiments, each model element with corresponding generated code has a derivative of NamingManager for each type of element for which the software synchronization system handles changes. For example, the software synchronization system creates an EntityNamingManager for handling changes to the element itself or related class code, a PropertyNamingManager for handling changes to properties, and a FieldPropertyNamingManager for handling changes to fields. Each class corresponds to exactly one code element generated from the model element. The following is an example of a FieldPropertyNamingManager class.",{"@attributes":{"id":"p-0026","num":"0025"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[NamingManagerFor(typeof(DesignTimeMetaModel.PropertyInfo),"]},{"entry":[{},"NamedElement.NameMetaAttributeGuidString, ElementKind.Field)]"]},{"entry":[{},"internal class FieldPropertyNamingManager :"]},{"entry":[{},"NamingManager<DesignTimeMetaModel.PropertyInfo>"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003..."]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In some embodiments, the software synchronization system implements CalculateFullName by concatenating the values of several attributes and special prefixes or suffixes (e.g., \u201cDestination\u201d) for a property produced from an associated model element. The software synchronization system can use the resulting string to detect multiple types of changes to the corresponding code element.","In some embodiments, each derivative of NamingManager has the NamingManagerFor attribute applied to it. This attribute specifies the model element corresponding to the NamingManager instance, which model element's property causes the change of a corresponding code element (e.g., Name), and the kind of code element. The information in this attribute enables the software synchronization system to generically listen for changes in the abstract model and trigger the corresponding changes in the source code. For example, Visual Studio provides an event interface that receives an indication when changes occur to any element with this attribute.","Detecting Changes","As discussed above, the software synchronization system consists of three major components: a component that provides a mapping between model elements and corresponding code elements, a component that listens for changes in the model and triggers updates in the associated code, and a component that performs source code updates. This section describes the operation of the second of these components in further detail.","In some embodiments, the software synchronization system inspects each code assembly using .NET reflection when the development environment loads, discovers all NamingManagerFor attributes, and uses the discovered attributes to subscribe to relevant change events in the model. Visual Studio, for example, provides the ability to register for changes to an abstract model. For example, the NamingManagerFor attribute on PropertyNamingManager indicates that an event listener can be registered to detect property change events so that code can be regenerated when a property changes. Thus, when the development environment is loaded, the software synchronization system can register to receive notification of any changes in the model.","When the development environment passes a change in the model to a registered event handler, the software synchronization system looks at the list of discovered NamingManager classes to find ones correlated to the changed model element type. If the software synchronization system discovers a match for the changed model element, then the system uses the NamingManager class to calculate the old and new names of the code element. The NamingManager then executes code updates accordingly.","In some embodiments, if the developer changes the code first, such that the model needs to be updated, then the software synchronization system locates the model element through the mapping of the model element to the code element name collected when the development environment loaded the software project. As described above, the software synchronization system can use reflection when a project is loaded to create an initial association between model and code elements. Then the software synchronization system can extract the model element name from the code element name or from other stored information. After locating the model element, the software synchronization system performs the change on the model element, and then the system proceeds as described above when a model change occurs. The system may prompt the developer to ask if it is okay to proceed with the model element change to ensure that the developer did not accidentally cause the change.","Updating Source Code","As discussed above, the software synchronization system consists of three major components: a component that provides a mapping between model elements and corresponding code elements, a component that listens for changes in the model and triggers updates in the associated code, and a component that performs source code updates. This section describes the operation of the third component in further detail.","In some embodiments, the software synchronization system invokes an existing tool to propagate a change. For example, many popular development environments (e.g., Visual Studio) provide a global rename operation (also known as rename refactoring) for renaming variables or other definitions in source code. If a developer makes a change to one part of the model or the source code, the software synchronization system can invoke an appropriate operation of the existing tool. For example, the software synchronization system may propagate the change throughout the abstract model and invoke the global rename function of Visual Studio to propagate the change throughout the source code.","In some embodiments, the software synchronization system uses the Microsoft Visual Studio Code Model Application Programming Interface (API) to find the existing declaration of the code element based on the calculated old code element name. The Visual Studio code model offers automation clients the ability to discover code definitions in a project and modify those code elements. The code model automatically updates all referenced objects when a developer makes modifications in the code editor. The code model allows automation clients to avoid implementing a parser for Visual Studio languages in order to discover the high-level definitions in a project, such as classes, interfaces, structures, methods, properties, and so on. After the software synchronization system finds the correct declaration using the code model API, the system invokes the Microsoft Visual Studio rename refactoring API as described above to update the code with the new code element name.","Figures","The following figures illustrate some embodiments of the features of the software synchronization system described above.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 2","b":["200","210","220","230","240","250","260","270","210","220","230","240","250","260","270"]},"The computing device on which the system is implemented may include a central processing unit, memory, input devices (e.g., keyboard and pointing devices), output devices (e.g., display devices), and storage devices (e.g., disk drives). The memory and storage devices are computer-readable media that may be encoded with computer-executable instructions that implement the system, which means a computer-readable medium that contains the instructions. In addition, the data structures and message structures may be stored or transmitted via a data transmission medium, such as a signal on a communication link. Various communication links may be used, such as the Internet, a local area network, a wide area network, a point-to-point dial-up connection, a cell phone network, and so on.","Embodiments of the system may be implemented in various operating environments that include personal computers, server computers, handheld or laptop devices, multiprocessor systems, microprocessor-based systems, programmable consumer electronics, digital cameras, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and so on. The computer systems may be cell phones, personal digital assistants, smart phones, personal computers, programmable consumer electronics, digital cameras, and so on.","The system may be described in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other devices. Generally, program modules include routines, programs, objects, components, data structures, and so on that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 3","b":["310","320","330","340","330"]},"In block , the component updates the model based on the detected change. For example, if the developer renamed a class, then the component renames all references to that class in the model. In block , the component prompts the generate code component to regenerate code based on the updated model. In block , the component updates the added source code (e.g., the code that is not generated) based on the change. After block , these steps conclude.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 4","b":["410","420","430","440","440"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 5","FIG. 4"],"b":["510","520","530","540","540"]},"From the foregoing, it will be appreciated that specific embodiments of the software synchronization system have been described herein for purposes of illustration, but that various modifications may be made without deviating from the spirit and scope of the invention. For example, although software has been described, other fields where a model and a document are closely related could also use the methods described. UML in particular is a modeling language suitable for modeling many systems and is often used in fields other than software. Accordingly, the invention is not limited except as by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
