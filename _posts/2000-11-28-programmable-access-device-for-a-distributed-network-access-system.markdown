---
title: Programmable access device for a distributed network access system
abstract: A programmable access device for use in a network access system includes first and second network interfaces through which packets are communicated with a network, a forwarding table utilized to route packets communicated between the first and second network interfaces, and a packet header filter. The packet header filter identifies messages received at one of the first and second network interfaces on which policy-based services are to be implemented and passes identified messages via a message interface to an external processor for processing. In preferred embodiments, the packet header filter is capable of filtering packets for service processing based upon protocol information pertaining to protocol layers higher than layer 3. In preferred embodiments, the programmable access device may also include a usage monitor that reports events, such as session activity levels, to the external processor, a policer that polices packets by reference to programmed traffic parameters, and a scheduler that schedules the transmission of outgoing packets to support multiple quality of service classes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08180870&OS=08180870&RS=08180870
owner: Verizon Business Global LLC
number: 08180870
owner_city: Basking Ridge
owner_country: US
publication_date: 20001128
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF A PREFERRED EMBODIMENT","CONCLUSION"],"p":["The present application is related to the following co-pending applications, which are filed on even date herewith and incorporated herein by reference:\n\n","1. Technical Field","The present invention relates in general to communication networks and, in particular, to an IP-centric communication network. Still more particularly, the present invention relates to an IP-based communication network including a network access system having distributed and separated routing, signaling, service control, filtering, policy control and other functionality from IP forwarding.","2. Description of the Related Art","The Internet can generally be defined as a worldwide collection of heterogeneous communication networks and associated gateways, bridges and routers that all employ the TCP\/IP (Transport Control Protocol\/Internet Protocol) suite of protocols to communicate data packets between a source and one or more destinations. As is well known to those skilled in the art, the TCP\/IP suite of protocols corresponds to layers 3 and 4 (the network and transport layers, respectively) of the seven-layer International Organization for Standardization Open Systems Interconnection (ISO\/OSI) reference model, which provides a convenient framework for discussing communication protocols. The ISO\/OSI reference model further includes physical and link layers (layers 1 and 2, respectively) below the network and transport layers, and session, presentation, and application layers (layers 5 through 7, respectively) above the network and transport layers.",{"@attributes":{"id":"p-0007","num":"0009"},"figref":["FIG. 1A","FIG. 1A"],"b":["10","14","10","16","16","12","17","14","17","12","14","18","20"]},"The state of the art in router design to a large extent dictates the network design shown in  because routers are expensive and must operate on highly aggregated traffic flows. A principal consideration in the design of such networks is to minimize the number of routers so that the routing protocol will scale effectively. This means that a number of functions are concentrated in these routers: routing, policy database storage, and policy enforcement.","In the prior art, router architecture is generally monolithic and proprietary. Consequently, the range of data services that a service provider can offer in addition to basic packet routing is limited by the control software offered by router vendors. In addition, the packet-processing throughput of a router is generally limited by its originally installed processing hardware and cannot be expanded or extended without replacement of the entire router. The monolithic and proprietary design of conventional routers presents a number of problems addressed by the present invention.","First, because routers traditionally have a single controller providing all services for all message types, edge router controllers tend to be quite complex, making it difficult and expensive to add new services or modify existing services. As a result, the time to market for new router-based services is extended and is usually dependent upon vendors responding to service provider requests to implement new services within their proprietary router architectures.","Second, conventional monolithic router architectures are not readily scalable, which presents a significant problem for service providers, particularly in light of the phenomenal growth of Internet traffic. Consequently, the processing capabilities of deployed routers cannot easily be scaled to keep pace with increasing traffic. Instead, service providers must purchase additional or replacement routers to meet the demands of increased traffic.","Third, conventional monolithic router designs also have limited flexibility and extensibility. For example, the present invention recognizes that it would be desirable, in view of the rapid growth of Internet traffic, to dynamically provision, configure, and\/or reallocate access capacity to IP-based services. Because access capacity is necessarily limited and providing additional access capacity is a major cost component of networks, the enforcement of intelligent admission control policies and provision of differing qualities of service is vital to the efficient utilization of available access capacity. However, conventional edge routers are not capable of classifying a wide variety of traffic types while enforcing policy controls or of responding to dynamic requests for capacity, and this functionality is difficult to incorporate within currently deployed monolithic edge routers. The present invention accordingly recognizes that it would be desirable to provide the above as well as additional policy control, network monitoring, diagnostic, and security services in commercialized hardware, while permitting these services to be tailored to meet the needs of individual customers and service providers.","Fourth, because of the proprietary nature of router architectures and services, if a service provider deploys routers from multiple vendors in a communication network, the proprietary services implemented by the different router vendors will not necessarily inter-operate. Consequently, service providers are not able to purchase routers and switches from one vendor and purchase service control software from another vendor. Furthermore, a service provider cannot offer its communication network as a platform for a wholesale provider to offer value-added data services utilizing the existing base network capabilities.","In view of the foregoing and additional shortcomings in the prior art, the present invention recognizes that it would be desirable to introduce a new network access architecture that addresses and overcomes the limitations of conventional monolithic router architectures.","The present invention introduces a distributed network access system architecture including a programmable access device.","The programmable access device includes first and second network interfaces through which packets are communicated with a network, a forwarding table utilized to route packets communicated between the first and second network interfaces, and a packet header filter. The packet header filter identifies messages received at one of the first and second network interfaces on which policy-based services are to be implemented and passes identified messages via a message interface to an external processor for processing. In preferred embodiments, the packet header filter is capable of filtering packets for service processing based upon protocol information pertaining to protocol layers higher than layer 3. In preferred embodiments, the programmable access device may also include a usage monitor that reports events, such as session activity levels, to the external processor, a policer that polices packets by reference to programmed traffic parameters, and a scheduler that schedules the transmission of outgoing packets to support multiple quality of service classes.","In addition to the programmable access device, the distributed network access system architecture preferably includes an external processor and an access router. Thus, in accordance with the present invention, conventional monolithic, proprietary edge routers are replaced with a distributed network access system that allocates the functionality of traditional edge routers (as well as additional functionality) among three logical modules: a programmable access device, an external processor, and an access router. According to a preferred embodiment of the present invention, basic routing of packets between input and output ports of the access network is performed by the access router. However, forwarding and generic traffic conditioning functions, such as marking, policing, monitoring, shaping, and filtering, are implemented in the programmable access device, and service functions, such as message interpretation, signaling, admission control, and policy invocation, are implemented in the external processor. As detailed infra, this distribution of functionality results in numerous advantages, including improved scalability, flexibility, extensibility, interoperability, security, and service provisioning.","Additional objects, features, and advantages of the present invention will become apparent in the following detailed written description.","Distributed Network Access System Architecture","With reference again to the figures and in particular with reference to , there is depicted a high-level block diagram of a portion of a communication network  having a distributed network access system  in accordance with the present invention. As illustrated, communication network  may be coupled to equipment of a number of customers (one of which is represented by a customer router ) by an access line . As in , access to line  may employ any of a number of commonly utilized transport network technologies, such as Ethernet, SONET, ATM and frame relay, and may further include unillustrated aggregation hardware.","As with conventional networks, communication network  includes one or more core communication links  (e.g., trunk lines) coupled to one or more core routers . However, in contrast to conventional communication networks, such as that illustrated in , customer router  does not interface to communication network  via a monolithic, proprietary edge router. Instead, customer equipment, such as customer router , interfaces with communication network  via a network access system  that distributes the functions of traditional edge routers (as well as additional functionality) among three logical modules: a programmable access device (PAD) , an external processor , and an access router . According to a preferred embodiment of the present invention, basic routing of packets between input and output ports of the access network is performed by access router  by reference to forwarding table  as determined by Exterior Gateway Protocol (EGP) and Interior Gateway Protocol (IGP) routing tables  and . However, forwarding and generic traffic conditioning functions, such as marking, policing, monitoring, shaping, and filtering, are implemented in PAD , and service functions, such as message interpretation, signaling, admission control, and policy invocation, are implemented in external processor . Given this distribution of functionality, incoming and outgoing packets are typically communicated between core communication links  and customer router  via PAD , access router , and core router  (and optionally additional switching the access network, such as an ATM or MPLS switch ). However, if the filtering functionality of PAD  detects packet flows for which additional services are required, PAD  passes appropriate messages to external processor  for service processing via a Message, Reporting, and Control Interface (MCRI) , which can be accessed via an Application Programming Interface (API) on PAD  and external processor . Distributing functionality between access router , PAD , and external processor  in this manner gives the service provider (or even third parties) the freedom to extend and modify existing services, create new services, or add more processing power to external processor  without adversely affecting the forwarding performance of PAD  and the routing performance or functionality of access router .","To implement a desired functionality for PAD  and external processor , the service provider (or even a customer or a third party) can define policy rules in the policy database  of one or more policy servers  (also referred to as a policy decision point (PDP)). Policy server  then makes policy decisions that control the functionality and operation of PAD  and external processor  by reference to the policy rules stored in policy database . Policy server  communicates policy decisions and associated configuration parameters for external processor  and\/or PAD  to external processor  via a Service Policy Interface (SPI) , which can be accessed, for example, via an API on policy server  and external processor . Communication via SPI  can employ any of a number of policy query protocols, including Common Open Policy Service (COPS) and Lightweight Directory Access Protocol (LDAP), which are respectively defined by Internet Engineering Task Force (IETF) RFCs 2748 and 2251, which are incorporated herein by reference. External processor  relays configuration parameters for PAD , if any, to PAD  via MCRI .","As discussed further below, network access system  also permits the service provider (or even a third party) to deploy additional functionality in external processor  by developing a service controller to support the functionality and installing the service controller on external processor . Additional functionality can also be implemented in network access system  utilizing NMS (Network Management System) , which is also referred to as an OSS (Operation and Support System). NMS  monitors, controls, reports alarms for, and configures (e.g., assigns an IP address to) each of the components of network access system  via interfaces -. NMS  also preferably includes billing and accounting facilities that allocate costs for services to appropriate customers, for example, in response to messages from the service controllers in external processor .","As further illustrated in , network access system  of the present invention permits flexibility in the placement and implementation of network switching. For example, an ATM or MPLS (Multi-Protocol Label Switching) network can be utilized to couple one or more PADs  to port of an access router  through an ATM or MPLS switch , thereby permitting signaling and policing functional blocks  and  to be implemented separately from access router . If, however, signaling is implemented by access router , switch  can be eliminated. Switch  can also alternatively be interposed between access router  and core router  an aggregation switch. Furthermore, access router  may be implemented by an external processor  running routing software controlling a large PAD .","Programmable Access Device (PAD)","Referring now to , there is illustrated a high-level block diagram of the logical elements comprising an exemplary embodiment of a PAD  in accordance with the present invention. As noted above, PAD  is a programmable access device containing required forwarding and packet classification functions along with other optional traffic conditioning functional modules that implement any desired combination of marking, policing, monitoring, and shaping for incoming and outgoing packets. In a typical embodiment, PAD  is implemented as a combination of software and conventional router hardware that cooperate to provide the functionality of the illustrated modules. (In , dashed line illustration is utilized to indicate optional functional modules.)","Generally speaking, the functional modules of PAD  are logically arranged in incoming (e.g., from customer router ) and outgoing (e.g., to customer router ) traffic paths, with the incoming path including packet header filter , marker\/policer , monitor(s) , forwarding table , and output buffers and scheduler . The outgoing path similarly includes packet header filter , forwarding table , monitor(s) , marker\/shaper , and output buffers and scheduler . The functions of all of these functional modules can be independently configured or programmed by an external processor  through MCRI .","Incoming packets received from customer router  at the external interface of PAD  are first processed by packet header filter , which distinguishes between various message types using any one or a combination of the protocol type, Source Address (SA), Destination Address (DA), Type Of Service (TOS), Diffsery Codepoint (DSCP), Source Port (SP), Destination Port (DP), and other fields of a packet (e.g., layer 4 and higher layer fields such as the SYN, ACK, RST, and FIN TCP flags) upon which packet header filter  is configured to filter. Importantly, in addition to filtering on layer-3 information, packet header filter  has the ability to identify higher layer (i.e., layer 4-7) message types or specific fields and forward those messages from\/to external processor  based on the configured filter parameters. Thus, based upon its filter configuration and the fields of an incoming packet, packet header filter  directs the packet either to an external processor  via message interface  or to a specific marker\/policer . It should also be noted that message interface  may also inject a packet specified by external processor  into either of packet header filters  and .","In response to receipt of a stream of packets from packet header filter , marker\/policer  polices the packet stream by applying one or more token or leaky bucket algorithms to determine whether the packet stream conforms to the traffic parameters established by control interface . As a result of the policing function, marker\/policer  may discard nonconforming packets, mark nonconforming packets (e.g., with a higher or lower priority), and\/or count nonconforming packets, depending upon its configuration. If marking is required, marker\/policer  may set bits in the Differentiated Services (DiffServ)\/TOS byte in the IP packet header, and\/or the 3-bit MPLS experimental field, and\/or the 20-bit MPLS label field, and\/or other fields as configured by control interface  for that particular packet stream.","Within the incoming path, one or more monitors  having different functions may optionally be included. For example, these monitors  may include a usage monitor that tracks statistics for different layer-2, layer-3, layer-4, and higher layer traffic types (e.g., to monitor a Service Level Agreement (SLA)). Monitors  may also include a fault\/troubleshooting\/debugging monitor that verifies conformance to standards and assists in code debugging and fault diagnosis by saving and reporting memory dumps and other related information to external processor  via reporting interface  and MCRI . To regulate reporting messages, thresholds and other criteria can be set up to invoke a reporting event. The reporting messages sent to external processor  by monitors  may summarize usage information for a particular customer, report the occurrence of a high-priority traffic flow, alert external processor  to a large volume of out-of-band traffic, report on inactivity of a monitored flow, etc.","After processing by packet header filter  (and optionally by marker\/policer  and monitors ), incoming packets are processed by forwarding table . Forwarding table  maintains entries for each forwarding path, where each forwarding path is represented by packet flow attributes, such as DA, SA, TOS, PT, SP, DP, the incoming port, and the corresponding output port to which PAD  forwards the packet through the access network toward access router . Utilizing these forwarding table entries, forwarding table  forwards packets to the appropriate output ports and passes the packets to output buffers and scheduler .","Output buffers and scheduler  buffer packets ready for transmission over communication network  and schedule the transmission of such packets. The buffering within output buffers and scheduler , which can comprise a single buffer or preferably multiple buffers, is preferably configured to support multiple QoS classes, or even QoS for each individual flow. For example, a percentage or a fixed amount of buffer space can be assigned to a queue serving a generic class of traffic or a particular traffic flow classified by DA, SA, TOS, PT, SP and\/or DP. The packet scheduler then applies weighted round robin and\/or other algorithms to the multiple queues multiplexing the different traffic flows. The combination of the buffering and scheduling mechanisms can place a limit on the queuing delay to transmit a packet through PAD , thus guaranteeing a bounded value for the QoS jitter parameter for selected traffic flows. Buffers and scheduler  can also apply CBQ (Class-based Queuing), WFQ (Weighted Fair Queuing), WRR (Weighted Round Robin) or other link sharing algorithms to optimize communication.","The outgoing path through PAD  is similar to the incoming path, except for the inclusion of marker\/shaper  in lieu of marker\/policer . As will be appreciated by those skilled in the art, marker\/shaper  discards nonconforming packets, sends marked packets to appropriate output buffers for the various queues serving different QoS classes for individual flows within output buffers and scheduler  to control the delay, jitter and loss of an outgoing packet flow, or simply counts non-conforming packets.","A PAD  in accordance with the present invention can be deployed at a number of locations in a network to perform traffic management and policy control. For example, a PAD  can be placed in a customer access network (e.g., fiber, xDSL, cable modem, WAP (Wireless Access Protocol), etc.) connecting customer equipment to a provider network controlled by regionally located external processors . Alternatively, a PAD  can be deployed at a service provider's Point of Presence (POP), interfacing with a customer site over a private line, FR, ATM, MPLS or Ethernet access network. A PAD  in accordance with the present invention can also be located facing a server farm that can be in the provider's POP or in a customer's site. The manner in which such a distributed network of PADs  forwards packets to access router  is configured in forwarding table  by an external processor  using control interface .","External Processor","With reference now to , there is illustrated a high-level block diagram depicting the logical elements comprising a preferred embodiment of an external processor  in accordance with the present invention. External processor  can be implemented utilizing either or both of software and hardware, which hardware can include general purpose computing hardware or special purpose hardware. Although software-only implementations of external processor  that execute on the hardware of a PAD  are possible, external processor  is preferably implemented with stand-alone hardware to allow the service processing performed by external processor  to be easily scaled by the installation of additional and\/or higher performance external processor hardware. Separation of external processor  from the forwarding function performed by PAD  also allows dynamic allocation of processing resources within external processor  in response to access traffic patterns without degrading the forwarding performance of PAD . Moreover, as shown in , implementing external processor  separately from PAD  permits an external processor  to service multiple PADs and (which may be located at physically distant locations) or, alternatively, permits multiple external processors  to service a single PAD . The association of a single PAD  with multiple external processors  provides enhanced fault tolerance.","In a preferred embodiment, external processor  primarily performs three types of processing: invoking policy services, signaling to setup and teardown access network connections, and configuring one or more associated PADs . To coordinate these different processing functions, external processor  contains one or more service controllers , which each preferably controls these three functions for a respective type of service. For example, service controllers  may include any or all of a Conference Call Service Controller (CCSC), an E-Commerce Service Controller (ECSC), an IP Telephony Service Controller (IPTELSC), a Reserved Bandwidth Service Controller (RBSC), and a Multicast Service Controller (MSC). Such service-specific control can be implemented either with dedicated service controllers or with generic controllers that each support service-specific APIs. Each service controller preferably maintains a session table recording all of its active sessions with a PAD .","As further shown in , external processor  includes, for each associated PAD , a respective PAD controller . Under the direction of service controller(s) , each PAD controller  configures forwarding table , packet header filters  and , marker\/policer , marker\/shaper , monitors  and , and output buffers and schedulers  and  of the associated PAD  by invoking commands or scripts understood by control interface . External processor  also contains a respective message processor  for each associated PAD . Message processors  each communicate messages to and from the message interface  of the associated PAD . Upon receipt of a message from a PAD , which is usually a message received from the customer router , a message processor  parses the message and informs the appropriate service controller (as determined by the type of service) of its contents. As indicated in , at any given time not all PADs  may be configured to handle all service types; thus, a particular service controller  may communicate messages with less than all PADs .","As indicated by dashed line illustration, external processor  may further include a reporting processor  for each PAD (e.g., PAD ) containing optional monitors  or  and reporting interface . Reporting processor  receives report messages from the corresponding PAD's reporting interface  and transmits appropriate report messages to one or more service controllers . Reporting processor  can also configure the reporting interface  of a PAD  to specify acceptable type(s) of reporting messages, content of reporting messages, reporting events, etc.","Upon receipt of a report message from reporting processor  or another message type from a message processor , a service controller  translates the message into one or more policy queries and transmits the policy query or queries to policy server  via SPI . For example, if SPI  employs COPS, a service controller  will translate RSVP and SIP messages to COPS (RSVP) and COPS (SIP) messages, respectively. A service controller  may also pass a message to another service controller  to obtain additional services via interface .","In response to receipt of a policy decision from policy server , service controller  may inject one or more packets into a traffic flow via message processor , configure a PAD  via PAD controller  or control signaling inside or outside communication network  via signaling controllers and . Signaling controllers  support signaling protocols (e.g., RSVP, Label Distribution Protocol (LDP), Private Network-Network Interface (PNNI), frame relay or ATM User Network Interface (UNI), etc.) to setup or tear down a Virtual Connection (VC) or Label Switched Path (LSP) across the network. A VC or LSP setup by a signaling controller  may have a specified QoS.","To reduce the number of messages passed between service controllers  and policy server  via SPI , service controllers  each preferably cache frequently used policy rules in a respective policy cache . Accordingly, if policy information for a policy query arising from an incoming message is already cached, a service controller  can forego sending a query to the policy server  and make a policy decision by reference policy rules cached in its policy cache . In addition, when a service controller  queries policy server  with a new service request, the service controller  may request policy server  to dump all the related policy information from policy database  to its policy cache . However, there is a tradeoff between the number of policy queries and the cache refresh frequency and the amount of policy information downloaded from policy server  at each refresh. The objective is to cache policies for IP services requiring intensive policy queries, such as SIP calls, while avoiding caching policy lookups for other sessions (e.g., TCP sessions) that generally generate only one policy query in their lifetime.","Network Access System Interfaces","As described above, the network access system of the present invention supports at least two interfaces: SPI  and MCRI . Each of these interfaces is examined in turn infra.","As summarized in Table I below, SPI  preferably supports at least one message type that is sent from the service controllers  of external processor  to policy server , namely, queries regarding policy requirements. Such policy queries preferably include a flag that can be set to request that policy server  dump the policy rules for the query into the policy cache  of the requesting service controller .","SPI  also preferably supports at least five message types that are sent from policy server  to service controllers . The message types sent via SPI  from policy server  to service controllers , which are also summarized in Table I, include transaction approval and rejection messages, messages specifying configuration parameters, and messages containing policy information to be cached in policy caches . In addition, policy server  can send messages to external processor  that indicate settings for session level parameters in PAD . As understood by those skilled in the art, one important session level parameter is an inactivity timer that counts time that has elapsed since a packet has been received in an active session and, if more than a specified amount of time has elapsed, signal that the session should be closed for lack of activity.",{"@attributes":{"id":"p-0075","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE I"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Service Controller ","Query policy requirements with or without"]},{"entry":["to Policy Server","request to cache policy information"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Policy Server","Approve transaction"]},{"entry":["to Service","Reject transaction with a cause indication"]},{"entry":["Controller","Provide configuration parameters"]},{"entry":[{},"Dump the policy information into policy caches"]},{"entry":[{},"Set session level parameters"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Communication between policy server  and external processor  over SPI  can be either solicited or unsolicited. In the unsolicited mode operation, policy server  sends configuration parameters for external processor  and PAD  to external processor  in the absence of a policy request. Alternatively, in the solicited mode of communication, policy server  sends policy decisions and configuration parameters to external processor  in response to a policy request. As shown in , policy requests can either be sent by external processor  or, because SPI  preferably employs an open policy query protocol, by a third party's (e.g., a customer's policy server). In either case, policy server  receives a policy request via SPI . The policy request typically specifies a requested service and requires a response indicating whether the requested service is to be provided given the parameters of the service (e.g., identity of the requestor, type and amount of service requested, etc.), and if so, the appropriate configurations for the service. In response to receipt of a policy request, policy server  interrogates policy database  to access the appropriate policy rules given the parameters provided in the policy request. Policy server  then makes policy decisions for the policy request utilizing the accessed policy rules and usage information. For example, policy server  may track the amount of bandwidth reserved by a particular customer (a policy rule) and approve or reject a new service request by comparing the amount of remaining reserved bandwidth that is unutilized (usage information) and the amount of bandwidth required to provide the requested service. Policy server  then supplies the resulting policy decisions, which can be \u201capprove,\u201d \u201creject,\u201d and\/or configuration of session level parameters for external processor  and PAD , to external processor  via SPI .","Turning now to MCRI interface , Table II, below, summarizes message types that are sent by PAD  to external processor . As indicated, these message types can be conveniently categorized by reference to which of message interface , reporting interface , and control interface  is the source of the messages.","As noted above, message interface  of PAD  passes messages captured by packet header filters  and  to message processor  of external processor . The messages that are passed to message processor  can be filtered out of the incoming or outgoing packet flows based upon SA, DA, PT, SP, DP and\/or other packets fields such as TCP flags (e.g., SYN, ACK, RST, FIN, etc.), as well as layer 4-7 message types and fields.","Control interface  sends control reply messages to PAD controller  in response to receipt of a control command message. If the command completes successfully (e.g., a configuration of a monitor  is successfully updated), control interface  returns a command acknowledgement to PAD controller . However, if a command cannot be completed due to improper syntax, unavailability of required resources, etc., then control interface  notifies PAD controller  of the command failure with a command failure indication.","Reporting interface  of PAD  sends reporting messages to reporting processor  of external processor . The reporting messages tabulated in Table II include messages providing information about monitored sessions, messages related to communication between PAD  and service controllers  of external processor , and messages containing statistics collected by monitors  and . For certain protocols, such as TCP and SIP, PAD  implements a state machine for each active session. If a TCP state machine detects that a particular active TCP session has had a number of retransmissions in excess of an established retransmission threshold, reporting interface  sends a message notifying message processor  of external processor  that the TCP retransmission threshold has been exceeded, thus indicating that the TCP session has failed. Reporting processor  similarly reports other session failures such as the expiration of an inactivity timer on certain IP protocol sessions, such as TCP and SIP. For other data flows (e.g., UDP sessions) that do not have associated state machines to ensure reliability, reporting interface  of PAD  sends \u201cActivity Detected\u201d reporting messages when activity is detected in the session.","In the preferred embodiment of the present invention represented by Table II, the connection state between a PAD  and external processor  is indicated by keepalive messages that are periodically exchanged between each PAD  and the associated external processor . The absence of a keepalive message from a PAD  indicates the failure of the connection between the PAD  and external processor  and\/or the failure of PAD  itself. Such keepalive messages are preferably transmitted between reporting interface  and reporting processor ; however, if no reporting interface is implemented, keepalive messaging can alternatively be provided by message interface .","Service controllers  within external processor  are also subject to failure or dynamic reallocation to different services (e.g., for load balancing reasons). In the event of a failure of an external processor  supporting multiple service controllers  or a redistribution of service responsibility between service controllers , the new service controller  to which responsibility for a session is transferred must receive state information pertaining to all of the active sessions of the old service controller . Accordingly, in the event of a so-called switchover that assigns a PAD  to a preferred external processor , PAD  preferably reports the state information for active sessions to reporting processor  of external processor  in a state synchronization message. Making PAD  responsible to provide session state information to the new service controller  in this manner advantageously relieves service controllers and from the responsibility of synchronizing session states, which is a message-intensive process that degrades service controller performance during normal operation. This aspect of the design achieves fault tolerance to hardware, software, and network failures.","Table II finally lists two exemplary reporting messages triggered by the monitoring performed by optional monitors  and . First, reporting interface  can provide general usage statistics on a per-customer basis. Service controllers  in external processor  can utilize this statistical information to measure conformance to SLAs and detect certain events of interest. Second, reporting interface  can specifically indicate in a reporting message that a customer's predefined traffic threshold has been exceeded. A service controller  in external processor  can utilize this information to allocate additional resources to the customer's traffic (e.g., to ensure conformance to a SLA) or can notify billing server  that an adjustment should be made in customer billing (e.g., if billing is based upon usage). Of course, additional reporting messages can also be defined.",{"@attributes":{"id":"p-0084","num":"0086"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE II"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Message","Filtered messages"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Control","Command acknowledgement"]},{"entry":[{},"Command failure indication"]},{"entry":["Reporting","TCP retransmit threshold exceeded"]},{"entry":[{},"TCP state memory full"]},{"entry":[{},"Inactivity timer expired"]},{"entry":[{},"Activity detected"]},{"entry":[{},"Keepalive exchange"]},{"entry":[{},"State synchronization in event of a service controller "]},{"entry":[{},"switchover"]},{"entry":[{},"Traffic threshold exceeded"]},{"entry":[{},"Usage statistics"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Referring now to Table III, messages types sent to PAD  from message processor , PAD controller , and reporting processor  of external processor  via MCRI  are summarized. In the interface embodiment shown in Table III, message processor  can send at least two types of messages to message interface . First, message processor  may send message interface  one or more packets to be injected into either the incoming or outgoing packet flow. Second, message processor  may send message interface  a message indicating packet field flags in message interface  to be set or reset to cause message interface  to pass or to prevent message interface  from passing particular messages to message processor  based upon the contents of various packet fields, such as SA, DA, PT, SP, DP, etc.","As set forth in Table III, the control messages sent from PAD controller  to control interface  via MCRI  include a number of configuration messages that enable a PAD controller  to configure any of the filtering, marking, policing, monitoring, buffering, scheduling, shaping and forwarding functional modules - of PAD  through control interface . In particular, output buffers and schedulers  and  can be configured to allocate a number of buffers or size of buffer per traffic class or traffic flow or to implement CBQ, WFQ, WRR or other buffer scheduling algorithms. PAD controller  can also configure marker\/shaper  to employ static or adaptive shaping algorithms and can configure marker\/shaper  to implement shaping on a per traffic flow or per traffic class basis. PAD controller  can further configure forwarding table  in response to a request by a service controller  in order to enable the service controller  to associate a data flow with an ATM SVC or a MPLS LSP.","In addition to general control messages utilized to configure functional modules -, MCRI  also supports various control messages utilized to configure particular features of the functional modules of PAD . For example, packet header filters  and  can be configured to drop multicast packets from an unauthorized source, to admit or deny source routing for a data flow, or to admit only packets with specific source addresses. In addition, PAD controller  can update forwarding table  with SVC and LSP paths setup by a service controller  using a signaling controller . Reporting interface  can be configured via a \u201cSet reporting flags\u201d control message to enable or disable reporting of selected events by setting or resetting reporting flags corresponding to these events. PAD  can also be configured via MCRI control messages to set the TCP retransmission notification threshold, inactivity timers, activity timers and traffic threshold discussed above. Finally, the processing resources of PAD  and output buffers and scheduler ,  can be configured by an \u201cAllocate Resource\u201d control message sent via MCRI  and control interface  to dynamically allocate resources, such as bandwidth, queues, and processing time slices, to a customer interface, a packet flow, a class, or a multicast group.","The reporting messages sent from reporting processor  of external processor  to PAD  are generally limited to exchanging keepalive messages with reporting interface . The continued exchange of keepalive messages informs PAD  that the associated service controller  is operative. If PAD  fails to receive keepalive messages from a service controller , PAD  initiates a switchover of service to a secondary service controller , as discussed further below.",{"@attributes":{"id":"p-0089","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE III"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":[{},"Inject packet into ingress or egress packet flow"]},{"entry":["Message","Set pass\/no pass flag of message interface"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Control","Configure packet header filter"]},{"entry":[{},"Configure marker"]},{"entry":[{},"Configure policer"]},{"entry":[{},"Configure forwarding table"]},{"entry":[{},"Configure output buffers and scheduler"]},{"entry":[{},"Configure shaper"]},{"entry":[{},"Drop multicast packets from specified source"]},{"entry":[{},"Admit\/deny source routing option"]},{"entry":[{},"Set TCP retransmission threshold"]},{"entry":[{},"Set session inactivity timer"]},{"entry":[{},"Set activity timer and level"]},{"entry":[{},"Set traffic reporting threshold"]},{"entry":[{},"Allocate resource"]},{"entry":[{},"Set reporting flags"]},{"entry":[{},"Set SVC, PVC or LSP"]},{"entry":[{},"Delete TCP session"]},{"entry":["Reporting","Keepalive exchange"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"To prevent an interruption in service in the event of a service controller failure, each service is preferably supported by both a primary service controller that ordinarily provides the service and a secondary service controller that can provide the service if the primary service controller fails or if the connection between a PAD and the primary service controller is lost. In a preferred embodiment of the present invention, the primary and secondary service controllers reside on separate external processors  diversely connected via the access network. In response to detecting failure of communication with the primary service controller, PAD  performs a switchover to the secondary service controller.","Referring now to , there is depicted a time-space diagram showing exemplary network access system signal to switchover the provision of service from a failed primary service controller to a secondary service controller in accordance with the present invention. In , it is assumed for the purpose of illustration that service controller is the primary service controller and service controller is the secondary service controller.","During normal operation, a PAD  employs a reliable communication protocol (e.g., TCP) to exchange information with service controllers and of the associated external processor . As noted above, a keepalive message is periodically exchanged between external processor  and PAD  to keep the TCP session active. When PAD  detects a timeout of the keepalive message, meaning that the connection to primary service processor has failed, PAD  attempts to set up a TCP session with secondary service controller , as shown in  by PAD  sending a synchronizing segment (SYN) to secondary service controller . If PAD  is unsuccessful in connecting with secondary service controller (e.g., no SYN ACK is received from the secondary service controller ), PAD  stops accepting new sessions and maintains the state and service for all currently active sessions until communication with primary service controller is restored.","If, however, PAD  successfully established a TCP session with secondary service controller (e.g., as indicated by receipt of a SYN ACK and return of an ACK), PAD , which maintains a state machine for each active session, uploads state information for all of its active sessions controlled by failed primary service controller to secondary service controller . Once receipt of the state information by secondary service controller is acknowledged by an ACK message, PAD  initiates the exchange of keepalive messages with secondary service controller . Thus, service is not interrupted is by the failure of a single service controller , and no synchronization is required between service controllers and ","Communication between PAD  and secondary service controller may continue and not revert to primary service controller if a non-reverting behavior is desired. However, it is presently preferred for communication to revert to primary service controller , if possible, to maintain load balancing of service controller processing across the distributed PADs.","Referring now to , there is depicted a time-space diagram showing exemplary signaling between a programmable access device and an external processor during a switchover from a secondary service controller to a primary service controller following restoration of the primary service controller. The reversion process begins with primary service controller sending a SYN segment to PAD  to reestablish a TCP session. PAD  responds to receipt of the SYN with a SYN ACK, which primary service controller confirms with an ACK. Once a TCP session has been initiated, PAD  uploads the states of active sessions to primary service controller , and service controller confirms receipt of the session states with an ACK.","After the session states have been successfully restored to primary service controller , PAD  notifies secondary service controller that primary service controller has been restored via a \u201cPrepare to shutdown\u201d message. PAD  then closes the TCP session with secondary service controller via a pair of FIN (i.e., finished) and ACK handshakes, the first half of which is originated by PAD  and the second half of which is originated by secondary service controller . After the TCP connection is closed, secondary service controller deletes all the state information related to the sessions transferred to primary service controller . PAD  thereafter resumes keepalive exchanges with primary service controller ","Metropolitan Implementation","With reference now to , there is depicted an exemplary metropolitan implementation of an Internet Service Provider (ISP) network including a distributed network access system in accordance with the present invention.  illustrates physical interconnections of components, rather than logical (e.g., network) connections, as shown in .","Starting from the left hand side, customer LANs  interconnect either to a lowest level access network (e.g., TDM, ATM, or Ethernet) among metropolitan access networks \u2032 or directly to a PAD . As shown, PADs  may also be located at higher levels in the aggregation network hierarchy. Engineering economic and\/or performance considerations determine placement of PADs . For example, aggregation of a minimum amount of traffic or the need to access a low speed access link may drive placement of a PAD  to higher and lower access network levels, respectively.","As discussed above, PADs  perform policy enforcement, thus relieving the aggregation routers (i.e., access routers ) of some workload. Policy determination is also removed from the aggregation routers and is instead located in redundant external processors  and PDPs . For most implementations, external processors  would typically be deployed in a distributed manner to each metropolitan area, while PDPs  would be deployed more sparsely on a regional basis. As a result of relieving some of the workload of aggregation routers, access routers  can be scaled to handle larger traffic capacities because they are optimized to handle the simpler, yet essential, task of Internet routing. The capabilities of the ISP network are also expanded because PADs , external processors , and PDPs  implement not only the functionality of state-of-the-art edge routers, but also a number of functions not currently available in monolithic router designs.","In order to further illustrate aspects of the present invention, examples of network access system signaling and messaging for various operating scenarios are described below with reference to generic space-time drawings. The examples illustrate exemplary implementations of network-level signaling, connection-oriented and connectionless transport protocols, application-level communication, and policy-based multicast service management.","Network-Level Signaling Example","With reference now to , there is illustrated a time-space diagram depicting exemplary network-level signaling utilized to obtain a service reservation through the use of the Resource Reservation Protocol (RSVP). In the illustrated example, a customer application initiates the reservation process by sending a RSVP PATH message to PAD . For example, the customer application may request a path of specified bandwidth at a particular time. As shown in , packet header filter  of PAD  captures the RSVP PATH message based upon RSVP protocol type (i.e., PT=46) and forwards it to the appropriate service controller  (which in this example is referred to as a Reserved Bandwidth Service Controller (RBSC))  within external processor .","In response to receipt of the path message, RBSC  transmits an appropriate policy query to policy server  via SPI  (which in this case is assumed to implement COPS) to determine whether the reservation service is authorized for this customer. If policy server  returns a policy decision to RBSC  approving the reservation service for this customer, RBSC  returns a RSVP PATH message to PAD , which sends the PATH message downstream to the egress point of the network.","If the receiver at the far end of the network also approves the reservation, the receiver responds by transmitting a reservation (RESV) message to PAD , which passes the RESV message to RBSC . In response to the RESV message, RBSC  invokes another policy query to policy server  to ascertain whether the bandwidth requirements specified by the RESV message are authorized for this customer. In response to this second query, policy server , which tracks allocated bandwidth for each customer, determines whether the currently allocated bandwidth plus the requested bandwidth is less than the maximum authorized bandwidth for this customer. If so, policy server  notifies RBSC  with a policy decision indicating approval. RBSC  then initiates appropriate ATM or MPLS signaling to set up a RVC or LSP utilizing one more signaling controllers . After RBSC  receives confirmation of the requested path from the network, RBSC  configures packet header filter  and forwarding table  of PAD  to transmit packets in the customer's flow over the established SVC or LSP. In addition, RBSC  returns the RESV message to PAD  using message interface , which sends the RESV message upstream to the customer application. RBSC  also sends a CONFIRM message downstream to the receiver via PAD  to complete the handshake utilized to set up the SVC or LSP.","Connection-Oriented Transport Examples","With reference now to , there are depicted a TCP state machine and time-space diagrams of various TCP events that together illustrate the handling of connection-oriented transport protocols by a network access system in accordance with the present invention. Referring first to , a preferred embodiment of a state machine maintained for a TCP session on a PAD  is depicted. As shown, TCP state machine  includes two states: an idle state  in which there is no active TCP session and an active state  in which there is an active TCP session. The operation of state machine  maintains TCP session state during four TCP processes, including (1) opening a TCP session in response to a synchronizing segment (SYN), (2) closing a TCP session in response to a finished (FIN) message, (3) closing a TCP session that has timed out and (3) closing a TCP session in response to a reset (RST) message. In , messages associated with each of these operations are identified by corresponding legends (e.g., \u201c1.x\u201d for a TCP session open, \u201c2.x\u201d for a TCP session close in response to a FIN message, etc.) and are further time-ordered by alphabetic designations (e.g., \u201c1.a\u201d precedes \u201c1.b,\u201d etc.).","As illustrated, opening of a TCP session is initiated when state machine  is in idle state  and PAD  receives a SYN segment. As illustrated at reference numeral , packet header filter  captures the initial SYN message received from the customer and passes it to the service controller  within external processor  that is designated to handle TCP services. In response to receipt of SYN message, service controller  queries policy server  regarding a TCP session for this customer. If service controller  receives a policy decision indicating approval of the TCP session, service controller  returns the SYN segment to PAD  as indicated at reference numeral . In response to receipt of SYN message from service controller , state machine  changes state from idle state  to active state . PAD  forwards the SYN segment to the receiver specified by the destination address and receives a SYN, ACK segment from the receiver, as shown at reference number . The sender completes the three-way handshake required to open the TCP session by replying with an ACK message, as depicted at reference numeral . PAD  passes the ACK message representing the success of the handshake to service controller , as shown at reference numeral . Receipt of the ACK message notifies service controller  that the TCP session is open and causes service controller  to add the TCP session to its active session table. Service controller  then sets an inactivity timer and other parameters of this TCP session in PAD  and returns the ACK message to PAD , as also indicated at reference numeral . Thereafter, data can be transmitted between the customer and the receiver via the active TCP session, as shown at reference numeral .","To close an active TCP session, either the customer or receiver can send PAD  a FIN message. In response to receipt of the FIN message, PAD  resets TCP state machine  to idle state  as shown at reference numeral . PAD  than passes the FIN message to service controller  as shown at reference numeral . The FIN message notifies service controller  that the TCP connection is inactive and causes service controller  to delete the TCP session from its active session table. As illustrated, PAD  forwards the FIN message to its destination (i.e., either the customer or receiver), which responds with an ACK message and a FIN message . The source then responds the last FIN message with an ACK message . In response to receipt of the last ACK message, PAD  deletes the state machine  for the TCP session.","As further illustrated in , PAD  will also close an active TCP session if the inactivity timer for the TCP session expires. In response to expiration of the inactivity timer for an active TCP session, PAD  transitions state machine  from active state  to idle state , as illustrated at reference numeral . PAD  also reports a timeout error to service controller , as shown at reference numeral . In response to receipt of the timeout error message, service controller  deletes the TCP session from its active session table and updates the configuration of PAD  to remove the inactivity timer and other configuration information associated with the TCP session. PAD  then deletes the state machine  for the TCP session.","PAD  also closes an active TCP session in response to receiving a reset (RST) message from either party to a TCP connection. In response to receipt of the RST message, PAD  transitions state machine  from active state  to idle state , as shown at reference numeral . PAD  also passes the RST message to service controller , as shown at reference numeral . In response to receipt of the RST message, service controller  passes the RST message back to PAD  to acknowledge receipt of RST and successful deletion of the TCP session, as also shown at reference numeral . PAD  then deletes the state machine  of the TCP session and forwards the RST message to the other party of the TCP session.","In order to promote efficient operation of PAD  and service controller , it is desirable to minimize the amount of messaging there between. Accordingly, PAD  only forwards the last ACK messages to service controller  if required to open a TCP session. In addition, PAD  only passes the first SYN, FIN segment received in a session to service controller . In this manner, excessive messaging is avoided, even though the functions of PAD  and service controller  are distributed.","In the preferred embodiment, PAD  needs only keep active state information for TCP session for which service controller  configures value-added services. In other words, PAD  will not keep state information for best-effort TCP sessions. This greatly reduces the required memory size on PAD  for keeping TCP state information (e.g., state variables for packet header filters  and  and monitors  and ). Also, since there may be a large number of active TCP sessions, the delete TCP session message given in Table III allows service controller  to decide which TCP sessions will receive value-added service in the event that TCP session state memory is full.","As illustrated in , PAD  sends a TCP state memory full message  to service controller  through the reporting interface  in response to detecting a TCP state memory full event . State memory full event  may result from depletion either of storage for packet header filter state variables or of storage for monitor state variables. In response to receipt of TCP state memory full message , service controller  records the TCP state memory status of PAD .","When customer router  initiates another value-added TCP session by sending a SYN message , PAD  passes the SYN message to service controller  through the message interface , as shown at reference numeral . In response to receipt of the SYN message, service controller  checks the TCP state memory status of PAD . Since the TCP state memory status is full, service controller  decides whether or not to allow the new TCP session to overwrite existing value-added TCP sessions based on some pre-installed policies. For example, service controller  may assign each value-added service a priority and allow sessions of higher relative priority to overwrite lower priority TCP sessions. Alternatively or in addition, service controller  may permit the new TCP session to overwrite the TCP session having the longest period of inactivity.","If the new TCP session is not allowed to overwrite any existing TCP session, service controller  ignores the SYN message. As a result, PAD  does not install any state information for the new TCP session, and PAD  provides best-effort service to the new TCP session. If, however, service controller  decides that the new TCP session can overwrite another TCP session, service controller  sends a Delete TCP session message  to PAD  through control interface . PAD  responds by deleting an existing TCP session from its TCP state memory, as indicated at reference numeral . The process illustrated in  at reference numerals - is then performed to install the new TCP session in the state memory of PAD .","Given the exemplary TCP state machine depicted in , several examples of TCP signaling will now be described with reference to . Referring first to , exemplary signaling utilized to establish a TCP session through a network access system in accordance with the present invention is shown.","As illustrated, to open a TCP session, a client application first issues an open command that informs the protocol stack that the application desires to open a connection to a server at a specified port and IP address (e.g., when accessing a web page). The TCP agent at the client site then selects an initial sequence number (800 in this example) and transmits a synchronizing segment (SYN) carrying the selected sequence number. When the SYN segment arrives, packet header filter  in PAD  detects, based upon the specified destination IP address and port number (PT=6, Port=80), that the SYN segment is intended to initiate a mission-critical e-commerce TCP session. Accordingly, packet header filter  passes the SYN segment to an e-commerce service controller (ECSC) . ECSC  responds to the SYN segment by querying policy server , for example, utilizing an LDAP request.","In response to policy server  indicating approval of the TCP session, for example, via an LDAP APPROVE message, ECSC  returns the SYN segment to PAD . When PAD  receives the SYN segment from ECSC , PAD  spawns a new TCP state machine and sets it to active state . PAD  then sends the SYN segment downstream to the server specified in the SYN segment.","When the SYN segment is received at the server, the server's TCP agent picks an initial sequence number (400 in this case) and sends a SYN segment containing the selected initial sequence number and an ACK to PAD . The ACK message specifies that the first data byte sent by the client should be numbered 801. It should be noted that while the SYN and ACK messages sent by the server are forwarded by PAD  to the customer application, these messages need not be forwarded to ECSC .","When the TCP agent at the client receives the SYN\/ACK message, the TCP agent returns an ACK message of 401, meaning that the first data byte sent by the server should be numbered 401. This ACK message is passed by PAD  to ECSC  to notify ECSC  that the three-way handshake is successful and the TCP session is open. ECSC  then adds the TCP session into its active session table and configures PAD  with an allowed number of TCP retransmissions and appropriate inactivity timer setting. ECSC  may also set marker\/policer  to mark packets belonging to this TCP session as high priority. ECSC  then returns the ACK segment to PAD , which sends the ACK segment to the destination server to inform the receiver that the TCP session is open. Once the customer's TCP agent informs the client application that the TCP connection is open, the client and server can begin exchanging data in the TCP session.","With reference now to , there is depicted a time-space diagram that illustrates exemplary network access system signaling to close a TCP connection in accordance with the present invention. While either side of a TCP connection can initiate disconnection of TCP session, in the example shown in , the server application initiates closure of the TCP session by instructing its TCP agent to close the connection. Accordingly, the server's TCP agent sends a FIN segment, informing the client application that it will send no more data. In response to receipt of FIN segment, PAD  resets the TCP state machine for the connection to idle state  and passes the FIN segment to ECSC . ECSC  responds by deleting the TCP session from its active session table and by configuring PAD  to stop marking packets for this TCP session and to remove the session's inactivity timer and retransmission settings. PAD  also forwards FIN segment to the client, which acknowledges receipt of the FIN segment with an ACK that is passed to the server by PAD . The client application then commands its TCP agent to close the session. The client's TCP agent therefore sends a FIN message to the server's TCP agent via PAD . The server's TCP agent responds to the client's FIN message with an ACK that indicates to PAD  that the three-way handshake to close the TCP session is successful. PAD  accordingly deletes the state machine for the TCP session and forwards the ACK message to the client. Meanwhile, the server's TCP agent notifies the server application that the connection is closed.","Referring now to , there is illustrated a time-space diagram showing exemplary network access system signaling in accordance with the present invention in response to a request for an unauthorized TCP session. As can be seen by comparison of  to , the process is identical up until the point at which policy server  returns an LDAP policy decision to ECSC  denying the TCP session. Policy server  may deny the TCP session, for example, because the network lacks sufficient resources to support the requested TCP session or because the client has not subscribed to the requested high priority e-commerce service. Following denial of the TCP session, ECSC  issues a reset (RST) segment to PAD , which sends the RST segment upstream to the TCP agent at the client. When the client's TCP agent receives the RST segment, the client's TCP agent aborts the session. It should be noted that because PAD  does not receive a SYN segment from ECSC , PAD  does not create a state machine for the TCP session.","With reference now to , there is illustrated a time-space diagram showing exemplary network access system signaling when excessive TCP retransmissions are detected. As will be appreciated, TCP sessions are normally closed through a proper disconnect, as illustrated in . However, in the event of a network or server failure, the TCP session will timeout in the host and a normal disconnect will not occur. Accordingly, some mechanism must be implemented to update ECSC  and PAD  when the TCP session disconnects.","In the example shown in , the route between the customer and the server is disrupted by failure of a network link or node. This failure causes the TCP agent and the client to re-transmit the data until a threshold number of retransmissions is reached. The client's TCP agent then aborts the TCP connection. Subsequently, the inactivity timer for the TCP session in PAD  expires. In response to expiration of the inactivity timer, PAD  updates state machine  of the TCP session to idle state  and reports the TCP session timeout error to ECSC . ECSC  responds to the report of the timeout error by deleting the TCP session from its active session table and instructs PAD  to stop marking the packets for the TCP session and to delete the configuration for this TCP session. PAD  then deletes the state machine for the TCP session.","With reference now to , there is depicted a time-space diagram illustrating exemplary network access system signaling when a TCP session participant requests an abrupt close to the TCP session. As illustrated, an application, which in this case is the server application, signals an abrupt close by sending a reset (RST) segment. The application can launch the abrupt close for a number of reasons, for example, because the application wishes to abort the connection or because the TCP agent has detected a serious communication problem that cannot be resolved. In response to receipt of the RST segment, PAD  resets the TCP state machine  for the session to idle state  and passes the RST segment to ECSC . In response to receipt of the RST segment, ECSC  deletes the TCP session from its active session table and configures PAD  to stop marking packets for this TCP session. PAD  then deletes the TCP state machine  for the session and forwards the RST segment to the client. The client then closes the TCP session upon receipt of the RST segment.","Connectionless Transport Examples Using UDP Reporting Function","With reference now to , there are depicted three examples of network access system signaling for connectionless transport protocols. In each example, the Unreliable Datagram Protocol (UDP) is employed.","Referring first to , there is depicted a time-space diagram of network access system signaling in which UDP is utilized as the transport for voice data of an IP telephony session. In the example illustrated in , a customer has ordered guaranteed service for his IP telephony (IPTEL) calls, but has a client that does not support the use of RSVP to reserve guaranteed service for the IPTEL calls. Nevertheless, the customer is able to obtain guaranteed service for an IPTEL call through the exchange of messages detailed below.","The process begins when a customer at the customer site invokes a client application to place an IPTEL call. The client application then obtains an unused UDP port from a pool of available ports assigned for voice data transmission. The client application then starts sending voice data encapsulated by UDP packets over the network as best-efforts traffic. PAD , which has been configured to detect a flow of UDP (i.e., Protocol Type (PT)=17) packets within the voice port range, detects the UDP flow and reports it to the IP Telephony Service Controller (IPTELSC)  within external processor . IPTELSC  queries policy server  for a policy decision via SPI , which in this example employs COPS. By reference to policy database , policy server  determines that the customer has ordered guaranteed service for his IPTEL calls and returns a policy decision to IPTELSC  that instructs IPTELSC  to provide guaranteed service for this IPTEL session, as defined by SA, DA, PT=17, SP and DP.","IPTELSC  accordingly configures PAD  with an inactivity timer for the session and instructs PAD  to stop reporting the occurrence of this IPTEL session. IPTELSC  also begins to set up a reserved bandwidth route for the IPTEL call since the customer's client application is incapable of doing so. To set up the reserved bandwidth route, IPTELSC  sends a RSVP PATH MESSAGE to PAD , which forwards the PATH MESSAGE downstream to the receiver. To indicate approval of the reservation, as well as the amount of reserved bandwidth, the receiver sends a RESV message to PAD , which forwards the RESV message to IPTELSC . A determination is then made whether a reservation of the specified bandwidth is authorized. If IPTELSC  has cached sufficient policy information following the previous query of policy server , IPTELSC  need not query policy server  regarding the bandwidth. If, however, insufficient policy information was cached in the policy cache  of IPTELSC , policy server  is again queried whether the specified bandwidth can be reserved. If the specified bandwidth is available for reservation by this customer, IPTELSC  initiates signaling via a signaling controller  to set up either a SVC or LSP for the IPTEL session. For an ATM core, a bi-directional SVC is set up. Alternatively, for an MPLS core, two unidirectional LSPs are set up. Another means of providing QoS to this UDP session involves IPTELSC  instructing marker  in PAD  to modify the differentiated service (DiffServ) field in the IP header. Once IPTELSC  receives a connect or confirm message from the network indicating that the QoS path has been established, IPTELSC  updates PAD  to associate the flow of UDP packets with the QoS path. In addition, IPTELSC  confirms that the QoS path is setup and reserved by passing a confirm message to PAD , which passes the confirm message to the receiver. Thereafter, voice data encapsulated in UDP packets are sent from the customer application to the receiver via the QoS path.","As shown in , in the event that the query of policy server  results in a policy decision indicating that the customer does not have a QoS requirement for IPTEL calls, IPTELSC  configures PAD  to prevent PAD  from reporting the IPTEL call again. In addition, IPTELSC  sets an inactivity timer for the IPTEL call so that the prevention of call reporting can be deleted when the inactivity timer expires. Because no QoS path is authorized, the voice data encapsulated by UDP packets continues to be transmitted over the network as best-effort traffic.","With reference now to , a time-space diagram is shown that illustrates network access system signaling utilized to tear down a QoS path in response to the expiration of a UDP session inactivity timer. While an UDP session inactivity timer can expire for a number of reasons including failure of a network link or node, in the example illustrated in , the timeout event is caused by the customer application at the customer site concluding a call and ceasing transmission of voice traffic. Sometime later, when the UDP session inactivity timer expires, PAD  detects the timeout event and reports it to IPTELSC . IPTELSC  responds by initiating appropriate signaling to release the SVC or LSPs for the IPTEL call, and the release is confirmed by a message to IPTELSC . IPTELSC  also invokes the pathtear message to explicitly tear down the QoS path for the IPTEL call. As this message is passed from PAD  through the network, the pathtear message removes installed RSVP states along the QoS path. IPTELSC  then deletes the IPTEL call from its active session table and configures PAD  to delete all configured parameters for the IPTEL call.","Application-Level Examples Using SIP Signaling","Referring now to , there are illustrated a number of time-space diagrams showing application-level SIP signaling in a network access system in accordance with the present invention. Referring first to , an example of SIP call establishment is shown. In the illustrated example, a caller at the customer site issues a SIP INVITE request to the callee in the network, for example, to invite the callee to participate in a multimedia conference call. When PAD  detects the invite request by the UDP or TCP port range assigned to SIP, PAD  passes the INVITE request to a Conference Call Service Controller (CCSC) . CCSC  then queries policy server  (e.g., utilizing an LDAP request) regarding whether the requested capability is approved for the customer. Importantly, to reduce the number of message exchanged between CCSC  and policy server , CCSC  preferably sets a flag in the query to request that policy server  dump the policy lookups for the SIP request into policy cache  of CCSC . In this manner, CCSC  can thereafter make policy decisions by reference to the cached policies and avoid unnecessary queries of policy server .","Assuming that policy server  approves the SIP session, policy server  sends CCSC  a policy decision indicating approval of the SIP session and dumps the policy rules for SIP calling into policy cache  of CCSC . In response to receipt of approval of the SIP session, CCSC  returns the INVITE message to PAD , which forwards the INVITE request toward the callee.","In response to receipt of the INVITE request, the callee returns a SIP 200 OK message to PAD , thereby indicating acknowledgement of the call without change in the specified SIP capability. Because there is no change in the SIP capability, PAD  forwards the SIP 200 OK message directly to the caller and does not pass the message to CCSC . The caller then acknowledges acceptance of the SIP 200 OK message via an ACK request, which PAD  passes to CCSC  to inform it of successful establishment of the SIP session. CCSC  then queries its policy cache  to approve the final capability set of the SIP call. CCSC  also adds the SIP session into its active session table and configures PAD  with an inactivity timer and other parameters to facilitate the SIP call. CCSC  then returns the ACK request to PAD , which in turns sends the ACK to the callee to complete SIP call establishment.","To obtain better performance, it is desirable to minimize message passing from PAD  to CCSC  and from CCSC  to policy sever . As discussed above, caching policy rules at CCSC  greatly reduces the number of required policy queries. Message passing from PAD  to CCSC  is preferably also reduced through implementation of a SIP state machine at PAD  that passes SIP messages to CCSC  only to establish, terminate, or change the capability set of a SIP session.","With reference now to , a time-space diagram is shown that illustrates exemplary network access system signaling for SIP call termination. In a multi-party SIP conference call, each party can only drop himself from the call, and the call is terminated after the last party leaves the call. In contrast, in a two-party SIP call, such as illustrated in , either the callee or the caller can terminate the call. As shown in , the caller at the customer site initiates call termination by sending a BYE request, which PAD  passes to CCSC . CCSC  responds to the BYE request by deleting the SIP session from its active session table and by cleaning its policy cache  of policy rules pertaining to the SIP session. CCSC  then configures PAD  to prevent PAD  from passing subsequent SIP messages from the SIP call to CCSC  and to delete the entire configuration for the SIP call. CCSC  also sends the BYE request to PAD , which forwards the BYE request to the callee. In response to receipt of the BYE request, the callee acknowledges the end of the SIP call by sending a SIP 200 OK message, which PAD  forwards to the caller without passing to CCSC .","Referring now to , there is illustrated a time-space diagram showing exemplary network access system signaling to end a SIP call that has exceeded the allowed duration. In the depicted example, termination of a SIP call is triggered by CCSC  detecting that the SIP call has exceeded the allowed duration specified by the session's ExpireTimer. The callee then issues a BYE request to terminate the call. In response to receipt of the BYE request, PAD  passes the BYE request to CCSC , which CCSC  deletes the SIP session from its active session table and removes associated policies from its policy cache . CCSC  then configures PAD  to prevent PAD  from passing to CCSC  subsequent SIP messages in the SIP call and commands PAD  to delete the entire configuration for the SIP call. CCSC  then issues a BYE request to PAD , which forwards the BYE request to both the caller and the callee. The caller and the callee then acknowledge the end of the SIP session via a SIP 200 OK message.",{"@attributes":{"id":"p-0136","num":"0138"},"figref":"FIG. 9D","b":["40","40","120","130","120","40"]},"Referring now to , there is depicted a time-space diagram showing exemplary network access system signaling during negotiation of SIP call capability requirements between a caller and a callee. As described above with respect to , a SIP call is initiated by a customer application at the customer site issuing a SIP INVITE request. This INVITE request is captured by PAD  and passed to CCSC , which queries policy server . Policy server  responds with approval of the SIP call and a download of the policy rules for this SIP session (as requested in the policy query). CCSC  then returns the INVITE request to PAD , which forwards it to the callee.","However, in contrast to the example illustrated in , the callee does not respond with a SIP 200 OK message confirming the SIP call. Instead, the callee responds with a SIP 606 NOT ACCEPTABLE message indicating that the requested call bandwidth is higher than that which can be supported by the access link of the callee and that only a 56 Kbps connection is available. As requested by the INVITE request, the callee response further indicates a set of media encodings, for example, that only PCM (pulse code modulation) or linear predictive coding (LPC) audio can be supported (in that order of preference). In response to receipt of the SIP 606 NOT ACCEPTABLE message, PAD  passes the message to CCSC , which queries its local policy cache  and approves the new capabilities set. CCSC  then sends the SIP 606 NOT ACCEPTABLE message back to PAD , which passes the message to the caller.","When the caller receives the SIP 606 NOT ACCEPTABLE response, the caller adjusts the call capability requirements and issues another INVITE request specifying a 56 Kbps bandwidth, LPC audio encoding and an ExpireTimer of 120 minutes. As before, the new INVITE request is passed to CCSC  by PAD . CCSC  then queries its local policy cache  and limits the call duration to 100 minutes according to resource availability. CCSC  then returns the INVITE request with an ExpireTimer of 100 minutes to PAD , which sends the INVITE request to the callee.","In response to receipt of this second INVITE request, the callee determines that it is able to support of all the call requirements including a call duration of 100 minutes. Accordingly, the callee responds with a SIP 200 OK message having an ExpireTimer set to 100 minutes. In response to receipt of the SIP OK response, PAD  sends the response to CCSC , which checks the SIP capability set carried in the SIP OK response by reference to its policy cache  and approves it. CCSC  then sends the SIP OK response to PAD , which forwards the SIP OK response to the caller. When the caller receives the SIP OK response, the caller modifies its ExpireTimer to 100 minutes and acknowledges the SIP OK response via an ACK request. PAD  passes the ACK response to CCSC , which approves the final SIP capability set carried in the ACK response. Following this approval, CCSC  configures PAD  with an inactivity timer and other parameters to facilitate the SIP call. CCSC  also returns the ACK message to PAD , which forwards the ACK message to the callee. Upon receipt of the ACK response by the callee, the SIP call is successfully established.","IP Multicast Examples","As implemented in current networks, IP multicast, that is, the delivery of packets to two or more receivers, employs an \u201copen group\u201d model of communication. According to the open group model, sources need only know a multicast address to which to send packets, but do not need to know the membership of a \u201cgroup\u201d participating in a multicast session and or to belong to the multicast group to which they are sending multicast packets. Moreover, there is no centralized group management entity with which group members need to register, synchronize, or negotiate, meaning that multicast group members can join or leave a multicast group at will.","Although the current open group model of multicast communication does not permit management or control of multicast communication, management and control of multicast group membership is important to both senders and receivers. For senders, it is important that only authorized sources are available to send packets to a multicast group. For example, content providers often wish to protect their exclusivity as the only source of data to a multicast group and desire to avoid denial-of-service attacks due to flooding by unauthorized sources. It is likewise important for the set of receivers in a multicast group to be controlled to restrict reception of packets to parties authorized by the sources. As an example, sources desire to restrict the receivers capable of receiving video distribution and video conferencing multicast packets. It view of the shortcomings in the conventional IP Multicast open group model outlined above, the network access system architecture of the present invention implements policy-based multicast service management as illustrated in .","Referring first to , there are depicted two time-space diagrams showing exemplary network access system signaling to manage registration of new multicast groups in accordance with the present invention. As shown in , a host at the customer site signals a desire to join a multicast group (which may be a new multicast group) by sending an Internet Group Multicast Protocol (IGMP) Join-Group Report Message to access router  through PAD . Packet header filter  of PAD , which is configured to capture IGMP messages by examining protocol type (PT=2), forwards the Join-Group Report Message to a Multicast Service Controller (MSC)  in external processor . In response to receipt of a Join-Group Report Message, MSC  queries policy server  via SPI , which in this case employs LDAP. Policy server  responds to the query by searching policy database  to determine if the host's IP address belongs to the eligible membership list for the multicast group.","As shown in , if policy server  determines that the host is not eligible to join the multicast group, policy server  returns a policy decision to MSC  rejecting the Join-Group request. MSC  responds to rejection of the request by dropping the Join-Group Message that prevents the unauthorized host from registering a new multicast group in access router . MSC  may also write the unauthorized attempt into an event log for use in detecting fraud attempts or denial of service attacks.","Alternatively, if policy server  approves the host's request to join the specified multicast group, as shown in , policy server  sends a policy decision indicating approval to MSC , which returns the Join-Group Report Message to PAD . PAD  then forwards the Join-Group Report message to access router . If the host is the first member of the multicast group on the network, access router  adds the multicast group reported in the Join-Group Report message to the list of multicast group memberships on the network to which the host is attached.","Referring now to  there are depicted time-space diagram illustrating exemplary network access system signaling that is utilized to manage host membership queries seeking to determine the membership of a multicast group. In the example shown in , PAD  receives an IGMP Host Membership Query message originating in the network from access router . Packet header filter  captures this IGMP message based upon its port number and passes the Host Membership Query message to MSC  in external processor . MSC  then queries policy server  via SPI  (which in this example employs LDAP) to ascertain whether the source address of the Host Membership Query Message is an authorized access router .","As shown in , if policy server  determines by reference to policy database  that the Host Membership Query message is from an unidentified or unauthorized source, policy server  returns a policy decision to MSC  rejecting the Host Membership Query. In response rejection of the Query, MSC  drops the Host Membership Query message and writes a warning message into its event log that may indicate a denial-of-service directed toward the network by flooding of unauthorized Host Membership Query messages.","If, on the other hand, policy server  approves the Host Membership Query and so indicates to MSC , as shown in , the Host Membership Query is returned to PAD , which forwards the Host Membership Query to the hosts in the customer site. Thus, the network access system of the prevent invention supports policy-based management of Host Membership Queries.","With reference now to , there are depicted time-space diagrams of exemplary network access system signaling utilized to manage sending of multicast packets to the network. In the examples shown in both of , a host at the customer site sends IP multicast packets addressed to a particular multicast group. When PAD  receives the first multicast packet, packet header filter  captures the packet after checking to determine whether packets having its multicast address had previously been received. PAD  then passes the first multicast packet to MSC  in external processor . MSC  queries policy server  via SPI  (which in this case employs LDAP) to determine whether the source address of the multicast packet is authorized to send multicast packets to the specified multicast group.","As shown in , in response to receipt of a policy decision rejecting the sending of the multicast packet (e.g., because the source sending the multicast packet is unidentified or unauthorized), MSC  configures PAD  to drop multicast packets for this combination of source and multicast address and writes a warning message into the event log that may indicate a denial-of-service attempt by a particular source flooding multicast packets onto the network. Alternatively, if MSC  receives a policy decision from policy server  approving the multicast packet as shown in , MSC  configures PAD  to directly forward multicast packets for this combination of source and multicast address to access router  and returns the first multicast packet to PAD . PAD  then forwards the first multicast packet to access router  and forwards all subsequent multicast packets in the flow directly to access router  without passing them to MSC . Thus, the network access system of the present invention utilizes policy-based decisions to permit ingress of authorized multicast packets and prevent ingress of unauthorized packets.","With reference now to , there are illustrated time-space diagrams of exemplary network access system signaling utilized to manage the receipt of multicast packets from the network. In the example shown in , access router  receives IP multicast packets from the network and forwards them to PAD . In response to receipt of the first multicast packet, packet header filter  of PAD  captures the multicast packet after checking to determine whether a packet having its multicast address had previously been received. Packet header filter  then passes the first multicast packet to MSC  in external processor , which queries policy server  to determine whether the source address of the multicast address is authorized to send multicast packets to the specified multicast group.","As shown in , if policy server  determines that receipt of multicast packets is unauthorized, for example, because the source of the multicast packets is unidentified or unauthorized, policy server  sends MSC  a policy decision rejecting receipt of the multicast packet. In response to rejection of receipt of the multicast packet, MSC  configures PAD  to drop multicast packets for this combination of source and multicast address and writes a warning message into the event log that may indicate unauthorized multicast packets from the specified source address attempting to flood the sub-network in the customer site. As a result, subsequent multicast packets containing the same combination of source and multicast address are dropped by PAD .","Alternatively, as shown in , if policy server  approves receipt of the multicast packet, MSC  configures PAD  to directly forward subsequent packets containing the same combination of source and multicast address directly to the customer site. MSC  also returns the first multicast packet to PAD , which forwards the first multicast packet and subsequent multicast packets to the customer site. As illustrated in , subsequent multicast packets in the flow are forwarded by PAD  directly to the customer site without passing them to MSC .","As has been described, the present invention introduces a distributed network access system architecture. The distributed network access system architecture of the present invention replaces a conventional monolithic edge router with a programmable access device containing at least filtering and forwarding functionality, an external processor having one or more service-specific service controllers that implement policy-based control of the PAD, and an access router that performs basic routing. This distributed architecture has numerous benefits over conventional monolithic router architectures, including scalability, flexibility, extensibility, interoperability, security, and service provisioning.","The network access architecture of the present invention achieves superior scalability as compared to conventional monolithic routers by virtue of the distribution of functionality among three logical modules: a programmable access device, an external processor providing service control, and an access router. In particular, by separating the routing performed by the access router from the functionality implemented by the programmable access device and external processor, additional traffic and services can be handled without overloading the access router simply by adding external processor modules and programmable access devices according to service requirements and customer demand. In addition, as Internet traffic patterns continue to change from locally concentrated to globally distributed, the ability to apply service and policy control at the network access point separately from regional routing provides a more scalable design for forwarding traffic toward distant destinations.","The distributed network access system architecture of the present invention also provides improved flexibility. Such flexibility is a natural outgrowth of the ability of a service provider and\/or customer to implement policies that govern the service control and programmability of functional modules of the programmable access device. For example, the packet header filters of the programmable access device can be configured to distinguish packet flows based on any arbitrary combination of SA, DA, TOS\/DSCP, PT, SP, and DP, as well as higher-layer protocol information, such as TCP, SIP, and IGMP. In addition, the monitors of the programmable access device can be programmed by the service controllers of the external processor to collect statistics for arbitrary combinations of SA, DA, TOS\/DSCP, PT, SP, DP, or other fields and to report on events (e.g., excessive TCP retransmissions and RTP\/UDP inactivity) based upon the collected statistics. One particularly useful application of such monitoring is tracking statistics for different layer-2, layer-3, layer-4 and higher layer traffic types to ensure that active SLAs are maintained throughout the network. This policy-based approach for providing dynamic SLA support in the network is a more flexible solution than the current TDM (Time Division Multiplexing) approach to SLAs.","The advantage of extensibility arises in part because of the service-specific control provided by the service controllers in the external processor. Such service-specific control can be implemented either with dedicated service controllers or with generic controllers that each support service-specific APIs. Regardless of the chosen implementation, new services can be introduced simply by adding new service controllers or modifying existing service controllers. The addition of new services does not require any alteration to the programmable access device, access router, or other service controllers. Thus, other services are not disrupted during service upgrades. Moreover, because the service controllers are independent of the programmable access device and access router, the development of new services and upgrading of existing services is not dependent upon vendors of proprietary hardware, which greatly reduces the time and cost for developing or upgrading services.","The extensibility of the present invention is also attributable to the additional monitoring functions that may be implemented in the programmable access device, for example, to verify conformance to standards, debug code, and assist fault diagnosis by saving and reporting memory dumps and other related information to the service controllers. Such capability is not integrated into conventional switches or routers and is usually achieved only by the addition of external network monitoring devices. The enhanced usage monitoring provided by the present invention enables a service provider to sell network resources (i.e., capacity) dynamically while still conforming to SLAs. This not only improves network utilization, but also automates traffic engineering, which reduces network management expenses.","As noted above, the distributed network access system of the present invention distributes network access functionality among a programmable access device, an external processor providing service control, and an access router. Because these different components communicate via well-defined interfaces, interoperability is not dependent upon all the hardware or software components being developed by the same vendor.","The present invention also provides enhanced security against theft of services and network attacks. For example, the external processor may be maintained in a secure environment while leaving the forwarding functions of the programmable access device in a less-secure environment. In addition, security software and\/or hardware can easily be integrated into the external processor so that sessions to configure the programmable access device from IP addresses other than its master external processors (as well as other unauthorized communication) are denied by the packet header filter of the programmable access device without being passed into the network.","The present invention also has enhanced service provisioning. Since the programmable access device intercepts network, transport and application level messages, thereby enabling the identification of applications and users, the network access system of the present invention can establish appropriate priorities for or provide desired bandwidth to data flows of user applications. For example, by employing RSVP and a LAN subnet bandwidth manager (SBM), a customer application can be provided with guaranteed bandwidth and priority end-to-end across local and wide area networks. Importantly, the policies that enable customer applications to reserve bandwidth, perform admission control, and prioritize traffic streams based upon available network capacity can be determined not only by the service provider but also by customers. Thus, customer applications can interact with service provider network resources to dynamically provision services and provide applications with a guaranteed quality of service. This network-based provisioning invoked by policy control replaces time-consuming and error-prone OSS (Operation and Support System) provisioning, thereby reducing the intensity and the cost of the network provisioning for IP-centric customer applications.","Even with the above advantages, the distributed network access system architecture of the present invention can provide a cost-effective network solution. Currently, the trend is for service providers to push more \u201cintelligent\u201d and therefore more expensive devices to the edge of their network designs. However, this design requires customers to purchase intelligent and therefore expensive CPEs (Customer Premises Equipment). In contrast, the distributed network access system architecture of the present invention supports relatively inexpensive PADs, which enables customers to purchase sufficient intelligence to provide service delivery without undue expense.","While the invention has been particularly shown and described with reference to a preferred embodiment, it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention. For example, although aspects of the present invention have been described with respect to a computer system executing software that directs the functions of the present invention, it should be understood that present invention may alternatively be implemented as a program product for use with a data processing system. Programs defining the functions of the present invention can be delivered to a data processing system via a variety of signal-bearing media, which include, without limitation, non-rewritable storage media (e.g., CD-ROM), rewritable storage media (e.g., a floppy diskette or hard disk drive), and communication media, such as digital and analog networks. It should be understood, therefore, that such signal-bearing media, when carrying or encoding computer readable instructions that direct the functions of the present invention, represent alternative embodiments of the present invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself however, as well as a preferred mode of use, further objects and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0020","num":"0022"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0021","num":"0023"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0022","num":"0024"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0023","num":"0025"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0024","num":"0026"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0025","num":"0027"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0026","num":"0028"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0027","num":"0029"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0028","num":"0030"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0029","num":"0031"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0030","num":"0032"},"figref":"FIG. 7C"},{"@attributes":{"id":"p-0031","num":"0033"},"figref":"FIG. 7D"},{"@attributes":{"id":"p-0032","num":"0034"},"figref":"FIG. 7E"},{"@attributes":{"id":"p-0033","num":"0035"},"figref":"FIG. 7F"},{"@attributes":{"id":"p-0034","num":"0036"},"figref":"FIG. 7G"},{"@attributes":{"id":"p-0035","num":"0037"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0036","num":"0038"},"figref":"FIG. 8B"},{"@attributes":{"id":"p-0037","num":"0039"},"figref":"FIG. 8C"},{"@attributes":{"id":"p-0038","num":"0040"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0039","num":"0041"},"figref":"FIG. 9B"},{"@attributes":{"id":"p-0040","num":"0042"},"figref":"FIG. 9C"},{"@attributes":{"id":"p-0041","num":"0043"},"figref":"FIG. 9D"},{"@attributes":{"id":"p-0042","num":"0044"},"figref":"FIG. 9E"},{"@attributes":{"id":"p-0043","num":"0045"},"figref":"FIG. 10A"},{"@attributes":{"id":"p-0044","num":"0046"},"figref":"FIG. 10B"},{"@attributes":{"id":"p-0045","num":"0047"},"figref":"FIG. 10C"},{"@attributes":{"id":"p-0046","num":"0048"},"figref":"FIG. 10D"},{"@attributes":{"id":"p-0047","num":"0049"},"figref":"FIG. 10E"},{"@attributes":{"id":"p-0048","num":"0050"},"figref":"FIG. 10F"},{"@attributes":{"id":"p-0049","num":"0051"},"figref":"FIG. 10G"},{"@attributes":{"id":"p-0050","num":"0052"},"figref":"FIG. 10H"}]},"DETDESC":[{},{}]}
