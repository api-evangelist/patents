---
title: Garbage collection based on total resource usage and managed object metrics
abstract: A method includes selectively controlling, at a computing device having a memory, initiation of a full garbage collection operation based on a total resource usage metric and a managed object metric. The managed object metric is based on objects managed by a runtime application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09384129&OS=09384129&RS=09384129
owner: Microsoft Technology Licensing LLC
number: 09384129
owner_city: Redmond
owner_country: US
publication_date: 20110616
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Memory allocations in computer systems can typically be classified as either static allocations or dynamic allocations. Generally, the size and lifetime of statically allocated memory may be known before runtime (e.g., expressly defined in source code). Conversely, the size and lifetime of dynamically allocated objects in memory (e.g., in a \u201cheap\u201d portion of the memory) may vary during runtime. The process of monitoring dynamic memory operations may be referred to as memory management. Memory management may help prevent undesirable situations such as memory leaks in which memory space that is dynamically allocated by an application is not deallocated, thereby becoming \u201clost\u201d to the application.","Garbage collectors are memory management tools that can deallocate dynamically allocated memory. When dynamically allocated objects in a managed heap are independent of objects outside the scope of the managed heap, garbage collectors may provide relatively stable and reliable memory management. However, dynamically allocated objects may include or refer to objects that are outside the scope of the managed heap (e.g., native objects), and vice versa. In this scenario, the garbage collector may not be able to deallocate managed objects from the managed heap until one or more associated native objects have been collected.","One type of garbage collector is the generational garbage collector. Generational garbage collectors may operate on the premise that a majority of the dynamically allocated objects that are collectable during a garbage collection operation are those objects that have most recently been allocated. If a dynamically allocated object survives a garbage collection operation, it may be \u201cpromoted\u201d to a higher (i.e., older) generation. For example, the objects in \u201cgeneration 0\u201d of a heap may be newer than objects stored in \u201cgeneration 1\u201d of the heap, and the objects stored in \u201cgeneration 1\u201d of the heap may be newer than the objects stored in \u201cgeneration 2\u201d of the heap. Based on the assumption that newly allocated (i.e., generation 0) objects will be more commonly collected than older (i.e., generation 1 and generation 2) objects, a generational garbage collector may perform two types of garbage collection operations: a full garbage collection and an ephemeral (e.g., partial) garbage collection. Whether a full garbage collection or ephemeral garbage collection is performed may depend on how much heap space is consumed by managed objects (i.e., objects that the garbage collector is aware of).","In a full garbage collection, the garbage collector may pause running applications and sweep all generations of the heap for \u201cdead\u201d objects (e.g., objects that are no longer needed by any running applications). In an ephemeral garbage collection, the garbage collector may sweep the newest generation (e.g., generation 0) for \u201cdead\u201d objects, sometimes without pausing running applications. Once an object (and any other objects included therein) is promoted out of generation 0, the object may no longer be collectable during an ephemeral garbage collection. Thus, it may be undesirable to have large objects residing in older generations of the heap, especially after the objects become collectable. The use of ephemeral garbage collection, when possible, may be preferable to the use of full garbage collection, as ephemeral garbage collection may avoid stopping or pausing executing applications.","In some computing systems, managed objects may include references (e.g., pointers) to larger native objects that the garbage collector is unaware of Since the native object is referred to by the managed object, the native object may not be freed up until the managed object is collectable. In such situations, initializing garbage collection based solely on how much space is occupied by managed objects may not be effective. For example, a relatively small managed object may be promoted out of generation 0 even though the managed object has a reference to a much larger native object. Since full garbage collections may occur less frequently than ephemeral garbage collections, an effective size of the heap may be reduced due to the existence of large native objects in higher generations of the heap, which may lead to application crashes.","Systems and methods of garbage collection based on a total resource usage metric and a managed object metric are disclosed. For example, a memory manager may determine whether to initialize a full garbage collection operation or an ephemeral garbage collection operation based on managed object size as well as total heap usage. By considering multiple metrics, the memory manager may reduce how often managed objects having references to larger native objects are promoted out of generation 0, which may result in more available heap space and fewer application crashes.","The use of the same reference symbols in different drawings indicates similar or identical items.","The disclosed techniques may include determining whether to initiate a full garbage collection operation or an ephemeral garbage collection operation based on multiple metrics. For example a total resource usage metric and a managed object metric may be used in the determination. Using a combination of total memory (e.g., heap) usage and managed object usage may lead to more efficient memory management and fewer application crashes.","In a particular embodiment, a computer-implemented method includes selectively controlling, at a computing device having a memory, initiation of a full garbage collection operation based on a total resource usage metric and a managed object metric. The managed object metric is based on a number or size of objects managed by one or more runtime applications.","In another particular embodiment, a computer system includes a processor and a memory coupled to the processor. The memory stores a heap and a memory manager. The memory manager is executable by the processor to determine whether to initiate a full garbage collection operation or an ephemeral garbage collection operation on the heap based on a total resource usage metric and a managed object metric that is based on objects allocated in the heap and managed by one or more runtime applications. The memory also stores a generational garbage collector that is executable by the processor to perform the full garbage collection operation or the ephemeral garbage collection operation based on the determination.","In another particular embodiment, a computer-readable storage medium includes instructions that, when executed by a computer, cause the computer to determine whether a ratio of a total resource usage metric to a managed object metric is greater than a threshold, where the managed object metric is based on a number or size of objects managed by one or more runtime applications. The instructions, when executed by the computer, also cause the computer to initiate a full garbage collection operation when the ratio is greater than the threshold. The instructions, when executed by the computer, further cause the computer to determine whether the total resource usage metric is greater than a maximum total resource usage when the ratio is not greater than the threshold. The instructions, when executed by the computer, cause the computer to initiate the full garbage collection operation when the total resource usage metric is greater than the maximum total resource usage. The instructions, when executed by the computer, also cause the computer to, when the total resource usage metric is not greater than the maximum total resource usage, determine whether a size of a heap increased by a growth amount greater than a growth threshold. The instructions, when executed by the computer, further cause the computer to initiate the full garbage collection operation when the growth amount is greater than the growth threshold and to initiate an ephemeral garbage collection operation when the growth amount is less than the growth threshold.","Referring to , a particular embodiment of a computing device  is shown. The computing device  includes a system memory , an operating system , an application framework , and a representative managed application  (or multiple applications). The system memory  includes a stack  and a heap that is divided into a managed heap  and a native heap . The managed heap  may store multiple generations (e.g. generations , , and ) of dynamically allocated data. The managed heap  includes a first portion  supporting generation 0, a second portion  supporting generation 1, and a third portion  supporting generation 2 data. The native heap  may store native objects. Managed objects stored in the managed heap  may include references to native objects stored in the native heap , and vice versa.","The application framework  includes a memory manager . The memory manager  includes logic  to perform garbage collection metric measurement and ratio calculations. The memory manager  may access a finalizer list  that is also accessible by generational garbage collector . The finalizer list  may represent a list of objects that have a finalizer method and are marked as \u201clive\u201d by the generational garbage collector . One or more finalizer threads (not shown) of the application framework  may execute the finalizers of objects in the finalizer list  so that the objects can be deallocated from the managed heap . Generally, the finalizer of an object may include clean-up operations that a programmer indicates are to be performed before the object is deallocated. For example, the finalizer of a managed object may include a call to a finalizer of native object that is stored in the native heap  and that is referenced by the managed object.","The application framework  receives memory allocation and deallocation requests  from one or more managed applications . The application framework  may generate native operating system calls  based on the requests , where the native operating system calls  are sent to the operating system . In a particular embodiment, the operating system  is a Windows\u00ae, Windows\u00ae Phone, or Windows\u00ae Mobile operating system that is available from Microsoft Corporation of Redmond, Wash., USA (Windows\u00ae is a registered trademark of Microsoft Corporation in the United States and other countries). In a particular illustrative embodiment, the application framework  may be a framework that supports a mobile application or another type of embedded environment supported by .NET, common language runtime (CLR), or similar technologies. For example, the application framework  may be a mobile application framework such as Silverlight\u00ae, available from Microsoft Corporation (Silverlight\u00ae is a registered trademark of Microsoft Corporation in the United States and\/or other countries). It should be noted that such technologies are listed for example only. The garbage collection techniques disclosed herein may also be used with other operating system, application, and runtime technologies.","The system memory  includes the stack  which contains one or more managed object references. For example, an illustrative managed object reference  is stored within the stack . The managed object reference  may be created in the stack  by the managed application . The managed object reference  may correspond to a managed object  stored in the managed heap . Upon creation, the managed object  may be stored in generation 0 of the managed heap , as illustrated in . The managed object  may include a native object reference  to a native object  that is stored in the native heap . In a particular embodiment, the managed object  may be a dynamically allocated file handler, software handler, network connection, network socket, process resource (e.g., a mutex or a semaphore), or a user interface (UI) element, such as a Button, a GridControl, or another UI element.","During operation, the application framework  supports the memory manager  that may respond to the memory allocation or deallocation requests . In a particular embodiment, the memory manager , in response to receiving a memory allocation request or in response to another memory allocation trigger, determines whether to initiate a full garbage collection or an ephemeral garbage collection operation on the managed heap . The determination of whether to initiate a full garbage collection operation or an ephemeral garbage collection is based on a total resource usage metric and a managed object metric based on the objects allocated in the heap and managed by a runtime application. Alternatively, the managed object metric may be based on objects managed by all runtime applications being executed at the computing device . For example, the garbage collection metric measurement and ratio calculation logic  may measure garbage collection metrics and may calculate ratios that are used to determine whether to perform a full garbage collection operation on the heap or an ephemeral garbage collection operation on the managed heap , as further described with reference to . The generational garbage collector  is responsive to commands from the memory manager  and may perform either the full garbage collection operation or the ephemeral garbage collection operation based on the determination made by the memory manager .","During operation, the managed application  may reach a point of execution when the managed object  on the managed heap  is no longer needed. In response, the managed application  may delete the managed object reference . However, if the managed object  has been promoted out of generation 0, an ephemeral garbage collection operation may not successfully deallocate the managed object  and its associated native object , as further illustrated in .","Referring to , a particular embodiment of a method of performing garbage collection  is shown. A managed application  (e.g., the managed application  of ) may own a managed object reference  (e.g., the managed object reference  of ). The managed object reference  may refer to a managed object  (e.g., the managed object  of ). The managed object  may include a native object reference  (e.g., the native object reference  of ), which refers to a native object  (e.g., the native object  of ). In the particular embodiment illustrated in , the managed object  may occupy one megabyte (1 MB) of heap space and the native object  may occupy 9 MB of heap space. Thus, a total memory usage (T) may be equal to 10 MB and a managed object usage (M) may be equal to 1 MB. In this illustrated example, a total memory usage\/managed object usage (T\/M) ratio may be equal to 10.","In response to a first ephemeral garbage collection operation, the objects within generation 0 are promoted to generation 1, as shown at . Subsequently, the managed application  may delete the managed object reference , as indicated at . Since the only reference to the managed object  has been deleted, the managed object  is \u201cdead\u201d and collectable (i.e., the memory corresponding to the object  and the associated native object  may be recovered by the garbage collector). However, since the managed object  is in generation 1, executing an ephemeral garbage collection based solely on the space occupied by managed objects (i.e., based on M=1 MB) would not finalize and deallocate the native object , as indicated at  (e.g., since a finalizer method of the native object  may not be executed until a finalizer method of the managed object  executes). As the size of generation 1 of the heap increases, the likelihood of an application crashing or an operating system terminating a running application due to lack of available memory also increases. Instead, determining to initiate a full garbage collection based on the T\/M ratio=10 MB may successfully deallocate the objects  and . Accordingly, for the illustrated example, it is preferable to perform a full garbage collection operation in response to evaluating the T\/M ratio, as indicated at . In a particular embodiment, the determination to initiate the full garbage collection operation based on the T\/M ratio is performed by a memory manager (e.g., the memory manager  of ).","Thus, selectively controlling initiation of a full garbage collection operation based on both a total usage metric and a managed object metric, as illustrated in , may be preferable to controlling initiation of the full garbage collection operation based solely on managed object usage.","Referring to , a particular illustrative embodiment of a method  of performing garbage collection or of controlling a garbage collection operation is shown. The method  includes selectively controlling, at a computing device having a memory, initiation of a full garbage collection operation based on a total resource usage metric and a managed object metric, at . The managed object metric is based on objects managed by one or more runtime applications (e.g., a size and\/or a number of all managed objects in a heap). An example of a runtime application includes a CLR application and\/or a mobile application.","The method  further includes initiating either the full garbage collection operation or an ephemeral garbage collection operation, at , based on the determination made as a function of the total resource usage metric and the managed object metric. The method  may repeat as memory allocations and deallocations take place. In a particular embodiment, the decision to initiate the method  is performed (e.g., by a memory manager such as the memory manager  of ) when a requested allocation of memory exceeds a particular threshold. For example, the method  to selectively control garbage collection may be initiated as each megabyte of memory is allocated and after a heap has reached a minimum size (e.g., 20 MB)","Referring to , a particular detailed embodiment of a method  of controlling and performing garbage collection is shown. The method  includes determining a ratio of a total resource usage metric to a managed resource usage metric, at . For example, the method  may be initiated, at , after each megabyte of managed allocation of the memory once the total resource usage exceeds a minimum threshold (e.g., 20 megabytes), as shown. Examples of managed objects include dynamically allocated file handlers, software handlers, network connections, network sockets, and process resources.","The method  further includes comparing the ratio to a threshold, as shown at . For example, the T\/M ratio may be compared to a T\/M threshold. If the T\/M ratio exceeds the T\/M threshold, at , the method  proceeds to initiate a full garbage collection operation with respect to each generation of allocated objects in a heap, at . Performing the full garbage collection may include performing operations illustrated with respect to  and referenced as \u201cA\u201d  in . The method  may automatically adjust the T\/M threshold, at . Automatically adjusting the T\/M threshold may include performing operations illustrated with reference to  and referenced as \u201cC\u201d  in .","Referring to step , if the T\/M ratio does not exceed the T\/M threshold, then the method  compares the total memory usage T to a maximum total memory usage T, at . In a particular embodiment, the maximum total memory usage is determined based on an application programming interface (API) call to an operating system. For example, a GetApplicationCap( ) function may provide a maximum heap size, and Tmay be equal to the maximum heap size minus a buffer value (so that a full garbage collection is triggered before the maximum heap size is reached). In a particular embodiment, the buffer value is the lesser of twice the T\/M ratio threshold (in megabytes) and 15 MB.","In a particular embodiment, the method  may include performing an additional check (not shown), at , to verify that at least a certain number of ephemeral garbage collection operations (e.g., 5) have been performed since a previous T\/M ratio-triggered full garbage collection operation. For example, a particular application may have a high T\/M ratio because managed objects holding native objects may be remain alive. For such an application, without the additional check, all or a majority of garbage collection operations may turn into T\/M ratio-triggered full garbage collection operation. However, when there are no or few ephemeral garbage collection operations, benefits of generational garbage collection may not be realized.","If the total memory usage exceeds the maximum total memory usage at , then the full garbage collection operation is initiated, at , and performed, at . The T\/M threshold may also be adjusted, at -. If the total memory usage does not exceed the maximum total memory usage, at , then an amount that the heap has grown since a previous garbage collection operation is compared to a growth threshold, at . In a particular embodiment, the growth threshold is 5 MB.","If the heap growth has exceeded the growth threshold, at , then the method  initiates and performs a full garbage collection operation, at -. If the heap growth has not exceeded the growth threshold, at , the method  initiates an ephemeral garbage collection operation with respect to a newest generation of allocated objects in the heap, at . Performing the ephemeral garbage collection may include performing operations illustrated with respect to  and referenced as \u201cB\u201d  in .","Referring to , a method  of performing a full garbage collection operation is shown. The method  may begin at \u201cA\u201d , corresponding to the label \u201cA\u201d at , , and  of .","The method  includes stopping execution of the managed application, at . The method  also includes determining whether each allocated object in each generation of the heap is reachable (i.e., \u201calive\u201d if at least one reference to the object exists) or unreachable (i.e., \u201cdead\u201d if no references to the object exist), at .","The method further includes adding the unreachable objects in each generation to a finalizer list, at , and moving the reachable objects to a contiguous portion of the heap, at . In a particular embodiment, consolidating objects into a contiguous portion of the heap reduces heap fragmentation and improves memory latency of the computing device. Consolidating objects may also include modifying existing references to the objects. Such modification of references may be permissible since the managed application was stopped, at . The method  includes resetting generation boundaries, at , and restarting execution of the managed application, at . Judicious initiation and performance of full garbage collection, as illustrated in , may improve an amount of available heap space at a computing device.","Referring to , a method  of performing an ephemeral garbage collection operation is shown. The method  may begin at \u201cB\u201d , corresponding to the label \u201cB\u201d  of .","The method  includes determining whether each allocated object in generation zero (i.e., a newest generation) of the heap is reachable or unreachable, at . The method  also includes adding the unreachable objects in generation zero to a finalizer list, at , and promoting the reachable objects in generation zero to generation one, at . If additional generations exist, the method  may include promoting objects from generation 1 to generation 2, etc., at . It will be appreciated that since the ephemeral garbage collection method  may not relocate objects in the heap, the ephemeral garbage collection method  may be performed without stopping executing of running applications.","It should be noted that the full garbage collection and ephemeral garbage collection methods  and  of  are for example only. The steps and order of steps performed by the garbage collector may vary depending on an underlying operating system and application framework.","Referring to , a method  of automatically adjusting the T\/M threshold is shown. The method  may begin at \u201cC\u201d , corresponding to the label \u201cC\u201d at  and  of .","The method  includes determining an active finalizer ratio, at . The active finalizer ratio may be equal to a ratio of how many generation 1 finalizers are active (i.e., how many objects are marked \u201clive\u201d by the garbage collector and listed on a finalizer list) after full garbage collection to how many generation 1 finalizers were active before full garbage collection. To illustrate, if more generation 1 finalizers are active after full garbage collection than before full garbage collection (i.e., the finalizer ratio is increasing), this may mean that the garbage collections triggered by the T\/M ratio are occurring too frequently, resulting in wasted processor cycles. Conversely, if the finalizer ratio is decreasing, this may mean that more frequent garbage collections triggered by the T\/M ratio may be preferable.","Accordingly, when the active finalizer ratio is within a finalizer range (e.g., 0.5-0.95), the method  leaves the T\/M threshold unchanged, at . When the active finalizer ratio is less than the finalizer range (e.g., less than 0.5), the T\/M threshold is decreased, at . When the active finalizer ratio is greater than the finalizer range (e.g., greater than 0.95), the T\/M threshold is increased, at . Thus, the T\/M threshold may be dynamically adjusted based on the finalizer ratio to achieve a more efficient timing and frequency of full and ephemeral garbage collection operations.","Thus, a computer-implemented method has been described that includes selectively controlling initiation of a full garbage collection operation based on a total resource usage metric and a managed object metric. The computer implemented method is performed at a computing device. The managed object metric is based on those objects managed by a runtime application. Alternatively, the managed object metric may be based on objects managed by all runtime applications currently being executed by a processor of the computing device.","In a particular example, the runtime application is a common language runtime (CLR) application, a mobile application, or any combination thereof The total resource usage metric is a measurement of total memory usage of the computing device and the managed object metric is a measurement of the amount of memory allocated to the managed objects. The method may further include determining whether to perform a full garbage collection (e.g., as illustrated in ) or an ephemeral garbage collection (e.g., as illustrated in ) based on a ratio of the total resource usage metric (T) and the managed object metric (M), where the ratio is T\/M. The determination may be made after each megabyte of managed memory allocation. However, the determination may not be made until the total resource usage metric is greater than a minimum total resource usage (e.g., 20 MB).","The T\/M threshold for comparison to the T\/M ratio may be greater than or equal to 5 and less than or equal to 15. While the T\/M ratio is within the range of 5 to 15, the T\/M ratio may be set to a default ratio or may be programmed according to user selection and\/or system parameters. In addition, the T\/M threshold may be adjusted automatically. Automatically adjusting the T\/M threshold may include a method based on determining and evaluating an active finalizer ratio, as illustrated with respect to . A finalizer range for use in the finalizer ratio comparison operation may have a lower bound of 0.5 and an upper bound of about 0.95 in a particular illustrative example. A full garbage collection operation may also be initiated when the heap has grown by more than a growth threshold (e.g., 5 MB) since a previous garbage collection operation. When the T\/M ratio is less than the T\/M threshold, the total memory usage is less than the maximum total memory usage, and the heap has not grown by more than the growth threshold, an ephemeral garbage collection operation may be initiated.","Referring to , a particular embodiment of a computing environment  including a computing device  that is operable to support embodiments of systems, methods, and computer program products according to the present disclosure is shown. The computing device  includes at least one processor  and a system memory . Depending on the configuration and type of computing device, the system memory  may be volatile (such as random access memory or \u201cRAM\u201d), non-volatile (such as read-only memory or \u201cROM,\u201d flash memory, and similar memory devices that maintain stored data even when power is not provided), or some combination of the two.","The system memory  may include an operating system , an application platform , a managed application , a managed heap , and a native heap . The managed heap  may include multiple generations of dynamically allocated data, such as illustrated generation 0, at , generation 1, at , and generation 2, at . While three generations have been illustrated, it should be understood that the managed heap  may include any number of generations, such as two generations or more than three generations, based on the particular application and system configuration.","The application platform  includes a memory manager  that includes logic  to perform garbage collection metric measurement and ratio calculation. The memory manager  also includes a generational garbage collector . The generational garbage collector  may selectively perform full garbage collection or ephemeral garbage collection on the managed heap  responsive to needs of the managed application  and based on metrics and ratios calculated by the logic . In a particular embodiment, the memory manager  may perform the methods , , and  of , and the generational garbage collector  may perform the methods  and  of .","The computing device  may also have additional features or functionality. For example, the computing device  may include removable and\/or non-removable additional data storage devices, such as magnetic disks, optical disks, tape devices, and standard-sized or flash memory cards. Such additional storage is illustrated in  by removable storage  and non-removable storage . Computer storage media may include volatile and\/or non-volatile storage and removable and\/or non-removable media implemented in any technology for storage of information such as computer-readable and computer-executable instructions, data structures, program components or other data. The system memory , the removable storage  and the non-removable storage  are all examples of computer storage media. The computer storage media includes, but is not limited to, RAM, ROM, electrically erasable programmable read-only memory (EEPROM), flash memory or other memory technology, compact disks (CD), digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium that can be used to store information and that can be accessed by the computing device . Any such computer storage media may be part of the computing device .","The computing device  may also have input device(s) , such as a keyboard, mouse, pen, voice input device, touch input device, motion or gesture input device, etc, connected via one or more wired or wireless input interfaces. Output device(s) , such as a display, speakers, printer, etc. may also be connected via one or more wired or wireless output interfaces.","The computing device  also contains one or more communication connections that allow the computing device  to communicate with other computing devices  over a wired or a wireless network. It will be appreciated that not all of the components or devices illustrated in  or otherwise described in the previous paragraphs are necessary to support embodiments as herein described. For example, the removable storage  may be optional.","The illustrations of the embodiments described herein are intended to provide a general understanding of the structure of the various embodiments. The illustrations are not intended to serve as a complete description of all of the elements and features of apparatus and systems that utilize the structures or methods described herein. Many other embodiments may be apparent to those of skill in the art upon reviewing the disclosure. Other embodiments may be utilized and derived from the disclosure, such that structural and logical substitutions and changes may be made without departing from the scope of the disclosure. Accordingly, the disclosure and the figures are to be regarded as illustrative rather than restrictive.","Those of skill would further appreciate that the various illustrative logical blocks, configurations, modules, and process steps or instructions described in connection with the embodiments disclosed herein may be implemented as electronic hardware or computer software. Various illustrative components, blocks, configurations, modules, or steps have been described generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. Skilled artisans may implement the described functionality in varying ways for each particular application, but such implementation decisions should not be interpreted as causing a departure from the scope of the present disclosure. For example, a calendar application may display a time scale including highlighted time slots or items corresponding to meetings or other events.","The steps of a method described in connection with the embodiments disclosed herein may be embodied directly in hardware, in a software module executed by a processor, or in a combination of the two. A software module may reside in computer readable media, such as random access memory (RAM), flash memory, read only memory (ROM), registers, a hard disk, a removable disk, a CD-ROM, or any other form of storage medium known in the art. An exemplary storage medium is coupled to a processor such that the processor can read information from, and write information to, the storage medium. In the alternative, the storage medium may be integral to the processor or the processor and the storage medium may reside as discrete components in a computing device or computer system.","Although specific embodiments have been illustrated and described herein, it should be appreciated that any subsequent arrangement designed to achieve the same or similar purpose may be substituted for the specific embodiments shown. This disclosure is intended to cover any and all subsequent adaptations or variations of various embodiments.","The Abstract of the Disclosure is provided with the understanding that it will not be used to interpret or limit the scope or meaning of the claims. In addition, in the foregoing Detailed Description, various features may be grouped together or described in a single embodiment for the purpose of streamlining the disclosure. This disclosure is not to be interpreted as reflecting an intention that the claimed embodiments require more features than are expressly recited in each claim. Rather, as the following claims reflect, inventive subject matter may be directed to less than all of the features of any of the disclosed embodiments.","The previous description of the embodiments is provided to enable a person skilled in the art to make or use the embodiments. Various modifications to these embodiments will be readily apparent to those skilled in the art, and the generic principles defined herein may be applied to other embodiments without departing from the scope of the disclosure. Thus, the present disclosure is not intended to be limited to the embodiments shown herein but is to be accorded the widest scope possible consistent with the principles and novel features as defined by the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present disclosure may be better understood, and its numerous features and advantages made apparent to those skilled in the art by referencing the accompanying drawings.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 7","FIG. 4"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 8","FIGS. 1-7"]}]},"DETDESC":[{},{}]}
