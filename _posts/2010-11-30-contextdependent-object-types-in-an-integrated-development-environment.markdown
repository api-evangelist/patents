---
title: Context-dependent object types in an integrated development environment
abstract: A method is provided to display indicia of an object type for a service within a user interface of a software development system that runs on a computer, the method comprising: obtaining runtime context information that includes an identification of a respective service and an indication of a user role; providing a plurality of corresponding object types; using context dependent rules to determine which respective object types are within scope of a service; and generating a user interface that includes respective indicia of respective object types determined to be within the scope of the service.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08869052&OS=08869052&RS=08869052
owner: SAP SE
number: 08869052
owner_city: Walldorf
owner_country: DE
publication_date: 20101130
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DESCRIPTION OF EMBODIMENTS","Example OTP interaction with Object Type Definitions","Hardware Environment"],"p":["Integrated development environment (IDE) applications abstract the computer programming complexities and reduce software applications development time so as to enhance the productivity. An IDE allows a developer to concentrate more on the functionality of the application that is being created rather than concentrating on the writing code. An IDE may include a variety of components such as a source code editor, a compiler or interpreter, build automation tools, and a debugger and tools to build an executable, for example. Versioning control may be included to assist computer programmers manage the history of the development objects, e.g. source code. An IDE for object-oriented programming (OOP) often includes a class browser, tools to produce class hierarchy diagrams, and an object inspector, for example. An IDE can assist a developer in developing applications by allowing him to easily drag and drop objects onto a \u2018form\u2019 or onto a \u2018canvas\u2019 of the application that is under development. Thus, a developer may be required to write fewer lines of code, which reduces the time required to create an application. An IDE may combine several editor tools, each tool tailored to process objects of a specific type. State-of-the-art IDEs often provide plug-in options which allow users or commercial developers to integrate external tools and new object types.","However, not all of tools, object types and operations are intended to be used by anybody, anywhere. Depending upon user authorizations, user role, system configuration, client-specific customizing and other context information, access to certain types and operations and tools may be forbidden or restricted. FIGS.  and A-B provide illustrative examples of user interfaces that are not especially well matched to the particular context in which they are used.",{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1","sub":"\u2014"},{"@attributes":{"id":"p-0005","num":"0004"},"figref":["FIGS. 2A-2B","FIG. 2A","FIG. 2B"]},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 3"},"With the increasing complexity of IDEs, there has been a need for improvement in the ability to flexibly generate different user interface displays for use within an IDE that support differences in the availability and prominence of the displays of different object types and operations to different users in different situations.","In one aspect, a method is provided to display indicia of an object type for a service within a user interface of a software development system. In another aspect, a method is provided to display a user interface menu within a user interface of a software development system. In yet another aspect, a method is provided to display indicia of an object type within a hierarchical user interface of a software development system. Runtime context information is used in concert with information structures in computer readable storage device that indicate context information dependent rules to determine a display to be generated. A user interface display is generated consistent with the runtime context and context dependent rules.","These and other features and advantages will be understood from the following detailed description of embodiments in conjunction with the appended drawings.","The following description is presented to enable any person skilled in the art to create and use a computer system configuration and related method and article of manufacture to enable different object types, object type operations and object type display presentations within different contexts. Various modifications to the preferred embodiments will be readily apparent to those skilled in the art, and the generic principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the invention. Moreover, in the following description, numerous details are set forth for the purpose of explanation. However, one of ordinary skill in the art will realize that the invention might be practiced without the use of these specific details. In other instances, well-known structures and processes are shown in block diagram form in order not to obscure the description of the invention with unnecessary detail. Thus, the present invention is not intended to be limited to the embodiments shown, but is to be accorded the widest scope consistent with the principles and features disclosed herein.","Introduction","In accordance with some embodiments, object types are comprehensively specified at design time. An object type specification designates applicable functional scope and operations, as well as requirements to access operations on an object type. An object type specification also may include options and conditions for displaying on the UI.","At runtime, the IDE uses the object type specifications in conjunction with runtime context information (e.g., system, client, user profile, object state) to determine the availability of object types, specific objects and operations. The availability is checked before those entities (types, objects, and operations) are presented on screens or in menus. Based upon the availability of object types, objects and operations, the IDE flexibly and dynamically generates situation-specific screens and menus. Generation of user interface displays once a determination of object types or elements to be represented in the user interface is well known to persons skilled in the art and is not described in detail herein.","Example User Interface Screen Displays",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIGS. 4-7","FIG. 4","FIG. 5","FIG. 4","FIG. 6","FIG. 7"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIGS. 8-10","FIG. 8","FIG. 9","FIG. 10"]},"Process Overview","Object type definitions are provided that set forth runtime context dependent rules for the use of object types in an IDE. Runtime criteria may include user role, system configuration, user authority for a particular operation, for example.  is an illustrative flow diagram representing interaction between a user, an integrated development environment (IDE) and an object type provider (OTP) in accordance with some embodiments. The OTP acts as an interface between the IDE and the object type definitions. But the Object Type Provider is more than a simple API (\u2018Application Programming Interface\u2019); it also evaluates the dynamic availability and significance of the individual object types by accounting for the complex runtime situation. A machine is configured according to program code to act as an IDE that is responsive to user commands. The machine is further configured according to program code to act as an object type provider that is responsive to the IDE. It will be appreciated that although the OTP and IDE are shown as separate components, the OTP may be implemented as integral with the IDE.","A characteristic of an IDE is that it provides an infrastructure, in general a set of services, which eases the development process and supports the user. These services refer to \u2018functional scopes\u2019 such as \u2018Active\/Inactive Handling\u2019, \u2018Version Management\u2019, \u2018Transport Management\u2019, \u2018Where-used list\u2019. Functional scopes are rather coarse-grained entities, whereas the operations (or \u2018functions\u2019) are rather fine-grained entities: For example, the functional scope \u2018Version Management\u2019 includes operations such as \u2018Display version\u2019, \u2018Compare versions\u2019, \u2018Retrieve version\u2019. Object type definitions specify to which of the services or functional scopes an object type may be associated, and which of the operations may be applicable to the object type.","An OTP is programmatically integrated at many locations in the source code of the IDE, these locations representing \u2018functional scopes\u2019. Then, at runtime, the OTP dynamically determines the availability, visibility and UI presentations of the object types, objects and operations. These determinations depend upon context information indicative of the current (dynamic) situation, e.g., user profile, user authorizations, system or client customizing and settings (e.g., switch settings), object state (locked, saved, active\/inactive), hardware or software parameters, backend engine, etc. With the aid of the OTP, the IDE generates menus and screens.","At runtime, the process of  evaluates pre-defined object type definitions in view of runtime context information to determine the availability of object types, operations that can be performed on those object types and the position of visible indicia of those object types in a display screen. In user block , a user requests to start the IDE and opens a general view or display screen, e.g. a browser view. In response to the user request, IDE block  requests from the OTP all available (i.e. visible) object types. In response to the IDE request, OTP block  evaluates runtime context (e.g., object type specifications; user authorities for the activity \u2018DISPLAY\u2019; user role; system configuration; etc.) and returns the available object types. IDE block  generates a user interface screen that displays indicia of the object types available to the user. In user block , the user requests a menu for an object type shown on the screen display. In response to the user request, IDE block  requests from the OTP available operations for the selected object type. In response to the IDE, OTP block  evaluates runtime context (e.g., object type specification; user authorities; user role; object state; etc.) and returns available operations. IDE block  generates the specific menu using the returned operations. In user block , the user selects an operation on the object type. In response to the user request, IDE block  requests from the OTP the appropriate tool for the selected operation and object type. In response to the IDE request, OTP block  loads and returns the proper tool according to the type specification. IDE block  invokes the returned tool to process the selected operation.","Object Type Data Model Structure",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 12A-12B"},"As explained in the following paragraphs, each object type specification may provide context dependent rules that determine what shall be referred to herein as a \u2018functional scope\u2019 to which the object type is connected; may provide context dependent operations that are applicable on the object type; and may provide context dependent information that determines where (positioning e.g. within a hierarchy) and how prominently the object type is to be presented in an output device, e.g. a user interface display. These object type data (scope, operations, positioning) may be coupled (as part of an overall object type specification) to some context-based requirements or conditions that are checked\/evaluated at runtime to determine whether a given object type is within the scope of the request, to determine which operations are to be offered, and to determine positioning of indicia of the object type and the operations offerings within the output.","The example object type data model structure includes an OBJTYPE_REGISTRY table and an OBJTYPE_TEXTS table that provide what shall be referred to herein as formal data that provide general information concerning the object type and its display. In the illustrated embodiment, the OBJTYPE_REGISTRY structure provides a technical name for the object type, which may involve a multi-component key (e.g., transporttype+subtype), an edit date (EDATE) and identification of an icon (i.e. pictogram) to act as visual or graphical indicia of the object in a user interface display screen. In the illustrated embodiment, the OBJTYPE_TEXTS structure provides a display name for the object type. In some embodiments, a language-dependent text table is provided that contains the object type name in different languages and character sets, in different grammatical cases (e.g., singular and plural, nominative case, accusative case), and with different character lengths (to cope with different field lengths on the UI). The IDE uses these name-related data to generate certain screen displays and menu displays that incorporate visual indicia (e.g., an icon representing the object type). In some embodiments, an object type may be declared to be \u2018normal\u2019, \u2018abstract\u2019 and\/or \u2018derived\u2019. Moreover, an object type may be derived from another type (which may be \u2018abstract\u2019 or not). In order to derive an object type, the \u2018parent\u2019 object type must be named. (Derived data can be \u2018redefined\u2019 or \u2018overwritten\u2019.) Furthermore, an object type may belong to a category or class of object types, or may be part of a type hierarchy.","The OBJTYPE_SCOPES table and the OBJTYPES_SCOPES_REQUIREMENTS table provide first data sets that provide \u2018coarse\u2019 (\u2018high-level\u2019) rules for control or filtering of the context-dependent functional scope that is enabled for the object type. The functional scope signifies services or areas or components of the IDE where an object type may be integrated: \u2018Active-\/Inactive Handling\u2019, \u2018Version Management\u2019, \u2018Transport Management\u2019, \u2018Where-used list\u2019, etc. A functional scope also may signify a \u2018hidden\u2019 (or \u2018dark\u2019) function, such as \u2018Automatic Backup\u2019, where objects of the given type are to be involved but are not directly accessible to the user and may have no corresponding visual indicia in a UI display. For example, an object type that is defined to be picked up in the \u2018Automatic Backup\u2019 job of the IDE. For a common developer, this batch job has no visibility on the UI.","Table 1 provides example detailed rules that may be provided within the OBJTYPE_SCOPES table structure and within the OBJTYPES_SCOPES_REQUIREMENTS table structure of . Scope requirements information provided in the OBJTYPES_SCOPES_REQUIREMENTS table corresponds to information provided in the first and second columns of Table 1. The first and second columns of Table 1 respectively indicate functional scopes in which the object type may be available and conditions or requirements for availability within a given functional scope. For example, referring to the first data-containing row of Table 1, the example object type is available within the functional scope, \u2018Active-\/Inactive Handling\u2019, provided that the condition that the current user is in the \u2018Developer\u2019 role is satisfied. In this example, \u2018Active\/Inactive Handling\u2019 is a functional scope. When no requirements are defined for a certain scope (e.g., \u2018Transport Management\u2019), then the object type has unconditioned access to that scope. Processor tool information provided in the OBJTYPE_SCOPES table corresponds to the third column of Table 1, which indicates the processor tool provided within each functional scope. Thus, the example OBJTYPE_SCOPES table structure and the OBJTYPES_SCOPES_REQUIREMENTS structure determine the context-dependent conditions in which a given object type may be available within a given functional scope and also determine the processor tool(s) available for use with the object type within that functional scope.","Note that in the middle column of the Table 1, the \u201cRequired User Role\u201d is one example for a context-dependent requirement.",{"@attributes":{"id":"p-0036","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},"Required",{}]},{"entry":["Functional Scope","User Role","Processor Tool"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Active-\/Inactive Handling","Developer","CL_XTYPE_EDITOR"]},{"entry":["Where-used list \/",{},"CL_XTYPE_INFOSYST"]},{"entry":["Infosystem",{},{}]},{"entry":["Dequeue\/Enqueue","Developer","CL_XTYPE_EDITOR"]},{"entry":["(Locking)",{},{}]},{"entry":["Logging, History","Quality ","CL_XTYPE_EDITOR"]},{"entry":[{},"Manager",{}]},{"entry":["Versioning",{},"CL_XTYPE_LM"]},{"entry":["Upgrade",{},"CL_XTYPE_LM"]},{"entry":["Automatic testing","Quality ","CL_XTYPE_EDITOR"]},{"entry":[{},"Manager",{}]},{"entry":["Customizing","Developer","CL_XTYPE_EDITOR"]},{"entry":["Transport Management",{},"CL_XTYPE_LM"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"A \u2018processor tool\u2019 is the software tool to be called by the runtime environment in order to process the object type in the context of the respective \u2018Functional Scope\u2019.","Typically, a processor tool is decoupled from the IDE framework. Upon a request, the IDE framework searches through some registry to determine the right tool. (For example, in order to display some \u2018Graphical Model\u2019 object, the appropriate processor tool will be a \u2018Graphical Editor\u2019.) In the present embodiments described herein, the object type specifications include information on the processor tools; the set of object type specifications therefore implicitly establishes a tool registry. In an alternative embodiment, the processor tools might be registered separately from the object type specifications.","In an object-oriented programming language, such a processor tool or editor is a class which implements a certain interface. The runtime environment will call the tool class via the interface. For any \u2018Functional Scope\u2019, an individual tool (or a shared tool) may be registered as processor tool.","The OBJTYPE_FUNCTIONS and OBJTYPE_FUNCTIONS_REQUIREMENTS tables provide second data sets that provide rules for \u2018finer\u2019 (\u2018lower-level\u2019) control or filtering of context-dependent operations that are enabled for the object type. The example second data set identifies context-dependent operations associated with the object type and the conditions or requirements under which the operations are available to be accessed used. Table 2 provides example detailed information that may be provided within the OBJTYPE_FUNCTIONS and the OBJTYPE_FUNCTIONS_REQUIREMENTS table structures of . In some embodiments, a first data set such as that of Table 1 is used to determine whether a given object type is within the scope of some service, component or area of the IDE for a given context. Assuming that the object type is within the scope, then a second data set such as that of Table 2 is used to determine which operations associated with the object type are available for the given context.","The first and second columns of Table 2 respectively indicate operations that are available and conditions for availability. For example, referring to the second, data-containing row of Table 2, the example operation, \u2018DISPLAY\u2019, is available provided that the condition \u201cUser has authorization S_DEVELOP\u201d is satisfied. (A user role is associated with a distinct set of authorizations. An authorization may refer to an \u201cauthority object\u201d and an \u201cactivity\u201d. The IDE may check whether the current user (in his current role) has the required authorization.)","A combination of context-dependent conditions (linked with \u2018AND\u2019 or \u2018OR\u2019, or combinations) may be specified for an operation. Requirements may include user authorization level, hardware parameters or the existence\/installation of a certain backend software engine, for example.","For example, consider the operation \u2018EXECUTE\u2019, which means to execute specific objects of the given type. (Example: To \u2018execute\u2019 a compiled program means to run the program.) A context-dependent rule for the EXECUTE operation may involve two requirements specified in an object type specification:","1.) The user account must have some technical authorization in the software system, characterized by some authority object \u2018S_DEVELOP\u2019 and activity \u2018EXECUTE\u2019.","2.) The kernel of the runtime system must be of version x.4.1 or higher.","Both conditions may be defined and linked with \u2018AND\u2019 in the object type definition at design time. At runtime, the system will evaluate them. The result is that operation\/function \u2018EXECUTE\u2019 will be available (e.g. visible and selectable) on the User Interface only if both conditions are fulfilled at runtime.","Note that in some embodiments, requirements may be specified as being \u201cmandatory\u201d, or \u201csufficient\u201d, which is roughly equivalent to combining requirements with \u2018AND\u2019 or \u2018OR\u2019.","The third column of Table 2 indicates whether at runtime indicia of the object type or operation is visible on the user interface when the context condition is not satisfied and the operation is unavailable. For example, indicia of the \u2018DISPLAY\u2019 operation is visible even if the \u2018DISPLAY\u2019 operation is unavailable, but indicia of the \u2018CREATE\u2019, operation is not visible if the \u2018CREATE\u2019 operation is unavailable. Note that information in the third and fourth columns \u2018Display Mode\u2019 and \u2018Processor Tool\u2019 is not required to determine whether condition-dependent operations are available. The \u2018Display Mode\u2019 can be defined as a general setting (which holds for any operation, or even for any object type); the \u2018Processor Tool\u2019 may already be defined with respect to the \u2018Functional Scope\u2019, i.e. on a higher level (so there might be no need to override it here).","In Table 2, the second column \u201cRequired Authorization\u201d is one example for a context-dependent requirement.",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},"Required","Display Mode",{}]},{"entry":["Operation","Authorization","(if unavailable)","Processor Tool"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["DISPLAY","S_DEVELOP","Visible but disabled","CL_XTYPE_EDITOR"]},{"entry":[{},{},"(i.e., not selectable)",{}]},{"entry":["CREATE","S_DEVELOP","Not visible","CL_XTYPE_EDITOR"]},{"entry":["CHANGE","S_DEVELOP","Not visible","CL_XTYPE_EDITOR"]},{"entry":["ACTIVATE","S_DEVELOP","Not visible","CL_XTYPE_EDITOR"]},{"entry":["DELETE","S_DEVELOP","Not visible","CL_XTYPE_EDITOR"]},{"entry":["WHERE_USED","S_DEVELOP","Not visible","CL_TYPE_INFO"]},{"entry":["EXECUTE","S_FCONSUMER","Not visible","CL_XT_PROCESSOR"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"The OBJTYPE_POSITIONS and OBJTYPE_POSITIONS_REQUIREMENTS tables provide third data sets that provide rules for control or filtering of context-dependent UI display presentation (e.g. position) of visible indicia of a given object type. The example third data set identifies context-dependent object type display presentations and the conditions that determine which presentation is generated. Table 3 provides example detailed information that may be provided within the OBJTYPE_POSITIONS and the OBJTYPE_POSITIONS_REQUIREMENTS table structures of . The Table 3 example refers to general views, i.e. views of sets of object types, as shown in \u2018Browsers\u2019. Moreover, positions may be characterized by abstract \u2018Levels\u2019, or by technical identifiers (e.g., \u2018Root node in Explorer Tree\u2019). In the Table 3 example, the importance of a certain object type is relative, since it depends on the role or profile of a user, or on other parameters. Accordingly, the object type is to be presented more or less prominently within a set of object types on the UI depending upon a user's role.","In Table 3, the second column \u201cRequired User Role\u201d is one example for a context-dependent requirement.",{"@attributes":{"id":"p-0053","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},"Display Position","Required User Role"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Top Level","Quality Manager"]},{"entry":[{},"Standard Level","Developer"]},{"entry":[{},". . .",". . ."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"It will be appreciated that some object types may require categories of information in addition to that shown in the data model of the general structure shown in  in order to instantiate the object type. For example, the access of an object type to \u2018functional scope\u2019 Active-\/Inactive Handling may require further, detailed data such as a list of dependent object types (i.e., objects which have to be activated synchronously with objects of the present type); Activation phase at runtime where objects of the present type have to be activated (e.g., \u2018Pre-Activation\u2019 or \u2018Standard Activation\u2019 or \u2018Post-Activation\u2019). As another example, access of an object type to \u2018functional scope\u2019 Transport Management may require further, detailed data such as to indicate whether objects of this type are to be automatically transported to other systems in the \u2018transport landscape\u2019, or manually transported; to indicate whether this is a main transport type, or a subordinate transport type (The latter means: Objects of this type are transported as a part of another object.); and to indicate the \u2018transport layer\u2019 in which objects of this type are transported. As yet another example, access of an object type to \u2018functional scope\u2019 Where-Used list may require further, detailed data such as which objects (object types) may be used by objects of the present type and which objects (object types) may use objects of the present type.","In some embodiments an Object Type Editor tool is provided to support persons who design object types and object type specifications. By providing admission control, edit locks, automatic entry help and entry checks, as well as comprehensive checks, an Object Type Editor tool can assure that object type specifications are consistent, plausible and complete. In general, \u2018functional scope\u2019, operations\/functions and UI positioning for a given object type are interdependent. The Object Type Editor can check for any conflicts. For example, an object type which allows operation Transport should have access to the \u2018functional scope\u2019 \u2018Transport Management\u2019. Object types can be comprehensively specified at design time. Authority checks and other availability checks at runtime can be delegated from the tools to the \u2018Object Type Provider\u2019. In effect, the object types and tools in the IDE can be centrally controlled, and the usability of the IDE is improved. Screens and menus on the User Interface are more homogeneous.","An alternative object oriented programming approach to comprehensively specifying scope, operations and\/or presentation of an object type is to represent object type specifications as classes implementing well defined interfaces. At design time, comprehensive properties of an object type are written in the source code of such a class. In this alternative embodiment there is no need for a specific editor tool for object types.","Referring again to , additional illustrative details of the process of block  are shown in . Additional illustrative details of the process of block  are shown in . Additional illustrative details of the process of block F are shown in .","More particularly,  is an illustrative flow diagram showing details of a first OTP process performed in response to an IDE block  requests for all available (i.e. visible) object types. It will be understood that a machine may be configured with program code to implement acts represented by the illustrative modules of . In response to a request from the IDE, which is responsive to a user request to start a service, for example, module  accesses a corresponding object type definition from an object type definition database , which stores a multiplicity of object type definitions. Referring to , module  uses OBJTYPE_REGISTRY table information to retrieve the object type definition. Module  accesses saved context information  to obtain context data that is required to evaluate the context-dependent scope conditions within the OBJTYPE_SCOPES table and the OBJTYPES_SCOPES_REQUIREMENTS table of the selected object type definition. As explained below, the context information is not persistently stored, but rather is saved only temporarily. Decision module  evaluates the context-dependent conditions specified by the object type definition for the selected object type to determine whether the selected object is within the scope function.","Note that the object type information in definition database  is persistently stored, whereas the context information  relates to the runtime situation (e.g., system state, date, time, user role, etc.) which comprises transient data. If decision module  determines that the selected object type is within the functional scope, then decision module  evaluates context-dependent conditions specified by OBJTYPE_POSITIONS and OBJTYPE_POSITIONS_REQUIREMENTS tables of  in view of context information to determine whether a special display rule is to be applied to the selected object type. If decision module  determines that a special display rule is to be applied to the selected object type, then module  returns the selected object type and the special display rule to the IDE module , which integrates the selected object type into generation of the user interface in accordance with the special display rule. Referring to Table 3, for example, the special rule might specify that the object type is to be displayed as the root node in the tree. If decision module  determines that no special display rule is to be applied, then module  returns the selected object type and a default display rule to the IDE module , which integrates the selected object type into generation of the user interface in accordance with the default display rule. Following a determination by decision module  that the selected object type is not within the functional scope, a return by module  or a return by module , whichever the case, decision module  determines whether the last object type has been evaluated for it's being within the functional scope. If not, then control flows back to module  and the process repeats. If decision module  determines that all object types to be evaluated have been evaluated, then the process ends.","Referring again to , for example, the first OTP process of  can be used to determine whether and where a \u2018Check Configuration\u2019 object type is incorporated within a user interface. For the illustrative user interface of , for example, decision module  would have determined that the \u2018Check Configuration\u2019 object type is within the functional scope; decision module  would have determined that a special display rule applies to the \u2018Check Configuration\u2019; and module  would have returned to the IDE indications that the \u2018Check Configuration\u2019 object type is to be displayed according to the special display rule. In the case of the example user interface of , the special display rule specified that the \u2018Check Configuration\u2019 object type is to be displayed in a top level of a display hierarchy.","Referring to the user interface display screen of , for example, decision module  would have determined that the \u2018Check Configuration\u2019 object type is within the functional scope; decision module  would have determined that no special display rule applies; and module  would have returned to the IDE indications that the \u2018Check Configuration\u2019 object type is to be displayed according to a default display rule. Accordingly, the example user interface of , displays the \u2018Check Configuration\u2019 object type in a lower level of a display hierarchy beneath the package node.","Referring to the user interface display screen of , for example, decision module  would have determined that the \u2018Check Configuration\u2019 object type is within the functional scope; decision module  would have determined that a special display rule applies; and module  would have returned to the IDE indications that the \u2018Check Configuration\u2019 object type is to be displayed according to a special display rule. in this example, the special display rule specifies that the \u2018Check Configuration\u2019 object type is not to be visible at all in the user interface. Accordingly, the example user interface of , omits the \u2018Check Configuration\u2019 object type altogether.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 14","FIG. 14","FIGS. 12A-12B"],"b":["1112","1402","1304","1402","1404","1308","1406","1406","1408"]},"Referring again to , for example, the second OTP process of  can be used to determine whether the \u2018Create\u2019 operation is available for the \u2018Check Configuration\u2019 object type within different contexts. For the illustrative user interface screen display of , for example, decision module  would have determined that the \u2018Create\u2019 operation is available for the \u2018Check Configuration\u2019 object type within the context given for the user interface of , which includes a user in the role of quality manager. Module  would have returned to the IDE indications that the \u2018Create\u2019 operation is to be displayed in a menu of operations for the \u2018Check Configuration\u2019 object type. Referring to the user interface display screen of , for example, module  would have determined that the \u2018Create\u2019 operation is not available for the \u2018Check Configuration\u2019 object type within the context given for the user interface of , which includes a user in the role of developer. Module  also would have determined that the \u2018Create\u2019 operation is to be displayed with indicia that it is unavailable (i.e., displayed as grayed-out or dimmed). Referring to the user interface display screen of , for example, module  would have determined that the \u2018Create\u2019 operation is not available for the \u2018Check Configuration\u2019 object type within the context given for the user interface of , which includes a user in the role of customer developer. Module  also would have determined that the \u2018Create\u2019 operation is not to be displayed. In , the absence of any visible indicia of the (unavailable) \u2018Create\u2019 operation is indicated by the empty space enclosed within the dashed lines.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 15","FIG. 15","FIGS. 12A-12B"],"b":["1120","1502","1304","1502","1502","1504"]},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 16"},"Embodiments may also, for example, be deployed by Software-as-a-Service (SaaS), Application Service Provider (ASP), or utility computing providers, in addition to being sold or licensed via traditional channels. The computer may be a server computer, a personal computer (PC), a tablet PC, a set-top box (STB), a Personal Digital Assistant (PDA), cellular telephone, or any processing device capable of executing a set of instructions (sequential or otherwise) that specify actions to be taken by that device. Further, while only a single computer is illustrated, the term \u201ccomputer\u201d shall also be taken to include any collection of computers that individually or jointly execute a set (or multiple sets) of instructions to perform any one or more of the methodologies discussed herein.","The example computer processing system  includes processor  (e.g., a central processing unit (CPU), a graphics processing unit (GPU) or both), main memory  and static memory , which communicate with each other via bus . The processing system  may further include video display unit  (e.g., a plasma display, a liquid crystal display (LCD) or a cathode ray tube (CRT)). The processing system  also includes alphanumeric input device  (e.g., a keyboard), a user interface (UI) navigation device  (e.g., a mouse, touch screen, or the like), a mass storage disk drive unit , a signal generation device  (e.g., a speaker), and a network interface device .","The disk drive unit  includes computer-readable medium  on which is stored one or more sets of instructions and data structures (e.g., software ) embodying or utilized by any one or more of the methodologies or functions described herein. The software  may also reside, completely or at least partially, within the main memory  and\/or within the processor  during execution thereof by the processing system , the main memory  and the processor  also constituting computer-readable, tangible media.","Object types database  may be stored persistently in mass storage , for example. Context information  can be saved in main memory , for example. Program code corresponding to processes of FIGS.  and - may be encoded in main memory  when the processes run on processor , for example.","The software  may further be transmitted or received over network  via a network interface device  utilizing any one of a number of well-known transfer protocols (e.g., HTTP).","While the computer-readable medium  is shown in an example embodiment to be a single medium, the term \u201ccomputer-readable medium\u201d should be taken to include a single medium or multiple media (e.g., a centralized or distributed database, and\/or associated caches and servers) that store the one or more sets of instructions. The term \u201ccomputer-readable medium\u201d shall also be taken to include any medium that is capable of storing, encoding or carrying a set of instructions for execution by the computer and that cause the computer to perform any one or more of the methodologies of the present application, or that is capable of storing, encoding or carrying data structures utilized by or associated with such a set of instructions. The term \u201ccomputer-readable medium\u201d shall accordingly be taken to include, but not be limited to, solid-state memories, and optical and magnetic media.","While the invention(s) is (are) described with reference to various implementations and exploitations, it will be understood that these embodiments are illustrative and that the scope of the invention(s) is not limited to them. In general, techniques for maintaining consistency between data structures may be implemented with facilities consistent with any hardware system or hardware systems defined herein. Many variations, modifications, additions, and improvements are possible.","Plural instances may be provided for components, operations or structures described herein as a single instance. Finally, boundaries between various components, operations, and data stores are somewhat arbitrary, and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the invention(s). In general, structures and functionality presented as separate components in the exemplary configurations may be implemented as a combined structure or component. Similarly, structures and functionality presented as a single component may be implemented as separate components. These and other variations, modifications, additions, and improvements fall within the scope of the invention(s)."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIGS. 2A-2B","FIG. 2A","FIG. 2B"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIGS. 4-7"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIGS. 8-10"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIGS. 12A-12B"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
