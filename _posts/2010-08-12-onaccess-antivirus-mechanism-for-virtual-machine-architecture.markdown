---
title: On-access anti-virus mechanism for virtual machine architecture
abstract: A tangible medium embodying instructions usable by a computer system to protect a plurality of guest virtual machines (VMs), which execute via virtualization software on a common host platform, from malicious code is described. A scan engine is configured to scan data for malicious code and determine a result of the scanning, wherein the result indicates whether malicious code is present in the data. A driver portion is configured for installation in an operating system of a target VM, which is one of the guest VMs. The driver portion intercepts an access request to a file, that originates within the target VM. The driver portion communicates information identifying a location of the data to be scanned by the scan engine without sending a copy of the data to the scan engine. The scan engine executes within the virtualization layer outside a context of the target VM.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08010667&OS=08010667&RS=08010667
owner: VMware, Inc.
number: 08010667
owner_city: Palo Alto
owner_country: US
publication_date: 20100812
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CLAIM OF PRIORITY","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This Application is a continuation of and claims priority to U.S. patent application Ser. No. 11\/955,265, filed on Dec. 12, 2007, which is incorporated herein by reference in its entirety.","Virtualization","As is well known in the field of computer science, a virtual machine is an abstraction\u2014a \u201cvirtualization\u201d\u2014of an actual physical computer system.  show two possible arrangements of virtualization software in a computer system  that implements virtualization. A virtual machine or \u201cguest\u201d  is installed on a \u201chost platform,\u201d or simply \u201chost,\u201d which will include system hardware  and one or more layers or co-resident components comprising system-level software, such as an operating system or similar kernel, or a virtual machine monitor or hypervisor as described in more detail below, or some combination of these. The system hardware typically includes one or more processors , memory , some form of mass storage , and various other devices .","Each VM , . . . , -will typically have both virtual system hardware  and guest system software . The virtual system hardware typically includes at least one virtual CPU ---, virtual memory , at least one virtual disk , and one or more virtual devices . Note that a disk\u2014virtual or physical\u2014is also a \u201cdevice,\u201d but is often considered separately because of the important role of the disk. All of the virtual hardware components of the VM may be implemented in software using known techniques to emulate the corresponding physical components. The guest system software includes a guest operating system (OS)  and drivers  as needed for the various virtual devices .","A single VM may be configured with more than one virtualized processor. To permit computer systems to scale to larger numbers of concurrent threads, systems with multiple CPUs have been developed. These symmetric multi-processor (SMP) systems are available as extensions of the PC platform. Essentially, an SMP system is a hardware platform that connects multiple processors to a shared main memory and shared I\/O devices. Virtual machines may also be configured as SMP VMs. , for example, illustrate multiple virtual processors -, -, . . . , -(VCPU, VCPU, . . . , VCPUm) within the VM .","Yet another configuration is found in a so-called \u201cmulti-core\u201d architecture, in which more than one physical CPU is fabricated on a single chip, each core having its own set of functional units (such as registers, L2 caches, arithmetic\/logic units (ALUs), etc.) and can execute threads independently. Multi-core processors typically share certain resources, such as L2 and\/or L3 caches. Still another technique that provides for simultaneous execution of multiple threads is referred to as \u201csimultaneous multi-threading,\u201d in which more than one hardware thread operates simultaneously on a single processing core.","Each guest VM executes on system hardware  and physical CPU(s)  in its own \u201ccontext,\u201d which is provided by an underlying virtualization software layer. A \u201ccontext\u201d generally includes the state of all virtual address space, as well as the set of registers (including privilege registers), with all hardware exception and entry points. Thus, although they share system resources, each guest VM is isolated from one another and from the underlying virtualization software. Furthermore, if the virtualization system is properly designed, applications  running on each VM will function as they would if run directly on a physical computer, even though the applications are running at least partially indirectly on virtual system hardware . Executable files will be accessed by guest OS  from the virtual disk  or virtual memory , which are mapped to portions of the actual physical disk  or memory , respectively, which portions are allocated to that VM by the virtualization software layer. The design and operation of virtual machines are well known in the field of computer science.","The virtualization software layer, also referred to herein as \u201cvirtualization layer\u201d or \u201cvirtualization software,\u201d may include one or more software components and\/or layers, possibly including one or more of the software components known in the field of virtual machine technology as \u201cvirtual machine monitors\u201d (VMMs), \u201chypervisors,\u201d \u201chost operating systems,\u201d or virtualization \u201ckernels.\u201d Because terminology related to virtualization has evolved over time and has not yet become fully standardized, these terms do not always provide clear distinctions between the software layers and components to which they refer. For example, the term, \u201chypervisor\u201d is often used to describe both a VMM and a kernel together, either as separate but cooperating components or with one or more VMMs incorporated wholly or partially into the kernel itself. However, \u201chypervisor\u201d is sometimes used instead to mean some variant of a VMM alone, which interfaces with some other software layer(s) or component(s) to support the virtualization. For example, in some systems, some virtualization code is included in at least one \u201csuperior\u201d VM or host operating system to facilitate the virtualization.","Some software components are shown and described as being within a \u201cvirtualization layer\u201d located logically between all virtual machines and the underlying hardware platform and\/or system-level host software. This virtualization layer can be considered part of the overall virtualization software, although it would be possible to implement at least part of this layer in specialized hardware.  show one or more virtual machine monitors that appear as separate entities from other components of the virtualization software and perform certain functions relating to the invention. Those skilled in the art may recognize that such a representation of these components is provided only for the sake of simplicity and clarity and by way of illustration. As mentioned above, the distinctions between and among the various components of a virtualization system are not always so clear-cut, and the use of the term \u201cvirtual machine monitor\u201d or just \u201cVMM\u201d is meant to encompass the component(s) in the virtualization software that perform the indicated functions, regardless of what name they are given.","The various virtualized hardware components of virtual system hardware , such as virtual CPU(s) -, virtual memory , virtual disk , and virtual device(s) , are shown as being part of VM  for the sake of conceptual simplicity. In reality, these \u201ccomponents\u201d are merely projections of virtual devices that are visible to guest operating system , but are actually usually implemented by device emulators  included in the VMM.","Different systems may implement virtualization to different degrees\u2014\u201cvirtualization\u201d generally relates to a spectrum of definitions rather than to a bright line. A particular implementation often reflects a design choice with respect to a trade-off between speed and efficiency on the one hand and isolation and universality on the other hand. For example, \u201cfull virtualization\u201d is sometimes used to denote a system in which no software components of any form are included in the guest other than those that would be found in a non-virtualized computer; thus, the guest OS could be an off-the-shelf, commercially available OS with no components included specifically to support use in a virtualized environment.","In contrast, another concept, which has yet to achieve a universally accepted definition, is that of \u201cpara-virtualization.\u201d As the name implies, a \u201cpara-virtualized\u201d system is configured in some way to provide certain features that facilitate virtualization. For example, the guest operating system in some para-virtualized systems is designed to avoid hard-to-virtualize operations and configurations. For example, the guest operating system may be written so that it avoids certain privileged instructions, certain memory address ranges, etc. As another example, many para-virtualized systems include an interface within the guest that enables explicit calls to other components of the virtualization software.","In addition to the sometimes fuzzy distinction between full and partial (para-) virtualization, two arrangements of intermediate system-level software layer(s) are in general use: a \u201cnon-hosted\u201d configuration, such as that shown in , and a \u201chosted\u201d configuration, such as that shown in . The non-hosted configuration illustrated in , deploys one or more VMMs -on top virtualization kernel . Kernel  is constructed specifically to provide efficient support for VMMs -. In particular, kernel  includes device drivers to manage and control physical system hardware , and to assign and distribute resources to VMMs -. A console operating system  and associated applications  may be provided to provide a user interface to allow a user (e.g., an administrator) control over the operation of kernel  as well as to interact with applications executing on each of the virtual machines.","In the hosted configuration shown in , VMMs -run directly on the hardware platform along with host operating system . In a hosted virtualized computer system, an existing, general-purpose operating system forms \u201chost\u201d operating system  that is used to perform certain input\/output (I\/O) operations, alongside and sometimes at the request of the VMM. In this configuration, host operating system  includes driver  and one or more executable applications  that serve a number of virtualization functions, including provide an interface between VMMs -and physical devices, manage and distribute system resources, and provide user interfaces to virtualization system and the inputs and outputs to each of the virtual machines. Host operating system , installed drivers , VM applications , along with other user applications  form host system software . The Workstation product of VMware, Inc., of Palo Alto, Calif., is an example of a hosted, virtualized computer system, which is also explained in U.S. Pat. No. 6,496,847 (Bugnion, et al., entitled \u201cSystem and Method for Virtualizing Computer Systems\u201d). Thus, the term \u201chost\u201d in this particular context refers to the host operating system that is used to support a virtual machine, whereas, generally speaking, it refers to the physical host platform on which the virtual machine resides.","With respect to terminology, it should be noted that kernel  shown in the non-hosted system in  is not the same as the operating system kernel within the guest operating system . As is well known, every operating system has its own kernel. Note also that kernel  is part of the \u201chost\u201d platform of the VM\/VMM as defined above even though the configuration shown in  is commonly termed \u201cnon-hosted.\u201d Kernel  may be considered to be both part of the host platform and part of the virtualization software. The difference in terminology is one of perspective and definitions that are still evolving in the art of virtualization.","Regardless as to whether the system is configured as a hosted virtualization system or a non-hosted virtualization system, the address space of system memory  is generally partitioned into pages, regions, or other analogous allocation units. Applications address the memory using virtual addresses (VAs), each of which typically comprises a virtual page number (VPN) and an offset into the indicated page. The VAs are then mapped to physical addresses (PAs), each of which similarly comprises a physical page number (PPN) and an offset, and which is actually used to address physical system memory . The same offset is usually used in both a VA and its corresponding PA, so that only the VPN needs to be converted into a corresponding PPN. The concepts of VPNs and PPNs, as well as the way in which the different page numbering schemes are implemented and used, are described in many standard texts, such as \u201cComputer Organization and Design: The Hardware\/Software Interface,\u201d by David A. Patterson and John L. Hennessy, Morgan Kaufmann Publishers, Inc., San Francisco, Calif., 1994, pp. 579-603 (chapter 7.4 \u201cVirtual Memory\u201d). Similar mappings are used in region-based architectures or, indeed, in any architecture where relocatability is possible.","An extra level of addressing indirection is typically implemented in virtualized systems in that a VPN issued by an application running in a VM is remapped twice in order to determine which page of system memory  is intended. The first mapping is provided by guest operating system , which translates the guest VPN (GVPN) into a corresponding guest PPN (GPPN) in the conventional manner. In a manner of speaking, the guest OS therefore \u201cbelieves\u201d that it is directly addressing the actual hardware memory, but in fact it is not. A memory management module, located typically somewhere in the virtualization software (such as in the VMM) performs the second mapping by taking the GPPN issued by the guest OS and mapping it to a hardware (or \u201cmachine\u201d) physical page number PPN that can be used to address physical system memory . This GPPN-to-PPN mapping may instead be done in the main system-level software layer, depending on the implementation. From the perspective of guest operating system , the GVPN and GPPN might be virtual and physical page numbers just as they would be if the guest operating system were the only operating system in the system. From the perspective of the system software, i.e., the virtualization layer, the GPPN is a page number that is then mapped into the physical memory space of the hardware memory as a PPN.","The addressable space of the disk(s), and therefore also of the virtual disk(s), is similarly subdivided into separately identifiable portions such as blocks or sectors, tracks, cylinders, etc. In general, applications do not directly address the disk; rather, disk access and organization are tasks reserved to the operating system, which follows some predefined file system structure. When the guest OS wants to write data to the (virtual) disk, the identifier used for the intended block, etc., is therefore also converted into an identifier into the address space of the physical disk. Conversion may be done within whatever system-level software layer that handles memory, disk and\/or file system management for the VM and other processes.","Viruses","A \u201cvirus\u201d is a malicious program or code that surreptitiously enters a computer environment. Viruses often replicate themselves, or cause themselves to be replicated, thereby consuming excessive amounts of computer resources, and causing degradation or disruption of computer operation. A \u201cworm\u201d can be defined as a virus that automatically attaches itself to outgoing email or other network messages. Some viruses are written so that they do not seriously harm the infected system. For example, a virus may be written that merely causes the message \u201cHappy Birthday Ludwig!\u201d to repeat on a monitor screen. Other viruses erase or corrupt disk files, or require that a hard disk be entirely reformatted. A virus may wreak its havoc immediately upon entering a computer environment, or may lie dormant until circumstances cause their code to be executed by the host computer. Regardless as to the potential damage that can be caused by a particular virus, all viruses are generally considered malicious, should be prevented from infecting a system, and should be removed if discovered. For present purposes, the term \u201cvirus\u201d will refer to any such malicious code.","The threat of viruses is particularly acute in a networked environment, where a computer on the network is accessible to viruses of varying degrees of sophistication and severity created by legions of hackers. These viruses may surreptitiously enter the computer environment through a variety of mechanisms, for example, as attachments to emails or as downloaded files, from a CD or diskette, or through a service program listening to a well known network port, such as that for the RPC service in Windows. To guard against viruses such as these, there is a need for an anti-virus mechanism that is effective and scales easily in a virtual machine environment. There are generally two types of anti-virus software\u2014system scanners that scan a complete disk drive and memory system for malicious code, and \u201con-access\u201d scanners that scan a file when it is requested by the operating system. An on-access scanner is generally considered the more secure system since the malicious code is not able to cause damage prior to the next complete scan. With the ongoing progress of hardware processing power and the advance of SMP architectures, the number of virtual machines capable of being run on a single hardware host is increasing. With the concomitant proliferation of computer networks, the threat of viruses or worms remains a serious threat to the stability, reliability, and performance of applications and operating systems running within virtual machines.","An on-access anti-virus mechanism that is optimized for use in a virtualized computer system is provided. In one embodiment, a method for protecting a plurality of guest virtual machines (VMs) from malicious code includes scanning certain data using a scan engine configured to execute within a virtualization layer outside a context of a target virtual machine (VM), and protecting the target VM using a driver portion installed in the target VM. The scanning of the data includes receiving a scan request from a driver portion of the anti-virus system the scan request identifying the data to be scanned, reading the data and comparing the data with a virus signature database, determining a result of the scanning, the result indicating whether malicious code is present in the data, and reporting the result of the scanning back to the driver portion that requested the scan. The protecting of the target VM includes intercepting an access request to a file, communicating a scan request to the scan engine, receiving the result from the scan engine, and taking remedial action when the result indicates the file contains malicious code. The scan request includes the identification of the data to be scanned by providing information identifying a location of the data to be scanned. The data to be scanned being or corresponding to contents of the file. The remedial action can include one or more of notifying a user, deleting the file, or quarantining the file.","In another embodiment, a tangible medium embodying instructions usable by a computer system to protect a plurality of guest virtual machines (VMs), which execute via virtualization software on a common host platform, from malicious code is provided. A scan engine is configured to scan data for malicious code and determine a result of the scanning, wherein the result indicates whether malicious code is present in the data. A driver portion is configured for installation in an operating system of a target VM, which is one of the guest VMs. The driver portion intercepts an access request to a file, that originates within the target VM. The driver portion communicates information identifying a location of the data to be scanned by the scan engine without sending a copy of the data to the scan engine. The scan engine executes within the virtualization layer outside a context of the target VM.","Existing antivirus solutions do not scale well with increasing numbers of guest virtual machines (VMs) on a single host platform. Consider, for example, , which illustrates a conventional on-access type anti-virus mechanism adapted for use in a physical computer system . As shown, that mechanism has two components, a kernel driver  and a scan engine , which together are configured to check for viruses in a four-step sequence. In step , the kernel driver  intercepts a file access request, e.g., open, close, write or read access, from a source , which may be an application or a system-level program. In step , kernel driver  invokes the scan engine . The scan engine , which includes a virus signature database , performs a scan to determinate if there is a virus infection of that file. More specifically, the scan engine  scans the file to determine whether one or more of the virus signatures in the virus signature database  are encountered. In step , the scan engine  reports the results of the scan, i.e., positive (file infected) or negative (file not infected), back to the kernel driver . In step , if the results of the scan are positive, the kernel driver  denies the file access request, and may also quarantine the infected files or delete the virus from the file. If the results of the scan are negative, the kernel driver  allows the request to proceed.","To adapt this scheme to a virtual machine environment, it has been proposed that the mechanism illustrated in  be replicated within each of the virtual machines resident on the physical host. This situation is shown in , which illustrates a virtual machine system , comprising a plurality of virtual machines -, resident on a physical computer . As shown, the mechanism of , identified in  with numerals -, has been replicated within each of the virtual machines -resident on the physical computer .","Unfortunately, this approach is cumbersome and inefficient for at least four reasons. First, it is expensive and complicated to manage because, as new viruses are identified, updates must be made to each of the virus signature databases running inside each of the virtual machines. Second, because scan engines are running in parallel inside each of the virtual machines, and duplicate copies of the same virus signature database must be stored in memory, the memory \u201cfootprint\u201d presented by each virtual memory, and the memory overhead consumed by each virtual machine, increases. As a result, memory requirements multiply with the number of VMs and bottlenecks due to contention for physical memory at the host are increased. Third, the scheme presents a risk that the anti-virus software executing inside a guest virtual machine may be disabled by a virus or infected file that also resides within the same guest virtual machine. Fourth, the system does not scale well with an increase in virtual machines, as each addition of a virtual machine requires adding a entirely new anti-virus mechanism to the system.","A client server scheme, illustrated in , has also been proposed for use in a virtual computer system  for the purpose of combating viruses. This configuration is described in \u201cPerformance Implications of Anti-Virus Execution on a Virtual Platform,\u201d slide presentation, Derek Uluski et al., Jan. 11, 2006, Cambridge, Mass. In this scheme, a virtual computer system  has a server VM  and a plurality of guest VMs , , etc. Server VM  and guest VMs  are in communication with each other over a virtual network , which is implemented entirely in software by the virtualization layer of virtualized system . An anti-virus mechanism is resident on server VM , where it may be invoked by \u201cclient\u201d guest VMs , , etc., in response to anti-virus (A\/V) server calls. These A\/V server calls in turn are spawned whenever a file access request is attempted by a client machine or whenever data is attempted to be sent between a client machine and the host. In response to an A\/V server call, the server requests the file, and the client machine communicates the content of the file to the server. The server scans the file, and compares it against a virus signature database. If the server detects a virus, it interrupts the client virtual machine, which in turn alerts the end user.","While the client-server scheme requires that updates be made to only a single virus signature database, it suffers from additional problems. For instance, while the A\/V server calls are being processed, the file accesses in the client machines are allowed to proceed. As a result, if the file is infected, an access to the file may spread the virus throughout the virtual machine, putting the entire VM at risk. The problem is compounded because of the delay between the time an A\/V server call is made, and the time the server detects a virus and notifies the client machine. This delay can be significant, particularly with large files, which take longer to send to server VM  and then scan. The larger the delay, the greater the risk that the virus will spread and proliferate throughout the client machine.","One embodiment of a virtualized computer system  addressing the deficiencies of the prior art noted above is illustrated in . In this embodiment, a plurality of guest virtual machines (VMs) -reside on a physical host platform . Although three guest VMs -are shown, it should be understood that any number of guest VMs can be provided. The physical host platform  also includes a virtualization layer . Virtualization layer  comprises a layer of executable code in the virtualized computer system  for managing guest VMs -and for providing an interface between guest VMs -and one or more physical resources of the host platform  as described above with reference to . In a hosted virtualization system such as that described above with reference to , the virtualization layer  includes at least a virtual machine monitor (VMM) for each guest virtual machine and the host operating system, drivers, and applications, as described in the Background section above. In a non-hosted virtualization system such as that described above with reference to , the virtualization layer includes at least a VMM for each guest VM and a virtualization kernel. As previously described, it is also possible for the console operating system  () to include virtualization components such as user interface elements. Furthermore, some components of virtualization layer  may reside in hardware.","An anti-virus system is provided to protect each VM -from malicious software such as viruses. The anti-virus system includes a driver portion -for each guest VM, a scanning portion , and a communication portion . Each driver portion -resides in a corresponding one of each guest VM -. Scanning portion  resides in virtualization layer , outside contexts of the guest VMs. Communication portion  provides two-way communication between driver portions -and scanning portion . This communication can take a variety of forms, including, for example, pairwise communication, i.e., communication that occurs between the scanning portion  and one of the driver portions -at a time, or broadcast or multicast communication, i.e., communication that occurs between the scanning portion  and one or more of the driver portions -at a time. Existing communication mechanisms known in the field of virtualization software can be utilized.","In one embodiment, driver portions -may be part of or include software agent processes executing within each of the guest VMs -. The software agent may be configured to perform a variety of tasks on behalf of the corresponding guest VM. For example, the software agent may be responsible for managing communications between the corresponding guest VM and the virtualization layer . Driver portion -may be a kernel driver or module of the guest operating system running in each of the guest VMs -. In an exemplary embodiment, driver portion -may be configured to intercept file access requests that originate from a source -within the corresponding one of guest VMs -. As described above with reference to , the virtual disk for each guest VM may be mapped to a physical location on a physical disk of or accessible by the host platform. The physical disk may, of course, be any non-volatile mass data storage device. The file access requests may include open, close, write, or read requests. When such a file access request is intercepted, driver portion -causes information regarding the requested file to be communicated to the scanning portion  over the communication portion . Information regarding the requested file includes information sufficient to enable the scanning portion to scan the file to determine whether the infected file contains malicious software, and may include the contents or location of the requested file. The location of the requested file can include either an identifier or address of the file, wherein the address specifically identifies virtual disk blocks or portions of guest memory containing the file content. In one embodiment, driver portion -communicates the information regarding the requested file directly. In another embodiment, driver portion -causes the information to be communicated by triggering an agent or other program resident in the corresponding VM to perform the communication. Source -may be an application program executing in the corresponding guest VM -at the user level, but may also be a program or utility executing at the VM's system level, i.e., within or by the guest operating system.","In one embodiment, driver portion -may be configured to suspend the file access request until scanning portion  reports back the results of the scan. In this embodiment, any virus infecting the file is not allowed to proliferate in the virtual machine while scanning portion  is scanning the file contents. If scanning portion  reports back that the file is infected, driver portion -may block the file access request and take some other remedial action, such as alerting the end user of the presence of a virus in the requested file and\/or quarantining or deleting the requested file. If scanning portion  reports back that the file is clean, i.e., devoid of malicious software, then the driver portion -allows the file access request to proceed. In one embodiment, the intercepting and suspending of file access requests and the scanning of requested files are performed transparently to the end user, who may be informed of the result of the scanning only when an infected file is detected.","The scanning portion  comprises a scan engine  and a virus signature database . Scan engine  is a body of executable code, stored, for example, on a tangible computer readable medium and\/or executing on a processor, which is configured to scan the content of a selected file, typically as binary data stored on a memory, for example, hard disk or RAM memory, and compare it with virus \u201csignatures\u201d in the virus signature database . A virus \u201csignature\u201d is a unique string of bits, or the binary pattern, of all or a portion of a virus. It is analogous to a fingerprint in that it can be used to detect and identify specific viruses. Virus signature database  is a collection of such signatures. In the embodiment illustrated in , scanning portion  resides within virtualization layer . For a non-hosted system such as that depicted in , scan engine  may written for execution within or attached to VM kernel  (). For example, scan engine  may be provided as component that runs directly on virtualization kernel . It is also possible for scan engine  to be implemented and installed as a driver component of kernel , or execute within console operating system . In the case of a hosted virtualization system, where the virtualization layer  includes all or part of the host operating system, scan engine  may reside within the host operating system.","Scan engine  receives the contents or the location of the requested file from driver portions -and compares the contents of the requested file with the virus signatures in virus signature database  to determine whether the file contains malicious code in a manner well known in the art of anti-virus software. Virus signature database  may reside on a system disk or otherwise be accessible to scan engine . After completing the comparison, scanning portion  reports its results, i.e., whether the file contains malicious code or not, back to the driver portion -that intercepted the file request.","The communications portion  is a means for allowing or enabling two-way communication between each of the driver portions -, and the scanning portion . As mentioned above, the contents of the communication may include file content or file location, and the communication may be provided directly from driver portion -, or via an intermediary such as a software agent to the scanning portion . Communication portion  also allows communication of scanning results, i.e., whether or not a file contains malicious code, from scanning portion  to the driver portion -. Furthermore, a particular communication may be pairwise communication, i.e., communication between only one of the driver portions -and the scanning portion , or it may be multicast or broadcast communication, i.e., parallel or concurrent communication between a plurality of driver portions -and the scanning portion . In one embodiment, the communication portion  includes a communication link or utility allowing communication between a software agent executing in each of the virtual machines -, which software agent includes the driver portion , , , and the virtualization layer  or the host operating system included in the virtualization layer .","In one embodiment, the software agent may be provided in a package of tools running in each virtual machine known as VMware Tools that is provided with VMware's \u201cESX Server\u201d and \u201cWorkstation\u201d products, and the communication link between this agent and the virtualization layer  is a reliable communication channel known as a \u201chypervisor call\u201d or just \u201chypercall.\u201d A hypercall is a special function that allows select software modules, such as drivers -, to communicate with the virtualization layer  through a bridge component (not shown) which may itelf be implemented in virtualization layer . For example, driver may place information into one or more registers or into a specified memory location and then execute an instruction that causes a hardware fault, such as an IN or OUT instruction in the current x86 platform, or an instruction such as VMCALL from the new \u201cIntel VT\u201d or \u201cAMD-V\u201d virtualization extensions from Intel Corporation and AMD, respectively. Virtualization layer  then responds to the hardware fault, obtains the information passed by driver and reacts accordingly. For example, the virtualization layer  may switch the hardware context to allow scanning portion  to execute, and the virtualization layer  may pass information received from driver to scanning portion , using the bridge.","The anti-virus system described above with reference to  simplifies virus signature updates that occur. For example, when a new virus is identified, rather than having to update multiple instances of this database, as required in the approach described above with reference to , only a single virus database need be updated. In addition, the present embodiment described with reference to  reduces overhead and contention for memory because only one scan engine and signature database are needed per host whereas, in , each VM requires a scan engine and signature database. Because the scanning portion  is not visible to applications programs running in the guest VMs at the user level, the scanning portion is protected from these applications as well as the guest kernel running in the VM. Therefore, malicious code running in the guest VM is unable to disrupt or disable the scan engine or the signature database. The system described here with reference to  can support multiple scanners operating in parallel, which may be provided by different vendors that specialize in removing different forms of viruses. This feature increases the chances of detecting viruses sooner than in the past. Because file accesses in the guest VMs -are suspended while the scanning occurs, the anti-virus system described with reference to  is less vulnerable to virus proliferation than the previous system described above with reference to .","Referring to , a second embodiment of a virtualized computer system  is illustrated. In this figure, elements in common with the embodiment of  are referenced with like identifying numerals, and, for purposes of clarity, are not separately described here. Rather, the reader is referred to the description of the embodiment of  for a description of these elements. Here, the focus of the discussion will be on the differences between this embodiment and that illustrated in .","In this embodiment, an anti-virus system, comprising driver portion -resides in each of the guest VMs -, whereas scanning portion  resides within a scanning VM , which may be a dedicated virtual machine. By \u201cdedicated,\u201d it is meant that the only substantial function of scanning VM  is to provide anti-virus scanning. In this or other embodiments, scanning VM  may be streamlined, i.e., have limited functionality, when compared with the other guest VMs -. Similar to the communications portion  in , here communications portion  provides or enables communication between each driver portion -, and the scanning portion . Unlike communications portion  in , the communications portion  extends through, but does not terminate at, the virtualization layer  or the host operating system. Otherwise, the communications portion  performs the same function as communications portion . In one embodiment, communication portion  provides an intermediary component (not shown) that receives and retransmits messages from driver portions -and scanning portion .","Although the embodiment presented in  requires additional processing overhead caused by performing anti-virus scanning within a VM and by providing communication between the target and scanning VMs instead of just a single VM as in the previous embodiment described above with reference to , the embodiment shown in  provides enhanced protection against vulnerabilities in third-party virus scanners and malicious software. This is because scanning portion  is isolated in scanning VM  and therefore allows remaining VMs to continue to operate in the event that scanning VM  fails, e.g., as a result of a malicious exploit, and is forced to restart. On the other hand, if the scanning portion  is provided within virtualization layer  as shown in , then there is a small risk that the entire system can crash as a result of a malicious exploit against the anti-virus system.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 7","b":["700","502","502","502","502","502"],"i":["a","c ","a","b","c ","a","c. "]},"In operation , the file access request is intercepted by one of driver portions -. In operation , the file access request is suspended pending the scanning of the file for viruses. In one embodiment, this step is performed by the one of driver portions -that corresponds to the guest VM in which the file access request is intercepted.","In operation , the location or contents of the requested file is communicated to scan engine . In the embodiment of , this communication is provided or enabled by the communication portion . In the embodiment of , it is provided or enabled by the communication portion . A variety of specific approaches for performing operation  are possible. Three such examples will be described now, although it should be understood that many more examples are possible, and these three examples are not intended to be limiting in any way.","In a first approach, referred to hereinafter as \u201cthe disk block approach,\u201d the driver portion, or software agent including the driver portion, of the \u201ctarget\u201d VM, i.e., the virtual machine where the request originated, queries the guest operating system for the virtual disk blocks containing the file content. As discussed earlier, each virtual machine has a virtual disk that is mapped to a physical disk on the host. For example, the disk blocks, which are physical from the stand point of the virtual machine are mapped by the virtualization layer to disk blocks of a file maintained by the virtualization layer on the host's disk. In one embodiment, the addresses of the disk blocks are retrieved using an application programming interface (API) provided by the guest operating system, for example, the de-fragmentation API in Windows.","In the case of the embodiment of , the software agent in the target VM communicates the location of those disk blocks (e.g., the disk block address or identifier) on behalf of driver portion -over the communications portion  to the scanning portion , or the virtualization layer . In turn, the scanning portion  or virtualization layer  on behalf of scanning portion , has those disk blocks mapped as a file object, which may be disk blocks or a portion of memory that is accessible to the scanning portion . The file object is then passed or identified to the scan engine  for scanning. In one embodiment, the virtualization layer translates the virtual disk block numbers into offsets in a file that represents the guest VM's virtual disk drive. The file may include an image of the VM's virtual disk maintained by the virtualization layer. The scanning portion would then invoke an API provided by a component of the virtualization layer (e.g., the host operating system or VM kernel) to access the block contents.","In the case of the embodiment of , the virtualization layer receives the disk block numbers from the target VM and identifies the file offsets as described above. The virtualization layer then passes these file offsets to the scanning VM. Within the scanning VM, a special device is provided to access the disk image file of the target VM. To scan a block within the disk image, the scanning VM simply accesses the file block at the given offset.","While this approach is relatively efficient, it will not work when the disk blocks are encrypted or compressed using an algorithm that is proprietary to the guest operating system, or when the disk blocks identifiers are not an up-to-date or consistent representation of the file because, for example, the file system has cached the file content to RAM memory and has lazily flushed a portion of this content to disk. An example of a file system where this possibility is present is NTFS from Microsoft.","In a second approach, referred to hereinafter as the \u201cnetwork file approach,\u201d it is assumed that the requested file resides within a network file system, i.e., a file system that is shared at least between the target guest virtual machine and the host platform. Those skilled in the art of virtualization will note that it is common for a virtual network be implemented that places each of the guest VMs in communication with one another over virtual network interfaces.","A network path name is a path name that specifically identifies the file across a network. One example of a network path name is one that follows the Uniform (or Universal) Naming Convention, known as UNC. Such a network path name has meaning to the scan engine , which resides outside of the target VM. The computer and volume names can be used to specify a globally unique name that specifically identifies a file across the network. In the second approach, the driver portion or the software agent, operating on behalf of the driver, obtains the network path name that corresponds to the file being accessed.","For example, the driver portion or agent may generate the network path directly using known information such as the syntax of the network path convention being followed, and known information such as the computer and volume names. Alternatively, the driver portion or agent may communicate the local (i.e., known) path name for the requested file to the guest operating system, which translates that into a network path name. Thus, the network path may be followed by the scan engine  in order to access the file content. For example, a path name of \u201cC:\\Windows\\notepad.exe\u201d that has meaning to a target virtual machine VM might be translated to \u201c\\\\VM\\C\\Windows\\notepad.exe,\u201d a path name that has meaning to the scan engine . The scan engine  then accesses the file content using this network path name, and scans the file. This approach may be used in those cases where the first disk block approach will not work, for example, because the disk blocks are encrypted or compressed using an algorithm that is proprietary to the target VM, the disk blocks do not accurately represent the file content, or the scan engine  resides in a dedicated scanner VM, and the disk blocks from the target VM are not accessible to the scanner VM.","In a third approach, referred to hereinafter as a \u201cmemory-based approach,\u201d the software agent in the target VM writes a representation of the file into a portion of the guest physical memory of the target VM, has the guest operating system lock this portion of the guest physical memory, and communicates to the virtualization layer  an address of the portion of guest physical memory where the content is stored. The writing can include reading the contents from the virtual disk, decrypting the contents, and then writing the decrypted contents. Note that in this case, the contents written to memory may therefore not be simply a copy of the file as it exists on the disk, but rather a representation of the file contents that correspond to the actual file contents. As discussed in the background section, guest physical memory may be mapped to different physical memory locations in the host or paged out to a swap file or device by the virtualization layer . The virtualization layer  or host operating system in turn converts this portion of guest physical memory into a corresponding portion of host physical memory, and then communicates an address of the portion of host physical memory where the file content is stored to the scan engine . The scan engine  then performs the scan on the file content as stored in the host physical memory. In a hosted virtualization system, scan engine  may run at the user level of the host operating system. In this case, the host operating system, can remap the host's physical memory (which is shared with the virtualization layer) to virtual memory of the host, in which case the scan engine  can access the file contents using the mapped virtual memory of the host operating system.","In the case where the scan engine  is resident on a dedicated scanner VM as shown in , a variant of this approach may be followed. More specifically, the driver portion or agent in the target VM informs the corresponding VMM which guest physical memory pages contain the content. The VMM or other component of the virtualization layer converts the guest physical pages numbers (GPPN) to physical page numbers (PPN) of the host platform. In the scanner VM, a special guest physical memory location that is mapped before the scan to the same host physical pages backing the guest physical memory pages of the target VM. After the scan, this memory is unmapped. In one implementation, the pseudo-code for this procedure is as follows: the target VM tells the VMM (or other component in the virtualization layer) which guest physical memory pages contain the content. In the scanner VM, there is special guest physical memory, which is mapped, before the scan, to the same machine pages backing the guest physical memory pages of the target VM. After the scan, this memory is unmapped. In one implementation, the pseudo-code for this procedure is represented in Table 1:",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Target VM","Virtualization Layer","Scanner VM"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["In the target VM,",{},{}]},{"entry":"get a list of"},{"entry":"GPPNs that"},{"entry":"contain the"},{"entry":"file content"},{"entry":"(for example"},{"entry":"through"},{"entry":"kernel API);"},{"entry":"Send the list of"},{"entry":"GPPNs"},{"entry":"to the VMM;"},{"entry":[{},"VMM receives the list of GPPNs and"]},{"entry":[{},"converts them to a list of PPNs. If a"]},{"entry":[{},"GPPN is currently swapped out,"]},{"entry":[{},"allocate new PPN and fetch the page"]},{"entry":[{},"from the swap file into memory;"]},{"entry":[{},"VMM remaps the PPNs to the special"]},{"entry":[{},"GPPNs in the scanner VM;"]},{"entry":[{},{},"Scanner VM"]},{"entry":[{},{},"scans the"]},{"entry":[{},{},"remapped"]},{"entry":[{},{},"memory"]},{"entry":[{},{},"blocks,"]},{"entry":[{},{},"returns result;"]},{"entry":[{},"When the scan is finished, the VMM"]},{"entry":[{},"removes the mapping to the special"]},{"entry":[{},"GPPNs"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Turning back to , in operation , scan engine  scans the file contents. In one embodiment, operation  is performed by comparing a binary data representation of the file content with binary data representations of the virus signatures from the virus signature database . Of course, other approaches are possible. For example, decompressed, decoded or processed content from the file may be compared with the virus signature.","In operation , the scan engine determines whether any malicious code has been detected in the file content through the scanning performed in operation . If so, the procedure flows to operation . Otherwise, the procedure flows to operation .","In operation , scanning portion  reports back or has reported back to driver portion of the target VM that the file is infected. Then, in operation , the driver portion, in response to receiving the \u201cfile infected\u201d message from scanning portion , denies or blocks the file access that was suspended in operation . In operation , the driver portion provides an alert to the end user that the requested file is infected. At that point, the procedure completes.","In one embodiment, after the scan engine detects a virus as a result of a scan, it informs a component of the VMM of the target VM of the result, which in turn informs the driver portion. In addition, the VMM may launch a user defined action at the VM level in addition to sending the result to the driver portion. Such VM level action may include but is not limited to creating a consistent snapshot of the VM, starting to record the operation of the VM, disconnecting the VM from the network, suspending the VM, and any combination of the foregoing. The benefit of VM level action is that such action is not dependent on software running inside the guest VM, and thus can be more reliably enforced.","In operation , branched to in the case when a virus has not been detected through the scanning in operation , the scanning portion reports back, or has reported back, to the driver portion of the target VM that the file is clean. In response, to receiving this \u201cfile clean\u201d message, driver portion -of the target VM, in operation , allows the file access request that was suspended in operation  to resume. The method then completes.","Some optional refinements or optimizations of operation  are possible. In one refinement, applicable when using the disk block approach described above, a scan history of the disk blocks may be kept so that the disk files need be scanned only once, i.e., when an access to the file is first attempted. The disk files thereafter need not be rescanned in response to subsequent attempts to access the same file.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIG. 8A","FIGS. 5 and 6"],"b":["800","802","804","804","804","806","802","804","806","804","806","802","804","806"],"i":["a","b","n","a","n","a","a","b","b","c","c. "],"sub":["1","2","n","1 ","2 ","n "]},"In this subsystem, a scan history is maintained for each of the disk blocks indicating whether or not the block was previously scanned with a negative (i.e., clean) result, and unchanged. Optionally, a time-stamp of the scan can also be maintained in the scan history as well. When the results of the scan indicate that malicious code is present, the corresponding disk blocks may be deleted or quarantined. When malicious code is present, the results of the scan, and the action taken in response to the scan, need not be stored. However, it should be appreciated that embodiments are possible where this information is also stored as part of the scan history.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 8B","FIG. 6"],"b":["808","810","810"],"i":["a ","b"]},"In the subsystem of , when an attempted access is made to a file, and the file is earmarked for scanning by the scanning portion , the scan history of the guest virtual disk blocks that contain the file content is consulted. If those scan results indicate the file content has been previously scanned, and unchanged since the last scan, the file content is not scanned again. Instead, the guest virtual machine is notified of the previous scan results, i.e., that no malicious code is present. If the scan history indicates that the file content has changed since the last scan, then the file is scanned. If the scan results for this portion are negative, i.e., no malicious code found, then, again, the guest virtual machine is notified of these scan results. After a clean scan, these blocks are flagged to indicate they have been scanned. If a block is later modified, the flag is cleared.","As an example of this, when a file in a first virtual machine VM is first accessed, because this is the first time the file has been accessed, it is scanned and all blocks corresponding to the file are scanned. In a second virtual machine VM the same file may be accessed. Since all blocks of the file are flagged as \u201cclean,\u201d another scan may be avoided.","In another embodiment, applicable in the case where the network file or memory-based approaches for file transfer are followed, scan engine  maintains a scan history of the file content scanned for the guest VMs. The scan history comprises meta-data for each page (or whichever unit of memory is applicable) of scanned content, where the meta-data includes a signature of the page content.","Here, a \u201csignature\u201d for a file is the result of one or more operations performed on information (usually, but not necessarily limited to, the contents) of the file intended to uniquely identify the file. In general, the signature should be able to represent the file using fewer bytes (or bits, etc.) than are needed for the contents of the file itself, since otherwise it would be easier simply to use the file's contents directly as its own \u201cidentifier.\u201d Thus, for a 4 k-byte file, the signature should preferably consist of fewer than k bytes. In other words, the signature represents a reduced-dimensionality mapping.","Many different types (or combinations) of signatures may be used to identify memory pages within an acceptable degree of ambiguity. The chosen signature is a design choice within the skill of programmers who understand memory management techniques. A by no means exhaustive list of examples of possible signatures includes any type of checksum and any of the many types of hashing algorithms. Meta data can also be used to generate a signature. For example, a value, e.g., a hash value, computed from file block addresses can be generated. In this case, so long as the addresses of file blocks on the disk remain unchanged, then the system will assume that the file is unchanged, without having to read the entire file content to generate the signature.","In one embodiment, scan engine  maintains a hash table or a list of hash values. Each entry in the list or table corresponds to content of a file or a page of a file content that is identified as being free of malicious code. With the second approach, the scan engine is provided with a network path to the file to be scanned. In this case, the scan engine can maintain a signature corresponding to each file that it has scanned. When it is asked to scan the file again, it can first generate a new signature value and compare the new signature with the stored copy. If the new signature matches the stored signature, then the scan engine can assume the file has not been modified since the most recent successful scan, and can immediately report back that the file is free of malicious code.","However, if the third approach is used, the scan engine is provided with a location of a copy of the file in memory, and may not be aware of the location of the file. In this case, the scan engine maintains a list of \u201cvalid\u201d signatures, each corresponding to a clean (i.e., having no malicious code) file. When the scan engine receives a request for a new scan, it first accesses the file in the indicated memory location and generates a new signature. The scan engine then compares the new signature with previously generated signatures in the list of signatures. If a match is found, then the scan engine assumes that the file contents are identical to the file contents of a previously scanned file that was found to be free of malicious code, and the scan engine immediately reports back that the present file is clean. This approach is more risky, however, using sufficiently long signatures, e.g., 20-byte or 160-bit signatures, can reduce the risk to an acceptable level. Furthermore, the memory allocated to the list of signatures may be limited to ensure the list does not grow ad infinitum. Finally, in many cases the list may be flushed or deleted when certain events happen, e.g., the virus database, which contains virus signatures to identify infected files, is updated.","In each case, if the computed hash value does not match the entry in the table or list of signatures then the file is rescanned, and if the scan returns a negative result indicating the file is free of malicious code, then the hash values previously computed are entered into the table or list of signatures. Of course, if the scan returns a positive result indicating that the file contains malicious code, then the driver portion is notified and corrective action is taken, e.g., deleting or quarantining the file.","This alternative implementation introduces some risk of false negatives, i.e., declaring a page as free from viruses when in fact it is infected. A false negative can occur when data signatures such as hash values are used since two different contents can be mapped to the same data signature, e.g., a clean file, and an infected file. In the case of two different pages having the same hash, one infected, the other clean, a false negative can arise if, for example, scan engine  scans the clean page, and, as a result of this, enters the hash value of the clean page to the hash table. Later, assuming an incoming file is received containing the infected page, because the pages have the same hash, the scan engine  will detect that a hash of the infected page matches the entry in the hash table, and thus assume that the page is clean when it is not. Because of this risk of false negatives, it may not always be possible to apply this alternative implementation. On the other hand, the use of large hash values, e.g., having 20 bits or more, can reduce this risk to practically zero, and this approach can greatly reduce the burden of repeated scanning.","Furthermore, in the virtual machine environment described, where the scan engine and hash database are centralized, the use of file signatures yields efficiencies that are not achievable in a traditional computer environment. For example, if a file is shared by a plurality of guest VMs executing on the same host, a likely scenario if the guest VMs are running the same guest operating system, then this file needs to be scanned only once for each of the virtual machines. This is especially fruitful when the virtualization system maps two virtual disks for separate VMs running the same operating system to a common physical disk so that identical system files are mapped to the same physical disk blocks to save disk space. After one VM accesses a system file and causes that file to be scanned for malicious code, subsequent accesses by other VMs will not require repeated scanning. An approach where file content hashing is performed independently by each of the virtual machines would require scanning this file multiple times, once by each of the virtual machines.","Although the foregoing invention has been described in some detail for purposes of clarity of understanding, it will be apparent that certain changes and modifications may be practiced within the scope of the appended claims. Accordingly, the present embodiments are to be considered as illustrative and not restrictive, and the invention is not to be limited to the details given herein, but may be modified within the scope and equivalents of the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 1A and 1B"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 8B","FIG. 8A"]}]},"DETDESC":[{},{}]}
