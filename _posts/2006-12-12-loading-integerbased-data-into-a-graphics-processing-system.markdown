---
title: Loading integer-based data into a graphics processing system
abstract: One embodiment of the present invention sets forth a technique for improving the flexibility and programmability of a graphics pipeline by enabling full access to integer texture maps within a graphics processing unit (GPU). A new mechanism for loading and unloading integer texture images is disclosed that enables the shader units within the GPU to have full access to integer values stored within an integer image buffer in a GPU local memory. New integer formats are added to the graphics API that indicate that data should be loaded and processed without the prior art conversion to a floating-point representation, thereby enabling the use of these new integer data types.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07986325&OS=07986325&RS=07986325
owner: NVIDIA Corporation
number: 07986325
owner_city: Santa Clara
owner_country: US
publication_date: 20061212
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","Embodiments of the present invention generally relate to graphics programming and more specifically to loading integer-based data into a graphics processing system.","2. Description of the Related Art","Over the past decade, the cost of adding on-chip logic to processors has substantially decreased. Consequently, certain types of processors, such as advanced graphics processing units (GPUs), now include functionality not previously available in earlier GPU designs. For example, newly introduced GPUs are now able to perform full integer processing operations; whereas, such operations could not be effectively performed on the GPU. One benefit of this new capability is that more efficient graphics processing may now be performed on the GPU, thereby increasing overall performance in the graphics pipeline.","To fully realize additional processing capabilities of advanced GPUs, as much GPU functionality as possible needs to be exposed to graphics application developers. Among other things, doing so enables graphics application developers to tailor their shader programs to optimize the way GPUs process graphics scenes and images. Exposing new full integer GPU processing capabilities to graphics application developers requires that the application programming interface (API) be configured with new calls and libraries that make new features and functionalities directly accessible by developers.","GPU APIs typically expose an interface to graphics application developers that enables an application executing on the host CPU to load image data, in the form of one or more texture maps, into GPU local memory for greater access and processing efficiency by the GPU. Texture map data is commonly represented as one or more intensity values per texture element, called a \u201ctexel.\u201d For example, a texel may include a single intensity value per texel. Alternately, a texel may include four values, corresponding to red, green and blue intensity, and opacity. Each value within a texel is commonly represented using either a floating-point value, such as a standard 32-bit floating-point number, or a fixed-point normalized value. For example, an 8-bit normalized value includes 256 codes, ranging from 0x00 to 0xFF, where 0x00 corresponds to a floating-point value of \u201c0.0\u201d and 0xFF corresponds to a floating-point value of \u201c1.0.\u201d The incremental codes between 0x00 and 0xFF correspond to 254 increasing floating-point values between zero and one.","In prior art GPUs, the data stored in a texture map is used for a very limited scope of computation, typically performed by fixed-function shaders that are limited to using floating-point math. Thus, data retrieved from a texture map by a shader is first converted to a floating-point representation before being presented to the shader. Data written to the texture map by the shader is presumed to originate as floating-point data from the shader and may be converted from the presumed floating-point format to a specific storage format, such as normalized 8-bit values, before being stored. With the introduction of GPUs that able to perform full integer processing, the prior art data path connecting a shader unit to the GPU local memory becomes an impediment to enabling the use of integer data within a texture map. By always casting texture data to a floating-point or normalized representation in this way, the GPU's ability to perform more general computation using data stored in a texture map is highly constrained.","As the foregoing illustrates, what is needed in the art is a mechanism to extend the use of integer data types within texture maps.","One embodiment of the invention sets forth a method for loading texture data produced by an application program into a local memory of a graphics processing unit. The method includes the steps of determining that the texture data is integer texture image data, where the integer texture image data has a defined packing organization and is comprised of pixels having values expressed in a first integer format, unpacking the texture data into an array of pixels, populating any unpopulated pixel data fields, and storing the texture data within the local memory.","One advantage of the disclosed method it provides new mechanisms for loading and unloading integer texture images into the local memory of a graphics processing unit. These mechanisms enable the different shader units within the graphics processing unit as well as the application program to have full access to the integer data included in the integer texture images.","As described herein, the term \u201ctexture image\u201d broadly refers to texture data that is organized as an array of pixels or texels. A texture image may reside in memory that is typically not accessible for texture mapping using texture mapping techniques. \u201cPixels\u201d is usually used when discussing texture image data that is a source image or other data transmitted from an application program or when the texture image data is stored a frame buffer memory local to a graphics processing unit, and \u201ctexels\u201d is usually used when discussing texture image data that is stored in a texture memory local to the graphics processing unit. The words pixel and texel may be used interchangeably throughout the present application, depending on context, and neither word is intended to limit the scope of the present invention. Texture image data may include conventional image data, such as color components, or may include other types of data also suitable for use as a texture map, e.g., light intensity, height fields, displacement data, and the like. Each pixel or texel making up the texture data may include one or more components. An \u201cinteger texture image\u201d is texture image data where each component of the pixels or texels has a signed or unsigned integer value. A prior art \u201ctexture map\u201d or \u201cnon-integer texture map\u201d is texture image data where each component of the pixels or texels has a non-integer representation such as a floating-point type or normalized integer type. Importantly, when an integer texture image stored in either the texture memory or frame buffer memory is accessed by either the application program or, if possible, by a programmable or fixed function processing engine within the graphics processing unit, signed or unsigned integer values are returned to the application program or processing engine.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1","b":["100","100","102","104","110","150","160","170","102","110","104","102","110","110","150","104","102","150","102","150","104","150","110","102","110","102","104","150","102","160","150","160","170"]},"The system memory  includes an application program  and integer texture image data  that represents one or more integer texture images, an API  and a GPU driver . The system memory  may also include texture map data , representing one or more texture maps. The application program  generates calls to the API  in order to produce a desired set of results, typically in the form of a sequence of graphics images. The application program  also transmits integer texture image data  and texture map data  to the API  for processing within the GPU driver . The GPU driver  includes a texture loader  and a texture unloader . The texture loader  coordinates the transmission of integer texture image data  and texture map data  to the GPU , which then stores this data in the GPU local memory . As described below, the texture loader  also performs any processing and formatting of the integer texture image data  and the texture map data , according to the specific requirements of the GPU . The texture unloader  retrieves data from the GPU local memory  on behalf of the application program . The texture unloader  performs any processing and formatting of the integer texture image data  and the texture map data , according to the specific request requirements of the application program .","The GPU  includes a vertex shader , a geometry shader , a fragment shader , a scan out unit  and a memory interface . As is well-known, the vertex shader  receives a sequence of one or more sets of vertex attributes, where each set of vertex attributes is typically associated with a geometric primitive. The vertex shader  processes the vertex attributes so that linear interpolation may be performed on the processed vertex data by subsequent processing stages. The vertex shader  may also store and retrieve data within the GPU local memory . The vertex shader  may operate according to a set of fixed-functions or operate according to a set of programming instructions, as determined by the specific class of GPU  design. The geometry shader  receives sets of processed vertices from the vertex shader . The geometry shader  performs per-primitive operations on vertices grouped into primitives such as triangles, lines, strips and points generated by the vertex shader . The geometry shader  may operate according to a set of fixed-functions or operate according to a set of programming instructions, as determined by the specific class of GPU  design. The fragment shader  processes fragment data, which may include raster position, depth or interpolated vertex attributes, such as texture coordinates, color, opacity, and other relevant per-pixel data, to produce final pixel values. The fragment shader  may operate according to a set of fixed-functions or operate according to a set of programming instructions, as determined by the specific class of GPU  design.","The memory interface  stores and retrieves data within the GPU local memory  in response to requests from on-chip clients, such as the vertex shader , the geometry shader , the fragment shader  and the scan out unit . The memory interface  arbitrates for competing requests for bandwidth, performs address remapping for greater efficiency in the use of the available bandwidth, re-formats data according to the type of buffer being accessed and implements the bus interface protocol used by the GPU local memory . The scan out unit  retrieves data from the GPU local memory  for visible display on the display . The scan out unit  typically operates under a set of real-time requirements set by the display , such as horizontal and vertical refresh rates. The scan out unit  should, in some operating modes, be permitted to complete a vertical refresh of an image prior to any modification of the image source buffer to avoid visual \u201ctearing\u201d of the image being displayed.","The GPU local memory  includes at least one integer texture image  and a frame buffer . The GPU local memory  may also include one or more texture maps . The integer texture image  may be generated by copying data from the integer texture image data  within system memory . Alternately, the integer texture image  may be generated procedurally by one of the shader units within the GPU , such as the fragment shader . The texture map  is typically copied from texture map data  within system memory . Alternately, the texture map  may be generated procedurally by one of the shader units within the GPU . The texture map  and integer texture image  store data elements typically organized in one-dimensional, two-dimensional or three-dimensional structures. Data stored within the texture map  and integer texture image  is typically accessed with the assistance of application specific hardware that provides for a dimensional access view of the data. For example, a two-dimensional surface may be addressed with the assistance of a hardware unit that transposes a horizontal and vertical surface location into a physical memory address that corresponds to the location. The frame buffer  includes at least one two-dimensional surface that is used to drive the display . The frame buffer  may include more than one two-dimensional surfaces so that the GPU  can render to one two-dimensional surface while a second two-dimensional surface is used to drive the display .","Again, as described herein, the integer texture image  comprises an array of texels stored as signed or unsigned integer values and the texture map  comprises an array of texels having a non-integer representation or a normalized integer representation that is converted to floating-point when accessed. If stored in the frame buffer , the integer texture image and the texture map are stored as an array of pixels.","The display  is an output device capable of emitting a visual image corresponding to an input data signal. For example, the display may be built using a cathode ray tube (CRT) monitor, a liquid crystal display, or any other suitable display system. The input data signal to the display  is typically generated by scanning out the contents of one or more frames of image data that is stored in the frame buffer .",{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 2","FIG. 1"],"b":["200","110","160","112","210","120","210","114","116","120","210","112","120","210","164","162","215","120","210","210","220","260","215","210","164","162"]},"In one embodiment, the first texture load pipeline within the texture load path  proceeds according to the prior art pipeline, described in detail in the OpenGL\u2122 2.0 specification. This texture load pipeline includes an unpack data engine , a convert data to red-green-blue-alpha (RGBA) floating-point unit , a pixel transfer engine , a clamp unit  and a pack data engine . The unpack data engine  is configured using OpenGL\u2122 functions to unpack a source image, such as texture data , and to produce an array of pixels, where each pixel has a specified dimension that includes allocated space for RGBA values. As described in detail in the Open GL 2.0 specification, the pixels within a source image are a sequence of signed or unsigned bytes (GL data types byte and ubyte), signed or unsigned short integers (GL data types short and ushort), signed or unsigned integers (int or uint) or floating-point values (float). These data values are grouped into sets of one, two, three or four values per pixel, depending on the format of the source image. Fixed-point normalized data are then converted from the unpacked source image format to a standard floating-point format in the convert RGBA to floating-point unit  using Equation 1, set forth below. The variable f represents the converted floating-point value. The variable c represents the integer value of the bit field within the source image containing the data value being converted. N is the number of bits in the bit field.\n\n\/(2\u22121)\u2003\u2003(Equation 1)\n","In the event that the source image format is not a complete RGBA format, the convert RGBA to floating-point unit  fills out the unpopulated data fields of the converted pixels with values from one or more data fields of the source pixels. For example, if the source image format includes only luminance, then the convert RGBA to floating-point unit  copies the source luminance value to each of the RGBA values in the destination pixel. The pixel transfer engine  is configured using OpenGL\u2122 functions to perform scale, bias, convolution and color conversion operations on the converted floating-point data. The pixel transfer engine  transmits data to the clamp unit , which optionally clamps the data values generated by the pixel transfer engine  to the inclusive range of [0.0 to 1.0]. The data generated by the clamp unit  is then processed by the pack data engine  for efficient storage and access within the texture map . The first texture load pipeline thus processes the texture data , which may include a significant number of different source formats, into a consistent floating-point format for efficient storage in the texture map .","The second texture load pipeline within the texture load path  processes data according to a newly introduced pipeline architecture, whereby the texture data  generally proceeds from the application program  to GPU local memory  without modification of the byte values of the texels within the texture data . A set of new data formats are added to the API  that enable the application  to indicate which of the two texture load pipelines should be used to load a given set of texture data  into GPU local memory . TABLE 1 lists these new data formats.",{"@attributes":{"id":"p-0029","num":"0028"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Format Name","Format Identifier"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["RED_INTEGER_EXT","0x8D94"]},{"entry":["GREEN_INTEGER_EXT ","0x8D95"]},{"entry":["BLUE_INTEGER_EXT","0x8D96"]},{"entry":["ALPHA_INTEGER_EXT","0x8D97"]},{"entry":["RGB_INTEGER_EXT","0x8D98"]},{"entry":["RGBA_INTEGER_EXT","0x8D99"]},{"entry":["BGR_INTEGER_EXT","0x8D9A"]},{"entry":["BGRA_INTEGER_EXT","0x8D9B"]},{"entry":["LUMINANCE_INTEGER_EXT","0x8D9C"]},{"entry":["LUMINANCE_ALPHA_INTEGER_EXT","0x8D9D"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":["215","120","210","120","210","260","262","264","270","260","230","262","264","162","162","264","270","162"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 3","FIG. 1"],"b":["300","160","110","310","160","110","112","310","310","315","120","310","116","114","160","330","328","326","324","322","320","116"]},"The unpack from memory engine  reverses any packing, remapping or formatting performed by the pack data engine  of  and presents the pixel transfer engine  with floating-point values from the texture data . The pixel transfer engine  is configured using OpenGL\u2122 functions to perform scale, bias, convolution and color conversion operations on the floating-point data. The pixel transfer engine  transmits data to the convert RGB to L unit , which in turn restructures the floating-point RGB data, if necessary, in accordance with the format of texture map data . The restructured data is transmitted to the clamp unit , which optionally clamps the output values to a specified range. For example, a floating-point number maybe clamped to the range of [0.0-1.0]. The pack data engine  then stores the clamped pixel data using the pixel packing organization specified for the texture map data . The pack data engine  performs any remaining conversions to a specific format for storage, as requested by the application program . The OpenGL\u2122 2.0 specification defines the different packing organizations that may be implemented by the pack data engine .","The second texture unload pipeline within the texture load path  processes data according to a newly introduced pipeline architecture, whereby the texture data  generally proceeds from the GPU local memory  to the application program  without modification of the byte values of the texels within the texture data . More specifically, GPU driver  processes texture data  through this second pipeline when GPU driver  determines, in step , that the texture data  is in one of the integer formats listed in TABLE 1. The second pipeline includes an unpack from memory engine , a format conversion unit , a convert RGBA to L unit and a pack data engine .","The unpack from memory engine  reverses any remapping, packing or formatting performed by the pack data engine  of  and presents the format conversion unit  with integer values from the texture data . The integers values are passed to the format conversion unit , which may resize the integer values according to the format of the integer texture image data . For example, a signed 16-bit integer within the texture data  may be sign-extended to conform to a signed 32-bit format within the integer texture image data . The convert RGB to L unit  performs any organizational modifications to the data received from the format conversion unit  necessary to conform to the format of the integer texture image data . The pack data engine  then clamps the pixel data to a range that is representable within the integer texture image data  and stores the pixel data using the packing organization in the integer texture image data . Again, the pack data engine  uses the OpenGL\u2122 2.0 specification for packing formats, which are organized according to elements per pixel and bytes per element.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIGS. 2 and 3","b":["112","162","160","162","152","153","154","162","112"]},"In addition, even though  describes unloading texture data stored in either texture map  or integer texture image  within GPU local memory  using the load path  of , in alternative embodiments, un-load path  of  may be used to unload texture data stored in frame buffer  within GPU local memory  using the load path described below in .",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 4","FIG. 1"],"b":["400","110","166","160","112","410","120","410","114","116","120","410","112","120","410","166","166","415","120","410","410","420","460","166"]},"In one embodiment, the first texture load pipeline within the frame buffer load path  proceeds according to the prior art pipeline, described in detail in the OpenGL\u2122 2.0 specification. This texture load pipeline includes an unpack data engine , a convert data to floating-point unit , a convert to RGBA unit , a pixel transfer engine , a clamp unit  and the fragment shader . The unpack data engine  is configured using OpenGL\u2122 functions to unpack a source image, such as texture data , and to produce an array of pixels, where each pixel has a specified dimension that includes allocated space for RGBA values. As described in detail in the Open GL 2.0 specification, the pixels within a source image are a sequence of signed or unsigned bytes. These data values are grouped into sets of one, two, three or four values per pixel, depending on the format of the source image. Fixed-point normalized data are then converted from the unpacked source image format to a standard floating-point format in the convert data to floating-point unit  using Equation 1, set forth previously herein.","In the event that the source image format is not a complete RGBA format, the convert to RGBA unit  fills out the unpopulated data fields of the converted pixels with a combination of predefined constant values and values from one or more data fields of the source pixels. For example, in the LUMINANCE and LUMINANCE_ALPHA formats, the red, green and blue components are filled with the luminance values. Any remaining unpopulated fields are filled with predefined default values. The pixel transfer engine  is configured using OpenGL\u2122 functions to perform scale, bias, convolution and color conversion operations on the converted floating-point data. The pixel transfer engine  transmits data to the clamp unit , which clamps the data values generated by the pixel transfer engine  to the inclusive range of [0.0 to 1.0]. The data generated by the clamp unit  is then used to generate fragments that are processed by the fragment shader , which provides access to the frame buffer  within GPU local memory . The DrawPixels( ) OpenGL\u2122 API command may be used to engage the fragment shader  to provide the write path to the frame buffer . The first texture load pipeline thus processes the texture data , which may include a significant number of different source formats, into a consistent floating-point or normalized integer format for storage in the frame buffer . When the frame buffer  is configured to store a normalized integer format, the outputs of the fragment shader  are converted to a fixed-point value for storage","The second texture load pipeline within the frame buffer load path  processes data according to a newly introduced pipeline architecture, whereby the texture data  generally proceeds from the application program  to the frame buffer  within GPU local memory  without modification of the byte values of the texels within the texture data . Again, Table 1 sets forth a set of new data formats that are added to the API  that enable the application  to indicate which of the two texture load pipelines should be used to load a given set of texture data  into the frame buffer  within GPU local memory .","More specifically, in step , if GPU driver  determines that texture data  is in one of the formats listed in TABLE 1, then GPU driver  processes texture data  through the second texture load pipeline, which includes an unpack data engine , a convert to RGBA unit , a format conversion unit  and to pack data unit . The unpack data engine  operates on the data formats specified in TABLE 1, producing an array of pixels similar to the array produced by the unpack data engine . In the event that the source image format is not a complete RGBA format, the convert to RGBA unit  fills out the unpopulated data fields according to well-known prior art techniques. In one embodiment, the pixel values may be expressed as signed or unsigned integer values that are 8, 16 or 32 bits in length. The format conversion unit  converts between integer formats, should the need arise, but otherwise passes data through unmodified. For example, a source image using signed 8-bit values should undergo sign extension if the frame buffer format is a signed 32-bit format. The data generated by the format conversion unit  are then processed by the fragment shader , which provides access to the frame buffer  within GPU local memory . The DrawPixels( ) OpenGL\u2122 API command may be used to engage the fragment shader  to provide the write path to the frame buffer . In such a scenario, the fragment shader  should be compiled to expect the input colors associated with input fragments to be integer values.","In sum, three types of texture access mechanisms are added to a computing device that incorporates a GPU co-processor capable of full integer math operations. The first mechanism provides full integer texture loading and un-loading between the system memory and the GPU local memory. This process is invoked by a graphics application using new integer data types added to the API. The second mechanism enables GPU shader units to access integer texture image data directly and without compulsory casting operations being performed on the data. The third mechanism enables the GPU to render texture data directly into the frame buffer via the fragment shader.","In one embodiment of the invention, a computer-readable medium includes instructions that, when executed by a processor, cause the processor to load texture data produced by an application program into a local memory of a graphics processing unit, by performing the steps of determining that the texture data is integer texture image data, wherein the integer texture image data has a defined packing organization and is comprised of pixels having values expressed in a first integer format, unpacking the texture data into an array of pixels, populating any unpopulated pixel data fields, and storing the texture data within the local memory.","While the forgoing is directed to embodiments of the present invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof, and the scope thereof is determined by the claims that follow.","All trademarks are the respective property of their owners."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["So that the manner in which the above recited features of the present invention can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to embodiments, some of which are illustrated in the appended drawings. It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
