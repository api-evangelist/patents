---
title: Method and system for encrypting JavaScript object notation (JSON) messages
abstract: The confidentiality of JavaScript Object Notation (JSON) message data is secured using an encryption scheme. The encryption scheme implements a JSON encryption syntax, together with a set of processing rules for creating encrypting arbitrary data in JSON messages in a platform/language independent manner. A method for encrypting a data item in a JSON message begins by applying an encryption method and a key to the data item to generate a cipher value. A data object is then constructed that represents an encryption of the data item. The data item in the JSON message is then replaced with the data object, and the resulting modified JSON message is then output from a sending entity. At a receiving entity, information in the data object is used to re-generate the data item, which is then placed back in the original message.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09461817&OS=09461817&RS=09461817
owner: International Business Machines Corporation
number: 09461817
owner_city: Armonk
owner_country: US
publication_date: 20090120
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF AN ILLUSTRATIVE EMBODIMENT"],"p":["This application is related to Ser. No. 12\/356,290, filed Jan. 20, 2009, titled \u201cMethod and system for signing JavaScript Object Notation (JSON) Messages\u201d.","1. Technical Field","This disclosure relates generally to securing data messages over a communication network.","2. Background of the Related Art","Asynchronous JavaScript and XML (collectively referred to as AJAX) are well-known technologies that allow user interaction with Web pages to be decoupled from the Web browser's communications with a Web server. AJAX is built upon dynamic HTML (DHTML) technologies including: JavaScript, a scripting language commonly used in client-side Web applications; the Document Object Model (DOM), a standard object model for representing HTML or XML documents; and Cascading Style Sheets (CSS), a style sheet language used to describe the presentation of HTML documents. In AJAX, client-side JavaScript updates the presentation of a Web page by dynamically modifying a DOM tree and a style sheet. In addition, asynchronous communication, enabled by additional technologies, allows dynamic updates of data without the need to reload the entire Web page. These additional technologies include XMLHttpRequest, an application programming interface (API) that allows client-side JavaScript to make HTTP connections to a remote server and to exchange data, and JavaScript Serialized Object Notation (JSON), a lightweight, text-based, language-independent data-interchange format.","JSON is based on a subset of the JavaScript Programming Language, Standard ECMA-262, 3Edition, dated December 1999. It is also described in Request for Comment (RFC) 4627. JSON syntax is a text format defined with a collection of name\/value pairs and an ordered list of values. JSON is very useful for sending structured data over the wire (e.g., the Internet) that is lightweight and easy to parse. It is language-independent but uses conventions that are familiar to C-family programming conventions. Further information about JSON can be found as json.org.","Currently, JSON messages are secured over the wire using mere transport security (such as SSL), which only provides point-to-point message security. The data in the message, however, is provided in the clear and, as a result, such data can still be compromised through various means, such as by malicious altering by an attacker, or accidental altering through transmission errors.","There remains a need to add data confidentiality protection to JSON messages.","The privacy of JSON message data is secured using an encryption scheme. The encryption scheme implements a JSON encryption syntax, together with a set of processing rules for encrypting arbitrary data in JSON messages in a platform\/language independent manner.","According to one feature, a machine-implemented method for encrypting a data item in a JavaScript Object Notation (JSON) message begins by applying an encryption method and a key to the data item to generate a cipher value. A data object is then constructed that represents an encryption of the data item. The data item in the JSON message is then replaced with the data object, and the resulting modified JSON message is then output. Preferably, the data object is constructed according to a syntax, which defines a set of one or more elements. These elements includes at least one of a first element that includes information associated with the encryption method; a second element that includes data associated with the key; a third element that includes data associated with the cipher value generated by applying the encryption method and the key to the data item; and a fourth element that includes data associated with an encrypted version of the key. By organizing or applying these elements in various ways to the message contents, an encryptor can encrypt any JSON object, array, string, or other artifact within the JSON message, or any combination of such data, or the JSON message itself.","The above-described functionality can be used to implement an end-to end system wherein entities communicate JSON messages to one another over a network. In this aspect, a sending entity comprising a calling application (such as a Web browser), and an encryptor that constructs a data object for at least one data item in a JSON message. The data object includes information on how to decrypt data associated with the data object to obtain the data item. In operation, the encryptor replaces the data item in the message with the data object and provides a resulting modified JSON message to the calling application. The system also includes a receiving entity comprising a calling application (such as a Web server) that receives the modified JSON message, and a decryptor. The decryptor uses the information in the data object to decrypt the data associated with the data object to obtain the data item. The decryptor then replaces the data associated with the data object with the data item to obtain the original JSON message, which it then provides to the application.","The foregoing has outlined some of the more pertinent features of the invention. These features should be construed to be merely illustrative. Many other beneficial results can be attained by applying the disclosed invention in a different manner or by modifying the invention as will be described.","In a typical scenario, illustrated in , JSON messages are sent from an initial sender  to an ultimate receiver  along a JSON message path comprising zero or more intermediaries . The devices ,  and  are computing entities, such as data processing systems each comprising hardware and software, which entities communicate with one another over a network, such as the publicly-routed Internet  (in this example), an intranet, an extranet, a private network, a wireless link, or any other communications medium or link. As described below, a data processing system typically comprises one or more processors, an operating system, one or more applications and one or more utilities. A given data processing system may be a sender or sending entity, in which case the system is deemed to be on a \u201csender side\u201d of the transmission, or a receiver or receiving entity, in which case the system is deemed to be on a \u201creceiver side.\u201d JSON messages, such as message , may flow in either direction. Typically, the sender  includes a Web browser, and the receiver  includes a Web server, or vice versa. In AJAX, client-side JavaScript updates the presentation of a Web page displayed in the browser by using the XMLHttpRequest API (or the like) to communicate to server asynchronously, with the resulting request\/response typically involving the exchange of one or more JSON (or other structured data) messages. In the prior art, the JSON messages are delivered over the wire in the clear, although point-to-point security typically is used (between sender and receiver) using transport layer security mechanisms, such as HTTP over TLS (Transport Layer Security). In a typical scenario, the sending entity is a client machine executing an AJAX-enabled Web browser, and the receiving entity is a server machine executing an AJAX-enabled Web server. By \u201cAJAX-enabled,\u201d a particular device has the capability of creating and processing messages using AJAX technologies. Of course, these are merely representative data processing systems.","By way of additional background, known JSON syntax is built on two structures: a collection of name\/value pairs, and an ordered list of values. The collection of name\/value pairs goes by different nomenclature depending on the language involved, and this structure typically is realized as an object, a record, a struct, a hash table, a keyed list or an associative array. For discussion purposes, the object nomenclature will be used. The ordered list of values also goes by different nomenclature depending on the language involved, and this structure typically is realized as an array, a vector, a list or a sequence. For discussion purposes, the array nomenclature will be used.","\u201cAn object is an unordered set of name\/value pairs. An object begins with \u201c{\u201d (left brace) and ends with \u201c}\u201d (right brace). Each name is followed by \u201c:\u201d (colon) and the name\/value pairs are separated by \u201c,\u201d (comma):\n\n","An array is an ordered collection of values. An array begins with \u201c[\u201d(left bracket) and ends with \u201c]\u201d (right bracket). Values are separated by \u201c,\u201d (comma):\n\n","A value can be a string in double quotes, or an object, or an array. These structures can be nested, such as value =string \u2225object\u2225 array.",{"@attributes":{"id":"p-0028","num":"0029"},"figref":["FIG. 2","FIG. 3"],"b":["200","300"]},"The following Example 1 illustrates the actual JSON message that corresponds to the tree representation in :",{"@attributes":{"id":"p-0030","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ \u201cPaymentInfo\u201d: {"]},{"entry":[{},"\u2003\u2003\u201cName\u201d:\u201cJohn Smith\u201d,"]},{"entry":[{},"\u2003\u2003\u201cCreditCard\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cLimit\u201d:\u201c5,000\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cCurrency\u201d:\u201cUSD\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cNumber\u201d:\u201c4019 ... 1234\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cIssuer\u201d:\u201cExample Bank\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cExpiration\u201d:\u201c04\\\/02\u201d"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The following Example 2 illustrates the actual JSON message that corresponds to the tree representation in :",{"@attributes":{"id":"p-0032","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ \u201cUserRecord\u201d: {"]},{"entry":[{},"\u2003\u2003\u201cName\u201d:\u201cJohn Smith\u201d,"]},{"entry":[{},"\u2003\u2003\u201cCreditCards\u201d: [ {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cCreditCard\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cLimit\u201d:\u201c5,000\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cCurrency\u201d:\u201cUSD\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cNumber\u201d:\u201c4019 ... 1234\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cIssuer\u201d:\u201cExample Bank\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cExpiration\u201d:\u201c04\\\/02\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003},"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cCreditCard\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cLimit\u201d:\u201c25,000\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cCurrency\u201d:\u201cUSD\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cNumber\u201d:\u201c2115 ... 1234\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cIssuer\u201d:\u201cExample Bank\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cExpiration\u201d:\u201c04\\\/02\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003} ]"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"According to this disclosure, encryption is applied to any part or the whole JSON message that includes JSON (object, array or string) artifacts. The following Table 1 describes a JSON Encryption syntax according this disclosure. The JSON Encryption comprises a set of properties that are described as follows:",{"@attributes":{"id":"p-0034","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Property\/element\/object","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["EncryptedData","This is a required element that is a container for information"]},{"entry":[{},"describing the encrypted data."]},{"entry":["VersionId","This optional element describes the namespace for the"]},{"entry":[{},"EncryptedData element. The VersionId allows for future"]},{"entry":[{},"EncryptedData format and processing changes."]},{"entry":["Id","An EncryptedData element could have an optional Id for"]},{"entry":[{},"identification purposes and retrieval."]},{"entry":["EncryptionMethod","This is a required element describing the algorithm used for"]},{"entry":[{},"encryption and optionally the data type of the object encrypted."]},{"entry":["Type","A child element of EncryptionMethod that is a URI that"]},{"entry":[{},"identifies the data type encrypted."]},{"entry":["Algorithm","A child element of EncryptionMethod that is a URI that"]},{"entry":[{},"identifies the encryption algorithm used for the encrypted data or"]},{"entry":[{},"encrypted key."]},{"entry":["KeyInfo","The element that contains information needed to retrieve the"]},{"entry":[{},"decryption key."]},{"entry":["CipherData","A required element that contains a CipherValue."]},{"entry":["CipherValue","A base64 encoded string of an encrypted octet sequence."]},{"entry":["EncryptedKeys[ ]","An array of EncryptedKey elements."]},{"entry":["EncryptedKey","An optional element that describes information on an encrypted key"]},{"entry":[{},"that when decrypted can be used to decrypt the EncryptedData"]},{"entry":[{},"CipherValue. This element can be a child of KeyInfo and"]},{"entry":[{},"EncryptedKeys[ ]."]},{"entry":["VersionId","This optional element describes the namespace for an"]},{"entry":[{},"EncryptedKey element. The VersionId allows for future"]},{"entry":[{},"EncryptedKey format and processing."]},{"entry":["Id","An EncryptedKey may have an optional Id for identification purpose"]},{"entry":[{},"and retrieval. This element is used when the EncryptedKey is a"]},{"entry":[{},"child element of EncryptedKeys[ ]."]},{"entry":["ReferenceList[ ]","An array of data references that identify the encrypted data to which"]},{"entry":[{},"this key can be applied."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"When encrypting data in the JSON message, the resulting data is replaced by a new JSON object. This object is referred to as an EncryptedData object. The EncryptedData object has information in it regarding how to decrypt the data to get the original JSON message data. In particular, typically, the EncryptedData object includes one or more other JSON syntax objects, such as VersionId, EncryptionMethod, and CipherData. A VersionId object is used to identify a version of the JSON encryption element, typically specified as a URI. The KeyInfo element typically defines one or more parameters (e.g., name, value, retrieval method, and the like) for the keys used to encrypt and\/or decrypt. These parameters may themselves be specified or structured as separate JSON objects (e.g., such as KeyName, KeyValue, RetrievalMethod, and the like). The EncryptionMethod object identifies the particular encryption algorithm, typically specified as a URI, which is to be used for the encryption. The CipherData object is an element that identifies a cipher value that results from applying the encryption algorithm to the data, and the cipher value itself may be a structured element. An EncryptedKey object may be used to specify how to build an encrypted key. The nomenclature set forth above should not be taken as limiting. Thus, for example, any of the above-identified objects may be generalized into \u201cfirst,\u201d \u201csecond\u201d and \u201cthird\u201d objects or elements without loss of generality. Also, the term \u201cobject\u201d in the context of the JSON encryption syntax described herein may also be referred to as an \u201celement\u201d without loss of generality.",{"@attributes":{"id":"p-0036","num":"0037"},"figref":"FIG. 4","b":["400","402","404","406","408","410","412","400","402","414","416"]},"With reference now to , a process flow diagram is shown illustrating how to encrypt a data item according to the subject matter described herein. As used herein, and as noted above, a \u201cdata item\u201d may be any JSON object, array, string, or other artifact within the JSON message, or any combination of such data, or the entire JSON message itself. The encryption process illustrated in  is repeated for each data item to be encrypted in the message, and as will be seen it can also be used to encrypt the key that is used for encryption if such encryption is desired.","For each data item to be encrypted as an EncryptedData or EncryptedKey, the encryptor performs the following machine-implemented method. The method begins at step  by selecting an algorithm (and parameters) to be used in encrypting the data item. At step , the routine obtains and (optionally) represents the key that will be used for encryption. Thus, if the key is to be identified in the JSON message itself, at step  the routine constructs a KeyInfo element with the appropriate parameters (e.g., KeyName, KeyValue, RetrievalMethod, and the like). If the key itself is to be encrypted, at step  the routine constructs an EncryptedKey JSON object, preferably by recursively applying the encryption process. The result of recursively applying the encryption process may then be used as a child element of KeyInfo, or the result may be positioned at the root of the JSON document tree, e.g., in a list of EncryptedKeys.","After step  is completed, the routine continues at step , which is a sub-loop used to encrypt the data item. In particular, at step  the routine obtains a series of octets by serializing the data item in UTF-8. As is well-known, UTF-8 (8-bit. UCS\/Unicode Transformation Format) is a variable-length character encoding for Unicode. UTF-8 encodes each character in one to four octets (8-bit bytes). In the context of data storage and transmission, serialization is the process of converting a data item into a sequence of bits so that it can be stored on a storage medium (such as a file, or a memory buffer) or transmitted across a network connection link. When the resulting series of bits is re-read according to the serialization format, it can be used to create a semantically identical clone of the original data item. The process of serializing a data item is also known as deflating or marshalling; the opposite operation, namely, extracting a data item from a series of bytes, is known as deserialization (inflating or unmarshalling). Serialization may be done by the encryptor; if the encryptor does not serialize, then the application should perform the serialization. If the data item is of any other type that is not already in octet form, the application should serialize the data item as octets.","At step , the routine encrypts the octets using the algorithm (identified in step ) and the key obtained in step . At step , the encryptor identifies a data item \u201ctype.\u201d This operation is desired unless the decryptor knows (explicitly or implicitly) the type of the data item being encrypted. The definition of the \u201ctype\u201d is preferably bound to an identifier (e.g., through a URI) and specifies (to the decryptor) how to obtain and interpret the plaintext octets after decryption. The type specified indicates the return type of JSON artifact of the parsed JSON plaintext. In particular, the encryption method type identifies the underlying JSON data type encrypted so as to simplify the decryption processing. JSON libraries have classes that can parse a JSON string and turn it into a JSON object, and that can serialize a JSON object to a JSON string. There are different JSON object data types (JSONObject, JSONArray). Knowledge of the type of data allows the decryption process to use the methods supplied by JSON libraries and thereby construct the resulting JSON message after decryption. This completes the data encryption sub-loop .","The routine then continues at step  to build the EncryptedData or EncryptedKey JSON object. The EncryptedData JSON object represents the information described above used to encrypt the data item, including the type of the encrypted data, encryption algorithm, key, and the like. If the encrypted octet sequence obtained in step  is to be stored in the CipherData element within the EncryptedData or EncryptedKey JSON object, then the encrypted octet sequence is encoded (e.g., through base  encoding) and inserted as the content of a CipherValue element.","The routine then continues a step  to process the EncryptedData object. In one embodiment, the encryptor returns the EncryptedData JSON object to the application. The application then uses the EncryptedData object as a top-level element in a new JSON message, or inserts the object into another JSON message. More typically, and according to another embodiment, it is the encryptor that replaces the unencrypted JSON artifact (the data item) with the EncryptedData object. In particular, and as shown in , when an application  requires a JSON artifact to be replaced, the application  supplies the encryptor  the JSON message  in addition to identifying the JSON artifact  to be replaced. The JSON artifact can be identified using notation as described above. After creating the EncryptedData JSON object , the encryptor  removes the identified JSON artifact  and inserts in its place the EncryptedData JSON object .","This completes the encryption process.",{"@attributes":{"id":"p-0044","num":"0045"},"figref":"FIG. 6"},"The routine begins at step  to process the JSON object to determine the algorithm, parameters and KeyInfo element to be used for the decryption. If some information is omitted, the application that calls the decryptor must supply it. At step , the routine locates the data encryption key according to the KeyInfo element, which (as noted above) may contain one or more children elements. These children typically have no implied processing order. If the data encryption key is encrypted, the routine locates the corresponding key in order to decrypt it. This may be a recursive step, as the key-encryption key itself may be encrypted. Or, the routine may retrieve the data encryption key from a local data store using the provided attributes or implicit binding identified in the element.","At step , the routine decrypts the data contained in the CipherData element. In particular, if a CipherValue child element is present, then the associated text value is retrieved and decoded (e.g., by base  decoding) to obtain the encrypted octet sequence. The encrypted octet sequence is then decrypted using the algorithm, parameters and key value already determined from steps  and . Thereafter, and at step , the decrypted data is processed. In particular, the cleartext octet sequence obtained in step  is interpreted, e.g., as UTF-8 encoded character data. The decryptor must be able to return the \u201ctype\u201d value and the UTF-8 encoded JSON character data. The decryptor may also perform validation on the serialized JSON object. Preferably, the decryptor also replaces the EncryptedData object with the decrypted JSON artifact represented by the UTF-8 encoded characters. The decryptor or some other function may also perform a validation on the result of this replacement operation. Typically, the application supplies the JSON message context and identifies to the decryptor the EncryptedData object being replaced. If the JSON document into which the replacement is occurring is not UTF-8, the decryptor transcodes the UTF-8 encoded characters into the target encoding.","This completes the decryption process.","\u201cThe following are representative examples that illustrate how the JSON encryption syntax and processing rules generate protected JSON messages according to the techniques disclosed herein. URLs specify \u201chttp:\u201d (omitted for clarity).\u201d","Example 3 below represents the JSON message of Example 1 following encryption. In this example, The EncryptedData JSON object represents the encrypted CreditCard information. The EncryptionMethod describes the type of encrypted JSON data and the applied encryption algorithm, which (in this example) is triple DES (Data Encryption Standard). The KeyInfo contains the information that is needed to retrieve the decryption key, which (in this example) is a shared secret key represented by the KeyName object. The CipherValue contains the cipher text that is obtained by serializing and encrypting the CreditCard information:",{"@attributes":{"id":"p-0050","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ \u201cPaymentInfo\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cName\u201d:\u201cJohn Smith\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cEncryptedData\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cVersionId\u201d:\u201chttp:\/\/www.ibm.com\/2008\/09\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003jsonenc#EncryptedData\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cEncryptionMethod\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cType\u201d:\u201chttp:\/\/www.ibm.com\/2008\/09\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003jsonenc#object\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cAlgorithm\u201d:\u201c\/\/www.ibm.com\/...\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003jsonenc#tripledes-cbc\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2002},"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cKeyInfo\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cKeyName\u201d:\u201cshared secret key name\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003},"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cCipherData\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cCipherValue\u201d:\u201cydUNqHkMrD...\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In Example 3 above, it is assumed that both the sender and recipient have a common secret key. If the recipient has a public and private key pair, which is most likely the case, the Creditcard information can be encrypted as shown in Example 4 below. In this example, the symmetric key is derived by the encryptor (it is not a pre-established secret); the symmetric key is encrypted with the public key of the recipient, and output is stored in EncryptedKey. This allows for the encrypting process to \u201cshare\u201d the symmetric key on-the-fly rather than having it as a pre-established secret. It also allows the encryptor to limit the number of recipients:",{"@attributes":{"id":"p-0052","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"{ \u201cPaymentInfo\u201d: {"},{"entry":"\u2003\u2003\u201cName\u201d:\u201cJohn Smith\u201d,"},{"entry":"\u2003\u2003\u201cEncryptedData\u201d: {"},{"entry":"\u2003\u2003\u2003\u201cVersionId\u201d:\u201chttp:\/\/www.ibm.com\/2008\/09\/"},{"entry":"\u2003\u2003\u2003jsonenc#EncryptedData\u201d,"},{"entry":"\u2003\u2003\u201cEncryptionMethod\u201d: {"},{"entry":"\u2003\u2003\u2003\u2002\u201cType\u201d:\u201c\/\/www.ibm.com\/2008\/09\/jsonenc#object\u201d,"},{"entry":"\u2003\u2003\u2003\u2002\u201cAlgorithm\u201d:\u201c\/\/www.ibm.com\/...\/jsonenc#tripledes-cbc\u201d"},{"entry":"\u2003\u2003},"},{"entry":"\u2003\u2003\u201cKeyInfo\u201d: {"},{"entry":"\u2003\u2003\u201cEncryptedKey\u201d: {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201cVersionId\u201d:\u201c:\/\/www.ibm.com\/2008\/09\/"},{"entry":"\u2003\u2003\u2003\u2003\u2003jsonenc#EncryptedKey\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201cEncryptionMethod\u201d: {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u201cAlgorithm\u201d: \u201c\/\/www.ibm.com\/...\/jsonenc#rsa-1_5\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003},"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201cKeyInfo\u201d: {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u201cX509Data\u201d: {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cX509SKI\u201d: \u201cR8ReX ... GNM=\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003},"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u201cCipherData\u201d: {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u201cCipherValue\u201d:\u201cyMTEyu0tAm1...\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2002},"},{"entry":"\u2003\u2003\u201cCipherData\u201d: {"},{"entry":"\u2003\u2003\u2003\u2003\u201cCipherValue\u201d:\u201cydUNqHkMrD...\u201d"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2002}"},{"entry":"\u2002}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The following Example 5 is similar to Example 4, however, here the EncryptedKey is found using a RetrievalMethod instead of embedding it as a child object of the KeyInfo element. As can be seen in this example, at the root of the JSON document a list of EncryptedKeys contains an array of EncryptedKey JSON objects. In this example, there is one EncryptedKey that contains an identifier that matches the URI in the RetrievalMethod of the EncryptedData. EncryptedKeys can be mapped during parsing with an EncryptedKey. Id being the key, and the value would be the EncryptedKey data. This allows for quick retrieval of the EncryptedKey. The ReferenceList here is an object that contains pointers from a key value of an EncryptedKey to items encrypted by that key value (EncryptedData or EncryptedKey JSON objects).",{"@attributes":{"id":"p-0054","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ \u201cPaymentInfo\u201d: {"]},{"entry":[{},"\u2003\u2003\u201cName\u201d:\u201cJohn Smith\u201d,"]},{"entry":[{},"\u2003\u2003\u201cEncryptedData\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u201cVersionId\u201d:\u201c\/\/www.ibm.com\/2008\/09\/"]},{"entry":[{},"\u2003\u2003\u2003jsonenc#EncryptedData\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u201cId\u201d:\u201cCreditCard\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u201cEncryptionMethod\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cType\u201d:\u201c\/\/www.ibm.com\/2008\/09\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003jsonenc#object\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cAlgorithm\u201d:\u201c\/\/www.ibm.com\/2008\/09\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003jsonenc#tripledes-cbc\u201d"]},{"entry":[{},"\u2003\u2003\u2003},"]},{"entry":[{},"\u2003\u2003\u2003\u201cKeyInfo\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cRetrievalMethod\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cURI\u201d:\u201c#ID_OF_ENCRYPTEDKEY\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cType\u201d:\u201chttp:\/\/www.ibm.com\/2008\/09\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003jsonenc#EncryptedKey\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003},"]},{"entry":[{},"\u2003\u2003\u2003\u2003},"]},{"entry":[{},"\u2003\u2003\u2003\u201cCipherData\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cCipherValue\u201d:\u201cydUNqHkMrD...\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003},"]},{"entry":[{},"\u2003\u2003\u201cEncryptedKeys\u201d:["]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u201cEncryptedKey\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cVersionId\u201d:\u201c\/\/www.ibm.com\/2008\/09\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003jsonenc#EncryptedKey\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cId\u201d:\u201cID_OF_ENCRYPTEDKEY\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cEncryptionMethod\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cAlgorithm\u201d:\u201c\/\/www.ibm.com\/2008\/09\/"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003jsonenc#rsa-1_5\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003},"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cKeyInfo\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cX509Data\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cX509SKI\u201d:\u201cR8ReXSe ... vWQWGNM=\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003},"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cCipherData\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cCipherValue\u201d:\u201cxyzabc..\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003},"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cReferenceList\u201d: [ {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cDataReference\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cURI\u201d:\u201c#CreditCard\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003} ],"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cCarriedKeyName\u201d:\u201cSally Doe\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003}]"]},{"entry":[{},"\u2003}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Example 6 below represents the JSON message of Example 1 following encryption of just the CreditCard number. This example is similar to that of Example 3 above, with the main difference being the EncryptionMethod Type value. The resulting decryption of the EncryptedData would result in a string that would be set as the value of the Number object:",{"@attributes":{"id":"p-0056","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ \u201cPaymentInfo\u201d: {"]},{"entry":[{},"\u2003\u2003\u201cName\u201d:\u201cJohn Smith\u201d,"]},{"entry":[{},"\u2003\u2003\u201cCreditCard\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cLimit\u201d:\u201c5,000\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cCurrency\u201d:\u201cUSD\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cNumber\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u201cEncryptedData\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cVersionId\u201d:\u201c...\/jsonenc#EncryptedData\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cEncryptionMethod\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cType\u201d:\u201c...\/jsonenc#string\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cAlgorithm\u201d:\u201c ... \/jsonenc#tripledes-cbc\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003},"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cKeyInfo\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cKeyName\u201d:\u201cshared secret key name\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003},"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201cCipherData\u201d: {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cCipherValue\u201d:\u201cydUNqHkMrD...\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003},"]},{"entry":[{},"\u2003\u2003\u2003\u2003},"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cIssuer\u201d:\u201cExample Bank\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cExpiration\u201d:\u201c04\\\/02"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Example 7 below represents the JSON message of Example 2 following encryption of the CreditCards[ ] JSON array. In this example, the result is very similar to Example 3 above, with the main difference once again being the EncryptionMethod Type. The resulting decryption of the EncryptedData would result in a string value that when parsed would result in a JSON array data type that would be added to the UserRecord in place of the EncryptedData:",{"@attributes":{"id":"p-0058","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"{ \u201cUserRecord \u201d: {"},{"entry":"\u2003\u2003\u201cName\u201d:\u201cJohn Smith\u201d,"},{"entry":"\u2003\u2003\u201cEncryptedData\u201d: {"},{"entry":"\u2003\u2003\u2003\u2003\u201cVersionId\u201d:\u201c\/\/www.ibm.com\/ ...\/jsonenc#EncryptedData\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u201cEncryptionMethod\u201d: {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u201cType\u201d: \u201chttp:\/\/www.ibm.com\/2008\/09\/jsonenc#array\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u201cAlgorithm\u201d:\u201c... \/jsonenc#tripledes-cbc\u201d"},{"entry":"\u2003\u2003\u2003\u2003},"},{"entry":"\u2003\u2003\u2003\u2003\u201cKeyInfo\u201d: {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u201cKeyName\u201d:\u201cshared secret key name\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003},"},{"entry":"\u2003\u2003\u2003\u2003\u201cCipherData\u201d: {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u201cCipherValue\u201d:\u201cydUNqHkMrD...\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The particular encryption algorithms, keys and parameters used by the encryptor are not a feature of this disclosure. Thus, the encryption algorithms used to encrypt the data items in the JSON message may be any known techniques. Such as one or more of the following:\n\n","These algorithms are merely representative, however, as any known or later-developed encryption algorithms may be used.","The techniques described herein are advantageous. The disclosed subject matter solves the problem of adding message encryption to JSON messages. Using the encryption syntax as described, a sending entity can encrypt all or parts of a JSON message supporting symmetric (shared secret) and asymmetric (public key) encryption methods. The advantage of using JSON over XML is that JSON is lightweight and fast to parse, resulting in increased performance and smaller footprint (on disk and memory). By implementing JSON message encryption in this manner, an additional layer of security (over and above any transport layer security) is provided to protect the data confidentiality of the communicated data. Thus, the data in the message is further secured against malicious altering by an attacker (who can compromise the transport security), or against accidental altering through transmission errors. Using this approach, the sending entity need not even use transport security.",{"@attributes":{"id":"p-0062","num":"0066"},"figref":"FIG. 8","b":["800","800","802","805","804","806","808","810","812","814","816","818","820"]},"\u201cThe disclosed subject matter can take the form of an entirely hardware embodiment, an entirely software embodiment or an embodiment containing both hardware and software elements. In one embodiment, the JSON encryption syntax and associated encryptor and decryptor routines are implemented in software, which includes but is not limited to firmware, resident software, microcode, and the like. Furthermore, as noted above, the disclosed subject matter can take the form of a computer program product accessible from a computer-usable or computer-readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description, a computer-usable or computer readable medium can be any apparatus that can contain or store, the program for use by or in connection with the instruction execution system, apparatus, or device. The medium can be an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system (or apparatus or device). Examples of a computer-readable medium include a semiconductor or solid state memory, magnetic tape, a removable computer diskette, a random access memory (RAM), a read\u2014only memory (ROM), a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk-read only memory (CD-ROM), compact disk\u2014read\/write (CD-R\/W) and DVD. The transform and related functions may also be implemented as a service.\u201d","The encryptor and\/or decryptor functions may be implemented as computer programs that are retrieved over a computer network. In one example embodiment, the encryptor or decryptor is a computer program product comprising a set of instructions (program code). The instructions are stored in a computer readable storage medium in a data processing system, and these instructions are downloaded over a network from a remote data processing system. In an alternative embodiment, the instructions are stored in a computer readable storage medium in a server data processing system, and the instructions are downloaded over a network to a remote data processing system for use in a computer readable storage medium with the remote system. The encryptor and\/or decryptor functions may also be carried by a third party as a managed or hosted service offering.","While the above describes a particular order of operations performed by certain embodiments of the invention, it should be understood that such order is exemplary, as alternative embodiments may perform the operations in a different order, combine certain operations, overlap certain operations, or the like. References in the specification to a given embodiment indicate that the embodiment described may include a particular feature, structure, or characteristic, but every embodiment may not necessarily include the particular feature, structure, or characteristic.","Finally, while given components of the system have been described separately, one of ordinary skill will appreciate that some of the functions may be combined or shared in given instructions, program sequences, code portions, and the like.","The subject matter herein is not limited to encrypting JSON messages. The techniques may be applied to any text-based, data-interchange message format that is used to create a portable representation of structured data. Thus, the techniques described herein apply to encrypting structured data messages, where a structured data message comprises a collection of name\/value pairs, and an ordered list of values. More generally, the techniques described herein may be generalized for use with respect to any structured data-interchange format. Examples of such alternative formats include those where the collection of name\/value pairs is a record, a struct, a hash table, a keyed list or an associative array, or where the ordered list of values is realized as a vector, a list or a sequence."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a more complete understanding of the present invention and the advantages thereof, reference is now made to the following descriptions taken in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
