---
title: Automatic run-time identification of textures
abstract: In one embodiment, a texture identification method and system are disclosed that uniquely identifies textures as they are used by the application and associates collected, inferred, or user-specified data with objects not owned by the library. In various embodiments, textures may be identified in various scenarios such as when textures are loaded, deleted, relocated, reloaded, and the like. In a further embodiment, APIs are provided that the application can call to provide useful information to the system that can improve the quality of the data in some situations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09582919&OS=09582919&RS=09582919
owner: Microsoft Technology Licensing, LLC
number: 09582919
owner_city: Redmond
owner_country: US
publication_date: 20091009
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE","BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS"],"p":["This application is related to co-pending U.S. application Ser. No. 12\/576,548, filed on Oct. 9, 2009, entitled \u201cAUTOMATIC REAL-TIME SHADER MODIFICATION FOR TEXTURE FETCH INSTRUMENTATION\u201d, which is hereby incorporated by reference in its entirety.","Many computing applications perform a significant amount of processing to generate graphics. For example, video game applications may use 3D graphics to render images and animations. However, 3D applications typically require a significant amount of texture data to produce good quality scenes. The amount of texture data in turn requires a significant amount of space in memory and on the storage medium (e.g., hard disk or optical disc). For most games, this texture data, as a percentage, typically consumes most of the available storage, relative to other aspects of the game such as the executable program code and audio data. Therefore, reducing the amount of graphics data such as texture data and optimizing the processing required to support the application is desirable for increasing the space available for other types of data, reducing download times, and fitting necessary data such as texture data onto a storage medium such as an optical disc. Reducing the amount of graphics data used for textures in a game or program would also allow for new textures used in new levels or new areas new or portions of the game to be added, expanding the game or program.","An important aspect of data optimization is understanding how many times an image file is used during the course of the execution of an application. For example, it would be advantageous to know how many times a certain MIP level of a texture is used during the course of a video game. In many cases an application such as a video game may ship with many examples of sub-optimal texture usage such as duplicate textures, textures that are never used, and MIP levels that never fetched.","However, gathering detailed statistics regarding texture usage requires a significant amount of development investment and game modification. Typically, developers use simpler techniques such as visual inspection where textures are colored at run-time based on which MIP level is being displayed. Such techniques may, for example, provide information for identifying issues with the diffuse texture on a mesh. However, such techniques may not provide sufficient information in the case of textures where the color does not come through such as in a normal or gloss map. Furthermore, the use of visual inspection does not provide a holistic view of a texture's usage throughout the game, and tend to provide more qualitative rather than quantitative analysis. This visual inspection method is also not able to detect identical duplicates because visually they appear the same upon visual observation, and may not provide an easy mechanism for identifying which textures are being observed.","It is therefore desirable to uniquely identify textures as they are loaded and passed to the host system via, for example, the application programming interface (API). Typically such identification is difficult to perform on platforms that provide the application flexibility for creating and manipulating textures. For example, the system would need to deal with textures that have been deleted, relocated, aliased, and the like. In addition, the system must be able to detect if a texture being loaded has been used before.","In various embodiments disclosed herein, a method and system are disclosed for run-time tracking and monitoring of detailed statistics about the use of data assets during execution of an application such as a video game. After execution of the game, usage data may be provided to the developer describing the use of each asset during execution.","In one embodiment, a texture identification method and system are disclosed that uniquely identifies textures as they are used by the application. In various embodiments, textures may be identified in various scenarios such as when textures are loaded, deleted, relocated, reloaded, and the like. In this manner, applications may use a method of choice for creating and managing textures. In a further embodiment, APIs are provided that the application can call to provide useful information to the system that can improve the quality of the data in some situations.","In an embodiment, such a method may be implemented in a software development kit, and a game application developer may use a texture tracking feature to record and provide texture usage data. The development kit may then automatically instrument shaders as the data and instructions are passed to the system in real time.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter. Furthermore, the claimed subject matter is not limited to implementations that solve any or all disadvantages noted in any part of this disclosure.","Certain specific details are set forth in the following description and figures to provide a thorough understanding of various embodiments of the disclosure. Certain well-known details often associated with computing and software technology are not set forth in the following disclosure to avoid unnecessarily obscuring the various embodiments of the disclosure. Further, those of ordinary skill in the relevant art will understand that they can practice other embodiments of the disclosure without one or more of the details described below. Finally, while various methods are described with reference to steps and sequences in the following disclosure, the description as such is for providing a clear implementation of embodiments of the disclosure, and the steps and sequences of steps should not be taken as required to practice this disclosure.","Infrastructure for Texture Identification and Tracking",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1","b":["200","200","200"]},"Numerous other general purpose or special purpose computing system environments or configurations may be used. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, embedded systems, distributed computing environments that include any of the above systems or devices, and the like.","Computer-executable instructions, such as program modules, being executed by a computer may be used. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Distributed computing environments may be used where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment, program modules and other data may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The processing unit  may represent multiple logical processing units such as those supported on a multi-threaded processor. The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus). The system bus  may also be implemented as a point-to-point connection, switching fabric, or the like, among the communicating devices.","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CDROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 2","FIG. 1","FIG. 2"],"b":["12","100","100","101","102","104","106","102","104","101","102","104","106","100"]},"A graphics processing unit (GPU)  and a video encoder\/video codec (coder\/decoder)  form a video processing pipeline for high speed and high resolution graphics processing. Data is carried from the graphics processing unit  to the video encoder\/video codec  via a bus. The video processing pipeline outputs data to an A\/V (audio\/video) port  for transmission to a television or other display. A memory controller  is connected to the GPU  to facilitate processor access to various types of memory , such as, but not limited to, a RAM (Random Access Memory).","The multimedia console  includes an I\/O controller , a system management controller , an audio processing unit , a network interface controller , a first USB host controller , a second USB controller  and a front panel I\/O subassembly  that are preferably implemented on a module . The USB controllers  and  serve as hosts for peripheral controllers ()-(), a wireless adapter , and an external memory device  (e.g., flash memory, external CD\/DVD ROM drive, removable media, etc.). The network interface  and\/or wireless adapter  provide access to a network (e.g., the Internet, home network, etc.) and may be any of a wide variety of various wired or wireless adapter components including an Ethernet card, a modem, a Bluetooth module, a cable modem, and the like.","System memory  is provided to store application data that is loaded during the boot process. A media drive  is provided and may comprise a DVD\/CD drive, hard drive, or other removable media drive, etc. The media drive  may be internal or external to the multimedia console . Application data may be accessed via the media drive  for execution, playback, etc. by the multimedia console . The media drive  is connected to the I\/O controller  via a bus, such as a Serial ATA bus or other high speed connection (e.g., IEEE 1394).","The system management controller  provides a variety of service functions related to assuring availability of the multimedia console . The audio processing unit  and an audio codec  form a corresponding audio processing pipeline with high fidelity and stereo processing. Audio data is carried between the audio processing unit  and the audio codec  via a communication link. The audio processing pipeline outputs data to the A\/V port  for reproduction by an external audio player or device having audio capabilities.","The front panel I\/O subassembly  supports the functionality of the power button  and the eject button , as well as any LEDs (light emitting diodes) or other indicators exposed on the outer surface of the multimedia console . A system power supply module  provides power to the components of the multimedia console . A fan  cools the circuitry within the multimedia console .","The CPU , GPU , memory controller , and various other components within the multimedia console  are interconnected via one or more buses, including serial and parallel buses, a memory bus, a peripheral bus, and a processor or local bus using any of a variety of bus architectures. By way of example, such architectures can include a Peripheral Component Interconnects (PCI) bus, PCI-Express bus, etc.","When the multimedia console  is powered ON, application data may be loaded from the system memory  into memory  and\/or caches ,  and executed on the CPU . The application may present a graphical user interface that provides a consistent user experience when navigating to different media types available on the multimedia console . In operation, applications and\/or other media contained within the media drive  may be launched or played from the media drive  to provide additional functionalities to the multimedia console .","The multimedia console  may be operated as a standalone system by simply connecting the system to a television or other display. In this standalone mode, the multimedia console  allows one or more users to interact with the system, watch movies, or listen to music. However, with the integration of broadband connectivity made available through the network interface  or the wireless adapter , the multimedia console  may further be operated as a participant in a larger network community.","When the multimedia console  is powered ON, a set amount of hardware resources are reserved for system use by the multimedia console operating system. These resources may include a reservation of memory (e.g., 16 MB), CPU and GPU cycles (e.g., 5%), networking bandwidth (e.g., 8 kbs), etc. Because these resources are reserved at system boot time, the reserved resources do not exist from the application's view.","In particular, the memory reservation preferably is large enough to contain the launch kernel, concurrent system applications and drivers. The CPU reservation is preferably constant such that if the reserved CPU usage is not used by the system applications, an idle thread will consume any unused cycles.","With regard to the GPU reservation, lightweight messages generated by the system applications (e.g., popups) are displayed by using a GPU interrupt to schedule code to render popup into an overlay. The amount of memory required for an overlay depends on the overlay area size and the overlay preferably scales with screen resolution. Where a full user interface is used by the concurrent system application, it is preferable to use a resolution independent of application resolution. A scaler may be used to set this resolution such that the need to change frequency and cause a TV resynch is eliminated.","After the multimedia console  boots and system resources are reserved, concurrent system applications execute to provide system functionalities. The system functionalities are encapsulated in a set of system applications that execute within the reserved system resources described above. The operating system kernel identifies threads that are system application threads versus gaming application threads. The system applications are preferably scheduled to run on the CPU  at predetermined times and intervals in order to provide a consistent system resource view to the application. The scheduling is to minimize cache disruption for the gaming application running on the console.","When a concurrent system application requires audio, audio processing is scheduled asynchronously to the gaming application due to time sensitivity. A multimedia console application manager (described below) controls the gaming application audio level (e.g., mute, attenuate) when system applications are active.","Input devices (e.g., controllers () and ()) are shared by gaming applications and system applications. The input devices are not reserved resources, but are to be switched between system applications and the gaming application such that each will have a focus of the device. The application manager preferably controls the switching of input stream, without knowledge the gaming application's knowledge and a driver maintains state information regarding focus switches. The cameras ,  and capture device  may define additional input devices for the console .","In the embodiments disclosed herein, some or all of the described operations may be performed using one or more of the functional components described above. For example, some CPUs are powerful enough now to perform GPU-like processing of vertices and pixels. Thus the disclosed embodiments may be implemented in cases without a separate GPU.","Textures","The following example embodiments describe a texture identification and real-time shader modification method for texture fetch instrumentation in the context of video game applications and systems such as Microsoft's XBOX 360 console. However, the application to video game consoles is exemplary, and those skilled in the art will recognize that the disclosed principles are readily applicable to other real-time 3D data, applications and platforms. Such data may include any media file such as music files. Furthermore, the presently disclosed subject matter is applicable not only to textures, but to any situation where a library is attempting to track information (lifetime, usage patterns, uniqueness) of objects which it does not own, but which are passed into the library by other code not controlled or directly instrumentable by the library. All such data, applications and platforms are contemplated as within the scope of the present disclosure.","In the following examples, the disclosed methods are illustrated in the context of a software development kit used by a video game developer. However, the examples are provided for the purpose of illustration and the disclosed methods may be provided in using other methods and mechanisms.","In graphics applications such as video games, 3D graphics may be used. 3D graphics uses modeling via the wireframe representation of three-dimensional objects that may be displayed as a two-dimensional image using various 3D rendering techniques. Such techniques may, for example, represent a 3D object using a collection of points in 3D space connected by a geometric entity such as a triangle. When a scene in a video game application is set up, the various virtual objects, the viewer's perspective, color, and lighting may be considered in generating a still image or an animation. Typically, the 3D model's vertices are colored and that color may then be interpolated across the model's surface during rendering. One method of adding color information to a 3D model is by applying a 2D texture image to the model's surface using texture mapping. Textures may add detail, surface texture, or color to a computer-generated graphic or 3D model. Vertex geometry information (vertex buffers) may comprise texture coordinates that indicate how to map the points of the texture image map to the 3D model's surface. The texture may be mapped to the surface of a shape such as a triangle that is typically used in 3D modeling. Additionally, shaders may perform complex calculations to fetch from arbitrary locations within any number of textures.","Since a textured surface may be at an arbitrary distance and orientation relative to the viewer, some form of filtering may be applied to determine the best color for the pixel. Given a rectangular texture, depending on the desired viewing distance and orientation, multiple texels may need to be sampled and combined, to provide the most appropriate color for a pixel.","Mipmapping is one technique that may be used to save some of the processing required to map the texture data. Mipmaps may be pre-calculated optimized collections of images that accompany a main texture. The mipmaps may thus be used to increase rendering speed by alleviating the need to resize a texture in real time. Mipmapping prefilters the texture and stores the texture in smaller sizes down to a single pixel. As the textured surface moves farther away, the texture being applied switches to the prefiltered smaller size. Each mipmap image may be a version of the main texture, but at a certain reduced level of detail. Although the main texture may be used when the view is sufficient to render it in full detail, the renderer may switch to a suitable mipmap image when the texture is viewed from a distance or at a small size. Rendering speed increases since the number of texture pixels being processed can be much lower than with simple textures. For example, if the texture has a basic size of 256 by 256 pixels, then the associated mipmap set may contain a series of eight images, each one-fourth the total area of the previous one: 128\u00d7128 pixels, 64\u00d764, 32\u00d732, 16\u00d716, 8\u00d78, 4\u00d74, 2\u00d72, and 1\u00d71.","Referring to , illustrated is an example of a texture mipmap image with a plurality of MIP levels. As shown in the figure, the principal image  on the left is accompanied by filtered copies of reduced size , , and so on.","3D applications typically require a significant amount of texture data to produce good quality scenes. The amount of texture data in turn requires a significant amount of space in memory and on the storage medium (e.g., hard disk or optical disk). In some cases application developers such as video game developers may have problems with having sufficient space on the disk for the desired image data. For example, each figure for every scene in a videogame may have multiple textures associated with it. A texture may be 128\u00d7128 pixels and may require several kilobytes per texture. To exacerbate the problem, a developer may inadvertently provide two or more textures of the same image. In other cases, a texture may be provided that is much larger than is needed for the application. It would be helpful to provide the data on the use of textures during development of the games that the developer can use to optimize the use of textures before shipping the product. For example, with such information a developer can eliminate duplicate textures, or reduce the dimensions of textures that are too large for their ultimate utilization in the application. Therefore, reducing the amount of graphics data such as texture data and optimizing the processing required to support the application is desirable for increasing the space available for other types of data, reducing download times, and fitting necessary data such as texture data onto a storage medium such as an optical disc. Reducing the amount of graphics data used for textures in a game or program would also allow for new textures used in new levels or new areas new or portions of the game to be added, expanding the game or program.","An important aspect of data optimization is understanding how many times an image file is used during the course of the execution of an application. For example, it would be advantageous to know how many times a certain MIP level of a texture is used during the course of a video game. In many cases an application such as a video game may ship with many examples of sub-optimal texture usage such as duplicate textures, textures that are never used, and MIP levels that are never fetched.","However, gathering detailed statistics regarding texture usage requires a significant amount of development investment and game modification. Typically, developers use simpler techniques such as visual inspection where textures are colored at run-time based on which MIP level is being displayed. Such techniques may, for example, provide information for identifying issues with the diffuse texture on a mesh. However, such techniques may not provide sufficient information in the case of textures where the color does not come through such as in a normal or gloss map. Furthermore, the use of visual inspection does not provide a holistic view of a texture's usage throughout the game, and tend to provide more qualitative rather than quantitative analysis. This visual inspection method is also not able to detect identical duplicates because visually they appear the same upon visual observation. The visual inspection method also is not well-suited for identifying which texture the developer is observing.","Some developers may implement offline processing of textures in their content pipelines that look for static issues such as duplicated color channels and similar textures. Such techniques can identify a certain class of issues, but do not provide useful information about how the texture is used at run-time. For example, such techniques cannot determine if a texture is never used during run-time, or if any channels were never fetched.","It is therefore desirable to uniquely identify textures as they are loaded and passed to the host system via, for example, the application programming interface (API). Typically such identification is difficult to perform on platforms that provide the application flexibility for creating and manipulating textures. For example, the system would need to deal with textures that have been deleted, relocated, aliased (i.e., have multiple texture headers that point to the same memory location), and the like. In addition, the system must be able to detect if a texture being loaded has been used before. One issue that such an identification needs to address is that when a texture is requested by reference to its address, the shader may identify the correct size of the texture (e.g., that it is a 64\u00d764 texture) but it may not be known where from the disk that the texture was loaded from. Another issue is that textures loaded in a particular area of memory may later be moved, if allowed to by the library.","In various embodiments, a game developer may load the game application using the software development kit, click a button to enable data capture, and then run through the game at its various levels and scenes. Thereafter, the developer may view a report detailing the usage of the textures and the MIP levels that were used during the execution of the game.","Identification","In an embodiment of the presently disclosed subject matter, a modified 3D API library and a viewer application may be provided. The modified library may provide the same interfaces as the standard version of the library, but with several under-the-hood modifications to enable texture tracking. The user\/developer may compile their game application against the modified library and call a specific API to enable the tracking of textures. As the game executes, the library may uniquely identify all the textures used by the game. The library may also instrument shaders and command buffers on the fly such that texture usage statistics can be collected. In an embodiment, when the user desires to take a capture (i.e., a recording of texture usage patterns), the user may click a button on the viewer application or call the \u201cstart\u201d API, whereupon all texture usage may be recorded by the library and stored in a capture file. When the user ends the capture by clicking a button in the viewer app or calling the \u201cstop\u201d API, the capture file may be transferred to the host computing system and loaded into the viewer application. At this time the viewer application may process the texture usage data and generate a list of smart recommendations for improving the usage of space. In one embodiment the user may be presented with the entire list of textures used, each with thumbnails, usage statistics, and recommended modifications to save texture space. An interactive graph of fetches per MIP and screenshots may be provided in order to help the user better understand the context in which the texture was used.","In one embodiment, a library provided by the system or console for use by the application (i.e., the external code) may expose a set of one or more APIs to the external code which process the objects. In some systems such a library may be provided that can be called by the game application to access functions provided by the system for example for rendering images and animations on the user interface. In the case of Microsoft's XBOX 360 which uses Direct3D, such APIs may comprise \u201cSetTexture\u201d or \u201cSetPixelShader\u201d wherein a game application may pass a texture or shader object to the library in order for the texture or shader object to be used by the library.","In some systems such as Microsoft's XBOX 360, the application may be provided complete control over the loading of textures from the DVD into the memory. While such a capability may provide flexibility to the game developer to improve performance, the flexibility may make it more difficult for the system to track a texture's usage once loaded. For example, when loading a texture from the DVD into the console memory, a copy of the image may be loaded into a section of memory that is unknown to the library.","The system may implement a structure for tracking the possible locations of objects in memory, with descriptions of each object that has identified at each memory address. When, for example, Direct3D directs commands and textures to the Graphics Processing Unit (GPU), the texture's identification may be determined. When the external code calls any of the standard or optional APIs, the library may be notified that \u201cthere is an object at address X, which has this description, and is being used in this way.\u201d The library may then check the memory tracking structure to see if a matching object with the same description was recently identified at that memory address.","If no objects have been identified at the address, or if other objects have been loaded at that memory address which do not match the new object, a new node for the address may be added to the structure with the description of the object that was provided to the API. Any previous nodes for the address may be added to the history of the node.","If the most recent object identified at that memory address matches the description of the object being passed to the API, the node tracking for that address may be updated with a \u201cmost recently used\u201d timestamp and a counter may be incremented.","In order to deal with cases such as aliasing (where two objects with different descriptions share the same region of memory), a history of each memory address may be maintained that tracks the last N objects that have been loaded in that memory address. If an object's description does not match the \u201cmost recently used\u201d in the address' history, but does match some other node in the history, then the old matching node may be moved to the \u201cmost recently used\u201d position.","When a new object is discovered (e.g., whenever a new node is created in the above history), a new object analyzer may be invoked. Such an analyzer may be used to uniquely identify the object. In one embodiment an icon or thumbnail of the texture referenced by the GPU may be captured and saved. The thumbnail or icon may then be associated with the time that the image was rendered and the memory location that was retrieved. Future texture fetches associated with the same memory location may be accumulated and provided in the usage report.","One problem that may arise is when the developer may provide a name to identify a texture and then use the name again for a different texture or similar texture. For example, there may be a \u201cbrick\u201d texture file for Level 1 of a game that represents a rectangular red brick. For Level 2 of a game, there may be a \u201cbrick\u201d texture that represents a rounded gray stone used as a brick. In this case it would be useful to find another way to distinguish the textures even if they are given the same name by the developer. Another problem that may arise is when two identical textures are given different names. Similarly, a texture may have been provided twice.","In one embodiment, a hash may be calculated for each texture that is fetched. For instance, the new object analyzer may generate a 128-bit hash of the RGBA bits of one or more MIP levels of the texture. For more complex objects, other types of hashing or unique identification methods may be used. With a hash for each of the textures, the system may be able to determine when hashes are identical or when different MIP levels are associated with the same image.","Once the object has been assigned a unique identifier (the 128-bit hash or otherwise), a history of the usage of that object may be maintained. For example, a texture may be loaded at time 0:15 to address A, unloaded at 0:20, re-loaded at 0:30 to address B, loaded into a 2nd memory address (address C) at 0:40, unloaded from B at 0:50 and from C at 0:53. For each of the times that the texture is loaded, the external code may be allowed to load the texture at any memory location (A, B, or C). By using the unique identifier, the creation\/deletion information for each of the three addresses can be combined into one useful history. The per-address object description node may point to the appropriate entry in the unique persistent object-tracking database.","If a texture is loaded but never used during the course of execution of the application, no data needs to be provided for that texture and the developer can assume that the texture was not used.","Additionally and optionally, the library may expose a set of APIs to assist the tracking of object creation and deletion. In one embodiment, a second set of APIs may be used to allow for hints to be provided to assist the texture tracking code. For example, such hints may provide information for establishing definitive timestamps for texture creation and deletion. On Microsoft's XBOX 360, for example, such hints may be helpful because game applications may be allowed to manage textures independently from the D3D library. In another embodiment, the external code may also name an object. For example, the actual file name or the full path-on-disk of the file from which the object was loaded may be used as a name. This name can be used to assist in uniquely identifying the object. In this case the developer may need to modify the game code to provide the file names.","Example situations where \u201chint\u201d functions may be used by the tracking mechanism include:","1) When the external code physically relocates an object in memory. In this case the external code may call a \u201creport moved object\u201d API to inform the memory tracker function.","2) When the external code replaces an object with another object with a matching description but a different unique object ID, the external code may either call a \u201cSet Object Name\u201d API, a \u201cReport New Object\u201d API, or a \u201cReport Deleted Object\u201d API in order to provide information so that the tracking mechanism can distinguish the two objects.","3) The API may be called to inform the system that a texture has been deleted.","However, if the new object analyzer is sufficiently fast, in some cases it may be acceptable to re-hash or re-generate the unique ID for every object, in which case the external calls to the \u201chint APIs\u201d may not be invoked.","Referring now to , illustrated is an exemplary functional diagram depicting various aspects of an identification system disclosed herein. The figure indicates one example including application-owned code and data and library-owned APIs. Application  may have access to application owned APIs . Such APIs may be called for creating objects, moving objects, deleting objects, and the like. As discussed above, in some systems the application may be provided control over the loading of objects into memory . Thus memory  may contain multiple objects which may have lifetimes and descriptions that are unknown to the library.","The library may provide APIs  that can use and process the objects. The user\/developer may compile their game application against the library and call a specific API to enable the tracking of textures. One or more APIs maybe called by application  to process the objects.","A structure  may be created and stored to describe the library's information regarding the current state of objects that are loaded in memory. New nodes may be added to the structure with the description of the object that was provided to the API when a new address is identified as having an object for processing or if objects have be loaded at that memory address which do not match the new object. Any previous nodes for the address may be added to the history of the node. If the most recent object identified at that memory address matches the description of the object being passed to the API, the node tracking for that address may be updated with a \u201cmost recently used\u201d timestamp and a counter may be incremented.","When a new object is discovered, new object analyzer  may be invoked to uniquely identifying the object. All objects that have been created or otherwise used may be stored in persistent database . Additionally and optionally, a second set of APIs  may be used to allow for hints to be provided to assist the texture tracking code. For example, such hints may provide information for reporting new objects, reporting deleted objects, naming objects, reporting moved to objects, reporting used to objects, and the like.","Data Capture","Shaders are typically used to program a GPU. A shader may comprise a set of software instructions for calculating rendering effects on the GPU. A shader may, for example, describe the characteristics of a vertex such as position, texture coordinates, and colors. A shader may also describe the characteristics of a pixel such as its position, texture coordinates, and colors. In an exemplary system, the central processing unit (CPU) may send instructions and geometry data to the GPU, and a vertex shader may transform the geometry, perform lighting calculations, perform changes to the geometries in a scene, triangulate the calculated geometry, and transform the triangle's pixel primitives.","In one embodiment, in order to determine how textures are used, a development system may track all shaders and textures used by an application. The tracking may be performed at the API level. In other embodiments, the tracking may be performed at other levels such as the driver level. Typically the instructions and data for the GPU are contained in packets that identify a texture as well as identifying the processing to be performed on that texture. For example, a packet may contain a point to a text and an instruction for the GPU to draw a texture one hundred times.","The packets may be interpreted and analyzed to determine the nature and content of what is being requested. Sufficient knowledge of how the packet will be used is necessary to do this interpretation and analysis. In one embodiment, the development system may parse the command buffer which is submitted to the GPU, and analyze and\/or modify each packet. Commands may be added to track what textures and MIPs are being used. For example, the command packets may contain shader instructions and pointers to textures. A pixel shader may be disassembled to find all instructions which fetch from textures, and instructions may be added that determine the identity and MIP levels of each texture that is to be retrieved. After instrumenting the shader, the new shader may be added to a shader cache or other mechanism, in order to enable the original game's shader to point to the instrumented copy. The collected information (such as texture identity and MIP level) may then be sent to the CPU so that the information can be tracked. In one embodiment a counter can be used to track how many times a texture is used.","In this fashion, whenever shaders are newly loaded or newly created they may be modified to track information related to the associated texture such as its identity or location. The modifications to the shaders, or of command buffer instructions may be called \u201cinstrumentation\u201d and the terms may be used interchangeably herein.","In an exemplary system depicted in , the CPU  may send instructions and geometry data to the GPU . Textures  may be loaded into memory  from, for example, a DVD that includes a video game application. The application may include shader code  and game code  that has been compiled into executables. Shader instructions  may be modified or instrumented  prior to being executed by GPU .",{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 6","b":["605","600","610"]},"In order to prevent a shader from being re-instrumented multiple times, a cache system may be added. In one embodiment, a hash table of all previously-instrumented shaders may be maintained. In other embodiments, simpler methods may be used depending on the particular platform and scenario. For example, in a Windows Direct3D implementation, Direct3D completely owns the shader interfaces. In this case, flags may be added to the shader object indicating whether the object has been previously instrumented. If so, a pointer to the instrumented copy of the shader may be provided. Generally, some sort of caching mechanism may be used to improve performance.","A shader analyzer  may locate texture fetch and control flow instructions, analyze register usage, and the like. The instrumentation may then be inserted into a copy of the shader . Shaders that have not been previously instrumented may be analyzed in order to determine the appropriate texture fetch instructions and to determine the feasibility of instrumenting the shader. Adding instrumentation may involve, for example, allocating resources from the shader such as general purpose registers, input or constant registers, and extra shader instruction slots. If it is determined that there are insufficient resources available to add the instrumentation, then the shader may be flagged as not instrumentable.","In one embodiment, groups of similar texture fetch instructions may be identified that may be executed together. Such groups may, for example, not be separated by control flow branches. Instrumentation may then be inserted for the group rather than each instruction individually.","The nature of the instrumentation can vary depending on the hardware platform. For example, in an embodiment using Microsoft's XBOX 360 console, performance counters may be conditionally incremented from within the shader. In another embodiment, a byte may be conditionally exported to memory indicating that certain mipmap levels have been read.","For the purpose of identifying which mipmap levels are being read, instructions may be added that calculate the MIP that each texture fetch will retrieve. However, if a given texture has only one MIP level or if for any other reason the shader is being instrumented just for the purpose of determining which textures have been read (rather than for mipmap usage), the mipmap level calculation may be skipped.","Additionally and optionally, instructions may be inserted that save and restore  any states modified by the instrumentation code so that the original intended calculations of the shader are not altered.","For debugging purposes, the instrumented shader may be validated  to ensure that the added instrumentation does not affect the color\/depth or any other calculations. Validation may be performed symbolically or through simulation.","In various embodiments described herein, one approach may be to anticipate the shader instruction that is about to be processed and instrument the instruction to include code to capture usage statistics. The embodiments are illustrative and one skilled in the art will recognize that the particular ordering of the described steps may be modified. For example, the modified instructions can be processed before or after the texture is retrieved. Those skilled in the art will also recognize that the disclosed methods may be applied to systems processing a variety of data in addition to textures and without prior knowledge of the data used by the application.","Once a shader has been instrumented, wherever the original shader is used, the system may load the instrumented version instead of the original. The command buffer may be modified  to point to the instrumented shader and set up constants and GPU state registers. In some cases, the system may also insert other commands into the command buffer to direct the results of the performance counters or memory to the desired location. In addition, other commands may be used to initialize and\/or restore any registers allocated during the instrumentation process (general purpose registers, constants, interpolants, etc.).","When the process is completed a final report may be provided that indicates the amount of use of particular textures over time. For example, for each identified texture, a timeline may be provided that indicates when the texture was used. Such information may be useful to determine whether, for example, a particular textures was never used (that is, never displayed during the captured sequence), or used so infrequently that the developer may consider modifying the application to eliminate the texture altogether. In one embodiment the images or textures may be searched for after executing the application to determine which textures were actually called for a given piece of usage data. In another embodiment, the system may provide prioritized recommendations for saving texture space based on usage at run-time.","Turning to , illustrated is an exemplary system  for tracking usage data for textures and other data assets. System  may comprise a development machine  and target platform . Game application  may be loaded and launched on the target platform. Texture content  may be loaded into the system memory. The texture content  may be rendered with 3D APIs that are exposed by the API Library . Various textures may be fetched and used to render graphics during execution of game application .","Viewer application  on the development machine  may provide additional interfaces for the developer to select options such as enabling and initiating a data capture. 3D API Library  may perform tasks such as uniquely identifying textures if the texture tracking feature is enabled. 3D API Library  may also instrument the shaders and command buffers and collect texture usage data if capturing is enabled. The usage data may be streamed to the appropriate target such as the operating system (OS) and\/or system hardware such as a hard drive.","When execution of the game application  is complete or when the developer terminates data capture, the usage data captured and collected by the OS  may be provided to the viewer application  and may be displayed by a view recommendations feature  on the viewer application . Depending on the particular embodiment, the developer may generate and\/or print various reports detailing the usage of the texture content . Based on the usage data, the developer may modify the texture content  and execute game application  on target platform  to further refine and optimize the texture content . This process may be repeated iteratively until the developer is satisfied with the texture content  and finalize the content for production delivery.","In one embodiment, the iterations may be simulated automatically so that the developer can quickly preview the results of the changes. Additionally and optionally, a file may be output that is fed into the content generation pipeline to perform the modifications automatically.","Thus in various embodiments the shader code can be modified in real-time to collect usage data for textures and other data assets. This application is useful not only for textures but in any application where a system that provides control over data assets is not informed about the creation or deletion of the assets or has limited information. By generating a unique identification such as a hash, detailed usage information can be collected about the use of those assets.","Referring now to , illustrated is an exemplary process for identifying shared assets in a system for rendering graphics using the shared assets. One or more of the illustrated operations may be omitted, and the illustrated operations do not imply a particular order. In one exemplary method, process  illustrates receiving indication that a requesting process has requested that one of the shared assets be processed by the rendering subsystem. Information comprising an identifier, memory location, and requested use for said one of the shared assets may be received . As discussed above, the identifier may comprise a thumbnail of the shared asset and\/or a hash of the matching asset. It may then be determined  that a matching asset was previously identified at the memory location, updating a record associated with the matching asset , and storing a timestamp corresponding to a system time . Otherwise, a unique identifier may be determined  for said one of the shared assets and a new entry comprising the memory location and requested use may be stored .","In one embodiment, the operation of updating a record may further comprise storing a description of the matching asset . In another embodiment the operation of updating a record may further comprise maintaining a history of the memory location that tracks a predetermined number of shared assets that have been loaded at the address.","In some embodiments, information may be received  from the requesting process information to assist said determining the unique identifier. In one embodiment, the information may comprise a file name of the shared asset. In other embodiments, the information may comprise information describing a memory relocation of the shared asset, an indication that the shared asset is replaced with another shared asset with a matching description and a different unique identifier, or an indication that the shared asset has been deleted.",{"@attributes":{"id":"p-0107","num":"0106"},"figref":["FIG. 9","FIG. 9"],"b":["900","910","920","920"]},"Block  illustrates receiving information comprising an identifier, memory location, requested use for one of the shared assets being processed by the rendering subsystem. Block  illustrates during execution of the rendering subsystem, determining that a matching asset was previously identified at the memory location, updating a record associated with the matching asset, and storing a timestamp corresponding to a system time. Block  illustrates determining a unique identifier for said one of the shared assets and storing a new entry comprising the memory location and requested use.","Any of the above mentioned aspects can be implemented in methods, systems, computer readable media, or any type of manufacture. For example, per , a computer readable medium can store thereon computer executable instructions for identifying shared assets in a system for rendering graphics using the shared assets. Such media can comprise a first subset of instructions for receiving indication that a requesting process has requested that one of the shared assets be processed by the rendering subsystem ; a second subset of instructions for receiving information comprising an identifier, memory location, requested use for said one of the shared assets ; a third subset of instructions for determining that a matching asset was previously identified at the memory location, updating a record associated with the matching asset, and storing a timestamp corresponding to a system time ; and a fourth subset of instructions for determining a unique identifier for said one of the shared assets and storing a new entry comprising the memory location and requested use . It will be appreciated by those skilled in the art that additional sets of instructions can be used to capture the various other aspects disclosed herein, and that the presently disclosed subsets of instructions can vary in detail per the present disclosure.","It should be understood that the various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the disclosure, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the disclosure. In the case of program code execution on programmable computers, the computing device generally includes a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may implement or utilize the processes described in connection with the disclosure, e.g., through the use of an application programming interface (API), reusable controls, or the like. Such programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","While the invention has been particularly shown and described with reference to a preferred embodiment thereof, it will be understood by those skilled in the art that various changes in form and detail may be made without departing from the scope of the present invention as set forth in the following claims. Furthermore, although elements of the invention may be described or claimed in the singular, the plural is contemplated unless limitation to the singular is explicitly stated."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The systems, methods, and computer readable media for altering a view perspective within a virtual environment in accordance with this specification are further described with reference to the accompanying drawings in which:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 10","FIGS. 1-9"]}]},"DETDESC":[{},{}]}
