---
title: Methods and apparatus for root cause identification and problem determination in distributed systems
abstract: A technique for determining a root cause of a condition (e.g., service outage) of at least one subject component in a computing environment comprises the following steps/operations. First, one or more components in the computing environment upon which the at least one subject component depends (e.g., antecedents) are identified. Identification comprises traversing at least a portion of a model representative of an existence of one or more relationships associated with at least a portion of components of the computing environment and which is capable of accounting for a full lifecycle (e.g., including deployment, installation and runtime) associated with at least one component of the computing environment. Then, one or more procedures are performed in accordance with the one or more identified components to determine a condition status associated with each of the one or more identified components. By way of example, the inventive techniques may be applied to a distributed computing environment. The computing environment may also be an autonomic computing environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07096459&OS=07096459&RS=07096459
owner: International Business Machines Corporation
number: 07096459
owner_city: Armonk
owner_country: US
publication_date: 20020911
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS"],"p":["The present application is related to the concurrently-filed U.S. patent applications respectively identified as: Ser. No. 10\/241,162 entitled: \u201cMethods And Apparatus For Managing Dependencies in Distributed Systems\u201d and issued as U.S. Pat. No. 6,847,970 on Jan. 25, 2005; Ser. No. 10\/241,189 entitled: \u201cMethods And Apparatus For Topology Discovery and Representation of Distributed Applications and Services;\u201d Ser. No. 10\/241,214 entitled: \u201cMethods And Apparatus For Impact Analysis and Problem Determination;\u201d and Ser. No. 10\/241,397 entitled: \u201cMethods And Apparatus For Dependency-based Impact Simulation and Vulnerability Analysis;\u201d the disclosures of which are incorporated by reference herein.","The present invention relates to distributed computing systems and, more particularly, to methods and apparatus for analyzing and determining the root cause of a service outage based on dependencies between the various components of such distributed computing systems.","The identification and tracking of dependencies between the components of distributed systems is becoming increasingly important for integrated fault management. Applications, services and their components rely on a variety of supporting services that might be outsourced to a service provider. Moreover, emerging web-based (world wide web-based) business architectures allow the composition of web-based e-business (electronic business) applications at runtime.","It is to be understood that the term \u201cruntime\u201d generally refers to the time period when a piece of software is being executed and active in a computer system's memory, as opposed to being dormant and merely sitting in storage on a computer's hard drive. Thus, being able to compose e-business applications at runtime means having the capability to do so without the need to bring down and restart the system\/application and without the need to recompile the application. Traditionally, the lifecycle of a computer program is: write program code->compile (translate into machine code)->run. Thus, with the above capability, one can assemble several pieces of software to form a new application \u201con-the-fly,\u201d i.e., without the need to bring down\/compile\/restart the application.","Consequently, however, failures occurring in one service affect other services being offered to a customer, i.e., services have dependencies on other services. Dependencies exist between the components of different services on a single system and also between the client and server components of a service across multiple systems and domains. Herein, services that depend on other services are referred to as dependents, while services on which other services depend are referred to as antecedents.","It is important to note that a service often plays both roles (e.g., a name service is required by many applications and services but depends, itself, on the proper functioning of other services, such as the operating system and the network protocols and infrastructure). Furthermore, dependency relationships are transitive, i.e., the dependent of a given component requires, in addition to the component itself, the components' antecedent(s).","Dependencies exist between various components of a distributed system, such as end-user services, system services, applications and their logical and physical components. However, service dependencies are not made explicit in today's systems, thus making the task of problem determination, isolation and resolution particularly difficult.","Existing art in the area of software development (such as U.S. Pat. No. 4,751,635 and U.S. Pat. No. 5,960,196), maintenance (such as U.S. Pat. No. 5,493,682) and software packaging (such as U.S. Pat. No. 5,835,777) deal with individual software elements and modules that form the atomic parts of a program package and require the availability of program source code in order to build software and bundle it into software products. Source code is available to the software developer and not to the service user. The invention primarily focuses on software products that are already packaged.","The Institute of Electrical and Electronics Engineers Standard 1387.2 (entitled \u201cPortable Operating System Interface (POSIX) system administration, part 2: Software Administration,\u201d IEEE, 1995) addresses software distribution\/deployment\/installation. The IEEE standard defines a mechanism for ensuring that new software components (which are going to be installed) do not conflict with an already existing software installation. The IEEE standard identifies three kinds of relationshi: prerequisite, exrequisite, corequisite, that facilitate such compatibility checks. This is done individually for every system on which new software needs to be installed. With the IEEE standard, the software inventories present on other systems are not taken into account. Furthermore, the IEEE standard does not deal with instantiated applications and services and therefore does not represent any means of determining the dependencies between components at runtime.","Open Group (Systems Management: Distributed Software Administration, CAE Specification C701, The Open Group, January 1998) extends IEEE 1387.2 by defining several commands (swinstall, swlist, swmodify, etc.) that are invoked by software installation tools on a specific system. Open Group also defines a software definition file format to make sure that the information required by the aforementioned commands is available from the system on which the commands are invoked. The shortcomings of IEEE 1387.2 (i.e., confined to a single isolated system, no means for determining software dependencies at runtime) also apply to the Open Group specification.","Current Operating System Inventory implementations (such as the IBM AIX Object Data Manager (ODM), the Linux Red Hat Package Manager (RPM) or the Microsoft Windows Registry) follow either the OpenGroup specification and the IEEE 1387.2 standard or describe the software inventory in a proprietary format. Thus, the aforementioned limitations also apply to such Current Operating System Inventory implementations.","Techniques for electronic software distribution of whole program packages (such as U.S. Pat. No. 6,009,525 and U.S. Pat. No. 5,721,824) or updates\/corrections\/fixes\/patches (such as U.S. Pat. No. 5,999,740, U.S. Pat. No. 5,805,891, and U.S. Pat. No. 5,953,533) are, by definition, restricted to the distribution\/deployment\/installation of (one or many at a time) physical software packages and do not take the runtime stages of applications into account. In addition, they deal with one system at a time and do not take the cross-system aspects of applications and services into account.","Techniques for determining conflicts in existing software\/hardware configurations (such as U.S. Pat. No. 5,867,714) are also confined to a single system and do not take runtime aspects into account.","While existing work (such as U.S. Pat. No. 5,917,831), often within the scope of event correlation (see, e.g., Gruschke et al., \u201cIntegrated Event Management: Event Correlation Using Dependency Graphs, DSOM '98, 1998 and K\u00e4tker et al., \u201cFault Isolation and Event Correlation for Integrated Fault Management, IM '97, 1997), has focused on identifying and describing service dependencies in a proprietary format, it has remained unclear how dependency information can actually be exchanged between different entities of the fault management process. Since it is unlikely that the different parties involved in the fault management process of outsourced applications use the same toolset for tracking dependencies, it is of fundamental importance to define an open format for specifying and exchanging dependency information.","Also, due to the heterogeneity associated with components of the distributed system with which the fault management process is involved, determining the root cause of a system failure (e.g., service outage) is extremely difficult, given the limitations of existing techniques.","To sum up, a few techniques relating to the determination of relationships between software products have been described and implemented in the existing art. These existing techniques suffer from one or more of the following shortcomings:","(a) they address only the installation and deployment phases of a software product; i.e., they do not attempt to capture the design and runtime aspects;","(b) they do not deal with end-to-end applications and services that span multiple systems; i.e., they address the characteristics of software residing on a single, isolated system;","(c) software inventory information is described in a proprietary format that makes it extremely difficult to share this information among various heterogeneous systems; and","(d) they do not effectively identify the root cause of a service outage.","The present invention provides techniques for identifying the root cause of a component failure and performing appropriate problem determination procedures in accordance with a computing environment. By way of example, the inventive techniques may be applied to a distributed computing environment. The computing environment may also be an autonomic computing environment.","For example, in one aspect of the invention, a computer-based technique for determining a root cause of a condition (e.g., service outage) of at least one subject component in a computing environment comprises the following steps\/operations. First, one or more components in the computing environment upon which the at least one subject component depends (e.g., antecedents) are identified. Identification comprises traversing at least a portion of a model representative of an existence of one or more relationships associated with at least a portion of components of the computing environment and which is capable of accounting for a full lifecycle (e.g., including deployment, installation and runtime) associated with at least one component of the computing environment.","Then, one or more procedures are performed in accordance with the one or more identified components to determine a condition status associated with each of the one or more identified components. The procedures may be carried out either stepwise or in combination, and may include, by way of example, process inspection, exercising, heartbeats, and status indicators.","By way of example, a component may be a service, an application, middleware, hardware, a device driver, an operating system or a system associated with the computing environment. However, the term \u201ccomponent\u201d is not limited to these examples.","These and other objects, features and advantages of the present invention will become apparent from the following detailed description of illustrative embodiments thereof, which is to be read in connection with the accompanying drawings.","The present invention will be explained below in the context of an illustrative distributed computing environment. However, it is to be understood that the present invention is not limited to such a particular computing environment. Rather, the invention is more generally applicable to any computing environment in which it is desirable to manage (e.g., compute, query, etc.) dependencies in order to make the task of problem determination, isolation and resolution significantly easier.","As used herein, depending on the context of the discussion, the term \u201csystem\u201d may be used to refer to a computer system, a software system and\/or some combination thereof. The term \u201csystem\u201d may also be used to refer to an application and\/or a service. Thus, the phrase \u201cmultiple systems\u201d refers to a collection of several systems. Also, the term \u201ccomponent\u201d may refer to a system, itself, or one or more portions of a system.","As mentioned above, service dependencies are not made explicit in today's systems, thus making the task of problem determination, isolation and resolution particularly difficult. Solving this problem requires the determination and computation of dependencies between services and applications across different systems and domains, i.e., establishing a \u201cglobal\u201d service dependency model and enabling system administrators to navigate through the resulting directed graph from the top to the bottom and in reverse order. The need for such a mechanism is best illustrated by the following two scenarios.","The first scenario deals with managing outsourced services, typically offered by Internet or Application Service Providers (ISP\/ASP). Outsourcing services leads to layered service hierarchies where, e.g., the services of an ASP depend on the IP-connectivity (Internet Protocol-connectivity) offered by an ISP, which, in turn, relies on the wide area network of a telecom carrier. At every layer, a service is accessed through a Service Access Point (SAP). A SAP delimits the boundary between the different organizational domains and is the place where Service Level Agreements (SLAs) are defined and observed. Usually, this is done at every layer by monitoring a set of specific parameters that are exposed by the provider. In case of an outage or performance degradation in an upper-layer service, it is necessary to traverse the service hierarchy from the top to the bottom to identify the root cause of the problem.","The second scenario deals with the regular maintenance tasks that can not be done \u201con-the-fly\u201d and therefore affect services and their customers: e.g., e-mail servers get updated with a new release of their operating system, network devices are exchanged or upgraded with a new firmware version, etc. In all cases, it is important for the network and server administrators to determine in advance how many and, more specifically, which services and users are affected by the maintenance. We refer to this task as impact analysis.","The aforementioned tasks are further exacerbated by the following factors.","Dependency models provide a straightforward means to identify possible root causes of an observed problem. If the dependency graph for a system is known, navigating the graph from an impaired service towards its antecedents (being either co-located on the same host or on different systems) will reveal which entities might have failed. Traversing the graph towards its root (i.e., in upwards direction) yields the dependents of a service, i.e., the components that might fail if this service experiences an outage. The following issues need to be addressed.","(a) Scale: The number of dependencies between many involved systems can be computed, but may become very large. From an engineering viewpoint, it is often undesirable (and sometimes impossible) to store a complete, instantiated dependency model at a single place. Traditional mechanisms used in network management platforms such as keeping an instantiated network map in the platform database therefore can not be applied to dependencies due to the sheer number and the dynamics of the involved dependencies.","These two facts make it prohibitive to follow a \u201cnetwork-management-style\u201d approach for the deployment of application, service and middleware dependency models. As an example, typical data centers of service outsourcers host vast amounts (several thousands) of web application and database servers. This implies a huge number of simultaneously running program instances of, e.g., web application and database servers. A system capable of constructing a dependency model should provide features that allow appropriate scalability by distributing the storage and computation of dependencies across the systems involved in the management process.","(b) Dynamics: Hosted applications (running within web application servers) have a very short lifetime, often only a few seconds. Upon reception of a request, the business logic of a web application (usually implemented as one or more Java Servlets) gets instantiated by the servlet engine of the application server, performs its tasks and is then removed by the servlet engine. Consequently, a system for computing dependencies among these dynamic entities should address the trade-off between the accuracy of the data and the workload generated for retrieving this data.","(c) Heterogeneity: Heterogeneity comes in three different flavors. First, the services offered to customers differ to a large degree. Second, there may be various providers involved in offering a service to a customer. Finally, the products implementing a service may stem from a variety of vendors. A system for computing dependencies should provide a language that is independent of specific operating systems, network protocols, software products and the services offered to a customer.","(d) Manual maintenance of Dependency Data: The acquisition of a service dependency model, even confined to a single host system, is a challenge on its own as today's systems usually do not provide appropriate management instrumentation. It is to be understood that the term \u201cinstrumentation\u201d refers to program code that exposes the management characteristics and capabilities of a (managed) resource through a well-defined (sometimes even standardized) interface so that it can be accessed by management applications. Further, even if available from managed resources, dependency data is not exploited by today's management systems. Instead, the dependency information not only has to be entered manually into a specific management component, but also in a proprietary format. The dependency information is therefore incomplete, outdated (due to the error-prone manual processing), and sometimes even inconsistent because different operators enter the rules independently and there is no way to check the rule base for consistency in an automated way.","(e) Taxonomy for Dependencies: The notion of dependencies is very coarse and needs to be refined in order to be useful. Examples for this are the strength of a dependency (indicating the likelihood and the degree to which a component is affected if its antecedent fails), the criticality (how important this dependency is with respect to the goals and policies of an enterprise), the degree of formalization (i.e., how difficult it is to obtain the dependency) and many more. There is a need to add attributes to dependencies that allow them to be qualified more appropriately; and accordingly, a need to reflect these attributes in the dependency representation.","(f) Problem Determination Features: Further facilities for combining local dependency graphs, stored on every system, into a uniform dependency model are desired. In addition, these facilities should provide an API (application programming interface) allowing management applications to issue queries against the dependency model. These queries will be allowed to retrieve the entities that a specific service directly depends on, or to recursively determine a whole set of nodes, including sub-antecedents. The list of nodes received by the management application enables it to perform specific problem determination routines to check whether these services are operational.","The previous discussion shows that it is important to establish a mapping between three different stages of a service lifecycle:","(a) an (abstract) service being offered to customers, e.g., \u201cWeb Hosting,\u201d \u201cManaged Storage,\u201d \u201cIP Connectivity,\u201d \u201cManaged Database,\u201d etc.;","(b) the implementation of a service, i.e., the product(s) being used for providing the service, e.g., \u201cIBM Universal Database version 7.1,\u201d \u201cWebSphere Application Server version 3.2;\u201d and","(c) the running instance(s) of an implementation, i.e., the process or task, e.g., \u201cdb2 daemon,\u201d \u201cnfs daemon.\u201d","While the task of individually obtaining information available at every single stage is feasible, the combination of the three stages into a uniform dependency model is challenging and has not been done in previous work. In addition, there is a need for establishing an efficiently computable dependency model that addresses the requirements of scale, dynamics and heterogeneity of the underlying environment while eliminating the need for human interaction and maintenance of dependency data.","As will be illustrated below in the context of the figures, the present invention addresses these and other needs. That is, the present invention has features which compute runtime dependencies (a \u201cdependency model\u201d) between components of a distributed system on behalf of a management application. The invention offers a generic and uniform approach for retrieving dependency information from computer systems that provide a mechanism for retrieving configuration information of individual computer systems or that provide such data in a machine-readable format.","One benefit of the aforementioned system is that a large amount of application\/service management information can be obtained from these computer systems without having the need to instrument individual applications\/services. However, if such application\/service instrumentation is available, it can be used by the present invention.","The execution of the system described by the present invention may be triggered either by a specific (management) application (such as: impact analyzer, root cause analyzer), a network management platform (such as IBM\/Tivoli NetView, HP OpenView or Aprisma Spectrum) or a management application based on traditional network management systems and platforms.","The present invention provides, inter alia, features for:","(a) observing performance degradations and outages of subscribed services;","(b) tracking down the root cause of the problem by traversing the different layers of the dependency model from the top to the bottom (since various services may be outsourced to other service providers, this (recursive) traversal of a dependency model crosses domain boundaries); and","(c) analyzing the impact of a service outage by navigating the dependency model from the bottom to the top.","The invention combines dependency information that is available during the lifecycle of an application or service (i.e., from the design to deployment, installation and runtime stages of an application\/service). This information is kept within the following models:","(a) Functional Model: In a preferred implementation, the functional model defines dependencies between different generic services (database service, name service, web application service, connectivity service, etc.). The functional model does not describe client\/server relationships within a specific service. In addition, the functional model neither takes into account which concrete products have been chosen to implement the services nor their actual configuration. The functional model establishes the principal constraints to which the other models (described below) are bound, i.e., further models may refine the dependencies defined in the functional model with respect to a concrete system infrastructure but should not introduce new dependencies between service categories. The model is very compact and generic and is preferably stored on the managing system.","(b) Structural Model: In a preferred implementation, the structural model contains the detailed descriptions of software components that realize the services defined in the functional model. The structural model provides details captured during the installation\/deployment phase and complements the functional model by taking the software inventory of concrete systems into account. The structural model provides information about which services are installed and configured on a specific system and, for every service, whether the system operates in a client or a server role. The potentially high numbers of systems and services make it difficult to track these dependencies from a remote location. It is thus desirable to store this model close to or at the managed resources.","(c) Operational Model: In a preferred implementation, when software packages get instantiated and bindings between services and applications are established, the operational model of dependencies is created. The high degree of dynamics of this model and large number of involved systems places a limitation on the extent to which the complete model can be instantiated and stored. It is not practical to define and store such a model, rather, the model has to be computed dynamically and stepwise. The operational model is therefore computed \u201con demand\u201d and relies on the functional and structural models.","As is to be expected, the amount of dependencies and their dynamics are extremely high in large-scale distributed systems. The features of the present invention keep their impact on the distributed system (in terms of resource and bandwidth usage) as small as possible and leave as many configuration options that might affect the performance up to the user. Examples for this are: the time intervals for retrieving an updated dependency model, the range of the systems whose dependencies should be tracked, the depth of the dependency model (only services immediately affected versus transitive closure for a given service versus whole service hierarchy).","The present invention preferably exploits the following characteristics of dependency information:","(a) Dependencies between different services are layered. Furthermore, their dependency graph is directed and acyclic. The latter statement also reflects experiences with IP-based networked services, such as DNS (Domain Name System), NFS (Network File System), DFS (Distributed File System), NIS (Network Information System), etc., but there may be cases where mutual dependencies may occur in some systems. A pathological example for such a mutual dependency is a DNS server that mounts the file system in which its DNS configuration is stored via NFS from a remote system. While such a configuration is technically feasible, it reflects flaws in the system design because this leads to an unstable system whose bootstrapping might be non-deterministic and thus should be avoided. A dependency-checking application that discovers cyclic dependencies should issue a warning to an administrator.","(b) Every dependency is visible at a customer\/provider domain boundary and made explicit by means of SLAs. It follows that the number of observable dependencies is finite.","(c) Dependency models allow a top-down traversal of dependency chains.","(d) Dependencies between different systems (\u201cinter-system\u201d) are perceived as dependencies between the client and server parts of the same service. It is not possible that a client for service A issues requests to a server which provides a different service B.","One goal of the present invention is to retrieve information mainly from a few well-known\/well-defined places (e.g., system repositories) in order to achieve a maximum degree of independence from concrete service\/application instrumentation. In order to achieve this, the invention defines a minimal and sufficient amount of commonly available dependency information.","The invention comprises facilities for storing dependency models persistently or leaves this to the discretion of a management application or another service that uses the invention.","The invention is enabled to have a notion of history in order to detect and determine changes in the dependency model. In this case, the invention provides a publish\/subscribe interface for notifying software components that have previously registered for changes within the dependency model. Another possible use of the invention is to leave the detection of changes in the dependency model up to the discretion of a management application (or a change management service) to issue periodic calls to the invention in order to determine whether changes in the dependency model have occurred.","Furthermore, as will be illustrated herein below, the present invention provides techniques for identifying the root cause of a service outage and performing appropriate problem determination procedures. Finding the root cause of a service outage involves the traversal of the service dependency graph from the top to the bottom to identify the candidate services that may have experienced a problem, which is then propagated to the service in question. This traversal from the service where the outage or degradation has been observed towards its antecedents retrieves the entities that a specific service directly depends on, or recursively selects the complete set of nodes, including sub-antecedents, that this service requires to function properly. The list of nodes received by a root cause analyzer enables it to perform, in a second step, specific problem determination routines to check whether these services are operational. These problem determination procedures involve determining whether a service is functioning properly or not. The problem determination procedures may be carried out either:","(i) stepwise, i.e., the function test is carried out for every single service returned, or","(ii) combined, i.e., the whole list of antecedent services (or a subset of the operational model) is obtained first, and problem determination procedures are carried out for all of them simultaneously. The order in which these tests are carried out may be determined by precedence values computed from the strength of dependencies between services, which, in turn, are expressed as weights associated with such dependencies.","As mentioned, in order to determine whether a service is functioning properly, problem determination procedures may be used. Examples of problem determination procedures for distributed services and applications may include, but are not limited to:","(i) Process Inspection: For software applications that implement a service, one way to determine whether they are functioning properly is to verify if their processes (daemons) are running. This can be done in a non-intrusive way by inspecting the process table (or task list) of an operating system and does not require any instrumentation of the application. If the process(es) of an application are running, the application is considered to be in a healthy state.","(ii) Exercising an application is an intrusive (and more precise) way of determining whether the application is fully operational, i.e., running, and performing its business function. An \u201cexerciser\u201d is a transaction or command invoked from outside of the application that exercises the application in some fairly complete way to determine if it is really alive and able to deliver its functionality in a timely way. What is exercised is a function of the application itself. An analogy in networking is to test the connectivity via the ICMP (Internet Control Message Protocol) \u201cping\u201d command, which sends time-stamped IP (Internet Protocol) packets to a resource. These packets are returned by the resource and thus allow a system to determine whether the resource is alive and to measure the round-trip delay.","(iii) Heartbeats allow the application to demonstrate that it is alive and well. The application regularly announces that it is in a healthy operational state by generating events automatically and repeatedly. The system listening for heartbeats must understand that if the timeout period expires between the heartbeat events then the application may not be functioning correctly.","(iv) Status indicators are specific management variables of an application that reflect the current status of an application implementing a service. Querying one or more status variables indicates the overall health of a service. However, this approach requires the application to be instrumented appropriately by exposing this information to the outside.","Further, the root cause determination methodology of the invention may be performed for one or more subject components substantially concurrently (e.g., for one component at a time, or for multiple components in parallel). At least a portion of results of the root cause determination methodology of the invention may be persistently stored, however, such results may not be persistently stored. Still further, a history of results associated with the root cause determination methodology of the invention may be maintained. Such history may be used to derive heuristics for subsequently determining the sequence of steps for determining the root cause. For example, a ranking may be established, from the history, of the most common outages and the next time a root cause analysis is invoked, the component that has been failing the most in the past is checked first.","Given the above realizations made in accordance with the present invention and general features associated with the present invention, the remainder of the detailed description will provide an illustrative explanation of techniques for implementing such realizations and features in the context of .","Referring initially to , a block diagram illustrates an example of an electronic commerce system in the form of a client-server application architecture with which the features of the present invention can interact to produce information. The architecture of  will be described below to illustrate how such an architecture may handle a transaction in the absence of the techniques of the invention.","As depicted, a client system  is used to initiate a request, for example via keyboard. Requests, however, could be initiated by any conventional means such as by mouse click, voice command, bar code swipe, etc. Examples of the client system  are personal computers, kiosks, data entry terminals, scanners, telephones, pagers, handheld or wearable devices, wireless devices, personal digital assistants, network-enabled watches, etc.","The request is acted upon locally where the request is formulated and forwarded to a web application server  over a network  and by passing through one or many network access  devices. An example of the network  and communication protocol are socket-based communications riding on a TCP\/IP (Transmission Control Protocol\/Internet Protocol) transport across a local area network (LAN) that is connected by network access  devices such as routers and switches to a wide area network (WAN) containing many switching locations that create a virtual circuit to a service provider and eventually to a web application server . Examples of a web application server  are high-end personal computers, RISC-based PowerPC's, UNIX-based workstations, minicomputers or mainframe computers running software fielding requests from clients and distributing the requests to appropriate back-end database servers when appropriate.","For illustrative purposes, an electronic commerce transaction initiated within a web browser (running on the client system ) to purchase an item using the Internet will now be described. It is to be understood that the techniques of the invention may work with any form of transaction. Examples of web application servers include, but are not limited to, those available from IBM Corporation under the trademark WEBSPHERE, from BEA Systems, Inc. under the trademark WEBLOGIC, or from Lotus under the trademark LOTUS DOMINO SERVER.","In the example transaction, the business logic of the web application server  processes the incoming request and provides authentication and\/or identification of the client system . Once the business logic implemented by the web application server  determines that the client may proceed with the purchase, it communicates another request via a network  to a database server  to decrement the inventory. The database server  processes the request, accesses its database  and prepares a response to the web application server . Examples of database servers include, but are not limited to those sold by Microsoft under the trademark SQL\/SERVER or TRANSACTION SERVER and by IBM Corporation under the trademark DB2 UNIVERSAL DATABASE SERVER.","The web application server  receives the response from the database server  and returns it via the network  to the client system . The client system  then processes the response to format it for display and presents the response for the transaction initiator to review.","An administrator  observes the various software and hardware components, through which the business transaction is processed, located at the site of the service provider to determine if they function properly. In case of an outage  occurring at the database , such as a corrupted tablespace or a failure of the database runtime system, the task of the administrator  is to locate the cause of the outage, correct the problem and verify if the overall system is functioning properly again. It is to be understood that the invention is intended to operate with any form of outage or performance degradation.","The administrator  interacts with the software and hardware components either directly or through a management system that processes the administrative information (such as status and health data) exposed by software and hardware components at a well-defined management interface. In either case, it is important to note that the hardware and software components are perceived by the administrator as isolated resources and not as being part of an overall system serving a specific business purpose.","In particular, errors occurring in one component may not be noticed because the administrator does not become aware of them due to lack of continuous monitoring. In addition, absent the techniques of the invention, no explicit information regarding the interdependencies between the various components is available to an administrator in a straightforward way. Thus, it is possible that an error within a component, which is not continuously monitored may go unnoticed until the failure propagates to a monitored component.","In case of the aforementioned database outage , an administrator may eventually only become aware of the outage if the web application server  is not functioning properly anymore (for example, the load on the web application server increases drastically because it continuously retries to connect to the database server , and is unable to complete the requests sent by the client system ). Thus, the administrator  would first examine the web application server , then determine if there is a network  connectivity problem and finally verify if the database server  is experiencing difficulties that might stem from an internal error in the database .","The client-server application architecture described above can be regarded as a precursor to an emerging computing environment referred to by IBM Corporation as an \u201cautonomic\u201d computing environment. P. Horn, \u201cAutonomic Computing: IBM's Perspective on the State of Information Technology,\u201d IBM Research, October 2001, the disclosure of which is incorporated by reference herein, defines autonomic computing as a comprehensive and holistic approach to self-managed computing systems with a minimum of human interference. The term derives from the body's autonomic nervous system, which controls key functions without conscious awareness or involvement. More specifically, one of the goals of autonomic computing is to automate some or all of the tasks an administrator  would typically carry out. Motivation for doing so is as follows.","As computing evolves, the overlapping connections, dependencies, and interacting applications call for administrative decision-making and responses faster than any human can deliver. Pinpointing root causes of failures becomes more difficult, while finding ways of increasing system efficiency generates problems with more variables than any human can hope to solve. The problem of identifying and tracking dependencies between different systems of an autonomic computing environment may be characterized in the following way. Since a system can exist at many levels, an autonomic system needs detailed knowledge of its components, current status, ultimate capacity, and all connections with other systems to govern itself. Those skilled in the art will appreciate that the present invention may be performed in an autonomic computing environment.","Referring now to , a block diagram illustrates a system for providing dependency management according to an embodiment of the present invention. More specifically,  depicts a dependency management system that addresses the aforementioned issues. The system comprises four layers (application layer , service layer , middleware layer  and resource layer ) and an administrator graphical user interface  by which an administrator  interacts with the system.","The lowest layer is the resource layer . The resource layer  comprises managed resources , a resource dependency repository  and a repository agent . Examples of managed resources  include, but are not limited to, physical and logical hardware components (examples of the former are hard disks, random access memory, central processing units, network adapters, channel controllers, etc.; examples of the latter are disk partitions, file systems, etc.) and software components (such as operating system, system services like print spoolers or name services, and end-user applications).","The resource dependency repository  contains the inventory of the hardware and software components of every managed resource  and the dependency information on a per-resource basis (i.e., the dependencies between the components within a managed resource ). The resource dependency repository  can be either co-located with every individual managed resource  or reside at a centralized location. The resource dependency repository  can be queried, updated and modified through a repository agent , which makes the information of the resource dependency repository  available to other components of the system.","The middleware layer  comprises a management communication infrastructure  such as the protocols and object request brokers by which the different components of the system exchange (management) information.","The service layer  comprises various generic management services  such as policy, event and directory, which can be used by a variety of management applications. A specifically important service is the dependency service , which retrieves information, both from the managed resources  and from the repository agent , and processes this information to establish an end-to-end dependency model of the overall resource environment. This model (or parts of it) is stored in the end-to-end dependency repository , according to the needs (e.g., caching for faster retrieval) of the dependency service . Note that the dependency service  is the only component in the described system that directly interacts with the end-to-end dependency repository .","It is to be appreciated that the above-mentioned dependency model and its parts may be generated in accordance with the techniques disclosed in the above-referenced and concurrently-filed U.S. patent application identified by Ser. No. 10\/241,162 entitled: \u201cMethods And Apparatus For Managing Dependencies in Distributed Systems,\u201d some illustrative details of which are provided herein below. However, other model generation techniques may be employed.","The application layer  comprises various management applications that use the generic management services  and\/or the dependency service . Examples of such management applications include, but are not limited to, fault manager , topology generator , impact analyzer , impact simulator  and root cause analyzer .","The root cause analyzer , as will be described further herein, determines the root cause of an outage (i.e., the component that initially caused the outage) based on traversing the dependency model (provided by the dependency service ) from a component affected by an outage towards its antecedents.","The impact analyzer  determines the impact of an outage (i.e., the components that are likely to be affected by the outage) based on traversing the dependency model (provided by the dependency service ) from a component experiencing an outage towards its dependents. The impact analyzer may employ the techniques disclosed in the above-referenced and concurrently-filed U.S. patent application identified by Ser. No. 10\/241,214 entitled: \u201cMethods And Apparatus For Impact Analysis and Problem Determination.\u201d However, other impact analysis techniques may be employed.","The impact simulator , based on the impact analyzer , allows an administrator  to carry out a \u201cwhat-if\u201d analysis by simulating the effects of an outage of a specific component on the overall system. This enables the provisioning of appropriate failover solutions. The impact simulator may employ the techniques disclosed in the above-referenced and concurrently-filed U.S. patent application identified by Ser. No. 10\/241,397 entitled: \u201cMethods And Apparatus For Dependency-based Impact Simulation and Vulnerability Analysis.\u201d However, other impact simulation techniques may be employed.","The fault manager  performs appropriate \u201csanity checks\u201d or tests on components that have been identified either by the root cause analyzer  or the impact analyzer  as candidates for a failure. That is, the fault manager can perform such tests upon the direction of the root cause analyzer  or the impact analyzer  (i.e., serve as an interface for these modules), and report back results thereto. However, the root cause analyzer  or the impact analyzer  can perform their own tests independent of the fault manager.","It is to be understood that the fault manager is preferably comprised of a collection of application-specific or resource-specific tools that allow a determination to be made whether the component that is being tested is working properly or not. Thus, after testing the component with a related tool, the fault manager may return a message indicating whether the component \u201cworks\u201d or \u201cdoes not work.\u201d These tools may be automated and\/or manual. By way of one automated example, a so-called \u201cping\u201d program checks network connectivity. If the subject remote system answers to a ping, it is online and its network protocol stack (and all the underlying hardware, e.g., network adapter, cables, intermediate network components, etc.) works. If the remote system does not answer, it is known that at least something is wrong and another (set of) tool(s) may be employed to determine the problem. Thus, the fault manager may employ the ping program, as well as any number and type of other tools needed to test components of the distributed computing environment (e.g., heartbeat detection, status indication, etc.).","The topology generator  establishes (a subset of) the overall topology of a distributed system, comprising a vast amount of highly dynamic components, such as web applications, database instances and transactions. An example for using the topology generator  is to display the components of a distributed system that are involved in fulfilling the requests of a specific client system . The dependency model (or parts of it) is stored in the topology database , according to the needs (e.g., caching for faster retrieval) of the topology generator . Note that the topology generator  is the only component in the described system that directly interacts with the topology database . The topology generator may employ the techniques disclosed in the above-referenced and concurrently-filed U.S. patent application identified by Ser. No. 10\/241,189 entitled: \u201cMethods And Apparatus For Topology Discovery and Representation of Distributed Applications and Services.\u201d However, other topology generation techniques may be employed.","Referring now to , a block diagram is shown illustrating a generalized hardware architecture of a computer system suitable for implementing the various functional components\/modules of a system for providing dependency management as depicted in the figures and explained in detail herein. It is to be understood that the individual components of the dependency management system, namely, components associated with the graphical user interface , the application layer , the service layer  and the middleware layer  (), may be implemented on one or more computer systems having an architecture as shown in . The other components shown in , e.g., the components associated with the resource layer , may also be implemented on similar computer systems.","As shown, the computer system may be implemented in accordance with a processor , a memory  and I\/O devices . It is to be appreciated that the term \u201cprocessor\u201d as used herein is intended to include any processing device, such as, for example, one that includes a CPU (central processing unit) and\/or other processing circuitry. The term \u201cmemory\u201d as used herein is intended to include memory associated with a processor or CPU, such as, for example, RAM, ROM, a fixed memory device (e.g., hard drive), a removable memory device (e.g., diskette), flash memory, etc. In addition, the term \u201cinput\/output devices\u201d or \u201cI\/O devices\u201d as used herein is intended to include, for example, one or more input devices (e.g., keyboard) for entering data to the processing unit, and\/or one or more output devices (e.g., CRT display and\/or printer) for presenting results associated with the processing unit.","It is also to be understood that the term \u201cprocessor\u201d may refer to more than one processing device and that various elements associated with a processing device may be shared by other processing devices.","Accordingly, software components including instructions or code for performing the methodologies of the invention, as described herein, may be stored in one or more of the associated memory devices (e.g., ROM, fixed or removable memory) and, when ready to be utilized, loaded in part or in whole (e.g., into RAM) and executed by a CPU.","Referring now to , a block diagram illustrates a functional dependency model of services according to an embodiment of the present invention. More specifically,  depicts a functional application dependency graph between various components in an electronic commerce system such as the one depicted in . This functional dependency model represents both the functional components of a distributed system and their dependencies. Thus, the model defines dependencies between generic services, which are considered atomic from a business perspective. This implies that the functional model is not concerned with dependencies occurring within a business service. Such a decomposition makes sense in the scope of a specific product being used to implement the service and will be discussed in more detail with reference to .","Dependencies between components are depicted as arrows. An arrow always points from the dependent to the antecedent. Functional components are the (sub-) services that a service provider needs to deploy for providing an end-to-end service to a customer, the latter being defined in a service level agreement. The functional model focuses on the design of an end-to-end service and abstracts from the details of an end-to-end service's technical realization, such as the products being used for the service offering, their location (local or remote system), the provider domain (i.e., whether the provider itself outsources some of its services to another service provider, transparent to the customer), etc.","As shown, an e-business application  service depends on a web application service  for hosting the business logic. In order to function properly, the web application service  requires two further services. The static content of the electronic commerce website is provided by a web service , while a back-end database service  stores the dynamic content (such as product descriptions, user and manufacturer data, shopping carts, user profiles and preferences, payment information, etc.) of the e-business application  being offered to a customer. The web service  depends, itself on two services, namely, the name service  for mapping host names to IP addresses, and the IP service  for network connectivity.","Recall that dependency relationships are transitive, i.e., the dependent of a given component requires, in addition to the component itself, also the components' antecedent(s). Consequently, in addition to the IP service  and the database service , all the depicted services require the presence of an operating system (OS)  service. For the sake of brevity, the dependency relationships of an OS  on hardware components is not depicted, although they are present in a functional model.","Referring now to , a block diagram illustrates a structural dependency model of services according to an embodiment of the present invention. More specifically,  depicts a structural application dependency graph between various components in an electronic commerce system such as the one depicted in .","This structural dependency model extends the functional model () in the following ways. The structural dependency model deals with the implementation of a business service and is focused on concrete products and their logical (modules, components) and physical (files, shared libraries) architecture. The structural dependency model captures the detailed descriptions of software components, i.e., the system inventory, which is usually recorded in the various system repositories or in well-defined places, e.g., the configuration files of a managed resource .","Note that although the structural model deals with the components of a single system, it may maintain references to services and applications hosted by other systems, because the configuration files located on the system may contain this information. Examples of system repositories include, but are not limited to, the IBM AIX Object Data Manager (ODM), the Linux Red Hat Package Manager (RPM) or the Microsoft Windows Registry. Information relating to software components is typically captured during the installation and deployment of a software package. In addition, the structural model contains the dependencies between the various system components, depicted as arrows. For the sake of clarity, the names of the business services are written without quotes, while the names of the elements of the structural model are written with quotes in .","The system with the fully qualified domain name wslab8.watson.ibm.com  hosts the following components: the e-business application (a business service defined in the functional model), which is implemented as storefront servlets , the latter encapsulate the business logic of the application. The web application service is implemented by IBM WebSphere version 3.5 , while the web service is realized by the IBM HTTP Server version 1.3.6 . The IP service is implemented by the default IP protocol stack , the operating system (OS) is Win(dows) NT version 4 .","The system with the fully qualified domain name rslab2.watson.ibm.com  hosts the following components: a database service implemented by (IBM) DB2 Universal Database (UDB) version 5.2 , and an operating system, here (IBM) Advanced Interactive Executive (AIX) version 4.3.3 .","Referring now to , a block diagram illustrates a service lifecycle addressed by functional, structural and operational dependency models according to an embodiment of the present invention. More specifically,  depicts the relationships between a functional model  and a structural model , described above, and introduces a third dependency model, an operational model . These three models enable the invention to track the services during their whole lifecycle, i.e., from the design stage to the installation and deployment stage, to the operational or runtime stage.","As explained above, the functional model  relates to the design of the business services and is thus captured at the design time of a business system. Once the system described by the functional model  becomes instantiated or deployed (step ), the structural model  is established. The operational model  is created when the various components of the structural model  become instantiated (step ) and when runtime bindings between them are established. The operational model represents the characteristics of the previously described models at runtime. Several scenarios that illustrate the aforementioned concepts will now be described.","The web application service  is implemented by IBM WebSphere ; one or more instances of the latter are referred to as websphere-daemon . Here, the web (or WWW) service  is implemented by two products, namely, Apache 1.3.4  and Lotus Domino . The running instances of these products can be identified as http daemons \u201chttpd\u201d . The database service  is implemented by two products, namely, Oracle v7  and DB2 UDB ; however, no instances of Oracle v7  are active because no server processes are visible in the operational model . In contrast, four instances of DB2 UDB  are running, as can be seen from the presence of four DB2 daemons \u201cdb2d\u201d  in the operational model . The name service  is implemented by BIND version 5.6 ; the running instance of BIND can be observed as \u201cnamed\u201d  in the operational model .","Note that the dependencies are propagated from the functional to the structural and the operational model. This is necessary because it is not possible to determine from a running application instance which other application instance(s) it requires to function properly.","Due to the short-livedness of some application instances, the operational model  is highly dynamic and potentially very large. In contrast to the functional and structural dependency models, the operational model  is not stored in a repository or a database, but computed on demand and to the extent needed.","Referring now to , a block diagram illustrates relationships between functional, structural and operational dependency models according to an embodiment of the present invention. More specifically,  depicts the details of the data template used for the three dependency models and the means for tying these models together by an example. The example details the template and its associated values for describing the name service during its lifecycle.","The functional template , used for the functional model  contains the \u201chostName\u201d (the unique name of the computer system that hosts the service), the \u201cserviceName\u201d (name of the service) and the \u201ccomponentType\u201d (the role in which this service acts, i.e., client or server). With this information, a service can be uniquely identified within a distributed environment. However, further fields containing descriptive data (such as a description of the purpose of the service, the customer that subscribes to this service, etc.) may be added without departing from the spirit of the present invention. Finally, the \u201cAntecedent\u201d field contains the service(s) this service requires for proper functioning.","The structural template , used for the structural model , contains all the fields of the functional template , which allows to link the functional template  with the structural template  in order to navigate from the functional model  to the structural model , and vice-versa. In addition, the structural template  contains the \u201ccomponentName\u201d (the name of the product component), an \u201cidentifier\u201d (a globally unique name for identifying the component), the \u201cversion,\u201d \u201crelease\u201d and \u201cmodification\u201d (e.g., maintenance or patch\/fix level) numbers, the \u201cinstallState\u201d (indicating whether the component has been successfully and completely installed) and \u201cprocessName\u201d (the name of the process(es) that identify this product component at runtime). Furthermore, the \u201cAntecedent\u201d field lists the component(s) this component requires to be operable.","The operational template , used for the operational model , contains the fields \u201chostName\u201d (the unique name of the computer system that hosts the service) and \u201cprocessName\u201d (the name of the process(es) that identify the product component at runtime). These two fields link the structural template  with the operational template  in order to navigate from the structural model  to the operational model , and vice-versa. In addition, the operational template  contains the fields \u201coperState\u201d (the operational state of the process, i.e., running, interrupted, zombie, etc.), \u201cportNumber\u201d (the number of the TCP\/UDP port by which an application can connect to the process), and, \u201cinstanceID\u201d (to distinguish the various application instances within the scope of a computer system).","The three dependency models are stored and computed at different places to achieve a maximum degree of efficiency. The functional model  is gathered and stored at the management system , i.e., the central point of control by which the administrator  interacts with the distributed environment. Some of the reasons for this choice are as follows. As seen in the descriptions of  and , the functional model  is fairly compact because the amount of possible business services is limited. In addition, the functional model is not subject to overly frequent changes. The functional model is defined at the time when a business service is provided to a customer and remains unchanged until the service offering period ends. Since the administrator  is responsible for setting up and updating the functional model , it is a natural choice to keep it close to the management system .","As mentioned in the description of  and , the structural model , in contrast, captures the detailed descriptions of software components, i.e., the system inventory, which is usually recorded in the various system repositories or in well-defined places, e.g., the configuration files of managed resource . Consequently, it is both large sized (the content of a system repository tends to be between several hundred kilobytes and up to a few Megabytes) and also subject to frequent changes. Therefore, keeping the structural model  of a system at the managed resource , itself, eliminates both the communication overhead for updating the model and the need for vast amounts of storage that would occur if the structural models  of all managed resources () is stored at a centralized place.","The operational model  has been described in  as very dynamic and also extremely large because it covers potentially multiple instances of every application present on the computer systems of the distributed environment and the dependency relationships between them. Given the fact that current data centers of Internet\/Application\/Storage Service Providers and outsourcers consist of several thousands of computer systems with each hosting close to 100 applications and system services, an operational model comprising all the currently instantiated applications and their dependencies may be impractical. Thus, a practical approach is to compute the relevant parts of the operational model on demand (step ). This is the purpose of the dependency service .","Referring now to , a block diagram illustrates components involved in analyzing and computing the root cause of a service outage based on dynamic information technology (IT) service dependencies according to an embodiment of the present invention. More specifically,  depicts the data flows between the various components used for analyzing and computing such a root cause. It is assumed that the managed resources  are able to provide XML (Extensible Markup Language) descriptions of their system inventory, configuration files and their various dependencies. However, it should be noted that any data description format may be used in accordance with the invention. The details on how this information can be acquired are as follows.","One straightforward way is to provide appropriate instrumentation within the system and its applications and services. This information is described in flat XML files  and made available to the other components of the system through a web server .","Alternatively, the dependency service  makes use of information stored in system repositories  for generating appropriate service dependency information. This information is made available to the other components of the system through a web server .","Third, the managed resources  expose their information by means of an instrumentation agent, called CIM (Common Information Model, which is a standardized management framework) provider , which interacts with a CIM Object Manager (CIMOM) , as proposed by the Distributed Management Task Force (DMTF). The CIMOM then exposes the necessary information to the interested components.","In the center of , various management services, being part of the service layer , are depicted. These are: a name service , a trader service , an event service  and the dependency service . The dependency service , triggered by queries of the administrator  through either the root cause analyzer , its management system or any management application located in the application layer  using a communication protocol (e.g., Java Remote Method Invocation (RMI)), processes them and sends the results back to the root cause analyzer  which, in turn, forwards the results for further processing to the administrator . The main tasks of the dependency service  are as follows:","(a) Interacting with the management system or any management application located in the application layer . The management system issues queries to the application programming interface (API) of the dependency service ().","(b) Expose a \u2018drill-down\u2019 method that, upon receiving the identifier of a service, returns:\n\n","(c) Provide a \u2018drill-up\u2019 method with the same facilities, targeting the dependents of the service.","(d) Additional methods for gathering and filtering information for classes and properties of managed objects are present.","(e) Obtaining the dependency information from the managed resources  by issuing queries over http (HyperText Transport Protocol) and applying filtering rules (as specified by the administrator ) to it.","(f) Combining the information into a data structure that is sent back to the management system as XML document.","As mentioned above, due to its fully distributed nature, the invention aims at keeping the load on every involved system as low as possible. The invention decouples the management system from the managed resources  and encapsulates the time consuming filter and join operations in the dependency service , which can be replicated on various systems. It is therefore possible to achieve a maximum level of parallelism for query operations, since the selection of an instance of the dependency service  can be done flexibly by the management system.","Another important advantage is that the (very large and highly dynamic) operational model  is not stored at a specific place but computed on demand in a stepwise manner. The different parts of the structural model  are stored at the managed resources . The management system therefore always receives the most recent information but is still free to store it according to elaborate caching policies.","Referring now to , a block diagram illustrates components of a root cause analyzer according to an embodiment of the present invention. As shown, a root cause correlator , which functions as a flow coordinator for the entire root cause analysis process, receives service problem reports  from the administrator , providing the name of the service and the host name where the problem has been observed or reported. The root cause correlator  interacts with the dependency service  in order to obtain a list of the basic services on which the problematic service depends. Examples of basic services would be: domain name service, IP connectivity service, etc.","The task of the dependency service  is to find the antecedents of the service in question, even if the e-commerce environment spans different managed domains . In order to deal with multiple domains, various (cascaded) instances of the dependency service  may work jointly together. In , the e-commerce environment is shown by the dotted rectangle. Typically, such environments contain one or more managed domains, eventually each with its own dependency database  and dependency service . The dependency service  returns the names and identifiers of the antecedents back to the root cause correlator , which then initiates further problem determination procedures to verify whether one or more antecedents experience difficulties. This can be accomplished via a number of approaches, some of which are illustrated below.","A first approach assumes the presence of an event monitoring and distribution function, provided by an event monitor . Examples of such event monitors include, but are not limited to HP OpenView Event Services and Tivoli Enterprise Console. The event monitor  receives events\/alerts related to resources within the e-commerce environment and forwards the ones, which are relevant to an event database . Some events are informational in nature or are related to errors that are fixed automatically by the domain management services. These are typically filtered out and not forwarded to the event database . In practice, the event monitor  may comprise of a hierarchical arrangement of multiple event monitors, one for each managed domain.","The main function of an event-service correlator  is to provide, for a given service or resource, a list of outstanding alerts associated with that resource or service. It does so by interacting with event monitors  and stores the events in the event database  for further retrieval. When a service returned by the dependency service  is one of the suspected root causes, the root cause correlator  uses the event-service correlator  to estimate the likelihood of this being the case by getting a list of events that may have been reported about the suspected service or resource. If there is an undesirable event, for example buffer overflow, the likelihood of this resource being a root cause is high.","The root cause correlator  also interacts with the dependency services  for each of the managed domains in order get a set of possible root causes that lie within that domain. The dependency service  interacts with domain dependency data , which is constructed during deployment and periodically updated during the operation phase of the e-commerce setup.","A second approach is to obtain the current status of a service or resource from a status monitor , which directly interacts with the services and verifies whether they are functioning properly or not (e.g., failed, not failed, degraded, etc.). As mentioned above, if the system incorporates a fault manager (as does the system of ), the status monitor may serve as the interface between the root cause analyzer and the fault manager so as to, among other advantages, make the root cause analyzer independent of any particular test procedure. The status monitor  may therefore serve as a single point of contact for the root cause correlator  to determine the health of the service in question.","In general, it can not be assumed that an external fault manager is always available. Since, however, the functionality of determining the status of a service is crucial for the root cause analyzer, this functionality must be present and is provided by the status monitor , which may extend the functionality offered by a fault manager. Thus, external fault managers may provide either:","(a) all the needed functionality (thus, the status manager will \u201cwrap\u201d the functions performed by the fault manager and adapt the interface to what the root cause correlator  expects;","(b) only a part of the functionality (e.g., testing of network connectivity only\u2014but no application and middleware status verification), thus the needed functionality must be provided by the status monitor; or","(c) no functionality at all; it is either not present or does not offer its functionality to other components through a programmatic interface. So while a human user may interact with the fault manager through a GUI (graphical user interface), no program (such as the correlator ) can use it.","Also note that a fault manager is meant to refer to a loose collection of system administration tools having completely different interfaces. The status monitor thus serves to integrate these various tools under a uniform interface. That is, the status monitor preferably operates to account for any mismatch between a root cause correlator which expects everything to be testable for status and the fault manager which may provide between 0 percent and 100 percent of this required functionality.","The root cause correlator  thus has two ways to determine whether a service is functioning properly or experiences a problem, i.e., the correlator can query the event-service correlator  for problem event reports relating to a service or directly look up the status of a service from the status monitor . The root cause correlator  is free to choose by which of these at least two means it determines the health of a service. Further, the root cause correlator  may choose to obtain information both from the event-service correlator  and from the status monitor .","After the root causes have been narrowed down to the smallest possible set of services and resources, the root cause correlator  returns this information  to the administrator .","Referring now to , a flow diagram illustrates steps for invoking a dependency service and performing root cause analysis on an operational model according to an embodiment of the present invention. More specifically,  depicts a methodology of invoking a dependency service (e.g., dependency service ), collecting its results, and applying root cause analysis to them. This methodology is initiated either by an administrator  or a management application being part of the application layer , as described in .","The methodology begins at block  and proceeds as follows. First, a business service is selected (step ), typically from the functional model, since an administrator is interested in the business services provided by the distributed system. Upon selection of a business service, the structural model is queried to provide a selection of hosts that are involved in the provisioning of the business service. This can be either done by locating the structural models present on every host of the distributed system, or (for efficiency purposes) by querying a (periodically updated) service\/host lookup table stored at the management system, which contains a mapping between the services and hosts present in the distributed system. The administrator then selects a host at his discretion (step ).","In addition, the administrator composes a query (step ). Examples of query parameters include, but are not limited to, the direction of the traversal (towards the service dependents, or towards its antecedents), the depth of the traversal (e.g., only the immediate antecedents\/dependents; the overall possible antecedents\/dependents, i.e., the complete transitive closure of the operational model; only between the m-th and n-th layers of the operational model), filtering criteria related either to the presence of attributes or to their values.","The fact that the order of the steps for selecting service (step ), host (step ) and the options for composing the query is prescribed here, emphasizes the \u201cservice-centric\u201d approach (versus the \u201chost-centric\u201d approach of existing art) of the present invention. However, one having skill in the relevant art will recognize that modifications in the order of steps (steps ,  and ) may be made without departing from the spirit and scope of the present invention.","Examples of such modifications are: to offer the user (e.g., by means of a graphical user interface) the choice of performing the three steps of the selection process in an arbitrary order; allowing at first the selection of a host and then looking up the services present on that host by means of querying the structural model, thereby restricting the possible service candidates for selection.","After the service and host selection and the composition of the query, the dependency service is invoked (step ) with these parameters. Note that the mode of invocation can be either synchronous (i.e., blocking the invoker until the results are returned by the dependency service) or asynchronous (thus allowing the invoker to perform additional tasks during the computation).","The dependency service computes the appropriate part of the operational model and, depending on the mode of invocation, either sends the results back to the invoker or notifies the invoker that the results are available. The invoker then collects the results and applies root cause analysis and appropriate problem determination procedures to them (step ). The methodology ends at block .","Referring now to , a flow diagram illustrates tasks of an administrator for creating and updating a functional dependency model according to an embodiment of the present invention. This is necessary either if new (business) services are deployed and offered, or changes are applied to an existing model, or existing (business) services are withdrawn from an offering.","The methodology begins at block  and proceeds as follows. An administrator or a management application evaluates whether a new business service should be added or an existing service is to be deleted (step ). If this is not necessary, the methodology proceeds directly to block . Otherwise, in step , the service and its description are entered in (or removed from) the template  of the functional model, which has been described in .","Then, in step , the service dependencies, i.e., its relationships regarding its antecedents, need to be added to (or removed from) the template  of the functional model. In case of a deletion, note that the dependencies from the service dependents need to be adjusted to point to the antecedents of the service that is to be removed. This may involve checking for eventual duplicate descriptions within the dependencies of the antecedents. Finally, the updated functional model is stored in the repository of the management system (step ). The methodology ends at block .","Referring now to , a flow diagram illustrates steps of updating a structural dependency model by installing or removing hardware\/software components on a computer system according to an embodiment of the present invention. This is necessary either if new components are deployed and installed on a host, or existing components are removed from the host.","The methodology begins at block  and proceeds as follows. If new hardware components are installed\/removed, the verification and adjustment of their dependencies is usually performed by the operation system and is thus not described further here. Instead, the following description focuses on the task of adding\/removing software components. An administrator or a management application performing software distribution and installation evaluates whether a new software component should be added or an existing software component is to be deleted (step ). If this is not necessary, the methodology proceeds directly to block . Otherwise, in step , the software components' descriptions are entered in (or removed from) the template  of the structural model, which has been described in . Then, in step , the software components' dependencies, i.e., its relationships regarding its antecedents, needs to be added to (or removed from) the template  of the structural model.","In case of a deletion, note that the dependencies from the software components' dependents need to be adjusted to point to the antecedents of the software component that is to be removed. This may involve checking for eventual duplicate descriptions within the dependencies of the antecedents. Finally, the updated structural model is stored in the resource dependency repository of the host (step ). The methodology ends at block .","Referring now to , a flow diagram illustrates performance of root cause analysis on an operational model according to an embodiment of the present invention. The methodology begins at block  and proceeds as follows. The system performing the root cause analysis on the operational dependency model is continuously listening for requests at a specific port of the host on which the system is executed, which is illustrated by the loop that connects step  with itself. This is the standard behavior for server processes (\u201cdaemons\u201d) that implement services, which can be invoked by applications at any time.","On reception of a request, the system extracts the input parameters from the request (step ). As mentioned in the description of , examples of input parameters include, but are not limited to, the names of the service and the host in question, the direction of the traversal, the depth of the traversal, filtering criteria related either to the presence of attributes or to their values. These input parameters are then used to invoke the computation of the operational model, which is invoked in step .","In addition, the results of the computation, i.e., the operational model, are gathered. The root cause analysis is then performed on the operational model (step ). The results of the root cause analysis are returned to the invoking application, in accordance with the mode of invocation specified at the time of the invocation (step ). After this step, any allocated resources of the host on which the system is running are released (step ). Examples of host resources include, but are not limited to, memory, disk space or CPU registers. Finally, the system returns back to its initial stage and listens for subsequent incoming requests (return to step ).","Referring now to , a flow diagram illustrates performance of root cause analysis on antecedents of a service according to an embodiment of the present invention. The methodology begins at block  and proceeds as follows.","First, the names of the targeted service and the host are obtained (step ). These parameters are provided by the invoking management application, which obtains these parameters either directly from the administrator or from an event message that arrives at the management console. In addition, the search criteria according to the status of the antecedents are specified. They indicate whether the system should return the services that have encountered a problem (\u201cdefective\u201d) or the services that perform well. Usually, a management application is interested in the former, i.e., the defective services. Furthermore, the search path is specified. A management application can be either interested in the direct antecedents of a service (search path length=1), the whole set of services the service directly (or indirectly) depends on (search path=recursive), or the lowest level of the antecedents, i.e., the base services that a service depends on (search path=max).","Then, the computation of the operational model is performed by the dependency service, according to the parameters \u201cService Name,\u201d \u201cHost Name,\u201d \u201cAntecedent status,\u201d \u201csearch path\u201d (step ). Next, in step , the results, i.e., the list of antecedent service elements (\u201cCandidate List\u201d), are obtained from the dependency service.","The following steps are performed until the list of candidate service elements is empty ():","The first service element of the candidate list is selected (step ) and checked to determine whether it is functioning properly (step ). The steps of this status check procedure are described in detail in . If the service element in question is functioning properly (status=\u201cOK\u201d), it is added to the list of working service elements, i.e., an \u201cOK\u201d list (step ). If, however, it turns out that the service element is experiencing a problem, it is added to the \u201cdefective\u201d list (step ). Finally, the service element in question is removed from the candidate service elements list (step ) and the methodology proceeds back to block step .","If the list of candidate service elements is empty, the methodology then proceeds directly to step , where either the list of working service elements or the list of defective service elements is returned to the invoker. The results content depends on whether the invoker has been asking in step  for working or defective services. The methodology ends at block .","Referring now to , a flow diagram illustrates steps for determining a status of a service according to an embodiment of the present invention. More specifically,  illustrates interactions of the root cause correlator  with the event-service correlator  and the status monitor , depicted in . The methodology begins at block  and proceeds as follows.","First, the name of the targeted service element is obtained (step ). This problem determination problem is described from the perspective of checking the status of a single service element, as may be done by the root cause correlator . It is to be understood that this procedure is repeated for every service in question. It is to be further understood that this procedure is carried out in step  of .","Also, with respect to step , the names of the targeted service elements are provided by the invoking management application, which obtains these parameters either directly from the administrator or from an event message that arrives at the management console.","Then, the root cause correlator  queries the event-service correlator  for the presence of events relating to the service in question (step ). These events indicate whether any problems with this service have been observed. If this is the case, the service element is flagged as \u201cdefective\u201d (step ), and the result is returned to the invoker (step ).","If step  yields that no fault events have occurred for this service, it is necessary to perform further work to determine the status of a service. This is done by querying the status monitor  for the status of the service (step ). The task of the status monitor  comprises providing a uniform interface to status information for every service in the distributed system, regardless of how the status of the service is determined.","As mentioned above, four illustrative ways of determining the status of a service may comprise: (i) process inspection; (ii) exerciser; (iii) heartbeat; and (iv) status indicators. If the query (step ) to the status monitor  yields that the service in question is functioning properly (status=\u201cOK\u201d), the service element representing the service is flagged as \u201cOK\u201d (step ). In any case, the result is returned to the invoker (step ). The methodology ends at block .","Referring now to , examples are depicted of root cause analyzer application programming interfaces (APIs) according to an embodiment of the present invention. The table includes base APIs that can generate, send and request receipt of appropriate operational models for a given service and host name. Those skilled in the art will appreciate that the APIs can use one or more parameters (not shown) to identify characteristics (specified in the functional description) used by the APIs.","Specifically, a \u201cgetDirectAntecedents(parameters)\u201d API retrieves direct antecedents, regardless of their current status, of a service located on a specific host. The \u201cgetAntecedentsRecursive(parameters)\u201d API performs a recursive \u201cdrill-down,\u201d i.e., it retrieves all the antecedents of a given service (regardless of their current status), which is located on a specific host. It therefore returns all the services residing \u201cbelow\u201d a given service in the dependency hierarchy. The \u201cgetLowestAntecedents(parameters)\u201d API retrieves the lowest antecedents of a service located on a specific host. This method yields the services that do not have any antecedents themselves (i.e., they reside in the lowest layer of the dependency hierarchy of a given service).","The \u201cgetWorkingDirectAntecedents(parameters)\u201d API retrieves direct antecedents with status \u201cup\u201d of a service located on a specific host. The \u201cgetWorkingAntecedentsRecursive(parameters)\u201d API performs a recursive \u201cdrill-down,\u201d i.e., it retrieves all the antecedents with status \u201cup\u201d of a given service, which is located on a specific host. It therefore returns all the working services residing \u201cbelow\u201d a given service in the dependency hierarchy. The \u201cgetWorkingLowestAntecedents(parameters)\u201d API retrieves the lowest antecedents with status \u201cup\u201d of a service located on a specific host. This method yields the services that do not have any antecedents themselves (i.e., they reside in the lowest layer of the dependency hierarchy of a given service).","The \u201cgetDefectiveDirectAntecedents(parameters)\u201d API retrieves direct antecedents with status \u201cdown\u201d of a service located on a specific host. The \u201cgetDefectiveAntecedentsRecursive(parameters)\u201d API performs a recursive \u201cdrill-down,\u201d i.e., it retrieves all the antecedents with status \u201cdown\u201d of a given service, which is located on a specific host. It therefore returns all the failed services residing \u201cbelow\u201d a given service in the dependency hierarchy. The \u201cgetDefectiveLowestAntecedents(parameters)\u201d API retrieves the lowest antecedents with status \u201cdown\u201d of a service located on a specific host. This method yields the services that do not have any antecedents themselves (i.e., they reside in the lowest layer of the dependency hierarchy of a given service). This API is particularly useful if a user or management application wants to determine quickly whether any \u201cfundamental\u201d service (e.g., network connectivity service) has failed without having to verify the status of \u201cintermediate\u201d services (such as name services).","Although illustrative embodiments of the present invention have been described herein with reference to the accompanying drawings, it is to be understood that the invention is not limited to those precise embodiments, and that various other changes and modifications may be made by one skilled in the art without departing from the scope or spirit of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 15"}]},"DETDESC":[{},{}]}
