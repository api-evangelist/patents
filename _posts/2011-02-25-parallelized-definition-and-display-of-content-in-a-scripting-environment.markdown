---
title: Parallelized definition and display of content in a scripting environment
abstract: Various content may be defined and display in parallel in a scripting environment. The scripting language may not wait for error checking or reporting before proceeding to updating the content definition. In one embodiment, no error checking or reporting may be performed. Content may be defined by setting graphics states while content may be displayed by validating the graphics states and submitting validated states to a GPU. The defining and display of content may be performed asynchronously.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08786619&OS=08786619&RS=08786619
owner: Adobe Systems Incorporated
number: 08786619
owner_city: San Jose
owner_country: US
publication_date: 20110225
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","Description of the Related Art","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS","EXAMPLE SYSTEM","CONCLUSION"],"p":["This disclosure relates generally to graphics interfaces, and more specifically, to graphics application programming interfaces (APIs).","The interface between a central processing unit (CPU) and an attached graphics processing unit (GPU) is traditionally managed using a client-server architecture. Actions performed on the client are converted to requests on the GPU server. Consequently, server requests may cause a return of information to the client. For such requests, synchronous APIs in the client must block further requests until results are available from the server. In turn, the server also spends a significant amount of time idle waiting for subsequent client actions.","This disclosure describes techniques and structures that facilitate parallelized definition and display of content in a scripting environment. In one embodiment, a graphics state may be set. A task corresponding to the set graphics state may be submitted to a GPU. Without waiting for indication of successful completion of the task by the GPU, another graphics state may be set. In one embodiment, the scripting environment may provide a single-threaded programming model. Before submitting the task, the set graphics state may be validated. If the graphics state fails validation, the task may be skipped and another set graphics state may be read. If the graphics state passes validation, the task and graphics state may be submitted to a GPU to perform the draw task corresponding to the graphics state. In one embodiment, errors may not be checked or reported. Likewise, in one embodiment, validation failure may not be reported; instead, in such an embodiment, the draw task associated with the graphics state that failed to validate may be skipped.","In one embodiment, setting graphics states, validating graphics states, and\/or performing draw tasks may be performed in parallel. Thus, subsequent graphics states may be set before a draw task is complete. Graphics states may be set in a buffer, and graphics states may be read, for example, for validation and transfer to the GPU, from the same buffer. The buffer may allow for simultaneous reads and writes. In one embodiment, a debug mode may be selected in which, in serial, a graphics state may be set, a corresponding draw task may be performed, and error checking and reporting may be performed. Accordingly, the debug mode may allow serial and sequential definition and display of content.","While the disclosure is described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that the disclosure is not limited to the embodiments or drawings described. It should be understood, that the drawings and detailed description thereto are not intended to limit the disclosure to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present disclosure. The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description. As used throughout this application, the word \u201cmay\u201d is used in a permissive sense (i.e., meaning having the potential to), rather than the mandatory sense (i.e., meaning must). Similarly, the words \u201cinclude\u201d, \u201cincluding\u201d, and \u201cincludes\u201d mean including, but not limited to.","In the following detailed description, numerous specific details are set forth to provide a thorough understanding of claimed subject matter. However, it will be understood by those skilled in the art that claimed subject matter may be practiced without these specific details. In other instances, methods, apparatuses or systems that would be known by one of ordinary skill have not been described in detail so as not to obscure claimed subject matter.","Some portions of the detailed description which follow are presented in terms of algorithms or symbolic representations of operations on binary digital signals stored within a memory of a specific apparatus or special purpose computing device or platform. In the context of this particular specification, the term specific apparatus or the like includes a general purpose computer once it is programmed to perform particular functions pursuant to instructions from program software. Algorithmic descriptions or symbolic representations are examples of techniques used by those of ordinary skill in the signal processing or related arts to convey the substance of their work to others skilled in the art. An algorithm is here, and is generally, considered to be a self-consistent sequence of operations or similar signal processing leading to a desired result. In this context, operations or processing involve physical manipulation of physical quantities. Typically, although not necessarily, such quantities may take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared or otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to such signals as bits, data, values, elements, symbols, characters, terms, numbers, numerals or the like. It should be understood, however, that all of these or similar terms are to be associated with appropriate physical quantities and are merely convenient labels. Unless specifically stated otherwise, as apparent from the following discussion, it is appreciated that throughout this specification discussions utilizing terms such as \u201cprocessing,\u201d \u201ccomputing,\u201d \u201ccalculating,\u201d \u201cdetermining\u201d or the like refer to actions or processes of a specific apparatus, such as a special purpose computer or a similar special purpose electronic computing device. In the context of this specification, therefore, a special purpose computer or a similar special purpose electronic computing device is capable of manipulating or transforming signals, typically represented as physical electronic or magnetic quantities within memories, registers, or other information storage devices, transmission devices, or display devices of the special purpose computer or similar special purpose electronic computing device.","\u201cFirst,\u201d \u201cSecond,\u201d etc. As used herein, these terms are used as labels for nouns that they precede, and do not imply any type of ordering (e.g., spatial, temporal, logical, etc.). For example, in a graphics API setting graphics states, the terms \u201cfirst\u201d and \u201csecond\u201d graphics states can be used to refer to any two graphics states. In other words, the \u201cfirst\u201d and \u201csecond\u201d graphics states are not limited to logical processing elements 0 and 1.","\u201cBased On.\u201d As used herein, this term is used to describe one or more factors that affect a determination. This term does not foreclose additional factors that may affect a determination. That is, a determination may be solely based on those factors or based, at least in part, on those factors. Consider the phrase \u201cdetermine A based on B.\u201d While B may be a factor that affects the determination of A, such a phrase does not foreclose the determination of A from also being based on C. In other instances, A may be determined based solely on B.","Digital image editing applications, executed on a computing device, may be used to manipulate, enhance, transform, create and render images, graphics, and videos, such as vector graphics, 3D graphics, and video. Digital image editing applications may be used to render, modify, and edit such objects, according to various embodiments described herein, and may use an API, such as OpenGL, DirectX, or Direct3D.","Various embodiments of methods and apparatus for parallelized definition and display of content, such as 3D content, in a scripting environment are described. Some embodiments may include a means for parallelized defining and displaying of content. For example, a state setting module may receive user input and set a graphics state in a state block. A drawing module may validate the set graphics state and provide the graphics state to a GPU. The state setting and drawing modules may, in some embodiments, be implemented by program instructions stored in a computer-readable storage medium and executable by one or more processors (e.g., one or more CPUs or GPUs) of a computing apparatus. The computer-readable storage medium may store program instructions executable by the one or more processors to cause the computing apparatus to perform parallelized definition and display of content, as described herein. Other embodiments of the state setting and drawing modules may be at least partially implemented by hardware circuitry and\/or firmware stored, for example, in a non-volatile memory.","Turning now to , one embodiment for parallelized definition and display of content is shown. While the blocks are shown in a particular order for ease of understanding, other orders may be used. In some embodiments, the method of  may include additional (or fewer) blocks than shown.  is illustrated as parallel processes that may be performed at the same time. The left box in , blocks -, may correspond to the script execution portion (scripting thread) of the scripting environment. The right box in , blocks -, may correspond to the worker thread of the scripting environment. The two paths are depicted as parallel paths for ease of understanding. The two paths may occur simultaneously, sequentially, or may sometimes occur simultaneously and sometimes occur sequentially. Both paths demonstrate an example ordering and may, in some embodiments, proceed in a different ordering.","At , a graphics state may be set. A graphics state may be a definition for a display of content, such as 3D content. For example, in a 3D graphics API, the graphics state may be set to setRenderToTexture( ). The command to set the graphics state may come from a scripting language, (e.g., ActionScript 3, JavaScript, Microsoft .NET scripting languages, etc.), which may provide a single-threaded programming model. Other example graphics states may include: setProgram( ) setProgramConstantsFromVector( ) setProgramConstantsfromMatrix( ) setVertexBufferAt( ) setBlendFactors( ) setColorMask( ) setDepthTest( ) setTextureAt( ) setRenderToTexture( ) setRenderToBackBuffer( ) setCulling( ) setStencilActions( ) setStencilReferenceValue( ) setScissorRectangle( ) etc. In one embodiment, invoking a function that sets a state may perform modifications, such as a write, of a graphics state block and return so that another graphics state may be set (or so that other scripting tasks may be performed). The graphics state block may implement buffer flipping, such as with a circular buffer or ring buffer. A ring buffer of multiple state blocks may allow a write only mode for setting states and a read only for reading states, thereby preventing simultaneous access. In one embodiment, the graphics state block may be implemented as a 64-ring buffer. The size of a buffer, in various implementations, may be based on how fast the script is at setting up new states versus how fast the GPU is at using the states. Setting the graphics state may include writing to one of the blocks\/elements of the graphics state block buffer. The graphics state block may, in various embodiments, reside in central processing unit (CPU) system memory such that state changes may be cached in CPU system memory. In doing so, setting the graphics state may not require GPU access. In one embodiment, a graphics state may be set in a debug mode. In the debug mode, the graphics state may be set directly in the GPU by the scripting thread.","In one embodiment, after setting a graphics state, it may be determined if another graphics state is ready to be set at . If another graphics state is ready to be set, then that graphics state may be set at , without waiting for any results from the GPU (i.e., without waiting for indication of successful completion of the task corresponding to the set graphics state). Setting additional graphics state may include modifying the graphics state block. For example, in an embodiment that uses a ring buffer, the scripting thread may modify an element of the ring buffer that is empty or has already been read, as described in . As a result, in a simple example in which two graphics states have been written to the ring buffer and neither has been read, both graphics states may coexist in different elements of the ring buffer. In one embodiment, the scripting may continue without waiting for GPU results and allow for another graphics state to be set. Setting the graphics state in a state block, or ring buffer, may be transparent to the scripting language. If no other graphics states are ready to be set, the scripting thread may perform other scripting tasks at .","At , the scripting thread may perform other scripting. For example, other tasks or processing for an API, and other non-graphics-rendering tasks may take place. In one embodiment, after setting a graphics state at , the scripting thread may perform other scripting. The scripting thread may perform other scripting if no pending graphics states are ready to be set. In one embodiment, the scripting thread may perform a task other than setting a graphics state, if a task is available, before checking for new graphics states to be set. In that manner, if both graphics state setting tasks and other scripting tasks are available for the scripting thread to perform, the scripting thread may alternate between setting graphics state tasks and performing other scripting tasks. In one embodiment, setting graphics states may be a higher priority than other scripting tasks and all available new graphics states may be set before performing other scripting tasks. After performing other scripting, the scripting thread may again check if another graphics state is ready to be set. If another graphics state is ready to be set, the scripting thread may finish its other task, then set the next graphics state. In one embodiment, an indication may be provided to scripting thread that a new graphics state is ready to be set in the buffer so that an actual check or polling may not be required. The scripting thread may again finish any outstanding task and then set the new graphics state at . In one embodiment, if no graphics states are ready to be set and the scripting thread has no other scripting tasks to perform, the scripting thread may wait idle at .","Simultaneous with the scripting language execution, a worker thread may be performing tasks. At , it may be determined if a new graphics state has been set. In one embodiment, a worker thread may read the buffer to see which graphics state(s) are new in the sense that they have not previously been read by the worker thread. Multiple new graphics states may be set in the buffer. For instance, the worker thread may not process and provide the set graphics states to the GPU as fast as the scripting thread may set the graphics states. In these cases, the worker thread may read priority data (e.g., a timestamp or a high priority indication) to determine which state to read first at .","In one embodiment, the set graphics state may be read at . The read may be asynchronous in that setting a graphics state may not necessarily be directly followed by reading that set graphics state. Other reads may be ahead in the queue or setting the graphics state may be faster than reading and processing the states. As shown in , reading a set graphics state may occur simultaneously with setting graphics states in block  and performing other scripting in block . Further, blocks - may also occur simultaneously with blocks -. - collectively represent a class of calls that may initiate drawing corresponding to a set graphics state, and may be collectively referred to as draw time. In one embodiment, reading a set graphics state may include a thread inspecting the state block and determining that a state is new since the last time the thread inspected the state block. If multiple new graphics states exist in the state block, the thread may read pointers or other priority data (e.g., a timestamp or high priority indication) in the state block to determine which set graphics state should be read first.","Two calls may initiate drawing by passing data from the set and read graphics state into a graphics pipeline: clear( ) drawTriangles( ). The drawing calls may be initiated by the scripting thread but the scripting thread may return to geometry processing tasks while the worker thread picks up the draw task. The draw task may pass all state information, or a modified portion, to the graphics subsystem (GPU) and initiate drawing. In one embodiment, the draw task may make no effort to recover an error state from the graphics subsystem.","As illustrated at , the read graphics state may be validated. For instance, situations may exist in which a state block is in an invalid state. In one embodiment, validating the read graphics state may be a read only operation. Validation may occur internally, performed by a thread on the CPU, and scripting may continue during validation. As an example, the read graphics state may be setProgram( ) that may set a shader that needs certain inputs to function properly. The shader program in this example may require three texture inputs. If the state block is incomplete and only has two texture inputs set instead of three, then a draw function corresponding to the set state may not function properly. In such an example, validation may fail. If validation fails, a draw call may not be executed and task submission to the GPU may be skipped. As a result of validation failure, it may be determined if another graphics state is set at block . Validation may be performed for security and safety reasons and may not include any status reporting. In one embodiment, no validation failure reporting is performed. In addition, validation may not include error checking and validation failure may not trigger an error notification to the scripting language. If the read graphics state is validated, a draw call may proceed in block .","At , a task corresponding to the validated graphics state may be submitted to a GPU. In one embodiment, the worker thread may call functions on a graphics library and set the state in the GPU. In response to the draw call, the worker thread may take the vertices that were provided in the draw call and provide those vertices to the GPU. In one embodiment, another worker thread may simultaneously perform - for another set graphics state and submit a corresponding task to the same or a different GPU. As described in -, multiple graphics states may be queued such that the graphics subsystem may be kept busy. Thus, after the task is submitted to the GPU, the next set graphics state may be read and processed at -.","Allowing for parallel setting of graphics states and processing the set graphics states may provide a set of choices for and implementation of API semantics that may create a fast-path operating mode that may allow non-blocking initiation of GPU drawing. Such an API may be valuable in a scripting environment that may not have direct support of thread control. The method of  may permit an internal worker thread to continue GPU state management while script execution may immediately return to user processing. The script programmer may enjoy the performance benefit of interleaved processing without having to introduce thread control constructs or handle asynchronous events. Further, by performing state validation, security may still be protected in lieu of error checking and reporting.","Turning now to , one embodiment for a debug mode is shown. While the blocks are shown in a particular order for ease of understanding, other orders may be used. In some embodiments, the method of  may include additional (or fewer) blocks than shown, such as blocks - of .","At , a debug mode may be entered, which may allow synchronous drawing. In one embodiment, debug mode may be selected at draw time at the script level.","As shown at , a graphics state may be set. In one embodiment, a graphics mode may be set after entering debug mode while in some embodiments, a graphics mode may already be set when debug mode is entered. In any event, when debug mode is selected, subsequent graphics states may not be set until the GPU returns an error state (which may include a lack of errors). As such, the script may be blocked from further operations.","As illustrated at , the set graphics state may be validated. In one embodiment, the graphics state may be validated, as in block , before the task is submitted to the GPU. In one embodiment, validation is performed in the scripting language while is some embodiments, validation may be performed at the GPU. Failure to validate the state block may result in an error exception and may trigger an error notification at block .","At , an error status may be reported. As mentioned at , failure to validate the state block may trigger an error notification. In addition, the graphics pipeline may be monitored for errors. In debug mode, state setting and drawing may be performed synchronously such that using sequence IDs to identify an asynchronous task or state may not be necessary. Accordingly, in a synchronous debug mode, rendering may be completed before results are passed back to the client. In other embodiments, a framework for managing message sequence IDs may be introduced to detect and report errors asynchronously. In such an embodiment, a sequence ID may be created for each API call made by the client\/scripting language. Each sequence ID may be associated with a respective state block. If an error is determined at the check validation stage, an error may include the id. On the client side, a list of the sequence IDs may map back to the operation that caused the error.","As shown at , a task corresponding to the set graphics state may be submitted to a GPU. In one embodiment, the scripting language may initiate a draw call. The scripting language may call functions on a graphics library and directly set the state in the GPU. In response to a draw call, the script may provide the vertices in the draw call to the GPU. When the task is complete, the scripting language may set the next graphics state at . In one embodiment, the GPU may report any graphics pipeline errors back to the scripting language.","Selecting the debug mode of  may allow a script programmer to opt-out of the performance mode of  and view validation errors and\/or graphics pipeline errors. Providing a default mode that may facilitate high performance graphics yet allow for selecting a debug mode may provide a significant degree of flexibility for script programmers.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 3","FIG. 3"],"b":["302","304","302","304","304","304","304","318"]},"In one embodiment, graphics API  may set a graphics state. Example graphics states may include: setProgram( ) setProgramConstantsFromVector( ) setProgramConstantsfromMatrix( ) setVertexBufferAt( ) setBlendFactors( ), setColorMask( ), setDepthTest( ) setTextureAt( ) setRenderToTexture( ) setRenderToBackBuffer( ), setCulling( ) setStencilActions( ), setStencilReferenceValue( ), setScissorRectangle( ) etc. As shown in , graphics states may be set in state blocks - of a state buffer. In the example shown, the state buffer includes 4 elements or blocks. As described above, the buffer may include 4, 8, 16, 32, 64, etc. elements. In one embodiment, the buffer may reside in CPU system memory. As an example of setting a graphics state, an input may be received by graphics API  to create a texture object that may be assigned using a setTextureAt call (the \u201cAt\u201d portion of a call may refer to previously set portions of the program). The setTextureAt state may be set in one of state blocks -.","In one embodiment, scripting environment  may perform a trivial validation of the input received by graphics API . For example, scripting language may check for invalid texture size, NULL required parameters, etc. Graphics API  may then provide two draw  calls that initiate drawing by passing date into the graphics pipeline: clear( ) and drawTriangles( ). Invocations of draw  may queue a draw task and allow scripting environment  to return to other tasks. Queuing the draw task may include: calculating a list of vertices, storing the vertices in a vertex buffer, and calling setVertexBufferAt. In the above setTextureAt\/setVertexBufferAt example, the state may, at this point, include: how to interpret the vertices, textures to apply to the vertices, and the vertices themselves. Thus, scripting environment  may be free to return to geometry processing tasks while thread  picks up the draw task. Accordingly, thread  may be transparent to scripting environment  and graphics API .","Thread  may inspect the state block, states -, and determine which state is new to GPU  since the previous inspection. If multiple states are new, for example, states  and , thread  may look for pointers indicating an ordering or priority for processing. Thread  may then validate the state - corresponding to the queued draw task. This may help ensure compatibility between the VertexBuffer definitions and the shader programs that access them. Further, validation of data before delivery to the graphics subsystem may enhance security by making it more difficult to pass arbitrary user data into the graphics subsystem. Validation failure may not trigger an error notification to graphics API . In one embodiment, if validation fails, the state - corresponding to the failed validation may be skipped and never be provided to GPU . Instead, the next state in the queue may be checked for validity and proceed if validated. Thread  may call functions on the graphics library and provide the new state, state  in , to the GPU . In response to the draw call, thread  may take the vertices that were provided in the draw call and provide them to GPU . At that point, GPU  may perform the draw task and draw triangles, for example. During validation of the state -, and while thread  provides the state to GPU , scripting environment  and graphics API  may continue setting new graphics states in state blocks -. In other words, thread  may read one state block - and, in parallel, graphics API  may set a different state block -. A mechanism may prevent the same state block - from being read\/written simultaneously.","Permitting a script programmer to simply update a graphics state while a thread reads the state and applies changes to the GPU may allow threaded behavior in a single-thread scripting environment without using or requiring threading constructs in the scripting language. This may result in significant performance gains. For example, if the scripting language completes its processing quickly and recycles to set additional graphics states, state blocks may be queued and processed sequentially by draw tasks. The existence of a run queue may ensure that the graphics subsystem is not idle waiting for data. And because the scripting language may not block, waiting for error reporting from the draw task, it may continue to set graphics states for later asynchronous processing. As a result, idle time may be minimized at the scripting level and at the GPU level.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 4","FIG. 4","FIG. 3","FIG. 4","FIG. 4","FIG. 3"],"b":["402","404","404","404","404"]},"A debug mode may be selected at scripting environment \/graphics API . Graphics API , in debug mode, may include a different layout, appearance-wise, and contain different options compared to graphics API  in normal mode. As in normal mode, a graphics state may be set in state block . Only one state block  is shown in the debug portion of , however, the same state blocks - of the normal mode may be available in the debug mode. Setting and reading the states blocks may be performed sequentially and serially, as opposed to the parallel capabilities of the normal mode. Therefore, in one embodiment, even when multiple state blocks - are available to write to and read from, graphics API  may only write to and read from one of the state blocks - at a time.","In debug mode, validation may be performed at draw time in GPU . Failure to validate the state block  may result in an error exception. The error exception may be provided back to scripting environment  and graphics API . During validation at GPU , scripting environment  and graphics API  may be blocked from setting subsequent graphics states  until GPU  has finished performing the draw task, or reported an error. Accordingly, in one embodiment, GPU  may check for and report any errors to scripting environment  before scripting environment  may proceed with further operations. In an alternative disclosed embodiment, a framework for managing message sequence IDs may be introduced to detect and report errors. Such a framework may enable asynchronous drawing methods, as in normal\/default mode, but also include the capability to check for and report errors.","The aforementioned debug mode may permit drawing methods to be synchronous, which may facilitate error reporting. Additionally, the debug mode may be selectable such that a default mode may permit high performance, and parallelized GPU drawing, yet still allow a programmer debugging capabilities in a low overhead manner.","Embodiments of a state setting module, drawing module, and\/or the various parallel definition and display of content techniques as described herein may be executed on one or more computer systems, which may interact with various other devices. One such computer system is illustrated by . In different embodiments, computer system  may be any of various types of devices, including, but not limited to, a personal computer system, desktop computer, laptop, notebook, or netbook computer, mainframe computer system, handheld computer, workstation, network computer, a camera, a set top box, a mobile device, a consumer device, video game console, handheld video game device, application server, storage device, a peripheral device such as a switch, modem, router, or in general any type of computing or electronic device.","In the illustrated embodiment, computer system  includes one or more processors  coupled to a system memory  via an input\/output (I\/O) interface . Computer system  further includes a network interface  coupled to I\/O interface , and one or more input\/output devices , such as cursor control device , keyboard , and display(s) . In some embodiments, it is contemplated that embodiments may be implemented using a single instance of computer system , while in other embodiments multiple such systems, or multiple nodes making up computer system , may be configured to host different portions or instances of embodiments. For example, in one embodiment some elements may be implemented via one or more nodes of computer system  that are distinct from those nodes implementing other elements.","In various embodiments, computer system  may be a uniprocessor system including one processor , or a multiprocessor system including several processors  (e.g., two, four, eight, or another suitable number). Processors  may be any suitable processor capable of executing instructions. For example, in various embodiments, processors  may be general-purpose or embedded processors implementing any of a variety of instruction set architectures (ISAs), such as the x86, PowerPC, SPARC, or MIPS ISAs, or any other suitable ISA. In multiprocessor systems, each of processors  may commonly, but not necessarily, implement the same ISA.","In some embodiments, at least one processor  may be a GPU. A GPU may be considered a dedicated graphics-rendering device for a personal computer, workstation, game console or other computing or electronic device. Modern GPUs may be very efficient at manipulating and displaying computer graphics, and their highly parallel structure may make them more effective than typical CPUs for a range of complex graphical algorithms. For example, a graphics processor may implement a number of graphics primitive operations in a way that makes executing them much faster than drawing directly to the screen with a host central processing unit (CPU). In various embodiments, the image processing methods disclosed herein may, at least in part, be implemented by program instructions configured for execution on one of, or parallel execution on two or more of, such GPUs. The processors and\/or GPU(s) may implement one or more APIs that permit programmers to invoke the functionality of the GPU(s). Suitable GPUs may be commercially available from vendors such as NVIDIA Corporation, ATI Technologies (AMD), and others.","GPUs, such as one or more of processors  may be implemented in a number of different physical forms. For example, GPUs may take the form of a dedicated graphics card, an integrated graphics solution and\/or a hybrid solution. The dedicated graphics card may be a 3D graphics card. GPU  may interface with the motherboard by means of an expansion slot such as PCI Express Graphics or Accelerated Graphics Port (AGP) and thus may be replaced or upgraded with relative ease, assuming the motherboard is capable of supporting the upgrade. However, a dedicated GPU is not necessarily removable, nor does it necessarily interface the motherboard in a standard fashion. The term \u201cdedicated\u201d refers to the fact that hardware graphics solution may have RAM that is dedicated for graphics use, not to whether the graphics solution is removable or replaceable. Dedicated GPUs for portable computers may be interfaced through a non-standard and often proprietary slot due to size and weight constraints. Such ports may still be considered AGP or PCI express, even if they are not physically interchangeable with their counterparts.","Integrated graphics solutions, or shared graphics solutions are graphics processors that utilize a portion of a computer's system RAM rather than dedicated graphics memory. For instance, modern desktop motherboards normally include an integrated graphics solution and have expansion slots available to add a dedicated graphics card later. As a GPU may be extremely memory intensive, an integrated solution finds itself competing for the already slow system RAM with the CPU as the integrated solution has no dedicated video memory. For instance, system RAM may experience a bandwidth between 2 GB\/s and 8 GB\/s, while most dedicated GPUs enjoy from 15 GB\/s to 30 GB\/s of bandwidth. Hybrid solutions may also share memory with the system memory, but may have a smaller amount of memory on-board than discrete or dedicated graphics cards to make up for the high latency of system RAM. Data communicated between the graphics processing unit  and the rest of the computer system  may travel through a graphics card slot or other interface, such as I\/O interface  of .","Note that program instructions  may be configured to implement a graphics application as a stand-alone application, or as a module of another graphics application or graphics library, in various embodiments. For example, in one embodiment program instructions  may be configured to implement graphics applications such as painting, editing, publishing, photography, games, animation, and\/or other applications, and may be configured to provide the functionality described herein. In another embodiment, program instructions  may be configured to implement the techniques described herein in one or more functions or modules called by another graphics application executed on GPU  and\/or processor(s)  (e.g., a state setting module or a drawing module). These modules may be executable on one or more of CPUs  and\/or GPUs  to cause computer system  to provide the functionality described herein. The graphics application may be implemented in various embodiments using any desired programming language, scripting language, or combination of programming languages and\/or scripting languages, e.g., C, C++, C#, ActiveScript, Java\u2122, Perl, etc. For example, in one embodiment, the graphics application may be JAVA based, while in another embodiments, it may be implemented using ActiveScript 3. In other embodiments, the graphics application may be implemented using specific graphic languages specifically for developing programs executed by specialized graphics hardware, such as a GPU. In addition, the graphics application may be embodied on memory specifically allocated for use by graphics processor(s), such as memory on a graphics board including graphics processor(s). Program instructions  may also be configured to render images and present them on one or more displays as the output of an operation and\/or to store image data in memory  and\/or an external storage device(s), in various embodiments.","System memory  may be configured to store program instructions and\/or data accessible by processor . In various embodiments, system memory  may be implemented using any suitable memory technology, such as static random access memory (SRAM), synchronous dynamic RAM (SDRAM), nonvolatile\/Flash-type memory, or any other type of memory. In the illustrated embodiment, program instructions and data implementing desired functions, such as those described above for embodiments of a state setting module and drawing module are shown stored within system memory  as program instructions  and data storage , respectively. In other embodiments, program instructions and\/or data may be received, sent or stored upon different types of computer-accessible media or on similar media separate from system memory  or computer system . Generally speaking, a computer-accessible medium may include storage media or memory media such as magnetic or optical media, e.g., disk or CD\/DVD-ROM coupled to computer system  via I\/O interface . Program instructions and data stored via a computer-accessible medium may be transmitted by transmission media or signals such as electrical, electromagnetic, or digital signals, which may be conveyed via a communication medium such as a network and\/or a wireless link, such as may be implemented via network interface .","In one embodiment, I\/O interface  may be configured to coordinate I\/O traffic between processor , system memory , and any peripheral devices in the device, including network interface  or other peripheral interfaces, such as input\/output devices . In some embodiments, I\/O interface  may perform any necessary protocol, timing or other data transformations to convert data signals from one component (e.g., system memory ) into a format suitable for use by another component (e.g., processor ). In some embodiments, I\/O interface  may include support for devices attached through various types of peripheral buses, such as a variant of the Peripheral Component Interconnect (PCI) bus standard or the Universal Serial Bus (USB) standard, for example. In some embodiments, the function of I\/O interface  may be split into two or more separate components, such as a north bridge and a south bridge, for example. In addition, in some embodiments some or all of the functionality of I\/O interface , such as an interface to system memory , may be incorporated directly into processor .","Network interface  may be configured to allow data to be exchanged between computer system  and other devices attached to a network, such as other computer systems, or between nodes of computer system . In various embodiments, network interface  may support communication via wired or wireless general data networks, such as any suitable type of Ethernet network, for example; via telecommunications\/telephony networks such as analog voice networks or digital fiber communications networks; via storage area networks such as Fibre Channel SANs, or via any other suitable type of network and\/or protocol.","Input\/output devices  may, in some embodiments, include one or more display terminals, keyboards, keypads, touchpads, scanning devices, voice or optical recognition devices, or any other devices suitable for entering or retrieving data by one or more computer system . Multiple input\/output devices  may be present in computer system  or may be distributed on various nodes of computer system . In some embodiments, similar input\/output devices may be separate from computer system  and may interact with one or more nodes of computer system  through a wired or wireless connection, such as over network interface .","As shown in , memory  may include program instructions , configured to implement embodiments of a state setting module and drawing module as described herein, and data storage , comprising various data accessible by program instructions . In one embodiment, program instructions  may include software elements of embodiments of a state setting module and drawing module as illustrated in the above Figures. Data storage  may include data that may be used in embodiments. In other embodiments, other or different software elements and data may be included.","Those skilled in the art will appreciate that computer system  is merely illustrative and is not intended to limit the scope of a state setting module and drawing module as described herein. In particular, the computer system and devices may include any combination of hardware or software that can perform the indicated functions, including a computer, personal computer system, desktop computer, laptop, notebook, or netbook computer, mainframe computer system, handheld computer, workstation, network computer, a camera, a set top box, a mobile device, network device, internet appliance, PDA, wireless phones, pagers, a consumer device, video game console, handheld video game device, application server, storage device, a peripheral device such as a switch, modem, router, or in general any type of computing or electronic device. Computer system  may also be connected to other devices that are not illustrated, or instead may operate as a stand-alone system. In addition, the functionality provided by the illustrated components may in some embodiments be combined in fewer components or distributed in additional components. Similarly, in some embodiments, the functionality of some of the illustrated components may not be provided and\/or other additional functionality may be available.","Those skilled in the art will also appreciate that, while various items are illustrated as being stored in memory or on storage while being used, these items or portions of them may be transferred between memory and other storage devices for purposes of memory management and data integrity. Alternatively, in other embodiments some or all of the software components may execute in memory on another device and communicate with the illustrated computer system via inter-computer communication. Some or all of the system components or data structures may also be stored (e.g., as instructions or structured data) on a computer-accessible medium or a portable article to be read by an appropriate drive, various examples of which are described above. In some embodiments, instructions stored on a computer-accessible medium separate from computer system  may be transmitted to computer system  via transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as a network and\/or a wireless link. Various embodiments may further include receiving, sending or storing instructions and\/or data implemented in accordance with the foregoing description upon a computer-accessible medium. Accordingly, the present disclosure may be practiced with other computer system configurations.","Various embodiments may further include receiving, sending or storing instructions and\/or data implemented in accordance with the foregoing description upon a computer-accessible medium. Generally speaking, a computer-accessible medium may include storage media or memory media such as magnetic or optical media, e.g., disk or DVD\/CD-ROM, volatile or non-volatile media such as RAM (e.g. SDRAM, DDR, RDRAM, SRAM, etc.), ROM, etc., as well as transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network and\/or a wireless link.","The various methods as illustrated in the Figures and described herein represent example embodiments of methods. The methods may be implemented in software, hardware, or a combination thereof. The order of method may be changed, and various elements may be added, reordered, combined, omitted, modified, etc.","Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. It is intended that the disclosure embrace all such modifications and changes and, accordingly, the above description to be regarded in an illustrative rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
