---
title: Client-tier validation of dynamic web applications
abstract: In one embodiment, a method includes accessing and crawling a dynamic web application that comprises a client tier. In one embodiment, the crawling includes one or more instances of guided crawling that each initiate when a preceding instance of automatic crawling reaches a state in the dynamic web application that meets one or more predetermined criteria for the instance of guided crawling and, when initiated, perform one or more predetermined actions with respect to the dynamic web application. The method further includes generating, based on the crawling, a screen transition model of the dynamic web application. In a particular embodiment, the screen transition model includes a hierarchical finite state machine (FSM). In one embodiment, after the generation of the screen transition model has completed, the method further includes performing model checking on the screen transition model to validate the client tier of the dynamic web application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08255384&OS=08255384&RS=08255384
owner: Fujitsu Limited
number: 08255384
owner_city: Kawasaki
owner_country: JP
publication_date: 20090930
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","DESCRIPTION OF EXAMPLE EMBODIMENTS"],"p":["The present disclosure generally relates to validation, and more particularly to validating dynamic web applications.","Conventional techniques for the functional validation (or verification) of web applications typically involve the use of capture-replay tools such as Selenium, WebKing, and Sahi. Using these frameworks, a user desiring to validate a particular web application manually exercises the application through various test scenarios, one test scenario at a time. The actions taken by the user while exercising the application are recorded by the tool at, for example, a Hyper Text Markup Language (HTML) Document Object Model (DOM) level and can be replayed back at a later time, usually with user-defined assertions regarding expected behavior, inserted at various steps. This technique of validation, however, requires a substantial amount of manual effort. While frameworks such as JsUnit can be used to perform unit testing of the JavaScript code in the application, this manner of testing is by its very nature very localized, language specific, and also manually intensive.","Another validation technique involves reverse engineering a model of a desktop graphical user interface (GUI) application with the objective of generating test cases. However, while desktop GUI applications may share some of the rich user-interface and interactivity of modern dynamic web applications, modern dynamic web applications have other features such as, for example, synchronous client-server communication and a DOM-based user interface, which are not shared or present in conventional desktop GUI applications. Furthermore, these and other conventional techniques remain increasingly ill-suited for increasingly dynamic web applications, particularly those web applications utilizing asynchronous techniques such as Asynchronous JavaScript and XML (AJAX). Still other validation techniques for web applications generally propose testing of web applications by representing relevant behavior through some kind of state-based model and then checking the model using various conventional techniques. Such approaches specify the model manually and are generally geared towards traditional, static, and\/or non-user interactive web applications. Furthermore, these approaches typically involve generating test traces from the model and then checking these traces one at a time.","Particular embodiments relate to validating web applications. Particular embodiments relate to validating dynamic web applications that may include JAVA or other software platforms and that may be configured to display web pages that include Hyper Text Markup Language (HTML) content, Extensible Markup Language (XML) content, JavaScript resources, and\/or other embedded resources. Particular embodiments relate to validating dynamic web applications that are configured to utilize asynchronous techniques such as, by way of example, Asynchronous JavaScript and XML (AJAX). Particular embodiments generate a behavior model of a dynamic web application in the form of a screen transition diagram or model. In particular embodiments, the screen transition model is formatted in XML. In particular embodiments, the screen transition model includes a hierarchical finite state machine (FSM). In particular embodiments, the screen transition model is generated as a result of guided crawling of the deployed dynamic web application. In particular embodiments, the crawling involves both instances of fully automatic crawling as well as at least one instance of guided \u201ccustom\u201d crawling. In particular embodiments, model checking is used to validate the screen transition model after generation of the screen transition model is completed, hence enabling validation of global properties of the model. Particular embodiments are concerned with validating the client tier of the dynamic web application.","As described above, particular embodiments relate to validating dynamic web applications. By way of example, such dynamic web applications may generally be characterized by feature-rich, client-side user interfaces and typically support a high degree of user interactivity. By way of example, technologies such as AJAX and Adobe Flash may be utilized to enable such features of these dynamic web applications. As is also mentioned above, particular embodiments focus on validating the behavior of the client-tier of the web application. By way of example, the client-tier of a web application generally refers to the portion of the code for implementing the web application that resides and executes within or at the end-user's machine (or client device). Typically, a web application executes in the context of a web browser (e.g., Microsoft Windows Internet Explorer, Mozilla Firefox, Apple Safari, Google Chrome, and Opera, etc.) that consumes content over a network and renders the content on a display of the end-user's machine.","Generally, a web application is an application that may be accessed via a web browser or other client application over a network, or a computer software application that is coded in a web browser-supported language and sometimes reliant on a web browser to render the application executable. Web applications have gained popularity largely as a result of the ubiquity of web browsers, the convenience of using a web browser launched at a remote computing device as a client (sometimes referred to as a thin client), and the corresponding ability to update and maintain web applications without distributing and installing software on remote clients. Often, to implement a web application, the web application requires access to one or more resources provided at a backend server of an associated website. Additionally, web applications may often require access to additional resources associated with other applications.","A web application deployed at an end-user's machine may cause a web page to be rendered on a display of the end-user's machine. Web applications that execute in conjunction with or in the context of a web browser may cause the web browser to render a web page on the display. Web pages of web applications typically include embedded links to other web pages of the web application as well as to web pages and web sites external to or not affiliated with the web application. Dynamic web applications in particular often include a plurality of embedded links which may be rendered on the currently viewed web page as a hyperlink, icon, or other \u201cclickable\u201d feature. Typical dynamic web applications may include one or more resources. A web page or resource for rendering a web page, which may themselves include multiple embedded resources, may include data records, such as content plain textual information, or more complex digitally encoded multimedia content, such as software programs or other code objects, graphics, images, audio signals, videos, and so forth. One prevalent markup language for creating web pages is the Hypertext Markup Language (HTML). Other common web browser-supported languages and technologies include the Extensible Markup Language (XML), the Extensible Hypertext Markup Language (XHTML), JavaScript, Cascading Style Sheet (CSS), and JAVA, among others. By way of example, HTML enables an application or web page developer to create a structured document by denoting structural semantics for text and links, as well as images, web applications and other objects that can be embedded within the page. Generally, a web page may be delivered to a client as a static document, however, through the use of web elements embedded in the page, an interactive experience may be achieved with the page or a sequence of pages. During a user session at the client device, the web browser interprets and displays the pages and associated resources received or retrieved from the web application or website hosting the web page, as well as, potentially, resources from other websites.","JavaScript is an example of a scripting language that enables various web applications to access resources within other applications for use on the client side of a user session to enable an interactive or dynamic user session when accessing a dynamic web application. AJAX (shorthand for Asynchronous JavaScript and XML) refers to a group of interrelated techniques used on the client side of a user session to enable more interactive and rich web applications. Utilizing JavaScript or AJAX, a web application can transmit requests for resources to backend servers associated with the web application or to other external resource providers in order to retrieve the resources asynchronously in the background operations of the end-user's machine without necessarily interfering with the display and behavior of the currently-rendered page. More particularly, when using AJAX, resources are usually retrieved by transmitting an XMLHttpRequest (XHR) object to the resource provider. An XHR is a document object model (DOM) application programming interface (API) that can be used with a web browser scripting language (e.g., JavaScript) to send, for example, an HTTP or HTTPS request for a resource directly to a web server and load the resource retrieved from the server in response to the request directly back into the scripting language code. Once the resource is within the code, the resource may then be available as, by way of example, an HTML or XML document or plain text. In this manner, the retrieved resource may be used to manipulate the currently active document rendered by the web browser without requiring the client to load a new webpage document. In some example embodiments, if the resource is retrieved as plain text, the plain text may be formatted in JavaScript Object Notation (JSON) by the server and evaluated within JavaScript to create an object of data for use on the current DOM.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 1","FIG. 5"],"b":["100","102","102","104","102","104","102","104","102","108","104","104","102","108","104","110","104"]},"In particular embodiments, the behavioral model  generated by validation toolkit  is a screen transition model (behavioral model and screen transition model may be used interchangeably herein and may both be designated by the reference number ). Additionally, in particular embodiments, screen transition model  takes the form of or is generated in the form of a finite state machine (FSM), and even more particularly, a hierarchical FSM. A hierarchical FSM is generally a FSM in which each of one or more nodes or states of the FSM is, in turn, a FSM. An example hierarchical FSM is illustrated by way of reference in . An example graphical representation of an example screen transition diagram is illustrated by way of reference in .","In particular embodiments, validation toolkit  includes a crawler  that dynamically, automatically, and comprehensively navigates and exercises the dynamic web application  under test through a process the present inventors refer to as guided crawling. As illustrated in , crawler  may receive input such as guidance instructions, parameters, and other information from a guidance engine  for use by crawler  in crawling dynamic web application , as will be described in more detail below. An output of crawler , namely screen transitional model , is a compact mathematical model or representation of the behavior of dynamic web application  and, in particular embodiments, the client-tier of dynamic web application . In one embodiment, screen transition model  is formatted in XML and subsequently stored as an XML document or file by validation toolkit .","In the second part (or stage), validation toolkit  checks, verifies, and\/or validates interesting properties, and particularly global properties, of the screen transition model . In particular embodiments, validation toolkit  includes a model checker  that receives as input the screen transition model  generated by crawler  and performs model checking on or of the screen transition model  in order to validate the client-tier of the dynamic web application , as will be described in more detail below (Note that in some alternate embodiments, model checker  may be separate from validation toolkit  and crawler ). In a particular embodiment, model checker  receives as input a specification or set of requirements . Model checker  may then test, automatically, whether or not screen transition model  satisfies the specification. By way of example, model checker  may determine whether or not screen transition model  satisfies one or more functional properties of dynamic web application  as specified in specification . As another example, model checker  may determine whether or not screen transition model  satisfies one or more navigational properties related to the usability of dynamic web application  as specified in specification . In particular embodiments, model checker  performs model checking and validation after screen transition model  has been generated\/completed in its entirely. That is, in particular embodiments, generating the screen transition model  is not concurrent with or doesn't overlap the checking of the screen transition model . In an alternate embodiment, the generating and checking may be concurrent or portions of the checking may overlap portions of the generating.","In particular embodiments, and as illustrated in , crawler  includes a browser , crawling controller , and robot simulator . In some embodiments, browser , in some respects, is similar to a convention web browser. In a particular embodiment, browser  receives content and other information for rendering a web page from dynamic web application  through application interface  and translates the web page into a DOM representation (e.g., a DOM hierarchical tree) . In some embodiments, browser  may include its own AJAX engine  for aiding application interface  in constructing DOM  and for asynchronously updating the DOM representation  of the current web page. In the illustrated embodiment, a programmatic interface  also interacts with DOM . By way of example, programmatic interface  passes event information to DOM  and receives updates based on DOM . In a particular embodiment, programmatic interface  is coded in JAVA or is JAVA-based. Programmatic interface , in turn, is coupled to robot simulator , which is, in turn, coupled to crawling controller . In particular embodiments, programmatic interface  enables robot simulator , and through it crawling controller , to interact\/communicate with the dynamic web application via browser . In an example embodiment, programmatic interface  receives input (such as, for example, mouse clicks, keyboard character input, etc.) from robot simulator  (at the direction of crawling controller ) and supplies this input to dynamic web application  via application interface . Additionally, programmatic interface  receives output (such as querying the state of various DOM elements within the current DOM  constructed via application interface  and AJAX engine , and pass this output to robot simulator  for subsequent routing to crawling controller  (or, alternately, directly to crawling controller ). In an example embodiment, crawling controller  may be or be similar to the crawljax controller developed by the Technical University, Delft.","In particular embodiments, upon navigating to a new web page from a previous web page for which a previous DOM has been generated by browser , browser , rather than discard the previous DOM and construct a new DOM for the new web page, modifies the previous DOM to incorporate the differences between the previous and new web pages using new content and resources retrieved via dynamic web application  for rendering the new web page. Additionally, in particular embodiments, the differences between adjacently navigated web pages are stored and used to generate screen transition model , as opposed to storing each DOM\/state and generating a behavioral model based on the entire DOMs\/state themselves.","The two-part approach to validating a dynamic web application provides numerous advantages over conventional validation techniques. More particularly, the afore-described techniques of generating a behavioral model of a dynamic web application through dynamic guided crawling followed by model checking the completed and statically represented model may provide several significant advantages, some or all of which may be provided in various particular embodiments described herein. Such advantages will become more clear in the following more detailed descriptions.","In particular, guided crawling facilitates dynamic, automatic, and comprehensive exploring of a dynamic web application while reducing the amount of computing required and enabling the generation of a compact and accurate behavioral model as opposed to conventional techniques employing fully automatic crawling or manual exploration. By way of reference, crawling-based model generation is a relatively expensive step (in terms of the computing resources required including processing as well as storage) and so, in this regard, it is advantageous to limit the amount of crawling performed on a given web application. In one particular embodiment, crawler  crawls the dynamic web application  only once while the model checking by model checker  may be performed offline with the completed screen transition model  as many times as needed or desired without adversely impacting the model generation efficiency. Additionally, as all the requirements of the dynamic web application to be checked are often not known prior to checking and validating, relegating the validation of screen transition model  offline obviates the need to repeat the relatively expensive crawling and model generation, as opposed to conventional techniques in which the checking and validating are performed concurrently with the crawling and model generation.","Furthermore, particular embodiments generate a relatively compact screen transition model  (as compared to conventional techniques). By way of example, compaction results, at least in part, by discarding application-level implementation details that are not relevant from a validation perspective as well as compression that may be achieved by the specific choice of the mathematical representation of the model . This compaction facilitates a more efficient validation of the requirements. Still further, global properties or requirements of the screen transition model  are easier to check in particular embodiments. More particularly, checking\/validating requirements related to the global behavior of the web application is facilitated by checking the complete screen transition model  as opposed to during model generation (as in conventional techniques) in which there is typically only visibility into a single trace (i.e., the current trace being crawled). Further compression and compaction may be achieved by generating screen transition model  based on the differences in the DOMs of adjacently navigated web pages as opposed to the complete DOMs\/states themselves.","Guided crawling facilitates comprehensive, accurate, and compact model generation in other ways as well. By way of example, web applications often enable users to provide input or even require input from a user to proceed to certain web pages offered by the web application. By way of example, a web application may require some sort of user authentication, such as a login ID and\/or password, in order to proceed to a next step or next web page or to enable or render certain features provided by the web application. This may require, by way of example, entering a specific, valid username and password information into specific input boxes rendered on the current web page and\/or clicking a specific button, such as a login button, rendered on the current web page. Such authentication may be required at a first (e.g., \u201chome\u201d) web page rendered with the dynamic web application. Alternately, such an authentication step may be required at a later point at a subsequent web page navigated to from a previously rendered web page (e.g., such as is the case with the checkout stage implemented by Amazon.com). In such cases, fully automatic crawling fails to proceed further and model coverage is limited. In particular embodiments, this is when the guided custom crawling takes over. Upon authentication or other information input, the crawler  may revert back to automatic crawling. States in which it is advantageous for crawler  to switch to an instance of guided custom crawling may correspond to screens\/web pages in which a user is prompted to enter information, among others. Such predetermined states or criteria may be programmed into guidance engine  as described more fully below.","Furthermore, some web applications manifest different behaviors (e.g., privileges, features, actions, etc.) for administrators or other specially privileged users as opposed to regular users or unregistered users not having usernames and passwords. In such cases, in particular embodiments, validation toolkit , and particularly crawler , may perform more than one instance of crawling the same dynamic web application (e.g., one instance with an administrative login, one instance with a regular user login, and even one instance with no login, where applicable).","HTML forms have become more and more common in modern web applications (a user authentication panel as described above is one special instance). Using conventional techniques, typical exploration would require exploring these forms with different data sets (e.g., one erroneous data set and one valid data set) for checking the response of the application to incorrect and correct user inputs. Additionally, in many instances, practical resource constraints dictate that only specific actions on specific pages be exercised when crawling a web application. In particular embodiments, this is achieved through the guiding crawling techniques described herein by excluding from crawling and from the screen transition model  those features and actions that may be outside the scope of or irrelevant to the ensuing checking and validating step.","Particular embodiments account for the afore-described considerations, advantages, conventional shortcomings using guided crawling. More particularly, validation toolkit  provides a mechanism for specifying and executing (during crawling) a specific sequence of actions, with specific and possibly multiple sets of data, which are executed at specific stages in the evolution or navigation of dynamic web application ; that is, at specific states corresponding to specific pages of dynamic web application . Thus, crawler  may navigate through several sequences based on the various scenarios described above. In particular embodiments, the behavior produced through this guided or \u201ccustom\u201d crawling may be seamlessly and accurately integrated with other parts of the screen transition model  being generated through \u201cblind\u201d or fully automatic crawling (e.g., involving fully automatic link navigation).","In particular embodiments, the guidance provided to crawler  is in the form of guidance directives supplied to crawler  by guidance engine . These guidance directives may be specific to the particular web application under test. In an example embodiment, a guidance directive may be defined mathematically as G=(p,A). In this way, the guidance directive G is an ordered pair that consists of a predicate p that is evaluated on the current web application state and an action sequence A. The action sequence A=(\u03b1, \u03b1. . . , \u03b1) is a sequence of atomic actions \u03b1. Each atomic action \u03b1=(e,u,D) is a triple consisting of a DOM element e, a user-action u, and a set of data-instances D (potentially empty) associated with u. A guidance directive G, as per the afore-described definition, includes the predicate that determines when G should be activated. In an example embodiment, the predicate is evaluated on the current state of the web application  during the crawling. In particular embodiments, the state is essentially an encoded version of the DOM of the current screen\/web page rendered by browser . The action sequence A represents the sequence of user actions that must be executed on the web application upon activation of G (i.e., when p is true in the current state\/screen), along with the associated data, if applicable. Each atomic action \u03b1 in A is a user action u (e.g., a simple browser-based user action) on a particular DOM element e on the current screen\/web page. By way of example, one typical action u would be a click or mouse-over on a DOM element such as, for example, a link or button. Such actions have no corresponding data. Hence, the D component of the atomic action would be the empty set \u00d8. Another class of actions are those that correspond to the choice or input of some data string, for example, selecting an option from a select element or assigning a string value to an <input> HTML element, etc. In these cases, the D component would represent the set of data values for which to test\/exercise the element with. Upon activation of the guidance directive, validation toolkit , and specifically crawling controller , constructs a concrete action sequence from A by picking specific data values from the set D corresponding to each \u03b1 in A and executes it on the web application . In particular embodiments, validation toolkit  does this systematically for each combination of data values represented in A.","Two example algorithms are presented below. The first is an algorithm for performing a guide crawl on dynamic web application  from the initial, home, or first rendered page of dynamic web application . The second is an algorithm for performing a guided crawl on dynamic web application  from a particular state S.",{"@attributes":{"id":"p-0032","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Algorithm 1: GuidedCrawl(W,G)"]},{"entry":[{},"M = \u00d8"]},{"entry":[{},"InitPage \u2190 LoadBrowser(W)"]},{"entry":[{},"GuidedCrawlFromState(InitPage)"]},{"entry":[{},"return M"]},{"entry":[{},"Algorithm 2: GuidedCrawlFromState(S)"]},{"entry":[{},"if IsVisited(S) then"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end if"]},{"entry":[{},"MarkVisited(S)"]},{"entry":[{},"AddState(S,M)"]},{"entry":[{},"Actions \u2190 FindActions(S)"]},{"entry":[{},"for all G(p,A) \u2208 Gdo"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if p(S) = true then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Actions \u2190 Actions \u222a ComputeActionSequences(A)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"end if"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end for"]},{"entry":[{},"for all \u03b1 \u2208 Actions do"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"nextState \u2190 Execute(\u03b1,W,S)"]},{"entry":[{},"AddTransition(nextState,S,M)"]},{"entry":[{},"GuidedCrawlFromState(nextState)"]},{"entry":[{},"UndoTransition(nextState,S,M)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end for"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["212","322","104"],"sup":"set","ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["IsVisited: Checks if the state S has been visited by a previous invocation of Guided CrawlFromState. this check takes into account any state-abstractions implemented for this step.","MarkVisited: Marks state S as visited to exclude it from future guided crawls.","AddState: Records the state S in the navigational model M as a newly discovered state.","FindActions: Computes the set of primitive (non-guided) user actions (e.g., clicks, mouseovers, etc.) that can be executed on the current screen S.","ComputeActionSequences: Computes concrete sequences of actions from the guidance directive G by picking specific data values in its constituent atomic actions \u03b1. Computes all possible sequences that can be created by various choices of the specified data values.","Execute: Executes the action (or action sequence) \u03b1 on the web application W, which is currently in state\/screen S.","AddTransition: Records the transition from state S to state nextState in the model M.","UndoTransition: Functionally reverses the recent transition (S\u2192nextState) on W to restore it to state S."]}}}},"The model extracted during the guided crawling primarily captures the navigational aspects of the web application's client-tier behavior. The chosen screen transition model mirrors the natural structure of a dynamic web application as well as ties in with the specific method of model generation described, that is, dynamic guided crawling. Much of the navigational behavior of modern, highly dynamic web applications is focused around changes to the browser-screen content while remaining on the same Uniform Resource Locator (URI). Thus, the afore-described methods of generated DOMs based on differences between adjacently navigated pages and modeling the behavior based on such differences work synergistically. Further, while the web application may theoretically allow for an infinite number of different screens or web pages it is neither practical nor particularly useful to attempt to capture, represent or check these infinite screens. Thus, particular embodiments focus on automatically navigating (through guided crawling) a rich but finite number of screens at each URI of the web application, while using innovative state representation and abstraction mechanisms to represent this information compactly.","The screen transition model  may, according to particular embodiments, be summarized as follows. A state representation is used to capture the content of each web page\/screen visited by the application  and a FSM is used to represent the navigational behavior of the web application  around each URI. Further, a top level FSM captures the navigation of the web application from one URI to another. Thus, such a screen transition model  is intrinsically a hierarchical FSM. As illustrated in , each U, U, and U represent a super-state encompassing the navigational behavior at a particular URI and each contains an inner FSM representing this intra-URI behavior.","In particular embodiments, XML is used to represent the screen transition model . There are numerous features of model  that are noteworthy from an efficiency and efficacy perspective. By way of example, in particular embodiments the format of the model  excludes any HTML CSS (cascading style sheets) information as well as information about the DOM tree hierarchy. As another example, in particular embodiments, the model  represents the FSM of each super-state through its transition relation, rather than the explicit representation of each screen (as described above), as it is natively available during the guided crawling. This may be particularly significant as the state changes only minimally in a single transition. Therefore, a high degree of compaction can be achieved in the model  by representing only the changes between successive screens rather than the whole screen state.","As described above, particular embodiments achieve compression through one or more of a variety of sources. By way of example, in particular embodiments, crawler  is provided a specific list of HTML elements that should definitely be included during crawling (i.e., white listing) and those that should definitely be excluded during the crawling (i.e., black listing). This specification may be done by the user on an application-specific basis, as an input to the model generation step. As another example, as there are many instances in which two \u201csimilar-looking\u201d HTML pages result in the same state representation in the model (e.g., when two pages have an identical DOM tree and differ only in the content of the text nodes attached to various DOM elements), in particular embodiments, two such web pages are viewed as and considered the same state and hence represented as a single state in the navigational model , providing significant state-space reduction in the model . In particular embodiments, the criteria for state-equivalence are implemented as within the IsVisited( ) function in the afore-described algorithm. As another example, typically, every HTML attribute of every DOM element included in a model figures as a separate state variable in the state representation in the model. However, in many or most practical instances, attributes change values in unison as the application transitions from one screen\/state to another. Thus, in particular embodiments, each state may potentially be represented with a fewer number of state variables (than one variable per HTML DOM element attribute). Hence, this observation is used in particular embodiments to perform a state re-encoding step on the generated model, using, by way of example, algorithms similar to those for FSM minimization.","The present inventors have determined that several navigational and other types of requirements that are typically checked on web applications can be quite naturally formulated as properties in temporal logic, an input language of model checkers, hence making model checking an advantageous choice to validate the described screen transition models of dynamic web applications. By way of example and not limitation, such classes of requirements include screen transition requirements, feature availability\/unavailability requirements, and navigation structure\/usability requirements.",{"@attributes":{"id":"p-0038","num":"0045"},"figref":"FIG. 4","b":["402","404","406","408"]},"Validation toolkit  may include one or more software components residing at one or more computer systems.  illustrates an example computer system . Validation toolkit  and model generator  may be software components at one or more computer systems, which may be similar to example computer system . Particular embodiments may implement validation toolkit , model generator , or both as hardware, software, or a combination of hardware and software. As an example and not by way of limitation, one or more computer systems may execute particular logic or software to perform one or more steps of one or more processes described or illustrated with respect to validation toolkit , model generator , or both. One or more of the computer systems may be unitary or distributed, spanning multiple computer systems or multiple datacenters, where appropriate. The present disclosure contemplates any suitable computer system. Herein, reference to logic may encompass software, and vice versa, where appropriate. Reference to software may encompass one or more computer programs, and vice versa, where appropriate. Reference to software may encompass data, instructions, or both, and vice versa, where appropriate. Similarly, reference to data may encompass instructions, and vice versa, where appropriate.","One or more computer-readable media may store or otherwise embody software implementing particular embodiments. A computer-readable medium may be any medium capable of carrying, communicating, containing, holding, maintaining, propagating, retaining, storing, transmitting, transporting, or otherwise embodying software, where appropriate. A computer-readable medium may be a biological, chemical, electronic, electromagnetic, infrared, magnetic, optical, quantum, or other suitable medium or a combination of two or more such media, where appropriate. A computer-readable medium may include one or more nanometer-scale components or otherwise embody nanometer-scale design or fabrication. Example computer-readable media include, but are not limited to, application-specific integrated circuits (ASICs), compact discs (CDs), field-programmable gate arrays (FPGAs), floppy disks, floptical disks, hard disks, holographic storage devices, magnetic tape, caches, programmable logic devices (PLDs), random-access memory (RAM) devices, read-only memory (ROM) devices, semiconductor memory devices, and other suitable computer-readable media.","Software implementing particular embodiments may be written in any suitable programming language (which may be procedural or object oriented) or combination of programming languages, where appropriate. Any suitable type of computer system (such as a single- or multiple-processor computer system) or systems may execute software implementing particular embodiments, where appropriate. A general-purpose computer system may execute software implementing particular embodiments, where appropriate.","The components in  are examples only and do not limit the scope of use or functionality of any hardware, software, embedded logic component, or a combination of two or more such components implementing particular embodiments. Computer system  may have any suitable physical form, including but not limited to one or more integrated circuits (ICs), printed circuit boards (PCBs), mobile handheld devices (such as mobile telephones or PDAs), laptop or notebook computers, distributed computer systems, computing grids, or servers. Computer system  includes a display , one or more input devices  (which may, for example, include a keypad, a keyboard, a mouse, a stylus, etc.), one or more output devices  (which may, for example, include one or more speakers), one or more storage devices , and various storage media .","Bus  connects a wide variety of subsystems. Herein, reference to a bus encompasses one or more digital signal lines serving a common function, where appropriate. Bus  may be any of several types of bus structures including a memory bus, a peripheral bus, or a local bus using any of a variety of bus architectures. As an example and not by way of limitation, such architectures include an Industry Standard Architecture (ISA) bus, an Enhanced ISA (EISA) bus, a Micro Channel Architecture (MCA) bus, a Video Electronics Standards Association local bus (VLB), a Peripheral Component Interconnect (PCI) bus, a PCI-Express (PCI-X) bus, and an Accelerated Graphics Port (AGP) bus.","Processor(s)  (or central processing unit(s) (CPU(s))) optionally contains a cache memory unit  for temporary local storage of instructions, data, or computer addresses. Processor(s)  are coupled to storage devices including memory . Memory  includes random access memory (RAM)  and read-only memory (ROM) . ROM  may act to communicate data and instructions unidirectionally to processor(s) , and RAM  may act to communicate data and instructions bidirectionally with processor(s) . ROM  and RAM  may include any suitable computer-readable media described below. Fixed storage  is connected bidirectionally to processor(s) , optionally through storage control unit . Fixed storage  provides additional data storage capacity and may also include any suitable computer-readable media described below. Storage  may be used to store operating system , EXECs , data , application programs , and the like. Typically, storage  is a secondary storage medium (such as a hard disk) that is slower than primary storage. Information in storage  may, in appropriate cases, be incorporated as virtual memory in memory .","Processor(s)  is connected to multiple interfaces, such as graphics control , video interface , input interface , output interface , and storage interface . These interfaces are in turn connected to appropriate devices, as illustrated. In general, an input\/output (I\/O) device may be a video display, a track ball, a mouse, a keyboard, a microphone, a touch-sensitive display, a transducer card reader, a magnetic- or paper-tape reader, a tablet, a stylus, a voice or handwriting recognizer, a biometrics reader, another computer systems, or other suitable I\/O device or a combination of two or more such I\/O devices. Processor(s)  may connect to another computer system or to telecommunications network  (which may include network ) through network interface . With network interface , CPU  may communicate with network  in the course of performing one or more steps of one or more processes described or illustrated herein, according to particular needs. Moreover, one or more steps of one or more processes described or illustrated herein may execute solely at CPU . In addition or as an alternative, one or more steps of one or more processes described or illustrated herein may execute at multiple CPUs  that are remote from each other across network .","In particular embodiments, when computer system  is connected to network , computer system  may communicate with other devices connected to network . Communications to and from computer system  may be sent through network interface . For example, network interface  may receive incoming communications (such as requests or responses from other devices) in the form of one or more packets (such as Internet Protocol (IP) packets) from network  and computer system  may store the incoming communications in memory  for processing. Computer system  may similarly store outgoing communications (such as requests or responses to other devices) in the form of one or more packets in memory  and communicated to network  from network interface . Processor(s)  may access these communication packets stored in memory  for processing.","Particular embodiments include storage with one or more computer-readable media encoding computer-executable code for carrying out computer-implemented operations. The media and computer-executable code may be specially designed or created for particular embodiments or well known and available to a person having ordinary skill in the art. Examples of computer-readable media include, but are not limited to, magnetic media (such as hard disks, floppy disks, and magnetic tape), optical media (such as CD-ROMs and holographic devices), magneto-optical media (such as floptical disks), and hardware devices specially configured to store and execute code, such as application-specific ICs (ASICs), programmable logic devices (PLDs), and ROM and RAM devices. Examples of computer-code include machine code, such as code produced by a compiler, and files containing higher-level code that a computer may execute with an interpreter.","Computer system  may provide functionality as a result of processor(s)  executing software embodied in one or more computer-readable storage media, such as memory . Memory  may store software that implements particular embodiments, and processor(s)  may execute the software. Memory  may read the software from one or more other computer-readable media (such as mass storage device(s) ) or from one or more other sources through a suitable interface, such as network interface . The software may cause processor(s)  to carry out one or more processes or one or more steps of one or more processes described or illustrated herein. Carrying out such processes or steps may include defining data structures stored in memory  and modifying the data structures as directed by the software. In addition or as an alternative, computer system  may provide functionality as a result of logic hardwired or otherwise embodied in a circuit, which may operate in place of or together with software to execute one or more processes or one or more steps of one or more processes described or illustrated herein. Herein, reference to software may encompass logic, and vice versa, where appropriate. Moreover, reference to a computer-readable medium may encompass a circuit (such as an IC) storing software for execution, a circuit embodying logic for execution, or both, where appropriate. The present disclosure encompasses any suitable combination of hardware, software, or both.","The present disclosure encompasses all changes, substitutions, variations, alterations, and modifications to the example embodiments herein that a person having ordinary skill in the art would comprehend. Similarly, where appropriate, the appended claims encompass all changes, substitutions, variations, alterations, and modifications to the example embodiments herein that a person having ordinary skill in the art would comprehend."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
