---
title: System and method for range search over distributive storage systems
abstract: This invention pertains generally to a method for resolving and managing eventual consistency conflicts when using a Prefix Hash Tree (“PHT”) in which the underlying storage system is a Distributed Hash Table (“DHT”). An embodiment according to the within invention comprises a computer implemented method for resolving eventual consistency conflicts when using a PHT and DHT. The method includes using an algorithm to create a prefix hash tree that relates to a distributed hash table, the prefix hash tree having multiple nodes, wherein the nodes comprise leaf nodes and internal nodes, aggregating all distinct records across all conflicting nodes, wherein conflicting nodes are nodes that have identical data records, and counting records returned to obtain an aggregated record count; splitting the conflicting nodes that have the aggregated record counts that exceeding a max record count, such that the aggregated records are divided by a prefix into each new node, resulting in the consolidation of duplicate data that were in conflicting nodes into a single data record in a single node; and splitting conflicting nodes that are internal nodes regardless of the aggregated record count.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08924365&OS=08924365&RS=08924365
owner: WaveMarket, Inc.
number: 08924365
owner_city: Emeryville
owner_country: US
publication_date: 20110930
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION(S)","BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENT(S)"],"p":["This application claims the benefit of U.S. provisional application No. 61\/440,844, filed Feb. 8, 2011, which is incorporated by reference as if fully set forth.","This invention generally relates to computer network storage systems, and more particularly, to Prefix Hash Trees (\u201cPHT\u201d) used in conjunction with an underlying Distributed Hash Table (\u201cDHT\u201d) storage system for network applications and distributed databases.","During the past few years a revolution in scalable storage has been occurring. As the prevalence of web-based consumer services grows from e-commerce to social networking, there is an increasing demand for scalable storage systems that favor availability over consistency as contextually related to the Consistency, Availability and Partition Tolerance (\u201cCAP\u201d) Theorem. In particular, traditional database management systems (\u201cDBMS\u201d) that typically favor so-called Atomicity, Consistency, Isolation and Durability (\u201cACID\u201d) properties embodied through strong guarantees of transactional integrity are found to be lacking in terms of dynamic scaling. To address these concerns, there has been a movement toward so-called No Structured Query Language \u201cNoSQL\u201d systems, typically associated with so-called DHTs.","Although DHTs can provide significant improvement in terms of dynamic scaling, they are more limited in terms of the kinds of search operations they can support natively. An important aspect in the context of the within invention is range search. That is, the ability to retrieve a set of records in which a particular field falls within a pre-determined range, for example a search that finds all employees with a salary less than $70K.","Prefix Hash Trees (\u201cPHTs\u201d) support search operations including 1 dimensional range queries over a DHT. PHTs further support heap queries, proximity queries, and limited multi-dimensional search operations. PHTs are trie-based data structures, wherein each node has either 0 or 2 children. A leaf node stores a key and includes a label which is a prefix of the key. Each leaf node stores a threshold number of keys, and each internal node contains an amount of keys equal to at least the threshold number plus one. Each leaf node includes a pointer to the leaf nodes to its immediate left and right. Ramabhadran et al., Prefix Hash Tree An Indexing Data Structure over Distributed Hash Tables, University of California, San Diego, 2004.","Using a PHT allows for efficient range search in which the underlying storage system is a DHT. However the original PHT research left open a number of practical details relating to managing write conflicts that are unavoidable in a setting in which availability is favored over consistency. Particularly, the omitted details become apparent in environments in which writers of data records may be acting independently yet in conflict, on physically separate components of the underlying DHT. Fundamental defects in the original PHT research such as a write conflict render the research infeasible without modification.","Consistency in the traditional DBMS\/ACID sense is not a requirement of DHTs however \u201ceventual consistency\u201d is a requirement. Consistency in the traditional DBMS\/ACID sense refers to the fact that when user A inserts record R into a DBMS, user B will have to wait a short time for user A to complete their insert transaction prior to being able to access and see record R within the DBMS, that is the affected portion of the DBMS will be made unavailable to user B for a short period of time. Eventual consistency generally means that given a sufficiently long period of time over which no inserts or updates are sent by a user, it can be expected that during that time period, all inserts or updates will eventually propagate through the system and all the replicas will be consistent. For example, when user A inserts record R into a system, and for some time subsequent to this insert, user B may not see record R but user B will not be precluded from accessing the affected portion of the system. However, after some time period of update or insert inactivity, record R will have been replicated across the DHT system and going forward all future readers will see record R.","What is needed is a method for resolving the various types of conflicts that will arise in a system based on the DHT\/PHT algorithms associated with the underlying eventual consistency property of the underlying DHT.","An embodiment according to the within invention comprises a computer implemented method for resolving eventual consistency conflicts when using a PHT and DHT. The method includes using an algorithm to create a prefix hash tree that relates to a distributed hash table, the prefix hash tree having multiple nodes, wherein the nodes comprise leaf nodes and internal nodes, aggregating all distinct records across all conflicting nodes, wherein conflicting nodes are nodes that have identical data records, and counting records returned to obtain a count, if the count of aggregated records exceeds a max record count then splitting the nodes that have records that exceed the max record count, such that the aggregated records are divided by a prefix into each new node, resulting in the consolidation of duplicate data that were in conflicting nodes into a single data record in a single node, if one or more of the returned conflicting nodes is an internal node, the internal node is split regardless of the number of aggregated records.","Another embodiment according to the within invention further comprises a computer implemented method for resolving eventual consistency conflicts when using a PHT and DHT. The method includes reading a node by a user, the node having conflicting records entered by different users prior to the reading by the user, the conflicting records having different content but are written to a same node of the tree, resolving the conflicting data by forcing a node split.","Another embodiment according to the within invention further comprises a computer implemented method for resolving eventual consistency conflicts when using a PHT and DHT. The method includes reading a record from a node by a user, the record having data that the user desires to delete, marking the record for deletion by updating a delete-indicator within the record.","Another embodiment according to the within invention comprises a computer implemented method for resolving eventual consistency conflicts when using a PHT and DHT. The method includes marking the record with a delete-timestamp.","Another embodiment according to the within invention further comprises a computer implemented method for resolving eventual consistency conflicts when using a PHT and DHT. The method includes the steps of using a computer software program to inspect the delete-indicator, if the delete-indicator lists the record as to be deleted then delete the record.","Another embodiment according to the within invention further comprises a computer implemented method for resolving eventual consistency conflicts when using a PHT and DHT. The method includes the steps of using a computer software program to inspect the delete-timestamp, if the delete-timestamp falls within a pre-determined time frame then delete the record.","Another embodiment according to the within invention comprises a method for resolving eventual consistency conflicts within a prefix hash tree. The method comprises the steps of using an algorithm to create a prefix hash tree that relates to a distributed hash table, the prefix hash tree having multiple nodes, wherein the nodes are leaf nodes and internal nodes, obtaining a maximum tree depth of the prefix hash tree, obtaining a max record count for each node, aggregating all distinct records across all conflicting nodes, wherein conflicting nodes are nodes that have identical data records, and counting record returned to obtain an aggregated record count, obtaining the nodes that are related to a new record that is to be inserted beginning at a deepest node, inserting the new record into the deepest node that has an aggregate record count less than the max record count, then obtaining a next node upward; and repeating the insert process when the aggregate record count is less than the max record count and the aggregate record count of the next node upward is less than the max record count, otherwise end insertion of the new record.","Another embodiment according to the within invention comprises an eventual consistency resolution system. The system includes one or more of a plurality of servers and one or more of a plurality of program storage devices readable by machine such that the one or more of a plurality of program storage devices and the one or more of a plurality of servers are connected together to form a network, wherein the one or more of a plurality of program storage devices embodies a program of instructions executable by the machine to perform a method for eventual consistency resolution. The method includes using an algorithm to create a prefix hash tree that relates to a distributed hash table, the prefix hash tree having multiple nodes, wherein the nodes are leaf nodes and internal nodes. A maximum tree depth of the prefix hash tree is obtained and a max record count for each node is obtained. The nodes that are related to a new record that is to be inserted beginning at a deepest node then continuing upward in the prefix hash tree are obtained. It is determined if a deepest node has an aggregate number of records that equal max record count. If the deepest node has an aggregate record count less than max record count then the new record is inserted into the deepest node and a next node upward is gotten, and it is determined if the aggregate record count is less than max record count. If the aggregate record count of the next node upward is less than max record count the insert process is repeated, otherwise insertion of the new record is ended.","The above and yet other objects and advantages of the within invention will become apparent from the hereinafter set forth Brief Description of the Drawings, Detailed Description of the Invention, and Claims appended herewith.","A PHT is a non-trivial, multi-node data structure built on top of a DHT. It is well known within the industry that building multi-node data structures on top of a DHT must be handled carefully, since DHTs typically only offer eventual consistency, which can make performing operations against the data structure non-trivial.","In an environment supporting only eventual consistency, conflicts will ultimately arise. The nature of these conflicts typically relates to conflicting data associated with a particular node which is associated with a given prefix. Where a conflict is observed is a property of the underlying DHT. However, a data conflict is generally observed during a read operation in a typical DHT implementation. That is, previous to the read, two or more clients have successfully written conflicting data to a data store associated with a particular node. When the read occurs, the conflicting data associated with the node is returned.","An embodiment according to the within invention preferably comprises a PHT Tree and Leaf structure. In the within Application, PHT Tree and Leaf Structure will also be referred to as a \u201cPHT data structure\u201d or a \u201cdata structure.\u201d The PHT Tree and Leaf structure is a binary Trie, also referred to as a Prefix Tree in which abstract nodes are associated with a prefix of index values in binary representation. Abstract nodes are mapped to DHT nodes via a pre-defined hash function applied to an abstract node prefix. In the PHT Tree and Leaf structure, RECORDs are only stored in LEAF nodes, not in INTERNAL nodes.","An embodiment according to the within invention comprises a primary operation wherein the primary operation is an \u201cINSERT(Record r).\u201d In this operation, a RECORD is inserted into a data structure. The RECORD includes a KEY k that is mapped into a set of binary strings of length D. A unique id associated with the entered RECORD is returned.","As records are added to a PHT, a LEAF node can reach a critical size then it is SPLIT. A SPLIT operation comprises translating the LEAF node into an INTERNAL node and creating two or more descendent nodes in which newly created LEAF nodes have both the pre-existing RECORDs and the newly added RECORD.","Referring to  that illustrates a PHT SPLIT operation according to an embodiment of the invention, an initial state of an INTERNAL node  having an index value of 001 is associated with 2 LEAF nodes, a LEAF node  having a prefix index value of 0010 and a LEAF node  having a prefix index value of 0011, however other prefix index values can be used. A MAX record count  is the maximum number of RECORDS that a LEAF node can have. In  the MAX record count  associated with the PHT is set at 2 records, however other values greater than or less than 2 can be used. When a user request or a system utility request is issued to add a new record , the MAX record count , is checked to determine if the LEAF node has reached its record limit. In  the new record has a value of 0010 0101 0110 and should be inserted into LEAF node  having an index of 0010. However LEAF node  has previously reached its MAX record count of 2 resulting in LEAF node  having to be translated into a new INTERNAL node  with two newly created descendent LEAF nodes associated with INTERNAL node , LEAF node  and LEAF node . According to an embodiment of the within invention, upon an INSERT operation for a LEAF node that has already reached its MAX record count  limit, in this example 2, a new INTERNAL node  is created under INTERNAL node . LEAF node  having index value 001 is split into 2 new LEAF nodes to be stored under new INTERNAL node . The new LEAF nodes are LEAF node  having an index value of 00100 and LEAF node  having an index value of 00101. The previous records 0010 0011 1010 and 0010 1010 0010 that were stored in LEAF  having an index value of 0010 are now split between new LEAF node  and new LEAF node . New record  is inserted into LEAF node  and new LEAF node  contains available space for any future insert request since MAX record count  remains set at 2.","PHTs and other multi-node data structures are susceptible to irrecoverable failure in high-availability environments. In particular, write conflicts on a particular node will happen, and these conflicts need to be resolved correctly in order to avoid permanent data loss. An embodiment according to the within invention comprises a method for managing write processing and any subsequent conflicts that may occur.","The PHT data structure and multi-node data structures using index ordering includes three principle properties that are stored permanently within the DHT substrate: node-state such as LEAF, INTERNAL and EMPTY, record-membership such as a list of records attached to a LEAF node or any node, and adjacency.","Decoupling the process of updating these properties on an INSERT operation may involve one or more SPLIT operations, which alleviates the potential for node read conflicts and simplifies the process of resolving conflicts when they do occur.","Instead of populating only the current LEAF node with a new record on an INSERT, a novel method is to populate all nodes starting at the maximum tree depth going upward in the tree toward the ROOT node stopping at a point where the number of records reaches a critical density. This method advantageously avoids having to move or migrate records in the process of a node split.","Referring to  an example is illustrated of a PHT Tree and Leaf structure before record insertion according to an embodiment of the within invention. Max record count  is 5. This means that no node can have more than 5 records. The tree has a Max depth  of 6. Only the deepest nodes  of the tree are illustrated within . By way of example, writer A issues an INSERT(Record r) operation for record \u201c0010 1001 1001\u201d which will go into LEAF node  having a key of \u201c001010.\u201d Record \u201c0010 1001 1001\u201d is first inserted in LEAF node , processing continues by recursively inserting record \u201c0010 1001 1001\u201d up the tree, inserting the record to each parent node until a node that has its Max record count  equal to 5. In  record \u201c0010 1001 1001\u201d will be added in LEAF node  having a key of \u201c001010\u201d and LEAF node  having a key of \u201c00101.\u201d","Additional primary operations associated with a PHT according to an embodiment of the within invention is Set<Record>RANGE_SEARCH (T start, T end, long max) which is a search for records where KEY k lives in the index interval (T start, T end) where T represents an index value associated with the search, and returns no more than max records which is a count of records, and List<Record>NEAREST_NEIGHBOR_SEARCH (T center, long max), which is a search for records ordered by distance from a center index where T represents an index value associated with the search, this search also returns no more than max records which is a count of records.","According to an embodiment of the within invention a PHT is configured to allow for an efficient range search of RECORDs against a particular field associated with that RECORD. The field searched is indexed and referred to as a KEY. The KEY has values in some ordered set T with a metric such as an interval (0.0, 1.0) in real numbers that can be mapped in a natural way into a set of binary strings of length D. D is configurable and is associated with the size of the KEY space.","Due to the nature of data that is typically used in range search applications and in particular applications that are applying proximity in 2 dimensions associated with physical locations, so-called \u201chot spots\u201d can occur where there is an unusually high density of keys in a particular small range. Additionally when dealing with physical locations it is possible to get a large number of records associated with a particular precise location such as the location of a shopping center having many stores or a sports arena having many teams.","For this reason a novel method is required when dealing with records having duplicate keys. According to an embodiment of the within invention when determining if a LEAF node is FULL, records associated with a duplicate key are not counted. That is, if a LEAF node is considered FULL when it contains N records, then in making this determination only DISTINCT key values are considered when counting the records. However, should it be necessary for a particular application, a method of storing the set of duplicate keys and their data values separately using an auxiliary indexing scheme can be used. That is, a sole record in the PHT data structure for a set of duplicate key records can be a pointer to auxiliary storage for this set of records.","As stated previously, when performing a SPLIT on a PHT LEAF node, conflicts can sometimes occur in terms of whether a particular node is a LEAF node or an INTERNAL node, and if it is a LEAF node what records are contained in that node. This can happen, for example, when conflicting writers perform INSERTS on separate parts of the underlying DHT and the conflict is observed only after the writes have completed back to the respective callers.","Conflicts can be detected internally within the DHT, either on subsequent internal writes occurring after the DHT has returned to the caller or during an internal \u201chouse cleaning\u201d process, such as an operation involving Merkle trees. The DHT is also typically responsible for resolving so-called \u201ccausal\u201d conflicts where it is clear that one write occurred after an earlier write and that the caller had access to information associated with this causal nature. In some systems this type of causal detection is managed through vector clocks.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 3","b":["301","302","303","301","302","304","305","301","301","301"]},"This process can be proven to be effective against corrupting the PHT tree structure. However when searching for a LEAF node using binary search, it may happen that a read on a node incorrectly returns an EMPTY value leading to the binary search to land incorrectly on an INTERNAL node. This can be resolved by simply retrying the binary search.","It is possible that a record can become orphaned on an INTERNAL node. If a binary search or cached LEAF values are used by clients, it may be the case that this INTERNAL node is never revisited, and thus the conflict is not resolved and the written record remains orphaned.","This is a fairly mild defect and occurs only under fairly artificial behavior, but it is possible. To resolve this potential defect, a number of things can be done, including replacing a binary search or LEAF value caching with a linear search beginning at the ROOT node. Additionally a complete tree scan can be performed periodically, looking for conflicting reads since this will detect an orphaned record, and the above process will resolve the conflict.","In many applications, KEY density can be highly non-uniform. That is, many keys can be associated with a narrow range of key space, and possibly many records can be associated with the same identical key. For example, keys can be associated with physical locations, such as a pizza shop that operates under a single name having many locations. When dealing with duplicate keys, it is preferable to avoid generating multiple RECORD objects in the PHT that are associated with every inserted RECORD.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 4","b":["401","403","403","401","403","1","1","402","404","404","405","406","405","407","408","409","404","407","407","405"]},"A primary operation associated with a PHT according to an embodiment of the within invention is a Boolean DELETE (long id) which deletes the associated record from an index.","Any general purpose data store must support a DELETE capability. Typically when employing a complex data structure such as a b-tree or trie, the inserting of records into leaves and the resulting splitting of nodes is seen as a symmetric operation. As records are deleted, descendent nodes can be merged and this process can occur recursively up the tree toward the ROOT node.","Unfortunately this process becomes unwieldy when managed within an environment supporting only \u201ceventual consistency\u201d from the key\/value store perspective. To overcome this, an embodiment according to the within invention preferably avoids actually removing records upon delete, and instead simply marks them for deletion. This process can include a timestamp, and at some later date a periodic process can be used to reclaim records marked for deletion. The existence of a timestamp dramatically reduces the risk of conflict or data loss.","According to an embodiment of the within invention when records are marked for deletion, the records are not immediately removed. In the event that two writers conflict, and one intended to delete a record, the conflict resolution process will have no way to know that the delete was intentional. To overcome this issue the record is marked as deleted as opposed to restructuring the tree. By marking it as deleted, the delete intention will be clear and the conflict can be resolved. This advantageously allows timestamps associated with the deletion flag to be used for later \u201cgarbage collection\u201d, thereby removing deleted records that have been flagged for a certain minimum time. Records marked for deletion are simply ignored rather than restructuring the tree.","An embodiment according to the within invention comprises avoiding MERGING of nodes. In many application domains it is entirely practical to leave under-populated or empty LEAF nodes in place, having an end result of trading efficiency for enhanced stability. In certain instances and application domains this may not be practical. In such a case marking a record for deletion with timestamp, can effectively be used.","The merging of nodes can be the source of a number of types of data corruption in the PHT data structure under the normal circumstances of a DHT. A solution is not to merge nodes. Under many real-world scenarios, not merging is OK since records can be removed or marked as deletions. There is nothing structurally wrong with a PHT having empty LEAF nodes.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 5","b":["501","502","503","504"]},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 6","b":["601","602","603","604","605","601","602","603"]},"Having described embodiments for a system and method for range search over distributive storage systems, it is noted that modifications and variations can be made by persons skilled in the art in light of the above teachings. It is therefore to be understood that changes may be made in the particular embodiments of the invention disclosed which are within the scope and spirit of the invention as defined by the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWING(S)","p":["The foregoing Summary as well as the following detailed description will be readily understood in conjunction with the appended drawings which illustrate embodiments of the invention. In the drawings:",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
