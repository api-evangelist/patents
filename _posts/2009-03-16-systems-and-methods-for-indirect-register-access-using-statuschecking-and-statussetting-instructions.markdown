---
title: Systems and methods for indirect register access using status-checking and status-setting instructions
abstract: The present invention broadly contemplates braids and fibers, high-level programming constructs which facilitate the creation of programs that are partially ordered, to address the continuing trend of ever-increasing processor speeds and attendant increases in memory latencies. These partial orders can be used to respond adaptively to memory latencies. It is shown how these constructs can be effectively supported with simple and inexpensive instruction set and micro-architectural extensions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09003169&OS=09003169&RS=09003169
owner: International Business Machines Corporation
number: 09003169
owner_city: Armonk
owner_country: US
publication_date: 20090316
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION","GOVERNMENT INTERESTS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENTS","APPENDIX","REFERENCES"],"p":["This application is a divisional application of U.S. patent application Ser. No. 10\/959,609, filed Oct. 5, 2004, issued as U.S. Pat. No. 7,516,306 on Apr. 7, 2009, which is incorporated by reference as if fully set forth herein.","This invention was made with Government support and under contract no. NBCH3039004 awarded by DARPA. The Government has certain rights in this invention.","The present invention relates generally to instructions and operations configured for response to latencies.","Herebelow reference is made to several references that are listed near the close of this disclosure. Thus, numerals in brackets ([1], [2], etc.) are intended to refer to references in that list.","As processor speeds continue to increase at a much higher exponential rate than DRAM speeds, memory latencies will soon exceed 1000 cycles. With such non-uniform access times, the flat memory model that was made practical by deeply pipelined superscalar processors with multi-level cache memories will no longer be tenable due to the inexorable effects of Amdahl's Law. The most common approach to this problem is hardware multi-threading, but multi-threading requires either abundant independent applications, or well-parallelized monolithic applications, and neither is easy to come by.","In U.S. Pat. No. 6,308,261 (\u201cComputer System Having an Instruction for Probing Memory Latency\u201d), as well as European Patent Nos. EP 0933698A2 (\u201cProbing Computer Memory Latency\u201d) and EP 0933698A3 (\u201cProbing Computer Memory Latency\u201d), Dale C. Morris and Douglas B. Hunt have proposed to maintain availability status for registers in a computer system, wherein the availability status indicates whether an instruction attempting to read a particular register (which can be the destination of a memory load instruction) will stall. A memory probe instruction can be used to alter the program execution path based on the availability status of one or more of the registers. In one embodiment, a latency probe instruction retrieves the availability status of a register to another register so that a conditional branch instruction can determine the program execution path based on the availability status. In another embodiment, a conditional branch instruction can query the availability status of a register directly to determine the program execution path. Conceptually, the availability status is the same as the presence bit used in I-structures [1] or tagged memory.","A need has been recognized in connection with providing a more broadly applicable and more effective approach than in conventional arrangements such as those contemplated by Morris and Hunt and by others.","In accordance with at least one presently preferred embodiment of the present invention, there are broadly contemplated herein braids and fibers, high-level programming constructs which facilitate the creation of programs that are partially ordered. These partial orders can be used to respond adaptively to hardware latencies. It is shown how these constructs can be effectively supported with very simple and inexpensive instruction set and microarchitectural extensions. Braiding is much simpler than parallelizing, but yields many of the same benefits. Braided versions of a number of important algorithms, including quicksort the mark phase of a garbage collector, have been developed. The braided code is easy to understand at the source level, yet can be translated into highly efficient code using hardware extensions in accordance with the present invention.","In summary, one aspect of the invention provides computer instruction set architecture comprising: an inquiry instruction for making an inquiry of at least one characteristic of at least one operation; wherein at least one of the following is performed in connection with the operation: (a) the inquiry is made without the at least one operation being performed; (b) if the at least one characteristic satisfies at least one condition, the at least one operation is performed; yet if the at least one characteristic does not satisfy the at least one condition, the at least one operation is not performed and the at least one characteristic of the at least one operation is reported; (c) if the at least one characteristic satisfies at least one condition, the at least one operation is performed; yet if the at least one characteristic does not satisfy the at least one condition, the at least one operation is performed in an alternate mode that does not block subsequent operations from being executed; and (d) the inquiry is made after the at least one operation is performed.","A further aspect of the invention provides a computer system comprising a processor and a prediction mechanism; the prediction mechanism being adapted, upon receiving an inquiry from the processor, to provide an estimate of at least one characteristic of at least one operation without executing the at least one operation.","Yet another aspect of the present invention provides a process comprising the steps of: generating an address of an operand; inquiring as to whether the operand is available for reading or writing; performing one of the following: (a) if the operand is available, performing an operation immediately; (b) if the operand is not available, recording the operand in a data structure and issuing an operation intended to make the operand available after a predetermined time.","Furthermore, an additional aspect of the invention provides a process comprising the steps of: generating the address of an operand, performing one of the following (a) and (b): (a) employing a split-phase operation to attempt to read or write the operand; (b) determining whether a split-phase operation will succeed or fail; performing one of the following (c) or (d): (c) if a split-phase operation succeeds, or it is determined that a split-phase operation will succeed, repeating the generating step after performance of a split-phase operation; (d) if a split-phase operation fails, or it is determined that a split-phase operation will fail, recording in a data structure either an address or other information related to a split-phase operation; consulting a data structure to determine whether a deferred split-phase operation has completed; performing one of the following (e) or (f): (e) if a deferred split-phase operation has completed, extracting information from the consulted data structure and repeating the generating step; (f) if a deferred split-phase operation has not completed, either: waiting for a deferred split-phase operation to complete; or performing other operations until a deferred split-phase operation has completed and then repeating the generating step.","For a better understanding of the present invention, together with other and further features and advantages thereof, reference is made to the following description, taken in conjunction with the accompanying drawings, and the scope of the invention will be pointed out in the appended claims.","It should be appreciated herethroughout that the inventive constructs broadly contemplated herein are applicable both to hardware and software environments. Specific reference will be made to one environment or the other as needed. Otherwise, it may be assumed that both environments are contemplated (where appropriate).","Generally, there is broadly contemplated in accordance with at least one presently preferred embodiment of the present invention systems and arrangements considerably different from and more effective than those presented by Morris and Hunt. Particularly, for a memory load instruction, in Morris & Hunt's method, the load operation is always performed. In accordance with an embodiment of the present invention, however, the load operation may not be performed at all if the predicted latency is long (for example, the data is not cached in an on-chip cache).","For a memory load instruction that causes long latency, in Morris & Hunt's method, some status register is set properly once the data becomes available for use. In accordance with an embodiment of the present invention, however, it is possible that no status flag (observable to software) will be set when the data becomes available (in this case, the software can use the query instruction again to check to see if the data is available).","In Morris & Hunt's method, an availability status is associated with an architecture register. In accordance with an embodiment of the present invention, there is no such constraint. This provides enormous flexibility. For example, in accordance with an embodiment of the present invention, a query instruction can be used to check the latency of a memory barrier instruction (which does not write to any architecture register, but may experience very long latency).","In Morris & Hunt's method, an availability status indicates whether the data is available or not. With a cache miss, the software would not be able to tell how long it is likely to take before the data is available. In this case, only after the data becomes available will the software be notified (the software need to poll the availability status). In accordance with an embodiment of the present invention, however, a latency inquiry instruction can receive the expected latency of a memory load operation. For example, the latency prediction mechanism can tell the software if the data is on-chip or not within a short period of time (well before the data becomes available). It is worth noting that, even though the data is not available, a prediction of how long it will take to receive the data (e.g. whether the data is cached on-chip or not) can be very useful to software. In the case of short latency, it may be preferably for software not to jump to another task (especially in the presence of out-of-order execution).","High performance uni- and multi-processors have for many years been designed to present a flat memory abstraction to the programmer. This greatly simplifies the programming model, and works well as long as caches are able to hide memory system latency. However, this abstraction is beginning to break down due to current technological trends in which the memory hierarchy is becoming ever deeper while the relative speed of the processor to the memory continues to increase. Latencies for main memory accesses will soon exceed 1000 cycles.","Techniques like prefetching have been used successfully to hide significant amounts of latency, but prefetching only works well for highly predictable programs. Ultimately, as the performance of the memory system becomes more and more non-uniform, such approaches to tolerating latency will no longer function. One needs ways to adaptively avoid latency and do other work.","If one goes to a restaurant and there is a line, one is given an estimate of the length of time one will have to wait. If one calls a customer service and all their operators are busy, one receives an automatic estimate of the amount of time one will have to remain on hold. Explained in these practical, real-world contexts, it seems highly apparent that one ought to find out how long a variable, potentially lengthy delay will take. A high-level programming model that allows programs to respond to long latencies by performing other work while high-latency operations are in progress is now presented.","The fundamental approach is to divide the program into fibers, which are sections of sequential code that can be interleaved in a partial order. Although fibers are partially ordered with respect to each other, each individual fiber executes sequentially. This greatly reduces the conceptual complexity of the programming model, since the programmer must not worry about locking or arbitrary interleaving of parallel threads. Instead, the interleaving occurs at intuitive points that are specified and controlled by the programmer. A collection of fibers with the same scope of execution is called a braid. Braids are object-like abstractions, and fibers are method-like abstractions.","After presenting the high-level abstractions and an example algorithm that uses them, the extensions to the hardware and instruction set architecture that are required to support braided code will be presented. The fundamental hardware abstractions are inquiring operations and split-phase operations, which return information about potentially lengthy instructions instead of blocking and waiting for the result. They allow the program to respond adaptively and perform other work while waiting for the operation to complete (for instance, waiting for the loading of a memory location into the cache, or the computation of an address translation).","To allow efficient interaction between software and hardware resources, the hardware associates memory transaction identifiers with in-flight operations. The software can then poll for completion, typically when some other memory operation is deferred. A number of braided algorithms, and examples of the corresponding compiled code that makes use of our instruction set extensions, are presented herein.","The balance of the instant disclosure is organized as follows: the high-level-language constructs for expressing braided code are presented, the instruction set architecture (ISA) extensions are presented, how the ISA extensions can be implemented inexpensively at the micro-architectural level are presented, and a number of braided algorithms are presented. An Appendix (relating to ) presents the compiled code for a simple braided program. Finally, related work will be discussed.","Programming Constructs","A set of high-level language constructs for expressing latency-adaptable programs will now be described. In subsequent sections the necessary instruction set architecture (ISA) and micro-architecture enhancements to support these constructs will be described, and it will be shown how the constructs can be efficiently compiled to the extended ISA.","Fundamentally, a program that is able to adapt to memory latency must defer some portion of its work while necessary data is being fetched. To do this it must be able to operate on a partial order over its data. Therefore, the programmer must give up explicit control of the ordering of some operations in exchange for higher performance.","Explicit Programming for Availability","The fundamental primitive notion that allows programmers to express latency-dependent partial orders is that the program can inquire whether an object is in local memory before committing to perform some work on that object. The exact definition of \u201clocal memory\u201d can be implementation-dependent, but the difference between \u201clocal\u201d and \u201cnon-local\u201d should be large. For instance, \u201clocal\u201d might be on-chip L1 or L2 caches while \u201cnon-local\u201d might be off-chip L3 cache or DRAM memory.","Statements that query for memory locality are called inquiring operations. There are two inquiry operators, which take an expression and return true if it is possible to read or update the expression (typically something like a C lvalue) \u201cnow\u201d\u2014that is, with minimal delay.","The syntax of these unary boolean operators is",{"@attributes":{"id":"p-0049","num":"0048"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"readnow expr"]},{"entry":[{},"updatenow exp"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"They are typically used in conditional statements, for instance",{"@attributes":{"id":"p-0051","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (readnow a[i])"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"process(a[i]);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"enqueue(a[i]);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The want statement (presented for completeness, and not part of the present invention) is a declaration that the program intends to use a memory location in the near future; it is essentially a prefetching declaration.","To see how the inquiry and prefetch operators can be used to program explicitly latency-adaptive computations, consider the simple example of histogram calculation, as shown in . This function iterates over an array of values, and for each value increments an associated \u201cbucket\u201d in the histogram array. The iteration over the array of values is sequential, and memory latencies may be avoided by the hardware caching and prefetching mechanisms. However, the updates to the histogram array could be completely random. If the histogram array is too large for the cache, the program will suffer a cache miss on a very high percentage of the histogram updates. If the penalty for a miss is large, the slowdown will be dramatic.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 2"},"With the appropriate tuning of the queue size, most accesses will hit in the cache. However, tuning the queue size is tricky: if it is too small, the function will try to update the queued histogram elements before they have been prefetched. If it is too large, the prefetched elements will already have been evicted again by the time they are processed.","Programming with Braids and Fibers","While explicit use of inquiring operations, as illustrated above, is sometimes useful, the need for the user to tune the queue size also illustrates a potential weakness of the approach. Therefore, it is desirable for the system (including the hardware, the compiler, and the run-time system) to manage the work queue of outstanding work implicitly.","In order to do this, the program must be broken up into units that can execute out-of-order. We call these units fibers, since they behave somewhat like very fine-grained threads. The fundamental abstraction over fibers is the braid. Intuitively, with our braid construct, one can think of the fibers as being attached at the beginning and end of the braid, but freely intertwined between the two ends.","The major difference between braiding and other fine-grained multi-threading abstractions is that at execution time there is a well-defined total order of high-level operations. Programmers therefore do not need to concern themselves with the complexities of concurrency and synchronization, but only with specifying a relaxed ordering in which the high-level functions of the program can occur.","Furthermore, since all of its component fibers must terminate for a braid to terminate, braids provide abstraction over concurrency: two successive braids can be viewed as completely sequential at the macro level. Any internal concurrency in either braid will never have any effect on the operation of the other braid.","A braid is declared as a special type of class, and a fiber is declared as a special type of method.","A braid defines a set of braid instance variables. Inside of a braid, the only variables accessible are the braid instance variables, local variables, and formal parameters of methods. The braid class may define static variables, but they must be constants (for instance, final pointers to mutable objects are not allowed). A braid's instance variables are not accessible outside of the braid. This includes other braids of the same class; therefore, the instance variables are not private in the Java sense of the term.","Braids are scoped and block-structured: they are created with the braid statement, which creates a braid object and executes the associated fibers with the braid; braids may not be created with the new operator. The braid statement terminates when the main control fiber all deferred fibers of that braid have terminated. Braid objects can be passed as parameters and stored in other objects, but once terminated any attempt to invoke a braid method will raise a BraidTerminated exception.","It is easiest to explain braids in the context of an example.  shows a braided version of the histogram calculation. The histogram calculation is encapsulated in a braid class named Histogram. It has a normal constructor, which takes the value and histogram arrays as parameters, but it runs in the context of its own braid, so it may spawn fibers.","The fiber method UPDATE( ) takes two parameters: an integer lvalue and an integer index. Since lvalue is a update parameter, the fiber is only executed if the parameter satisfies the updatenow predicate. Since index is a use parameter, its value is made available inside the fiber. Note that since lvalue is not declared as use update, it is actually not in scope inside of the fiber. By convention, fiber names are all upper case to emphasize fiber calls.","Fibers are coroutine scheduled: a fiber either runs immediately if all of its read and update parameters are available, or it is deferred. If a fiber is deferred, other previously deferred fibers may run. Thus any fiber within the braid may run at any fiber call point, or at the end of the braid, but nowhere else. Furthermore, fibers execute atomically until they terminate or until they make another fiber call. Semantically, each fiber runs with its own stack. Elimination of separate stack, store of return address, and inlining are all optimizations of the basic model.","The braid statement in the computeHistogram( ) method (which is part of some other class) creates a braid scope, instantiates the braid class object of type Histogram within that scope, and executes its constructor. The Histogram object is not bound to any variable since there are not any meaningful operations that can be performed on it once it terminates. However, within the braid the object can be referred to normally using the this reference, which can be stored in stack or heap variables of arbitrary lifetimes.","Programmers should attempt to use as few use parameters to fiber methods as possible. Values that are constant during the execution of the braid should be stored in final braid instance variables, and when it does not involve extra computation on the fast (non-deferring) execution path, multiple objects should be consolidated. For instance instead of passing three variables in this braided hash table insertion:",{"@attributes":{"id":"p-0068","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int i = hash(key);"]},{"entry":[{},"INSERT(table[i], key, value);"]},{"entry":[{},"."]},{"entry":[{},"."]},{"entry":[{},"."]},{"entry":[{},"INSERT (update Nod Head, Key key, Val val) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Nod n = new Nod(key, val)"]},{"entry":[{},"n.nxt = head;"]},{"entry":[{},"head = n;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"It is more efficient to pass a single Nod object that contains both the key and value pointers, since this operation is performed anyway if the INSERT( ) method is executed immediately:",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int i = hash(key);"]},{"entry":[{},"Nod n = new No"]},{"entry":[{},"INSERT(table[i], n);"]},{"entry":[{},"."]},{"entry":[{},"."]},{"entry":[{},"."]},{"entry":[{},"INSERT (update Nod Head, Nod nod) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"n.nxt = head;"]},{"entry":[{},"head = n;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Using these types of optimizations, the histogram example can easily be optimized to run with only a single word of stored state per deferred fiber.","The break braid statement can be used to terminate the current braid block and abort any pending fibers. Note that since fibers execute sequentially, there is no danger of a break statement asynchronously interrupting a running fiber\u2014the only fiber that it interrupts is the one which itself issues the break braid statement.","Instruction Set Architecture","In this section the extensions to the instruction set architecture to support the approach of the present invention is described. To make the design concrete, the ISA is presented as an extension to the 64-bit IBM POWERPC [10] architecture, but the same principles can be applied to any modern instruction set architecture.","As with all instructions that address memory, the issue of which addressing modes to support is an issue with our memory instructions. This issue is abstracted by simply presenting instructions that take an address as a parameter. There could be as few as one addressing mode per instruction or as many as are supported by all the various load\/store instructions in the machine ISA. Which addressing modes to support is primarily a tradeoff between orthogonality and instruction set encoding space.","Inquiring Memory Operations","An inquiring memory operation is one that finds out whether a given address can be accessed in a timely fashion. This is in contrast to the informing memory operations of Horowitz et al. [3], which inform the program how long a memory operation has taken once it completes. An inquiring memory operation returns some state information about the memory location in question, which can subsequently be used for conditional execution of loads and stores.","The POWERPC instruction set [6] already contains prefetch instructions, called Data Cache Block Touch (dcbt) and Data Cache Block Touch for Store (dcbtst). These instructions generate speculative loads of the cache line containing the effective address of the instruction. We will model our instruction set extensions as further \u201cdata cache block\u201d operations.","In keeping with POWERPC architecture conventions, a condition register (CR7) is assigned to hold the outcome of inquiring memory operations. An alternative implementation would be to have a completely separate set of memory query condition registers. Separating the memory query results may be beneficial for branch prediction, which may be more accurate if memory-dependent branches are treated differently.","Since the condition register is four bits wide, the following meanings can be assigned to the condition register fields:\n\n","Obviously, there are many levels of detail at which latency information could be provided, from a single bit (\u201cavailable\u201d or \u201cnot available\u201d) to a number estimating the number of cycles required. Herein we present a preferred embodiment making use of the POWERPC's condition register architecture.","The simplest inquiring instruction simply asks whether the data at the given address is available. There are two variants: one for reading and one for writing. The latter is primarily for multiprocessor systems, where the operation of the cache-coherence protocol may delay a write. Query operations which return \u201cavailable\u201d may optionally prefetch the data into the L1 cache or pipeline the data to the CPU.","In the simplest incarnation of inquiring memory operations, only two instructions need to be added to the ISA (dcbq and dcbqst with one addressing mode each). These are shown in . The dcbq instruction performs a data cache block query: that is, it determines what the cost of accessing the data cache block containing the effective address is likely to be. The dcbqst does the same for a write rather than a read operation. Generalizations include multiple addressing modes and combined query\/load instructions that perform the load operation if the data is available.","Split-Phase Memory Operations","Split-phase memory operations allow the software to initiate a load or store and be notified semi-asynchronously when the resources are available to perform it. The notification is semi-asynchronous because the hardware asynchronously sets a flag indicating that the data is available, but the software must poll for this condition.","To support split-phase memory operations, the hardware maintains a memory transaction register (MTR), which is assumed to be the same size as the architected register size, in the present case 64 bits. Each bit in the MTR may be associated with a split-phase memory operation, and if so associated, indicates whether or not the memory is available (1) or not available (0).","The MTR may be read by the program but may not be written directly. Instead, split-phase memory operations on data that is not immediately available are associated with a particular memory transaction identifier (returned in a general purpose register). When the data becomes available, the bit indexed in the MTR by the returned GPR value is set.","The MTR can be examined by the program. Memory transaction identifiers must also be freed explicitly by the program, but may not be immediately usable depending on the hardware implementation (in particular, if a transaction identifier is freed while a memory transaction is in progress, the hardware may not make the freed MTR transaction identifier usable until the transaction completes).",{"@attributes":{"id":"p-0086","num":"0088"},"figref":"FIG. 5"},"The dcbp (Data Cache Block Prepare) and dcbpst (Data Cache Block Prepare for Store) instructions begin split-phase memory operations. If the data is already available, they act like their corresponding query operations. However, when the data is not available the hardware allocates a memory transaction identifier, which is an index into a bit in the MT R. This bit will eventually be set to 1 when the data becomes available. The program can therefore save a small amount of state indexed by the transaction identifier number and periodically poll for completion. When the operation completes, it can branch to a handler and use the saved state to perform a deferred operation.","The dcbpst instruction is almost identical, except that the prepares for a store operation. This causes the cache line containing [addr] to be obtained in exclusive mode instead of shared mode. On a uniprocessor, dcbpst has the same functionality as dcbp.","The POWERPC architecture defines a variety of special-purpose registers (SPRs), and instructions to read and write these registers. The memory transaction register (MT R) can only be read; it may not be written directly, although there can be instructions which modify its state indirectly.","The Move From Memory Transaction Register instruction loads a copy of the current state of the MTR into a general purpose register, as shown in ). Once the contents of the MTR are in a general purpose register, standard ALU instructions are used to determine the course of action. Common cases are comparing the MTR contents to 0 to determine whether any data has become available, and using the count leading zeros (CLZ) instruction to get the index of the first memory operation which has become available.","Once a split-phase memory operation has been completed, the associated transaction identifier should be freed for re-use by subsequent split-phase operations. There are two forms: the mtrfree instruction releases a single memory transaction identifier named by a GPR, as shown in ).","The mtrclr instruction shown in ) releases all memory transaction identifiers and may be used at context switches when software is not prepared to handle transaction identifiers generated by other contexts. In this case it is the software's responsibility to either complete or re-initiate the split-phase operations when the context resumes execution.","There may be some delay between the freeing of a transaction identifier by software and its availability for re-use, especially if the transaction identifier is freed before the corresponding memory operation is complete.","In the event that multiple methods, threads, or processes are simultaneously issuing split-phase operations, it may be helpful for the application to determine how many split-phase operations can be issued before there are no more available transaction identifiers. If this is the case, the number of available transaction identifiers can be obtained by loading the MTR into a general purpose register and then counting the number of 0 bits in the register with the Count Zero Bits (cntzb) instruction shown in ).","A set of new instruction mnemonics can be added for branch instructions based on the outcome of inquiring memory operations. These assembler mnemonics are shown in .","Microarchitecture Support","The implementation of the instruction set extensions at the micro-architectural level in accordance with the present invention will now be described. To make the design complete, it is described in terms of the micro-architecture of the IBM POWER4 chip [11], since it represents an aggressive design for which documentation is widely available. Clearly the design of the present invention is predicated on delay characteristics of future processor generations, but it is expected the implementation to remain largely the same.","At the micro-architectural level, the inquiring instructions (dcbq and dcbqst), split-phase prepare instructions (dcbp and dcbpst), and memory transaction register instructions (mtrfree and mtrclr) primarily interact with the Load Miss Queue or LMQ. In general, the hardware is free to take advantage of the fact that these operations are designed to improve performance, so a certain amount of imprecision may be tolerated (although this should not be abused, as it will otherwise negate the effect of the optimizations). Thus the inquiry operations that set the EQ (memory available) bit and the LT,GT (memory delay) bit pair in the condition register are to some extent free to return arbitrary results. However, the hardware should err on the side of conservatism: it is better to report that a few in-cache data are not in cache, which will lead to spurious delay of work, than to report that out-of-cache data are in cache, which will lead to processor stalls.","Similarly, since bits in the MTR are set asynchronously by the hardware, the state of the MTR as observed by the program may be out-of-date with respect to completed transactions (but not with respect to freed transactions). This fact may be exploited by the implementation to avoid branch mis-predictions based on the MTR value by eagerly executing the mfmtr instruction. The only absolute restriction is that available data must eventually be detected by the program, but in practice it should be detected as soon as possible.","The number of memory transaction identifiers is implementation-dependent, anywhere from 0 to 64. It will generally be less than the number of LMQ entries.","Supplying Memory Latency Information","A cache directory may be placed physically closer to the processor than the corresponding cache data array. This allows directory information to be accessed faster to reduce the overhead of latency inquiry operations. For example, the processor chip may contain the directory of the L3 cache, but not the data array of the L3 cache.","In addition, cache latencies need not be distinguished if the difference is small. Consider a computer system that employs on-chip L1 and L2 caches and off-chip L3 cache. Since the difference between on-chip and off-chip access latencies is much more than the difference between on-chip access latencies, we can treat L1 and L2 caches in the same way when a latency inquiry operation is performed. In particular, we may choose to report as \u201cavailable\u201d (EQ bit on) data that is in either L1 or L2 cache.","The cache state can be used to determine or predict the latency of memory access operations. For example, for a store operation, we can predict its latency based on where the address is cached, and in what state the data is cached. If the cache state shows the address is cached with the exclusive ownership, a store operation can be executed on the cache with little cache coherence overhead. In contrast, if the cache state shows that the address is cached without the exclusive ownership, a store operation may not be executed before other cache copies are invalidated. The latency of a store operation is generally more important for strict memory models such as Sequential Consistency than for relaxed memory models such as POWERPC's memory model.","If the desired address is in L1 cache it is immediately reported as available (EQ=1) with a latency of \u201cvery short\u201d (LT,GT=00). If the L2 cache is on-chip, the inquiry operation is treated similarly to a load: it generates a specially tagged entry in the load miss queue (LMQ).","For inquiry operations (dcbq and dcbqst) the operation completes as soon as the L2 directory lookup has been performed. If the line is in the L2 cache, a prefetch to L1 cache is initiated, the line is reported as available, and the latency is reported as \u201cshort\u201d (LT,GT=01). Otherwise, a prefetch is not initiated and the latency is reported as either \u201clong\u201d or \u201cvery long\u201d (LT,GT=10 or 11). On an L2 hit, the LMQ entry is released when the prefetch completes; on an L2 miss the LMQ entry is released immediately. Note that when a load or store is issued subsequent to a corresponding cache query instruction, the load can be combined with the query in the LMQ.","Alternatively, the computer system can have a built-in prediction mechanism that can be used to predict whether an address is loaded in a cache or set of caches. The prediction mechanism is often based on a prediction table that is smaller than the cache directory and can therefore be accessed faster than the cache directory. For example, the prediction table could be a summary of the cache directory that contains only a subset of the address bits, or a hashed value from the address bits. When an address is loaded into the cache, a corresponding entry is created in the prediction table. The prediction table can be a set-associative table that uses an LRU replacement algorithm. For a latency inquiry operation, if the address is found in the prediction table, the latency is predicted to be the cache hit latency; otherwise the latency is predicted to be the cache miss latency.","Split-Phase Operations and the MTR","The split-phase prepare instructions (dcbp and dcbpst) are implemented similarly to the inquiry instructions, but with more sophisticated functionality. They always cause a speculative load of the cache line containing the effective address into the L1 cache. Therefore the corresponding LMQ entry is not released until the cache load is completed (although the instruction is retired as soon as the inquiry portion completes and MTR resources have been allocated).","If the cache line is not \u201cavailable\u201d, a split-phase operation is initiated and the hardware searches for an available transaction identifier. This is done by looking for a zero bit in a non-architected register that records reserved MTID's (the Memory Transaction Reservation Register or MTRR).","If the MTRR is all ones (indicating no transactions available), the SO bit is set to 1, indicating an MTR overflow, and the instruction completes. The associated cache load operation can optionally be flushed. This is not required, but is perhaps best done asynchronously to avoid flooding the LMQ in pathological cases.","If there are transactions available, the search begins with the bit specified in the non-architected Memory Transaction Search Register (MTSR). The MTSR is rotated to the left (modulo the number of available transactions) until a free bit is found in the MTRR.","Assuming there is a free bit in the MTRR, that bit position is assigned as the memory transaction identifier (MTID) of the request, and is return in register Rn. The MTID is associated with the LMQ entry, and that bit position is set to 1 in the MTRR and 0 in the MTR.","When a cache load completes, the cache logic looks for an MTID associated with the completed LMQ entry. If present, that bit is set to 1 in the MTR. Then the LMQ entry is released. Note that the update of the MTR bit may be performed asynchronously without any particular timing constraint, and the bit need not be set before the LMQ entry is released.","Memory Transaction Register Instructions","The corresponding pair of bits in the MTR and the MTRR determine the four states in the state transition diagram for MTIDs (). In fact, the value reported for the MTR by the mfmtr instruction is really the value of MTR^MTRR.","The mtfree instruction releases an MTID. The MTID may, however, not be available for immediate re-use if the MTID is associated with an LMQ entry. The implementation of mtfree is simply to negate the associated bits in the MTR and MTRR, which has the effect of moving a READY transaction into the FREE state, while a WAITING transaction is moved into the HELD state.","The mtclr operation simply negates the entire MTR and MTRR registers.","Methods and Algorithms","The concept of braids and fibers, high-level programming constructs supported by split-phase operations herein described, have been illustrated with the example of a histogram calculation. We now show how the present invention can be applied to more complex algorithms.","Garbage Collector Mark Phase","The mark phase of a garbage collector is essentially a graph traversal algorithm. It traverses the object graph, marking all objects that it encounters as live. It is therefore very memory intensive as well as containing many unpredictable, non-local memory accesses.","The standard formulation of the mark phase [7, 5] is shown in . The markStack is initially the set of roots (pointers in registers and on the stack). The method or algorithm then recursively traverses the object graph, marking each new object it encounters and backtracking when it encounters a marked object.","The version using inquiring operations is shown in . In this example, markObject (X) is only called if x is in local memory. Otherwise, x is prefetched placed in the deferredQ. When the queue fills up, its elements are processed with markDeferred( ), which marks objects unconditionally to avoid repeated attempts to prefetch the same object, since that could cause cache pollution.","A braided version of the algorithm is shown in . In this case, the queue of outstanding memory operations is maintained in concert by the software and hardware. The fiber method causes the read parameter to be accessed using a split-phase operation dcbp. If the parameter is not available, it is queued and execution continues with another pointer in the mark stack. At some later point when another operation is not available, the software will poll the memory transaction register (MTR) and eventually receive notification that the earlier addressed memory location is now available, and will perform the delayed mark operation.","Sparse Matrix Algorithms",{"@attributes":{"id":"p-0120","num":"0122"},"figref":"FIG. 12"},"Related Work","Horowitz et al. [3] describes informing memory operations. While similar in spirit to inquiring memory operations of the present invention, informing memory operations provide feedback about memory performance to the program after the fact. They are therefore useful for profile-based approaches, but lack the ability to adapt dynamically in the manner of our inquiring operations, and they also lack the mechanism for associating operations with transaction identifiers.","Mowry and Ramkissoon [9] describe how informing memory operations may be used for compiler-controlled multi-threading on a processor core with simultaneous multi-threading (SMT). However, the programming model is significantly more complex since the programmer must be prepared to deal with arbitrary interleaving. The advantage of braiding over multi-threading is that the points at which fibers are interleaved are limited, well-defined, and apparent to the programmer.","Morris and Hunt [8] describe a computer system with instructions that allow registers to be probed to determine if an attempt to use them will stall. This approach is significantly less flexible than ours, since the ability to schedule arbitrary code at arbitrary times is greatly restricted by having to use fixed registers. The ability of our system to allocate and free transaction identifiers gives the software many more degrees of freedom.","There are also some superficial similarities with the Intel IA-64 NAT bits [4].","Split-C [2] provides split-phase memory operations (get and put) in a parallel, SPMD programming language. However, because the split-phase operations are assumed to have high overhead and there is no automatic notification of completion, the programmer must explicitly synchronize at various points, waiting for all outstanding split-phase operations to complete. Our hardware support makes the individual operations much lighter weight, which in turn allows synchronization at the level of individual split-phase operations.","I-structures [1] provide a split-phase functional abstraction in the form of a an array of write-once elements, and an array element read operation which blocks until the write has occurred. This is fundamentally different from our approach in that the semantics are based on the availability of the value, rather than the memory location.","Summary","Braids and fibers, high level programming constructs which allow a program to be expressed as sections of sequential code that can be interleaved in a partial order have been presented. Although fibers are partially ordered with respect to each other, they execute sequentially. This greatly reduces the conceptual complexity of the programming model, since the programmer must not worry about locking or arbitrary interleaving of parallel threads. Instead, the interleaving occurs at intuitive points that are specified and controlled by the programmer.","It has also been demonstrated how braids and fibers can be supported by simple extensions to existing instruct set architecture and microarchitecture. The fundamental hardware abstractions are inquiring operations, which return information about potentially lengthy instructions instead of blocking and waiting for the result. They allow the program to respond adaptively and perform other work while waiting for the operation to complete (for instance, loading a memory location into the cache, or computing an address translation).","To allow efficient interaction between software and hardware resources, the hardware associates memory transaction identifiers with in-flight operations. The software can then poll for completion, typically when some other memory operation is deferred. A number of braided algorithms have been presented, and examples of the corresponding compiled code that makes use of the instruction set extensions of the present invention have also been presented.","Contemplations","By way of general overview, there is broadly contemplated in accordance with an embodiment of the present invention an instruction, in a computer instruction set architecture or in software, for making inquiry of the latency or predicted latency of an operation (or set of operations) without actually performing the operation (or set of operations). The operation can be a memory load operation, memory store operation, memory read-modify-write operation, memory barrier operation, cache operation, synchronization operation, IO operation, arithmetic operation, branch\/jump operation, address translation operation, or any architecture or software operation. There is broadly contemplated herein a set of registers for recording the latency or predicted latency of the operation (or set of operations) upon execution of the instruction.","There is broadly contemplated herein, in a computer instruction set architecture or in software, an instruction for making inquiry of the cost or predicted cost of an operation (or set of operations) without actually performing the operation (or set of operations). The cost may be based on at least one of: latency, bandwidth, power, reliability, security, efficiency or any other architecture or software metric. The operation may be a memory load operation, memory store operation, memory read-modify-write operation, memory barrier operation, cache operation, synchronization operation, IO operation, inter-processor communication operation, arithmetic operation, branch\/jump operation, address translation operation, or any architecture or software operation. There may be a set of registers for recording the cost or predicted cost of the operation (or set of operations) upon execution of the instruction.","There is broadly contemplated, in accordance with an embodiment of the present invention, in a computer instruction set architecture or in software, an instruction for making an inquiry of the latency or predicted latency of an operation (or set of operations), wherein if the latency or predicted latency is below a threshold, the operation (or set of operations) is performed; if the latency or predicted latency if above the threshold, the operation (or set of operations) is not performed, and the latency or predicted latency of the operation (or set of operations) is reported. The operation may be a memory load operation, memory store operation, memory read-modify-write operation, memory barrier operation, cache operation, synchronization operation, IO operation, inter-processor communication operation, arithmetic operation, branch\/jump operation, address translation operation, or any architecture or software operation. The threshold may preferably be specified in the instruction, in a separate instruction, or in the architecture or in software. There is broadly contemplated a set of registers for recording the latency or predicted latency of the operation (or set of operations) upon execution of the instruction.","There is broadly contemplated herein, in a computer instruction set architecture or in software, an instruction for making inquiry of the cost or predicted cost of an operation (or set of operations), wherein if the cost of predicted cost is below a threshold, the operation (or set of operations) is performed; if the cost or predicted cost is above the threshold, the operation (or set of operations) is not performed, and the cost or predicted cost of the operation (or set of operations) is reported. The cost is preferably based on at least one of latency, bandwidth, power, reliability, security, efficiency, or any other architecture or software metric. The operation is preferably a memory load operation, memory store operation, memory read-modify-write operation, memory barrier operation, cache operation, synchronization operation, IO operation, inter-processor communication operation, arithmetic operation, branch\/jump operation, address translation operation, or any architecture or software operation. The threshold is preferably specified in the instruction, in a separate instruction, or in the architecture or software. There is preferably provided a set of registers for recording the cost or predicted cost of the operation (or set of operations) upon the execution of the instruction.","There is broadly contemplated herein, in a computer instruction set architecture or in software, an instruction for making inquiry of the latency or predicted latency of an operation (or set of operations), wherein if the latency or predicted latency is below a threshold, the operation (or set of operations) is performed; if the latency or predicted latency is above the threshold, the operation (or set of operations) is performed in the background mode that does not block subsequent instructions from being executed. The operation may preferably be a memory load operation, memory store operation, memory read-modify-write operation, memory barrier operation, cache operation, synchronization operation, IO operation, inter-processor communication operation, arithmetic operation, branch\/jump operation, address translation operation, or any architecture or software operation. The threshold is preferably specified in the instruction, in a separate instruction, or in the architecture or software. The completion of the background operation is also preferably reported. A task specified in the instruction, if any, is preferably executed or scheduled to execute upon the completion of the background operation. A set of registers is preferably provided for recording the latency or predicted latency of the operation (or set of operations) upon the execution of the instruction.","There is broadly contemplated herein, in a instruction set architecture or in software, an instruction for making inquiry of the cost or predicted cost of an operation (or set of operations), wherein if the cost or predicted cost is below a threshold, the operation (or set of operations) is performed; if the cost or predicted cost is above the threshold, the operation (or set of operations) is performed in the in low-cost mode that does not block subsequent instructions from being executed. The cost may preferably be based on at least one of latency, bandwidth, power, reliability, security, efficiency, or any other architecture or software metric. The operation is preferably a memory load operation, memory store operation, memory read-modify-write operation, memory barrier operation, cache operation, synchronization operation, IO operation, inter-processor communication operation, arithmetic operation, branch\/jump operation, address translation operation, or any architecture or software operation. The threshold is preferably specified in the instruction, in a separate instruction, or in the architecture or in software. Preferably, the completion of the low-cost operation is reported. A task specified in the instruction, if any, is preferably executed or scheduled to execute upon the completion of the low-cost operation. There is preferably provided a set of registers for recording the cost or predicted cost of the operation (or set of operations) upon the execution of the instruction.","There is broadly contemplated herein, in a computer instruction set architecture or in software, an instruction for making an inquiry of the latency or estimated latency of an operation (or set of operations) after the operation (or set of operations) is performed. Preferably, the operation may be a memory load operation, memory store operation, memory read-modify-write operation, memory barrier operation, cache operation, synchronization operation, IO operation, inter-processor communication operation, arithmetic operation, branch\/jump operation, address translation operation, or any architecture or software operation. There is preferably provided a set of registers for recording the latency or estimated latency of the operation (or set of operations) upon the execution of the instruction.","There is broadly contemplated herein, in a computer instruction set architecture or in software, an instruction for making an inquiry of the cost or estimated cost of an operation (or set of operations) after the operation (or set of operations) is performed. The cost is preferably based on at least one of latency, bandwidth, power, reliability, security, efficiency, or any other architecture or software metric. Preferably, the operation is a memory load operation, memory store operation, memory read-modify-write operation, memory barrier operation, cache operation, synchronization operation, IO operation, inter-processor communication operation, arithmetic operation, branch\/jump operation, address translation operation, or any architecture or software operation. There is preferably provided a set of registers for recording the cost or estimated cost of the operation (or set of operations) upon the execution of the instruction.","Referring now to , in connection with system-managed registers , there is broadly contemplated herein, in a computer system  having a set of system-managed registers  that can be accessed by software  only indirectly via a register index , wherein the register index  can be obtained by software  only via checking the status  of the set of system-managed registers . Each register  preferably has an attached state  that indicates if the register is free or busy. Referring now to , a first instruction  is preferably for receiving an index of a free register (if it exists) and setting the register state to busy; it otherwise receives a signal that indicates no register is free. A second instruction  preferably sets the state of a register with a given index to free. A third instruction  preferably sets the states of all the registers to free. A fourth instruction  preferably provides an inquiry of the number of busy registers in the set of system-managed registers.","In connection with micro-architecture support, there is broadly contemplated herein, in a computer system having a processor and a latency prediction mechanism, which upon receiving an inquiry from the processor, provides an estimate of the latency of the operation (or set of operations) without actually executing the operation (or set of operations). The latency prediction mechanism preferably comprises a table that contains a latency or predicted latency for each operation (or set of operations). The latency prediction mechanism preferably provides a plurality of possible outputs, each output being indicative of a different latency range. In one embodiment, the latency prediction mechanism provides two outputs, a first output being for the indication of a low latency, and a second output being for the indication of a high latency. The first output may preferably be for on-chip cache or memory operation latency, and the second output may preferably be for an off-chip cache or memory operation latency.","There is broadly contemplated herein, in a computer system having a processor and a cost prediction mechanism, which upon receiving an inquiry from the processor, provides an estimate of the cost of the operation (or set of operations) without actually executing the operation (or set of operations). The cost is preferably based on at least one of latency, bandwidth, power, reliability, security or any other architecture or software metric. The cost prediction mechanism preferably comprises a table that contains a cost or predicated cost for each operation (or set of operations). The cost prediction mechanism preferably provides a plurality of possible outputs, each output being indicative of a different cost range. The cost prediction mechanism preferably provides two outputs, a first output being for indication of a very cost, and a second output being for indication of a high cost.","There is broadly contemplated herein, in a computer system having a processor, a cache and a memory, a memory latency prediction mechanism, which upon receiving an inquiry from the processor, provides an estimate of the latency of the memory access operation without actually executing the operation. Preferably, the memory latency prediction mechanism comprises a table that contains a predicted latency for each address (or set of addresses). Preferably, each predicted latency has an associated probability. The memory latency prediction table may be a lookup table, a hash table, or a set associative table. Preferably, the memory latency prediction may be based on an on-chip cache directory. Preferably, the latency prediction mechanism provides a plurality of possible outputs, each output being indicative of a different latency range. The predicted latency may depend on whether an address is cached in a cache or memory, and which cache or memory (in the cache and memory hierarchy) contains the data. The predicted latency may depend on whether an address is cached in a cache bank, and which cache bank contains the data; on whether an address is cached in a cache, and the cache state of the address; on whether an address is cached in a local cache on the same processor or the same chip, or a remote cache in a different processor; or on the latency to receive the data from the closest place that contains the accessed data. A first output may preferably represent on-chip cache latency, and a second output may preferably represent off-chip cache or memory latency.","It should be appreciated that the systems contemplated hereinabove may be employed in a wide variety of environments, including multiprocessor systems.","It is to be understood that the present invention, in accordance with at least one presently preferred embodiment, includes at least one of the following groups of elements (A), (B), (C), (D) and (E):","(A) computer instruction set architecture comprising: an inquiry instruction for making an inquiry of at least one characteristic of at least one operation; wherein at least one of the following is performed in connection with the operation: (a) the inquiry is made without the at least one operation being performed; (b) if the at least one characteristic satisfies at least one condition, the at least one operation is performed; yet if the at least one characteristic does not satisfy the at least one condition, the at least one operation is not performed and the at least one characteristic of the at least one operation is reported; (c) if the at least one characteristic satisfies at least one condition, the at least one operation is performed; yet if the at least one characteristic does not satisfy the at least one condition, the at least one operation is performed in an alternate mode that does not block subsequent operations from being executed; and (d) the inquiry is made after the at least one operation is performed;","(B) a computer system comprising: a processor; and a set of registers accessible by software only indirectly via indexing;","(C) a computer system comprising: a processor; a memory; and a prediction mechanism; the prediction mechanism being adapted, upon receiving an inquiry from the processor, to provide an estimate of at least one characteristic of at least one operation without executing the at least one operation;","(D) an arrangement for carrying out a process comprising the steps of: generating an address of an operand; inquiring as to whether the operand is available for reading or writing; performing one of the following (a) or (b): (a) if the operand is available, performing an operation immediately; (b) if the operand is not available, recording the operand in a data structure and issuing an operation intended to make the operand available after a predetermined time; and","(E) an arrangement for carrying out a process comprising the steps of: generating the address of an operand, performing one of the following (a) and (b): (a) employing a split-phase operation to attempt to read or write the operand; (b) determining whether a split-phase operation will succeed or fail; performing one of the following (c) or (d): (c) if a split-phase operation succeeds, or it is determined that a split-phase operation will succeed, repeating the generating step after performance of a split-phase operation; (d) if a split-phase operation fails, or it is determined that a split-phase operation will fail, recording in a data structure either an address or other information related to a split-phase operation; consulting a data structure to determine whether a deferred split-phase operation has completed; performing one of the following (e) or (f): (e) if a deferred split-phase operation has completed, extracting information from the consulted data structure and repeating the generating step; (f) if a deferred split-phase operation has not completed, either: waiting for a deferred split-phase operation to complete; or performing other operations until a deferred split-phase operation has completed and then repeating the generating step.","Together, the elements in any of (A), (B), (C), (D) and (E) as set forth immediately hereabove may be implemented on at least one general-purpose computer running suitable software programs. These may also be implemented on at least one Integrated Circuit or part of at least one Integrated Circuit. Thus, it is to be understood that the invention may be implemented in hardware, software, or a combination of both.","If not otherwise stated herein, it is to be assumed that all patents, patent applications, patent publications and other publications (including web-based publications) mentioned and cited herein are hereby fully incorporated by reference herein as if set forth in their entirety herein.","Although illustrative embodiments of the present invention have been described herein with reference to the accompanying drawings, it is to be understood that the invention is not limited to those precise embodiments, and that various other changes and modifications may be affected therein by one skilled in the art without departing from the scope or spirit of the invention.","Implementation Techniques","In this appendix, it is shown how high level constructs can be compiled into machine language using the split-phase memory instructions added to the architecture in accordance with present invention.  shows how code is generated for a single memory operation that could miss in the cache.  shows how this can be generalized to a sequence of dependent loads.",{"@attributes":{"id":"p-0153","num":"0000"},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":["[1] ARVIND, NIKHIL, R. S., AND PINGALI, K. K. I-structures: data structures for parallel computing. 11, 4 (October 1989), 598-632.","[2] CULLER, D. E., ARPACI-DUSSEAU, A. C., GOLDSTEIN, S. C., KRISHNAMURTHY, A., LUMETTA, S., VON EICKEN, T., AND YELICK, K. A. Parallel programming in Split-C. In (1993), pp. 262-273.","[3] HOROWITZ, M., MARTONOSI, M., MOWRY, T. C., AND SMITH, M. D. Informing memory operations: memory performance feedback mechanisms and their applications. 16, 2 (1998), 170-205.","[4] INTEL CORPORATION. -64 1999.","[5] JONES, R., AND LINS, R. . John Wiley and Sons, 1996.","[6] MAY, C., SILHA, E., SIMPSON, R., AND WARREN, H., Eds. , second ed. Morgan Kaufmann, San Francisco, Calif., 1994.","[7] MCCARTHY, J. Recursive functions of symbolic expressions and their computation by machine. 3, 4 (1960), 184-195.","[8] MORRIS, D. C., AND HUNT, D. B. Computer system having an instruction for probing memory latency, October 2001. U.S. Pat. No. 6,308,261. See also European Patent Application 0-933-698.","[9] MOWRY, T. C., AND RAMKISSOON, S. R. Software-controlled multithreading using informing memory operations. In -(Toulouse, France, January 2000), pp. 121-132.","[10] SILHA, E., WOTTRENG, A., AND MAY, C. 1999.","[11] TENDLER, J. M., ET AL. POWER4 system microarchitecture. 46, 1 (January 2002), 5-25.","[12] WULF, W. A., AND MCKEE, S. A. Hitting the memory wall: implications of the obvious. 23, 1 (March 1995), 20-24."]}}}}],"GOVINT":[{},{}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIGS. 15-18"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 20"}]},"DETDESC":[{},{}]}
