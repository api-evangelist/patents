---
title: Recommended application evaluation system
abstract: A code evaluation tool greatly reduces time, cost, and other resource expenditures needed to validate that an application implements desired functionality. The tool is a search, navigation and visualization tool that accepts high-level processing concepts as inputs to identify, rank, and return the code of a recommended application. A software developer may use the tool to validate that functional requirements are met by the recommended application. The tool provides an efficient way to improve the evaluation of application logic to validate that the application meets specified functional requirement and implements the desired high-level processing concepts.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09021416&OS=09021416&RS=09021416
owner: Accenture Global Service Limited
number: 09021416
owner_city: Dublin
owner_country: IE
publication_date: 20081110
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION"],"p":["This application is a continuation in part of U.S. patent application Ser. No. 11\/804,030, filed May 16, 2007, which is incorporated herein by reference in its entirety.","1. Technical Field","This disclosure concerns evaluating applications identified as implementing desired functionality. In particular, this disclosure relates to a search, navigation and visualization tool that accepts high-level processing concepts as inputs that drive a multi-layered search of an application to validate that the logic of the application actually does implement desired functionality.","2. Background Information","Software professionals widely recognize that applications often fail to implement functionality as described by the application descriptions and project summaries of the applications. Software professionals use various inadequate techniques to reduce the time, money, and other costs for validating that an application implements particular functionality. Software professionals recognize API calls as forms of abstraction for high-level processing concepts, and merely search for the existence of particular API calls to validate that the application implements a desired functionality. For example, an API call may be identified and\/or described as implementing pull-down menu functionality, although the underlying logic may not actually include the logic necessary to deliver the functionality of a pull-down menu. Current logic evaluation techniques and tools require significant resources and user expertise to accurately validate that an application implements functional requirements in support of high-level processing concepts. Modern search engines do not ensure that the logic of applications identified by the search engines actually implement the functionality as described by the project summaries and documentation of the application.","Software professionals consider the mismatch between the high-level processing concepts (e.g., the intent reflected in the descriptions of applications) and low-level implementation details (e.g., API calls and actual run-time behaviour) found in application logic a fundamental technical challenge to validating that an application implements particular functionality. Software professionals intend to author meaningful descriptions of applications, in the course of depositing applications into software repositories. The mismatch between the description of an application and the actual behaviour of the application represents one example of the \u201cvocabulary problem\u201d, which states that no single word or phrase best describes a programming concept.","In the spiral model of software development, stakeholders describe high-level processing concepts to development teams, and together the stakeholders and development teams identify requirements in support of the high-level processing concepts. In addition, a development team builds a prototype based on the requirements, and the development team demonstrates the prototype to the stakeholders to receive feedback. Prototypes attempt to approximate the desired high-level processing concepts (e.g., features and capabilities) of the new application stakeholders desire development teams to build. The feedback from stakeholders often leads to changes to the prototype and the original requirements, as stakeholders iteratively refine their vision. In the event the stakeholders make a substantial number of changes to the requirements, the development team often discards the prototype and builds a new prototype, and another iteration of refinements repeats. Building prototypes repeatedly without reusing existing application logic costs organizations a great deal in the form of wasted project resources and time. Deploying an application without adequately evaluating and validating that the logic of the application implements desired functionality further complicates software development.","Development teams find the task of evaluating and validating that the logic of an application approximates high-level processing concepts and requirements of a software project resource intensive. In the context of application deployment, software development professionals consider such application logic as highly relevant application logic (HRAL). Many application repositories (e.g., open source repositories and source control management systems maintained by stakeholders internally) contain hundreds of thousands of different existing applications (e.g., potential highly relevant applications (HRAs)). Unfortunately, developers find it difficult to validate the logic of applications, because of the time and expense involved in searching the application, evaluating and validating that the logic of the application implements particular functionality.","The amount of intellectual effort that a developer must expend to move a software system from one stage of development to another may be considered the \u201ccognitive distance\u201d. For example, using current search tools, developers expend significant intellectual effort to validate that an application implements desired functionality. Many developers employ search engines that identify exact matches between keywords that are entered as part of the search query and the words found in an application. The application may include descriptions, application logic comments, program variables names, and variable types of the application. Such search engines actually increase the difficulty of validating the application, because of the poor quality of information contained in application, and the inability to reduce the cognitive distance required to validate that the logic of the application implements the desire functionality, as well as other factors. Additionally, many applications include incomplete, misleading and inaccurate descriptions of the application. Consequently, even matching keywords with words found in the application description does not guarantee that the search engine will identify application logic that actually implements desired functionality (e.g., highly relevant application logic (HRAL)).","Effective software evaluation techniques reduce the cognitive distance between the initial concept of a system (e.g., high-level processing concepts that expressly and implicitly describe the features and capabilities of an application), validating discrete requirements, and the production implementation of the application. Unfortunately, current application evaluation tools lack the ability to reduce the cognitive distance related to validating application logic to identify HRAL.","For example, an application description may indicate that an application includes an encryption feature when in fact the application uses compression as a crude form of encryption. A developer entering \u201cencryption\u201d (e.g., as a high-level processing concept and specific requirement) as a keyword may waste precious time to review a search engine result containing the incorrectly described logic of an application, and ultimately discard the result, because the application fails to meet the encryption requirement. The developer must locate and examine fragments of the application logic that allegedly implements encryption before determining that the application fails to meet the requirement. The developer may spend scarce project development budget resources and significant amount of time to analyze the application before determining that the application is not relevant. The developer may even observe the runtime behavior of the application to ensure that the behavior matches the high-level processing concepts desired by the stakeholders, and meets the requirements in support of the high-level processing concepts before establishing that the logic of the application qualifies as HRAL. Current evaluation tools also lack the ability to assist developers to rapidly identify requirements in support of high-level processing concepts described by stakeholders.","Some evaluation tools return code snippets (e.g., segments of application logic), however, code snippets do not give enough background or context to assist developers to rapidly evaluate and validate the logic, and such evaluation tools require developers to invest significant intellectual effort (e.g., cognitive distance) to understand the broader scope of the code snippets. Other existing approaches and tools retrieve snippets of code based on the context of the application logic that developers work on, but while these approaches and tools improve the productivity of developers, they do not return highly relevant applications logic from high-level processing concepts as inputs.","A need has long existed for a system and method that efficiently evaluates and validates application logic to identify HRAL and deployable application.","The recommended application evaluation system (RAE) provides a way to rapidly and efficiently evaluate the logic of recommended applications to validate that the recommended applications actually do implement highly relevant application logic (HRAL). One implementation of RAE includes a machine readable medium and logic stored on the machine readable medium that implements RAE area logic. The RAE area logic is operable to obtain recommended applications (e.g., highly relevant applications (HRAs)) for evaluation. The recommended applications may be supplied to the RAE in the form of source code for the recommended application, or in other forms.","The RAE area logic presents a concept query display region that displays topics, concepts and words of a query used to find the recommended applications. The RAE area logic presents a concept distribution display region that displays a recommended application representation of one of the recommended applications. The recommended application representation includes concept distribution locators that identify potential implementation locations of one of the topics, concepts and words. The RAE area logic presents a source code display region that is responsive to a selection of one of the concept distribution locators. The source code display region displays a portion of the source code that includes the potential implementation location for the selection of one of the concept distribution locators. The RAE area logic presents a metadata display region that displays metadata generated upon execution of the query.","In one implementation, the recommended applications (e.g., HRAs) are identified using the EXEcutable exaMPLes ARchive system (Exemplar). Exemplar identifies the location (e.g., concept distribution locators) in application logic where an API call implements a high-level processing concept. Using Exemplar, a developer enters high-level processing concepts (e.g., toolbar, download, smart card) as input (e.g., initial query keywords), and Exemplar uses information retrieval and program analysis techniques to retrieve HRAs that implement the high-level processing concepts in the application. Exemplar may also accept various types of inputs that describe high-level processing concepts (e.g. concept text identifiers, concept visual identifiers, concept audio identifiers, and any other sensory identifier usable to identify high-level processing concepts). Exemplar uses the help pages and help documentation of third-party libraries, software development kits, and other middleware to produce a list of names of API calls that Exemplar in turn uses to expand an initial query (\u201cquery expansion\u201d) to identify the highly relevant application logic of an application. Exemplar determines the behavior of the application logic and API call logic and ranks the API calls.","Exemplar uses help documentation or other trusted sources that describe API calls to expand queries. An application provider typically provides the help pages and help documentation for their applications, which developers consider reliable and a trusted source. In particular, developers consider application providers trusted sources for help pages and help documentation of popular and widely used applications written by large development teams, produced under rigorous testing and development best practices, and used by other developers who provide feedback regarding documentation using different forums (e.g., user groups). Developers trust help documentation over the descriptions of applications included in application repositories, because application providers generally produce more verbose and accurate help documentation than the descriptions of applications included in application repositories. Developers also trust help documentation because many different people and review procedures are typically used to produce help documentation.","Exemplar query expansion increases the probability of identifying logic matches that validate that the logic is highly relevant application logic, and addresses the vocabulary problem mentioned above by expanding an initial query to include new keywords, metadata, and semantics information found in help pages and other help documentation determined to have similar meanings to the keywords originally used by a developer in the initial query. Exemplar expands an initial query to include the names of API calls with semantics that reflect (in many cases unequivocally) specific behaviour of the application. Exemplar locates application logic containing the API calls that exhibit desired semantics by identifying API calls through help pages and help documentation. Exemplar provides a user interface that developers can use to navigate directly to the various locations to determine how an HRA implements high-level processing concepts.","Exemplar may rank HRAs according to the number of high-level processing concepts implemented by each API call found in the HRAs, or based on other ranking metrics. In other words, since API calls implement high-level processing concepts, the more high-level processing concepts implemented by an HRA the more relevant the HRA and the higher the rank assigned to the HRA. Exemplar considers keywords included in queries to represent logically connected concepts. Often a question structured as a sentence forms the basis for a query, from which a developer extracts keywords to form the query. For example, consider the query \u201csend receive secure XML.\u201d Where a query presents a relation between multiple concepts (e.g., send secure XML), then a relation should exists between API calls that implement the concepts in the corresponding application logic (e.g., API calls that encrypt, process or handle XML formatted content, and transmit content). Application logic often preserves the relations between concepts (e.g., control flow and data flow links), an instance of the software reflection model concept and known as connectivity heuristics. Exemplar calculates HRAs rankings based on analyzing the connectivity heuristics of API calls that implement the concepts included in the queries. Exemplar uses program analysis algorithms, and computes control flow graphs (CFG), and data flow graphs (DFG) to analyze the connectivity heuristics of API calls.","RAE provides a way to rapidly and efficiently evaluate the logic of recommended applications to validate that the recommended applications implement highly relevant application logic (HRAL).","Other systems, methods, and features of the invention will be, or will become, apparent to one with skill in the art upon examination of the following figures and detailed description. It is intended that all such additional systems, methods, features and advantages be included within this description, be within the scope of the invention, and be protected by the following claims.","The recommended application evaluation system (RAE) solves the technical problem of providing a tool to easily and quickly evaluate a recommended application to validate that the recommended application implements a particular functionality. In one implementation, the RAE may evaluate recommended applications obtained from the EXEcutable exaMPLes ARchive system (Exemplar).","Exemplar provides a tool that accepts high-level processing concepts as queries to identify, determine the behavior, rank and return the application logic of HRAs. Exemplar solves an instance of the difficult vocabulary problem that exists when users and developers describe processing concept with different words. Exemplar is not limited to basic keyword matching used in queries against application descriptions and comments included with application logic. Accordingly, when an application is highly relevant, and where a query contains keywords different from the words used by the developer to describe application logic and API call logic, Exemplar nevertheless returns the application as a highly relevant application.","Exemplar matches high-level processing concepts (e.g., expressed using keywords) with the descriptions of various API calls found in help documents or other trusted descriptive sources. Because a typical application invokes API calls from several different libraries, several different people who use different vocabularies often author help documents associated with API calls. The richness of different vocabularies increases the probability of finding matches and producing a long list of potentially relevant applications and API calls. Searching help documents or other trusted descriptive sources produces additional benefits. For example, help documents including an API call often indicate where the application logic implements the API call. Consequently, Exemplar may direct a developer to the location in application logic where an API call implements a high-level processing concept. The developer may then determine the relevance of the application logic and API call logic. In other words, the developer may determine whether the application logic and API call logic actually support the high-level processing concept.","Although specific components of Exemplar and RAE will be described, methods, systems, and articles of manufacture consistent with Exemplar and\/or the RAE may include additional or different components. For example, a processor may be implemented as a microprocessor, microcontroller, application specific integrated circuit (ASIC), discrete logic, or a combination of other type of circuits or logic. Similarly, memories may be DRAM, SRAM, Flash or any other type of memory. Logic that implements the processing and programs described below may be stored (e.g., as computer executable instructions) on a computer readable medium such as an optical or magnetic disk or other memory. Alternatively or additionally, the logic may be realized in an electromagnetic or optical signal that may be transmitted between entities. An example of such a signal is a physical layer Ethernet signal bearing TCP\/IP packets that include program source code or executable programs. Flags, data, databases, tables, and other data structures may be separately stored and managed, may be incorporated into a single memory or database, may be distributed, or may be logically and physically organized in many different ways. Programs may be parts of a single program, separate programs, or distributed across several memories and processors. Furthermore, the programs, or any portion of the programs, may instead be implemented in hardware.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","128","100","102","104","106","100","108","110","112","114","116","118"]},"In one implementation, the EPAD user interface , expanded search engine , heuristic relevance ranking engine  and logic analyzer  form an Exemplar system  within the Exemplar environment . The Exemplar system  may include additional or different components. The Exemplar system  may communicate with the help content processor , help content , API calls dictionary , and logic repository , as well as other systems, through the networks  (e.g., Internet) as external systems.","The logic repository  may include application logic  and API call logic . The Exemplar system  accepts high-level processing concepts (e.g., \u201csend secure XML\u201d) as input and produces output identifying which application logic  and API call logic  developers may use to prototype and develop new applications implementing the high-level processing concepts. In one implementation, the Exemplar environment  implements the help content  and the logic repository  with multiple storage devices (e.g., multiple databases on different disk drives), and interfaces to help content , application logic  and API call logic  from various available source (e.g., local or remote help databases, websites, knowledge exchanges, document repositories, or other sources).","In one implementation, the help content processor  may be implemented as a web crawler that traverses available application repositories, and downloads help content  (e.g., application descriptions), and logic repository  content (e.g., application logic , and API logic ). The help content processor  may also perform full text indexing on the help content  and the logic repository  content. The help content processor  may further produce an API calls dictionary  that includes sets of tuples (a form of ordered list) that link selected words from the descriptions of the API calls to the names of the API calls.","The description above used the examples of application logic  and API call logic . These types of logic may be program source code (e.g., C or C++ code), for example. However, the Exemplar environment  may search, analyze, and determine relevance for many other types of logic. As examples, the logic repository  may include programs or program components expressed in a visual programming language using graphical program elements and spatial arrangements of text and graphic symbols. The visual programming logic may include icon-based logic, form-based logic, diagram-based logic or other types of visual expression. The visual expression may be consistent with dataflow languages, flow-based programming, domain-specific modelling, or other programming paradigms.","In one implementation, the Exemplar environment  and the RAE  are present in a RAE environment . The RAE  includes a RAE user interface generation logic  that comprises RAE area logic . The RAE area logic  comprises concept query display logic , concept distribution display logic , source code display logic  and metadata display logic . Aspects of the RAE  are discussed in further detail below.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 2","b":["200","124","202","124","104","104","204","108","202","106"]},"The expanded search engine  may combine the original query  and the basis API call list  to form an expanded query . The expanded search engine  may execute an expanded search using the expanded query  to search through the logic repository  to obtain an expanded search result . In one implementation, the logic repository  may return the expanded search results  to the heuristic relevance ranking engine . The expanded search result  may contain a list of potentially relevant applications  and potentially relevant API calls  that the heuristic relevance ranking engine  analyzes using the logic analyzer . In one implementation, the heuristic relevance ranking engine  may include the logic analyzer . The logic analyzer  may include a parser generator such as ANTLR (\u201cANother Tool for Language Recognition\u201d) available from www.antlr.org that provides support for generating data flow graphs and control flow graphs.","The logic analyzer  may return connectivity rankings , discussed in detail below, to further determine an application heuristic relevance ranking  and an API call heuristic relevance ranking . The heuristic relevance ranking engine  may return the application heuristic relevance ranking  and an API call heuristic relevance ranking  to the EPAD user interface . The expanded search engine  may also return a relevant applications list  and a relevant API calls list  to the EPAD user interface . The Exemplar system  may assign an application heuristic relevance ranking  to one or more relevant applications found in the relevant applications list  to indicate how closely each relevant application supports the high-level processing concept represented by the original query . Similarly, Exemplar system  may assign an API call heuristic relevance ranking  to one or more relevant API calls found in the relevant API call list  to indicate how closely each relevant API call supports the high-level processing concept represented by the original query .","In one implementation, the RAE area logic  obtains the connectivity rankings , the application heuristic relevance rankings , the API call heuristic relevance rankings , the relevant applications list , and the relevant API call list . The RAE area logic  may use the connectivity rankings , the application heuristic relevance rankings , the API call heuristic relevance rankings , the relevant applications list , and the relevant API call list  to present a recommended application evaluation area, discussed in detail below, to evaluate recommended applications obtained from Exemplar .",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 3","b":["300","202","202","302","302","106","108","112","304","304","300","306","202"]},"Table 1 shows an example of an original query  in the form of a structured query language statement (SQL) that represents the high-level processing concept \u201ccompress uncompress ZIP file\u201d . Table 1 shows that the original query  will search the help content  (e.g., Java Help Documents) to identify a basis API calls list .",{"@attributes":{"id":"p-0054","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"original query 202"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SELECT basis API Calls"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"FROM Java Help Documents"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"WHERE Words in these Documents ="]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"compress or uncompress or ZIP or file."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Table 2 shows one example of the help content  represented by a fragment of Java Help Documentation released by Sun Microsystems, Inc. that describes the functionality of classes exported from the Java.util package. The Java.util package defines a number of classes, primarily collections classes that a developer may use when working with groups of objects. Referring to Table 2, the help content processor  may identify partial matches for the class ZipEntry to the original query . The help content processor  may search the help content  and identify a fragment of the help documentation for the ZipEntry class shown in Table 3.",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"help content 106 (e.g. a fragment of Java Help Document)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Class","Summary"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Adler32","A class that can be used to compute the"]},{"entry":[{},"Adler-32 checksum of a data stream."]},{"entry":["CheckedInputStream","An input stream that also maintains a"]},{"entry":[{},"checksum of the data being read."]},{"entry":["CheckedOutputStream","An output stream that also maintains a"]},{"entry":[{},"checksum of the data being written."]},{"entry":["CRC32","A class that can be used to compute the"]},{"entry":[{},"CRC-32 of a data stream."]},{"entry":["Deflater","This class provides support for general"]},{"entry":[{},"purpose compression using the popular ZLIB"]},{"entry":[{},"compression library."]},{"entry":["DeflaterInputStream","Implements an input stream filter for"]},{"entry":[{},"compressing data in the \u201cdeflate\u201d"]},{"entry":[{},"compression format."]},{"entry":["DeflaterOutputStream","This class implements an output stream"]},{"entry":[{},"filter for compressing data in the"]},{"entry":[{},"\u201cdeflate\u201d compression format."]},{"entry":["GZIPInputStream","This class implements a stream filter for"]},{"entry":[{},"reading compressed data in the GZIP file"]},{"entry":[{},"format."]},{"entry":["GZIPOutputStream","This class implements a stream filter for"]},{"entry":[{},"writing compressed data in the GZIP file"]},{"entry":[{},"format."]},{"entry":["Inflater","This class provides support for general"]},{"entry":[{},"purpose decompression using the popular"]},{"entry":[{},"ZLIB compression library."]},{"entry":["InflaterInputStream","This class implements a stream filter for"]},{"entry":[{},"uncompressing data in the \u201cdeflate\u201d"]},{"entry":[{},"compression format."]},{"entry":["InflaterOutputStream","Implements an output stream filter for"]},{"entry":[{},"uncompressing data stored in the"]},{"entry":[{},"\u201cdeflate\u201d compression format."]},{"entry":["ZipEntry","This class is used to represent a ZIP file"]},{"entry":[{},"entry."]},{"entry":["ZipFile","This class is used to read entries from a zip"]},{"entry":[{},"file."]},{"entry":["ZipInputStream","This class implements an input stream filter"]},{"entry":[{},"for reading files in the ZIP file format."]},{"entry":["ZipOutputStream","This class implements an output stream filter"]},{"entry":[{},"for writing files in the ZIP file format."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Table 3 shows the descriptions of two different methods (e.g., getCompressedSize, and setMethod) for the ZipEntry class that include the terms compress and uncompress found in the high-level processing concept \u201ccompress uncompress ZIP file\u201d . The basis API call list  may include the getCompressedSize and setMethod methods.",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"help content 106 (e.g., fragment of help"},{"entry":"documentation for ZipEntry class)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Method","Summary"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Object","clone( )"]},{"entry":[{},"Returns a copy of this entry."]},{"entry":["String","getComment( )"]},{"entry":[{},"Returns the comment string for the entry, or null if none."]},{"entry":["long","getCompressedSize( )"]},{"entry":[{},"Returns the size of the compressed entry data, or \u22121"]},{"entry":[{},"if not known."]},{"entry":["long","getCrc( )"]},{"entry":[{},"Returns the CRC-32 checksum of the uncompressed entry"]},{"entry":[{},"data, or \u22121 if not known."]},{"entry":["byte[ ]","getExtra( )"]},{"entry":[{},"Returns the extra field data for the entry, or null if none."]},{"entry":["int","getMethod( )"]},{"entry":[{},"Returns the compression method of the entry, or \u22121"]},{"entry":[{},"if not specified."]},{"entry":["String","getName( )"]},{"entry":[{},"Returns the name of the entry."]},{"entry":["long","getSize( )"]},{"entry":[{},"Returns the uncompressed size of the entry data, or \u22121"]},{"entry":[{},"if not known."]},{"entry":["long","getTime( )"]},{"entry":[{},"Returns the modification time of the entry, or \u22121"]},{"entry":[{},"if not specified."]},{"entry":["int","hashCode( )"]},{"entry":[{},"Returns the hash code value for this entry."]},{"entry":["boolean","isDirectory( )"]},{"entry":[{},"Returns true if this is a directory entry."]},{"entry":["void","setComment(String comment)"]},{"entry":[{},"Sets the optional comment string for the entry."]},{"entry":["void","setCompressedSize(long csize)"]},{"entry":[{},"Sets the size of the compressed entry data."]},{"entry":["void","setCrc(long crc)"]},{"entry":[{},"Sets the CRC-32 checksum of the uncompressed entry data."]},{"entry":["void","setExtra(byte[ ] extra)"]},{"entry":[{},"Sets the optional extra field data for the entry."]},{"entry":["void","setMethod(int method)"]},{"entry":[{},"Sets the compression method for the entry."]},{"entry":["void","setSize(long size)"]},{"entry":[{},"Sets the uncompressed size of the entry data."]},{"entry":["void","setTime(long time)"]},{"entry":[{},"Sets the modification time of the entry."]},{"entry":["String","toString( )"]},{"entry":[{},"Returns a string representation of the ZIP entry."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Table 4 shows an example of two equivalent forms of an expanded query  that expand the original search from the help content  (e.g., Java Help Documents) to the logic repository  using the basis API call list  from the original query . Table 4 statement A shows the getCompressedSize and setMethod that may be included in the basis API call list . Table 4 statement B shows the expanded query  as a nested query, where the original query  and the basis API call list  (e.g., getCompressedSize and setMethod) drive the outer query that searches the logic repository  for potentially relevant applications  to obtain the expanded query result  including potentially relevant applications  and potentially relevant API calls . The expanded query  may improve upon the original query  by targeting the search performed against the logic repository  to obtain application logic  with a high probability of including potentially relevant applications  and potentially relevant API calls .",{"@attributes":{"id":"p-0060","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"expanded query 206"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["A.","SELECT Potentially Relevant Applications"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FROM Logic Repository"]},{"entry":[{},"WHERE API Calls in"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Source Code Files of these Application"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"= getCompressedSize or setMethod."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"252pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/************* The SQL statement above also expressed below. ****************\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["B.","SELECT Potentially Relevant Applications"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003FROM Logic Repository"]},{"entry":[{},"\u2003WHERE API Calls in"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Source Code Files of these Application"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"= {"]},{"entry":[{},"\u2003SELECT basis API Calls"]},{"entry":[{},"\u2003FROM Java Help Documents"]},{"entry":[{},"\u2003WHERE Words in these Documents ="]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003compress or uncompress or ZIP or file"]},{"entry":[{},"}."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Table 5 shows another example of two equivalent forms of an expanded query  that expand the original search from the help content  (e.g., Java Help Documents) to the logic repository  by combining the original query  and the basis API call list  to form the expanded query . Table 5 statement A shows the getCompressedSize and setMethod (e.g., the basis API call list ) combined with the original query . Table 5 statement B shows the expanded query  as a nested query, where the original query  and the basis API call list  (e.g., getCompressedSize and setMethod) drive the outer query that searches the logic repository  for potentially relevant applications  to obtain the expanded query result  including potentially relevant applications  and potentially relevant API calls . The expanded query  may improve upon the original query  by targeting the search performed against the logic repository  to obtain application logic  with a high probability of including potentially relevant applications  and potentially relevant API calls .",{"@attributes":{"id":"p-0062","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"266pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"expanded query 206"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["A.","\u2003SELECT Potentially Relevant Applications"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FROM Logic Repository"]},{"entry":[{},"WHERE API Calls in"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Source Code Files of these Application"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"= getCompressedSize or setMethod or"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"compress or uncompress or ZIP or file."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"252pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/************* The SQL statement above also expressed below. ****************\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["B.","SELECT Potentially Relevant Applications"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003FROM Logic Repository"]},{"entry":[{},"\u2003WHERE API Calls in"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Source Code Files of these Application"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"= {"]},{"entry":[{},"\u2003SELECT basis API Calls"]},{"entry":[{},"\u2003FROM Java Help Documents"]},{"entry":[{},"\u2003WHERE Words in these Documents ="]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003compress or uncompress or ZIP or file"]},{"entry":[{},"} or compress or uncompress or ZIP or file."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Table 6 shows an example of a fragment of logic extracted from the logic repository  (e.g., potentially relevant application ) that includes a potentially relevant API call  (e.g., getCompressedSize).",{"@attributes":{"id":"p-0064","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"potentially relevant application 210"},{"entry":"(e.g., extracted logic fragment)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"public static void addFilesToExistingZip(File zipFile, File[ ] files)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"throws IOException {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ get a temp file"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"File tempFile = File.createTempFile(zipFile.getName( ),"]},{"entry":[{},"null);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ delete it, otherwise you cannot rename your existing zip to it."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"tempFile.delete( );"]},{"entry":[{},"int sz = zipFile.getCompressedSize( ):"]},{"entry":[{},"boolean renameOk=zipFile.renameTo(tempFile);"]},{"entry":[{},"if (!renameOk && sz == \u22121)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"throw new RuntimeException(\u201ccould not rename the"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"file\u201d+zipFile.getAbsolutePath( )+\u201c to \u201d+tempFile.getAbsolutePath( ));"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"byte[ ] buf = new byte[1024];"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 4","b":["124","400","400","402","404","406","408","410","402","220","124","206","220","412","414","416","414","408","102","400"]},"The relevant API list display area  may include the relevant API call list  returned by Exemplar system  based on the original query . The relevant API call list  may include a relevant API call identifier-1  (e.g., a function call name) and a relevant API call identifier-2  of the relevant API call logic-1  (e.g., source code for the function call) and relevant API call logic-2 , respectively. The EPAD project area  may present the relevant API call identifier-1  and the relevant API call identifier-2  as user selectable, indicated by the arrow , to display and highlight the relevant API call logic-1  and the relevant API call logic-2  in the logic display area . In one implementation, the logic display area  may highlight the relevant application logic , and relevant API call logic-1  and relevant API call logic-2  so that the user can further determine the relevance of the logic to the high-level processing concept represented in the original query .","The heuristic relevance ranking results display area , shown in , may include an application relevance threshold , an API call relevance threshold , data flow graph , control flow graph , and an API call graph . The heuristic relevance ranking results display area  may display heuristic relevance ranking engine  information to assist the user to determine the relevance of user selected logic. As will be described in more detail below, the heuristic relevance ranking engine  may determine the application heuristic relevance ranking  for the relevant application logic  based on the number of relevant API calls (e.g., relevant API call logic-1  and relevant API call logic-2 ) found in the relevant application logic  in comparison to other relevant application logic  identified by Exemplar system . For example, the high-level processing concept example \u201ccompress uncompress ZIP file\u201d  may be entirely implemented in relevant application logic , but only partially implemented in the other relevant application logic . As a result, the heuristic relevance ranking engine  may assign the relevant application logic  a higher application heuristic relevance ranking  than the other relevant application logic . In another implementation, the heuristic relevance ranking engine  may determine the API call heuristic relevance rankings  of the relevant API call logic-1  and the relevant API call logic-2 , based on analyzing semantics derived from the expanded query  and the expanded search result , which establish the behaviour of the relevant API call logic-1 , the relevant API call logic-2 , and the relevant applications logic-1 .","The application relevance threshold  and API call relevance threshold , shown in , may be user selectable and\/or pre-configured with system default values. In another implementation, Exemplar system  may determine the application relevance threshold  and the relevance threshold  based a number of factors (e.g., the complexity of the high-level processing concept represented by the original query , and the number of potentially relevant applications  and potentially relevant API calls  identified by the expanded search result ). Exemplar system  may use the application relevance threshold  and the relevance threshold  to further refine the relevant applications list  and the relevant API calls list , respectively. In one implementation, the application relevance threshold  and the relevance threshold  may determine an application heuristic relevance ranking  value that the potentially relevant applications  must meet to be included on the relevant applications list . The API call relevance threshold  may also determine the API call heuristic relevance ranking  value that the potentially relevant API calls  must meet to be included on the relevant API calls list . For example, an application relevance threshold  of 1 may indicate a low relevance requirement (e.g., requiring loosely relevant applications, and low application heuristic relevance rankings ) and allow a large number of potentially relevant applications  to qualify as relevant applications (e.g., relevant application logic-1 ). In another example, an application relevance threshold  of 10 may indicate a high relevance requirement (e.g., requiring highly relevant applications, and high application heuristic relevance rankings ) and allow only a fewer number of potentially relevant applications  to qualify as relevant applications. The heuristic relevance ranking engine  may also use the data flow graph  and control flow graph  to determine the application heuristic relevance ranking  and API call heuristic relevance ranking , and visually describe the relationships between the relevant application logic , the relevant API call logic-1 , and the relevant API call logic-2 , discussed in further detail below.","The relevant API call logic-1  and the relevant API call logic-2  may be user selectable (indicated by the arrow ), and provide the user the ability to generate a new application  with the selected logic. To that end, the EPAD project area  may implement point-and-click, drag-and-drop functionality for a user to select relevant API call logic-1  and relevant API call logic-2  to generate the new application . The EPAD project area  may also build the new application  by combining user selectable other relevant application logic , relevant API call logic-1, and relevant API call logic-2. The application creation display area  may also identify requirements  for the high-level processing concept represented by the original query . For example, a developer may desire to identify and confirm the requirements  for implementing a high-level processing concept (e.g., \u201csend secure XML\u201d). In one implementation, Exemplar may generate requirements documentation and end user documentation based on the help content  related to the other relevant application logic , the relevant API call logic-1, and the relevant API call logic-2 used to build the new application , and identify the requirements  in support of the new application .",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 5","b":["124","124","504","124","506","508","508","506","102","510","300","400","510","124"]},"The memory  may also include expanded search logic . Table 5, above, shows an expanded query  where the search logic  forms the expanded query by combining the original query  and the basis API call list  to form the expanded query . More generally, the expanded search logic  combines the original query  and the basis logic results  to form the expanded query , and executes an expanded search using the expanded query . The basis logic results  may include the basis API call list , including zero or more basis API call identifiers (e.g., the basis API call identifier-1 ), and a basis application list , including zero or more basis application identifiers (e.g., the basis application identifier-1 ). The expanded search logic  thereby obtains the expanded search results . The expanded search result  may include potentially relevant applications , and potentially relevant API calls  that include zero or more potentially relevant application identifiers-1  and zero or more potentially relevant API call identifiers (e.g., potentially relevant API call identifier-1  and potentially relevant API call identifier-2 ).",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 6","b":["124","506","114","602","216","218","604","428","430","216","218","210","212","220","222","604"]},"The memory  may also include analyzer logic  that the processor  executes to identify application metadata  and API metadata  of the potentially relevant applications , and the potentially relevant API calls , respectively. Examples of application metadata  include application descriptions, application logic comments, application parameter names, and application parameter types of existing applications. Similarly, examples of API metadata  include API descriptions, API logic comments, API parameter names, and API parameter types.","The analyzer logic  may generate the data flow graph  and control flow graph  to obtain the API call graph . The API call graph  may include nodes (e.g., node-1  and node-2 ) that represent potentially relevant API calls  and data flow edges (e.g., data flow edge ) between the potentially relevant API calls  to indicate data flow.  provides additional examples. The analyzer logic  may determine the data flow edge count  corresponding to the number of connections between potentially relevant API calls  within the potentially relevant application . A graph with \u2018n\u2019 nodes has as many as n(n\u22121) edges between nodes. The data flow edge count  provides insight into the degree of connectedness for the data flow graph . The analyzer logic  may also assign link values  to the edges between nodes, discussed in detail below. In one implementation, the analyzer logic  may determine the connectivity rankings  (e.g., strong connectivity ranking  and weak connectivity ranking ) for each connection between the potentially relevant API calls  based on common API parameters , discussed in detail below.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 6","b":["506","628","630","508","628","414","422","424","440","628","436","422","424","440","508","630","444","202","106","516","436","414","422","424","436","414","422","424","106","444","630","106","436","414","422","424"]},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 7","b":["434","114","216","212","214","620","212"]},"In one implementation, the logic analyzer  produces the API call graphs . The logic analyzer  may identify the application metadata  and API metadata  of the potentially relevant applications , and the potentially relevant API calls , respectively, to analyze the data flow paths and connectivity between the potentially relevant API calls . The logic analyzer  may provide the application metadata  and API metadata  to the heuristic relevance ranking engine . In an alternative implementation, the heuristic relevance ranking engine  may identify application metadata  and API metadata , and produce the data flow graph  and control flow graph  using logic analysis formulas, rules and equations to obtain the API call graphs . The data flow graphs , control flow graphs  and API call graphs  may be represented as mathematical structures. The logic analyzer  may obtain the API call graphs  as a result of comparing data flow and control flow between potentially relevant API calls .","In one implementation, the logic analyzer  may perform control flow analysis on the potentially relevant application  to obtain control flow graphs , and perform data flow analysis on the control flow graphs  to obtain data flow graphs. The data flow graphs , control flow graphs , and API call graphs may similarly include nodes and edges. The logic analyzer  may obtain a control flow graph  by logically partitioning a potentially relevant application  as a result of parsing the logic of the potentially relevant application  into nodes that represent logic that includes API calls. The logic analyzer  may assign parsed logic of the potentially relevant application  to an assigned node until the logic analyzer  identifies a potentially relevant API call or branching logic (e.g., if-then, switch-case, and do-while), and add the assigned node to the control flow graph . Where a program includes multiple potentially relevant applications , the logic analyzer  may merge the control flow graphs  produced for each potentially relevant application into a single control flow graph . The logic analyzer  may obtain the API call graph  by comparing the edges in the control flow graphs  with the edges in the data flow graph . For example, where a control flow graph  includes an edge that a data flow graph  does not include, the logic analyzer  may not include the edge in the corresponding API call graph . However, where a control flow graph  includes an edge that the data flow graph  also includes, the logic analyzer  may include the edge in the API call graph .","In one implementation, the logic analyzer  may receive user input to determine particular dependencies between API calls. For example, where a potentially relevant application  uses a function pointer (e.g., a type of pointer used in C, and C++ languages) to reference a potentially relevant API call  and a hash table (e.g., a data structure that associates keys with values) to store an object that represents a data element passed between API calls, the logic analyzer  may receive user input to determine dependencies between API calls because the logic analyzer  may otherwise interpret multiple possible dependencies between API calls when in fact only one or a finite set of valid dependencies exists.","In another implementation, the logic analyzer  may analyze the data flow paths (e.g., edges between nodes discussed below) (e.g., link heuristics) of the potentially relevant applications , and potentially relevant API call logic  to determine the connectivity rankings  of each connection between potentially relevant API calls . In one implementation, the heuristic relevance ranking engine  may determine the application heuristic relevance ranking  for the potentially relevant application , shown in  as potentially relevant application A, based on the total number of API calls \u2018n\u2019 represented by nodes - that represent different potentially relevant API calls  found in the potentially relevant application , the total number of connections between the potentially relevant API calls  (e.g., edges -) equal to n(n\u22121) (e.g., data flow edge count ), the quality of the connections (e.g., strong connectivity or weak connectivity), and the type of link (e.g., loop link, single link, or no link) between the potentially relevant API calls .","The applications metadata  and API metadata  may describe the data flow paths between the different potentially relevant API calls  (e.g., nodes -) within the potentially relevant application . For example, the logic analyzer  may determine common API parameters  and logic branches (e.g., if-then-else) found within the potentially relevant application  and potentially relevant API calls  to generate the data flow graphs , control flow graphs  and API call graphs . The logic analyzer  may, as  also illustrates, identify the function (e.g., K(x), J(x), S(y), P(y), F(x), and G(z)) of each potentially relevant API call  (e.g., -, and ) to determine the connectivity rankings .","In one implementation, the logic analyzer  may assign a weight W(e.g., connectivity ranking ) to each connection between the potentially relevant API calls  (e.g., nodes -). The logic analyzer  may assign weak connections a weight of 0.5 and strong connections a weight of 1.0 depending on multiple factors. For example, edge , edge  and edge  may represent weak connections between potentially relevant API calls  represented by node pairs  and ,  and , and  and  (e.g., function pairs K(x) and F(x), K(x) and J(x), and S(y) and P(y), respectively). Following the above example, where functions K(x) and F(x) share a common API parameter , but neither function generates the value of the common API parameter  then the logic analyzer  may assign the connectivity ranking  between node pair  and , represented by edge , a weak connection weight of 0.5. A weak connection assigned to a node pair (e.g.,  and ) may indicate a low relative probability (e.g., in comparison to the connectivity rankings of other node pairs) that the node pair implements the high-level processing concept represented by the original query . The logic analyzer  may use other heuristic analysis methods and tools to determine whether to assign a weak connection to a connectivity ranking .","Alternatively, edge , and edge  may represent strong connections between potentially relevant API calls , represented by node pairs  and , and  and  (e.g., function pairs K(x) and P(y), and J(x) and S(y), respectively). The logic analyzer  may determine that where function J(x) produces variable y, which both J(x) and S(y) share then the node pair  and , represented by edge , may be assigned a strong connectivity ranking . A strong connection assigned to a node pair (e.g.,  and ) may indicate a high relative probability (e.g., in comparison to the connectivity rankings of other node pairs) that the node pair implements the high-level processing concept represented by the original query . The logic analyzer  may use other heuristic analysis methods and tools to determine whether to assign a strong connection to a connectivity ranking .","The logic analyzer  may also assign a link value L (e.g. link value ) to each connection between potentially relevant API calls . For example, Exemplar system  may assign a link value L equal to 1 where a loop link (e.g., edges - form a loop) exists between potentially relevant API calls  (e.g., nodes -). Exemplar system  may assign a link value L equal to 0.5 where a single link (e.g., edge ) exists between potentially relevant API calls  (e.g., nodes -). In another implementation, Exemplar system  may assign a link value L equal to 0 where no link exists between potentially relevant API calls  (e.g., node  represents a potentially relevant API call  that does not have a connection with other potentially relevant API calls in a potentially relevant application ). Additional, different, or fewer weights may be used. The heuristic relevance ranking engine  may use the connectivity rankings  and link values  assigned to each connection between potentially relevant API calls  to determine the application heuristic relevance ranking  according to:",{"@attributes":{"id":"p-0085","num":"0084"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"munderover":{"mo":"\u2211","mrow":[{"mi":"i","mo":"=","mn":"1"},{"mi":"n","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}}]},"mo":"\u2062","mrow":{"mfrac":{"mrow":[{"msub":[{"mi":["W","i"]},{"mi":["L","i"]}],"mo":"\u2062"},{"mi":"n","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":"-","mn":"1"}}}]},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["where","i","ranges","from","to"],"mn":"1","mrow":{"mrow":{"mi":"n","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"n","mo":["\u2062","\u2062"],"mstyle":{"mtext":"-"},"mn":"1"}}},"mo":"."}}}},{"mrow":{"mo":["(",")"],"mrow":{"mi":"Equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mn":"1"}}}]}}}}},"The logic analyzer  may determine an API call heuristic relevance ranking  for a potentially relevant API call  based on the connectivity ranking  and link value  assigned to each edge that includes the potentially relevant API call . For example, where m represents the number of node pair including a particular node (e.g.,  and ,  and , and  and ) and the number of edges (e.g., ,  and ) that include the node equals m(m\u22121), and the assigned value for each connectivity ranking  and link value  for each edge that includes the node represent W and L, respectively, the API call heuristic relevance ranking  for the node may be determined according to Equation 1 above where m substitutes for n:",{"@attributes":{"id":"p-0087","num":"0086"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"munderover":{"mo":"\u2211","mrow":[{"mi":"j","mo":"=","mn":"1"},{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"m","mo":"-","mn":"1"}}}]},"mo":"\u2062","mrow":{"mfrac":{"mrow":[{"msub":[{"mi":["W","j"]},{"mi":["L","j"]}],"mo":"\u2062"},{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"m","mo":"-","mn":"1"}}}]},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":["where","j","ranges","from","to"],"mn":"1","mrow":{"mrow":{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"m","mo":"-","mn":"1"}}},"mo":"."}}}}}},{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 8","b":["124","210","124","510","202","802","104","202","804","516","204","520","516","806","124","202","808","514","206","208","210","212","810","606","112","812","602","214","620","216","218","210","212","814","602","428","430","604","210","428","430","816","602","210","220","210","428","818","602","216","218","210","212","208","820"]},{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 9","b":["124","114","216","210","602","210","212","904","602","432","433","906","43","908","602","432","433","650","210","214","212","910","602","216","210","912","216","218","602","216","218","210","212","208","914"]},{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 10","b":["440","400","624","426","418","420","422","424","222","1002","400","422","424","1004","624","422","424","436","440","1006","440","626","422","424","436","440","1008","124","444","202","124","106","436","422","424","440","444"]},{"@attributes":{"id":"p-0091","num":"0090"},"figref":["FIG. 11","FIG. 12"],"b":["128","128","1102","118","128","1104","1106","1106","128","124","1106","130","1202","132"]},"The RAE area logic  may include graphics libraries, window rendering calls, and other user interface logic operable to display interface elements, receive input, and pass the input to any particular program logic in the RAE . The RAE area logic  may further include the concept query display logic , the concept distribution display logic , the source code display logic  and the metadata display logic . The concept query display logic  may include topics , words , and concepts  of the original query  and\/or the expanded query . The concept query display logic  accepts the topics , words , concepts , the original query  and the expanded query  from Exemplar, and generates a window in the RAE user interface  (as described in more detail in connection with ) that presents the topics as selectable focus items for verifying recommended application functionality.","The concept distribution display logic  may include recommended application representations  of the recommended applications  (e.g., HRAs). In one implementation, the recommended applications  include the relevant application logic  and relevant API call logic (e.g.,  and ) obtained from Exemplar based on the original query  and\/or the expanded query . The recommended application representations  include concept distribution locators  that identify potential implementation locations of one of the topics, concepts and words. Exemplar identifies the location (e.g., concept distribution locators) in application logic where an API call implements a high-level processing concept. The concept distribution display logic  generates a visualization of a recommended application. The concept distribution display logic  may, for example, generate a concept distribution display region  that shows one or more of the modules, source code files, header files, library files, or other recommended application source files. The concept distribution display logic  further locates within the recommended application source files the API calls that implement the topics , words , concepts , the original query  and the expanded query , selected by an operator. The concept distribution display logic  may denote each location with a concept distribution locator , such as a solid horizontal line with hyperlink functionality through the recommended application source file at the location where the API call exists in the source file. Other concept distribution locators  may be used such as geometric shapes (e.g., circles, squares) and (e.g., fonts, graphics (e.g., lines or pointers), color and\/or sound).","The concept distribution display logic  is operable to receive concept distribution locator selections . The concept distribution display logic  may convey the concept distribution locator selection  to the source code display logic . As described in more detail below, the source code display logic  generates a source code display region on the user interface which displays the actual code at the selection point. As a result, an operator may evaluate the code to determine whether the code actually implements the search terms selected from the concept query display region.","The source code display logic  may include source code portions  of a recommended application . The source code portions  may include the potential implementation location of source code (e.g., highlighted concepts ) for a selected concept distribution locator . The source code display logic  accepts a concept distribution location selection  from the concept distribution display logic . In response, the source code display logic  retrieves the recommended application code at the selection point and presents the source code for review in the source code display region. Furthermore, the concept distribution display logic  highlights source code components in the display such as API calls in the source code that match the concepts selected from the concept query display region. Accordingly, an operator may review the source code to determine whether the source code actually does implement the concepts selected from the concept query display region. The source code display logic  may include read-only and edit modes that allow the source code display logic  to be responsive to source code edits  entered by a developer in the course of evaluating the recommended application .","The metadata display logic  may include application metadata  and API metadata  for the recommended applications  based on the topics , words , concepts , the original query  and the expanded query . The metadata display logic  may also include concept query statistics  and semantics information  based on the topics , words , concepts , the original query , the expanded query  and\/or recommended applications . In one implementation, concept query statistics  and semantics information  are determined by the heuristic relevance ranking engine  as a product of determining the API call heuristic relevance rankings  of the relevant API call logic-1  and the relevant API call logic-2 , based on analyzing semantics derived from the expanded query  and the expanded search result .",{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 12","b":["1202","132","1202","1204","1206","1214","1210","1204","1108","1110","1112","202","206","1204","1108","1110","1112","1204"]},"The concept distribution display region  displays the recommended application representations (RAR)  and  of a recommended application . For example, the RAR  may represent the source code file that includes the main( ) function, while the RAR  may represent the source code file with an alleged JPEG to BITMAP conversion routine. The recommended application representations  and  include concept distribution locators , , , , , and  inserted by the concept distribution display logic  that identify potential implementation locations in the source code files of the topics , words , concepts , the original query  and the expanded query  alone or in combination. The concept distribution locators , , , , , and  may employ different identifiers (e.g., fonts, graphics (e.g., lines or pointers), color and\/or sound) to identify a relationship between the concept distribution locators and the topics , words , concepts  of the original query  and the expanded query . The source code display region  includes highlighted concepts  (e.g.,  and ). In one implementation, the highlighted concepts  (e.g.,  and ) include identifiers (e.g., fonts, color and\/or sound) to indentify a relationship between the highlighted concepts  and the concept distribution locators (e.g., , , , , , and ). The RAE area logic  may use fonts, color and\/or sound (e.g., audio queues) to indicate relationships between the topics , words , concepts , concept distribution locators (e.g., , , , , , and ) and highlighted concepts , as indicated by the arrows  and .","In one implementation, the recommended application representations (,  and ) and\/or the concept distribution locators (e.g., , , , , , and ) are displayed in response to the selection of a particular topic , word , concept , and\/or element of the original query  and\/or the expanded query . In other words, the recommended application representations (,  and ) and\/or the concept distribution locators (e.g., , , , , , and ) displayed in the concept distribution display region  may be responsive to selections made in the concept query display region .",{"@attributes":{"id":"p-0100","num":"0099"},"figref":["FIG. 13","FIG. 13","FIG. 13"],"b":["1202","1202","1204","1206","1214","1210","1204","1302","1206","1304","1","1","2","3","4","5"]},"The recommended application representation  shows the source code at a specific concept location in a specific source code file, as selected by an operator. Thus, when an operator selects, for example, RAC, and the concept distribution locator , the concept distribution display logic  responds by retrieving the RAC source code at and around the concept location. The concept distribution display logic  displays the retrieved code in the recommended application representation  area. Furthermore, the concept distribution display logic highlights the sections of code that Exemplar's search techniques determined relate to the search terms shown in the concept query display region . As shown in , for example, the concept distribution display logic  has highlighted (using underlining) the source code components  \u201cnew\u201d and \u201c.set\u201d as relevant to the selected search terms \u201clength\u201d and \u201ccreate\u201d in the concept query display region .",{"@attributes":{"id":"p-0102","num":"0101"},"figref":"FIG. 14","b":["132","132","1402","132","124","1118","134","202","206","1404","134","136","1118","1120","1206","1406","1120","1118","1120","1206","1408","138","1124","1120","1410","140","1412","128","1414","1416"]},"The RAE  greatly reduces the time, cost, and other resource expenditures associated with evaluating a recommended application. The RAE  produces relevant results starting with high-level processing concepts. A software developer may deploy the highly relevant application into production upon successful evaluation.","Furthermore, it is noted that the system carries out electronic transformation of data that may represent underlying physical objects. For example, the RAE area logic visually transforms source code by adding search term locators and highlighting of relevant code that matches search terms. In addition, the RAE may be implemented as a particular machine. For example, the particular machine may include a CPU, memory, and a software library for carrying out the RAE area logic noted above.","A number of implementations have been described. Nevertheless, it will be understood that various modifications may be made without departing from the spirit and scope of the invention. Accordingly, other implementations are within the scope of the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The disclosure can be better understood with reference to the following drawings and description. The components in the figures are not necessarily to scale, emphasis instead being placed upon illustrating the principles of the invention. Moreover, in the figures, like referenced numerals designate corresponding parts or elements throughout the different views.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
