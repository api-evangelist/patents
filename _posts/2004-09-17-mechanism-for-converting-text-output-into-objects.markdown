---
title: Mechanism for converting text output into objects
abstract: The techniques and mechanisms described herein are directed at converting text into objects based on a template that describes the format of the text. The objects then being available for further processing. The conversion mechanism converts the text into an object having at least one method that is directly invocable and that is specific to a data type specified for the live object. The template comprises an object header indicator and a corresponding object header pattern. A new object is created whenever the object header pattern is identified within the text. In addition, the template comprises one or more field indicators each having a corresponding field pattern. The field pattern is in a format of a regular expression. A new field is created for the new object whenever a field pattern is identified within the text.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07555708&OS=07555708&RS=07555708
owner: Microsoft Corporation
number: 07555708
owner_city: Redmond
owner_country: US
publication_date: 20040917
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This document generally relates to text conversion mechanisms, and more particularly, to mechanisms for converting text output into objects.","In traditional command-line environments, commands execute and produce text output. The text output may then be pipelined to another command that parses the text output and performs additional processing. Recently, an object-based command-line environment has been developed. Commands (i.e., cmdlets) in the object-based command-line environment pass objects between each other. These cmdlets are not regular .exe files, but are rather a form of managed code assemblies. The operation of these cmdlets within the object-based command-line environment provides many benefits and increased functionality over the traditional command-line environments.","Unfortunately, there are many traditional commands written for the traditional command-line environment that can not utilize the features provided by the new object-based command-line environment when they are executed in the new environment. One way in which these traditional commands may utilize the new features is by re-writing the traditional commands as cmdlets. Another way is by writing a unique wrapper for each traditional command, where the wrapper is configured to generate the objects that can utilize the functionality provided by the new object-based command-line environment. Both of these approaches, however, involve a huge expense in code development and testing.","Therefore, there is a need for a mechanism that will allow traditional commands to utilize features provided in the new object-based command-line environment without having to incur a huge expense in code development and\/or testing of the commands.","The techniques and mechanisms described herein are directed at converting text into objects based on a template that describes the format of the text. The objects then being available for further processing. The conversion mechanism converts the text into an object having at least one method that is directly invocable and that is specific to a data type specified for the live object. The template comprises an object header indicator and a corresponding object header pattern. A new object is created whenever the object header pattern is identified within the text. In addition, the template comprises one or more field indicators each having a corresponding field pattern. The field pattern is in a format of a regular expression. A new field is created for the new object whenever a field pattern is identified within the text.","Briefly, the present text conversion mechanism converts text output into an object based upon a description of the text output in an output template. The object may then be used in further processing. The following description describes the text conversion mechanism as utilized within an administrative tool environment. However, after reading the following description, one skilled in the art will appreciate that the text conversion mechanism may be utilized in other environments and is applicable to other scenarios. While each of these other environments is not individually described, one will appreciate that the scope of the claimed text conversion mechanism includes operation within these other environments.","The following detailed description is divided into several sections. A first section describes an illustrative computing environment in which the present text conversion mechanism may operate. A second section describes an exemplary implementation for converting text output into an object within an administrative tool environment. A third section describes an exemplary process for converting the text output into an object.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","102","104","104","104","105","106","107","104","120","104","130","120","120","130","105","106","106","140","108"]},"Computing device  may have additional features or functionality. For example, computing device  may also include additional data storage devices (removable and\/or non-removable) such as, for example, magnetic disks, optical disks, or tape. Such additional storage is illustrated in  by removable storage  and non-removable storage . Computer storage media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules, or other data. System memory , removable storage  and non-removable storage  are all examples of computer storage media. Thus, computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media may be part of device . Computing device  may also have input device(s)  such as keyboard, mouse, pen, voice input device, touch input device, etc. Output device(s)  such as a display, speakers, printer, etc. may also be included. These devices are well known in the art and need not be discussed at length here.","Computing device  may also contain communication connections  that allow the device to communicate with other computing devices , such as over a network. Communication connection(s)  is one example of communication media. Communication media may typically be embodied by computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as a carrier wave or other transport mechanism, and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Computer readable media can be any available media that can be accessed by a computer. By way of example, and not limitation, computer readable media may comprise \u201ccomputer storage media\u201d and \u201ccommunications media.\u201d","Various modules and techniques may be described herein in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other devices. Generally, program modules include routines, programs, objects, components, data structures, etc. for performing particular tasks or implement particular abstract data types. These program modules and the like may be executed as native code or may be downloaded and executed, such as in a virtual machine or other just-in-time compilation execution environment. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2","b":["200","230","200","100","200"]},"However, as described above, there are many traditional commands (e.g., legacy utilities)  that only output text. Thus, these traditional commands  can not utilize the superior performance and flexibility provided by the framework . Thus, as will be described, the present conversion mechanism  allows the text output generated from traditional commands  to be converted into an object which can then be further processed using other commands\/cmdlets available within the framework . Thus, the focus of the following discussion is on the text conversion mechanism  that converts text output into an object. The utilization of the text conversion mechanism  within the described framework  provides one illustrative embodiment. Therefore, even though the framework  may have other components and mechanisms, these other components and mechanisms are not described here for the sake of brevity and clarity. However, the lack of a discussion here of those other mechanisms does not imply that the present conversion mechanism is not applicable in the presence of those other mechanisms. For more information about one particular framework which is particularly suited to the present conversion mechanism, refer to U.S. patent application Ser. No. 10\/693,785\/U.S. Pat. No. 7,155,706, entitled \u201cAdministrative Tool Environment\u201d, which is owned by the same assignee as the present conversion mechanism, and is incorporated here by reference.","The framework  includes a shell , a core engine , a script engine , and a parser . The shell  represents one mechanism for managing the interactions between a user and the other components within the framework . The shell  allows a user to provide commands to the computing system. The shell  also provides a mechanism to present feedback to the user, such as by displaying results of a command. The shell  may provide a graphical, textual, audible, or other interface.","Generally speaking, the core engine  manages the flow of information through the framework . The core engine  interacts with the shell  to receive command-line instructions. In the case where a command-line instruction is complex and contains multiple commands in a pipeline, the core engine  may interface with the parser  to decompose the command line instruction into its constituent commands. The parser  may additionally resolve any parameters that may be associated with a particular command and identify those to the core engine . The parser  also maps input requests into uniform cmdlet objects that are used throughout the framework . The core engine  also interacts with the shell  to present any output to the user.","The script engine  provides mechanisms and services to tie multiple cmdlets together using a script, where a script is an aggregation of command lines that share session state under strict rules of inheritance. The multiple command lines within the script may be executed either synchronously or asynchronously, based on the syntax provided in the input request. The script engine  has the ability to process control structures, such as loops and conditional clauses and to process variables within the script.","The framework  also includes various commands . The commands  are, typically, executables directed at managing system properties. Throughout the following discussion, the term \u201ccmdlet\u201d is used interchangeably with the term command to refer to commands that are used within framework . Thus, cmdlets correspond to commands in traditional command-line environments, but are quite different than these traditional commands. For example, cmdlets are typically smaller in size than their counterpart commands because the cmdlets can utilize common functions provided by the framework, such as parsing, data validation, error reporting, and the like. Because such common functions can be implemented once and tested once, the use of cmdlets throughout the framework allows the incremental development and test costs associated with application-specific functions to be quite low compared to traditional environments.","In addition, in contrast to traditional command-line environments, cmdlets do not need to be stand-alone executable programs. Rather, cmdlets may run in the same processes within the framework. This allows cmdlets to exchange \u201clive\u201d objects between each other. This ability to exchange \u201clive\u201d objects allows the cmdlets to directly invoke methods on these objects. Thus, the term \u201clive\u201d object refers to objects that have methods that are directly invocable. The methods that are directly invocable are specific to the data type of the live object. In contrast, a \u201cdead\u201d object refers to an object that does not have methods that are directly invocable.","Having described the above framework , the advantages and usefulness of the present text conversion mechanism  for use within framework  is easily discernable. Thus, by utilizing the present text conversion mechanism , the text output (not shown) generated by traditional utilities  may be converted into a \u201clive\u201d or \u201cdead\u201d object and made available for further processing within framework .","The present text conversion mechanism  includes an output template  and a text conversion cmdlet . One example of an output template  is illustrated in  and described below. Briefly stated, the output template  defines a structure for one or more converted objects  that are generated from the text output produced by the traditional utility . One example of the processing performed by text conversion cmdlet , in conjunction with processing performed within framework , is illustrated in  and described below.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3","b":["232","232","300","302","304","304","306","308"]},"The output template  is created by some individual or process that is aware of the format of the text output . Thus, the output template  identifies an object header indicator  and a corresponding object header pattern . Using the example text output , the object header indicator defines the object header pattern  as a series of dashes. The output template  also identifies one or more fields associated with the object. For example, for the above example, two fields are defined. Each field is identified using a field indicator (e.g., field indicator  and ) and an associated field pattern (e.g., field pattern  and ), respectively. The field patterns  and  may take the form of a regular expression, where the term regular expression refers to a language for describing strings. The use of regular expressions for describing strings is well known in the art and is only described as necessary for describing the present text conversion mechanism . Therefore, the regular expression includes a static portion (e.g., static portion  and ) that identifies actual text (e.g., \u201cUser:\u201d and \u201cDomain:\u201d) that will be encountered in the text output . The regular expression also includes a dynamic portion (e.g., dynamic portions  and ) that identifies the name for the field within the object and signals the parser to obtain the data after the static portion and assign the data as a value for the corresponding field. It is important to note that the field patterns  and  may take other forms than regular expressions without departing from the scope and spirit of the present text conversion mechanism.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 4","FIG. 2","FIG. 3"],"b":"402"},"At block , an output template associated with the traditional command is identified. Because each traditional command has a template that describes its output, there may be numerous templates. Therefore, the template associated with the traditional command that is currently being processed is identified. The identification may occur by registry, wrapper, and the like. For example, if a wrapper is utilized, each .exe has an associated wrapper script. Continuing with the example in , the showuser.exe has a wrapper script named showuser.script. Each wrapper script includes a line specifying the text conversion cmdlet, the executable, and the output template. Thus, the showuser.script may have a line such as: text2 framework showuser.exe $showusertemplate. Thus, the output template identified as showusertemplate is used whenever the showuser.exe command is entered. In another embodiment, there may be a lookup mechanism for associating the executable with the corresponding output template. These and other mechanisms provide a means for mapping a template to a traditional command.","In addition, each variation of a command may be mapped to a different template. For example, the output of a \u2018dir\u2019 command and a \u2018dir\/w\u2019 may each be mapped to a separate template in order to handle the corresponding output format. Thus, the mapping means may map a traditional command to a template based on switch arguments associated with the traditional command.","At block , the traditional command is executed to produce the text output. As mentioned above, because the execution of the traditional command produces text output, the traditional command can not utilize many of the features offered within the framework. Therefore, as will be described below, the text is converted into an object which can then be utilized by the features within the framework","At block , the text is converted into an object based on the description within the associated output template. Briefly, described below in detail in conjunction with , the text conversion cmdlet collects the text and attempts to match lines within the collected text to patterns identified within the output template.  now describes this process in more detail.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 5","FIG. 4"]},"At block , the text output from the traditional command is collected. The collected text output is assigned to a variable. In one embodiment, the text output may be collected as an array of strings. To support this embodiment, the framework may assign argument(0) of the command line within the script (i.e., the traditional command) to a command variable and assign argument(1) (i.e., the output template) to a template variable. The command variable and the template variable are accessible to the text conversion cmdlet for further processing. The text conversion cmdlet may then initiate another cmdlet that performs the process of collecting the text output into an output variable. The text conversion cmdlet may initiate this cmdlet by including the following statement: $output=invoke-command $command. The invoke-command cmdlet is a cmdlet  provided by the framework  shown in .","At begin loop , each line within the collected text output (i.e., $output) is processed via blocks -. Then, a next line is obtained at end loop  until all the lines within $output have been processed.","At block , the state of the processing determines the flow. If the process is looking for an object, processing continues at block . If the process is looking for a field, processing continues at block .","At block , an object header pattern specified for the object header indicator is located. If an object header pattern is not found, processing proceeds to block  where each of the objects that were found are output. However, if the object header pattern is found, processing continues at block .","At block , a new empty dead object is created. In one embodiment, the new object that is created is in a form of a hash table that has no form of its own. Rather, the hash table is a collection of properties and values. Thus, referring to the example illustrated in , a statement such as $o=new hashObject( ), may be implemented. For simplicity, the decision block that determines whether the new object should be a live object or a dead object is omitted from this . As discussed above, if the new object takes the form of a \u201clive\u201d object, the new object will have methods associated with its specific data type. This allows the new object to provide additional processing not available if the new object takes the form of a \u201cdead\u201d object. Determining whether the new object should take the form of a \u201clive\u201d or \u201cdead\u201d object may be based on information within the output template, a look-up table, and other means. In one embodiment, referring back to , the output template may include a live object indicator  and an associated live object type . The processing performed for creating a live object is described below in conjunction with . Processing continues at end loop .","At block , when in the state is looking for a field, a field pattern associated with the line is located and processing proceeds to decision block . At decision block , a determination is made whether a field pattern associated with the line was located. If not, processing changes to the looking for an object state at block . If the field pattern is found, processing continues at block . At block , a new field for the dead object is created. Referring again to the example illustrated in , a statement such as o.name=\u201cKumar\u201d, may be implemented when the first line is processed and a statement such as o.domain=\u201cNTDEV\u201d, may be implemented when the second line is processed. Thus, the properties and values are populated for the new object based on the text output produced from the traditional command. Processing continues at end loop .","As described above, end loop  gets another line for processing until each of the lines within the collected text has been processed. Once all the lines within the collected text have been processed, processing continues at block .","At block , each object with its associated properties are output. These one or more objects may then be pipelined to other cmdlets within the framework so that additional information can be obtained. Thus, by utilizing the present text conversion mechanism within the above described framework, traditional commands may operate as if they were written as a cmdlet and will have access t all the diverse capabilities provided by the framework.","In certain situations, the field will itself be an object. When this occurs, processing switches to the looking for an object state at .",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 6","FIG. 4","FIG. 5"],"b":["600","500","600"]},"Once it is determined that an object header pattern has been found at decision block , processing continues at block . At block , the object type name associated with the object header pattern is noted. Because some objects do not support a default constructor, an empty live object is not created at this point. Rather, as will be described, the live object is created after each of the fields associated with the object has been determined. Processing continues at end loop  as described above.","In another modification, after it has been determined that the field pattern associated with the line has been found at decision block , processing continues at block . At block , the field type and associated value are noted. As explained above, this information will be used when the live object is created. From block , processing continues at decision block .","At decision block , a determination is made whether all the fields have been found. If all the fields have not been found, processing continues at block  and proceeds as described above. However, if all the fields have been found, processing continues at block .","At block , a live object is created based on the object type and the field types and values that were noted in blocks  and , respectively. In one embodiment, a constructor for the object is called with suitable parameters, thus creating the live object. Processing then continues at block  and proceeds as described above.","While the processing of dead objects and live objects is illustrated in separate flow diagrams, one skilled in the art will appreciate that the flow diagrams illustrated in  and  may be combined so that both live objects and dead objects may be created from the collected output.","Importantly, even though traditional commands have various formats for the text output that they generate, the only unique component of the present text conversion mechanism for each traditional command is the output template. Therefore, there is minimal effort in integrating a traditional command for use as a cmdlet within the framework.","The present mechanism for converting text output into objects may be performed such that the parsing of the output of the traditional command is performed in parallel as the traditional command generates the output. In another alternative, the parsing of the output may be performed using output stored in a disk file. In another alternative, the traditional command may be executed on a machine running a different operating system than the local machine. The output of the traditional command is then made available to the local machine which performs the present conversion.","Reference has been made throughout this specification to \u201cone embodiment,\u201d \u201can embodiment,\u201d or \u201can example embodiment\u201d meaning that a particular described feature, structure, or characteristic is included in at least one embodiment of the present invention. Thus, usage of such phrases may refer to more than just one embodiment. Furthermore, the described features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.","One skilled in the relevant art may recognize, however, that the invention may be practiced without one or more of the specific details, or with other methods, resources, materials, etc. In other instances, well known structures, resources, or operations have not been shown or described in detail merely to avoid obscuring aspects of the invention.","While example embodiments and applications have been illustrated and described, it is to be understood that the invention is not limited to the precise configuration and resources described above. Various modifications, changes, and variations apparent to those skilled in the art may be made in the arrangement, operation, and details of the methods and systems of the present invention disclosed herein without departing from the scope of the claimed invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Non-limiting and non-exhaustive embodiments are described with reference to the following figures, wherein like reference numerals refer to like parts throughout the various views unless otherwise specified.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 4","FIG. 2"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 6","FIG. 4"]}]},"DETDESC":[{},{}]}
