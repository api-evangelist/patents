---
title: Determining performance of a software entity
abstract: Methods, systems, and products for determining performance of a software entity running on a data processing system. The method comprises allowing extended execution of the software entity without monitoring code. The method also comprises intermittently sampling behavior data for the software entity. Intermittently sampling behavior data may be carried out by injecting monitoring code into the software entity to instrument the software entity, collecting behavior data by utilizing the monitoring code, and removing the monitoring code. The method also comprises repeatedly performing iterations of the allowing and sampling steps until collected behavior data is sufficient for diagnosing performance of the software entity. The method may further comprise analyzing the collected behavior data to diagnose performance of the software entity.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08850402&OS=08850402&RS=08850402
owner: International Business Machines Corporation
number: 08850402
owner_city: Armonk
owner_country: US
publication_date: 20090522
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Instrumenting a section of code, or software entity, with monitoring code is a common approach to extracting software behavior data for performance analysis. The section of code monitored may be a few instructions or an entire procedure. Extracted behavior data may then be utilized in analyzing the performance of the software entity. To instrument the code, hooks may be added before entering or after exiting the section of code (software entity). These hooks temporarily pass control to monitoring routines that collect, process, and\/or save the behavior data. Each time a system processor executes the code of the software entity, the processor executes the monitoring code, thereby adding to the collection of behavior data.","Methods, systems, and products for determining performance of a software entity running on a data processing system are disclosed herein. The method comprises allowing extended execution of the software entity without monitoring code. The method also comprises intermittently sampling behavior data for the software entity. Intermittently sampling behavior data may be carried out by injecting monitoring code into the software entity to instrument the software entity, collecting behavior data by utilizing the monitoring code, and removing the monitoring code. The method also comprises repeatedly performing iterations of the allowing and sampling steps until collected behavior data is sufficient for diagnosing performance of the software entity. The method may further comprise analyzing the collected behavior data to diagnose performance of the software entity.","The foregoing and other objects, features and advantages of the disclosure will be apparent from the following more particular descriptions of exemplary embodiments of the invention as illustrated in the accompanying drawings wherein like reference numbers generally represent like parts of exemplary embodiments of the invention.","Exemplary methods, systems, and design structures for determining performance of a software entity running on a data processing system are described with reference to the accompanying drawings. The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein, the singular forms \u201ca\u201d, \u201can\u201d, and \u201cthe\u201d are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms \u201ccomprises\u201d and\/or \u201ccomprising.\u201d when used in this specification, specify the presence of stated features, integers, steps, operations, elements, and\/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and\/or groups thereof.","The corresponding structures, materials, acts, and equivalents of all means or step plus function elements in the claims below are intended to include any structure, material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description, but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 1A","FIG. 1B"],"b":["102","104","106","108","106","108","102","104","106","108","106","108","104","110","110","106","108","104","104","110"]},"However, the overhead associated with monitoring module  (as well as any hooks used to implement the monitoring module ) may be sufficient to bias program behavior for software entity \u2032 and thus influence results of performance analysis. The added overhead may also extend the runtime of the program to such a degree as to render the approach unusable. To increase accuracy and usability of the monitoring module , embodiments of the present invention nominally operate in the configuration depicted in  to generate behavior data typical to nominal operation. Intermittently (e.g. periodically), embodiments of the invention operate in the configuration of  to collect limited samples of the typical behavior data generated by nominal operation by executing monitoring module  in its entirety. For example, monitoring module  may be executed so that the module collects only a single sample of behavior data (although the sample may contain a variety of behavior data). By collecting limited samples over a sufficient period of time, the samples of behavior data accumulated over time may then be analyzed to accurately diagnose performance of the software entity with little or no processing overhead or additional run time.","Shifting to the configuration of  is carried out by instrumenting the software entity \u2032 with monitoring module . When the instrumented code is executed, it initializes whatever resources it needs (such as performance monitor counters, etc.) and runs the instrumented code section, then collects (or processes or saves) any performance data it is intended to monitor. It is then uninstrumented, such that on the next invocation of the previously instrumented code, no instrumentation is present (for example, no instrumentation hooks are run and no instrumented code is executed).","Extended execution of the software entity  generates accurate behavior data. Intended execution of the software entity without monitoring code may be defined as execution of the software entity to an extent negating overhead affects attributable to the monitoring code. In some implementations, extended execution of the software entity without monitoring code may comprise maintaining a ratio of execution of instances of the software entity without monitoring code to execution of instances of the software entity with monitoring code of at least 10:1. In other implementations, the ratio may be 100:1, 1000:1, or higher. Maintaining the appropriate ratio may be carried out directly, or by tuning execution by adjusting counter variables, interrupt triggers, or timers as described in further detail below.","Embodiments of the presently disclosed invention are implemented to some extent as software modules installed and running on one or more data processing systems (\u2018computing devices\u2019), such as servers, workstations, tablet computers, PCs, personal digital assistants (\u2018PDAs\u2019), smart phones, and so on.  sets forth a block diagram of an exemplary computer . Computing device  includes at least one computer processor  as well as a computer memory, including both volatile random access memory (\u2018RAM\u2019)  and some form or forms of non-volatile computer memory  such as a hard disk drive, an optical disk drive, or an electrically erasable programmable read-only memory space (also known as \u2018EEPROM\u2019 or \u2018Flash\u2019 memory). The computer memory may be connected through a system bus  to the processor  and to other system components. Thus, the software modules may be program instructions stored in computer memory.","An operating system  is stored in computer memory. Operating system  may be any appropriate operating system such as Windows XP, Windows Vista, Mac OS X, UNIX, LINUX, or AIX from International Business Machines Corporation (Armonk, N.Y.).","Computing device  may also include one or more input\/output interface adapters . Input\/output interface adapters  may implement user-oriented input\/output through software drivers and computer hardware for controlling output to output devices  such as computer display screens, as well as user input from input devices , such as keyboards and mice.","Computing device  may also include a communications adapter  for implementing data communications with other devices . Communications adapter  implements the hardware level of data communications through which one computer sends data communications to another computer through a network.","Also stored in computer memory is a performance determination module , which may operate in kernel mode. The performance determination module  includes computer program instructions for allowing extended execution of the software entity without monitoring code. The module also includes computer program instructions for intermittently sampling behavior data for the software entity, comprising: computer program instructions for injecting monitoring code into the software entity to instrument the software entity; computer program instructions for collecting behavior data by utilizing the monitoring code; and computer program instructions for removing the monitoring code. The performance determination module may also include computer program instructions for repeatedly performing iterations of the allowing and sampling steps until the collected behavior data is sufficient for diagnosing performance of the software entity.","Performance determination module  may be implemented as one or more sub-modules operating in separate software layers or in the same layer. Although depicted as a separate module from the operating system in , the performance determination module  or one or more of the sub-modules may be incorporated as part of the operating system . In particular, one or more of the sub-modules may be incorporated as part of an interrupt handler. In some embodiments, the performance determination module  may be implemented in the software stack, in hardware, in firmware (such as in the BIOS), or in any other manner as will occur to those of ordinary skill in the art.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 3","FIG. 3"],"b":["304","312","302","304","306","308","304","320","304"]},"The method also includes repeatedly performing iterations of the allowing and sampling steps until collected behavior data  is sufficient for diagnosing performance of the software entity  (decision ). If the collected behavior data is not sufficient for diagnosing performance of the software entity (), another iteration of the allowing  and sampling  steps are performed. If the collected behavior data is sufficient for diagnosing performance of the software entity (), the monitoring process ends, and the software entity returns to nominal execution. In other implementations, the monitoring process may continue indefinitely to continually monitor software entity , particularly if the overhead of the monitoring process as implemented is low. In some embodiments, the method includes analyzing the collected behavior data to diagnose performance of the software entity. Analyzing the collected behavior data may be carried out by extrapolating or interpolating the collected behavior data. The method may also include presenting the collected behavior data or the results of the analysis.","Sufficiency of collected behavior data may be defined in terms of the number of samples and\/or quality of samples. For example, collected behavior data may be sufficient if a particular number of samples are included and if the samples are sufficiently random. Irregular intervals may be used to increase the randomness of behavior data by avoiding timing-induced patterns. The method may include profiling representative samples to ensure randomness. In some implementations, the method may include screening, sorting, or other measures to insure sufficient randomness in the collected behavior data. Sufficiency may also be determined indirectly, such as by implementing timing, iterative, or event-triggered mechanisms.","Intermittently sampling behavior data for the software entity  (block ) is carried out by injecting monitoring code  into the software entity  to instrument the software entity (block ). Monitoring code may include lightweight processes or heavyweight processes, such as processes for measuring cache misses, flops, or energy use. Intermittently sampling behavior data for the software entity  (block ) also comprises collecting behavior data  by utilizing the monitoring code  (block ); and removing the monitoring code  (block ).",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 4","FIG. 5","FIG. 4"],"b":["310","402"]},"Collecting behavior data by utilizing the monitoring code (block ) is carried out by providing state information stored from the software entity at interrupt to the monitoring software module (block ). State information may include the minimal set of contextual data used by a task (e.g., thread or process) that must be saved to allow a task interruption and a continuation at the point or interruption at an arbitrary future time, but may also be modified to include additional data useful for sampling. The interrupt handler extension allows the interrupt handler to pass the state information generated from the execution of the non-instrumented software entity to the monitoring software module. For example, the interrupt may copy state information in hardware registers to a special location available to the monitoring software module in addition to a process control block, or may pass state information from the process control block to the monitoring software module.","Removing the monitoring code (block ) is carried out by returning control from the monitoring software module to the interrupt handler (block ). Upon exiting, for example, the method, state information is passed back to the interrupt handler (or the interrupt handler retrieves information stored in the process control block) and the interrupt handler updates the hardware registers with these values.","Referring to , the interrupt handler  performs context switches between software entity  and software entity , allowing each process extended execution. At each interrupt, the interrupt handler tests to see if the expression i=10 is true. If this value is false, the interrupt handler performs a typical context switch and increments i. When the expression is true, the interrupt handler  calls monitoring module  to sample behavior data as described above with reference to . When monitoring module  returns, the interrupt handler  resets the counter to i=0, and resumes normal handler functionality. The interrupt handler  may also be triggered to call the monitoring module  by the use of flag or communications from external modules.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 6","FIG. 7","FIG. 6"],"b":["606","604","606","612","606","606","608","610","608","610"],"i":["a ","b ","b ","a ","b ","a","a ","b","b"]},"Virtual memory management provides an abstraction between the virtual addresses (addresses used directly by the program) and the physical addresses in memory. The mappings may exist on a page basis. The size of a page may be 2048 bytes, 4096 bytes, 8192 bytes, or many more, including millions of bytes.","Embodiments of the present disclosure leverage aliasing pages with virtual memory. Consider an exemplary executable file, a.out. The executable file a.out is 65536 bytes in size, and is apportioned as follows:",{"@attributes":{"id":"p-0036","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["byte offset","name"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"133pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","start"]},{"entry":["1024","functiona"]},{"entry":["2048","functionb"]},{"entry":["4096","functionc"]},{"entry":["6440","functiond"]},{"entry":["12000","functione"]},{"entry":["16000","data"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"In one implementation, the instrumented and uninstrumented code have identical function addresses. Consider the following mappings used to instrument functione while leaving the remaining functions uninstrumented:",{"@attributes":{"id":"p-0038","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["code","virtual","uninstrumented","instrumented"]},{"entry":["page","address","phys address","phys address"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","0x10000000","0x50400000","N\/A"]},{"entry":["1","0x10001000","0x40003000","N\/A"]},{"entry":["2","0x10002000","0x84120000","0x9342000"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Many systems provide a mechanism of segmentation. For example, on the AIX operating system files may be mapped into segments. This allows two segments that have the same virtual addresses, but different physical addresses, so that toggling between instrumented code and non-instrumented code may be effected by changing the segment mapping. This is very efficient when a segment covers a large range of pages, because the virtual-to-physical mappings for a number of pages may be carried out in one step.","Referring to  with , injecting monitoring code into the software entity (block ) may be carried out by switching, from the interrupt handler  after an interrupt, to the second instance of the software in the second memory space  (block ) and providing state information stored from executing the first instance of the software entity in the first memory space  to the second instance (block ). Collecting behavior data by utilizing the monitoring code (block ) is carried out by executing the second instance of the software entity (block ).","Removing the monitoring code (block ) may be carried out by providing state information stored from executing the second instance of the software entity to the first instance after returning from the second interrupt (block ) and executing from the interrupt handler , after a second interrupt, the first instance of the software from the first memory space  (block ). Removing the monitoring code may also include causing the second interrupt.","In some embodiments, the method includes modifying the monitoring code between iterations in dependence upon the collected performance data samples. Consider a function functionc which is sometimes called by a function functiona and sometimes called by a function functionb. If the system determines that functionc executes a short time (e.g. 100 cycles) when called by functiona and a long time (e.g. 10.000 cycles) when called by functionb, additional measurements may be included in instrumentation specifically for calls to functionc from functionb, but not from functiona. The additional instrumentation may be for any measurements as will occur to those of skill in the art, such as, for example, picking up cache miss counts, branch mispredict behavior, etc.","It should be understood that the inventive concepts disclosed herein are capable of many modifications. To the extent such modifications fall within the scope of the appended claims and their equivalents, they are intended to be covered by this patent."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
