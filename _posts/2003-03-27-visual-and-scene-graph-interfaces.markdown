---
title: Visual and scene graph interfaces
abstract: A method and system implemented in an application programming interface (API) and an object model allows program code developers to interface in a consistent manner with a scene graph data structure to output graphics. Via the interfaces, program code writes drawing primitives such as geometry data, image data, animation data and other data to visuals that represent a drawing surface, including validation visual objects, drawing visual objects and surface visual objects. The code can also specify transform, clipping and opacity properties on visuals, and add child visuals to other visuals to build up a hierarchical scene graph. A visual manager traverses the scene graph to provide rich graphics data to lower-level graphics components.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07126606&OS=07126606&RS=07126606
owner: Microsoft Corporation
number: 07126606
owner_city: Redmond
owner_country: US
publication_date: 20030327
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","CONCLUSION "],"p":["The present invention is related to the following copending U.S. patent applications: Ser. No. 10\/184,795 entitled Multiple-Level Graphics Processing System and Method; Ser. No. 10\/184,796, entitled Generic Parameterization for a Scene Graph; Ser. No. 10\/185,775 entitled \u201cIntelligent Caching Data Structure for Immediate Mode Graphics;\u201d each filed on Jun. 27, 2002; and United States Patent Application entitled \u201cMarkup Language and Object Model for Vector Graphics\u201d Ser. No. 10\/693,633, filed concurrently herewith. Each related application is assigned to the assignee of the present patent application and hereby incorporated by reference in its entirety.","The invention relates generally to computer systems, and more particularly to the processing of graphical and other video information for display on computer systems.","The limits of the traditional immediate mode model of accessing graphics on computer systems are being reached, in part because memory and bus speeds have not kept up with the advancements in main processors and\/or graphics processors. In general, the current (e.g., WM_PAINT) model for preparing a frame requires too much data processing to keep up with the hardware refresh rate when complex graphics effects are desired. As a result, when complex graphics effects are attempted with conventional graphics models, instead of completing the changes that result in the perceived visual effects in time for the next frame, the changes may be added over different frames, causing results that are visually and noticeably undesirable.","A new model for controlling graphics output is described in the aforementioned U.S. patent application Ser. Nos. 10\/184,795, 10\/184,796, and 10\/185,775. This new model provides a number of significant improvements in graphics processing technology. For example, U.S. Ser. No. 10\/184,795 is generally directed towards a multiple-level graphics processing system and method, in which a higher-level component (e.g., of an operating system) performs computationally intensive aspects of building a scene graph, updating animation parameters and traversing the scene graph's data structures, at a relatively low operating rate, in order to pass simplified data structures and\/or graphics commands to a low-level component. Because the high-level processing greatly simplifies the data, the low-level component can operate at a faster rate, (relative to the high-level component), such as a rate that corresponds to the frame refresh rate of the graphics subsystem, to process the data into constant output data for the graphics subsystem. When animation is used, instead of having to redraw an entire scene with changes, the low-level processing may interpolate parameter intervals as necessary to obtain instantaneous values that when rendered provide a slightly changed scene for each frame, providing smooth animation.","U.S. Ser. No. 10\/184,796 describes a parameterized scene graph that provides mutable (animated) values and parameterized graph containers such that program code that wants to draw graphics (e.g., an application program or operating system component) can selectively change certain aspects of the scene graph description, while leaving other aspects intact. The program code can also reuse already-built portions of the scene graph, with possibly different parameters. As can be appreciated, the ability to easily change the appearance of displayed items via parameterization and\/or the reuse of existing parts of a scene graph provide substantial gains in overall graphics processing efficiency.","U.S. Ser. No. 10\/185,775 generally describes a caching data structure and related mechanisms for storing visual information via objects and data in a scene graph. The data structure is generally associated with mechanisms that intelligently control how the visual information therein is populated and used. For example, unless specifically requested by the application program, most of the information stored in the data structure has no external reference to it, which enables this information to be optimized or otherwise processed. As can be appreciated, this provides efficiency and conservation of resources, e.g., the data in the cache data structure can be processed into a different format that is more compact and\/or reduces the need for subsequent, repeated processing, such as a bitmap or other post-processing result.","While the above improvements provide substantial benefits in graphics processing technology, there still needs to be a way for programs to effectively use this improved graphics model and its other related improvements in a straightforward manner. What is needed is a comprehensive yet straightforward way for programs to take advantage of the many features and graphics processing capabilities provided by the improved graphics model and thereby output complex graphics in an efficient manner.","Briefly, the present invention provides an object model, and an application programming interface (API) for accessing that object model in a manner that allows program code developers to consistently interface with a scene graph data structure to produce graphics. A base object in the model and API set is a visual, which represents a virtual surface to the user; the scene graph is built of visual objects. Such Visuals include container visual objects, validation visual objects, drawing visual objects and surface visual objects. Visuals themselves can hold onto resource objects, such as clip objects, transform objects and so forth, and some type of Visuals (e.g., DrawingVisual, ValidationVisual) can hold on to drawing instruction lists that may reference resource objects, such as images, brushes and\/or gradients.","Typical resource objects in the scene graph are immutable once created, that is, once they are created they cannot be changed. Note that visuals are generally not considered resources, and that visuals not considered immutable to an extent, e.g., program code can replace the transform to which a Visual is pointing, but cannot change the transform itself, because the transform is immutable. The objects can be defined with a constructor or by using a companion builder object.","Via the application programming interfaces, program code writes drawing primitives such as geometry data, image data, animation data and other data to the visuals. For example, program code writes drawing primitives such as draw line instructions, draw geometry instructions, draw bitmap instructions and so forth into the visuals. Those drawing instructions are often combined with complex data like geometry data that describes how a path is drawn, and they also may reference resources like bitmaps, videos, and so forth.","The code can also specify transform, clipping and opacity properties on visuals, and methods for pushing and popping transform, opacity and hit test identification are provided. In addition, the visual has flags controlling how it participates in hit testing. The program code also interfaces with the visuals to add child visuals, and thereby build up a hierarchical scene graph. A visual manager processes (e.g., traverses or transmits) the scene graph to provide rich graphics data to lower-level graphics components.","Container visuals provide for a collection of children visuals and in one implementation, are the only visuals that can define hierarchy. The collection of children on a container visual allows for arbitrary insertion, removal and reordering of children visuals.","Drawing visuals are opened with an open call that returns a drawing context (e.g., a reference to a drawing context object) to the caller. In general, a drawing context is a temporary helper object that is used to populate a visual. The program code then uses the drawing context to add drawing primitives to the visual. The open call may clear the contents (children) of a visual, or an append call may be used to open a visual for appending to that current visual. In addition to receiving static values as drawing parameters, drawing contexts can be filled with animation objects.","A validation visual operates in a similar manner to a drawing visual, except that its drawing context is filled when the system requests that it be filled, instead of when the program code wants to fill it. A surface visual is provided to display a bitmap of pixel data, which can correspond to a drawing context filled with the pixel data, or another visual subgraph traversed by a surface visual manager that provides the pixel data. The system provides a drawing context implementation that can directly draw into the surface, and a SurfaceVisualManager can be used to compose a Visual scene graph into a surface. Other types of visuals are also described.","Thus, different types of primitives may be drawn into a visual using a drawing context, including geometry, image data and video data. Geometry is a type of class that defines a vector graphics skeleton without stroke or fill, e.g., a rectangle. Each geometry object corresponds to a simple shape (LineGeometry, EllipseGeometry, RectangleGeometry), a complex single shape (PathGeometry), or a list of such shapes (GeometryList) with a combine operation specified (e.g., union, intersection and so forth.) These objects form a class hierarchy. There are also shortcuts for drawing frequently used types of geometry, such as a DrawRectangle method.","When geometry is drawn, a brush or pen may be specified. A brush object defines how to graphically fill a plane, and there is a class hierarchy of brush objects. A pen also has a brush specified on it describing how to fill the stroked area. A special type of brush object (the VisualBrush) can reference a visual to define how that brush is to be drawn.","Other benefits and advantages will become apparent from the following detailed description when taken in conjunction with the drawings, in which:","Exemplary Operating Environment",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 1","b":["100","100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, tablet devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, and so forth, which perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of the computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, Accelerated Graphics Port (AGP) bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","The computer  typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by the computer  and includes both volatile and nonvolatile media, and removable and non-removable media. By way of example, and not limitation, computer-readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by the computer . Communication media typically embodies computer-readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer-readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules  and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media, discussed above and illustrated in , provide storage of computer-readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules  and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers herein to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a tablet (electronic digitizer) , a microphone , a keyboard  and pointing device , commonly referred to as mouse, trackball or touch pad. Other input devices (not shown) may include a joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . The monitor  may also be integrated with a touch-screen panel  or the like that can input digitized input such as handwriting into the computer system  via an interface, such as a touch-screen interface . Note that the monitor and\/or touch screen panel can be physically coupled to a housing in which the computing device  is incorporated, such as in a tablet-type personal computer, wherein the touch screen panel  essentially serves as the tablet . In addition, computers such as the computing device  may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface  or the like.","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface  or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Interfaces to Scene Graph Data Structures","One aspect of the present invention is generally directed to allowing program code, such as an application or operating system component, to communicate drawing instructions and other information (e.g., image bitmaps) to graphics components in order to render graphical output on the system display. To this end, the present invention provides a number of defined functions and methods, e.g., in the form of application programming interfaces (APIs) to an object model, that enable programs to populate a scene graph with data structures, drawing primitives (commands), and other graphics-related data. When processed, the scene graph results in graphics being displayed on the screen.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 2","FIG. 2"],"b":["200","202","204","206","212","204","202","206","206","208","210","212","206","208","210"]},"In one implementation, the graphics layer architecture  includes a high-level composition and animation engine , which includes or is otherwise associated with a caching data structure . The caching data structure  contains a scene graph comprising hierarchically-arranged objects that are managed according to a defined object model, as described below. In general, the visual API layer  provides the program code  (and the presenter system ) with an interface to the caching data structure , including the ability to create objects, open and close objects to provide data to them, and so forth. In other words, the high-level composition and animation engine  exposes a unified media API layer  by which developers may express intentions about graphics and media to display graphics information, and provide an underlying platform with enough information such that the platform can optimize the use of the hardware for the program code. For example, the underlying platform will be responsible for caching, resource negotiation and media integration.","In one implementation, the high-level composition and animation engine  passes an instruction stream and possibly other data (e.g., pointers to bitmaps) to a fast, low-level compositing and animation engine . As used herein, the terms \u201chigh-level\u201d and \u201clow-level\u201d are similar to those used in other computing scenarios, wherein in general, the lower a software component is relative to higher components, the closer that component is to the hardware. Thus, for example, graphics information sent from the high-level composition and animation engine  may be received at the low-level compositing and animation engine , where the information is used to send graphics data to the graphics subsystem including the hardware .","The high-level composition and animation engine  in conjunction with the program code  builds a scene graph to represent a graphics scene provided by the program code . For example, each item to be drawn may be loaded with drawing instructions, which the system can cache in the scene graph data structure . As will be described below, there are a number of various ways to specify this data structure , and what is drawn. Further, the high-level composition and animation engine  integrates with timing and animation systems  to provide declarative (or other) animation control (e.g., animation intervals) and timing control. Note that the animation system allows animate values to be passed essentially anywhere in the system, including, for example, at the element property level , inside of the visual API layer , and in any of the other resources. The timing system is exposed at the element and visual levels.","The low-level compositing and animation engine  manages the composing, animating and rendering of the scene, which is then provided to the graphics subsystem . The low-level engine  composes the renderings for the scenes of multiple applications, and with rendering components, implements the actual rendering of graphics to the screen. Note, however, that at times it may be necessary and\/or advantageous for some of the rendering to happen at higher levels. For example, while the lower layers service requests from multiple applications, the higher layers are instantiated on a per-application basis, whereby is possible via the imaging mechanisms  to perform time-consuming or application-specific rendering at higher levels, and pass references to a bitmap to the lower layers.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIGS. 3 and 4","FIG. 5"],"b":["300","400","500","501","506"]},"As represented in , a top-level (or root) visual  is connected to a visual manager object , which also has a relationship (e.g., via a handle) with a window (HWnd)  or similar unit in which graphic data is output for the program code. The VisualManager  manages the drawing of the top-level visual (and any children of that visual) to that window .  shows the VisualManager as one of a set of other objects  in the object model of the graphics system described herein.","To draw, the visual manager  processes (e.g., traverses or transmits) the scene graph as scheduled by a dispatcher , and provides graphics instructions and other data to the low level component  () for its corresponding window , such as generally described in U.S. patent application Ser. Nos. 10\/184,795, 10\/184,796, and 10\/185,775. The scene graph processing will ordinarily be scheduled by the dispatcher  at a rate that is relatively slower than the refresh rate of the lower-level component  and\/or graphics subsystem .  shows a number of child visuals \u2013 arranged hierarchically below the top-level (root) visual , some of which are represented as having been populated via drawing contexts ,  (shown as dashed boxes to represent their temporary nature) with associated instruction lists  and , respectively, e.g., containing drawing primitives and other visuals. The visuals may also contain other property information, as shown in the following example visual class:",{"@attributes":{"id":"p-0062","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public abstract class Visual : VisualComponent"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public Transform Transform { get; set; }"]},{"entry":[{},"public float Opacity { get; set; }"]},{"entry":[{},"public BlendMode BlendMode { get; set; }"]},{"entry":[{},"public Geometry Clip { get; set; }"]},{"entry":[{},"public bool Show { get; set; }"]},{"entry":[{},"public HitTestResult HitTest(Point point);"]},{"entry":[{},"public bool IsDescendant(Visual visual);"]},{"entry":[{},"public static Point TransformToDescendant("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Visual reference,"]},{"entry":[{},"Visual descendant,"]},{"entry":[{},"Point point);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public static Point TransformFromDescendant("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Visual reference,"]},{"entry":[{},"Visual descendant,"]},{"entry":[{},"Point point);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public Rect CalculateBounds( ); \/\/ Loose bounds"]},{"entry":[{},"public Rect CalculateTightBounds( ); \/\/"]},{"entry":[{},"public bool HitTestable { get; set; }"]},{"entry":[{},"public bool HitTestIgnoreChildren { get; set; }"]},{"entry":[{},"public bool HitTestFinal { get; set; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"As can be seen, visuals offer services by providing transform, clip, opacity and possibly other properties that can be set, and\/or read via a get method. In addition, the visual has flags controlling how it participates in hit testing, as described below. A Show property is used to show\/hide the visual, e.g., when false the visual is invisible, otherwise the visual is visible.","A transformation, set by the transform property, defines the coordinate system for the sub-graph of a visual. The coordinate system before the transformation is called pre-transform coordinate system, the one after the transform is called post-transform coordinate system, that is, a visual with a transformation is equivalent to a visual with a transformation node as a parent.  generally provides an example of transformation, identifying the pre-transformation and post-transformation coordinate systems relative to a visual. To get or set the transformation of a visual, the Transform property may be used.","Note that the coordinate transforms may be applied in a uniform way to everything, as if it were in a bitmap. Note that this does not mean that transformations always apply to bitmaps, but that what gets rendered is affected by transforms equally. By way of example, if the user draws a circle with a round pen that is one inch wide and then applies a scale in the X direction of two to that circle, the pen will be two inches wide at the left and right and only one inch wide at the top and bottom. This is sometimes referred to as a compositing or bitmap transform (as opposed to a skeleton or geometry scale that affects the geometry only).  is a representation of scaling transformation, with a non-transformed image  appearing on the left and a transformed image  with a non-uniform scale appearing on the right.  is a representation of scaling transformation, with the non-transformed image  appearing on the left and a transformed image  with geometry scaling appearing on the right.","With respect to coordinate transformation of a visual, TransformToDescendant transforms a point from the reference visual to a descendant visual. The point is transformed from the post-transformation coordinate space of the reference visual to the post-transformation coordinate space of the descendant visual. TransformFromDescendant transforms a point from the descendant visual up the parent chain to the reference visual. The point is transformed from post-transformation coordinate space of the descendant visual to post-transformation coordinate space of the reference visual. The CalculateBounds method returns the bounding box of the content of the Visual in Post-Transformation coordinate space. Note that there may be an alternative version of the API where more specific specifications are allowed as to how the transform on a visual is interpreted during a coordinate transformation. For example, the transform on the reference and descendant visual may or may not be taken into account. In this alternative, there are thus four options, e.g., coordinates can be transformed from pre-transformation to pre-transformation space, pre-transformation to post-transformation space, post-transformation to pre-transformation space, and post-transformation to post-transformation space. The same concept applies to hit-testing, e.g., hit-testing may be started in pre-transformation or post-transformation transform coordinate space, and the hit-test results might be in pre-transformation or post-transformation coordinate space.","The clip property sets (and gets) the clipping region of a visual. Any Geometry (the geometry class is described below with reference to ) can be used as a clipping region, and the clipping region is applied in Post-Transformation coordinate space. In one implementation, a default setting for the clipping region is null, i.e., no clipping, which can be thought of as an infinite big clipping rectangle from (\u2212\u221e, \u2212\u221e) to (+\u221e, +\u221e).","The Opacity property gets\/sets the opacity value of the visual, such that the content of the visual is blended on the drawing surface based on the opacity value and the selected blending mode. The BlendMode property can be used to set (or get) the blending mode that is used. For example, an opacity (alpha) value may be set between 0.0 and 1.0, with linear alpha blending set as the mode, e.g., Color=alpha*foreground color+(1.0\u2212alpha)*background color). Other services, such as special effects properties, may be included in a visual, e.g., blur, monochrome, and so on.","The various services (including transform, opacity, clip) can be pushed and popped on a drawing context, and push\/pop operations can be nested, as long as a pop call matches a push call. For example PushTransform( . . . ); PushOpacity( . . . ); PopTransform( . . . ); is illegal, because before the PopTransform call, PopOpacity needs to be called.","The PushTransform method pushes a transformation. Subsequent drawing operations are executed with respect to the pushed transformation. The PopTransform pops the transformation pushed by the matching PushTransform call:\n\n","Similarly, the PushOpacity method pushes an opacity value. Subsequent drawing operations are rendered on a temporary surface with the specified opacity value and then composite into the scene. PopOpacity pops the opacity pushed by the matching PushOpacity call:\n\n","The PushClip method pushes a clipping geometry. Subsequent drawing operations are clipped to the geometry. The clipping is applied in post transformation space. PopClip pops the clipping region pushed by the matching PushClip call:\n\n","Note that push operations can be arbitrarily nested as long as the pop operations are matched with a push. For example, the following is valid:",{"@attributes":{"id":"p-0074","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PushTransform( . . . );"]},{"entry":[{},"DrawLine( . . . );"]},{"entry":[{},"PushClip( . . . );"]},{"entry":[{},"DrawLine( . . . );"]},{"entry":[{},"PopClip( );"]},{"entry":[{},"PushTransform( . . . );"]},{"entry":[{},"DrawRect( . . . );"]},{"entry":[{},"PopTransform( );"]},{"entry":[{},"PopTransform( );"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Hit-testing is performed in the Post-Transformation coordinate space, and returns an identity of each hit-testable visual that is hit, e.g., when a pen or mouse click is detected. An alternate version of the interface may allow for hit-testing to start at a Pre-Transformation coordinate space relative to the visual where the hit test is started. Visuals that are hit are returned in right-to-left, depth-first order. Hit-testing may be controlled with various flags, including HitTestable, which determines if the visual is hit-testable (the default is true), and HitTestFinal, which determines if hit-testing stops when the visual is hit, i.e. if a Visual is hit and the HitTestFinal property of the visual is true, hit-testing aborts and returns the results collected up to this point (the default is false). Another flag is HitTestIgnoreChildren, which determines if the children of a visual should be considered when hit-testing is performed on a visual (the default is false).","A ProxyVisual is a visual that may be added more than once into the scene graph. Since any visual referred to by a ProxyVisual may be reached by multiple paths from the root, read services (TransformToDescendent, TransformFromDescendent and HitTest) do not work through a ProxyVisual. In essence, there is one canonical path from any visual to the root of the visual tree and that path does not include any ProxyVisuals.","As represented in , various types of visuals are defined in the object model, including ContainerVisuals , DrawingVisuals , ValidationVisuals , SurfaceVisuals  and HwndVisuals . The table below sets forth example methods of a DrawingVisual:",{"@attributes":{"id":"p-0078","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class DrawingVisual : Visual"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public DrawingVisual( );"]},{"entry":[{},"public IDrawingContext Open( );"]},{"entry":[{},"public IDrawingContext Append( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"A DrawingVisual is a container for graphical content (e.g. lines, text, images, and so forth). Note that it is possible to add a Visual into a DrawingVisual, but in some implementations this is not allowed. The DrawingVisual  includes an Open method, which returns an IDrawingContext that can be used to populate the DrawingVisual, e.g., with other visuals and drawing primitives, as described below. In one implementation, for various reasons also described below, a DrawingVisual may be only opened once to populate its drawing context; in other words, such a DrawingVisual is immutable with respect to what can be put into it (although program code can replace a resource object to which a visual is pointing). After the DrawingVisual has been populated, the DrawingVisual is closed using a Close method, e.g., on the drawing context. Note that an Open call may clear any contents (children) of a visual, however in one alternative implementation, there is provided an Append method, to open a current visual in a manner that appends to that visual. In other words, an OpenForAppend call works like Open, except the current content of the DrawingVisual is not cleared out on the open.","The following is an example of how a drawing context is used to populate a visual:",{"@attributes":{"id":"p-0081","num":"0088"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ContainerVisual cv1 = new ContainerVisual( );"]},{"entry":[{},"DrawingVisual dv1 = new DrawingVisual( );"]},{"entry":[{},"\/\/ Open a drawing context. The context"]},{"entry":[{},"\/\/ will automatically be closed when"]},{"entry":[{},"\/\/ exiting the using block. This will also"]},{"entry":[{},"\/\/ replace any contents that might already"]},{"entry":[{},"\/\/ be in dv1."]},{"entry":[{},"using (IDrawingContext dc = dv1.Open( ))"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"dc.DrawLine(new Pen(Brushes.Blue), new Point( . . . ),"]},{"entry":[{},"new Point( . . . ));"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/\/ Add dv1 to the child collection of cv1"]},{"entry":[{},"cv1.Children.Add(dv1);"]},{"entry":[{},"\/\/ Add another arbitrary visual to cv1"]},{"entry":[{},"cv1.Children.Add(someOtherVisual);"]},{"entry":[{},"\/\/ Create another DrawingVisual"]},{"entry":[{},"DrawingVisual dv2 = new DrawingVisual( );"]},{"entry":[{},"using (IDrawingContext dc = dv2.Open( ))"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ This sets up a new coordinate system"]},{"entry":[{},"\/\/ where everything is twice as big"]},{"entry":[{},"dv.PushTransform(new Scale(2.0, 2.0));"]},{"entry":[{},"\/\/ This line is drawn in the new scaled"]},{"entry":[{},"\/\/ coordinate system."]},{"entry":[{},"dc.DrawLine(new Pen(Brushes.Red), new Point( . . . ),"]},{"entry":[{},"new Point( . . . ));"]},{"entry":[{},"\/\/ This reverts to the original coordinate system."]},{"entry":[{},"dv.PopTransform( );"]},{"entry":[{},"dc.DrawLine(new Pen(Brushes.Green), new Point( . . . ),"]},{"entry":[{},"new Point( . . . ));"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/\/ Add dv2 to the child collection of cv1;"]},{"entry":[{},"cv1.Children.Add(dv2);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In general, a ValidationVisual  is conceptually similar to a DrawingVisual, except that a ValidationVisual is populated when the system requests that it be filled, instead of when the program code wants to populate it. For example, as described in U.S. Ser. No. 10\/185,775, the high-level composition and animation engine  () may invalidate scene graph data as resources are needed, such as when part of a scene graph is not visible. For example if some parts are scrolled off the display, clipped, and so on. If the invalidated scene graph data is later needed, the program code  called will be called back to redraw (validate) the invalidated portion of the scene graph. To this end, one typical usage scenario is for a program code to subclass the ValidationVisual and override the OnValidate method. When the system calls the OnValidate method, a drawing context is passed in, and the program the uses the drawing context repopulate the ValidationVisual.","The example below shows one way to implement a simple ValidationVisual, e.g., one that draws a line with a certain color. The color of the line can be changed by calling SetColor. To force the update of the ValidationVisual, SetColor calls Invalidate to force the graphics sub-system to revalidate the ValidationVisual:",{"@attributes":{"id":"p-0084","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class MyValidationVisual : ValidationVisual"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public override void OnValidate(IDrawingContext dc)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"dc.DrawLine(m_color, . . . );"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"public void SetColor(Color newColor)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"m_color = color;"]},{"entry":[{},"Invalidate( ); \/\/ Force a redraw of the ValidationVisual to"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ reflect the color change."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"private Color m_color"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"This example shows how to use the ValidationVisual:",{"@attributes":{"id":"p-0086","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MyValidationVisual myVV = new MyValidationVisual( );"]},{"entry":[{},"container.Children.Add(myVV);"]},{"entry":[{},"myVV.SetColor(new Color(. . .));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0087","num":"0094"},"figref":"FIG. 4","b":"400"},{"@attributes":{"id":"p-0088","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"VisualCollection vc = m_cv.Children;"},{"entry":"vc.Add(new DrawingVisual ( ));"},{"entry":"vc.Add(new DrawingVisual ( ));"},{"entry":"vc.Add(new DrawingVisual ( ));"},{"entry":"for (int i = 0; i < vc.Count; i++)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DrawingVisual v = (DrawingVisual) (vc[i]);"]},{"entry":[{},"if (v != null)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"v.Transform = Transform.CreateTranslation(i * 20.0f, i*20f);"]},{"entry":[{},"IDrawingContext dc = v.Open( );"]},{"entry":[{},"dc.DrawRectangle("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"new Brush(colors [i]),"]},{"entry":[{},"null,"]},{"entry":[{},"new Point2D(0, 0),"]},{"entry":[{},"new Point2D(100.0f, 100.0f));"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"v.Close(dc);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"As represented in , another type of visual object is a SurfaceVisual . In general, as represented in , a SurfaceVisual object  references an in-memory surface (bitmap)  that the program code  () can access. The client program code  can supply its own surface memory, or it can request that the memory be allocated by the surface object.","The program code  has the option to open a SurfaceVisual and get a drawing context , into which the program code  can write pixel data  or the like and directly put those pixels onto the surface. This is represented in  by the dashed line between the surface object , the drawing context  (shown as a dashed box to represent its temporary nature) and the pixel data .","The program code  also has an option to create a surface visual manager  and associate a visual subgraph  with the SurfaceVisual . This option is represented in  by the dashed line between the surface object  and the surface visual manager . Note that the visual subgraph  can also nest other surface visuals, as also shown in . The surface visual manager  (also shown as a type of other object in the set  of ) walks the visual subgraph  to update the SurfaceVisual bitmap . Further, note that this traversal is scheduled by the dispatcher , and for efficiency may be throttled to control how often this bitmap  is updated. The surface visual manager  does not have to traverse the visual subgraph  each time and\/or at the same rate that the top level visual manager  walks the rest of the scene graph.","With respect to surfaces, as further described with reference to , in general, the present graphics model thus allows compositing a set of visuals to a surface, immediate-mode rendering of vector and bitmap primitives into a surface, compositing a surface onto the desktop or onto another surface, and controlling which surface in a surface list is used to composite into or to draw into. A surface list is defined as a collection of one or more surfaces (i.e. frames\/buffers) of physical (system or video) memory used to store compositions of visuals or graphical drawings, or both. One of the surfaces of the surface list may be set as a current back buffer where drawing and\/or compositing is done, and one of the surfaces of the surface list is set as a current primary, or front buffer, which is used to composite onto another render target.","Surfaces may be used in a number of ways. By way of example,  shows compositing to a surface. In , a surface visual manager object  connects a surface list  as a render target for a visual tree . During each compositing cycle, the visuals are composited into the surface of the surface list that is currently serving as the active back buffer for the surface list. The surface being composited to can include a surface owned by the client\/high level compositing engine  () for in-process compositing scenarios, a surface owned by the low-level compositing engine  for scenarios where the client does not need the bits but the low-level compositing engine  needs them to composite the surface onto another render target, or a cross-process surface, for scenarios where the client needs access to the surface bits, but the low-level compositing engine  also needs the surface for other compositing work.","The compositing is controlled by a timing service that is attached to the Visual Manager. One example of a timing service, is a manual mode that might be used as in the example below:",{"@attributes":{"id":"p-0095","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ create a manual timing service and attach a visual manager"},{"entry":"TimingService timingService ="},{"entry":"new ManualTimingService(visualManager);"},{"entry":"\/\/ composite the visual tree to the current back buffer of the surface"},{"entry":"visualManager.Render( );"},{"entry":"foreach (Tick tick in timingService)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ advance the back buffer to the next frame of the surface"]},{"entry":[{},"surfaceList.NextFrame( );"]},{"entry":[{},"\/\/ advance the time of the visual tree"]},{"entry":[{},"timingService.Tick(tick);"]},{"entry":[{},"\/\/ composite the visual tree to the current back buffer of surface"]},{"entry":[{},"visualManager.Render( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Another way to use a surface is with immediate-mode rendering to a surface, via a context. Attaching a surface list to a visual (a surface visual) enables immediate-mode rendering to the surface of the surface list that is currently serving as the active back buffer for the surface list. This rendering is done by obtaining a drawing context from the surface visual and executing drawing commands on that context, as described above. Note that obtaining a drawing context locks the surface so that other compositing operations cannot be done to it. Each drawing command is executed immediately, and vectors and other surfaces can be drawn (blended) onto the surface. However, other visuals cannot be drawn onto the surface, but instead can be composited into the surface by associating it with a visual manager, as previously described (e.g., in ).",{"@attributes":{"id":"p-0097","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ attach a surface list to a visual"]},{"entry":[{},"SurfaceVisual surfaceVisual = new SurfaceVisual(surfaceList);"]},{"entry":[{},"\/\/ enable immediate-mode rendering to (and lock) back buffer"]},{"entry":[{},"surface"]},{"entry":[{},"BaseDrawingContext dc = surfaceVisual.Open( );"]},{"entry":[{},"\/\/ draw a line (immediately) to the current back buffer of the"]},{"entry":[{},"surface"]},{"entry":[{},"dc.DrawLine (pen, startPoint, endPoint);"]},{"entry":[{},"\/\/ unlock the surface - we're done with immediate-mode rendering"]},{"entry":[{},"surfaceVisual.Close(dc);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Another use for surfaces is when compositing a surface onto another render target. To this end, once a surface list is attached to a surface visual, the surface can then be attached as a node in a visual tree, and the surface of the surface list that is currently serving as the primary or front buffer can be composited to another surface or to the desktop. This is illustrated in  and in the example below:",{"@attributes":{"id":"p-0099","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ attach a surface list to a visual"},{"entry":"SurfaceVisual surfaceVisual = new SurfaceVisual(surfaceList);"},{"entry":"\/\/ Add the surfaceVisual to a visual tree for compositing onto another"},{"entry":"\/\/ render target"},{"entry":"rootVisual.Add(surfaceVisual);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Live composition to\/from a surface is represented in , where the above-described capabilities are combined so that compositing to the back buffer surface of a surface list and compositing from the front buffer surface of a surface list (e.g. to the desktop) happen simultaneously. Note that to eliminate the undesirable video effect known as tearing, the surface list should have at least two surfaces, a front and a back buffer surface. A surface used as in  is likely owned by the low-level engine , or is a cross-process surface to make the composition in the low level engine  perform better.","Surfaces are constructed as independent objects, as set forth in the examples of constructors below:",{"@attributes":{"id":"p-0102","num":"0109"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public class Surface"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ create and allocate a blank surface without initial data"]},{"entry":[{},"public Surface(int width,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int height,"]},{"entry":[{},"int dpi,"]},{"entry":[{},"PixelFormat pixelFormat,"]},{"entry":[{},"SurfaceFlags flags)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ create a surface using the supplied memory"]},{"entry":[{},"public Surface(int width,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int height,"]},{"entry":[{},"int dpi,"]},{"entry":[{},"PixelFormat pixelFormat,"]},{"entry":[{},"IntPtr pixels, \/\/ managed memory for the surface"]},{"entry":[{},"Int stride)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ create from a source (i.e. Clone)"]},{"entry":[{},"public Surface(Surface sourceSurface,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SurfaceFlags flags)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Create from File or URL"]},{"entry":[{},"public Surface (String filename,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SurfaceFlags flags)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Create from Stream"]},{"entry":[{},"public Surface (System.IO.Stream stream,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SurfaceFlags flags)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Create from HBITMAP (which can't be selected into an HDC)"]},{"entry":[{},"public Surface (HBITMAP hbitmap, HPALETTE hPalette)"]},{"entry":[{},"\/\/ Create from HICON"]},{"entry":[{},"public Surface (HICON hicon)"]},{"entry":[{},"\/\/ read-only properties"]},{"entry":[{},"public Int Width {get; }"]},{"entry":[{},"public Int Height {get; }"]},{"entry":[{},"public Int Dpi {get; }"]},{"entry":[{},"public PixelFormat Format{get; }"]},{"entry":[{},"public int Stride{get; }"]},{"entry":[{},"public IntPtr Buffer {get;}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"public class SurfaceList"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Create a list of blank surfaces (without initial data)."]},{"entry":[{},"public SurfaceList (int width,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int height,"]},{"entry":[{},"int dpi,"]},{"entry":[{},"PixelFormat pixelFormat,"]},{"entry":[{},"int numSurfaces,"]},{"entry":[{},"SurfaceFlags flags)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Create a SurfaceList that uses the specified surfaces"]},{"entry":[{},"\/\/ All the surfaces must have identical properties (w, h,"]},{"entry":[{},"\/\/ dpi, etc)."]},{"entry":[{},"public SurfaceList (Surface [ ] surfaces)"]},{"entry":[{},"\/\/ change the front buffer to the first-in-line back buffer"]},{"entry":[{},"public Flip( )"]},{"entry":[{},"\/\/ advance the back buffer to the next surface"]},{"entry":[{},"public Next( )"]},{"entry":[{},"public int FrontBufferIndex {get; set;}"]},{"entry":[{},"public int BackBufferIndex {get; set;}"]},{"entry":[{},"public Surface GetFrontBuffer( )"]},{"entry":[{},"public Surface GetBackBuffer( )"]},{"entry":[{},"public Surface GetSurface(int surfaceIndex)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Once constructed, a surface and\/or a surface list can be attached to a surface visual object or to a visual manager object.",{"@attributes":{"id":"p-0104","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Create a surface visual"]},{"entry":[{},"public SurfaceDrawingVisual(Surface surface)"]},{"entry":[{},"public SurfaceDrawingVisual(SurfaceList surfaceList)"]},{"entry":[{},"\/\/ Create a visual manager with a surface render target"]},{"entry":[{},"public VisualManager(Surface surface)"]},{"entry":[{},"public VisualManager(SurfaceList surfaceList)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Further, a surface can get data from a decoder, and\/or send its data to an encoder for writing to a specific file format. Surfaces can also receive\/send data from\/to effect interfaces. A surface can be constructed for any pixel format from the full set of supported surface format types. However, some adjustments may be made to the specified pixel format, e.g., if the specified pixel format is less than 32 bits per pixel, then the format will be promoted to 32 bits per pixel. Whenever bits are requested from a surface in the original format, the surface will be copied to a buffer of the requested pixel format using a format conversion filter.","Returning to , yet another visual is an HwndVisual , which positions a Win32 child HWnd in the scene graph. More particularly, legacy programs will still operate via the WM_PAINT method (or the like) that draws to a child HWnd (or the like) based on prior graphics technology. To support such programs in the new graphics processing model, the HwndVisual allows the Hwnd to be contained in a scene graph and moved as the parent visual is repositioned, as represented in . As a result of limitations with existing Hwnds, however, when rendered, a child Hwnd can only be on top of other windows, and cannot be rotated or scaled like other visuals described above. Some clipping is possible, as represented in , where the dashed lines indicate the HWnd's displayed rectangle being clipped during relative movement with respect to its parent visual.","Other types of visuals  are also feasible, and the present object model is extensible to allow others to be developed. For example, as represented in , a layered visual  enables an application developer to separately control the information in a visual via multiple data streams, providing a finer granularity of control relative to visuals having a single data stream. Note that similar granularity of control can be accomplished by having (e.g., three) separate child visuals under a single parent visual, however this requires that the program code work with multiple visuals, which is more complicated than working with a single layered visual having indexes to multiple layers.","By way of example, in , background data, content data and border data are contained in a single layered visual, but are separated from one another as indexed by a layer value, e.g., 0, 1 or 2, respectively. Layers can be inserted, including tacked onto either end, and\/or deleted, with the layering order (e.g., left-to-right as shown) defining an implied Z-order for display. Note that for security, child content and other data in a layered visual cannot be enumerated.","Other types of visuals include container visuals, and redirected child HWnd visuals, in which content is drawn to a bitmap, and incorporated into a surface visual. Three-dimensional visuals enable a connection between two-dimensional and three dimensional worlds, e.g., a camera-like view is possible via a two-dimensional visual having a view into a three-dimensional world.","Many of the resource objects are immutable once created, that is, once they are created they cannot be changed for various reasons, including simplifying threading issues, preventing corruption by others, and simplifying the interaction with elements and APIs. Note that this generally simplifies the system. It should be noted, however, that it is feasible to have a system where such objects are mutable, but for example would require managing a dependency graph. For example, while it is possible to have a system where such objects are mutable, if program code changed the clip set on a Visual, the visual would need to be re-rendered, thus requiring a notification\/registration mechanism, e.g., if a new clip is assigned to a visual, the visual registers itself with the clip for notifications (e.g., a clip changed notification). Thus, in one implementation, for simplification purposes, resource objects are immutable.","These resource objects can be defined with a constructor, which is a straightforward, generic way to create an object, or by using a companion builder object, as described below. For instance, to create a SolidColorBrush, (brush objects are described below), a constructor may be used:","Brush MyBrush=new SolidColorBrush(Colors.Red);","The user can also use the static members on the Brushes class to get a set of predefined colors.","Because immutable objects cannot be changed, to effectively change an object, the user needs to create a new object and replace the old one with it. To this end, many of the resource objects in the system may utilize the builder pattern, in which immutable objects are created with a builder class, which is a companion class that is mutable. The user creates an immutable object to mirror the parameters set on the builder, creates a new builder for that object, and initializes it from the immutable object. The user then changes the builder as necessary. Once done, the user can build a new object, by changing the builder and reusing it to create another immutable object. Note that having immutable objects with set properties is desirable, and that immutable objects cannot be changed, but only replaced by firing a property change event.","Thus, instead of using a constructor to create a SolidColorBrush as described above, a SolidColorBrushBuilder may be used:\n\n","Most objects that take static values can also take animation objects. For instance, on the DrawingContext there is an override on DrawCircle that takes a PointAnimationBase for the center of the circle. In this way, the user can specify rich animation information at the primitive level. For resource objects there exists an animation collection in addition to the base value. These are composited, whereby if the user wanted to animate the above example, the user could specify the following example line before the brush is built:\n\n","Note that an object with animation parameters is still immutable, because its animation parameters are static. However, when the scene graph is processed (e.g., traversed), the meaning of animation parameters changes over time, giving the appearance of animated, not static, data.","As described above, visuals can be drawn on by populating their drawing contexts with various drawing primitives, including Geometry, ImageData and VideoData. Furthermore, there are a set of resources and classes that are shared through this entire stack. This includes Pens, Brushes, Geometry, Transforms and Effects. The IDrawingContext exposes a set of drawing operations that can be used to populate a DrawingVisual, ValidationVisual. ISurfaceDrawingContext, a base interface to IDrawing context, can be used to populate a SurfaceVisual. In other words, the drawing context exposes a set of drawing operations; for each drawing operation there are two methods, one that takes constants as arguments, and one that takes animators as arguments.","The DrawLine method draws a line with the specified pen from the start point to the end point.",{"@attributes":{"id":"p-0120","num":"0132"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public void DrawLine(Pen pen, Point start, Point end);"]},{"entry":[{},"public void DrawLine("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Pen pen,"]},{"entry":[{},"PointAnimationBase start,"]},{"entry":[{},"PointAnimationBase end);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The DrawRoundedRectangle method draws a rounded rectangle with the specified brush and pen; brush and pen can be null.",{"@attributes":{"id":"p-0122","num":"0134"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public void DrawRoundedRectangle("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Brush brush,"]},{"entry":[{},"Pen pen,"]},{"entry":[{},"Point topLeft,"]},{"entry":[{},"Size size,"]},{"entry":[{},"float radius);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public void DrawRoundedRectangle("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Brush brush,"]},{"entry":[{},"Pen pen,"]},{"entry":[{},"PointAnimationBase topLeft,"]},{"entry":[{},"SizeAnimationBase size,"]},{"entry":[{},"NumberAnimationBase radius);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public void DrawRoundedRectangle("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Brush brush,"]},{"entry":[{},"Pen pen,"]},{"entry":[{},"Point topLeft,"]},{"entry":[{},"Point bottomRight,"]},{"entry":[{},"float rx,"]},{"entry":[{},"float ry);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public void DrawRoundedRectangle("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Brush brush,"]},{"entry":[{},"Pen pen,"]},{"entry":[{},"PointAnimationBase topLeft,"]},{"entry":[{},"PointAnimationBase bottomRight,"]},{"entry":[{},"NumberAnimationBase radiusX,"]},{"entry":[{},"NumberAnimationBase radiusY);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The DrawGeometry method draws a path with the specified brush and pen; brush and pen can be null.",{"@attributes":{"id":"p-0124","num":"0136"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public void DrawGeometry("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Brush brush,"]},{"entry":[{},"Pen pen,"]},{"entry":[{},"Geometry geometry);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The DrawRectangle method draws a rectangle with the specified brush and pen; brush and pen can be null.",{"@attributes":{"id":"p-0126","num":"0138"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public void DrawRectangle("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Brush brush,"]},{"entry":[{},"Pen pen,"]},{"entry":[{},"Point topLeft,"]},{"entry":[{},"Size size);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public void DrawRectangle("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Brush brush,"]},{"entry":[{},"Pen pen,"]},{"entry":[{},"PointAnimationBase topLeft,"]},{"entry":[{},"SizeAnimationBase size);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The DrawSurface method draws a surface.",{"@attributes":{"id":"p-0128","num":"0140"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public void DrawSurface("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Surface surface,"]},{"entry":[{},"Point topLeft,"]},{"entry":[{},"Size size,"]},{"entry":[{},"float opacity);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public void DrawSurface("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Surface image,"]},{"entry":[{},"PointAnimationBase topLeft,"]},{"entry":[{},"SizeAnimationBase size,"]},{"entry":[{},"NumberAnimationBase opacity);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Geometry is a type of class () that defines a vector graphics skeleton, without stroke or fill. Each geometry object is a simple shape (LineGeometry, EllipseGeometry, RectangleGeometry), a complex single shape (PathGeometry) or a list of such shapes GeometryList with a combine operation (e.g., union, intersection, and so forth) specified. These objects form a class hierarchy as represented in .","As represented in , the PathGeometry is a collection of Figure objects. In turn, each of the Figure objects is composed of one or more Segment objects which actually define the figure's shape. A Figure is a sub-section of a Geometry that defines a segment collection. This segment collection is a single connected series of two-dimensional Segment objects. The Figure can be either a closed shape with a defined area, or just a connected series of Segments that define a curve, but no enclosed area.","The filled area of the PathGeometry is defined by taking the contained Figures that have their Filled property set to true, and applying a FillMode to determine the enclosed area. Note that the FillMode enumeration specifies how the intersecting areas of Figure objects contained in a Geometry are combined to form the resulting area of the Geometry. An \u201cAlternate\u201d rule determines whether a point is inside the canvas, by conceptually drawing a ray from that point to infinity in any direction, and then examining the places where a segment of the shape crosses the ray. By starting with a count of zero and adding one each time a Segment crosses the ray from left to right and subtracting one each time a path segment crosses the ray from right to left, after counting the crossings, if the result is zero then the point is outside the path. Otherwise, it is inside. A \u201cwinding\u201d rule determines whether a point on the canvas is inside, and works by conceptually drawing a ray from that point to infinity in any direction and counting the number of path Segments from the given shape that the ray crosses. If this number is odd, the point is inside; if even, the point is outside.","As represented in , when geometry (e.g., a rectangle) is drawn, a brush or pen can be specified, as described below. Furthermore, the pen object also has a brush object. A brush object defines how to graphically fill a plane, and there is a class hierarchy of brush objects. This is represented in  by the filled rectangle  that results when the visual including the rectangle and brush instructions and parameters is processed.","As described below, some types of Brushes (such as gradients and nine grids) size themselves. When used, the size for these brushes is obtained from the bounding box, e.g., when the GradientUnits\/DestinationUnits for the Brush is set to ObjectBoundingBox, the bounding box of the primitive that is being drawn is used. If those properties are set to UserSpaceOnUse, then the coordinate space is used.","A Pen object holds onto a Brush along with properties for Width, LineJoin, LineCap, MiterLimit, DasKArray and DashOffset, as represented in the example below:",{"@attributes":{"id":"p-0135","num":"0147"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public enum System.Windows.Media.PenLineCap"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Butt, Round, Square"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"public enum System.Windows.Media.PenLineJoin"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Miter, Round, Bevel"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"public class System.Windows.Media.Pen"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Constructors"]},{"entry":[{},"public Pen(Color color, float width);"]},{"entry":[{},"public Pen(Brush brush, float width);"]},{"entry":[{},"\/\/ Properties"]},{"entry":[{},"public float[ ] DashArray { get; }"]},{"entry":[{},"public float DashOffset { get; }"]},{"entry":[{},"public FloatAnimationCollection DashOffsetAnimations { get; }"]},{"entry":[{},"public PenLineCap LineCap { get; }"]},{"entry":[{},"public PenLineJoin LineJoin { get; }"]},{"entry":[{},"public float MiterLimit { get; }"]},{"entry":[{},"public FloatAnimationCollection MiterLimitAnimations { get; }"]},{"entry":[{},"public float Opacity { get; }"]},{"entry":[{},"public FloatAnimationCollection OpacityAnimations { get; }"]},{"entry":[{},"public Brush Brush { get; }"]},{"entry":[{},"public float Width { get; }"]},{"entry":[{},"public FloatAnimationCollection WidthAnimations { get; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"public sealed class System.Windows.Media.PenBuilder : Builder"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Fields"]},{"entry":[{},"\/\/ Constructors"]},{"entry":[{},"public PenBuilder ( );"]},{"entry":[{},"public PenBuilder(Color color);"]},{"entry":[{},"public PenBuilder(Brush brush);"]},{"entry":[{},"public PenBuilder(Pen pen);"]},{"entry":[{},"\/\/ Properties"]},{"entry":[{},"public float[ ] DashArray { get; set; }"]},{"entry":[{},"public float DashOffset { get; set; }"]},{"entry":[{},"public FloatAnimationCollectionBuilder DashOffsetAnimations {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"get; }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public PenLineCap LineCap { get; set; }"]},{"entry":[{},"public PenLineJoin LineJoin { get; set; }"]},{"entry":[{},"public float MiterLimit { get; set; }"]},{"entry":[{},"public FloatAnimationCollectionBuilder MiterLimitAnimations {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"get; }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public float Opacity { get; set; }"]},{"entry":[{},"public FloatAnimationCollectionBuilder OpacityAnimations { get;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public Brush Brush { get; set; }"]},{"entry":[{},"public float Width { get; set; }"]},{"entry":[{},"public FloatAnimationCollectionBuilder WidthAnimations { get; }"]},{"entry":[{},"\/\/ Methods"]},{"entry":[{},"public Pen ToPen( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"As mentioned above, the graphics object model of the present invention includes a Brush object model, which is generally directed towards the concept of covering a plane with pixels. Examples of types of brushes are represented in the hierarchy of , and, under a Brush base class, include SolidColorBrush, GradientBrush, ImageBrush, VisualBrush (which can reference a Visual) and NineGridBrush. GradientBrush includes LinearGradient and RadialGradient objects. As described above, Brush objects are immutable.",{"@attributes":{"id":"p-0137","num":"0149"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public abstract class System.Windows.Media.Brush"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"float Opacity { get; }"]},{"entry":[{},"FloatAnimationCollection OpacityAnimations { get; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The following sets forth an example BrushBuilder class:",{"@attributes":{"id":"p-0139","num":"0151"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public abstract class System.Windows.Media.BrushBuilder : Builder"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public virtual Brush ToBrush ( );"]},{"entry":[{},"public override sealed object CreateInstance ( );"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return ToBrush ( );"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"float Opacity { get; set; }"]},{"entry":[{},"FloatAnimationCollectionBuilder OpacityAnimations { get; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Note that Brush objects may recognize how they relate to the coordinate system when they are used, and\/or how they relate to the bounding box of the shape on which they are used. In general, information such as size may be inferred from the object on which the brush is drawn. More particularly, many of the brush types use a coordinate system for specifying some of their parameters. This coordinate system can either be defined as relative to the simple bounding box of the shape to which the brush is applied, or it can be relative to the coordinate space that is active at the time that the brush is used. These are known, respectively, as ObjectBoundingBox mode and UserSpaceOnUse mode.",{"@attributes":{"id":"p-0141","num":"0153"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public enum System.Windows.Media.BrushMappingMode"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ObjectBoundingBox,"]},{"entry":[{},"UserSpaceOnUse,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"A SolidColorBrush object fills the identified plane with a solid color. If there is an alpha component of the color, it is combined in a multiplicative way with the corresponding opacity attribute in the Brush base class. The following sets forth an example SolidColorBrush object:",{"@attributes":{"id":"p-0143","num":"0155"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public sealed class System.Windows.Media.SolidColorBrush : Brush"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Constructors"]},{"entry":[{},"public SolidColorBrush( ); \/\/ initialize to black"]},{"entry":[{},"public SolidColorBrush(Color color);"]},{"entry":[{},"public"]},{"entry":[{},"SolidColorBrush(System.Windows.Media.Animation.ColorComposer"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"colorComposer);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Properties"]},{"entry":[{},"public Color Color { get; }"]},{"entry":[{},"public IEnumerator ColorAnimations { get; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"public class"},{"entry":"System.Windows.Media.SolidColorBrushBuilder : BrushBuilder"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Constructors"]},{"entry":[{},"public SolidColorBrushBuilder( ) ;"]},{"entry":[{},"public SolidColorBrushBuilder(Color color);"]},{"entry":[{},"public SolidColorBrushBuilder(SolidColorBrush scp);"]},{"entry":[{},"\/\/ Properties"]},{"entry":[{},"public Color Color { get; set; }"]},{"entry":[{},"public AnimationList ColorAnimations { get; }"]},{"entry":[{},"\/\/ Methods"]},{"entry":[{},"public virtual Brush ToBrush( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":")"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The GradientBrush objects, or simply gradients, provide a gradient fill, and are drawn by specifying a set of gradient stops, which specify the colors along some sort of progression. The gradient is by drawn by performing linear interpolations between the gradient stops in a gamma . RGB color space; interpolation through other gammas or other color spaces (HSB, CMYK and so forth, is also a feasible alternative. Two types of gradient objects include linear and radial gradients.","In general, gradients are composed of a list of gradient stops. Each of these gradient stops contains a color (with the included alpha value) and an offset. If there are no gradient stops specified, the brush is drawn as a solid transparent black, as if there were no brush specified at all. If there is only one gradient stop specified, the brush is drawn as a solid color with the one color specified. Like other resource classes, the gradient stop class (example in the table below) is immutable.",{"@attributes":{"id":"p-0146","num":"0158"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class System.Windows.Media.GradientStop"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public GradientStop(Color color, float offset);"]},{"entry":[{},"public Color Color { get; }"]},{"entry":[{},"public AnimationEnumerator ColorAnimations { get; }"]},{"entry":[{},"public float Offset { get; }"]},{"entry":[{},"public AnimationEnumerator OffsetAnimations { get; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"public class System.Windows.Media.GradientStopBuilder : Builder"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public GradientStopBuilder( );"]},{"entry":[{},"public GradientStopBuilder(Color color, float offset);"]},{"entry":[{},"public Color Color { get; set; }"]},{"entry":[{},"public AnimationList ColorAnimations { get; }"]},{"entry":[{},"public float Offset { get; set; }"]},{"entry":[{},"public AnimationList OffsetAnimations { get; }"]},{"entry":[{},"public GradientStop ToGradientStop( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"There is also a collection class, as set forth in the following example:",{"@attributes":{"id":"p-0148","num":"0160"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public class System.Windows.Media.GradientStopCollection :"},{"entry":"ICollection"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public GradientStopCollection( ); \/\/ empty list"]},{"entry":[{},"public GradientStopCollection(GradientStop[ ] GradientStops);"]},{"entry":[{},"public GradientStopCollection(ICollection c);"]},{"entry":[{},"\/\/ IEnumerable"]},{"entry":[{},"public IEnumerator GetEnumerator( );"]},{"entry":[{},"\/\/ ICollection"]},{"entry":[{},"public void CopyTo (Array array, int index);"]},{"entry":[{},"public bool ICollection.IsSynchronized { get { return false; } }"]},{"entry":[{},"public int Count { get; }"]},{"entry":[{},"public object ICollection.SyncRoot { get; }"]},{"entry":[{},"\/\/ Extra functions"]},{"entry":[{},"public GradientStop this [int index] { get; }"]},{"entry":[{},"public bool Contains (GradientStop value);"]},{"entry":[{},"public int IndexOf(GradientStop value); \/\/ returns first one"]},{"entry":[{},"public int IndexOf(GradientStop value, int startIndex);"]},{"entry":[{},"public int IndexOf(GradientStop value, int startIndex, int"]},{"entry":[{},"count);"]},{"entry":[{},"public int LastIndexOf(GradientStop value);"]},{"entry":[{},"public int LastIndexOf(GradientStop value, int startIndex);"]},{"entry":[{},"public int LastIndexOf(GradientStop value, int startIndex,"]},{"entry":[{},"int count);"]},{"entry":[{},"public GradientStopCollection GetRange(int index, int count);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"public class System.Windows.Media.GradientStopCollectionBuilder :"},{"entry":"Builder,"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"IList"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"{"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public GradientStopCollectionBuilder( );"]},{"entry":[{},"public GradientStopCollectionBuilder(GradientStop [ ]"]},{"entry":[{},"GradientStops);"]},{"entry":[{},"public GradientStopCollectionBuilder(ICollection c);"]},{"entry":[{},"public GradientStopCollectionBuilder(GradientStopCollection"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"GradientStops);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ IEnumerable"]},{"entry":[{},"public IEnumerator GetEnumerator( );"]},{"entry":[{},"\/\/ ICollection"]},{"entry":[{},"public void CopyTo(Array array, int index);"]},{"entry":[{},"public bool ICollection.IsSynchronized { get { return false; } }"]},{"entry":[{},"public int Count { get; }"]},{"entry":[{},"public object ICollection.SyncRoot { get; }"]},{"entry":[{},"\/\/ IList"]},{"entry":[{},"public bool IsFixedSize { get { return false; } }"]},{"entry":[{},"public bool IsReadOnly { get { return false; } }"]},{"entry":[{},"public object IList.this [int index] { get; set; }"]},{"entry":[{},"public int IList.Add(object value);"]},{"entry":[{},"public void Clear( );"]},{"entry":[{},"public bool IList.Contains(object value);"]},{"entry":[{},"public int IList.IndexOf(object value); \/\/ returns first one"]},{"entry":[{},"public void IList.Insert(int index, object value);"]},{"entry":[{},"public void IList.Remove(object value); \/\/ removes first one"]},{"entry":[{},"public void RemoveAt(int index);"]},{"entry":[{},"\/\/ Extra functions"]},{"entry":[{},"public GradientStop this [int index] { get; set; }"]},{"entry":[{},"public int Add(GradientStop value);"]},{"entry":[{},"public bool Contains(GradientStop value);"]},{"entry":[{},"public int IndexOf(GradientStop value); \/\/ returns first one"]},{"entry":[{},"public int IndexOf(GradientStop value, int startIndex);"]},{"entry":[{},"public int IndexOf(GradientStop value, int startIndex, int"]},{"entry":[{},"count);"]},{"entry":[{},"public int LastIndexOf(GradientStop value);"]},{"entry":[{},"public int LastIndexOf(GradientStop value, int startIndex);"]},{"entry":[{},"public int LastIndexOf(GradientStop value, int startIndex, int"]},{"entry":[{},"count);"]},{"entry":[{},"public void Insert(int index, GradientStop value);"]},{"entry":[{},"public void Remove(GradientStop value); \/\/ removes first one"]},{"entry":[{},"public void AddRange(ICollection c);"]},{"entry":[{},"public void InsertRange(int index, ICollection c);"]},{"entry":[{},"public void RemoveRange(int index, int count);"]},{"entry":[{},"public void SetRange(int index, ICollection c);"]},{"entry":[{},"public GradientStopCollectionBuilder GetRange(int index, int"]},{"entry":[{},"count);"]},{"entry":[{},"\/\/ Capacity is a hint. It will throw an exception if it is set"]},{"entry":[{},"less"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"than Count."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public int Capacity { get; set; }"]},{"entry":[{},"\/\/ Builder overloads"]},{"entry":[{},"public override object Build( );"]},{"entry":[{},"public override void ResetBuilder( );"]},{"entry":[{},"public override void SetBuilder(Object example);"]},{"entry":[{},"public GradientStopCollection ToGradientStopCollection( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"As represented in the table below, the GradientSpreadMethod specifies how the gradient should be drawn outside of the specified vector or space. There are three values, including pad, in which the edge colors (first and last) are used to fill the remaining space, reflect, in which the stops are replayed in reverse order repeatedly to fill the space, and repeat, in which the stops are repeated in order until the space is filled:",{"@attributes":{"id":"p-0150","num":"0162"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public enum System.Windows.Media.GradientSpreadMethod"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Pad,"]},{"entry":[{},"Reflect,"]},{"entry":[{},"Repeat"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0151","num":"0163"},"figref":"FIG. 16"},"The LinearGradient specifies a linear gradient brush along a vector. The individual stops specify colors stops along that vector. An example is shown in the table below:",{"@attributes":{"id":"p-0153","num":"0165"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public class System.Windows.Media.LinearGradient : GradientBrush"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Sets up a gradient with two colors and a gradient vector"]},{"entry":[{},"\/\/ specified to fill the object thegradient is applied to."]},{"entry":[{},"\/\/ This implies ObjectBoundingBox for the GradientUnits"]},{"entry":[{},"\/\/ property"]},{"entry":[{},"public LinearGradient(Color color1, Color color2, float angle);"]},{"entry":[{},"public BrushMappingMode GradientUnits { get; }"]},{"entry":[{},"public Transform GradientTransform { get; }"]},{"entry":[{},"public GradientSpreadMethod SpreadMethod { get; }"]},{"entry":[{},"\/\/ Gradient Vector"]},{"entry":[{},"public Point VectorStart { get; }"]},{"entry":[{},"public PointAnimationCollection VectorStartAnimations { get; }"]},{"entry":[{},"public Point VectorEnd { get; }"]},{"entry":[{},"public PointAnimationCollection VectorEndAnimations { get; }"]},{"entry":[{},"\/\/ Gradient Stops"]},{"entry":[{},"public GradientStopCollection GradientStops { get; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"}"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public class System.Window.Media.LinearGradientBuilder :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"GradientBrushBuilder"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"{"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public LinearGradientBuilder( );"]},{"entry":[{},"public LinearGradientBuilder(Color color1, Color color2, float"]},{"entry":[{},"angle);"]},{"entry":[{},"public LinearGradientBuilder(LinearGradient lg);"]},{"entry":[{},"\/\/ GradientUnits: Default is ObjectBoundingBox"]},{"entry":[{},"public BrushMappingMode GradientUnits { get; set; }"]},{"entry":[{},"\/\/ GradientTransform: Default is identity"]},{"entry":[{},"public Transform GradientTransform { get; set; }"]},{"entry":[{},"\/\/ SpreadMethod: Default is Pad"]},{"entry":[{},"public GradientSpreadMethod SpreadMethod { get; set; }"]},{"entry":[{},"\/\/ Gradient Vector"]},{"entry":[{},"\/\/ Default vector is (0,0) - (1,0)"]},{"entry":[{},"public Point VectorStart { get; set; }"]},{"entry":[{},"public PointAnimationCollectionBuilder VectorStartAnimations"]},{"entry":[{},"{ get;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"set; }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public Point VectorEnd { get; set; }"]},{"entry":[{},"public PointAnimationCollectionBuilder VectorEndAnimations"]},{"entry":[{},"{ get; set;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Gradient Stops"]},{"entry":[{},"public void AddStop (Color color, float offeset);"]},{"entry":[{},"public GradientStopCollectionBuilder GradientStops"]},{"entry":[{},"{ get; set; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The RadialGradient is similar in programming model to the linear gradient. However, whereas the linear gradient has a start and end point to define the gradient vector, the radial gradient has a circle along with a focal point to define the gradient behavior. The circle defines the end point of the gradient, that is, a gradient stop at 1.0 defines the color at the circle. The focal point defines center of the gradient. A gradient stop at 0.0 defines the color at the focal point.",{"@attributes":{"id":"p-0155","num":"0167"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0156","num":"0168"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public class System.Windows.Media.RadialGradient : GradientBrush"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Sets up a gradient with two colors."]},{"entry":[{},"\/\/ This implies ObjectBoundingBox for the GradientUnits"]},{"entry":[{},"\/\/ property along with a center at (0.5,0.5)"]},{"entry":[{},"\/\/ a radius of 0.5 and a focal point at (0.5,0.5)"]},{"entry":[{},"public RadialGradient(Color color1, Color color2);"]},{"entry":[{},"public BrushMappingMode GradientUnits { get; }"]},{"entry":[{},"public Transform GradientTransform { get; }"]},{"entry":[{},"public GradientSpreadMethod SpreadMethod { get; }"]},{"entry":[{},"\/\/ Gradient definition"]},{"entry":[{},"public Point CircleCenter { get; }"]},{"entry":[{},"public PointAnimationCollection CircleCenterAnimations"]},{"entry":[{},"{ get; }"]},{"entry":[{},"public float CircleRadius { get; }"]},{"entry":[{},"public FloatAnimationCollection CircleRadiusAnimations"]},{"entry":[{},"{ get; }"]},{"entry":[{},"public Point Focus { get; }"]},{"entry":[{},"public PointAnimationCollection FocusAnimations { get; }"]},{"entry":[{},"\/\/ Gradient Stops"]},{"entry":[{},"public GradientStopCollection GradientStops { get; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"public class System.Windows.Media.RadialGradientBuilder :"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"GradientBrushBuilder"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"{"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public RadialGradientBuilder( );"]},{"entry":[{},"public RadialGradient(Color color1, Color color2);"]},{"entry":[{},"public RadialGradientBuilder(RadialGradient rg);"]},{"entry":[{},"\/\/ GradientUnits: Default is ObjectBoundingBox"]},{"entry":[{},"public BrushMappingMode GradientUnits { get; set; }"]},{"entry":[{},"\/\/ GradientTransform: Default is identity"]},{"entry":[{},"public Transform GradientTransform { get; set; }"]},{"entry":[{},"\/\/ SpreadMethod: Default is Pad"]},{"entry":[{},"public GradientSpreadMethod SpreadMethod { get; set; }"]},{"entry":[{},"\/\/ Gradient definition"]},{"entry":[{},"public Point CircleCenter { get; set; } \/\/Default: (0.5, 0.5)"]},{"entry":[{},"public PointAnimationCollectionBuilder CircleCenterAnimations"]},{"entry":[{},"{ get;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"set;}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public float CircleRadius { get; set; } \/\/ Default: 0.5"]},{"entry":[{},"public FloatAnimationCollectionBuilder CircleRadiusAnimations {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"get; set; }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public Point Focus { get;set; } \/\/ Default: (0.5, 0.5)"]},{"entry":[{},"public PointAnimationCollectionBuilder FocusAnimations"]},{"entry":[{},"{ get; set; }"]},{"entry":[{},"\/\/ Gradient Stops"]},{"entry":[{},"public void AddStop(Color color, float offset);"]},{"entry":[{},"public GradientStopCollectionBuilder GradientStops"]},{"entry":[{},"{ get; set; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Another brush object represented in  is a VisualBrush object. Conceptually, the VisualBrush provides a way to have a visual drawn in a repeated, tiled fashion as a fill. This is represented in  by the visual brush referencing a visual (and any child visuals) that specifies a single circular shape , with that circular shape filling a rectangle . Thus, the VisualBrush object may reference a visual to define how that brush is to be drawn, which introduces a type of multiple use for visuals. In this manner, a program may use an arbitrary graphics \u201cmetafile\u201d to fill an area via a brush or pen. Since this is a compressed form for storing and using arbitrary graphics, it serves a graphics resource. The following sets forth an example VisualBrush object:",{"@attributes":{"id":"p-0158","num":"0170"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class System.Windows.Media.VisualBrush : Brush"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public VisualBrush(Visual v);"]},{"entry":[{},"public BrushMappingMode DestinationUnits { get; }"]},{"entry":[{},"public BrushMappingMode ContentUnits { get; }"]},{"entry":[{},"public Transform Transform { get; }"]},{"entry":[{},"public Rect ViewBox { get; }"]},{"entry":[{},"public Stretch Stretch { get; }"]},{"entry":[{},"public HorizontalAlign HorizontalAlign { get; }"]},{"entry":[{},"public VerticalAlign VerticalAlign { get; }"]},{"entry":[{},"public Point Origin { get; }"]},{"entry":[{},"public PointAnimationCollection OriginAnimations { get; }"]},{"entry":[{},"public Size Size { get; }"]},{"entry":[{},"public SizeAnimationCollection SizeAnimations { get; }"]},{"entry":[{},"\/\/ Visual"]},{"entry":[{},"public Visual Visual { get; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"public class System.Windows.Media.VisualBrushBuilder :"]},{"entry":[{},"BrushBuilder"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public VisualBrushBuilder( );"]},{"entry":[{},"public VisualBrushBuilder(Visual v);"]},{"entry":[{},"public VisualBrushBuilder(VisualBrush vb);"]},{"entry":[{},"\/\/ DestinationUnits: Default is ObjectBoundingBox"]},{"entry":[{},"public BrushMappingMode DestinationUnits { get; set; }"]},{"entry":[{},"\/\/ ContentUnits: Default is ObjectBoundingBox"]},{"entry":[{},"public BrushMappingMode ContentUnits { get; set; }"]},{"entry":[{},"\/\/ Transform: Default is Identity"]},{"entry":[{},"public Transform Transform { get; set; }"]},{"entry":[{},"\/\/ ViewBox: Default is (0,0,0,0) -- unset and ignored"]},{"entry":[{},"public Rect ViewBox { get; set; }"]},{"entry":[{},"\/\/ Stretch: Default is None -- and ignored"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/","because the ViewBox is not set"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public Stretch Stretch { get; set; }"]},{"entry":[{},"\/\/ HorizontalAlign: Default is Center and ignored"]},{"entry":[{},"public HorizontalAlign HorizontalAlign { get; set; }"]},{"entry":[{},"\/\/ VerticalAlign: Default is Center and ignored"]},{"entry":[{},"public VerticalAlign VerticalAlign { get; set; }"]},{"entry":[{},"\/\/ Origin: Default is (0,0)"]},{"entry":[{},"public Point Origin { get; set; }"]},{"entry":[{},"public PointAnimationCollectionBuilder OriginAnimations"]},{"entry":[{},"{ get; set; }"]},{"entry":[{},"\/\/ Size: Default is (1,1)"]},{"entry":[{},"public Size Size { get; set; }"]},{"entry":[{},"public SizeAnimationCollectionBuilder SizeAnimations"]},{"entry":[{},"{ get; set; }"]},{"entry":[{},"\/\/ Visual: Default is null -- nothing drawn"]},{"entry":[{}," public Visual Visual { get; set; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"A VisualBrush's contents have no intrinsic bounds, and effectively describe an infinite plane. These contents exist in their own coordinate space, and the space which is being filled by the VisualBrush is the local coordinate space at the time of application. The content space is mapped into the local space based on the ViewBox, ViewPort, Alignments and Stretch properties. The ViewBox is specified in content space, and this rectangle is mapped into the ViewPort (as specified via the Origin and Size properties) rectangle.","The ViewPort defines the location where the contents will eventually be drawn, creating the base tile for this Brush. If the value of DestinationUnits is UserSpaceOnUse, the Origin and Size properties are considered to be in local space at the time of application. If instead the value of DestinationUnits is ObjectBoundingBox, then an Origin and Size are considered to be in the coordinate space, where 0,0 is the top\/left corner of the bounding box of the object being brushed, and 1,1 is the bottom\/right corner of the same box. For example, consider a RectangleGeometry being filled which is drawn from 100,100 to 200,200. In such an example, if the DestinationUnits is UserSpaceOnUse, an Origin of 100,100 and a Size of 100,100 would describe the entire content area. If the DestinationUnits is ObjectBoundingBox, an Origin of 0,0 and a Size of 1,1 would describe the entire content area. If the Size is empty, this Brush renders nothing.","The ViewBox is specified in content space. This rectangle is transformed to fit within the ViewPort as determined by the Alignment properties and the Stretch property. If the Stretch is none, then no scaling is applied to the contents. If the Stretch is Fill, then the ViewBox is scaled independently in both X and Y to be the same size as the ViewPort. If the Stretch is Uniform or UniformToFill, the logic is similar but the X and Y dimensions are scaled uniformly, preserving the aspect ratio of the contents. If the Stretch is Uniform, the ViewBox is scaled to have the more constrained dimension equal to the ViewPort's size. If the Stretch is UniformToFill, the ViewBox is scaled to have the less constrained dimension equal to the ViewPort's size. In other words, both Uniform and UniformToFill preserve aspect ratio, but Uniform ensures that the entire ViewBox is within the ViewPort (potentially leaving portions of the ViewPort uncovered by the ViewBox), and UniformToFill ensures that the entire ViewPort is filled by the ViewBox (potentially causing portions of the ViewBox to be outside the ViewPort). If the ViewBox is empty, then no Stretch will apply. Note that alignment will still occur, and it will position the \u201cpoint\u201d ViewBox.",{"@attributes":{"id":"p-0162","num":"0174"},"figref":"FIG. 18","b":["1800","800","1802","1804","1806"]},"Once the ViewPort is determined (based on DestinationUnits) and the ViewBox's size is determined (based on Stretch), the ViewBox needs to be positioned within the ViewPort. If the ViewBox is the same size as the ViewPort (if Stretch is Fill, or if it just happens to occur with one of the other three Stretch values), then the ViewBox is positioned at the Origin so as to be identical to the ViewPort. Otherwise, HorizontalAlignment and VerticalAlignment are considered. Based on these properties, the ViewBox is aligned in both X and Y dimensions. If the HorizontalAlignment is Left, then the left edge of the ViewBox will be positioned at the Left edge of the ViewPort. If it is Center, then the center of the ViewBox will be positioned at the center of the ViewPort, and if Right, then the right edges will meet. The process is repeated for the Y dimension.","If the ViewBox is (0,0,0,0), it is considered unset, whereby ContentUnits are considered. If the ContentUnits are UserSpaceOnUse, no scaling or offset occurs, and the contents are drawn into the ViewPort with no transform. If the ContentUnits are ObjectBoundingBox, then the content origin is aligned with the ViewPort Origin, and the contents are scale by the object's bounding box's width and height.","When filling a space with a VisualBrush, the contents are mapped into the ViewPort as above, and clipped to the ViewPort. This forms the base tile for the fill, and the remainder of the space is filled based on the Brush's TileMode. Finally, if set, the Brush's transform is applied\u2014it occurs after all the other mapping, scaling, offsetting, etc.","The TileMode enumeration is used to describe if and how a space is filled by its Brush. A Brush which can be tiled has a tile rectangle defined, and this tile has a base location within the space being filled. The rest of the space is filled based on the TileMode value.  provides a representation of example graphics with various TileMode settings, including \u201cNone\u201d , \u201cTile\u201d , \u201cFlipX\u201d , \u201cFlipY\u201d  and \u201cFlipXY\u201d . The top left-most tile in the various example graphics comprises the base tile.",{"@attributes":{"id":"p-0167","num":"0179"},"figref":["FIG. 20","FIG. 20","FIG. 20"]},"In general, each time the contents of the pattern are drawn, a new coordinate system is created. The origin and offset of each repetition is specified by the Origin and Size properties, as filtered through the DestinationUnits and Transform properties.","A coordinate frame is set up based on the DestinationUnits property. To this end, if at step , the DestinationUnits property is UserSpaceOnUse, the current coordinate frame at the time the brush was used is the starting coordinate frame, via step . If instead at step  the property is ObjectBoundingBox, the bounding box of the geometry to which this brush is applied is used, as represented by step , to set a new coordinate frame such that the upper left corner of the bounding box maps to (0,0) and the lower left corner of the bounding box maps to (1,1). In either case, at step  the Transform property is applied to this coordinate frame, which essentially defines a grid.",{"@attributes":{"id":"p-0170","num":"0182"},"figref":"FIG. 21"},"At step , the visual is drawn into each cell of the grid, as represented in , where the visual draws the appropriate data. If at step  there is a ViewBox specified, the Visual is fitted into the grid cell as specified by the ViewBox, Stretch, HorizontalAlign and VerticalAlign attributes, via step . The DestinationUnits and Transform properties are used to apply the correct transform such that the visual lines up in the grid box.","If there is no ViewBox specified, then a new coordinate system is established for drawing the content at step .","The coordinate frame is set such that its origin is at the Origin point for that particular grid cell being drawn.","A clip is applied at step  based on the Size property such that this tile will not draw outside of the bounds of the cell. The Origin and Size are modified appropriately based on the DestinationUnits property.","The coordinate system is then modified, based on the SourceUnits property. To this end, if at step  the SourceUnits property is ObjectBoundingBox, the appropriate scaling transform is applied at step , otherwise it is UserSpaceOnUse, and no new transform is applied. The Transform property is applied at step , and the content is drawn at step .","Note that if any part of size is zero, nothing is drawn, and if Stretch is \u201cNone,\u201d the transform for the viewbox is set up such that one unit in the new coordinate frame is equal to one unit in the old coordinate frame. The transform essentially becomes an offset based on the align attributes and the size of the ViewBox. As described above at steps  and , Stretch and the alignment properties only apply when there is a ViewBox specified. The ViewBox specifies a new coordinate system for the contents, and Stretch helps to specify how those contents map into the Viewbox. The alignment options align the ViewBox, not the contents. Thus, for example, if the viewbox is set to \u201c0 0 10 10\u201d and something is drawn at \u221210,\u221210 and aligned to the upper left corner, that thing will be clipped out.","Returning to , image brush can be thought of as a special case of VisualBrush. Although a program can create a visual, put an image into it and attach it to VisualBrush, the API for doing so would be cumbersome. Since there is no necessary content coordinate frame, the ViewBox and ContentUnits property members no longer apply.",{"@attributes":{"id":"p-0178","num":"0190"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public class System.Windows.Media.ImageBrush : Brush"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public ImageBrush(ImageData image);"]},{"entry":[{},"public BrushMappingMode DestinationUnits { get; }"]},{"entry":[{},"public Transform Transform { get; }"]},{"entry":[{},"public Stretch Stretch { get; }"]},{"entry":[{},"public HorizontalAlign HorizontalAlign { get; }"]},{"entry":[{},"public VerticalAlign VerticalAlign { get; }"]},{"entry":[{},"public Point Origin { get; }"]},{"entry":[{},"public PointAnimationCollection OriginAnimations { get; }"]},{"entry":[{},"public Size Size { get; }"]},{"entry":[{},"public SizeAnimationCollection SizeAnimations { get; }"]},{"entry":[{},"public ImageData ImageData { get; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"public class System.Windows.Media.ImageBrushBuilder :"},{"entry":"BrushBuilder"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public ImageBrushBuilder( );"]},{"entry":[{},"public ImageBrushBuilder(ImageData image);"]},{"entry":[{},"public ImageBrushBuilder(ImageBrush ib);"]},{"entry":[{},"\/\/ DestinationUnits: Default is ObjectBoundingBox"]},{"entry":[{},"public BrushMappingMode DestinationUnits { get; set; }"]},{"entry":[{},"\/\/ Transform: Default is identity"]},{"entry":[{},"public Transform Transform { get; set; }"]},{"entry":[{},"\/\/ Stretch: Default is None"]},{"entry":[{},"public Stretch Stretch { get; set; }"]},{"entry":[{},"\/\/ HorizontalAlign: Default is Center"]},{"entry":[{},"public HorizontalAlign HorizontalAlign { get; set; }"]},{"entry":[{},"\/\/ VerticalAlign: Default is Center"]},{"entry":[{},"public VerticalAlign VerticalAlign { get; set; }"]},{"entry":[{},"\/\/ Origin: Default is (0,0)"]},{"entry":[{},"public Point Origin { get; set; }"]},{"entry":[{},"public PointAnimationCollectionBuilder OriginAnimations"]},{"entry":[{},"{ get; set; }"]},{"entry":[{},"\/\/ Size: Default is (1,1)"]},{"entry":[{},"public Size Size { get; set; }"]},{"entry":[{},"public SizeAnimationCollectionBuilder SizeAnimations"]},{"entry":[{},"{ get; set; }"]},{"entry":[{},"\/\/ ImageData: Default is null -- nothing drawn"]},{"entry":[{},"public ImageData ImageData { get; set; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"NineGridBrush is very similar to ImageBrush except the image is warped based on the size. In essence, NineGridBrush may be thought of a custom type of Stretch, in which certain parts of the image stretch, while others (e.g., borders) do not. Thus, while the Size of the image in the ImageBrush will cause a simple scale, the NineGridBrush will produce a non-uniform scale up to the desired size. The units for the non-scaled areas are the user units when the brush is applied, which means that ContentUnits (if it existed for NineGridBrush) would be set to UserUnitsOnUse. The Transform property of the Brush can be used effectively. Note that the border members count in from the edge of the image.","By way of example,  represents a nine-grid image being enlarged from a first instance  to a second instance , with four types of areas. As represented in , to keep the border the same, the areas marked \u201ca\u201d expand horizontally, the areas marked \u201cb\u201d expand vertically, the areas marked \u201cc\u201d expand horizontally and vertically, and the areas marked \u201cd\u201d do not change in size.",{"@attributes":{"id":"p-0181","num":"0193"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public class System.Windows.Media.NineGridBrush : Brush"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"public NineGridBrush(ImageData image,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int LeftBorder, int RightBorder,"]},{"entry":[{},"int TopBorder, int BottomBorder);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public BrushMappingMode DestinationUnits { get; }"]},{"entry":[{},"public Transform Transform { get; }"]},{"entry":[{},"public Point Origin { get; }"]},{"entry":[{},"public PointAnimationCollection OriginAnimations { get; }"]},{"entry":[{},"public Size Size { get; }"]},{"entry":[{},"public SizeAnimationCollection SizeAnimations { get; }"]},{"entry":[{},"public int LeftBorder { get; }"]},{"entry":[{},"public int RightBorder { get; }"]},{"entry":[{},"public int TopBorder { get; }"]},{"entry":[{},"public int BottomBorder { get; }"]},{"entry":[{},"public ImageData ImageData { get; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"public class System.Window.Media.NineGridBrushBuilder : BrushBuilder"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public NineGridBrushBuilder( );"]},{"entry":[{},"public NineGridBrushBuilder (ImageData image,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int LeftBorder, int RightBorder,"]},{"entry":[{},"int TopBorder, int BottomBorder);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public NineGridBrushBuilder (NineGridBrush ngb);"]},{"entry":[{},"\/\/ DestinationUnits: Default is ObjectBoundingBox"]},{"entry":[{},"public BrushMappingMode DestinationUnits { get; set; }"]},{"entry":[{},"\/\/ Transform: Default is identity"]},{"entry":[{},"public Transform Transform { get; set; }"]},{"entry":[{},"\/\/ Origin: Default is (0,0)"]},{"entry":[{},"public Point Origin { get; set; }"]},{"entry":[{},"public PointAnimationCollectionBuilder OriginAnimations { get;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"set; }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Size: Default is (1,1)"]},{"entry":[{},"public Size Size { get; set; }"]},{"entry":[{},"public SizeAnimationCollectionBuilder SizeAnimations { get; set; }"]},{"entry":[{},"\/\/ *Border: default to 0"]},{"entry":[{},"public int LeftBorder { get; set; }"]},{"entry":[{},"public int RightBorder { get; set; }"]},{"entry":[{},"public int TopBorder { get; set; }"]},{"entry":[{},"public int BottomBorder { get; set; }"]},{"entry":[{},"\/\/ ImageData: Default is null -- nothing drawn"]},{"entry":[{},"public ImageData ImageData { get; set; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"As generally described above, the graphics object model of the present invention includes a Transform object model, which includes the types of transforms represented in the hierarchy of , under a Transform base class. These different types of components that make up a transform may include TransformList, TranslateTransform, RotateTransform, ScaleTransform, SkewTransform, and MatrixTransform. Individual properties can be animated, e.g., a program developer can animate the Angle property of a RotateTransform.","Matrices for 2D computations are represented as a 3\u00d73 matrix. For the needed transforms, only six values are needed instead of a full 3\u00d73 matrix. These are named and defined as follows.",{"@attributes":{"id":"p-0184","num":"0196"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"mi":"m00"},{"mi":"m01"},{"mn":"0"}]},{"mtd":[{"mi":"m10"},{"mi":"m11"},{"mn":"0"}]},{"mtd":[{"mi":"m20"},{"mi":"m21"},{"mn":"1"}]}]}},"mo":"\u2003"}}}},"When a matrix is multiplied with a point, it transforms that point from the new coordinate system to the previous coordinate system:",{"@attributes":{"id":"p-0186","num":"0198"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":[{"mo":["[","]"],"mrow":{"msub":[{"mi":["X","newCoordSys"]},{"mi":["y","newCoordSys"]}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mn":"1"}},{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"mi":"m00"},{"mi":"m01"},{"mn":"0"}]},{"mtd":[{"mi":"m10"},{"mi":"m11"},{"mn":"0"}]},{"mtd":[{"mi":"m20"},{"mi":"m21"},{"mn":"1"}]}]}}],"mo":"\u00b7"},{"mo":["[","]"],"mrow":{"msub":[{"mi":["X","oldCoordSys"]},{"mi":["y","oldCoordSys"]}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mn":"1"}}],"mo":"="}}}},"Transforms can be nested to any level. Whenever a new transform is applied it is the same as post-multiplying it onto the current transform matrix:",{"@attributes":{"id":"p-0188","num":"0200"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mo":["[","]"],"mrow":{"msub":[{"mi":["X","newCoordSys"]},{"mi":["y","newCoordSys"]}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mn":"1"}},{"mo":"\u2003","mrow":{"mrow":[{"mrow":[{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"msub":{"mi":"m00","mn":"2"}},{"msub":{"mi":"m01","mn":"2"}},{"mn":"0"}]},{"mtd":[{"msub":{"mi":"m10","mn":"2"}},{"msub":{"mi":"m11","mn":"2"}},{"mn":"0"}]},{"mtd":[{"msub":{"mi":"m20","mn":"2"}},{"msub":{"mi":"m21","mn":"2"}},{"mn":"1"}]}]}},{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"msub":{"mi":"m00","mn":"1"}},{"msub":{"mi":"m01","mn":"1"}},{"mn":"0"}]},{"mtd":[{"msub":{"mi":"m10","mn":"1"}},{"msub":{"mi":"m11","mn":"1"}},{"mn":"0"}]},{"mtd":[{"msub":{"mi":"m20","mn":"1"}},{"msub":{"mi":"m21","mn":"1"}},{"mn":"1"}]}]}}],"mo":"\u00b7"},{"mo":["[","]"],"mrow":{"msub":[{"mi":["X","oldCoordSys"]},{"mi":["y","oldCoordSys"]}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mn":"1"}}],"mo":"="}}],"mo":"\u00b7"}}}},"Most places in the API do not take a Matrix directly, but instead use the Transform class, which supports animation.",{"@attributes":{"id":"p-0190","num":"0202"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public struct System.Windows.Media.Matrix"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Construction and setting"]},{"entry":[{},"public Matrix( ); \/\/ defaults to identity"]},{"entry":[{},"public Matrix("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"double m00, double m01,"]},{"entry":[{},"double m10, double m11,"]},{"entry":[{},"double m20, double m21);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Identity"]},{"entry":[{},"public static readonly Matrix Identity;"]},{"entry":[{},"public void SetIdentity( );"]},{"entry":[{},"public bool IsIdentity { get; }"]},{"entry":[{},"public static Matrix operator *(Matrix matrix1, Matrix"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"matrix2);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public static Point operator *(Matrix matrix, Point point);"]},{"entry":[{},"\/\/ These function reinitialize the current matrix with"]},{"entry":[{},"\/\/ the specified transform matrix."]},{"entry":[{},"public void SetTranslation(double dx, double dy);"]},{"entry":[{},"public void SetTranslation(Size offset);"]},{"entry":[{},"public void SetRotation(double angle); \/\/ degrees"]},{"entry":[{},"public void SetRotation(double angle, Point center);"]},{"entry":[{},"\/\/ degrees"]},{"entry":[{},"public void SetRotationRadians (double angle);"]},{"entry":[{},"public void SetRotationRadians(double angle, Point center);"]},{"entry":[{},"public void SetScaling(double sx, double sy);"]},{"entry":[{},"public void SetScaling(double sx, double sy, Point center);"]},{"entry":[{},"public void SetSkewX(double angle); \/\/ degrees"]},{"entry":[{},"public void SetSkewY(double angle); \/\/ degrees"]},{"entry":[{},"public void SetSkewXRadians(double angle);"]},{"entry":[{},"public void SetSkewYRadians(double angle);"]},{"entry":[{},"\/\/ These function post-multiply the current matrix"]},{"entry":[{},"\/\/ with the specified transform"]},{"entry":[{},"public void ApplyTranslation(double dx, double dy);"]},{"entry":[{},"public void ApplyTranslation(Size offApply);"]},{"entry":[{},"public void ApplyRotation(double angle); \/\/ degrees"]},{"entry":[{},"public void ApplyRotation(double angle, Point center); \/\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"degrees"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public void ApplyRotationRadian(double angle);"]},{"entry":[{},"public void ApplyRotationRadian(double angle, Point center);"]},{"entry":[{},"public void ApplyScaling(double sx, double sy);"]},{"entry":[{},"public void ApplyScaling(double sx, double sy, Point center);"]},{"entry":[{},"public void ApplySkewX(double angle); \/\/ degrees"]},{"entry":[{},"public void ApplySkewY(double angle); \/\/ degrees"]},{"entry":[{},"public void ApplySkewXRadians(double angle);"]},{"entry":[{},"public void ApplySkewYRadians(double angle);"]},{"entry":[{},"public void ApplyMatrix(Matrix matrix);"]},{"entry":[{},"\/\/ Inversion stuff"]},{"entry":[{},"public double Determinant { get; }"]},{"entry":[{},"public bool IsInvertible { get; }"]},{"entry":[{},"public void Invert( ); \/\/ Throws ArgumentException if"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"! IsInvertable"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public static Matrix Invert(Matrix matrix);"]},{"entry":[{},"\/\/ Individual members"]},{"entry":[{},"public double M00 { get; set; }"]},{"entry":[{},"public double M01 { get; set; }"]},{"entry":[{},"public double M10 { get; set; }"]},{"entry":[{},"public double M11 { get; set; }"]},{"entry":[{},"public double M20 { get; set; }"]},{"entry":[{},"public double M21 { get; set; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"As can be seen from the foregoing detailed description, there is provided a system, method and object model that provide program code with the ability to interface with a scene graph. The system, method and object model are straightforward to use, yet powerful, flexible and extensible.","While the invention is susceptible to various modifications and alternative constructions, certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood, however, that there is no intention to limit the invention to the specific forms disclosed, but on the contrary, the intention is to cover all modifications, alternative constructions, and equivalents falling within the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 8A and 8B"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 9A\u20139C"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 10A and 10B"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 24"}]},"DETDESC":[{},{}]}
