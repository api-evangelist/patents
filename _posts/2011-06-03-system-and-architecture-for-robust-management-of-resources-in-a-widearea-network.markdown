---
title: System and architecture for robust management of resources in a wide-area network
abstract: A system and method of management of communication in a potentially unreliable wide-area network that contains one or more nodes connected to said network, each potentially having access to one or more inputs and/or outputs and capable of evaluating said inputs and directing said outputs, a global address space (GAS) accessible by said nodes, and a communication system using said GAS that provides communications between said nodes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08572290&OS=08572290&RS=08572290
owner: Board of Supervisors of Louisiana State University and Agricultural and Mechanical College
number: 08572290
owner_city: Baton Rouge
owner_country: US
publication_date: 20110603
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","Partition Tolerance","Churn Tolerance","Reconfigurability","Timely Response","Relational Operations","Consistency","Availability","Brewer's CAP Theorem","Existing Group Communication Systems","ISIS","Spread Group Communication Toolkit","JGroups","Problems with Existing Group Communication Systems","DETAILED DESCRIPTION OF THE DRAWINGS","Example 1","Example 2","Example 3","Unreliable Network","Redeployment"],"p":["This application claims priority from U.S. Provisional Application No. 61\/481,667 (Mukhopadhyay et al.), filed May 2, 2011, which is incorporated herein by reference as if set forth in full below.","I. Field of the Invention","The present invention relates generally to computer networks, and relates more specifically to systems and methods for using network resources.","II. General Background","Computer networks can suffer from a variety of problems or limitations. In particular, certain computer network applications require that computers on a network be able to reliably access, process, evaluate and take action based on information acquired by other computers on said network even in cases where portions of the network become unreliable or inaccessible.","In view of the foregoing, there is a continuing need for a system and method of management of communication in an unreliable wide-area network that contains one or more resources, including any suitable input or source of information, an output that can include any suitable receiver of information or a data output device, a global address space (GAS), and a communication system for resources on the network.","In view of the aforementioned problems, it is an object of the present invention to allow computers on a network to reliably access, process, evaluate and take action based on information acquired by other computers on said network.","In an exemplary embodiment, the system includes one or more computers connected to a network. One or more of the computers connected to said network also contain instruments to measure the environment. In addition, one or more of the computers connected to said network also contain devices to take action on the environment.","In an exemplary embodiment, one or more of the computers connected to said network are specially programmed to contain (1) a moderating component which controls other processes of said computer; (2) an evaluating component which accesses available information and takes action based on internal logic; (3) a GAS which provides information to the evaluating component and coordinates the distribution of information through the GAS to other computers in the network; and (4) a communications component which passes information from the evaluating component to the GAS and provides the evaluating component access to information from the GAS.","The above and other objects and features of the present invention will become apparent from the drawings, the description given herein, and the appended claims.","In an exemplary embodiment, one or more of the following features may be found:\n\n","This application incorporates by reference the specification of United States Patent Application Publication Number US 2009\/0222921 (Mukhopadhyay et al.), filed Feb. 29, 2008.","As used herein, the terms \u201cnode\u201d and \u201chost\u201d are used interchangeably to mean a general purpose computer particularly programmed to carry out the tasks as stated herein, wherein each general purpose computer is connected to a network and also includes a data storage device.","As used herein, the terms \u201cinstrument\u201d and \u201cinput\u201d are interchangeable and mean any device, now known or hereinafter invented, which is capable of acquiring information from the environment. The definition of \u201cinstrument\u201d as well as \u201cinput\u201d includes, but is not limited to, devices that measure pressure, heat, conductivity, one or more frequencies of electromagnetic radiation (including, without limitation, visible light and microwave radiation), moisture, the presence of elements or combinations of elements on the periodic table, and the presence of complex molecules or portions thereof (including proteins, viruses, DNA molecules). As such, this definition includes, but is not limited to, an accelerometer, an ammeter, an anemometer, a caliper, a calorimeter, a DNA sequencer, a dynamometer, an electrometer, an electroscope, an electrostatic analyzer, a gravimeter, an hygrometer, an inclinometer, an interferometer, a magnetograph, a magnetometer, a mass spectrometer, a micrometer, a microscope, an ohmmeter, an oscilloscope, a seismometer, a spectrogram, a spectrometer, a telescope, a thermocouple, and a voltmeter. This definition also includes combinations of instruments or inputs configured to provide more complex information. For example, this definition includes a device that determines whether a door is open or closed, and it also includes computer systems capable of face recognition.","As used herein, the terms \u201cactuator\u201d and \u201coutput\u201d are interchangeable and mean anything that is capable of causing change in the environment. This definition includes, but is not limited to, solenoid valves powered by electricity or hydraulics, and may include a combination of actuators and other devices which, when used together, can effect change on the environment.","As used herein, the term \u201cglobal address space\u201d or \u201cGAS\u201d means one or more computers connected via a network and particularly programmed and configured to make a mutable set of data available to computers connected to the network. In certain embodiments, said computers may be configured to make a mutable set of data available make all of said data locally available to each computer that is part of the GAS. A distributed key-value store is one example of a GAS, but other technologies may be used. For example, relational databases configured with replication may be configured such that they provide a GAS. Also, multiprocessor systems such as high performance computing systems may be configured in a shared memory environment to provide a GAS.","As used herein, the term \u201cAPI\u201d means \u201capplication programming interface\u201d and has its usual understood meaning to those skilled in the art.","The embodiments of the disclosure will be best understood by reference to the drawings, wherein like parts are designated by like numerals throughout. It will be readily understood that the components, as generally described and illustrated in the Figures herein, could be arranged and designed in a wide variety of different configurations. Thus, the following more detailed description of the embodiments of the system and method of the disclosure, as represented in  is not intended to limit the scope of the disclosure, as claimed, but is merely representative of possible embodiments of the disclosure.","Much of the infrastructure that can be used with embodiments disclosed herein is already available, such as: general purpose computers; computer programming tools and techniques; computer networks and networking technologies; wireless communications; and digital storage media.","Suitable networks for configuration and\/or use as described herein include one or more local area networks, wide area networks, metropolitan area networks, ham radio networks, and\/or Internet Protocol networks such as the World Wide Web, a private Internet, a secure Internet, a value-added network, a virtual private network, an extranet, an intranet, or even standalone machines which communicate with other machines by physical transport of media. In particular, a suitable network may be formed from parts or entireties of two or more other networks, including networks using disparate hardware and network communication technologies. A network may incorporate wired or land line communication such as Ethernet over twisted pair, T-carrier, or other wired communications technologies. A network may also incorporate wireless communications technologies such as GPRS, EDGE, EV-DO, HSPA, HSDPA, and technologies based on the IEEE 802.11 set of standards.","The network may include communications or networking software such as software available from Novell, Microsoft, Artisoft, and other vendors, and may operate using TCP\/IP, SPX, IPX, and other protocols over twisted pair, coaxial, or optical fiber cables, telephone lines, satellites, microwave relays, modulated AC power lines, physical media transfer, and\/or other data transmission \u201cwires\u201d known to those of skill in the art. The network may encompass smaller networks and\/or be connectable to other networks through a gateway or similar mechanism.","Suitable networks can include a server and several clients; other suitable networks may contain other combinations of servers, clients, and\/or peer-to-peer nodes, and a given computer may function both as a client and as a server. Each network can include one or more computers, such as the server and\/or clients. A computer may be a workstation, laptop computer, disconnectable mobile computer, server, mainframe, cluster, so-called \u201cnetwork computer\u201d or \u201cthin client\u201d, mobile telephone, personal digital assistant or other hand-held computing device, \u201csmart\u201d consumer electronics device or appliance, or a combination thereof.","Suitable networks can also include one or more physical sensors and\/or physical actuators that either communicate with nodes of a network or are themselves nodes of the network. For example, a network can include a wireless sensor network of physical sensors. Physical sensors can include one or more motion sensors, heat sensors, chemical sensors, moisture sensors, photo detectors, or any other suitable data-gathering device configured to sense a physical quantity. The physical sensors can deliver information regarding a physical quantity to the network in any suitable manner, such as by electrical or light signals. Physical actuators can be configured to receive instructions from the network and to produce a physical action as a result. For example, the physical actuators can include one or more motors, triggers, solenoids, or other suitable devices.","Each computer of a network may include a processor such as a microprocessor, microcontroller, logic circuitry or the like. The processor may include a special purpose processing device such as an ASIC, PAL, PLA, PLD, Field Programmable Gate Array, or other customized programmable device. The computer may also include a memory such as non-volatile memory, static RAM, dynamic RAM, ROM, CD-ROM, disk, tape, magnetic, optical, flash memory, or other computer storage medium (which memory can store computer software). It is understood that the computer may run software that is stored in such a computer readable medium. The computer may also include various input devices and\/or output devices. The input device(s) may include a keyboard, mouse, touch screen, light pen, tablet, microphone, sensor, or other hardware with accompanying firmware and\/or software. The output device(s) may include a keyboard, mouse, touch screen, light pen, tablet, microphone, sensor, or other hardware with accompanying firmware and\/or software.","Aspects of certain of the embodiments described are illustrated as software modules or components. As used herein, a software module or component may include any type of computer instruction or computer executable code located within a memory device and\/or transmitted as electronic signals over a system bus or wired or wireless network. A software module may, for instance, comprise one or more physical or logical blocks of computer instructions, which may be organized as a routine, program, object, component, data structure, etc., that performs one or more tasks or implements particular abstract data types.","In certain embodiments, a particular software module may comprise disparate instructions stored in different locations of a memory device, which together implement the described functionality of the module. Indeed, a module may comprise a single instruction or many instructions, and may be distributed over several different code segments, among different programs, and across several memory devices. Some embodiments may be practiced in a distributed computing environment where tasks are performed by a remote processing device linked through a communications network. In a distributed computing environment, software modules may be located in local and\/or remote memory storage devices. In addition, data being tied or rendered together in a database record may be resident in the same memory device, or across several memory devices, and may be linked together in fields of a record in a database across a network.","The software modules tangibly embody a program, functions, and\/or instructions that are executable by computer(s) to perform tasks as described herein. Suitable software, as applicable, may be readily provided by those of skill in the pertinent art(s) using the teachings presented herein and programming languages and tools including, but not limited to, XML, Java, Python, PHP, Pascal, C++, C, database languages, APIs, SDKs, assembly, firmware, microcode, and\/or other languages and tools. Suitable signal formats may be embodied in analog or digital form, with or without error detection and\/or correction bits, packet headers, network addresses in a specific format, and\/or other supporting data readily provided by those of skill in the pertinent art(s).","Networks can suffer from a variety of problems or limitations. In particular, collaboration and coordination among various components of a given network can pose a variety of challenges, particularly for heterogeneous networks. For example, some networks include disparate sensing, computing, and\/or actuating devices that interface via wired and\/or wireless connections and\/or that run on different platforms (for example, but not limited to, on different operating systems). Such networks are widely used in healthcare, military, automobile, building security, and space industries, among other, which often depend upon reliable delivery of service from elements of the network and upon secure and trustworthy exchange of information among network elements. Reliability and security are often complicated by such matters as timing requirements, security requirements, and\/or fault tolerances of service and\/or devices.","A variety of complications can arise in such networks. For example, clients or services can migrate from one physical location to another, which can complicate failure semantics. Clients or services may operate in limited resource environments (for example, but not limited to, on PDA's, cellular phones, Arduino systems, or other embedded systems) having bandwidth limitations and\/or shortage of space or other resource limitations. In some instances, clients or services may communicate different types of data (e.g., voice information, multimedia information, etc.) through communication channels that are unreliable, are susceptible of eavesdropping, and\/or conform to differing standards (e.g., 802.11, Zigbee, Land Mobile Radio (LMR), etc.). The exchange of information in some networks can involve passing messages that include semi-structured data, the integrity of which may be compromised due to the presence of possible faults or breaches in the network. Indeed, the diverse platforms, computing elements, and\/or sensing elements of some networks may provide heterogeneous, semi-structured data having untraced or uncertified pedigrees, and individual nodes or even entire subnetworks of a given network may fail or be compromised.","Various embodiments described herein address some or all of the foregoing issues, as well as others that may or may not be discussed below. For example, in some embodiments, a coordination layer is provided that permits reliable communication between resources and output devices in a heterogeneous network. The coordination layer can promote the conformance of services and information exchanged over the network to the goals of a user and\/or can promote observance of the performance desires that a user wishes for a system to exhibit. For example, in some embodiments, the coordination layer provides formal guarantees that user-defined system objectives and quality of service requirements are met. In some embodiments, the coordination layer can respond to diverse local policies governing computation and communication in individual computing elements and local networks, as well as changes to a network (such as failures or compromises of individual nodes of subnetworks). In some embodiments, the coordination layer can dynamically adapt to changes in the network, such as failures or security breaches of individual services or devices, and can automatically provide for the successful achievement of the goals or objectives of the network (which in some instances, are user-defined). Other features and advantages of various embodiments are described below and will be apparent to those of skill in the art from the disclosure herein.","In one embodiment, a distributed hash table (DHT) is used as the GAS, and the GAS uses a synchronization algorithm to coordinate the distribution of information across multiple devices. The DHT may also be thought of as a data store which provides GAS access. Instances of the DHT are configured to communicate with only two other instances. In these embodiments, the instances of the DHT self-arrange into a ring (one example of a pattern), whereby information is passed in one direction from instance to instance until all instances receive the communicated information. This behavior is part of generic DHT algorithms. It has been observed that this embodiment, inherent of generic DHT algorithms, cannot detect when either the nodes on the network or the network itself becomes congested or over utilized. In addition, we speculate that a generic DHT configured in a circular message passing (single ring) configuration does not perform well when configured in a network of more than 80 instances.","In one embodiment, the DHT may be the distributed transactional key-value store known as Scalaris. In this embodiment, the synchronization algorithm used is a non-blocking implementation of Lamport's Paxos algorithm.","In another embodiment, a generic DHT has been modified by us to test network and node congestion before passing information to another node. This improvement over known DHT implementations improves resource efficiency and allows for greater scalability. The quality control test comprises the steps of sending approximately 10 to 15 test packets along the ring of instances. However, more or less test packets may be used. As each instance of the DHT receives the test packet, said instance measures its recent resource use. This may occur, for example, by requesting the operating system to report a Unix-style load calculation known as a load average. Each instance records its resource use measurement in the test packet, which is then communicated to the next instance. As each test packet returns to the tester, the testing instance of the DHT (1) measures the time to traverse the network; (2) determines how many of the test packets return; and (3) calculates overall CPU resource utilization based on the measured CPU resource usage reported in each test packet. Based on this information, the testing instance of the DHT determines whether it is appropriate to send the information at the present time or whether it should wait for resources to become free before sending. However, it has been observed that, for certain configurations, current overall resource use does not accurately predict future overall resource use. In other words, a goal of measuring overall resource use is to attempt to use resources when resource use is low. In certain configurations, overall resource use may vary rapidly, for example, from relatively high usage at time 1, to relatively low usage at time 2, and then back to relatively high usage at time 3. In such a situation, a measurement of overall resource use at time 2 would suggest that current use is low. If the instance of the DHT then sends information at time 2, this message compounds the high network use at time 3.","Accordingly, another embodiment has been modified by us to use Vapnik's Support Vector Machine (SVM) algorithm with feedback to predict, based on observed patterns of overall resource usage, whether the instance of the DHT should use overall resource resources by communicating a message to another instance of the DHT. This improvement over known DHT implementations improves resource efficiency and allows for greater scalability. In this embodiment, before the DHT begins operations, the learning algorithm is primed with random data. As the DHT runs, each time an instance of the DHT tests the network, the then current resource utilization status is recorded and the learning algorithm is asked to determine whether resource use will be high or low based on the current and previously recorded states. The learning algorithm is given feedback in the form of subsequent observations of resource utilization, which is used by the learning algorithm to make more accurate predictions. Although Vapnik's SVM algorithm is used in this embodiment, it is understood that a wide variety of machine learning algorithms may be used such as, for example Bayesian classifiers, hidden Markov models, and neural networks. Also, machine learning algorithms enabled by Waikato Environment for Knowledge Analysis (WEKA) may be used.","Because we speculate that certain configurations of DHTs do not perform well when configured in a network of more than 80 instances, another embodiment of the invention overcomes this limitation of DHTs by self-arranging into multiple connected communications rings. This improvement over known DHT implementations improves resource efficiency and allows for greater scalability.","In another embodiment, the GAS is a DHT (again, which may be thought of as a data store) which allows for retrieval of information based on key ranges or intervals. In addition, the DHT may be Scalaris as modified to allow for retrieval of information based on key ranges or intervals.","In certain embodiments, the system clocks of hosts are synchronized. Although it is understood that any number of time synchronization protocols such as the Network Time Protocol (NTP) may be used, in a preferred embodiment, a decentralized network time (DNT) algorithm is used. DNT algorithms are preferred because we perceive NTP to require centralized resources, whereas DNT algorithms do not. Accordingly, use of DNT algorithms enhances the availability and reliability of the group communication system. In certain embodiments, hosts collectively select one host to set the current time for all hosts. In certain embodiments, the host chosen by the group of hosts to set the time is the host with the earliest time. In certain embodiments, hosts communicate time through the GAS. In addition, the DNT algorithm may be Mattern's GVT algorithm, GVT algorithms based on Mattern's GVT algorithm, or other GVT algorithms such as the TQ-GVT algorithm described by Chen et al.","An embodiment of the invention includes a framework for conducting asynchronous communications. Processes may use this framework to communicate with other processes via the GAS, which may provide access to a tuple space similar to that of the Linda coordination language developed at Yale University by David Gelernter and Nicholas Carriero. In one embodiment, the GAS may provide access to the tuple space via a DHT. This framework allows processes to form, join, and leave groups, keeping track of group membership and consistency data in the tuple space. This framework also allows for processes to publish information to, or read information from, the tuple space. The framework also allows for information to be sequentially ordered and time stamped. Accordingly, information transmitted by the framework into the tuple space may include associated sequential order information and may include an associated time stamp provided by a DNT or other time synchronization algorithm. Processes may also remove information that is no longer needed by the framework in a process of garbage collection. The communications framework provides asynchronous communication capability, allowing components of the system to continue operation when communications become unreliable or certain components become unreachable over the network. As described more completely herein, the communications framework, in conjunction with other improved components of the system, allows for dynamic reconfiguration of components of the system.","The group communications framework (also a group communications system or an integrated communication framework) as described herein, together with the GAS, act together as middleware. There are a number of projects taking various approaches to implementing this type of middleware. Each of these projects or approaches have a number of characteristics, such as consistency, availability, tolerance to network partitions, tolerance to nodes continuously leaving and joining the system, reconfigurability, and timely response. These characteristics are described as follows:","A communication system is tolerant to network partitions if there is a network failure that splits the processing nodes into, for example, two groups that cannot talk to each other, but both subgroups continue to operate and process data independently until the partition is removed. In other words, a partition tolerant system continues to operate despite arbitrary message loss, which may partition the system into two or more groups. In our opinion partition tolerance is a good property for all communication systems.","A partition happens when there is a network failure that results in a communication gap between two nodes or groups of nodes in a system. A communication system is said to be tolerant to network partitions if, whenever there is any split in the communicating nodes due to network failure which creates subgroups of nodes, then the nodes in each subgroup continue to process information.","In a communication system, there will generally be three types of communication: node to node, node to a group of nodes, and between groups of nodes. So, for example, when there is a failure in the network which may cause interruption in communication between two groups of nodes, the individual groups (noting that a group may contain one or more nodes) will continue to operate independently in a partition tolerant system. Therefore, a system tolerant to network partitions may experience arbitrary message loss but continue to operate.","When a node joins a group communication system, the system will generally have to reconfigure itself in order to incorporate the node into the system. This process may require system resources, and the reconfiguration may cause delays in communication among nodes already part of the system. Systems (and in particular, systems with many nodes) may have some nodes leave and other nodes join the system with high frequency. The ability to handle these changes efficiently is known as churn tolerance. We believe that churn tolerance is an important characteristic for all systems, but is less important for fixed networks.","A group communication system is said to be reconfigurable if its behavior can be dynamically modified. For the purposes of this property, this includes modification to a processing component of the system, such as a portion of a computer containing a software object compiled into executable bytecode. A component can be modified while running or can be removed from the system, modified, and continue processing without missing any messages. It is our opinion that reconfigurability is a good property for all communication systems, but is very desirable in systems used for exploratory, military, or expeditionary purposes or in other situations where there is an unknown or uncertain environment.","A group communication system should respond to messages in a timely fashion. Although the term \u201ctimely\u201d may have a number of definitions in the art, we use the term timely to mean \u201cfaster than a human can calculate,\u201d and, more particularly, we use the term timely to mean that events detected by inputs or instruments can be evaluated and, where appropriate, acted upon (for example, by actuators), almost instantly. This may be accomplished, for example, where information is received, evaluated, and acted upon within, for example, less than 100 milliseconds. We believe that timely response is significantly important for all systems.","Because of how certain embodiments of this invention may be implemented (in particular, because of network disconnections and congestion), all components of the system may not always act timely. This is because where an input is received by a first node and the first node sends a message to a second node across a network, but a network disconnection causes said message to temporarily not reach said second node, then said second node cannot react to said input received by said first node \u201ctimely.\u201d However, said second node will still react timely to said input when the network disconnection or congestion is resolved, the partition event is over, and said second node receives the message.","Relational operations are database tables which have data ordered and organized on the basis of different common characteristics in the form of tables. For example, data may be organized in third normal form. We believe that relational operations are essential to, for example, enterprise management systems, banking systems, employee record systems, enterprise resource planning (ERP) systems, and customer relationship management (CRM) systems.","A communication system containing the nodes in a distributed computing environment is said to be consistent when each node in the system is consistent. Briefly, nodes are consistent where they contain the same information. A communication system may be consistent where it promises to have the familiar all-or-nothing semantics (i.e., a message must be received by all recipients before any can accept and process the message). Many systems achieve consistency via this all-or-nothing approach. In addition, some systems may also require that all messages be received and processed in order (i.e., no message reordering). The nodes in the system are said to be consistent if all nodes in the system have available the identical set of information. This may be achieved where:\n\n","A communication system is said to be highly available when the system continues to operate even though there may be one or more failures in the system (such as, for example, failures of individual sensors, individual nodes, or network communications links). In a highly available system, node failure should not prevent other nodes from continuing to operate. If there is a failure in the node, then the system should have some type of contingency planning, such as switching to another node, to keep the overall system running.","In other words, we believe that a highly available group communication system should not have centralized components with a single point of failure. This is because where a group communication system has centralized components, the failure of any such centralized component can cause the entire system to shut down. Accordingly, we believe that highly available systems should be decentralized rather than centralized.","According to the Brewer's CAP theorem, it is not possible for a distributed system to achieve the properties of consistency, availability, and tolerance to network partitions. Although some approaches attempt to approach achieving all three properties by relaxing the restraints required by one of the properties, it is our understanding that achieving such a relaxed set of goals is especially difficult in an asynchronous environment.","Although embodiments of the invention disclosed herein do not contradict Brewer's CAP theorem, the properties of consistency, availability, and tolerance to network partitions are achieved together by relaxing one of the three objectives. The approach taken by the invention disclosed herein relaxes one of the objectives: consistency. This is because, in our view, the other two objectives cannot be compromised by the distributed system in an asynchronous environment. Therefore, embodiments of the disclosed invention achieve all three properties by relaxing the consistency objective and replacing it with \u201ceventual consistency.\u201d","\u201cEventual consistency\u201d means that over a long time period where no updates are sent all updates will eventually propagate to all nodes and all the nodes will be consistent. In other words, all information eventually reaches all nodes, but there may be a delay. The time period for that delay will depend on available resources, the demand on those resources, and the duration of any network outages.","Group communication systems provide the communication medium between the nodes (users) in a network. They may be implemented over synchronous or asynchronous networks. We note the term asynchronous may have many meanings when used in connection with computer networks. As used herein to describe improvements of the invention disclosed herein, asynchronous means that transmission of a message is decoupled from receipt of said message. For example, in a synchronous network, the sender of a message transmits a message to a receiver only when the receiver is connected to the network and is currently ready to receive it (that is, the sender waits for the receiver to be ready). In an asynchronous network, the sender sends the message to the receiver without regard for whether the receiver is connected to the network or is ready to receive the message. A group communication system provides a communication layer between the sender and receiver, and ensures the messages are delivered accordingly with the desired properties (for example, synchronous or asynchronous semantics, message ordering, or other properties). There are some prominent group communication tools such as:\n\n","Based on our review of ISIS, Spread, and JGroups, we believe that these provide group communication in a synchronous environment. They are built on the top of TCP\/IP or UDP protocols. The key features they provide are virtual synchrony and consistency. Virtual synchrony is a property that allows nodes in a group communication system to form process groups for the purpose of organizing the transmittal of messages. Every node in a process group receives each message sent to the process group to which it belongs. Additionally, each message sent to a process group is received by each node in said process group in the same order in which said messages are sent. Group communications which implement virtual synchrony achieve the properties of data replication, fault tolerance, event notification and caching. Consistency as provided in these systems has the same meaning as described herein. That is, all the nodes in a network are consistent such that, when any node alters data in one node, the updated information is clearly visible to the other nodes in the network. It is our understanding that in these systems, each of the nodes will see the messages in the same order and that either all nodes receive a message or none of the nodes receive a message. Furthermore, if nodes are in a group, then if one node receives a message then each node in that group will receive that message; and, if any one node in a process group cannot receive a message, then no other node in the process group will receive the message. Thus, as we understand ISIS, Spread, and JGroups, they implement \u201call or nothing\u201d semantics.","The ISIS group communication tool is developed at Cornell University. It is our understanding that this tool implements a group communication system using the virtual synchrony approach. We understand that there are four different process groups implemented in ISIS, and each process group differs in how it implements group interactions. The four groups are: peer groups, client groups, diffusion groups and hierarchical groups.\n\n","ISIS nodes may or may not aware of one another. ISIS implements message delivery ordering rather than implementing the causal relationship between messages. As mentioned earlier, multiple modules are allowed to form a group under a group name and any message transmitted to the group will be received by all the nodes in that group.","The Spread wide area group communication system (Amir et al.) is developed at Johns Hopkins University. Spread comprises two low level protocols: ring and hop. The ring protocol is implemented on local area networks. The hop protocol is implemented on wide area networks. Furthermore, Spread implements a daemon-client architecture. In this architecture, group membership updates are done with minimal effort. When any node joins or leaves a group, this fact is communicated to others in the network via a single message. However, when there is network partition between nodes of a local area network, the membership update message causes a fully-fledged change in that node's group membership. We understand that Spread implements an \u201cextended\u201d form of virtual synchrony. This means that messages are transmitted even though messages may be lost using a variant of the alternating best protocol. Data is transmitted to the network via a necessary minimal set of components. Users have control over the Spread group communication system such that a message may be sent with priority over other messages transmitted in the network. Another prominent feature of this group communication system is that any node which is not a member of the group can transmit the message to the whole group.","JGroups is a commercial implementation of a group communication system written in Java and is an underlying part of the JBoss middleware. JGroups is a group communication system which implements so called reliable multicast communication. In JGroups, groups containing nodes can be created and deleted. The nodes are spread across local area networks and wide area networks. When each node joins or leaves the group, all other nodes in a group are notified. Messages may be one of two types: node to node and node to group. JGroups can implement different protocols like User Datagram Protocol (UDP), Transmission Control Protocol (TCP) and Java Message Service (JMS). Large messages are subjected to fragmentation and are encrypted when required. If there is any message loss, then the message is retransmitted. Another important feature of JGroups is failure detection, which removes disconnected nodes from any groups to which they belong.","Group communication systems may have a large number of nodes and may have nodes which are connected by either local area networks (LAN), wide area networks (WAN), or other suitable networks as described herein. Group communication systems comprised of a large number of nodes connected via a network that may experience outages or congestion are inherently asynchronous and are therefore more suited for asynchronous communication systems. Accordingly, we have identified the following list of problems with existing group communications systems when used in such environments:\n\n","In addition to ISIS, Spread, and JGroups, which are described immediately above, there are a number of other projects and approaches to this type of middleware. These include Data Distribution Service (used by, for example, United States Navy state-of-practice); Reliable Multicast (used by, for example, Isis, SPREAD, and Astrolabe); BigTable (used by, for example, Google); Cassandra (used by, for example, Facebook); CouchDB (provided by, for example, the Apache Project); Distributed Hash Tables (in the form used by, for example, Kademlia, Chord, and Pastry); Dynamo (used and provided by, for example, Amazon); Gizzard (used by, for example, Twitter), and JGroups (used by, for example, Jboss). A summary of these middleware options and our view of their features is included below.",{"@attributes":{"id":"p-0084","num":"0126"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE A-1"},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}},{"entry":[{},{},{},"Partition","Churn","Recon-","Timely"]},{"entry":["Approach","Consistency ","Availability","Tolerance","Tolerance","figurability","response"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Data","No","No","No","No","No","Yes"]},{"entry":["Distribution",{},{},{},{},{},{}]},{"entry":["Service",{},{},{},{},{},{}]},{"entry":["Reliable","Not","No","Yes","No","Not ","Yes"]},{"entry":["Multicast","available",{},{},{},"available",{}]},{"entry":["BigTable","No","Yes","Yes","No","No","No"]},{"entry":["Cassandra","No","Yes","No","No","Yes","No"]},{"entry":["CouchDB","Yes","No","No","No","Yes","No"]},{"entry":["Distributed","No","No","No","No","Yes","Yes"]},{"entry":["Hash Table",{},{},{},{},{},{}]},{"entry":["Dynamo","No","Yes","Yes","No","Yes","No"]},{"entry":["Gizzard","No","Yes","Yes","Yes","No","Yes"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]}}}}},"The discussions herein commenting upon other projects and the characteristics thereof contain our opinion and are based on our own review of these projects.","Our improvement over existing middleware approaches is that portions of the invention as described herein have all the desired properties\u2014consistency, availability, tolerance to network partitions, churn tolerance, reconfigurability, and timely response. In particular, when a group communication framework is implemented to utilize a GAS, the combination thereof has all of these properties and is an improvement over these currently-used approaches.","As depicted in the figures, lines connecting components may designate a direction. These directional signals are provided to assist in the understanding of the invention, and are nonlimiting.","With reference to , in certain embodiments, a first system  includes one or more resource  and an output . The resources  can include any suitable input or source of information. For example, the resources  can include one or more services (whether stateless and\/or stateful) or devices, such as online applications, software applications, computing elements, control stations, personal computers, personal electronic devices (such as personal digital assistants, smart phones, etc.), and\/or input devices, such as, for example, keyboards, mouse devices, and\/or physical sensors or other hardware devices configured to sense and, in some instances, to communicate one or more measurements and\/or aspects of a physical property or physical action. The output  can include any suitable receiver of information or data output device. For example, the output  can include a client, an online application, software application, computing element, control station, personal computer, personal electronic device, display, and\/or physical actuator. In some embodiments, the first system  includes multiple outputs .","The first system  further includes a layer, system, or control shell . In certain embodiments, the shell  allows for the satisfaction of policies, objectives and\/or quality of service goals, each of which may be user-defined, of the system . For example, in some embodiments, the shell  is capable of automatically determining the availability of one or more of the resources , selecting among the resources  to obtain the most reliable, cogent, or timely information for delivery to the output , and delivering the information thus obtained to the output  in a suitable format. In some embodiments, principles of artificial intelligence and programming languages are used to construct the shell , as further described below.","In some embodiments, the shell  is distributed among one or more nodes  that are arranged in a network . For example, in the illustrated embodiment, the shell  is distributed among three nodes . Each node  can comprise a storage device capable of storing information in a tangible medium. In some embodiments, one or more nodes  comprise one or more resources  and\/or one or more outputs .","As a non-limiting example, in the embodiment depicted in , the first system  can comprise a sprinkling system. The resources -of the sprinkling system can provide various forms of information regarding the landscaped property at which the sprinkling system is installed. For example, first resource can comprise a first clock, second resource can comprise a second clock, third resource can comprise a moisture sensor in the soil of the property, fourth resource can comprise a thermometer measuring the air temperature at the property, and fifth resource can comprise an online weather forecast application. The output  can comprise an actuator configured to activate or deactivate the sprinkling system. Each of the first resource , second resource , third resource , fourth resource , fifth resource , and the output  are in communication with the shell .","The shell  can include rules for instructing the output  to activate or deactivate the sprinkling system based on information received from one or more of: first resource , second resource , third resource , fourth resource , or fifth resource . For example, the shell  can include a rule set for determining whether to activate the sprinkling system, such as the following:\n\n","The shell  can gather information from first resource , second resource , third resource , fourth resource , and fifth resource ; and, based on the rule set, provide appropriate instructions to the output . Additionally, the shell  can monitor the availability and\/or operational status of first resource , second resource , third resource , fourth resource , and fifth resource and adapt the decision-making process in response to any changes that may occur to the system .","For example, the shell  can be configured to apply only the first rule of the rule set if one or more of the clocks (first resource and second resource ) are available. If the shell  senses that the clock (first resource ) is unavailable or inaccurate, such as may result from a brief power outage or other resetting event, the shell  can instead use second resource (also a clock). Additionally, the shell  can be configured to disregard the first rule and apply one or more of the second, third, and fourth rules if both first resource and second resource are unavailable or inaccurate.","In some embodiments, the shell  employs decentralized, context-aware programming models (further described below) that model workflows for processing of information regarding the current configuration (e.g., the state, status, or availability of one or more of the resources ) of the first system  and for discovering and composing services in order to adapt to future configurations of the system . The workflows can comprise business process models that consist of partially ordered sequences of cooperating and coordinated tasks executed to meet the objectives of the first system  and\/or the output .","With reference to , in certain embodiments, a second system  such as the first system  comprises one or more resources  and an output  in communication with a shell . In other embodiments, the second system  can include multiple outputs . Components of the shell  can be distributed among one or more nodes of a network  (see ) in any suitable manner. The shell  can include one or more gateways or control points  configured to communicate with the resources . Any suitable communication interface can be employed between the resources  and the control point , such as wired or wireless connections. The control point  can include any suitable device or system, and in some embodiments, comprises a computer.","In some embodiments, the control point  is in communication with a directory , and can be used to provide information to the directory . For example, information regarding the resources  can be provided to the directory  via the control point . The information for a particular resource  can include instructions for accessing the resource , a description of data available from the resource  (e.g., data that can be input to the shell  from the resource ), instructions for providing data to the resource  (e.g., data that can be output from the shell  to the resource ), instructions for processing data received from the resource , temporal behaviors of the resource  (e.g., real-time constraints, or actions performed over time, such as, for example, sending a message, operating a hardware device, etc.), and\/or pre-call and post-call conditions of the resource . In some embodiments, the directory  thus can provide for communication with one or more resources  that comprise stateless and\/or stateful services. In some embodiments, the directory  is an example of means for storing information regarding resources that are available to the system .","In some arrangements, the information can be entered into the directory  via the control point , such as via a computer keyboard. The control point  can include a graphical user interface, which in some arrangements includes icons and\/or forms for facilitating entry of the information by a user. In some configurations, information regarding the resources  can be entered in the directory  automatically as the resources  are placed in communication with the control point . Similarly, in some arrangements, changes to the resources  can be automatically registered in the directory .","For example, the control point  can include a universal plug and play (UPnP) database comprising specifications or other information regarding resources  capable of connection with the control point . In some embodiments, the control point  automatically populates the directory  with the specification of and\/or with other information regarding a resource  as the resource  is connected with the control point .","The UPnP database can be updated with changes to the resources , such as changes to the specifications or other information regarding the resources . For example, in some arrangements, a manufacturer of or service provider for a particular resource  can communicate with the control point  to update UPnP database, such as with a firmware upgrade for a device or sensor or a change in the input\/output parameters of an online application.","In some embodiments, specifications of the resources  are stored in the directory  in a scripting language (e.g., in one or more scripts). The scripting language can be capable of describing various information regarding the resources , such as communication parameters, call\/return parameters, real-time and\/or space constraints, and\/or descriptions regarding complex dynamic behavior of the resources , as discussed above, and in further embodiments, can specify the goals and constraints of the system , as discussed below. The scripting language can express temporal evolution, spatial relationships, communication parameters, departure from and joining of domains protected by firewalls, and\/or network topologies. The scripting language can provide sufficient expressiveness to describe models of complex physical devices (e.g., physical sensors) and services (e.g., online applications) in a heterogeneous network.","The control point  can include a compiler for converting information into the scripting language for delivery to the directory . For example, the control point  can include a UPnP database and, upon detection of a resource  for which the specification is contained in the database, can deliver the specification to the compiler for conversion to the scripting language. The control point  can then pass the scripting language version of the specification to the directory , which can store the specification. Similarly, updates made to the UPnP database can be compiled into scripting language and delivered to the directory  such that the update is included in the directory . Such updating can be automatic.","In some instances, a user may be versed in the scripting language, and can enter information in the scripting language into the directory  without using the compiler of the control point . In other instances, the user can use the graphical user interface to enter information in a format more familiar to the user, which information is then converted to the scripting language.","As discussed below, in some embodiments, the scripting language delivered to the directory  forms one or more statements. A set of such statements can constitute a scripting language record , which may include one or more fields capable of being updated. For example, the UPnP specification of a resource  stored in the directory  can comprise a scripting language record  of that resource , and in some instances, the records  can be updated via the control point  in a manner such as discussed above.","In some embodiments, the directory  stores records  that detail which resources  are interchangeable or provide similar or substantially equivalent functionalities. For example, the records  can include information indicating that two or more resources  are logically equivalent. This information can be used for fault tolerance purposes. For example, if one service  becomes inaccessible (e.g., fails or is disconnected from the system ), another service  may be used instead.","In some embodiments, the directory  contains one or more records  containing information regarding the topology of the system . The record or records  can be updated whenever the network topology changes. For example, if a node of a network were to fail or be compromised, the topology record or records  would be updated to reflect this change.","In some embodiments, the directory  stores records  for connecting the second system  with additional resources . For example, the records  can contain instructions for the control point  to connect with a supplemental resource  if one or more of the resources  fail. By way of illustration, the failed resources  can comprise, for example, online applications that provide information on a given topic without charge, and the supplemental resource  can comprise an online application that provides the same information, but which charges for the connection time during which the information is accessed. In such a scenario, the second system  may have as a goal to operate as inexpensively as possible such that the supplemental resource  is made available (e.g., a connection therewith is established) only when the free sources of information are unavailable.","The directory  can include an interface  through which it can communicate with one or more other components of the shell . For example, the directory  can communicate updates made to the records  and\/or can receive instructions and\/or updates via the interface , as further discussed below. As another example, the shell  can query the directory  through the interface . In some embodiments, the directory  can be replicated or backed up, such as for purposes of fault tolerance. Any suitable technique may be used for replication or backup, including those known in the art and those yet to be devised.","The shell  can include a model generator  configured to communicate with the directory . The model generator  can access or communicate with one or more generator records  or monitor records , which can be in the scripting language. The generator records  or monitor records  can be stored in any suitable manner. For example, the generator records  or monitor records  can be stored in one or more network nodes. In many arrangements, one or more of the generator records  or monitor records  are user-defined, and thus can be created in accordance with the goals the user may desire for the second system  to achieve and\/or limitations the user may desire for the second system  to avoid. The generator records  or monitor records  can be entered via the control point .","The generator records  or monitor records  can comprise constraints on the second system  and can describe one or more objectives of the system . In various embodiments, the generator records  or monitor records  comprise one or more of the following: context-awareness policies, such as actions to be taken in the event that a resource  obtains a specific reading; failure-handling policies, such as actions to be taken in the event that a resource  fails or is disconnected; safety or security policies or parameters, such as a description of which resources  may be accessed for use with a particular output ; distribution policies, such as the manner in which the shell  can deploy a computer-executable to a host (described below); timeliness constraints, such as the total amount of time the second system  is allowed to complete a task; goals; and\/or general constraints or requirements of the system .","In some embodiments, the generator records  are only used by the model generator , and the monitor records  are used by both the model generator  and a system monitor  (which is described below). For example, in certain embodiments, the generator records  comprise failure-handling policies and context-awareness policies, while the monitor records  comprise timeliness constraints and general application requirements. In other embodiments, the second system  does not include generator records . For example, the second system  can include only monitor records .","In further embodiments, one or more monitor-only records  are accessible only by the monitor . The monitor-only records  can be written in the scripting language and can be entered via the control point . In some embodiments, the monitor-only records  comprise user-defined security policies of the system .","The model generator  can be configured to generate a proof based on information corresponding to the resources  (e.g., information contained in the generator records ) and based on the constraints of the second system  (e.g., based on the generator records  and\/or monitor records ). For example, the model generator  can generate a model or constructive proof to determine whether the resources  are capable of satisfying the objective of the system . The constructive proof can contain instructions for using one or more of the resources  within one or more of the system constraints (e.g., in a manner consistent with the generator records  and\/or monitor records ).","In some embodiments, the model generator  comprises a deduction engine that can interpret the scripting language as theories, and can syntactically deduce the logical consequences of a set of scripts. For example, the scripts in the directory  and those in the generator records  or monitor records  can be interpreted as logical expressions or logical axioms. The deduction engine can synthesize a model from the deductions. Synthesis of the models can proceed in any suitable manner. For example, in some embodiments, a so-called Curry-Howard-style correspondence may be used in the synthesis by the model generator  to synthesize a model from a constructive proof. Other techniques for constructing such models include, without limitation, machine learning based on examples and combinatorial sketching.","As briefly mentioned, the scripts contained in the directory  can be viewed as a set of logical formulas or a set of axioms of a logical theory of available resources . Logical inferences based on such a theory can form a template for all available functionalities that can result from combining the capabilities of each available resource .","In some embodiments, to develop a model, the model generator  employs a forward-chaining natural deduction based on the axioms in the records , generator records , and\/or monitor records . For example, the model generator  can query the directory  for available services and\/or devices among the resources . From scripts returned as a result of the query, the model generator  can deduce whether the response thus received satisfies the system objective. If not, the model generator  can use the response to consult the directory  again for another resource  that will satisfy the system objective. As an end result of such a forward-chaining deduction process, the model generator  eventually develops a constructive proof by which the system objective can be satisfied, such as, for example, by triggering the output . The constructive proof can indicate that one or more of the resources  are sufficient to satisfy the system objective, and can include instructions for using the one or more resources  within one or more system constraints to satisfy the system objective. In other embodiments, the model generator  employs a backward-chaining deduction, which starts with the system objective, followed by one or more queries to the directory .","In some embodiments, the deduction is obtained from a finitely branching, finite deduction tree. The deduction tree can be built on an on-demand basis, thereby conserving space used in the deduction. Throughout the deduction, policies that are respected by the individual resources  and the constraints of the second system  can be used as constraints in the deduction steps. In such embodiments, the deduction process can be relatively inexpensive, in terms of computational resources.","The model generator  can also use information regarding the topology of the system , as obtained from the directory , to impose deployment constraints (e.g., constraints for deploying a computer-executable agent or computer-executable instructions, as described below) in the constructive proof. In some arrangements, in the event that a given record is inconsistent, whether intrinsically or with respect to the available resources , the model generator  will terminate, and will report the inconsistency. In the event that the available resources  are inadequate to implement the objective of the system , the model generator  can terminate and report the reason for the termination. Reporting of an inconsistency or termination can comprise updating one or more of the records , generator records , and monitor records .","The model generator  can automatically synthesize constructive proofs or models from the scripting language. Accordingly, the scripting language can be realizable, such that a model that satisfies the specification of a resource  can be constructed automatically from the scripting language version of the resource .","The models generated by the model generator  can be expressed as a modeling language. In some embodiments, the modeling language includes formal operational semantics and incorporates: communicating processes with external and internal actions, hierarchical group structure, group communication and logical and physical migration by processes. External actions can involve, for example, communication, logging into and out of groups, etc. Internal actions can involve, for example, invoking APIs provided by the resources . Additionally, the modeling language can communicate time constraints, space constraints, and\/or failures, and can include constructs for flow controls. In some arrangements, the modeling language can be dynamically reconfigured, as further discussed below. Such dynamic reconfiguration can involve any suitable replacement method, such as, for example, those used in object oriented paradigms. The modeling language can provide for certification of the provenance of data exchanged via the shell.","In some embodiments, models generated by the model generator  can include various advantages. For example, because some models correspond to a proof of the goals or objectives of the second system  that is deduced both from information particular to the resources  and from constraints of the system , the model can include intrinsic certification that the system objectives are met, that the system constraints are respected, and that none of the policies of the resources  are violated. In some embodiments, the model generator  is an example of means for generating a constructive proof that a subset of the resources  that are available to the second system  is sufficient to satisfy the objective of the system .","In some embodiments, a model generated by the model generator  is passed to an analyzer . The analyzer  can also accept as input one or more analyzer records  of non-functional safety properties of the system . The safety properties can include, for example, deadlock freedom, data consistency, mutual exclusion, and freedom from race conditions, etc. The analyzer records  can be user-defined, and can be entered via the control point . In some embodiments, the analyzer records  are stored in the scripting language.","The analyzer  can determine whether the model received from the model generator  is in compliance with the safety properties of the system , as set forth in the analyzer records . For example, in some embodiments, the analyzer  includes a static analyzer (e.g., a type checker), which verifies that the model is expressed in the modeling language. A static analyzer can be a combination of a model checker, a type checker, or can implement other suitable program analysis techniques including, without limitation, data flow analysis, run time analysis, and simulation, to check conformance of the generated model with safety properties, such as mutual exclusion, absence of race conditions, data consistency, etc. The model\/type checker takes as input the model and the one or more analyzer records  (e.g., the scripting language version of the specifications of the safety properties), and from these, automatically determines whether the model satisfies the specifications. The type checker automatically evaluates safety properties, such as, but not limited to, data consistency. In some embodiments, the analyzer  is an example of means for determining that a set of instructions violate a user-defined policy.","In certain embodiments, in the event that the analyzer  determines that the model does not satisfy the safety properties, the analyzer  sends a request to the model generator  for the model generator  to generate a new model in compliance with the one or more analyzer records . For example, the analyzer  can generate a counterexample in the scripting language. The counterexample is delivered to the model generator , which can produce a refined model based on the counterexample. Accordingly, the analyzer  can ensure that a model created by the model generator  satisfies the safety specifications of the system .","In some embodiments, the model is passed from the analyzer  to a compiler . The compiler  can convert the modeling language to a bytecode format in some embodiments. The compiler  thus can create a bytecode version of the model produced by the model generator  in such embodiments. In some embodiments, the compiler  compiles the model into Java bytecode.","The compiler  can deliver the converted model to a deployer , such as a distribution module. In some embodiments, the converted model includes deployment information that determines the manner in which the deployer  distributes the model. For example, in certain embodiments, one or more generator records  or monitor records  that the model generator  uses in creating a model can include distribution policies for a computer-executable agent or computer-executable set of instructions (e.g., the bytecode version of the model). These distribution policies can be included in the converted model, which is derived from the model generated by the model generator . In other embodiments, the deployer  directly accesses the one or more generator records  or monitor records  that contain the distribution policies.","The deployer  can deliver the converted model to one or more hosts  in compliance with the distribution policies. For example, in some embodiments in which the second system  comprises only two outputs , a first host  can be in communication with the first output  and a second host  can be in communication with the second output . If the second system  includes security constraints that prohibit communication between resources  used in developing a bytecode model and the first output , the deployer  will distribute the bytecode model only to the second host  (e.g., for communication with the second output ).","The deployer  can deliver a converted model to the one or more hosts  in any suitable manner. For example, in some embodiments, the deployer  communicates the converted model via wireless connections. In other embodiments, the connections are wired. Accordingly, in some embodiments, the deployer  is an example of means for communicating instructions to a host .","The one or more hosts  can be distributed among a network, and in some embodiments, each host  corresponds with a node of the network. Each host  can be in communication with one or more outputs . In some embodiments, an output  comprises the host . For example, the output  can comprise physical actuator with an inbuilt processor capable of operating as a host . A host  can comprise one or more of a machine , a driver , and a monitor . In some embodiments, the host  comprises the machine  and the driver , but the monitor  is located elsewhere within the system . Other arrangements are also possible.","The machine  can comprise an abstract machine or other suitable module for automatically receiving and running the bytecode model. For example, in some embodiments, the machine  comprises a Java virtual machine configured to run a Java bytecode model. Abstract machines in different hosts can be connected to each other through a network environment. For some embodiments, the network environment can be a group communication system (as a nonlimiting example, the SPREAD toolkit provided by Spread Concepts, LLC) or an environment such as the Parallel Virtual Machine (PVM) software tool provided by Oak Ridge National Laboratory. The machine  can have formal semantics based on the semantics of the modeling language. Prior to operation, the machines can be formally verified for properties such as no message loss, no message reorder, etc. For example, a no message loss property can ensure that messages are not lost during transmission. Retransmission techniques combined with acknowledgements can accomplish this property, in some embodiments. A property of no message reorder can ensure that messages are received by a receiver in the same order in which the sender sent them. This property can be achieved, for example, through the use of timestamps. The machine  can include APIs through which processes running on the machine  can call services. In some embodiments, a plurality of machines  can communicate with each other over a network.","In some embodiments, the machine  interacts with an output  via the driver . For example, in running the converted model, the machine  can generate instructions, signals, or other output that is sent to the driver , which delivers the instructions, signals, or other output in a format suitable for the output . In some embodiments, the output  can comprise a physical actuator that is activated when a particular set of instructions is received via the driver . In other embodiments, the output  can comprise an online application that uses information received via the driver .","In certain embodiments, the host  runs a monitor  in parallel with the machine . The monitor  can receive input from the machine  and is configured to diagnose malfunctions in the operation of the machine . The monitor  can be in communication with the directory  and\/or the model generator , and can issue one or more recovery actions if such malfunctions occur. For example, if a malfunction is detected (e.g., a process fails to verify the proof accompanying data it received), the monitor  can abort or roll back a transaction, dynamically quarantine the output  and\/or the host  from the network, and\/or dynamically quarantine one or more processes of the machine  (such as when the machine  has been compromised).","In some embodiments, the monitor  communicates with the directory  via the interface . The monitor  can be configured to detect changes made to the directory  (e.g., changes made to one or more of the records ), and in response, to dynamically modify the execution of the computer-executable model by the machine .","For example, changes to the configuration of a resource  that are registered in the directory  can be reported to the monitor . In the event of such a change, which may prevent the host  from executing the converted model in such a manner as to satisfy a system objective, the monitor  can query the directory  for a resource  that is logically equivalent to the previous configuration of the changed resource . If such a replacement resource  exists, the monitor  can dynamically reconfigure the processes running in the machine  to utilize the replacement resource. The dynamic reconfiguration can employ runtime method updates. In some embodiments, the monitor  sends a request to the model generator  to utilize the replacement resource  in place of the changed resource  and to generate and redeploy a new computer-executable model. Accordingly, in some embodiments, the monitor  is an example of means for detecting a change in a subset of resources  available to the second system  that prevents the host  from executing computer-executable instructions to satisfy the objective of the system .","In some embodiments, the monitor  is configured to diagnose that a resource  and\/or a network node has been compromised (e.g., violates the specification or policies of the resource  or the system ). The diagnosis can be based on the behavior of one or more processes in the machine . In some embodiments, the diagnosis is abductive. For example, the behavior of the resource  can be compared with the model generated by the model generator  or with the record  that corresponds to the resource . The monitor  can update the record  of a resource  to indicate that the resource  has been compromised. Additionally, the monitor  can send a request to the model generator  to utilize a replacement resource  in place of the compromised resource.","The monitor  can update a topology record  to indicate that a network node has been compromised. In certain embodiments, as a result of an update to the topology record  made during runtime of the system , the directory  provides an updated topology record  to the monitor . In response, the monitor  can dynamically redeploy one or more processes under the new topology and can update the dynamic links for proper communication between the processes. Thus, in some arrangements, the monitor  can ensure that constraints (e.g., formal guarantees) provided in the models generated by the model generator  continue to hold at runtime, even under changing network environments.","As mentioned above, in some embodiments, executable bytecode models are generated in such a way that communication of messages between executable bytecode models either running on the same host or on different hosts is accompanied by (e.g., carries with it) a proof of generation of the message. The proof describes how the message was generated. A bytecode model sends a message to another bytecode model, packaging the message with the proof of its generation. Before accepting a message, a receiving bytecode model checks the proof that accompanies the message. The proof checking is done by comparing the proof with the \u201cmodel\u201d of the sending entity. In some embodiments, the activities generating the message as recorded in the proof correspond to the capabilities as recorded in the model of the sending entity. The failure of a proof raises a flag. This mechanism is used to certify the provenance or pedigree of the data and helps in preventing generation of spurious triggers for activating resources . In further embodiments, the second system  can subsume models of multilevel security, such as, for example, so-called Bell-La Padula models. In other words, Bell-La Paluda models are a specialized example of a security models provided by embodiments of the invention, but more rigorous security models may be used.",{"@attributes":{"id":"p-0138","num":"0187"},"figref":"FIG. 3B","b":["100","100","20","40","40","160","170","170","30","100"]},"Non-limiting examples of some systems that can employ methods and architectures such as described above are now provided. These examples are provided by way of illustration, and are in no way meant to limit the disclosure herein.",{"@attributes":{"id":"p-0140","num":"0189"},"figref":"FIG. 4","b":["201","10","100","201","201","210","220","201","230","240","250","210","260","230","260","230","260","240","240","260"]},"Each of the first and second destroyers ,  has access to an API provided by a missile resource that can be invoked to fire upon intruder vessels. The missile service is exported by a central ordnance service (\u201cCOS\u201d) (not shown). On receiving the order to destroy the intruder vessel  from the command station , the first destroyer  invokes the API provided by the missile service using the location information for the intruder vessel . The outcome of the firing (success\/fail) is reported to the command station . If the first destroyer  fails to hit the intruder vessel , the command station  tasks the second destroyer  to destroy the intruder vessel.","In certain embodiments, the modeling language can be built on top of classical process calculus and provides a formal programming model for resource coordination. The syntax of one embodiment is provided below as recursive Extended Backus-Naur Form (EBNF). In this embodiment, the modeling language has operational semantics involving interactions between observable actions, communication, and silent computations. Additionally, the language can model timeouts and failures (e.g., in monadic style).",{"@attributes":{"id":"p-0143","num":"0192"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(Model)",{},{}]},{"entry":["M::=",{},{}]},{"entry":[{},"Ifp B (I)","(recursive model with an identifier)"]},{"entry":[{},"\u2003{N} M","\u2003\u2003(physical\/logical host with name)"]},{"entry":[{},"\u2003MM","\u2003\u2003(two models spatially coexisting in a distributed network)"]},{"entry":[{},"\u2003N ::=",{}]},{"entry":[{},"\u2003\u2002x","(XML namespace)"]},{"entry":[{},"\u2003\u2002n","(name from an XML namespace)"]},{"entry":[{},"(Bytecode Model)",{}]},{"entry":[{},"B::=",{}]},{"entry":[{},"(local n) B","\u2003\u2003(restriction)"]},{"entry":[{},"dead","\u2003\u2003(dead bytecode model)"]},{"entry":[{},"Bcomp B","(par. composition of bottom-level bytecode models)"]},{"entry":[{},"Id","\u2003\u2003(bytecode model identifier)"]},{"entry":[{},"Ext;B","\u2003\u2003(Observable action)"]},{"entry":[{},"Sil;B","\u2003\u2003(Silent behavior)"]},{"entry":[{},"failure(Id)","\u2003\u2003(failure module)"]},{"entry":[{},"handle(Id);B","\u2003\u2003(failure handle notation)"]},{"entry":[{},"timeout t;B","\u2003\u2003(timeout)"]},{"entry":[{},"[a(x),...;...a(x)]","\u2003\u2003(API export)"]},{"entry":[{},"Ext ::=","\u2003\u2003\u2003\u2003(observable actions)"]},{"entry":[{},"\u2003Sec","(Security)"]},{"entry":[{},"\u2003C","(Comm.)"]},{"entry":[{},"\u2003\u2002C::=","\u2003\u2003\u2003\u2003(Comm.)"]},{"entry":[{},"\u2003\u2003Ch(x)","\u2003\u2003(input)"]},{"entry":[{},"\u2003Ch<Str>","(output of string Str)"]},{"entry":[{},"\u2003mcg(C,...,C)<Str>","\u2003\u2003\u2003\u2003(group multicast of string Str)"]},{"entry":[{},"\u2003Ch::= N","\u2003\u2003\u2003\u2003(Channel)"]},{"entry":[{},"\u2003\u2002Sec ::=",{}]},{"entry":[{},"\u2003login N","\u2003\u2003(login to a logical\/physical host)"]},{"entry":[{},"\u2003logout N","\u2003\u2003(exit a boundary)"]},{"entry":[{},"\u2003Sil::=","\u2003\u2003(silent behavior)"]},{"entry":[{},"\u2003\u2002let x=S in Sil","\u2003\u2003\u2003\u2003(let reduction)"]},{"entry":[{},"\u2003\u2003if \u03b8 then B else B\u2032","\u2003\u2003\u2003\u2003(control flow)"]},{"entry":[{},"\u2003\u2003 modify(Id:\/\/a)","\u2003\u2003\u2003\u2003(reconfiguration by substituting resource)"]},{"entry":[{},"\u2003\u2003\u2003\u03b8","\u2003\u2003\u2003\u2003(constraint)"]},{"entry":[{},"\u2003\u2003fail(Id)","\u2003\u2003\u2003\u2003(failed computation)"]},{"entry":[{},"S::=",{}]},{"entry":[{},"\u2003Id:\/\/a(y)","\u2003\u2003\u2003\u2003(API exported by resource)"]},{"entry":[{},"Id:\/\/a(y)::=",{}]},{"entry":[{},"\u2003pre~post[y] ","(pre and post conditions for invoking an API)"]},{"entry":[{},"\u03b8::=",{}]},{"entry":[{},"\u2003x >=y+c",{}]},{"entry":[{},"\u2003x>y+c",{}]},{"entry":[{},"\u2003x =< y+c",{}]},{"entry":[{},"\u2003x<y+c"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"In this embodiment, a model can consist of several submodels, mutually recursive executable bytecode models (e.g., lfp is the least fixpoint), or a named logical or physical host that contains a running model inside. A recursive model can perform observable actions, exhibit silent behavior, detect and handle failures, and act as a resource exporting APIs that can be invoked by itself or other bytecode models. Observable action involves communication, logging in and out of physical and logical hosts. Silent computation takes place by calling APIs exported by resources. It can also involve failure handling and dynamic reconfiguration through substitution of one resource for another. APIs exported by resources are described by their interfaces, which include pre- and post-conditions that hold before and after invoking an API. The pre- and post-conditions can be simple type judgments (the types of the parameter passed) and arithmetic constraints. As an example, the workflow for the first destroyer  can be expressed as:\n\n","In certain embodiments, the scripting language is based on an intuitionistic mathematical logic. The language can describe both temporal and spatial evolution and has atomic constructs for describing relations among variables. The basic syntax of one embodiment is provided below as EBNFs.",{"@attributes":{"id":"p-0146","num":"0199"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["P::=",{}]},{"entry":["\u2002defun prop","(property definition)"]},{"entry":["\u2003OR(P1,P2)","(disjunction)"]},{"entry":["\u2003&&(P1,P2)","(conjunction in infix notation)"]},{"entry":["\u2003\u2192(P1,P2)","(intuitionistic implication)"]},{"entry":["\u2003~ P","(intuitionistic negation)"]},{"entry":["Finally P","(temporal evolution)"]},{"entry":["\u2003\u2003\u2003I","(variable for participant identifier)"]},{"entry":["Knows(u| Q)","\u2003(epistemic operator signifying knowledge of object)"]},{"entry":["\u2002Invoke(u|v|Q1|Q2|)","\u2003\u2003(invocation of API)"]},{"entry":["Send(u,Q)","(message send)"]},{"entry":["\u2003T","(constant true)"]},{"entry":["Exists(l,P)","(quantification over participant identifiers)"]},{"entry":["prop::=",{}]},{"entry":["\u2002ID Varlist",{}]},{"entry":["\u2002~Var Constant",{}]},{"entry":"\u2002~::=> | <| \u2266|\u2267"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In this embodiment, the scripting language includes participant identifiers standing for states and constructs for expressing communication, resource description, knowledge, etc. Services are defined in terms of their properties using the defun construct (akin to Lisp). A property can be a predicate or a constraint (i.e., an identifier followed by a list of variables). In the above, Q's denote patterns. Patterns are strings and can be regular expressions. They can characterize both bytecode models and resources. For example, \u201cKnows(u 1 Q)\u201d above denotes that the bytecode model matching the pattern Q knows the object u. A bytecode model can know an object only if it has received a communication of it. \u201cInvoke(u|v|Q1|Q2|I)\u201d describes the properties of a resource declaratively. This phrase describes an API exported by a resource to which an object u is passed as parameter, returns object v, satisfies the pattern Q1, can be invoked by a bytecode model that matches the pattern Q2, and is exported by the entity identified by I (that includes the location of the entity).","As an example, consider the first destroyer  described above. If the first destroyer  bytecode model receives an intrusion report x along with a \u201cdestroy\u201d command (i.e., comes to know of an intrusion report along with a \u201cdestroy\u201d command) the destroyer  will use that report to fire a missile in an attempt to destroy the intruder vessel  by invoking some API exported by some resource. This can be specified in the scripting language as follows:\n\n","Here, W is a placeholder since the name of the service is not yet known, nor is the entity exporting the service known. Once these items are discovered, the proper pattern, as well as the proper nominal, will be instantiated by a model generator  (not shown) of the present, illustrative example. The phrase \u201c*.input:IntrusionReport.*\u201d is a regular pattern indicating that the service accepts the type \u201cIntrusionReport\u201d as input where * describes wildcard. A substantial variety of security policies and context-awareness requirements can be specified in the scripting language. The foregoing example of one embodiment of the scripting language is provided by way of illustration, and should in no way be interpreted as limiting the disclosure as claimed.","The third system  can have coordination requirements (e.g., system constraints) such as the following, which may be stored in one or more records such as the records  described above:\n\n","These coordination requirements are referred to hereafter as \u201cCspec\u201d. In the foregoing, \u201cIntrusionReport\u201d represents a concatenation of the strings \u201cintrudervessel\u201d and the location of the intruder vessel . Additionally, \u201cmissile_response\u201d is a Boolean with values \u201csuccess\u201d and \u201cfailure\u201d. The specification Cspec states that the surveying station , or the SS \u201centity\u201d, will finally be able to obtain information about an intrusion by invoking some API exported by some resource and, if it obtains this information, will finally send it out as a message (e.g., C0). If the SS bytecode model sends a message, it should be finally received by the command station (C1). If the command station  comes to know of (i.e., receives) an intrusion report, then the command station  will finally send out a command ordering destruction of the intruding vessel (C2). If the command station  sends out a destroy command, this command will finally be heard by the first destroyer  (C3). If the first destroyer  receives a command to destroy an intruding vessel, then it will finally invoke some API exported by some resource to fire at the intruder vessel and destroy it (C4), and so on.","In this embodiment, the temporal \u201cFinally\u201d modality in the scripting language stands for branching time evolution. Additionally, the specifications are written in a possibilistic or \u201cpermissive\u201d mode. For example, in C1, because of the branching time semantics of \u201cFinally\u201d, it is only a possibility that the message will finally be received (i.e., there will exist a run in which this occurs). It is also possible that in some run the message will be lost in transit. The specification can be fashioned to deal with such situations. Workflows will be synthesized from such possibilistic specifications, thus enabling the synthesis of fault tolerant workflows. From the scripting language, the model generator  can synthesize the SS bytecode model as a model (as described hereafter).","Consider the radar service exported by the central radar agency . The service is specified by the following script:\n\n","This script is referred to hereafter as S1. Here the service is exported by the resource CRA, and provides an API Radar whose invocation does not require any formal parameter to be passed and returns the type IntrusionReport that consists of a pair that consists of the string \u201cintrudervessel\u201d and a value of type location. From Cspec, when the model generator  of the present, illustrative example encounters","Invoke(|\u201cintrudervessel\u201d, location|*input: null, output: IntrusionReport*|SS|U), the model generator  starts a subtree for natural deduction. The model generator  assumes in natural deduction style, Radar(,CRA, SS). Using S1 and the implication elimination rule, the model generator  deduces","Invoke(|\u201cintrudervessel\u201d, location|*input: null, output: IntrusionReport *|SS|CRA). Using standard the implication-introduction rule in natural deduction, the model generator  deduces\n\n","Based on this deduction the model generator  constructs the model for the surveying station  as\n\n","The basic deduction is conducted as a forward-chaining procedure, and whenever a goal involving an \u201cInvoke\u201d construct is encountered a companion proof tree is developed to discover the proper service. This companion deduction can be viewed as computing a logical interpolant. After the implication introduction, the assumption is discharged. The deduction, as well as the synthesis of bytecode models, can be carried out entirely automatically and can be implemented in software. From C0, the model generator  deduces \u201cSend(\u201cintrudervessel\u201d, location, SS)\u201d. From this and C1, the model generator  deduces \u201cKnows(x|COMMAND)\u201d. From these two deductions, the model generator  refines the model for SS as \u201clfp SS=let y=CRA:\/\/Radar( ) in Command<y>; . . . \u201d. In addition the model generator  constructs the COMMAND bytecode model as","\u201clfp COMMAND=Command(y); . . . \u201d Here, \u201cCommand\u201d is a new channel. In this manner the model generator  continues the deduction and simultaneously synthesizes bytecode models until no additional new facts are produced.","The formal operational semantics of a machine  (not shown) of the present, illustrative example can be implemented in software. An example of the semantics are declaratively provided below. In the following it is assumed that \u250c is an environment and that \u250c\/I denotes the restriction of \u250c to the bytecode model identified by the identifier I. In some embodiments, the environment can be implemented through a group communication system or a messaging platform like PVM.",{"@attributes":{"id":"p-0161","num":"0224"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u250c\/I\u2032 \u251c I:\/\/a= pre~post[x] \u2003\u2003\u2003\u2003\u2003\u2003\u2003(Serv inv. 1)"},{"entry":"\u250c\/I\u2032 \u251c I:\/\/a(y) \u2192 pre~post[y\/x]"},{"entry":"\u250c\/I\u2032 N \u251c pre[y\/x] \u2192true \u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(Serv inv. 2)"},{"entry":"\u250c\/I\u2032 \u251c pre~post[y\/x]\u2192 post[y\/x]"},{"entry":"\u250c\/I\u2032 \u251c Complete(x) \u250c\/I\u2032 \u251c val x = t \/I\u2032 \u251c post ::= (\u03c3[x]"},{"entry":"p[x]) x (\u250c\/I\u2032 \u251c\u25a1N \u251c (\u03c3[x] p[x]) [t\/x])\u2003\u2003\u2003(Serv.inv fail)"},{"entry":"\u250c\u222a {fail(I)} \u251c post \u2192false"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The first rule (Serv. inv. 1) states that before a service invocation, the preconditions of the service are evaluated. The second rule (Serv inv. 2) states that service invocation proceeds if the pre-condition evaluates to true (true and false are constants). The third rule (Serv. inv. fail) describes the manner in which the failure of a service is registered by the environment. If the \u201cComplete\u201d predicate of the environment (which registers when a service invocation is completed) is true, the resulting value does not satisfy the post condition. As a result, it is registered that the resource exporting the API ahas failed. This information will be used for failure handling by other bytecode models. For example, as illustrated by the rule below, the bytecode model failure(Id) is executed whenever any other bytecode model I\u2032 makes reference to handier(I):",{"@attributes":{"id":"p-0163","num":"0226"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mfrac":{"mrow":[{"mo":"\u2308","mrow":{"mo":"\u22a2","mrow":{"mrow":[{"mi":"fail","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"ld"}},{"mo":["(","\u2062","\u2062",")"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mrow":{"mi":["failure","composition"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}],"mo":"\u2062"}}},{"mo":"\u2308","mrow":{"mrow":[{"mo":"\/","mrow":{"msup":{"mo":"\u2758","mi":"\u2032"},"mo":"\u2062","mrow":{"mo":"\u22a2","mrow":{"mi":"handle","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"ld"}}}}},{"mi":"P","mo":"\u2192","mrow":{"mi":"failure","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mrow":{"mo":["(",")"],"mi":"ld"}}}],"mo":";"}}]}},{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}]}}}}},"Wireless sensor networks can be advantageously employed in a wide variety of applications. Some wireless devices (which can also be referred to as \u201cmotes\u201d) that are capable of collecting data from a sensor and relaying that data wirelessly throughout a network via any suitable method can allow for autonomous collection and processing of environmental conditions over a given area. Certain of such motes can communicate via radio frequency (\u201cRF\u201d) transmissions, and may communicate with other motes in the network.",{"@attributes":{"id":"p-0165","num":"0228"},"figref":"FIG. 5","b":["300","10","100","201","300","300","300"]},"In certain embodiments, the fourth system  includes one or more sensors  that are physically distributed throughout the landscaped property. The sensors  can be buried underground or otherwise situated as desired. In some embodiments, the sensors  are in communication with one or more access points , each of which can comprise one or more motes. Accordingly, the access points  may also be referred to hereafter as motes. In some embodiments, the access points  are in communication with one or more control stations , each of which, in turn, can be in communication with one or more master nodes  of a distributed network.","With reference to , in certain embodiments, one or more of the sensors  are configured to transmit data using magnetic induction (\u201cMI\u201d) transmissions. MI transmission can be particularly advantageous in underground environments or other environments which can significantly attenuate and\/or substantially block RF transmissions. For example, in comparison to RF transmission, MI transmission can be relatively unaffected by the medium through which it propagates (e.g., air, water, soil, rock, etc.).","In some embodiments, a sensor  comprises one or more sensing elements , such as, for example, a soil moisture probe. The sensing element  can be in communication with a transmitter . The transmitter  can receive information regarding a physical property of the soil, such as the moisture content of the soil, from the sensing element , and can transmit this information by MI transmission via a ferromagnetic coil . For example, the transmitter  can cause a signal of current to flow within the coil  in a manner that represents the information to be transmitted, which can generate a time-varying magnetic field.","With reference to , in some embodiments, one of more of the sensors  comprises a receiving unit . For example, in some arrangements, one or more sensors  are configured to both send and receive MI signals, and can communicate with each other.","The receiving unit  can comprise a coil . When a signal in the form of a time-varying magnetic field is incident on the coil, a corresponding voltage can be induced. The receiving unit  can further comprise a receiver  for detecting the signal. For example, the receiving unit  can detect varied flow of current through the coil that may result from the induced voltage.","In some embodiments the receiving unit  includes a data management unit  in communication with the receiver . The data management unit  can be configured to store, convert, manipulate, or otherwise use information received from the receiver . For example, the data management unit  can include an LCD panel for displaying information regarding the transmitted information, an RF transmitter for relaying the information, a data logger for storing the information and\/or some other suitable device. In some embodiments, the data management unit  can be in communication with the transmitter  (see ) of a sensor , and can instruct the transmitter to send information to an access point , as further described below.","With reference again to , in certain embodiments, one or more sensors  each may communicate directly with an access point  via MI transmission, as illustrated by the leftmost grouping of sensors  and the leftmost access point . In other embodiments, one or more sensors  may be distanced sufficiently far from the access point  to substantially prevent effective direct communication between some of the sensors  due to a relatively small transmission range of the transmitters . In certain of such embodiments, a first sensor  may transmit data to a nearby second sensor , which in turn may transmit the received data (along with additional data that it has gathered, in some instances) to yet a third sensor  which is out of the range of the first sensor . The third sensor  may then transmit data received from the other sensors  and\/or data it has gathered to an access point . An example of such a relay of sensors  is illustrated in the middle grouping of sensors  in , which are shown as communicating with the middle access point  via a single sensor . In various embodiments, the fourth system  can include hundreds, thousands, or even millions of sensors .","In some embodiments, the sensors  form a wireless network that employs only MI transmission. However, in other embodiments, the wireless network can use other suitable communication mechanisms instead of or in addition to MI transmission.","With reference to , in certain embodiments, an access point  can comprise a receiver  such as described above, and thus can receive signals transmitted by one or more sensors . The receiver  can further include a smart card  or any other suitable computing element in communication with the receiver .","The smart card  can further be in communication with (e.g., can transmit information to and\/or receive information from) a secondary communication device, such as a transceiver , that is configured to permit communication between the access point  and one or more additional elements of the fourth system . For example, in some embodiments, the access point  is configured to communicate with one or more other access points , one or more control stations , and\/or one or more master nodes  via the transceiver  (see ). In some embodiments, infrared transceivers, cables, wires, or other suitable communication media are used instead of or in addition to the transceiver .","With reference again to , in some embodiments, one or more of the access points  are positioned at or above ground level and are capable of communicating with one or more sensors  that are positioned underground. For example, each access point  may be in communication with a specific subset of sensors . The access points  can receive information from the sensors  and can communicate that information and\/or additional information to one or more access points , control stations , and\/or master nodes . In some embodiments, one or more access points  may be arranged in a relay such that a subset of access points  communicates with each other and a single access point  of the subset communicates with a control station  and\/or a master node .","The control stations  can assimilate and manage information received from the access points , which may be used in decision making, data logging, or other desired tasks. The master nodes  can receive data from the control stations  and can make decisions on or otherwise utilize the data thus received.","Any other suitable arrangement is also possible. For example, in some embodiments, the access points  can communicate directly with the master nodes, thereby eliminating the control stations . In other embodiments, the network can comprise only sensors  and access points . For example, the access points  can include networking software and can serve as network nodes. In still other embodiments, layers in addition to those shown in  can be used. For example, devices may be inserted to communicate between the access points  and the control stations . Any suitable combination of the master nodes , control stations , access points , and\/or sensors  can be positioned above or below ground or water, or may be suspended in air in any suitable manner (e.g., may be positioned on a pole, in an aircraft, etc.).","As illustrated by the arrows , the system  can include a much larger number of nodes , control stations , access points , and\/or sensors  than those shown. A hybrid of communication techniques may also be used to connect any element in the network. For example, some sensors  may communicate via MI transmission, while others may use cable, RF, infrared, or other technologies. Similarly, the nodes , control stations , and\/or access points  can use any suitable combination of such technologies to communicate.","The fourth system  can include one or more shells  (not shown in ) such as described above in any suitable number and\/or distribution. For example, in some embodiments, one or more nodes  and\/or control stations  include one or more directories , model generators , analyzers , compilers , and\/or deployers . In some embodiments, each access point  comprises a host . For example, the smart card  of a sensor  (see ) can serve as a host  on which a converted model can be executed. Other elements of the fourth system  can also serve as hosts , including the nodes  and\/or the control stations .","The sensors  can comprise resources  that are available to the fourth system . In some embodiments, the fourth system  utilizes information gathered from the sensors  to determine whether to actuate sprinklers via an output device  (not shown in ), such as, for example, any suitable actuator such as one or more valves comprising solenoids.","In certain embodiments, the smart card  (see ), which can be running a set of computer-executable instructions issued by a deployer , can receive information regarding the operational status of a sensor  and\/or data regarding the moisture content of the soil from the sensor  via the receiver . This information and data can be delivered via the transceiver  to the appropriate location or locations (e.g., to one or more nodes  and\/or control stations ) within the distributed network of the fourth system  to update a directory , which can comprise a record  for the sensor . If the information received from the sensor  is sufficient to provide a trigger, in some embodiments a node  may actuate an output device  to turn on the sprinkling system.","In some embodiments, the smart card  comprises a Java Smart Card that comprises a Java virtual machine. Java Smart Cards can permit small Java-based applications to run securely on them by incorporating Java kilobyte virtual machines. A smart card can contain an embedded device (i.e., a microcontroller) that provides a user with the ability to program the card and assign specific tasks to occur as a result of given events. The computer-executable instructions thus can be issued in the form of Java bytecode that can run securely on top of the Java virtual machine.","In some embodiments, the smart card  is placed in communication with the receiver  via a serial I\/O. The smart card can comprise a controller that includes electrical contacts that are connected to an output port of the receiver . A Java applet or application downloaded to the microcontroller can process incoming signals and can act accordingly by initiating commands to send data regarding the received signal to the transceiver . The data can be securely protected through an applet firewall that restricts and checks access of data elements from one applet to another.","By employing a control shell  such as described above, the fourth system  can include a scalable intelligent software-based coordination infrastructure. Distributed intelligent agents (e.g., instructions distributed by a model generator  and converted by a compiler ) can use data from the sensors  and user-defined system management policies to generate real-time control of the fourth system . In some embodiments, the control decisions are delivered to appropriate personnel for manual intervention. For example, the decision can be delivered to a control point  comprising a graphical user interface via which a user can provide commands to the fourth system . In other embodiments, the decisions are made without manual intervention, and are delivered directly to an output device . The shell  can provide for intelligent monitoring and control of soil properties. As discussed, the shell  can include a software tool that provides policy-based, on-demand coordination of the fourth system , which can be an irrigation system. Other aspects and advantages of embodiments of the fourth system  will also be apparent to those of skill in the art from the disclosure herein.","In certain embodiments, access points  comprising Java Smart Cards, which can interpret data through bytecodes, can consume less power than known motes. Such access points  can also be relatively smaller and much cheaper than known mote devices, in some instances. For example, the cost of manufacturing some arrangements can be only slightly over 10% the cost of manufacturing known mote devices. Furthermore, unlike certain embodiments disclosed above, known motes are not configured to communicate with MI transmission devices, nor are they configured to communicate with a large number (e.g., thousands or millions) of sensors that are intelligently interconnected via dynamically changeable software, such as that provided by control shells .","Embodiments of the fourth system  can be employed in a variety of contexts. For example, in some embodiments, the fourth system  can comprise an underground network of soil moisture sensors which may be fully buried (e.g., no cables or protrusions extending to the surface). Such a network could be used in agriculture to control irrigation. In some embodiments, the fourth system  can comprise an underground network of pressure, vibration, movement, audio, and\/or other sensors that could be a valuable defensive and monitoring system for military use. In other embodiments, the system can comprise an underwater network of sensors for monitoring water properties, such as temperature, quality, or quantity, plant or animal life and conditions, or a variety of other underwater applications. In some embodiments, the fourth system  can comprise a network of implanted biomedical sensors configured to coordinate the acquisition of certain vital signs or biological conditions of a patient. Such a network configuration can allow one sensor which detects a certain problem, such as a high fever or a heart condition, for example, to request other sensors to acquire relevant data immediately to assist in problem solving decision making. In other embodiments, the system can comprise a network through any medium in which short range communication is desirable. For example, a personal digital assistant, watch, cell phone, laptop, and personal computer can all synchronize to each other if within transmission range.","Various embodiments of first system , second system , third system , and fourth system  and\/or golf course watering system  include one or more advantageous features, such as the following. Certain embodiments provide for the reliable satisfaction of the goals (e.g., business goals) of a user, ensure that the quality of service constraints of the user are respected, and ensure that none of the policies imposed by individual services and devices of a system, nor those imposed by the system, are violated, even under rapidly changing environments, and some systems ensure that non-functional safety constraints of the system are satisfied. Certain of such embodiments can be particularly suited for deployment in mission-critical applications, such as patient monitoring or building security.","Some embodiments incorporate expressive yet tractable languages to describe models of complex heterogeneous physical devices, such as actuators or sensors. Some embodiments permit automatic synthesis of workflows from declarative specifications of the business logic and quality of service goals of a system and from models of available devices and services. Further embodiments provide models that are created and implemented in a manner that provides security features and that meets the quality of service goals of a system. Certain embodiments provide a mechanism for certifying the provenance of data exchanged between processes and prevent generation of spurious triggers for activating services and\/or devices of a networked system.","Some embodiments provide for automatic and controlled deployment and running of bytecode models or computer-executable instructions obtained from constructive proofs. The bytecode models can be generated automatically from user-defined system constraints such that the system functions substantially autonomously and without any or without extensive software development by the user. Some embodiments provide for readily deployable systems that can be easily adapted to meet the system goals of a user. Further embodiments permit reconfiguration of a workflow at runtime, which reconfiguration can include substituting new services and\/or devices for existing ones and\/or can provide new functionalities in response to changing requirements of or changing resource availabilities to a system, even when such conditions change rapidly.","Some systems can be easily reconfigured, such as when a user wishes for the system to conform to new or different policies. In some embodiments, the user can readily enter these policy changes via a control point . Some systems can also be rapidly deployable, such that the system can begin operation soon after policies, goals, and system objectives are created.","Various embodiments may be advantageously employed in numerous contexts, such as those for which intelligent and\/or reliable service coordination is important. For example, embodiments may be used for: generating mashup engines for intelligent location tracking and mapping; soil and water management and irrigation control for agricultural and environmental applications; intelligent distributed power control, such as control of a power grid; home entertainment and security; distributed intelligent control of Internet-based appliances; distributed robot control; intelligent control of manufacturing plants and inventory management; reliable and smart emergency management applications; on-line, flexible assembly of operationally responsive spacecrafts; intelligent and reliable control of guided missiles; tracking and monitoring for homeland security; cognitive antennas, including multiple input\/multiple output (MIMO) systems that use numerous antennas to optimize communication; cognitive radars; cognitive radios; automatic hospital management and\/or monitoring of the delivery of therapeutic drugs; and automated distributed fermentation control, as well as modulation of cellular metabolism. Other applications are also contemplated.","With reference to , in certain embodiments, a host  further comprises a machine  and a data store , said data store  providing GAS access.  depicts three hosts  as , , and (each host  having a communication system  and a logic process , showing that each data store  and each communication system  is capable of multi-instance distributed operation). The data store  may be a distributed key-value store or other DHT and may also be referred to as a distributed database. Data store  contains one or more data records . The directory  may be part of the data store , but the directory  may also be separate. In addition, the records  stored in the directory  may be data records . Generator records , monitor records , monitor-only records , and analyzer records  may be data records . The host  contains an operating system such as Ubuntu brand GNU\/Linux. Machine  may be an abstract machine such as a Java virtual machine (JVM) or Machine  may be resources provided by the operating system on host . Machine  monitors and controls the execution and thread-level synchronization of control process , logic process , and evaluating process . Control process  contains control loop  (). Logic process  contains logic loop  (). Data store  contains network model , testing module , and learning module  () as well as learning process  (). Control process , logic process , and evaluating process  may be implemented as Java threads or via another multiprocess or concurrent execution system as may be provided by machine . Logic process  may be a converted model as prepared by model generator , analyzer , and compiler . Control process , logic process , and evaluating process  communicate with communication system  (as such, it is understood that communication system  is capable of multi-instance distributed operation). Communication system  communicates with (interfaces with) data store . Control process  and logic process  communicate with (interface with) data store . Control process  and logic process  may communicate with (interface with) the data store  on the host wherein control process  and logic process  reside, or they may communicate with (interface with) the data store  on another process.  depicts communication of logic process  on host with the data store  on host . Logic process  may direct a driver  to control an output . Logic process  may also be a control point , may receive information from an input , and may communicate information to (interface with) communication system  or data store . In certain embodiments, deployer  may send information to host , and in particular to a data store  on host . Control process  retrieves information from data store  sent by deployer . Although  only shows one control process  on each machine , it is understood that each machine  may contain any number of control processes . Host depicts a host  and a machine  containing two logic processes . However, each machine  may contain any number of control processes  and any number of logic processes . In addition, a logic process  may communicate with more many outputs  (via one or more drivers ) and with many inputs  (via one or more control points ). As illustrated, components contained within a host  communicate with components contained within another host  via network .",{"@attributes":{"id":"p-0194","num":"0257"},"figref":"FIG. 10","b":["500","410","160","400","500","180","510","410","430","400","410","160","520","410","510","410","420","180","420","510","410","180","530","410","510","410","420","410","420","410","420","420","410","420","400","420","540","410","420","420","410","180","420","180","420","180","550","410","180","410","180","410","500","510","550","550","410","420","420","410","550","550"]},{"@attributes":{"id":"p-0195","num":"0258"},"figref":"FIG. 11","b":["600","420","400","600","410","420","600","601","605","610","620","650","660","680","620","180","621","621","630","640"]},"In message-retrieving step , logic process  accesses information transmitted by control process . Said information may be stored in logic process  or it may be stored in data store . It is understood that any number of inter-process communication techniques may be used to accomplish transmittal of information from control process  to logic process  or from logic process  to control process . After completing message-retrieving step , logic process  proceeds to deactivating step .","In deactivating step , logic process  analyzes information accessed in message-retrieving step . If said information indicates that control process  has instructed logic process  to terminate, logic process  records that it has received a termination instruction and proceeds to acting step . If said information does not indicate that control process  has instructed logic process  to terminate, logic process  proceeds to reading step .","In reading step , logic process  attempts to retrieve one or more data records  from data store . If a requested record is available, logic process  proceeds to delegating step . If a requested record is not available, logic process  proceeds to sleeping step .","In sleeping step , logic process  stops execution for a predetermined amount of time, such as, for example, 100 milliseconds. During this period of time, machine  does not execute logic process . When the predetermined amount of time has expired, machine  resumes execution of logic process  and continues logic loop  by proceeding to message-retrieving step . It is understood that sleeping step  is accomplished by using the Sleep function provided by the Java programming language; however, as described elsewhere herein, any suitable concurrent programming technique may be used to accomplish this step. In addition, in certain embodiments, sleeping step  may be omitted.","In delegating step , logic process  causes machine  to begin execution of evaluating process . Logic process  also records information associated with evaluating process  for use in acting step . In certain embodiments, delegating step  provides information available from logic process  or from data store  to evaluating process . After performing delegating step , logic process  proceeds to acting step .","Evaluating process  operates concurrently with logic process  and control process , and in certain embodiments, delegating step  causes a new Java thread to begin execution in machine . However, it is understood that evaluating process  may operate using any technology that may be used by logic process  or control process . As may be appreciated, evaluating process  may not be complete when logic loop  returns to delegating step  and thereby delegates another evaluating process. In such a situation, multiple evaluating processes  may be executing concurrently, thereby taking advantage of resources provided by host  which allow for concurrent execution of instructions. It is understood that host  may include multiple microprocessors or microprocessors containing multiple physical or logical cores. The one or more concurrently executing evaluating processes  may utilize the resources which may be provided by host  for concurrent execution of instructions.","It is understood that information available to evaluating process  and logic process  from data store  may have been acquired from one or more inputs  or may have been synthesized by one or more evaluating processes  delegated by one or more logic processes  on one or more hosts .","In evaluating step , evaluating process  analyzes information from data store  according to instructions created and provided by model generator , analyzer , and compiler . The instructions may be in the form of bytecode or other machine executable object code. In certain embodiments, evaluating step  executes a purely functional method. It is understood in the art that a purely functional method causes no change in program state, and merely returns a value based on evaluating a series of logical instructions and mathematical calculations.","In storing step , evaluating process  may communicate information synthesized in evaluating step  to logic process . After completion of storing step , evaluating process  terminates.","In acting step , logic process  controls one or more outputs  via driver . Also, logic process  stores information in data store  that has been synthesized by evaluating process  subsequent to any previous executions of acting step  by logic process .","After completion of acting step , logic process  determines whether to proceed to message-retrieving step  or to terminating step . If logic process  has recorded that it has received a termination instruction, then logic process  proceeds to terminating step . Otherwise, logic process  proceeds to message-retrieving step .","In terminating step , logic process  communicates with control process  the fact that logic process  has completed termination. Logic process  then ceases execution.","As may be observed, logic process  does not perform sleeping step  after acting step . Sleeping step  may be skipped. We think that it is better to perform sleeping step  when temporarily ceasing execution achieves an efficiency, such as where no information is available to logic process  in reading step . However, it is understood that certain embodiments of the invention may reorder steps in logic loop .","In the embodiment described in , evaluating step  and storing step  are performed in parallel to logic loop . However, it is understood that evaluating step  and storing step  may be performed as steps in logic loop .","In certain embodiments, some of the steps in logic loop  steps may be performed in parallel, or not as part of, logic loop . For example, reading step , delegating step , and acting step  may be performed as a non-repeating process in addition to or as an alternative to being performed as part of logic loop . It is understood that in certain embodiments, reading step , delegating step , and acting step  may be implemented such that they can be executed by machine  either in a thread containing other steps in logic loop  or in a thread containing only reading step , delegating step , and acting step .","As may be observed, where logic process  implements logic loop  and includes sleeping step , the amount of time that logic process  spends in sleeping step  influences resource utilization of host  and also influences the reaction time of logic process . For example, during sleeping step , resources of host  are not used by logic process , and machine  may execute instructions from other processes on host , such as control process  or evaluating process . This allows, for example, machine  to complete evaluating process  more quickly and leads to more efficient utilization of resources. On the other hand, when the time spent in sleeping step  is long, logic process  may execute reading step  a significant amount of time after data store  on any host  receives updated information. For example, if logic process  spends 100 milliseconds in sleeping step  and data store  receives updated information twenty milliseconds after logic process  enters sleeping step , then logic process  will not receive the updated information until at least eighty milliseconds after it is received by data store .","Certain embodiments achieve greater efficiency and increased reaction time by configuring data store  to communicate with, or trigger, logic process  on or by the existence of newly arrived information. In such an embodiment, when data store  receives updated information that logic process  should receive, data store  attempts to communicate with logic process  to indicate that logic process  should retrieve information from data store . In addition, in these embodiments, reading step , delegating step , and acting step  are executed by machine  in a separate process that is not part of logic loop .","In certain embodiments, the attempt by data store  to communicate with logic process  may fail (as a nonlimiting example, because resource use of host  is too high), and logic process  will eventually retrieve the newly updated information from data store  via reading step  in logic loop .","As shown in , data store  on one host  may communicate with logic process  on another host . In certain embodiments, such triggering may be from a data store  on one host  to a logic process  on another host , either in addition to, or instead of, triggering from a data store  on the same host as the triggered logic process .",{"@attributes":{"id":"p-0215","num":"0278"},"figref":["FIG. 12","FIG. 14A","FIG. 14"],"b":["400","400","400","170","400","400","400","950","960","970","900","400","400","60","400","430","430","720","730","711","721","731","712","722","732","713","723","733","714","724","734","730","730","720","400","430","720"],"i":["a ","b ","a ","b "]},"The data stores  are configured such that when a data record  (a key value pair) is added or deleted, or when a value  in a data record  is altered, the data stores  make the updated information available on all of the data stores . In certain embodiments, information is made available on all of the data stores  by containing all information in one or more data records  stored locally on each data store . As illustrated in , first record  corresponds with third record  and second record  corresponds with fourth record . Accordingly, first key  and third key  contain the same information; and second key  and fourth key  contain the same information. So, if a process updates first record  by changing first value  associated with first key , then data store communicates via network  with data store , and data store updates its corresponding third value  associated with third key  to match first value . The process may work in either direction. So, if a process updates fourth record  by changing fourth value  associated with fourth key , then data store communicates via network  with data store , and data store updates its corresponding second value  associated with second key  to match second value . Although  shows two data stores , any number of data stores  may be used. By making information available on each data store , use of a global address space (such as a distributed database or a distributed key-value store) allows said information to be available to processes such as logic process  contained on the same host  as data store  in the event that host  becomes temporarily disconnected from network . As explained more fully in the description of , the addition of a communication system  and a data store  to shell  improves shell  by allowing shell  to operate in unreliable network environments.",{"@attributes":{"id":"p-0217","num":"0280"},"figref":["FIG. 13","FIG. 14A","FIG. 14","FIG. 13","FIG. 13"],"b":["400","800","400","170","400","400","60","400","400","400","400","430","950","960","970","900","800","800","400","400","400","400","400","800","400","400","400","400","400","400","63","400","400","64","400","400","65","400","400","66","63","64","65","66","60","63","64","65","66","400","430","430","400","400","400","63","400","400","400","430","400","400","64","400","430","400","65","400","400","400","66"],"i":["a","b","c","d ","a","b","c","d ","a ","b ","b ","c ","c ","d ","d ","a ","a","a ","b ","b ","b","b ","b ","c ","c ","d ","d ","a "]},"In certain situations, embodiments of the invention may experience periods of high usage. In such a situation, it can be advantageous to configure data stores  configured into ring  to determine when resource use is high, and, when said resource use is high, temporarily refrain from communicating with other data stores . Accordingly, in certain embodiments, each data store  tests its host  and network  conditions before sending information (for example, information updating a data record ) to another data store  in ring . By reducing network  and host  resource use during periods of high usage, this improvement enhances the performance and scalability of ring , and as a result, improves the performance or reduces the resource requirements necessary for any host  that is part of an embodiment of the invention.",{"@attributes":{"id":"p-0219","num":"0282"},"figref":["FIG. 13","FIG. 13"],"b":["400","400","400","400","950","960","970","400","400","400","400","400","960","170","60","800","961","400","800","960","400","961","400","65","60","400","400","430","400","400","961","400","961","400","800","961","400","400","800","961","400"],"i":["a","b","c","d ","a","b","c","d ","c ","d "]},"In certain embodiments, before a data store  transmits a test packet  it has received to the next data store  in ring , the data store  will measure the resource utilization of the host  on which data store  resides and record said resource utilization in the test packet . In this manner, if the test packet  returns to the data store  which originated the test, said data store  will receive a measurement of the current resource utilization for each data store  in ring . The resource utilization measurement may be the Unix-style load average, but it is understood that any similar type of measurement may be used. As each test packet  returns to the data store  which originated the test, said data store  measures the time taken by that test packet  to traverse ring . Said data store  which originated the test also records the total number of returning test packets  for the current network test.","Once all the test packets  have returned or data store  determines that any unreturned test packets  will not return, then data store  evaluates whether the resource utilization is too high to send information to the next data store in ring . If resource use is too high, data store  will wait for a preconfigured amount of time (as a nonlimiting example, 100 milliseconds) before attempting another test. In certain embodiments, data store  determines whether overall resource use is too high by measuring (1) the total time it takes for each test packet  to return to the originating data store ; (2) how many test packets  return to the originating data store ; and (3) the measured resource utilization as measured by each data store  and recorded in each test packet .","In certain embodiments, testing module  may use learning module  and network model  to predict future overall resource utilization. Thus, in certain embodiments, the measurements of overall resource use described herein are recorded in network model  and used by data store  to determine whether to send information to the next data store  in ring .","In certain embodiments, learning module  uses learning process , testing module , and network model  to predict future overall resource utilization and to determine whether to send information to the next data store in ring .",{"@attributes":{"id":"p-0224","num":"0287"},"figref":"FIG. 14","b":["900","400","970","950","960","950","900","970","900","910","960","920","970","950","960","910","930","400","970","920","400","950","930","940","970","950","970","900","950","940"]},"Because we speculate that a ring  performs better when a ring  is comprised of no more than eighty data stores , certain embodiments of the invention overcome this limitation by configuring into multiple communications rings, or multirings. As can be observed, this embodiment reduces the time required to transmit a message to each data store  in the network. An embodiment of such a configuration is illustrated in .",{"@attributes":{"id":"p-0226","num":"0289"},"figref":["FIG. 15","FIG. 15"],"b":["400","800","810","820","800","830","810","400","400","400","400","820","400","400","400","400","400","400","400","400","63","400","400","64","400","400","65","400","400","66","400","400","67","400","400","68","400","400","69","63","64","65","66","67","68","69","60","63","64","65","66","67","68","69"],"i":["a","b","c","d","c","e","f","a","f ","a ","b ","b ","c ","c ","d ","d ","a ","c ","e ","e ","f ","f ","c "]},"Information may be received by a logic process  or synthesized by an evaluating process . Either logic process  or evaluating process  may directly access a data store , and either may indirectly access a data store  via a communication system  (further demonstrating the multi-instance distributed operation of communication system  and data store ). When either a logic process  or an evaluating process  accesses a data store  in such a fashion that alters one or more data records  contained in data store , said data store  may communicate that change to a data record  throughout multiring . The process by which data records  are updated is described more fully in connection with . As described in the following paragraph, a change may occur first on data store , but a change may occur first on any data store .","If a change occurs first on data store , data store begins the process by sending information to data store via first connection . In turn, data store sends said information to data store via second connection . Data store then sends said information to data store via third connection  and to data store via fifth connection . Data store then sends, via fourth connection , confirming information to data store that all data stores  in first ring  have received the information. After data store receives the information, data store sends said information to data store via sixth connection . Data store then sends, via seventh connection , confirming information to data store that all data stores  in second ring  have received the information. In this fashion, a data store  can send information to each other data store  in multiring .","In certain embodiments, data stores  may be configured to form multiring  and may perform the network testing and load prediction techniques described herein.","In certain embodiments, the data stores  are configured to automatically assemble into rings  forming multiring . In such an embodiment, data stores , , , and join first ring  until a predetermined maximum number of data stores  join first ring .  implies that the maximum number is 4, but any number may be used. After a first ring  contains the maximum number of data stores , the next data store  to attempt to join multiring  forms a second ring  containing the newly joining data store  and one data store  that is contained in a first ring . As shown by , when data store attempts to join multiring , data store creates second ring  containing only data stores and . Data store , or any data store creating a new ring , may use any suitable selection technique for selecting which preexisting data store to choose. After second ring  is created, newly joining data stores  join second ring . As shown by , when data store attempts to join multiring , data store joins second ring . In this process, first ring  is a so-called first level ring, and second ring  is a so-called second level ring. New data stores  may join multiring  until each data store  in a first level ring is also a member of a second level ring. Then, when new data stores  attempt to join multiring , a new ring  is created containing only the new data store  and a data store  contained in a second level ring, thereby creating a third level ring. This process may be repeated ad infinatum, as permitted by available host and network resources.","As used herein, the term \u201csupernode\u201d means a data store  that is a member of more than one ring (for example, by being a member of a first level ring and a second level ring). As an example, data store in  is a supernode.","It is understood that supernodes must use more resources than non-supernodes to communicate information to other data stores . This is shown, for example, in , whereby data store must send information to both data store and data store . It is also understood that a data store  may run on a host  along with other processes described herein as running on a host . Different hosts  may be configured to have different resources available. For example, some hosts  may have faster or a greater number of processors, more memory, or may be connected to higher speed or less congested portions of network . Alternatively, the processes running on some hosts  may require more system resources than the processes running on other hosts . Therefore, it is desirable to reconfigure multiring  such that multiring  does not necessitate that a host  with low available resources be a supernode.","Certain embodiments automatically detect underutilized and overutilized hosts  and reconfigure multiring  to make underutilized hosts  supernodes and to make overutilized hosts  which are supernodes not act as supernodes.","Using  as an example, if data store is overutilized and data store is underutilized, multiring  may swap data store and data store . In this process, data store becomes a member of ring . Then, data store becomes a member of ring  and is removed from ring . By this process, data store becomes a supernode.","Although  shows two rings , any number of rings  may be used, and each ring  may contain any number of data stores . However, we speculate that the performance of ring  is better if a ring  contains not more than eighty data stores .",{"@attributes":{"id":"p-0236","num":"0299"},"figref":["FIG. 16A","FIG. 16B"],"b":["420","400","440","420","440","440","420","400","440","420","400","971","972","971","972","430","770"]},{"@attributes":{"id":"p-0237","num":"0300"},"figref":["FIG. 16B","FIG. 16B"],"b":["420","400","440","420","440","1010","1120","430","400","971","972","430","170","420","440","420","420","440","400","400","440","420","1010","1120","420"]},"In joining step , logic process  joins a group. In certain embodiments, each group has a name, a list of members, a list of readers, and a list of changemakers (members which have requested addition to or removal from the group). These attributes are stored by communication system  in data store  in group record  (). Group record  stores information which represents whether the group membership has changed. Group state may be \u201cstable\u201d or \u201cunstable.\u201d When a logic process  requests to join a group, communication system  adds logic process  to a list containing group membership information\u2014the list of members. Communication system  also adds logic process  to a list of changemakers, sets the group state to be unstable, and removes all entries from the list of readers.","In leaving step , logic process  leaves a group. When a logic process  requests to leave a group, communication system  updates group record  () to remove logic process  from the list containing group membership information in group record . Communication system  also updates record  by adding logic process  to a list of changemakers, setting the group state to be unstable, and removing all entries from the list of readers.","In group state reading step , logic process  requests the current state of the group from communication system , which retrieves information related to the group from group record  () stored in data store . After retrieving said information, communication system , sends said information to logic process , which then reads said information representing the state of the group for which information was requested. In certain embodiments, logic processes  periodically check the current state of a group via communication system . If the group state read by logic process , after retrieval by communication system , is stable, communication system  takes no further action. If group state is unstable, then communication system  examines and records the then current changemakers list. If the then current changemakers list indicates that the group membership has changed since the last time logic process  has accessed group state (for example, if there are more entries in the changemakers list than previously recorded), then communication system  reads the current membership of the group and adds logic process  to the list of readers. If the changemakers list indicates that the group membership has not changed since the last time logic process  has accessed group state, then communication system  does not read the current membership of the group.","In registering step , logic process  registers a topic . Communication system  assigns a unique number with a topic  and records the name of the topic , along with other information necessary to carry out the functions communication system , in data store . This may be recorded in, for example, a data record  such as variable  (). Accordingly, other logic processes  may access topic  (including any information stored in said data record  associated with said topic ). Any number of topics  may be registered by the communication system .","In publishing step , logic process  transmits a communicative-value  corresponding to a topic . After a topic  is registered in communication system , logic process  may transmit newly measured or synthesized data associated with said topic  to communication system  by publishing a communicative-value  on a topic . Communication system  ensures that logic process  is permitted to publish communicative-values  on said topic . Communication system  records the total number of communicative-values  published on each topic , sequentially orders published communicative-values , and associates a sequence number with each published communicative-value  corresponding to the order in which the communicative-values  were published. Communication system  then transmits information to data store , which stores including said information and said sequence number in a value . Data store  records one or more values  in one or more data records  which may be variable records  (). It is understood that logic process  may publish a first communicative-value  on a topic , a second communicative-value  on a topic , and so on. The first communicative-value  published on a topic  may be associated with the number, one; and the second value published on a topic may be associated with the number, two. Accordingly, communication system  records the ordering of the sequence of communicative-values  published on a topic .","In subscribing step , logic process  subscribes to a published topic  by requesting a subscription from communication system . Logic process  also provides a variable representing time duration to communication system  indicating the period of time for which logic process  requires communication system  to retain information for use by logic process . This is called a lease period. Lease periods, time of publication, and other time values are synchronized in the network using any suitable time synchronization method such as NTP or DNT algorithms including, without limitation, Mattern's GVT algorithm. Communication system  ensures that logic process  is permitted to access said topic  and communicative-values  published on said topic . If so, communication system  records that fact and permits logic process  to subscribe. In addition, communication system  generates a unique number to identify the subscription of logic process  to said topic. The subscription information is recorded in a data record  such as variable record  ().","In alternate subscribing step , logic process  subscribes to a published topic  by requesting a subscription from communication system . Alternate subscribing step  differs from subscribing step  in that logic process  provides to communication system  the unique identifier that has already been created to associate logic process  with said topic . Communication system  verifies that the lease period for logic process  has not expired and retrieves the appropriate state record  from data store . Communication system  then transmits the state information stored in state record  to logic process  along with the sequence number of the most recently evaluated and processed value. Alternate subscribing step  may be used where a logic process  is terminated and a replacement logic process  is deployed by deployer . This step is used by embodiments of the invention to achieve the property of reconfigurability described herein.","In new value reading step , logic process  requests and communication system  provides, if available, the newest communicative-value  published on a requested topic . Communication system  provides this information by accessing the appropriate communicative-value  along with any appropriate variable records  from data store . Communication system  uses information it retrieves from communicative-value  and any retrieved variable records  to verify that logic process  is permitted to access communicative-values  associated with said topic . Communication system  also records the fact that logic process  has read said communicative-value  on said topic  in a variable record  in data store .","In certain embodiments, if a communicative-value  associated with the next expected sequence number to be published on a topic  does not yet exist in data store  as apparent to communication system , then the sequence number associated with the most recently published communicative-value  on said topic  is retrieved. This is the then maximum sequence number. If the then maximum sequence number is greater than or equal to the next expected sequence number, then communication system  deduces that the next expected sequence number has already been removed from the communications system  and data store  by the communications system  in garbage collecting step . If the then maximum sequence number is less than the next expected sequence number, then the next expected sequence number has not been published yet. If the next expected sequence number exists, then the communicative-value  associated with said sequence number may be retrieved and transmitted to logic process  by communication system .","In ordered value reading step , logic process  requests and communication system  provides, if available, the communicative-value  published on a requested topic  associated with a particular sequential order number associated with said communicative-value . In this step, logic process , for example, may request the fifth communicative-value  published on a topic . Communication system  then retrieves, if available, the appropriate communicative-value  and variable records  from data store . If appropriate information is available, communication system  provides to logic process  the fifth communicative-value  that was published. Communication system  also verifies that logic process  is permitted to access communicative-values  associated with said topic  by accessing and analyzing the contents of the communicative-value  and one or more retrieved variable records  from data store . Communication system  also records in one or more variable records  in data store  the fact that logic process  has read said communicative-value  on said topic . This process may be performed for any of the sequentially published values.","In deleting step , logic process  indicates that it has finished using a communicative-value . More than one logic process  may be required to read and process any given communicative-value . After logic process  has read and processed a communicative-value , then it communicates to communication system  that it has finished processing said communicative-value . Communication system  then records the fact that logic process  has finished processing said communicative-value  in a variable record  in data store . Communication system  does not delete data during deleting step , but merely indicates that the data is no longer needed by the particular logic process . Data is actually removed from data store  in garbage collecting step .","In stateful deleting step , a logic process  indicates that it has finished using a value and directs communication system  to store its state. Stateful deleting step  and deleting step  may be performed independently, and certain embodiments of the invention may implement stateful deleting step  without implementing deleting step . In addition to performing all the steps of deleting step , in stateful deleting step , communication system  also records the state of logic process  in data store  in a state record . As can be understood, stateful deleting step  and alternate subscribing step  are logically linked. Stateful deleting step  stores the state of logic process  in a state record  in data store . Alternate deleting step  is the counterpart of stateful deleting step  in that, in alternate deleting step , a prior state of logic process  is retrieved from (and is loaded into) logic process . The combination of alternate deleting step  and stateful deleting step  effectively provide the property of reconfigurability by allowing the behavior of hosts  to be altered by replacing logic processes  on hosts .","It is understood that all of, or a portion of, the information stored in logic process  is considered the \u201cstate\u201d of said logic process . In certain embodiments, the state of a logic process  may include current or past values that have been published on topics to which logic process  subscribes and has read via subscribing step  or alternate subscribing step . These values may be information obtained via an input  or synthesized by logic process  in evaluating process , and more specifically in evaluating step . It is understood that in storing step , logic process  performs publishing step . It is also understood that logic process  can serialize its state into a single variable. In certain embodiments, this is accomplished by encoding all of the variables comprising the state of logic process  into a single string variable. Any suitable encoding and decoding scheme may be used.","It is understood that in alternate subscribing step , logic process  retrieves a state for logic process . In certain embodiments, logic process  decodes the state retrieved in subscribing step  and sets the current value of each variable of logic process  to the value stored in the retrieved state. In this fashion, control process  may turn off a logic process  (see ), receive a new logic process  with different properties from deployer  and turn on the new logic process . The new logic process  can then load all of the information that was previously contained in the old logic process  into the new logic process .","In garbage collecting step , a process removes any values stored in data store  that are no longer needed by communication system . A value is no longer needed by communication system  if all logic processes  that have subscribed to the topic on which a value was published no longer need that value. A logic process  does not need a value if either (1) that logic process indicated that it has finished using said value by performing deleting step ; or (2) the lease period has expired for said topic subscription for said logic process . In other words, communication system  does not need a value if enough time has passed or if all logic processes  have finished using a communicative-value . As can be appreciated, garbage collecting step  allows the communication system  to publish only one communicative-value  for each newly acquired or synthesized piece of information. This is because deletion of any such communicative-value  does not occur until after logic processes  have finished using said communicative-value . This step allows for more efficient use of resources.",{"@attributes":{"id":"p-0253","num":"0316"},"figref":["FIG. 16C","FIG. 16B"],"b":["440","430","400","400","430","750","760","770","430","400","750","760","770"]},{"@attributes":{"id":"p-0254","num":"0317"},"figref":"FIG. 17","b":["1200","420","420","400","440","21","20","170","170","170","170","60","170","61","170","62","61","62","60","170","400","440","410","420","621","170","21","1205","400","170","170","170","160","60","160","130","140","150","31","30","31","170","31","33","33","35","37","35","39","35","33","39","37","1200","33","420","1200","61"],"i":["d","e","f ","d ","e ","d ","d","e","f","e"]},"Hosts and are ARM-based embedded linux systems powered by lithium ion battery power and solar power.","Host and , as well as first subnetwork  and second subnetwork  are in the outside environment, whereas network , deployer , and host may be in a data room under controlled conditions.","Deployer  deploys unique logic processes  to hosts , , and . A control process  on each host loads the appropriate deployed logic process  into machine .","Hosts , , and each use their respective communication system  to join a group. It is understood that a logic process  performs this operation, as is disclosed elsewhere herein. For convenience, this example will state that hosts , , and are perform actions, although it is understood that such actions are performed by components contained within each host, as described more fully elsewhere herein. Additionally, the term \u201ccommunication system\u201d  in example 3 refers collectively to each communication system  (and accompanying data store ) residing on each host .","Host registers moisture topic  in communication system . Host begins to take repeating measurements of soil moisture using instrument . For each measurement of soil moisture, host publishes a corresponding moisture value  to moisture topic  using communication system . After each moisture value  is published using communication system  (and transmitted to data store ), the published moisture value  will propagate to each data store  (as disclosed elsewhere herein).","Host registers sprinkler control topic  in communication system .","Host subscribes to sprinkler control topic  using communication system .","Host subscribes to moisture topic  using communication system , and repeatedly receives each moisture value  published by host . New moisture values  are received and processed according to logic loop  (). Each time host receives a new moisture value , the moisture value  is evaluated by evaluating process . In this example, host evaluates (in evaluating process ) the current time, the currently received moisture value , as well as previously received moisture values  and associated times. Said evaluation is performed in evaluating process  according to logic determined by model generator , analyzer , and compiler . The evaluation may be, for example, \u201cif moisture content has been below a threshold amount for more than eight hours, and the current time is after 6:00 P.M., then publish \u2018on\u2019 to the sprinkler control topic.\u201d If, based on said evaluation, host determines that it should publish a new sprinkler control value , it does so. Thus, host evaluates the moisture content of the soil, determines whether to turn the sprinkler on or off, and possibly publishes a sprinkler control value  on sprinkler control topic .","As it has subscribed to sprinkler control topic , host repeatedly receives each sprinkler control value  published by host . New sprinkler control values  are received and processed according to logic loop  (). Each time host receives a new sprinkler control value , the sprinkler control value  is evaluated by evaluating process . In this example, the evaluating logic in evaluating process  determines whether host has instructed sprinklers  to be on or off. If evaluating process  in host determines that it has been instructed to turn the sprinkler on, host directs solenoid  to open valve , allowing water  to flow to the sprinklers . If evaluating process  in host determines that it has been instructed to turn the sprinkler off, host direct solenoid  to close valve , restricting the flow of water  to the sprinklers .","Host may also register solenoid status topic  to which host subscribes. Host repeatedly measures the status of solenoid  and publishes a solenoid status value  on solenoid status topic . Host then, effectively, can receive direct feedback from the solenoid  and indirect feedback from instrument . Accordingly, host may have other actions it can take when solenoid  become unoperational. For example, host could send an email or text message to a supervising groundskeeper. Alternatively, in other embodiments, there may be more than one solenoid , valve , pipe , connected to sprinklers . If one solenoid  is unable to open and provide water , then other solenoids  could be directed to open a valve , allowing the golf course watering system  to operate in the event of equipment failure.","As may be observed this example may apply to other situations, such as situations where other resources are used (including, without limitation, electricity and oil), there may be varying costs associated with use of each resource. Thus, evaluating process  may be configured such that, where a lower cost resource may be used, it will be used. The cost of such resources may be published to the communication system . Therefore, evaluating process may continually reevaluate the availability and cost of resources to achieve a desired goal.","Example 3 operates under potentially unreliable conditions. For example, host (or ) may run out of battery power and the then currently available solar power may not be enough to power host . Therefore, host could remain shut off for a period of time. Additionally, first subnetwork  (or second subnetwork ) may have interference which temporarily interrupts communications. In either case, there is the possibility that, during the operation of system , that portions of system  may become disconnected.","In the event that first subnetwork  becomes unoperational, host will continue to measure soil moisture and publish new moisture values  on the moisture topic  via communication system  to its local data store . However, the newly published moisture values  will not be received (and thus, not read) by host . However, host will continue to evaluate newly published solenoid status values  and will continue to publish new sprinkler control values .","As an example, if first subnetwork  becomes unoperational after host has published a sprinkler control value  on sprinkler control topic , instructing solenoid  to open valve , host may, in addition to evaluating newly published moisture values , evaluate the period of time solenoid  has been in a state causing valve  to allow water  to flow through pipe . Thus, host may publish a sprinkler control value  to sprinkler control topic  directing solenoid  to close valve  based on the fact that solenoid  has been open for too long.","For any number of reasons, it may be desirable to have the logic on host changed. For example, a new host  may be added to the system  with, for example, new inputs or outputs. Alternately, a groundskeeper may desire to alter the operational logic of host because, for example, the seasons change or a course needs repair. Host may be altered without restarting host and without resetting any operational information that host has stored locally. The redeployment process is described in more detail in connection with , , and B.","In example 3, after host reads, evaluates, and acts on a newly published value, it saves its current state, as is described more fully in stateful deleting step . If host receives a message from deployer  instructing host to execute new logic, new logic may be deployed. Host then retrieves the appropriate state of its logic, as is described more fully in alternate subscribing step . Host may then continue to process newly published values.","If, for example, deployer  instructs host to deploy new logic when valve  is open, the new logic deployed in host , has all of the same knowledge has the previously deployed logic. Thus, host knows, for example, how long water  has been flowing through sprinklers . If host did not retrieve the state as it does, host may keep water  flowing through sprinklers  for too long.","Example 3 is provided as an instructional example. As precise operation becomes increasingly important (for example, in the control of operations in a nuclear power plant or in the control of military weapons systems or critical enterprise resource systems), the importance of the intelligent redeployment described herein becomes apparent.","The foregoing description of the embodiments of the invention has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed, and modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention. The embodiments were chosen and described in order to explain the principles of the invention and its practical application to enable one skilled in the art to utilize the invention in various embodiments and with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the claims appended hereto, and their equivalents.","Embodiments of the systems , , , , and  and\/or components thereof, can be implemented in hardware and\/or software. Further, it will be obvious to those having skill in the art that many changes may be made to the details of the above-described embodiments without departing from the underlying principles of the invention. For example, any suitable combination of the components of the systems , , ,  and\/or  is possible. The scope of the present invention should, therefore, be determined only by the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a further understanding of the nature and objects of the present invention, reference should be had to the following description taken in conjunction with the accompanying drawings in which like parts are given like reference numerals and, wherein:",{"@attributes":{"id":"p-0014","num":"0041"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0042"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0043"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0017","num":"0044"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0018","num":"0045"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0046"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0020","num":"0047"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0048"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0022","num":"0049"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0023","num":"0050"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0024","num":"0051"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0025","num":"0052"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0026","num":"0053"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0027","num":"0054"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0028","num":"0055"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0029","num":"0056"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0030","num":"0057"},"figref":"FIG. 16A"},{"@attributes":{"id":"p-0031","num":"0058"},"figref":"FIG. 16B"},{"@attributes":{"id":"p-0032","num":"0059"},"figref":"FIG. 16C"},{"@attributes":{"id":"p-0033","num":"0060"},"figref":"FIG. 17"}]},"DETDESC":[{},{}]}
