---
title: Technique for GPU command scheduling
abstract: A technique for scheduling the dispatching of Graphics Processing Unit (GPU) commands is described. A method implementation of this technique comprises receiving commands from a plurality of applications, buffering the received commands, and dispatching the buffered commands as a command batch towards a GPU. The dispatching is scheduled such that a GPU idle period is created between two successive command batches dispatched towards the GPU.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09001137&OS=09001137&RS=09001137
owner: Telefonaktiebolaget L M Ericsson (Publ)
number: 09001137
owner_city: Stockholm
owner_country: SE
publication_date: 20110426
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present disclosure generally relates to command scheduling in a heterogeneous computing environment and in particular to the scheduling of commands for a Graphics Processing Unit (GPU).","GPUs have long been used in stationary computers and are today also becoming an important technical feature of handheld devices such as mobile telephones. While originally intended for the acceleration of 3D graphics, GPUs are nowadays employed for a plethora of additional processing intensive graphics tasks such as 2D graphics rendering, composition of multiple graphics layers into a single image, image and video processing as well as user interface acceleration.","The inherent architectural parallelism makes GPUs particularly well suited for graphics tasks, but also in the field of general purpose computation there exist in many cases speed and power benefits when performing a task on a GPU rather than on a Central Processing Unit (CPU). Especially in heterogeneous embedded devices the CPU is often a critical resource, whereas the GPU is typically under-utilized. General Purpose GPUs (GPGPUs) are thus becoming increasingly widespread, and a corresponding standard (OpenCL) has recently been defined by the Khronos group.","WO 2009\/111045 A1 describes a typical environmental architecture for a GPU. Graphics commands generated by client applications are asynchronously written to command buffers. A window server is configured to detect the generation of graphics commands by the client applications. The window server analyzes an individual image to determine if compositing processing is to be initiated for this image. During compositing processing the image is combined with one or more other graphics or video layers of other client applications, and corresponding compositing graphics commands are then stored in the command buffers.","A GPU driver reads sets of graphics commands from the command buffers in the order in which they were written by the client applications and the window server. The GPU driver has a batch generator module which prepares a batch of graphics commands from the graphics commands retrieved from the command buffers. Once prepared, the batch of graphics commands (corresponding to one frame of image data) is sent in a single transaction via a hardware command queue to the GPU.","The transmission of graphics command batches from the batch generator module to the GPU is controlled by a notification handler module of the GPU driver. The notification handler module receives notification messages from the GPU which indicate that the GPU is ready to receive additional commands. The notification messages are based on interrupts sent from the GPU to a CPU hosting the GPU driver.","One drawback of conventional GPU architectures such as the one described in WO 2009\/111045 A1 is the fact that they do not prevent an individual application from monopolizing or even blocking the GPU. For this reason, GPU command schedulers have been proposed.","Mikhail Bautin, Ashok Dwarakinath and Tzi-Cker Chiueh: \u201cGraphics Engine Resource Management\u201d, Proceedings of 15Multimedia Computing and Networking Conference, 2008, SPIE 28 Jan. 2008, proposes a GPU command scheduler that controls a GPU command production rate of an application through its CPU scheduling priority. Specifically, GPU commands are scheduled in such a way that GPU scheduling matches resource allocation decisions of a CPU scheduler. As a result, an equal share of GPU time can be allocated to each application regardless of the application-specific demand.","A software implementation of the GPU command scheduler suggested by M. Bautin et al. comprises a dedicated command queue for each application requesting GPU resources. GPU command groups are scheduled from these \u201cper-application\u201d command queues using a weighted round robin scheduling policy.","It has been found that conventional GPU command scheduling approaches still suffer from certain disadvantages. For example, the scheduling is typically application-centred, which means that the specific needs and possibilities of individual GPUs are not taken into account during the command scheduling procedure.","US 2008\/303833 A1 discloses a method and an apparatus for notifying a sharing display driver to update a display with a graphics frame including multiple graphics data rendered separately by multiple graphics processing units (CPUs).","Chia-Ming Chang et al.: \u201cEnergy-saving techniques for low-power graphics processing unit\u201d, International SoC Design Conference, 2008, IEEE, Piscataway, N.J., USA, discloses a GPU with energy-saving techniques, which allow to achieve high performance with low power consumption from algorithm, architecture and circuit levels.","US 2005\/125701 A1 discloses a method and system for providing energy management within a processing system, which can reduce energy consumption by managing processes through intelligent scheduling of processes and in conformity with a measured level of energy use by each process.","It is an object underlying the present disclosure to provide a command scheduling technique for a GPU that avoids specific disadvantages of conventional (e.g., application-centred) scheduling approaches.","According to a first aspect, a method of scheduling the dispatching of GPU commands is provided, wherein the method comprises receiving commands from a plurality of applications, buffering the received commands, and dispatching the buffered commands as a batch towards the GPU. The dispatching is based on a scheduling, the scheduling being determined to create a GPU idle period between two successive command batches dispatched towards the GPU.","In one exemplary implementation, the command batches are dispatched to a GPU driver. In this manner, the dispatching process may be decoupled from processing requests initiated by the GPU itself (see, e.g., WO 2009\/111045 A1).","Scheduling the dispatching of command batches with the intention to control creation of a GPU idle period may permit the GPU to reduce its power consumption. As an example, the GPU may enter a power saving mode or even go to sleep during the idle periods thus created. The scheduling may be performed under control of an operating system. Accordingly, the operating system may gain control of the GPU processing cycles.","In order to maximize the idle periods, one or more idle period extension procedures may be implemented. One such idle period extension procedure may comprise excluding one or more of the buffered commands from being dispatched towards the GPU. To this end, the buffered commands may be analyzed in a first step. In a second step, one or more of the analyzed commands may be excluded from being dispatched towards the GPU depending on a result of the analysis.","The analysis of the buffered commands may be performed in many different ways. As an example, a graph-based analysis approach may be used. In such a graph-based analysis approach, a hierarchical or non-hierarchical graph representation of the buffered commands may be created. The graph created from the buffered commands may comprise nodes and edges. In one variant, each node represents one or more of the buffered commands that result in a specific destination surface when applied to zero, one or more source surfaces each. In this variant, each edge may link a first node representative of one destination surface with a second node representative of one source surface for the first node.","As understood herein, a surface may be an abstract entity represented by a data structure containing graphics-related information defining the surface. The graphics-related information may comprise a logical grouping of GPU commands pertaining to a specific graphics object, graphics task and\/or graphics area on a display device.","As an example, each surface may have a surface extent and a surface content (that may each be represented by a corresponding data structure portion). The surface extent may be indicative of a size (e.g., height and width) and\/or location of the surface content when output on a display device. The surface content, on the other hand, may be defined by at least one buffered command associated with the surface. As an example, the surface content may be defined by an intermediate representation created by executing the at least one buffered command associated with the surface. The intermediate representation may, for example, take the form of an image or a texture (e.g., of an image file conforming to the JPEG or any other graphics standard). Additionally, or in the alternative, the surface content may be defined by at least one job. Each job may include one or more of the buffered commands pertaining to a specific source surface.","In one implementation, the graph is parsed prior to each dispatching process to determine the buffered commands to be dispatched. Moreover, the graph may (at least partially) be re-created after each dispatching process. During a partial recreation of the graph, one or more previously created graph portions (e.g., sub-graphs) pertaining to buffered commands that have not changed since the last dispatching process may be re-used. Moreover, for the buffered commands that have not changed since the last dispatching process an associated intermediate representation may be created. The intermediate representation may be created by executing these commands and storing the execution result in a data structure representative of the intermediate representation.","Analyzing the buffered commands may comprise parsing the graph to determine at least one graph portion (e.g., a node or sub-graph) that can be skipped. The buffered commands relating to the graph portion that can be skipped may then be excluded from being dispatched towards the GPU. The skipped graph portion may pertain to a surface (or part of a surface) hidden by another surface. Additionally, or in the alternative, the skipped graph portion may pertain to an intermediate representation that has been generated and stored during a previous execution of the buffered commands associated with the skipped graph portion.","The scheduling may define a display update rate of a display device. As a result, the display update rate may dynamically be controlled by the scheduling. In one example, the scheduling takes into account the current processing capabilities (e.g., workload) of at least one of the GPU and CPU. If one or more intermediate representations are available, the intermediate representations may be retrieved and rendered on a display device instead of executing the buffered commands (that have been excluded from being dispatched towards the GPU) during an upcoming display update procedure. As will be appreciated, the intermediate representations consume memory resources but save processing (e.g., GPU) resources.","In a further implementation, the buffered commands may be analyzed to determine a total GPU workload associated with the buffered commands. Subject to the workload determination, a workload balancing between the GPU and at least one of another GPU and a CPU may be initiated.","The GPU commands may be received from the various applications via a GPU Application Programming Interface (API). Moreover, the command batches may be dispatched to a GPU driver in charge of feeding the GPU with the GPU commands.","According to another aspect, a computer program product is provided. The computer program product comprises program code portions which, when executed on a computing device, cause the computing device to execute the steps of any of the methods described herein. The computer program product may be stored on a computer-readable recording medium such as a permanent or re-writable memory, a CD-ROM, or a DVD. The computer program product may also be provided for download via one or more computer networks, such as the Internet, a cellular telecommunications network or a wireless or wired Local Area Network (LAN).","According to a still further aspect, a scheduler for GPU commands is provided, wherein the scheduler comprises an interface adapted to receive commands from a plurality of applications, a buffer adapted to buffer the received commands, and a controller adapted to dispatch the buffered commands as a command batch towards a GPU. The controller is configured to control the dispatching based on a scheduling, the scheduling being determined to create a GPU idle period between two successive command batches dispatched towards the GPU.","The controller may also be adapted to analyze the buffered commands and to exclude one or more of the analyzed commands from being dispatched towards the GPU depending on a result of the analysis. The controller may further be adapted to create a graph (as generally described above) from the buffered commands. The graph may then be parsed by the controller when analyzing the buffered commands to determine at least one graph portion that can be skipped. The buffered commands relating to the graph portion that can be skipped are then excluded from being dispatched towards the GPU. Several examples of graph portions that can be skipped have already been described above.","In a scenario in which the scheduling defines a display update rate, the controller may further be adapted to dynamically control the display update rate according to current processing capabilities of at least one of the GPU and a CPU. Moreover, the controller may also be adapted to analyze the buffered commands to determine the total GPU workload associated with the buffered commands, and to initiate a workload balancing between the GPU and at least one of another GPU and a CPU subject to the workload determination.","The scheduler interface for receiving GPU commands may take the form of a GPU API. Moreover, the scheduler may further comprise, or be connected to, a GPU driver adapted to receive the dispatched GPU commands. The GPU driver, in turn, may be configured to feed the GPU with the GPU commands received from the scheduler.","In the following description, for purposes of explanation and not limitation, specific details are set forth, such as specific device configurations and specific graphics content processing and display scenarios in order to provide a thorough understanding of the technique disclosed herein. It will be apparent to one skilled in the art that this technique may also be practiced in other embodiments that depart from these specific details.","Those skilled in the art will further appreciate that the methods, steps and functions explained herein may be implemented using individual hardware circuitry, using software functioning in conjunction with a programmed microprocessor or general purpose computer, using an Application Specific Integrated Circuit (ASIC) and\/or using one or more Digital Signal Processors (DSPs). It will also be appreciated that while the following embodiments are primarily described in the form of methods and devices, the technique disclosed herein may also be embodied in one or more processing units and a memory coupled to the processing units, wherein the memory stores one or more programs that perform the steps discussed herein when executed by the one or more processing units.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"b":["140","140","160","180","140","140"]},"Instead of the GPU commands being sent directly, via the GPU driver , to the GPU  by each application, the GPU commands will be buffered by the command scheduler  before being dispatched in individual command batches to the GPU driver  and, thus, to the GPU . As a result, the GPU  will be protected from un-coordinated accesses by the various applications, which would prevent the GPU  from going to sleep or initiating local power saving measures, and from the ability to cooperate with a system level resource and power management scheme.","Once the GPU commands are buffered by the command scheduler , the buffered GPU commands can be analyzed, simplified, deleted, and so on. In particular, an Operating System (OS) may become in control over GPU usage via the command scheduler . The OS may thus control how load is distributed between the GPU  and a CPU (or a further GPU). Moreover, the OS may control the command scheduler  so as to achieve a cooperation of the GPU  with a system level resource and power management scheme. As an example, the OS may limit, via the command scheduler , a display update rate to lower the overall load and the system power consumption.","These and the other advantageous aspects of the command scheduler  will now be described in more detail with reference to . The same reference numerals will be used to denote the same or similar components.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 2","FIG. 2"],"b":["140","100","100","140"]},"The mobile terminal  illustrated in  comprises, in addition to the command scheduler , a CPU , a GPU driver , a GPU  as well as a display device . The CPU  is configured to execute program code of an OS  and of various applications. The OS  is configured to control the command scheduler . It should be noted that while the applications running on the CPU  are configured to generate GPU commands, the applications need not necessarily be 3D graphics applications. Rather, the applications may be also be, e.g., 2D graphics, image processing, video or general purpose applications utilizing the GPU  as a GPGPU to disburden the CPU .","As illustrated in , the command scheduler  comprises an interface towards the CPU  in the form of a GPU API . The GPU API  may, for example, combine the functionalities of the 2D graphics API and the 3D graphics API shown in . The GPU API  may additionally be configured to receive and\/or generate composite commands as discussed above with reference to .","The command scheduler  further comprises a command buffer  located downstream of the GPU API . The command buffer  is configured to temporarily store the GPU commands received via the GPU API . In one implementation, the command buffer  is realized in the form of a command queue (e.g., in accordance with the FIFO paradigm).","A controller  of the command scheduler  is adapted to dispatch the commands in individual command batches from the command buffer  to the GPU driver . The controller  schedules the dispatching of the individual command batches such that a GPU idle period is created between two successive command batches dispatched towards the GPU . The scheduling of the dispatching procedures by the controller  may take into account information or instructions received from the OS . In this manner, the GPU command scheduling may be harmonized with system level resource and power management schemes.","The GPU driver  receives the batches of GPU commands from the command buffer  of the command scheduler . The GPU commands thus received are fed by the GPU driver  to the GPU  in accordance with conventional command feeding strategies (see, e.g., WO 2009\/111045 A1).","The operation of the command scheduler  will now be described in more detail with reference to a method embodiment illustrated in the exemplary flow chart  of .","As shown in , the scheduling procedure starts with the command scheduler  receiving GPU commands from the plurality of applications running on the CPU  (step ). These GPU commands may pertain to graphics-related processing operations to update a presentation on the display device . Additionally, or in the alternative, the GPU commands may relate to general purpose processing operations off-loaded from the CPU  to the GPU  in accordance with, for example, a load balancing scheme enforced by the OS .","In a next step , the GPU commands received from the various applications are temporarily stored in the command buffer . The buffering of the GPU commands may be performed in various different ways. According to one exemplary buffering approach, the GPU commands are queued in the command buffer  in accordance with a command graph that facilitates an analysis of the buffered commands by the controller .","In a further step , the controller  dispatches the buffered commands as a single command batch to the GPU driver  and thus towards the GPU . The controller  schedules the dispatching such that a GPU idle period is created between two successive command batches.  illustrates such an idle period between two GPU activity periods resulting from the processing of two successive command batches. During the idle period, the GPU  may go to sleep or to enter a low power mode. The resulting power reduction is particularly beneficial for battery-operated devices such as the mobile terminal  of .","The idle period of  is the result of the command scheduler  protecting the GPU  from \u201crandom accesses\u201d by the multiple applications running on the CPU . These \u201crandom accesses\u201d result from the fact that the various applications create their GPU commands independently from each other. Consequently, there are very little chances that the period of time between two successive GPU commands from different applications will be long enough to permit the GPU  enter a low power mode or go to sleep. Only with the insertion of the command scheduler  between the applications generating the GPU commands and the GPU  processing the GPU commands a buffering and a batch-wise dispatching of the buffered GPU commands can be achieved with the intention to maximize the idle period. In particular, the dispatching may become independent from GPU requests as generally known from WO 2009\/111045 A1).","The dispatching of the command batches from the command buffer  may be triggered or adjusted by the OS  in accordance with a system level resource or power management scheme. As an example, the OS  may control a display update rate of the display device  by controlling (e.g., dynamically adjusting) the period of time between two successive dispatching processes. Accordingly, the display update rate may be pro-actively limited by the OS  to limit an overall load and power consumption (e.g., in accordance with the current battery status of the mobile terminal ).","Alternatively, or in addition, the OS  may incorporate the GPU  in a system level resource and power management scheme by allowing for a load balancing between the CPU  and the GPU  at run-time as generally illustrated in . As shown in , the processing of exemplary 2D graphics commands may be distributed between the CPU  and the GPU  depending on the current system load","The workload distribution scenario illustrated in the upper diagram of  illustrates the \u201ctraditional\u201d way of rendering 2D graphics relying solely on the CPU  and using the GPU  only for 2D graphics command compositing. When system workload increases, a fair processing amount may be moved from the CPU  to the GPU  as shown in the diagram in the middle of . Thereby the CPU load is reduced to 30% compared to the approach illustrated in the top diagram. The GPU load goes up, but not as much as the CPU load is reduced since only processing tasks for which the GPU  has been optimized (e.g., tasks that require parallel processing) are moved to the GPU .","In the lower diagram, GPU use is maximized while CPU use is minimized. This approach includes also moving tasks from the CPU  to the GPU  that are not particularly well suited for the GPU . As a result, the total efficiency gain is lower compared to the transition from the top diagram to the diagram in the middle.","In the workload distribution scenario illustrated in the top diagram, the CPU  is likely to become a possible bottleneck, whereas in the bottom diagram the GPU  might become the bottleneck. The proper workload balancing between the CPU  and the GPU  will be performed at run-time.","It should be noted that the scenario shown in  illustrates only one of many client applications requesting CPU and GPU processing resources. In addition to the 2D graphics application illustrated in , 3D graphics applications and other graphics or non-graphics applications may request corresponding processing resources at the same time as the 2D graphics applications exemplarily illustrated in .","In the following, a graph-based approach to maximize the idle period between two successive command batches will be described with reference to . As shown in , which is an extension of the embodiments shown in , the graph-based functionalities of the command scheduler  are provided by the controller . Specifically, based on the commands currently stored in the command buffer , the controller  creates jobs. Based on the jobs, the controller  creates and maintains a hierarchical job graph. The job graph may (at least partially) be re-created after each dispatching process based on the commands that have newly arrived in the command buffer .","Once the job graph has been created, it is analyzed by the controller  to determine if any of the currently buffered commands can be excluded from being dispatched with the next command batch towards the GPU . As will be readily appreciated, excluding one or more of the buffered commands from being dispatched to the GPU will extend the GPU idle period and thus help to reduce GPU power consumption.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 7","b":["260","240","200"]},"In general, a surface can be regarded as an abstract entity (e.g., a data structure) defining a surface extent property and a surface content. The surface extent may simply be indicative of the size (e.g., the width and height) and, optionally, the location of the surface content when rendered on the display device . The surface extent may be defined by a polygon. The polygon may be defined using normalized coordinates together with a transformation matrix which allows to transform the normalized coordinates into custom coordinates of device or user space coordinate systems.","Surface content may be described by an ordered list of jobs, each of which optionally having a reference (\u201cedge\u201d) to another surface, thus forming a directed graph. Alternatively, the content may be described by an intermediate representation (typically an image or texture) created by executing the list of jobs rooted in the surface (potentially recursing into a constituent surface). The intermediate representation can thus be regarded as a property of the surface, representing the outcome of executing the associated job list. Once the intermediate representation has been created, it may be stored for later re-use and need not be re-created unless there is a change in the underlying jobs or surfaces during a future display update cycle.","In a similar manner, a job can be regarded as a data structure defining one or more of the following data items:","1) a sequence (ordered set) of one or more GPU commands currently stored in the command buffer  and associated data (such as data indicative of edges, etc.);","2) a destination surface (i.e., a surface affected by an execution of the GPU command associated with this job);","3) an optional source surface to which acts as input to the job is applied; and","4) an extension (e.g., a bounding polygon indicating the area to which the job applies).","The complex job graph of  can be simplified as illustrated in , and such simplified representations will in the following be discussed in more detail to illustrate the concepts of sub-graphs (\u201cgraph portions\u201d), common sub-graphs and the relationship between sub-graphs and intermediate representations.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 9","FIG. 9"],"b":"200"},{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIGS. 10 and 11","FIG. 10","FIG. 11"],"b":["200","200"]},"As illustrated in , seven surfaces S to S are rooted in the screen surface. The screen surface itself comprises three sub-graphs, or graph portions: S\u2192S\u2192(S, S), S\u2192S\u2192(S, S), and S\u2192S. The sub-graph S\u2192(S, S) is shared by surfaces S and S, and thus constitutes a common sub-graph to S and S. In the exemplary content rendering of , which is a mock-up of a video chat, S is an image formed by combining a foreground (S\/woman) with a background (S\/mountains), which is used by both the chat image (S) and its reflection (S).","Since S is used by both S and S, and S is formed by combining S and S, one may trade GPU processing resources (combining two images) for memory resources (storage space for S) by rendering S to an intermediate representation (e.g., an image file) on first use by S, and re-using the intermediate representation directly for S in one and the same display update cycle. Moreover, as long as S and S or the jobs\/commands in their respective job list continue to exist in the command buffer , the intermediate representation could also be re-used for future display update cycles.","Once an intermediate representation has been generated and stored in an associated memory (not shown in ), the sub-graph pertaining to the intermediate representation may be skipped during the next display update cycle, which means that the corresponding GPU commands in the command buffer  may be excluded from being dispatched to the GPU . Rather, instead of dispatching the corresponding commands to the GPU , the intermediate representation will be retrieved from the memory for being rendered during the upcoming display update cycle.","It should be noted that on current embedded platforms, memory can be more expensive than GPU processing resources, so that the decision whether or not to generate an intermediate representation for a common sub-graph may depend on the particular hardware architecture. Alternatively, or in addition, the decision may also be made based on the current workload of the GPU  and other parameters.","In general, the job graph needs to be re-created after each dispatching process based on the commands newly written into the command buffer  (and the dispatched commands may be deleted from the command buffer ). In certain cases, it may, however, be possible to re-use existing portions of the previous job graph when generating the new job graph (i.e., to perform a partial update). This means that it might not be necessary to re-create the whole job graph for the upcoming display update cycle.","Given the job graph of , if an application changes the content of S by adding\/removing individual jobs or changing the order of jobs, it is know a priori that sub-graphs not rooted in S will not be affected by the content change of S. If, as an example, S and S have been reduced to an intermediate representation (e.g., to images), all that needs to be done to get the final rendering on the display device  is to render S and then combine it with the intermediate representations of S and S onto the screen surface as defined by the job list for the screen surface (it should be remembered that \u201cscreen\u201d as understood herein is a surface, and not necessarily the physical screen of the display device ). As a result of the partial update, the generation of the job graph can be simplified.","In the example discussed above, the job graph is parsed by the controller  to determine sub-graphs that can be skipped, so that the associated buffered commands can be excluded from being dispatched towards the GPU . A further possibility to exclude buffered commands from being dispatched towards the GPU  results from sub-graphs pertaining to a surface (or a surface portion) hidden by another surface when rendered on the display device .","As has been discussed above, both surfaces and jobs have an extension property which defines their bounds in the form of, for example, a polygon. Based on the extension property, it can be determined by the controller  if the rendering on the display device  by a specific surface or job will be visible or not. During this determination, the execution order of the surfaces and jobs as defined in the job graph is also considered. As stated above, jobs are stored in the job graph in the form of ordered lists, and the surfaces are hierarchically ordered in the job graph.","Consequently, if a job or surface will not contribute to a display update cycle, it may be skipped when parsing the job graph by the controller . The skipping of the job will leave the job in the corresponding job graph, but will prevent the associated command(s) from being dispatched towards the GPU . Similarly to jobs, if a surface is hidden, the hidden surface and all sub-graphs routed in it will be skipped when determining the buffered commands that are to be dispatched towards the GPU . The skipping of the surface and the sub-graphs rooted in it will prevent the associated commands stored in the command buffer  from being dispatched towards the GPU .","As has become apparent from the description of preferred embodiments, the technique presented herein permits to protect the GPU  from random accesses by multiple applications, so that GPU idle periods between two successive GPU activity periods can be created in a controlled manner. Since creation of the idle period can be controlled by OS , the GPU  can be included into a system level resource and power management scheme. Additionally, workload balancing between the GPU  and the CPU  becomes possible, and the OS  gains influence on the display update rate, so that the display update rate can be adapted to the current resource situation of the overall system.","As a further advantageous measure, the idle period may be extended by excluding certain commands in the command buffer  from being dispatched towards the GPU . The determination of commands that may be excluded from being dispatched towards the GPU  may be performed using a graph-based technique. In one implementation, the graph-based technique permits the detection of sub-graphs representative of GPU commands not effecting the rendering process on the display device . Such GPU commands need therefore not be processed by the GPU.","In the foregoing, principles, embodiments and various modes of implementing the technique disclosed herein have exemplary been described. The present invention should not be construed as being limited to the particular principles, embodiments and modes discussed herein. Rather, it will be appreciated that various changes and modifications may be made by a person skilled in the art without departing from the scope of the present invention as defined in the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In the following, the technique described herein will be discussed in more detail with reference to exemplary embodiments illustrated in the drawings, wherein",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIGS. 10 and 11"}]},"DETDESC":[{},{}]}
