---
title: System for packaging native program extensions together with virtual machine applications
abstract: Methods and apparatus are described for packaging native program extensions with a virtual machine application. The application is distributed in an application package containing application code that runs in a virtual machine, native code that runs outside the virtual machine, and other resources. When the application requires access to native features of the underlying device not provided in the virtual machine, the native code is installed and executed. The virtual machine application accesses the native features by communicating with the native code running outside the virtual machine via inter-process communication.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08607224&OS=08607224&RS=08607224
owner: Yahoo! Inc.
number: 08607224
owner_city: Sunnyvale
owner_country: US
publication_date: 20090528
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF SPECIFIC EMBODIMENTS"],"p":["The present invention relates to mobile device computing, and more specifically to portable applications bundled with native program extensions for enhanced functionality.","Unlike desktop computers, mobile devices such as cell phones are not built on a common platform. Most desktop machines are based on the Intel x86 architecture, sharing a common instruction set, bus model, and standard components such as mouse, keyboard, hard drive, display, etc. Operating systems are fairly standardized as well, with the majority of desktop machines running some version of Microsoft Windows. By contrast, mobile devices are built around a wide variety of different hardware and operating systems. Processors from Texas Instruments, Qualcomm, Siemens\/BenQ, Broadcom, Marvell, and others are commonly used. Proprietary platforms and nonstandardized components such as Global Positioning System (GPS) receivers and cameras further complicate the picture. Many mobile device vendors develop their own operating systems or license operating systems from multiple providers. This creates a fragmented market of mobile devices lacking common hardware and software for application developers to target.","To address this problem, several common software platforms have been developed. Each platform provides a standard application programming interface (API) for accessing functionality of an underlying device. Applications run on top of the platform. When an application wants to use a device feature, it calls the platform API. The platform translates the API call into native instructions for the particular device being used. Applications written to the platform can run on a variety of devices without dealing with hardware and operating system differences between devices. Examples of such platforms include Sun Microsystem's Java Platform Micro Edition (Java ME or J2ME), Google's Android, and Qualcomm's Binary Runtime Environment for Wireless (BREW).","Platforms often do not expose every feature of the underlying device. Some device-specific features are covered up by the abstraction of a common API. Others may be omitted from the platform to provide a \u201clowest common denominator\u201d of features which exist in every device. Still others may not be widely used enough or exist at all when the platform is finalized. Additionally, code translating an API call into a native feature must be written for each device. If this translation code has not been written for a particular device, or if the device vendor did not load the translation code onto the device, then a feature may be unavailable even though both the platform and the underlying device support it.","For example, Mobile Information Device Profile (MIDP) is a set of Java ME interfaces. The first version of MIDP did not provide an API for full-screen graphics control, inhibiting the development of games on the Java ME platform. MIDP 2.0 corrected this, along with adding support for audio and multimedia playback, communications over HTTPS and other network protocols, and allowing MIDP applications to register with the operating system as handlers for certain types of network traffic. These features were available on devices before MIDP 2.0, but MIDP 1.0 did not provide a way to access them.","When a software platform does not provide features supported by the underlying device, an application programmer's options depend on the platform. Some platforms compile applications into native code for each device, providing only a cross-platform compatibility library for accessing device functions. In this case, the developer may be able to access unsupported features by calling the device operating system directly. The downside of this approach is code that is not portable to other devices. However, platforms such as Java ME do not even allow this option.","Java ME applications run inside a Java virtual machine. The virtual machine runs applications in Java bytecode, not native compiled code. The device processor won't run bytecode, and the virtual machine won't run native code. This technique, called sandboxing, prevents Java applications from accessing the device hardware or operating system directly. Sandboxed applications can only access what the virtual machine allows them to access. For instance, web browsers run Java virtual machines that forbid accessing the local file system.","A Java ME application has more limited options for accessing features outside the common platform. Java ME defines a number of optional libraries for features like Bluetooth and instant messaging. These libraries are not available on every device. A device manufacturer wishing to support such optional features can include the corresponding Java ME libraries on their devices. However, many manufacturers choose not to include such libraries, even though their devices support the underlying features.","Vendors can also create their own Java APIs for accessing device features. For instance, Research in Motion includes proprietary Java libraries for accessing additional features of their Blackberry devices. Such proprietary libraries are less desirable because they are limited to a single vendor, hampering portability of Java ME applications. In either case, these options are beyond the control of the application developer. Vendors decide whether to provide such features.","Java Native Interface (JNI) provides a third option for accessing features and services outside a java virtual machine in certain circumstances. With JNI, Java programs may directly execute native code. The Java virtual machine loads the native code into the running virtual machine process's address space and transfers control to it. When done, the native code must return control to the Java virtual machine. This differs from running Java bytecode, which runs on the Java virtual machine itself. JNI defeats any sandbox protection since native code is not bound by the restrictions imposed by the virtual machine on Java bytecode. Native code can perform any operation that any other program can perform. Because of this, high-security Java virtual machines such as the ones in web browsers do not allow JNI.","Many mobile devices do not provide JNI. Java ME defines two device configurations, Connected Device Configuration (CDC) and Connected Limited Device Configuration (CLDC). CDC runs on high-end mobile devices such as some smart phones with ample computing power and memory. CLDC runs on basic mobile devices, including the majority of cell phones. Because CLDC devices lack the needed power and memory, JNI is generally not available on them. Manufacturers may optionally add JNI to a CLDC device, but few do. As before, the decision to support JNI is not under the developer's control. Application developers targeting a wide variety of cell phones can not rely on JNI for interfacing with native code.","According to the present invention, methods and apparatus for providing native functionality to a virtual machine application on a computing device are provided. This involves running the virtual machine application in a virtual machine on the computing device. The virtual machine is not configured to provide access to one or more native features of the device. The application detects whether native code configured to provide access to the native features is installed on the computing device. If the native code is not detected, the application installs native code embedded in an application package corresponding to the virtual machine application onto the computing device. The installation is initiated by the virtual machine application and may be aided by another component such as an operating system. Once the native code is installed, the application accesses the native features by communicating with the native code.","Other embodiments of the invention include a computing device which provides native functionality to a virtual machine application. The computing device comprises one or more processors and one or more memories. The one or more memories contain a data structure and computer program instructions which run on the device. The data structure comprises a virtual machine application package containing at least a virtual machine application and native code for the device. A first portion of the computer program instructions comprise an operating system when executed by the computing device. The operating system provides a communication mechanism for processes on the computing device to communicate. The operating system further provides an installation mechanism to install programs on the computing device. A second portion of the instructions implements a virtual machine when executed by the device. The virtual machine runs virtual machine applications in a restricted environment which does not provide access to one or more native features of the computing device. A third portion of the instructions comprises the native code stored in the data structure. The native code provides access to the native features via the communication mechanism provided by the operating system when executed on the device outside the virtual machine. A fourth portion of the instructions comprises the virtual machine application. When executed by the virtual machine, the virtual machine application detects whether the native code is installed on the computing device. If the native code is not installed, the virtual machine application will install the native code embedded in the virtual machine application package onto the device via the installation mechanism provided by the operating system. When the native code is installed and loaded, the virtual machine application will access the native features by communicating with the native code via the communication mechanism provided by the operating system.","According to another embodiment of the invention, a computer program product comprising at least one computer-readable storage medium is described for providing native functionality to a virtual machine application. The computer program product comprises a data structure and computer program instructions that run on the computing device. The computing device includes an operating system which provides a communication mechanism for processes on the computing device to communicate and an installation mechanism to install programs on the computing device. The computer device also includes a virtual machine which runs a virtual machine application. This virtual machine does not provide access to one or more native features of the computing device. The data structure of the computer program product comprises a virtual machine application package containing the virtual machine application and native code. The computer instructions of the computer program product comprise the virtual machine application and native code. When executed by a processor of the computing device, the native code provides access to the one or more native features via the communication mechanism of the operating system. When executed by the virtual machine, the virtual machine application detects whether the native code is installed on the computing device. If the native code is not detected, the virtual machine application installs the native code embedded in the virtual machine application package via the installation mechanism provided by the operating system. When the native code is installed and loaded, the virtual machine application accesses the native features by communicating with the native code via the communication mechanism provided by the operating system.","A further understanding of the nature and advantages of the present invention may be realized by reference to the remaining portions of the specification and the drawings.","Reference will now be made in detail to specific embodiments of the invention including the best modes contemplated by the inventors for carrying out the invention. Examples of these specific embodiments are illustrated in the accompanying drawings. While the invention is described in conjunction with these specific embodiments, it will be understood that it is not intended to limit the invention to the described embodiments. On the contrary, it is intended to cover alternatives, modifications, and equivalents as may be included within the spirit and scope of the invention as defined by the appended claims. In the following description, specific details are set forth in order to provide a thorough understanding of the present invention. The present invention may be practiced without some or all of these specific details. In addition, well known features may not have been described in detail to avoid unnecessarily obscuring the invention.","Software platforms such as Java ME provide an attractive environment for developing mobile device applications. Rather than writing multiple versions of the software, each targeting a different subset of device architectures, a single Java ME application can run the same code on a wide variety of devices. This decreases time to market and development cost while increasing software reliability. However, some device features may not be available to applications in the virtual machine environment, even though the feature may be well supported on many devices.","Native code running outside the virtual machine can access such features, but providing this native code has proven difficult. Mobile device users frequently do not have the time or the interest to understand how native features would improve their virtual machine applications, to seek out and download native code providing those features, to verify that they have the proper version of the native code, to install it on the device, to configure their virtual machine applications for the use of this native code, and to keep the virtual machine and native code versions synchronized during upgrades. As a result, utilization of native code features by virtual machine applications remains low.","Techniques of the present invention enable packaging native program extensions with virtual machine applications. Native code providing access to native device features is bundled inside a virtual machine application. When the virtual machine application runs, it detects when an operation would benefit from or be enhanced by a native feature not offered by the virtual machine. The application extracts the bundled native code and installs it on the mobile device. The native code is then loaded into memory and executed on the device. The virtual machine application communicates with the native code using inter-process communication. This allows the application to send and receive messages requesting the native code to access native features and return any results. From the user's perspective, the virtual machine application provides the benefits of a native application without requiring any extra work from the user on some devices. Other devices may require minimal interaction, prompting the user only to approve the native code install. Updating the virtual machine application to a new version automatically updates the bundled native code as well, eliminating synchronization issues. In fact, some embodiments may operate so seamlessly that a user is unaware of the existence of native program extensions on the device.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1","b":["114","110","111","112","113","114","111","113"]},"The Java Virtual Machine itself comprises native code written for the device processor. Thus the Java Virtual Machine runs as a user process  on the device, just as an ordinary native program would. The term \u201cprocess\u201d here denotes a running program, while the modifier \u201cuser\u201d indicates that the program runs in an unprivileged mode that can not directly access some or all of the device hardware and operating system data structures. By contrast, a system process or kernel process has more privileges to directly access the hardware and data structures. Such privileged processes normally only run operating system code. A user process wishing to access the hardware does so indirectly through an operating system API. This is represented in the figure by operating system  sitting between user process  and hardware . Some operating systems do not enforce privilege separation. In this case, there is little distinction between user processes and system processes. Operating system  would still provide an API for interacting with hardware , but user process  could also access the hardware directly.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2","b":"201"},"The virtual machine application contained in application package  may need to access native features on certain devices. Native features are features provided by the device hardware or operating system to which the virtual machine does not grant access. Such features can be accessed by running native code outside the virtual machine on the mobile device. In some implementations, the native code is written for a particular device or class of related devices, such as devices sharing a common hardware architecture or operating system. In other implementations, the native code may run on a wide range of devices using a cross-platform compatibility library. In still others, the native code may include multiple native code files, each written for a different set of devices. For example, the native code may contain one file of native code for Blackberry devices, a second file of native code for Nokia devices, and a third for Motorola devices.","This native code is bundled  in the application package similar to other resource files as previously discussed. The application package may then be installed  on a mobile device. The installation method varies with the particular device and application package being used. Some devices simply copy the application package to local storage. Others may copy the application package to a certain location, such as a directory for application programs (much like the \u201cProgram Files\u201d folder on Windows). Still others may extract the individual code and resource files from the package or update a registry to indicate the application has been installed. For instance, installing a Java application usually involves copying the JAR file containing the application to a certain directory in the device's file system.","Whichever installation method a device implements, the user is typically shielded from the details. The user simply requests for the application to be installed and the system handles the rest. How this is done varies by device. On some devices, the user may so initiate installation by selecting the application package on a web page within the device's web browser. On others, the user may select the application package in a device synchronization program on a desktop computer.","Once the application is installed, it may be run  on the device. Parts of the application which use only features of the virtual machine can be used right away. For instance, if the virtual machine allows opening TCP\/IP connections, then the application may allow the user to engage in a wide range of activities enabled by such connections, e.g., check email, participate in instant messaging chats, or get weather updates.","However, some parts of the application require access to native features of the device. As an example, a mapping application may need to access GPS or cell tower data to automatically plot the device's current location. As another example, a messaging application may need to access the phone's Personal Information Management (PIM) data such as email messages or contact details such as names, addresses, and numbers. As a further example, an application may need to place or receive phone calls using the device. Native features can also include a storage location on the computing device, a Short Message Service (SMS) or other text messaging service, an image capture component such as a still or video camera, communication over a Universal Serial Bus (USB) port, or any number of other device features. If such a native feature of the device is not available within the virtual machine, then native code is needed to access that feature. The application detects whether access to a native feature is required . If not, the virtual machine application continues to run . Otherwise, the application checks whether the required native code has been installed  on the device before.","If the native code has not been installed previously, the application initiates the process by which the native code bundled with the application is made ready for use. The native code cannot be executed inside the virtual machine application. The native code comprises native machine instructions which run directly on the device processor. The virtual machine does not understand this code. Further, mechanisms to run the native code alongside the virtual machine such as JNI are not reliably present on every device. Therefore the native code should typically be run in a separate process.","Previously, setting up native code for use with a virtual machine application required an undesirable amount of manual intervention from the user. First, the application would have to make the user aware that certain features were unavailable. Then the application had to inform the user that the mobile device was capable of those features using native code. The user would then be informed that installing the native code would enable those features in the virtual machine application. Next the user would have to decide if the native features were worthwhile and whether to install the native code. If the user chose to proceed, he would have to locate the native code, download it, load the code onto his device, and initiate the installation process. A user might elect not to install the native code at any of these stages for a variety of reasons: worries about storage space, worries about insecure or malicious code, lack of time, not understanding the procedure, etc.","Techniques of the present invention allow installing and using native code without introducing the obstacles associated with these tedious and error-prone interactions. The application extracts the native code files for the current device from the application package , where they are bundled with other resources. The extracted native code can be stored in local storage, in memory, or anywhere else the device allows. Once extracted, the native code files will be visible to the operating system. The virtual machine application then installs the native code on the mobile device . This may performed directly by the application if the virtual machine allows the necessary operations. For instance, if installed code must be placed in a certain directory on the device and the application is allowed to create files in that directory, then the application may copy the extracted code there. More typically, however, installing code requires action by the operating system. In this instance, the virtual machine application would provide the operating system with the extracted native code files and request that they be installed.","Once installed, the native code must be loaded into memory  where it can execute. In certain embodiments, this involves launching a native program containing the native code. This creates a user process to run the native code separate from the user process running the virtual machine. On some systems, there may be little or no distinction between (file) storage and (process) memory, eliminating the need for this operation.","After the native code is loaded into memory and running, the virtual machine application can resume its execution. Now the virtual machine application may access the running native code  to gain use of native features. Access can occur through any type of inter-process communication allowed by the virtual machine. For instance, the native code process can open a network socket and listen for messages. When the virtual machine application requires a native feature, it can connect to the network socket and pass a message or data to the native code. The native code will process the data or message using the underlying device features which the virtual machine lacks. When the native code finishes processing the message or data, it can pass a result back to the virtual machine application over the network socket. The virtual machine application can then incorporate the result into the application.","An example may be instructive. Suppose as in a previous example that a mapping application in the virtual machine wants to show the device's current position on a map. However, the virtual machine does not support the device's GPS feature. After installing and loading native code as described, the mapping application can connect to the running native code over a network socket and request the current GPS data. The native code, which has direct access to the device's features, queries the GPS component for the current location. The native code then returns this data to the mapping application over the network socket. The mapping application displays a map showing the device's current location, using the GPS data which it could not access inside the virtual machine.","The virtual machine application and the native code may communicate through any type of inter-process communication on the device. Network sockets, local sockets, pipes, and shared memory are all contemplated, along with numerous other possibilities. The processes can even communicate through a file system, writing outbound messages to one file and monitoring another file for incoming messages. Many such techniques are well known in the art.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIGS. 3","FIG. 3","FIG. 1"],"i":["a","e ","a"],"b":["301","301"]},"Java Application  needs to use native features of the mobile device. To detect whether the required native code is installed, the application opens a local socket  and attempts to connect to a certain port. When the native code is installed and running, it listens for messages on this port. However, in this case the native code has not been installed. There is no native code process listening on the port. The application's attempt to connect fails.","Having determined that the native code is not available, Java Application  begins the install process. shows Java Application  running in device memory . Memory  is any type of memory suitable for executing processes. Typically, memory  might comprise volatile Random Access Memory (RAM) on the mobile device. By contrast, storage  represents nonvolatile memory for storing files and other persistent data on the mobile device. This is often implemented using flash memory, either built into the device or on removable media cards. Storage  contains Java Application Package , which is a JAR file containing the bytecode for Java Application  and other resources. One of those resources is Native Code . This native code is configured to run on the mobile device in a separate process outside the Java virtual machine. When executed, Native Code  allows Java Application  to access native features of the mobile device. To make the native code visible to the operating system, Java Application  extracts Native Code  from the Java application package and stores a copy Native Code  elsewhere in storage. For this example, Native Code copy  comprises a single file. Various embodiments allow multiple files, directory structures, embedded or archived files, and other combinations and variations known in the art.","In , Java Application  requests Operating System  to install the native code. Native Code  is installed in storage location Installed Native Code . The install process may involve a number of operations, including one or more of copying the native code files to a certain directory, extracting native code files from a native installer package (similar to a JAR file, but designed for native programs on a particular mobile device), updating system data structures such as a program registry, or executing pre- or post-install commands.","Requesting installation from the operating system is not as straightforward as it may appear. Java Application  can only interact with the operating system in limited ways. The MIDP\/CLDC environment provides no API for a java application to install another program, and the Java virtual machine does not allow direct access to operating system functions. To get around these limitations, Java Application  uses the MIDP function platformRequest. This method accepts a URL, which it passes to the operating system. The operating system invokes a handler based on the content type indicated by the URL. For instance, calling platformRequest (\u201chttp:\/\/www.yahoo.com\u201d) would ask the operating system to handle the URL \u201chttp:\/\/www.yahoo.com\u201d. The operating system might respond by opening the device's web browser and navigating to the given URL. Similarly, a call such as platformRequest(\u201ctel:+408-555-1234\u201d) might be handled by dialing the telephone number 408-555-1234 on the device.","Java Application  takes advantage of this feature by constructing a URL to the native code that triggers the system installation process. For example, phones based on the Symbian operating system use a package format called Symbian Installation Source (SIS). A SIS file contains a .pkg file containing installation information, native code, and other resources. When a Symbian device encounters a file or URL ending in .sisx (or the older .sis), it triggers the installation procedure on that object. Java Application  uses this to install the native code on a Symbian device. The Java Application creates a .sisx file when it extracts the native code to local storage. In this instance, Native Code  might be a file named nativecode.sisx containing the native code and other required resources (such as a .pkg file). Suppose the file is saved in a directory called tmp. Java Application  constructs the URL file:\/\/\/tmp\/nativecode.sisx pointing to the SIS file with native code in local storage. Then it calls platformRequest (\u201cfile:\/\/\/tmp\/nativecode.sisx\u201d) to pass this URL to the native handler. The operating system recognizes the URL ending in .sisx as a Symbian installation package and performs the installation procedure on the native code file.","After the native code is installed, it must be loaded into memory to execute. depicts this operation. The executable code is loaded from Installed Native Code  in storage  into memory . Here it executes in a user process as Native Code . Loading the native code may be performed by the operating system after the install. In some implementations, the operating system may load every program into memory immediately after installation. In others, the native code installation package may contain instructions to load the native code after the installation process.","Once Native Code  executes, it opens a local socket  and waits for messages from Java Application , as shown in . Java Application  now resumes running to contact Native Code . In implementations where the mobile device supports concurrent processing, Java Application  may periodically attempt to connect to socket  after initiating the native code install. Alternatively, Java Application  may suspend execution until receiving an indication that Native Code  is ready to receive messages. When both processes are ready, Java Application  opens socket  and connects to Native Code  at socket  on a given port. The application and the native code exchange messages as described herein to allow the Java application to access native features of the mobile device. The message protocol may be application-dependent or an already standardized protocol like Obex. Those of skill in the art will realize a wide range of possibilities.","Although certain devices and environments have been assumed for explanation purposes, embodiments of the present invention may be employed in any of a wide variety of computing contexts. For instance, the user application described need not run inside a virtual machine. Some environments provide sandboxing of native code applications. Although the sandboxing techniques may differ greatly, the end result to the application is virtually the same. The invention can be readily practiced in any environment which restricts access to system features. The restricted environment need not even be explicitly sandboxed. For example, a Python or Ruby application runs in an interpreter which may not provide full access to the underlying system. The techniques described herein may be used just as effectively in those types of environments.","Similarly, the invention is not limited to mobile devices. Those devices provide a useful example of an environment where virtual machine applications are preferable to native ones. However, the present invention may be practiced on any type of computing device, as illustrated in . Implementations are contemplated in which the relevant population of users interact with a diverse network environment via any type of computer (e.g., desktop, laptop, tablet, etc.) , media computing platforms  (e.g., cable and satellite set top boxes and digital video recorders), handheld computing devices (e.g., PDAs) , cell phones , or any other type of computing or communication platform. Many consumer media devices such as televisions, satellite receivers, cable boxes, digital video recorders, DVD players, and the like now ship with an embedded Java virtual machine. The advantages of the present invention on such devices are even more pronounced, where downloading and installing native extensions independently of a java application may prove difficult or impossible.","In addition, the computer program instructions with which embodiments of the invention are implemented may be stored in any type of non-transitory computer-readable storage media, and may be executed according to a variety of computing models including a client\/server model, a peer-to-peer model, on a stand-alone computing device, or according to a distributed computing model in which various of the functionalities described herein may be effected or employed at different locations.","While the invention has been particularly shown and described with reference to specific embodiments thereof, it will be understood by those skilled in the art that changes in the form and details of the disclosed embodiments may be made without departing from the spirit or scope of the invention. In addition, although various advantages, aspects, and objects of the present invention have been discussed herein with reference to various embodiments, it will be understood that the scope of the invention should not be limited by reference to such advantages, aspects, and objects. Rather, the scope of the invention should be determined with reference to the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
