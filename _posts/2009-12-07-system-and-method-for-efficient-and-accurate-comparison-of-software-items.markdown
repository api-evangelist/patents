---
title: System and method for efficient and accurate comparison of software items
abstract: Apparatus, processes, and related technologies for comparison between a target item of software code and a reference set of software code. The target item is preprocessed to be compared against a reference item from the reference set to identify a selected set of lines of software code from the target item to be used for the comparison. Each line of the selected set of lines from the target software item is individually compared with lines of software code from the reference set to produce a measure of similarity between the target software item and at least one reference item of software code from the reference set. Various techniques for maintaining and updating a numerical representation of similarity of the target item with each reference item, the numerical representation being stored in a corresponding element of a data structure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08499167&OS=08499167&RS=08499167
owner: Kaspersky Lab ZAO
number: 08499167
owner_city: Moscow
owner_country: RU
publication_date: 20091207
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FOREIGN PRIORITY","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS","Examples of Computer Systems on Which Embodiments of the Invention may be Implemented","Examples of Algorithms that may be Implemented Computer Systems Such as Those Described Above"],"p":["This Application claims priority to Russian patent application No. 2009136236, filed Oct. 1, 2009, and entitled \u201cMethod for Comparing an Unknown File to a Collection of Files Based on a Degree of Similarity.\u201d","The invention relates generally to computing and information processing. More specifically, this invention relates to systems and methods for the efficient comparison of files line-by-line to determine their similarity or non-similarity.","Harmful computer programs such as viruses, spyware, malware and others have been prevalent in the computing industry since at least the early 1970's. With each iteration in the development cycle of computer hardware and software, these harmful programs developed as well. The early harmful programs were somewhat more controllable, as system administrators could guard the limited entry points into their computers and computer networks. However, with the advent of the interne and the greater movement towards hyper-connectivity the task of guarding against the various harmful programs became a priority for both enterprise and consumer users.","Several companies, including Kaspersky, Symantec, McAfee, Panda, and Eset, created programs aimed at providing solutions to the problem of harmful programs. Several other programs were tailored to be attachments or plugins to specific network hardware devices or software packages, for example Upload Processor from MSmac Software was an application for uploading attachments to bulletin boards that would perform a virus scan of any identified upload before performing the transaction.","Although programs were developed to thwart and protect against known types of threats, the next wave of harmful programs were more advanced and were able to work around some of the detection and protection mechanisms put in place. These initial adaptations signaled the beginning of an \u201carms race\u201d in computer protection. Security firms are now locked in a race to protect against the rapidly maturing and developing world of harmful software. Each year this race becomes more and more relevant as the world becomes increasingly reliant on computer systems and infrastructure. It is estimated that harmful computer programs cause billions of dollars in damages each year. Further, cyberattacks and other forms of cyberwarfare utilizing harmful computer programs are major considerations in the defense and protection of various countries around the world.","One of the principle challenges in the development of protection and detection software is how to reduce false positives, which occur when a program or process is labeled as harmful when it actually isn't; and false negatives, which occur when a program or process is deemed safe when it is actually harmful. The false-positives and false-negatives directly impact the overall success rate of the product and directly impact computer systems and functionality. False positives effectively prevent a user from utilizing legitimate software in their systems. Thus, too many false positives can greatly impact the normal workflow operations of businesses and individuals alike and result in a switch to a different program for protection and detection, or even an abandonment of the protection and detection software altogether by users. The abandonment of the protection and detection software is of particular concern in the present day as it opens the door for many types of attacks including those that turn the user's computer into a \u201cbot,\u201d or \u201cdrone\u201d of harmful activity that spreads worms or attacks other machines on its network or on the Internet.","False negatives are equally problematic in that the user will not be warned of a harmful program and\/or will not have the option to prevent the program from executing. The result may be devastating, as the computer user believes they are protected from harmful programs which are, in fact, potentially executing on their machines. These \u201cprotected\u201d computers may then also become bots or drones, proliferating harmful activity.","In both the false positive and false negative situations, there remains the possibility of the additional costs of lost productivity, lost information and information exploitation as a result of the actions of the harmful programs. These additional costs have both immediate ramifications and potential to require businesses and individuals to make significant changes in their daily operations. Thus, many software suppliers offer appliances and applications that aim to reduce the false designations. However, these offerings have proven to be inefficient in providing protection due to long processing times as a result of overly complex algorithms, inaccurate detection methodologies and short lifespan due to lack of flexibility in addressing new threats.","Thus, a need exists for a fast, efficient and accurate method to detect harmful software that is able to adapt to the continually changing face of computer protection.","Aspects of the present invention substantially addresses limitations of existing methods of determining similarity of unknown, or target items of software, to previously analyzed, known, or more generally, to reference items of software (such as malicious or harmful software, or known benign software, for example). Efficient techniques and apparatus are described in detail below that compare software items to determine incidence of entire lines of software code of the target software items in the reference items of software. The techniques of the present invention increase comparison performance maintaining flexibility in adapting to variability in software structure and information content.","According to one aspect of the invention, a machine-implemented process for performing a comparison between a target item of software code and a reference set of at least one reference item of software code is provided. It should be understood that each of the target item or reference items of software can be in the form of files stored in a file system of a computer, or each can be portion of a file, or can span multiple files.","According to this process, the target item is preprocessed by a data processing machine, such as a computer system, for example, prior to executing the comparison operations. The preprocessing includes automatically analyzing the target item for a presence of any lines of software code that tend to reduce sensitivity of the comparison, and selecting a relevant set of lines of software code from a remaining portion of the target item to be used for the comparison.","In various embodiments, software code that tends to reduce the sensitivity of comparison may include a variety of instructions or data that are determined to have little or no effect on the unique functionality of the target item of software. For example, the preprocessing can be adapted to identify metadata generated during compilation of the software code, comments in source code, program header information, or header application stubs, which do not provide a functional effect in the operation of the target item. In another example, the preprocessing can be adapted to identify well-known portions of functional software code that are generated from the use of standard programming libraries or well-known functions or objects. Thus, in the context of the same example, when comparing a target item against known reference items of benign software, for instance, the presence of standard library code in the target item of software may tend to increase the measure of similarity between the target and reference items that are likely to also have such standard content, thereby reducing the sensitivity of the comparison in detecting differences that may be attributable to malware infection in the target item of software. Preprocessing to identify such content can therefore improve performance of the comparison operation that will follow. It should be noted that the reference items of software may have already been separately preprocessed in the same manner, or in a different manner.","Each of the relevant set of lines from the target software item is individually compared with lines of software code from the reference set to produce a measure of similarity between the target software item and at least one reference item of software code from the reference set. The comparison can be performed using a data processing machine that is either the same data processing machine used to perform the preprocessing, or a different data processing machine altogether.","In a related aspect, the preprocessing of the target item further includes separately compressing each line of the relevant set of lines selected from the target software item using a compression algorithm, such as a hashing algorithm, to produce a compressed set of lines from the target item of software. In this case, each line of the compressed set of lines from the target software item is separately compared with compressed lines of software code from the reference set, with the compressed lines of software code from the reference set having been compressed using the same compression algorithm used in the preprocessing of the target item.","In another related aspect of the invention, a data structure is generated having elements corresponding to each reference item of the reference set. As each line of software code of the target software item is compared against the set of reference items, a numerical representation of similarity of the target item with each reference item is stored (or updated) in a corresponding element of the data structure.","In another aspect of the invention, apparatus for performing a comparison between a target item of software code and a reference set of at least one reference item of software code includes a computer system including at least one processor and a data store. The computer system includes a preprocessing module, a comparison module, and an output data store. Each of the modules is either implemented as computer hardware, or as a combination of hardware and software that establishes operation of the hardware.","The preprocessing module is adapted to preprocess the target item to be compared against a reference item from the reference set to identify a selected set of lines of software code from the target item to be used for the comparison. The comparison module is adapted to individually compare each line of the selected set of lines from the target software item with lines of software code from the reference set to produce a measure of similarity between the target software item and at least one reference item of software code from the reference set. The output data store is adapted to store a data structure having elements corresponding to each reference item of the reference set. A numerical representation of similarity of the target item with each reference item is stored in a corresponding element of the data structure.","A number of advantages can be realized utilizing various embodiments of the invention such as, for example, quicker detection of harmful programs before they execute on a computer system. Additionally, benefits provided by aspects of the invention may include a lower false-positive and false-negative determination rate as compared to conventional methods of file comparison present in the art. Further, various the implementations may enable the line-by-line comparison of two file collections, either known or unknown, to determine their similarity in an efficient manner. Other advantages will become apparent from the following description of aspects of the invention.","Various embodiments may utilize database tables, collections, arrays, hash-tables or other data structures to store the result of the preprocessing, or the result of the comparison, or both, in memory or in other storage media.","Certain embodiments utilize an indexing system such as item-hash or hash-item data structures or both, to store the reference items of software. The item-hash data structure may associate a particular item with several lines of each item of software that has been compressed by a hash function such as SHA-1, MD5, CRC32, or the like. The hash-item data structure may associate lines of various items of software that have been compressed by a hash function such as those exemplified above, to the various items of software that contain the lines.","Various embodiments determine the similarity of a target item of software to each of the reference items utilizing line-by-line comparison. These embodiments utilize the file-hash structure of the preprocessed item of software to take the first preprocessed line from the target item of software and query the reference data structure to look for items that have the same line as indicated by a matching hash value. After all reference items with the same line have been identified; the corresponding similarity value stored in the similarity data structure is incremented. This process continues until all preprocessed lines of the target item of software have been compared against the reference data structure. Thus, after completion, the similarity data structure has various values that collectively represent a measure of the target item's similarity to each of the reference items.","Thus, various embodiments facilitate efficient determination of similarity of unknown or target items of software to reference items, which then can be utilized for a variety of uses, such as to block harmful or malicious programs from entering or executing on a computer. In other embodiments, the determination of similarity may be utilized to determine the similarity of a collection of unknown files to a collection of identified files in an efficient manner. In these embodiments, the procedure outlined above would be executed for each file in the collection of unknown files.","While the invention is amenable to various modifications and alternative forms, specifics thereof have been shown by way of example in the drawings and will be described in detail. It should be understood, however, that the intention is not to limit the invention to the particular embodiments described. On the contrary, the intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the invention as defined by the appended claims.","Introduction to Aspects of the Invention","Software programs are typically developed utilizing assembly code or high-level languages, and subsequently assembled or compiled into binary executable form. A variety of high-level programming languages such as JAVA\u00ae, Delphi, C, C++, C#, Perl\u00ae, Ruby\u00ae, Grails\u00ae, Python\u00ae, Visual Basic, and a myriad of others, or even a combination of different languages, may be utilized in creating source code and, ultimately, executable code for a program.","Aspects of the invention recognize that the functionality of programs, regardless of whether they exist as pre-compiled source code, runtime-executable code, or compiled executable code, such as portable executable code or machine code, generally consists as a series of individual instructions and arguments corresponding to instructions that are arranged in a line-by-line fashion. Each line of source code or executable code either constitutes a certain instruction, or corresponds to one or more instructions in some way. Accordingly, each line of a piece of software can be regarded in a general sense as an element of the software's functionality.","The same principle applies to malicious programs such as viruses, Trojans, keyloggers and other malware, which are also developed as pieces of software in which elements of functionality are represented line-by-line. These malicious programs may be developed from scratch, but sometimes they are altered legitimate or \u201coriginal\u201d programs that appear benign, but actually contain malicious code. In some cases, legitimate files are substantially modified by code being injected into the main body of the program. In other cases malicious code alters the initial portion of the file and intercepts all interactions with the legitimate file. Further, in the process of making a malicious program, a legitimate program may be decompiled from the binary executable, modified and recompiled or it may be altered in the binary state by a person having skill in the art that is able to navigate the binary signature and alter how the file is executed. However, an alteration of this type would affect the resultant decompilation of the program, thus altering certain lines of the line-by-line composition, but not others.","Aspects of the invention are directed to a line-by-line similarity analysis in which a software item of interest, referred to herein interchangeably as an unknown, or target software item, or target file, is compared to a reference software item (referred to herein interchangeably as a reference file or known or previously analyzed file) in an efficient manner utilizing line comparison. The various techniques can be applied in a variety of uses, including determining a level of security risk associated a target software item by comparing the target software item to known malicious software items, or known benign software items. A high degree of similarity of the target file and the known malicious file indicates a high probability of maliciousness while a low similarity indicates a benign or legitimate target file. The various techniques may be applied in areas other than computer security while still enjoying the benefits of efficiency provided by aspects of the invention.","Importantly, it should be understood that it is immaterial to the spirit of the invention as to where, or in what manner, the target software items and reference software items are stored or maintained. In various embodiments, software items may constitute files stored in the computer system's file system, or may be sets of data stored as part of one or more files, or loaded into RAM, a data buffer, or any other practical medium, whether local to the computer system, or located remotely, that is accessible to the processor of the computer system performing the similarity analysis.","The lines of the target or reference software items include a series of data symbols, such as bit sequences or strings, having a recognizable starting point and termination point. In the case of high-level program source code, lines may be terminated by a line feed character, and the start of each line is determinable either at the start of the software item or file, or following a line terminator. It should also be understood that line terminators may be explicit, as in the case with \u201c\\n\u201d or \u201c.\u201d character, or may be implicit, as in the case of fixed-length lines, or machine-executable code, where each instruction has a predefined number of bits (e.g., lines consisting of n bits in the case of machine code compiled to run on an n-bit processor).","Referring to , various computer-based embodiments of systems for determining similarity between files utilizing line-by-line analysis are described.  illustrates a relatively high-level architecture of a computer system programmed to perform comparisons between target and reference software items according to one embodiment. The computer system includes preprocessing module  and comparison module , along with various data storage facilities described below, and other facilities that are not shown in  but that are described below in connection with , such as input\/output, user interface, networking, and the like.","Each of the data storage facilities can be allocated in one, or a combination of, RAM, magnetic or optical disk, flash, or any suitable medium for storing data. Preprocessing module  includes processor that is programmed to read input data store  (from which it obtains a target software item or items), and reference data store , from which one or more reference software items are read. Processor reads preprocessing operating instructions from data store , and processes data according to those instructions. The output from processor is written to output data store . Operating memory data store  is allocated for use as a temporary scratchpad memory during execution of the preprocessing instructions.","In general, preprocessing module  operates to arrange the target software item(s) and, if not already preprocessed, the reference software item(s) into a form or representation that facilitates more effective or efficient comparison. As will be detailed below, preprocessing that may be performed by preprocessing module  can include operations to format, convert, compress, or prune the data being preprocessed.","Comparison module  includes processor that is configured to execute comparison operating instructions from data store . Processor may also utilize Operating memory data store  during execution of the comparison operating instructions. Data store  is used to store the output of the comparison module . Comparison module  operates on preprocessed software items to render a comparison between at least one preprocessed target software item and at least one preprocessed reference software item.","In one type of embodiment, processor and processor are the same processor. In this regard, preprocessing module  and comparison module  can share at least some of their hardware. In a related embodiment, all of the hardware devices are common among both, the preprocessing module , and comparison module . Accordingly, in one type of embodiment, the computer system is implemented in a single computer system. In another type of embodiment, however, the system may be implemented utilizing a system of more than one distinct computer, communicatively coupled with one another.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIGS. 2A and 2B","FIG. 2A"],"b":["200","202","204","206","208","210","212"]},"The computer network  is utilized to provide interconnectivity between the application server , administrative server  and client computers ,  and . In this way, the system  utilizes the computer network  as a platform to connect otherwise disconnected computers and computer networks and allows network capable devices to send and receive information and connect to programs and services made available.","The application server  may include a database component and an application\/web server component. In this embodiment, client computers ,  and  may connect to the application server  to obtain information relating to already identified known files. Further, the application servers may utilize database software such as MySQL\u00ae, Microsoft\u00ae SQLServer\u00ae, Oracle\u00ae, Postgres, Ingres\u00ae, hashfiles or a combination thereof, to store information relating to the files. In other embodiments the application server  is connected via a distributed network utilizing various architectures such as Client-Server, N-Tier, P2P, cloud or cluster. Further, application server  may be a standard desktop computer or may utilize high-end server hardware. A person having skill in the art will appreciate that the application server  will utilize hardware that is most appropriate for its load and performance requirements whether that be a the mini-ITX form factor, Extended ATX, blade or other configuration. Further, the servers may utilize Intel or AMD, or other processors, Double Data Rate (DDR) memory, Error Correcting memory (ECC), rotational or Solid State Disk (SSD) arrays and other hardware to ensure optimum performance and reliability in operation and storing of data. Further, the application server  may utilize enterprise-class software such as Linux\u00ae, Unix\u00ae or Windows\u00ae Server operating systems. Additional application server  may be utilized in load-balancing or cluster configurations in order to handle increased load and to maintain system performance as the number of requests to the application server  increase. In other embodiments, the application server  instructions are stored in the client computer's ,  and  memory.","The administrative server  may be a server located at an external service provider or computer software provider. The administrative server  may validate client computer's ,  and  license information when attempts are made to retrieve information relating to identified files from the application server . The administrative server  may be configured to utilize hardware and software similar to the application server  above. In one embodiment the administrative server  and the application server  may utilize the same hardware to which the client computers ,  and  connect. In this way, the administrative server may operate to identify computers authorized to utilize the various embodiments disclosed herein.","Client computers ,  and  may be personal desktop computers, personal laptops, netbooks, servers, UMPCs, smartphones such as the iPhone\u00ae from Apple\u00ae or Pre\u00ae from Palm\u00ae or other devices. In various embodiments, the client computers may utilize, Double Data Rate (DDR) memory, Error Correcting memory (ECC), rotational or Solid State Disks (SSD) to store the information relating to identified files. Client computers may utilize software such as Linux\u00ae, Unix\u00ae or Windows\u00ae or Apple\u00ae operating systems. Further, as disclosed above the client computers ,  and  may utilize database software such as Microsoft Access, MySQL lite, SQL Server Express, IBM DBS Express, hash files or a combination thereof to store information relating to identified files in a lightweight structure allowing for fast retrieval of identified file information.","Now referring to  another embodiment of a system  for determining similarity between files utilizing line-by-line analysis is presented. This embodiment includes computer network , application server , administrative server , client computers ,  and  and network appliance . In this embodiment, client computers ,  and  operate on a Local Area Network (LAN). Further, the LAN may utilize a firewall, router, server or other network appliance  to filter access to network resources. In this embodiment the application server  may be embedded into the firewall router, sever or other network appliance . Further, the client computers ,  and  may request identified file information from the local appliance . In other embodiments, communication with the application server  may be moderated by the administrative server . This way, access to identified files stored in the application server  may require authentication from the client computer ,  and  to pass through the administrative server . In this way, access to identified file information can be secured.","In various embodiments, the client computers ,  and  may be configured to run software applications developed in a variety of programming languages including JAVA\u00ae, Delphi, C, C++, C#, Perl\u00ae, Ruby\u00ae, Grails\u00ae, Python\u00ae and others. Thus, the methods for line-by-line comparisons may be implemented at least partially in a variety of programming languages and executed on client computers. In certain embodiments client computers ,  and  utilize a TCP\/IP link to connect to the application server  to obtain file information. In other embodiments, the client computers ,  and  utilize a web service to obtain file information. The web service may utilize TCP\/IP including HTTP and implement SOAP, or may utilize a RESTful architecture for queries and response. Further, the web service may be secured by utilizing secure web service technologies such as XML encryption, XML signatures, Secure Socket Layer (SSL), Transport Layer Security (TLS), Hypertext Transfer Protocol Secure (HTTPS) or HTTP Authentication. In this embodiment, client computers ,  and  format messages containing requested file information and send it to the application server  which processes the message and returns the requested information.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 3","b":["300","300","302","302","304","306","308","310","312","314","316","318","320","304","306","316","318","302","306","322","324","322","326","302","324","328","330","332","324","334","324","324","2","3","306","304"]},"The removable  and non-removable  memory interfaces may couple the computer  to disk drives  such as SSD or rotational disk drives. These disk drives  may provide further storage for various software applications such as the operating system , application programs  and other program modules . Further, the disk drives  may store other information such as program or application data . In various embodiments, the disk drives  store information that doesn't require the same low-latencies as in other storage mediums. Further, the operating system , application program  data, program modules  and program or application data  may be the same information as that stored in the RAM  in various embodiments mentioned above or it may be different data potentially derivative of the RAM  stored data.","Further, the removable non-volatile memory interface  may couple the computer  to magnetic portable disk drives  that utilize magnetic media such as the floppy disk , Iomega\u00ae Zip or Jazz, or optical disk drives  that utilize optical media  for storage of computer readable media such as Blu-Ray\u00ae, DVD-R\/RW, CD-R\/RW and other similar formats. Still other embodiments utilize SSD or rotational disks housed in portable enclosures  to increase the capacity of removable memory.","The computer  may utilize the network interface  to communicate with one or more remote computers  over a local area network (LAN)  or a wide area network (WAN) . The network interface  may utilize a Network Interface Card (NIC) or other interface such as a modem  to enable communication. The modem  may enable communication over telephone lines, coaxial, fiber optic, or powerline. The remote computer  may contain a similar hardware and software configuration or may have a memory  that contains remote application programs  that may provide additional computer readable instructions to the computer . In various embodiments, the remote computer memory  can be utilized to store information such as identified file information that may be later downloaded to local system memory . Further, in various embodiments the remote computer may be the application server , administrative server , client computers ,  and  or network appliance .","A user may enter in information to the computer  using input devices connected to the user input interface  such as a mouse  and keyboard . Additionally, the input device may be a trackpad, fingerprint scanner, joystick, barcode scanner, media scanner or the like. The video interface  may provide visual information to a display such as a monitor . The video interface  may be an embedded interface or it may be a discrete interface. Further, the computer may utilize plurality video interfaces , network interfaces  and removable  and non-removable  interfaces in order to increase the flexibility in operation of the computer . Further, various embodiments utilize several monitors  and several video interfaces  to vary the performance and capabilities of the computer . Other computer interfaces may be included in computer  such as the output peripheral interface . This interface may be coupled to a printer  or speakers  or other peripherals to provide additional functionality to the computer .","Various alternative configurations and implementations of the computer  are within the spirit of the invention. These variations may include, without limitation, additional interfaces coupled to the system bus  such as universal serial bus (USB), printer port, game port, PCI, PCI-X PCI Express or integrations of the various components described above into chipset components such as the northbridge or southbridge. For example, in various embodiments, the processing unit  may include a memory controller (not shown) to enable more efficient transfer of data from the system memory  than the system bus  may provide.","According to one aspect of the invention, two program files may be determined to be similar if:\n\n()>(),\n","where:\n\n","In other words, two files are similar if the number of lines that are present in both of the files exceeds the number of lines that are present in only one of the files. To further enumerate the concept, a level of similarity can be determined by utilizing the following relationship:\n\nsimilarity=()\u2212()=()\u2212(()+())=()\u2212(()\u2212()+()\u2212())=3*()\u2212()\u2212()\u2003\u2003(1)\n","A resultant positive value is an indication that the files are similar. A visual depiction of one embodiment of a determination of similarity is illustrated in . The result  after comparison of files indicates lines present only in the first file  and only in the second file . These lines can be compared with the lines common to both files . By utilizing the first line in equation (1) above, similarity is equal to the number common lines minus the number of lines that are not similar. Therefore, in this example the files are considered similar, as P(A\u2229B)\u2212P(A\u0394B)=8\u22123=5. Since the number of lines similar minus the number of varying lines is greater than zero, the files are deemed to be similar.","In certain cases, determining similarity based on the number of similar lines as in the first line of equation (1) as disclosed above, may not be sufficient in determining the maliciousness of target files. The cases where a strict similarity approach may be problematic is exemplified in . Referring to A, a target file  has been altered; however the alterations have only made minor changes to the file. Thus, if the target file is compared to a known \u201cclean\u201d file, utilizing the first algorithm above, the similarity would be positive due to the relatively minor changes in the file. The portion of the target file  that are clean  and  would be much greater than those that are infected . Thus, the number of lines that are the same as the identified file would be much greater than any differences, resulting in a determination that the file is clean. Often, files with such minor differences would be skipped by scanners and anti-virus programs in order to reduce the possibility of false-positives.","It should be noted that in various embodiments, the analyzed files are portable executable (PE) files. These files are common in windows operating systems and help define the operating parameters of the file. Thus, PE files may include a PE header with which the beginning and the length of the file can be determined by examining the PE header. In this way, by utilizing the PE header information a scanner can obtain additional file information which can then be leveraged in determining similarity.","Another embodiment, shown in  exhibit similar problems when utilizing the measure of similarity outlined above. In some situations a virus or malicious program will infect a clean file . The result of this infection is a modification of the original clean file  into an infected file  having a malicious portion  and the unaffected clean file portion . Often, in this situation, the file will appear normal to the end-user. The icons and filenames will appear as any other program or even the clean version; thus the end-user may execute the file without exercising caution even though the file contains a malicious payload.","Further, when a file is affected in this manner, the legitimate or clean portion of the file will often be executed after the malicious portion. In this way, the subterfuge is complete, i.e., the end-user sees a legitimate file and it executes as the legitimate file would. However, the malicious portion has also been executed as a result of the end-user's action. This configuration also leads to problematic determination utilizing the similarity equation disclosed above. It is possible that one could have an unknown target file that is clean . However, if this clean target file was compared to a known malicious file  which was configured with a malicious portion  and then the clean portion , the file would be determined similar due to the greater number of similar lines. Thus, this clean target file would be classified as malicious.","In various embodiments, a comparison of truncated files is implemented. A pre-execution comparison will examine the target file for the PE-file information, such as the PE-header, in addition to the overall file comparison. When the PE-file information is found by the scanner or process, the file is truncated and then compared with the known truncated malicious files. Thus, in this embodiment, clean file  will be compared with target file  first and then the target file  will be truncated and clean file  will be compared to the truncated malicious portion . In this situation, the truncated target file and clean file will not be highly similar because the truncated analysis will return little similarity.","A related type of embodiment addresses the situation depicted in D and E, where a malicious code overwrites a portion of a file , resulting in a target file  with a malicious portion  and a clean portion . In this situation, the target file  will appear similar to a legitimate file , which has a legitimate first  and second  portion. Further, in this situation, the normal function of the file being overwritten is destroyed and in cases where a PE-header is present, this information may be destroyed or overwritten as well.","In one such embodiment, a process similar to the one described above is utilized to determine similarity. A portion of the target file  may be truncated and compared against the legitimate file . In this embodiment, the target file  would not be truncated when the PE-header information is first determined; the target file  would be truncated at the end of the initial PE-file as determined in the header, if available. This would result in the malicious portion  being compared to the legitimate file . As a result of this comparison, the files would not be determined as being similar.","While the determination of similarity described in the first line of equation (1) above is sufficient in determining the similarity between files in certain situations, it may be insufficient in others. Thus, in order to further reduce the number of false-positives and false-negatives and increase the efficiency of determining similarity utilizing line-by-line comparisons, various other embodiments of the invention utilize phased matching.","Phased matching, according to these embodiments, determines the similarity of files, on a line-by-line basis, in phases. These phases include preprocessing, building and accessing a database of file information, and searching for and identifying similar files. In various related embodiments, there may be additional steps such as database optimization or data caching in order to further increase performance and efficiency.","In certain embodiments, the operation of phased matching may be altered utilizing configuration variables that may alter the execution of the phases. For example, configuration variables may alter how many hardware resources such as memory or clock cycles are devoted to phased matching.","In related embodiments, phased matching is implemented on multi-core processors; thus configuration files may determine how many cores to utilize, and in some embodiments, how many threads to execute on each core. The configuration files may be utilized to alter the location of the database such as a local directory or a remote directory on a network. The configuration files may indicate a timeout, or expiration of data within the database. The configuration files may be text files utilizing name-value pairs, text\/xml files, or a database table that stores the configuration information or take any suitable form currently known in the art, or later developed.","Preprocessing, according to various embodiments, analyzes the files and extracts relevant lines therefrom to be further processed in later phases. In various embodiments, the preprocessing phase may be performed by a stand-alone computer system, an application server, client computer, or other computer having a data store capable of storing preprocessed file information.","According to various embodiments, preprocessing may include parsing a file line-by-line and evaluating its contents against a set of comparisons or standards, and extracting the lines that meet the requirements. For example, lines can be extracted if: string characters adhere to standard code library conventions (C, C++, Java and similar), lines are longer than four characters, lines end with \\0, \\r, \\n or end of file (EOF). In various embodiments further criteria may be employed such examining for the presence of UNICODE or ASCII characters.","In some cases, the files to be compared are received in a packed, or compressed state. In these situations, in order to preprocess the files, the files are first unpacked or de-compressed prior to analysis. In various embodiments, the files are unpacked utilizing an anti-virus engine's unpacker. Anti-virus engines such as Symantec, McAfee, Eset, Kaspersky and others contain unpackers that enable the scanning of files for virus information. Other embodiments utilize an emulation engine to execute files in a contained space, thereby obtaining executable code corresponding to the file, stored in memory in the emulation space. Others embodiments make use of memory partitioning, and others still may utilize third-party packing and packaging utilities such as ASPack or diPacker to unpack the files for analysis.","Additional restrictions or exceptions may be added within the spirit of the invention in order to make the process more efficient in extracting the lines of a target file that provide the main functionality of the file. For example, not all lines in the target file will provide functional aspects to the file itself and thus additional restrictions or exceptions may be added to the preprocessing stage to remove these lines. For instance, many lines of compiled DELPHI code may be devoted to DELPHI maintenance operations or compilation, and not to the functions of the file. This is true for other compiled languages such as C, C++, Java and the others mentioned above which may have several lines in a file that are compilation-related metadata or artifacts.","In other instances, several lines of a target file may be non-functional documentation. Further, packing and packaging utilities may add lines of code to the target file, which may provide functionality to the packing or packaging utility, but not to the functionality of the program itself Restrictions or exceptions of this type may be predetermined manually by a file analyst that recognizes similarities in files, and added to a library of preconfigured rules that identify benign content for automatic detection of such content. For example, an analyst may identify similar lines in files created by the same packing utility or the same packing utility but different versions.","Alternatively, the phased matching process may include an automatic analysis portion that operates to recognize lines added by various packaging or packing utilities and versions, based on the preconfigured rules. Other restrictions or exceptions include headers added by ZIP, RAR or other compression utilities, common imported libraries in C, C++, Java and other languages, lines with names of common imported functions. The preprocessed lines that fall under the restriction or exception list are ignored and are not extracted for further analysis.","In another type of preprocessing, according to one type of embodiment, a compression algorithm or a hash function (such as CRC32, SHA-1 or MD5, for example) is applied to each line subject to comparison in order to increase the performance of the comparison operations and facilitate more efficient storage of those lines.","Now referring to  the phase of building and accessing a database of file information according to one type of embodiment is presented. In various related embodiments, the building and accessing of a database may be performed by a stand-alone computer system, or by an application server, client computer, or other computer having a memory capable of generating the file information. After the file is processed line-by-line, the extracted relevant lines and their associated hashes are entered into a database. The line hashes created in the preprocessing stage are inserted into an array that utilizes a file ID such as filename and then stores the associated hashes in as file-hashes relationships  as shown in .","In various related embodiments, these file-hashes relationships  allow for the efficient recovery of each item of functionality corresponding to an extracted line of a file. For example, a file having a file ID of FileID might have lines indentified in Hash, Hash . . . HashN and a file with file ID FileID might have lines indentified with Hash, Hash . . . HashK.","Further, various related embodiments create a database of file information that utilizes the line hashes and stores the associated file IDs in hash-files relationships  as shown in . These hash-files relationships  allow for the efficient recovery of all file IDs that have the hashed line present therein. For example, a hash with hash value Hash might be indentified in a file with a file ID of FileID and FileLID. Thus, in various embodiments, a program or analysis can find all hashed lines by file ID or all file ID by hash lines.","Now referring to , embodiments of performing the comparison are described. After the databases containing identified file information are created in the preprocessing phase, the process of searching for and determining similarity can be performed. In various embodiments, searching for and identifying similar files may be performed by a stand-alone computer system, or by an application server, client computer, or other computer having a memory capable of storing file information and a processor capable of line-by-line file analysis.","A new array is created with a size equivalent to the number of files present in a known database or collection of files to be searched for similarity at process block . The collection may be the database of known malicious files. After completion of the search or identification, this array will represent the similarity values of each file in the collection to a target file presented for search or comparison. The array is then populated with negative values corresponding to the number of lines present in each of the files of the collection of files, as indicated at process block  in order to prepare a first part of the baseline values. Next, the target file or file under investigation may be unpacked or decompressed at process block . The line-by-line extraction or preprocessing is performed at process block . The values in each cell of the array are further decremented by the number of lines in the file under investigation to be used for comparison . Each cell of the array is now populated with a baseline value equal to the negative value of the sum of the lines in the file being investigated and the corresponding file of the collection against which the file being investigated will be compared. This is the value of maximum dissimilarity for each file comparison.","The determination of similarity is generated when each extracted line is compared against the identified file collection at process block . For instance, a line from the target file may have a hash value of Hash. By utilizing the hash-file described above, the identified files that contain the same line corresponding to the hash value Hash as in the target file can be identified quickly. Thus, the line comparison  proceeds to obtain each next line at process block  (assuming decision  determines that there is at least one more line remaining in the file) and finds all the files in the collection that have the same line by looking at the database or collection of identified files at process block . In the case where a file in the collection or database of identified files has the same line (i.e. equal hash value), the corresponding array value for that file is incremented at process block . In accordance with equation (1), the value in the array element would be incremented by three for each line found to be the same. Upon completion, the line comparison process block  returns and checks whether the end of the file has been reached at decision , if not, the next line is accessed at process block  and the process continues. If the end of file has been reached the check at decision  will signal the end of the process, as indicated at block .","At the end of the process detailed in , the new array is populated with the similarity values of the target file compared to the identified files in the database or collection. This process is efficient in that the number of operations required equals the sum total of the popularity of the target file lines found in the database. For example if the target file has three lines found respectively in 1000 files, 10 files, and 100 files in the collection, the number of operations performed in the line comparison process block  of  would be 1000+10+100=1110 operations. Further, the more positive the values in the array, the more similar the target file is to the file in the database. If the array stores a negative value, the files are not similar, while the positive values indicate that the target file is similar to the identified file in the database associated with that array index.",{"@attributes":{"id":"p-0089","num":"0091"},"figref":["FIGS. 8A-8C","FIG. 7","FIGS. 8A-8C"]},{"@attributes":{"id":"p-0090","num":"0092"},"figref":["FIG. 8A","FIG. 8A"],"b":["800","802","814","816","818","820","834"]},"As the process continues at process block , a new line from the target file is obtained and compared against the array of known files at process block . The result of this comparison may result in additional increments of the values stored in the array. An example of this process is shown in  where additional iterations of the process blocks - result in the more positive similarity values stored in  and , indicating an increased degree of similarity.","Specifically, in one embodiment, a new line was obtained in  and compared against the collection of known files , in this embodiment, the collection was a hash-file structure containing all known files. The process queries the hash-file to find all entries in the hash-file that contain the same line as the one being compared. In this embodiment, the iteration producing the result illustrated in  results in the hash-file query returning, for example, FileID, FileID and FileID. These files are represented in the array as index ,  and  respectively , , . The process block  increments the associated values.  illustrates the result of an additional line comparison where the hash-file query returned, for example, FileID, FileID, FileID, FileID or array index ,, and  (reference numerals , , , and ). As a result, the values stored in the array are incremented again to reflect the finding of a similar line in the known files.","In various embodiments, the process blocks - continue until a similarity threshold has been reached. For example, as shown in  a similarity threshold value of 0 has been set and the file represented by index , shown as reference numeral , has reached the value of 0 after completion of the iteration. Thus, in one example embodiment utilizing a threshold value, the process terminates and the file represented by index   would be determined to be the file under investigation. Embodiments utilizing a similarity threshold may require fewer iterations in determining similarity, thus reducing processing time and increasing overall computing performance. Further, in various related embodiments, the similarity threshold may be variable based on the size of the target file, type of target file or other information returned from the preprocessing of the target file.","In other embodiments, the process continues until all lines of the target file being investigated are checked. This requires more iterations, but produces a final measure of similarity between the target file and each of the files of the collection.","It should be noted that numerous variations to the counting system of equation (1) are possible and within the spirit of the invention. For example, in other related embodiments, process block  utilizes a weighting system in increasing the value of similarity in the array. The weighting system may account for factors suggesting stronger similarity by increasing the measure of similarity in the array, and may in some instances account for factors suggesting weaker similarity by decreasing the measure of similarity reported after each iteration. For example, factors suggesting greater overall file similarity include, without limitation, consecutive similar lines, a number of similar lines within a predefined proximity to one another, the number of similar lines within a predefined range, and the like. A variety of other factors can be utilized for weighting.","As another example, in one embodiment, a consecutive line weighting system is utilized in which an additional counter variable is maintained in process block  to record the number of consecutive similar lines. Then, as process blocks - are repeated in a subsequent iteration, for each line that is similar, the counter variable is checked and if it is non-zero, a weight is applied to the baseline similarity value stored in the array. In other embodiments, counter variables are stored in a weight array or the array created in process block  may be multi-dimensional to enable storing of the weighting values.","Now referring to , another phased matching process of line-by-line comparison according to one type of embodiment is presented. The process takes a shared set of files  and determines whether the collection has been preprocessed at process block . If not, the process selects the first file from the collection at  and performs the preprocessing stage as defined above at . The preprocessing stage performed at  includes the determination of whether the extracted lines from the file meet the extraction criteria at . If not the lines are deleted or ignored at ; otherwise they are retained in the file in the collection and added to the file-hash structure at  and the next file is examined at process block . If the collection of files has been processed at , each entry in the collection of files contains only the lines that meet the preprocessing criteria and a file-hash structure is created at block  for each entry in the collection. Based on the created file-hash structure created at  a hash-file structure is created at . Upon completion of the creation of the hash-file structure, the collection of files is processed and is ready for target file comparisons. As mentioned above, this collection may be stored in a memory, such as a database, collection object, array, linked list or other known storage structure, either locally on a single computer system, or distributed among a plurality of communicatively-coupled computer systems.","In this embodiment, a set or collection of target files opened at process block  may be compared to the collection of processed files and the associated hash-file created at process block . For the set of files being processed, the technique will first determine if all processing is complete on the set of target files at process block . If not, the process will select a file from the set for processing at . The selected file will have the functional lines extracted from it according to the preprocessing rules described above, as indicated at block . This extraction process includes the determination of whether the lines meet the extraction criteria at decision block . If so, the extracted lines are compared at  to the hash structure of the known collection of files created at process block . If not, the lines are deleted at . The comparison process block  can be similar to the process presented in , where a determination of the similarity of the file compared to a known database or collection of files is determined. The process returns to check whether all files of the set or collection of target files have been processed at decision block , and the process continues with the other files in the set. If all files have been processed the processing check at  will proceed to end the routine at .","A person having skill in the art will appreciate that the various embodiments disclosed herein, while targeted to antivirus and security, may be utilized to determine the similarity between any file that is able to be parsed line-by-line. Thus, the embodiment disclosed in  may be utilized to determine the similarity between two collections of files. Further, in various embodiments, the database or collection of identified files and the target file may be identified files stored in a database or memory but their similarity unknown and undetermined. In this way the various embodiments disclosed herein may be utilized to determine the similarity of versions of a file, or a set or derivative files. In addition, a person having skill in the art will appreciate that by utilizing the system and method of efficient and accurate line by line comparison of files described herein, the process of identifying malicious files is faster, and requires fewer resources than other processes known in the art.","The embodiments above are intended to be illustrative and not limiting. Additional embodiments are within the claims. In addition, although aspects of the present invention have been described with reference to particular embodiments, those skilled in the art will recognize that changes can be made in form and detail without departing from the spirit and scope of the invention, as defined by the claims.","Persons of ordinary skill in the relevant arts will recognize that the invention may comprise fewer features than illustrated in any individual embodiment described above. The embodiments described herein are not meant to be an exhaustive presentation of the ways in which the various features of the invention may be combined. Accordingly, the embodiments are not mutually exclusive combinations of features; rather, the invention may comprise a combination of different individual features selected from different individual embodiments, as understood by persons of ordinary skill in the art.","Any incorporation by reference of documents above is limited such that no subject matter is incorporated that is contrary to the explicit disclosure herein. Any incorporation by reference of documents above is further limited such that no claims included in the documents are incorporated by reference herein. Any incorporation by reference of documents above is yet further limited such that any definitions provided in the documents are not incorporated by reference herein unless expressly included herein.","For purposes of interpreting the claims for the present invention, it is expressly intended that the provisions of Section 212, sixth paragraph of 35 U.S.C. are not to be invoked unless the specific terms \u201cmeans for\u201d or \u201cstep for\u201d are recited in a claim."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention may be more completely understood in consideration of the following detailed description of various embodiments of the invention in connection with the accompanying drawings, in which:",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 2A and 2B"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 5A-5E"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIGS. 6A-6B"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIGS. 8A-8C"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
