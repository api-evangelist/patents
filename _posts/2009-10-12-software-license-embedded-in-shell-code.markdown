---
title: Software license embedded in shell code
abstract: Software application protection methods and systems for protecting and verifying licensing of an original application. The system reads the original application executable, and generates a shelled application comprising the original application and a shell containing the license information. The shelled application implements license APIs, and establishes secure communications within the shelled application between the original application and the shell. Licensing for the original application can be verified by the shelled application alone.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08205096&OS=08205096&RS=08205096
owner: Safenet, Inc.
number: 08205096
owner_city: Belcamp
owner_country: US
publication_date: 20091012
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","The present invention relates to systems and methods for protecting software from unauthorized copying and\/or execution, and in particular to a system and method that protects software via shell code that contains embedded license information and\/or that communicates with a protected application via a secure tunnel.","2. Description of the Related Art","Software piracy is an ongoing problem for software vendors. Many techniques for discouraging software piracy have been developed, and products incorporating those techniques are available for use by software vendors to secure their software applications from unauthorized copying and\/or use.","One software application protection technique uses link-in modules that require the developer to modify the original application code to call specific functions, for example, functions that check for license conditions. Another protection technique is called shelling. Shelling ordinarily does not require changes to the application code. With the shelling technique, a shell generating process reads the original application executable and produces a modified, new executable as a so-called shelled application which contains an \u201couter layer\u201d of protection code that encapsulates the original application. Further, when shelling is used, one or more application sections, such as executable code, data, import tables, resources, and the like, can be protected via encryption and\/or compression when the shell code is generated, and the shell makes the protected code sections available as needed when the protected application runs.","One function typically performed by the shell is to confirm that a valid license for the application exists. For example, a traditional shell-based application protection solution will typically pack the protected application with shell code that stores license or key information in a storage location separate from the protected application. The licensing information can be stored in a registry, database, file, hidden disk sector, or the like. One or more application programming interfaces (APIs) are provided to access the license information, and the shell code can call the APIs to verify that the protected application is properly licensed.","One vulnerability inherent in shelling is that the software application program protection is provided only by the outer layer of protection. Consequently, a cracker may be able to gain access to the protected application by cracking only the outer layer of protection. When the shelled application launches, the shell code executes before the original application code, and code execution usually proceeds in a fixed, identifiable pattern. A cracker can follow the code execution (for example, by running the shelled program under a debugger), and once the code execution sequence is understood, the cracker can modify the code (for example, by patching the shelled application executable) to bypass and\/or disable license checking.","Link-in modules and shelling can also be used together. For example, in one scenario the shell code can be appended to the encrypted and\/or compressed application sections. When the shelled application first executes, the shell initially gains control and can perform security-related functions such as checking application integrity, checking for the presence of a debugger, decrypting and\/or decompressing application sections, and initializing application processes such as import functions and relocation tables, before passing control to the application. The original application code can also be modified to redirect some system APIs to the shell code. The application can then continue to interact with the shell code after control is transferred to the application. Furthermore, self-modifying code functions can be provided by the shell whereby, for example, certain application code snippets are encrypted at runtime, and the shell code can decrypt those code snippets before they are executed, and encrypt them again after executing.","However, in solutions that utilize shelling, the application code and the shell code of the shelled application reside in different sections of memory having identifiably different addresses. Prior art shelling solutions do not mask the difference between application code addresses and shell code addresses. A cracker may therefore be able to unpack the protected application code and determine which code is part of the shell, and which is part of the application the shell protects. If so, the cracker may then be able to remove or modify the link between shell code and application code. For example, encryption and decryption of code during program execution can be disabled by using no-operation (NOP) instructions to replace decrypt and encrypt instructions.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 1","FIGS. 2A and 2B"]},"After the application is compiled, the protective shell code is generated and a shelled application executable is generated. The shelled application executable can then be examined by a cracker using a debug tool, such as OllyDbg, for example, to disassemble the shelled application executable, or binary code. OllyDbg is a debugger that emphasizes binary code analysis. It traces registers, recognizes procedures, API calls, switches, tables, constants, and strings, and locates routines from object files and libraries. Such tools can be used to reverse engineer and crack programs.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 2A","FIG. 2B","FIGS. 2A and 2B"]},"Different code sections are illustrated in , wherein different blocks indicate code sections located in different address spaces. As shown, the address spaces of the different code sections have identifiable boundaries. Illustratively, during program execution the shell code can decrypt and encrypt sections of application code as needed, thereby enhancing the security of the application code. Even so, a cracker might be able to analyze the program, recognize the existence of the decryption and encryption shell processes, and remove the link between the shell code and the application code, for example, by using no-operation (NOP) instructions to replace the encryption instructions. Similarly, a cracker might be able to recognize the existence of license checking processes, and remove the link between the shelled application code and the license information stored outside of the shelled application.","Accordingly, there is a need for an application protection technique that resists cracking by making it more difficult for a cracker to disable license checking and\/or modify communications between application code and shell code.","Embedding application software license information in a shell, and securing communications between the shell and the application code of a shelled application, are disclosed. The license can be embedded in the shell code during the shell generating process. A set of application programming interfaces (APIs) can be provided in the shell and the application can be modified to interact with the APIs to access the license information. The application code and the shell code can communicate using a secure tunnel to strengthen the security of the communication link between them.","It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory and are intended to provide further explanation of the invention as claimed.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4","b":["400","402","404","406","402","422","418","402","414","416","428","402"]},"Generally, the computer  operates under the control of an operating system  stored in the memory , and interfaces with the user to accept inputs and commands and to present results through a graphical user interface (GUI) module A. Although the GUI module A is depicted as a separate module, the instructions performing the GUI functions can be resident or distributed in the operating system , the computer program , or implemented with special purpose memory and processors. The computer  also implements a compiler  which allows an application program  originally written in a programming language such as C, C++, Visual Basic, Delphi, or other programming language, to be compiled (translated) into processor  readable code. After completion, the compiled application  accesses and manipulates data stored in the memory  of the computer  using relationships and logic that were generated using the compiler . The computer  also optionally comprises a communication device  such as a modem, network card, or other device for communicating with external devices  such as other computers, storage devices, etc.","In an embodiment, instructions implementing the operating system , the computer program , and the compiler  are tangibly embodied in a computer-readable storage medium, e.g., data storage device , which could include one or more fixed or removable data storage devices, such as a hard drive, an optical disk drive, flash drive, tape drive, or the like. Further, the operating system  and the computer program  comprise instructions which, when read and executed by the computer , cause the computer  to perform the steps necessary to implement and\/or use the herein disclosed systems and methods. Computer program  and\/or operating system  instructions may also be tangibly embodied in memory , data storage device , and\/or external device , thereby making a computer program product or article of manufacture according to the herein disclosed systems and methods. As such, the terms \u201carticle of manufacture,\u201d \u201cprogram storage device,\u201d and \u201ccomputer program product\u201d as used herein are intended to encompass a computer program accessible from any computer readable device or storage medium.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 5","b":["504","505","500","502","504","506","506","508","508","510","512","507","512","507","510"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 6","b":["508","602","508","510","604","510","606","508","608","616","512","614","610","512","612"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 7","b":["700","702","704","706","704","706","700","708","706","702","704","702","706","710","700","712","702","710","704","712","708","704"]},"The license-related requests, responses, and other messages are sent between the application  and the shell . A secure tunnel  can be set up by the communication service thread between the application  and the shell . For example, the secure client library  may include one or more software security modules for secure communications. The shelled application  can include a pseudo-random number generator, and the secure client library  and\/or the communication service thread  can generate therefrom randomized one-time session keys to secure messages communicated between the application and the shell via secure tunnel . The messages can use any appropriate inter-process communication (IPC) method, such as named pipes, TCP\/IP, mailboxes, or the like.","In an exemplary embodiment, licensing information can comprise one or more features of various types, each feature comprising one or more elements. Illustratively, the feature types can include data, Elliptic Curve Cryptography (ECC), Advanced Encryption Standard (AES), and constraint features. Additional or other feature types may also be used.","Regarding the data feature type, an application developer can, for example, store data for use by the application into a data feature element, and the application can call an API to read the stored data, such as the exemplary SCL_FeatureRead API described below with other exemplary APIs. The ECC feature can contain an ECC private key, and can be used to sign message content using an elliptical curve signature scheme, such as ECCSH, for example. The application can call an API, such as SCL_FeatureSign, to sign message data, and then call another API such as SCL_FeatureVerify to verify the signature result in the application. Similarly, the AES feature can contain an AES algorithm key, and the application can call an API such as SCL_FeatureQuery to get a response, and compare the response with a previous response stored in the application. The application can also call APIs such as SCL_FeatureEncrypt and SCL_FeatureDecrypt to respectively encrypt and\/or decrypt application data. Finally, the constraint feature provides licensing constraints, such as constraints that must be satisfied for the application to run or before certain application functionality can be used. Shell License APIs can be called by the application code to access the license information embedded in the shell code.","In an exemplary embodiment, such license information may be encoded in messages communicated between the shell code and the application code as type-length-value (TLV) elements of up to 256 bytes in length, within the data communication protocol used. Each such element contains only one piece of licensing information, or \u201cconstraint feature.\u201d The TLV elements comprise at least three kinds of fields: type, length, and value. The type field is a numeric code indicating the kind of licensing information represented by the element. The length field indicates the size of the element or the value field in bytes. The value field is a variable sized field which contains the licensing constraint feature information.","Additional fields can also exist in each licensing constraint element.  shows fields of an exemplary licensing constraint element. In addition to the type, length, and value fields described above, each element contains a feature ID field, and a check mark field. The feature ID field identifies the source of the information that the element represents. The check mark field is used to check data integrity. The license information embedded in the shell code may be encrypted when stored, and decrypted when accessed.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 9","FIG. 9"]},"As previously described in connection with , the shell license library  comprises a set of APIs for use by the application  to access the license information .  provide illustrative names and formats of exemplary APIs that can be called by the application to access the licensing information embedded in the shell code, as follows. In the illustrative API names, \u201cSCL\u201d is simply an abbreviation for Secure Client Library.","SCL_OpenLicense\u2014this API can be used to create a secure tunnel between the shell code and the application code within the shelled application, and get a license handle. If it returns successfully, subsequent communication packets can be communicated via the secure tunnel. If the license has a constraint feature that cannot be satisfied, an error will be returned.","SCL_FeatureQuery\u2014this API can be used to generate an encrypted response based on the Advanced Encryption Standard (AES) feature ID and the queried data.","SCL_FeatureRead\u2014this API can be used to read data stored via the data feature.","SCL_FeatureEncrypt\u2014this API can be used to encrypt provided cleartext data based on the AES feature ID.","SCL_FeatureDecrypt\u2014this API can be used to decrypt provided cipher data based on the AES feature ID.","SCL_FeatureVerify\u2014this API can be used to verify digitally signed content using the public key of the ECC feature based on the ECC feature ID.","SCL_FeatureSign\u2014this API can be used to sign content using an algorithm based on the ECC feature ID.","SCL_CloseLicense\u2014this API can be used to close the secure tunnel and release the license handle.","One benefit of the herein described systems and methods is that a virtual shell license can be supplied for testing purposes before the packing process. A virtual shell license is a kind of service that can emulate all shell license functions. During the debugging and developing process, the library can access this server, and after adding the shell, the library in the application can access the license in the shell code. In an exemplary operation, the herein described systems and methods can be used to make each shelled application instance unique, for example, via various compression or encryption methods and\/or combinations. License information can also be encrypted using one or more vendor-related factors, such as a vendor ID or application name. License information can also be signed by one or more asymmetric algorithms.","In addition to the exemplary embodiments described above, various other modifications and variations can be made without departing from the spirit or scope of the invention. Thus, it is intended that the present invention cover all such modifications and variations provided they come within the scope of the appended claims and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying figures are included to provide a further understanding of the invention, and to present exemplary embodiments and illustrative features of the invention. Together with the description, the figures serve to help explain the principles of the invention, the scope of which is defined by the appended claims.","In the drawings:",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 2A and 2B"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIGS. 10A and 10B"}]},"DETDESC":[{},{}]}
