---
title: System and method for a healthcare communication framework
abstract: A computer-implemented method is described for asynchronous service-based communication. The method includes steps of generating events in an application layer of a computer software system, storing the generated events in a database table and scanning the database table by a process of a healthcare communication framework (HCF) at a time after the generated events are stored. The computer software system can run on a computer implementing the HCF and the generated events targeting service operations exported by another software system. During each scan the process is configured to group the events in the database table into packages based on a respective context of each event. For each package: consistency is checked for each event contained in the package, a consolidation logic is applied to consolidate events contained in the package, services operations associated with each event not being consolidated are found, and the service operations are invoked asynchronously.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08626526&OS=08626526&RS=08626526
owner: SAP AG
number: 08626526
owner_city: Walldorf
owner_country: DE
publication_date: 20090401
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","DETAILED DESCRIPTION OF THE EXAMPLE EMBODIMENTS"],"p":["This application claims priority to U.S. Provisional Patent Application No. 61\/103,145, filed Oct. 6, 2008, entitled \u201cHealthcare Communication Framework,\u201d which is herein incorporated by reference in its entirety.","Health care institutions (e.g., hospitals, clinics, doctor's offices) may have multiple computer software systems to provide a variety of services. For example, a hospital may use an administrative system for admission of patients. The administrative system may facilitate taking and managing information such as patient name, insurance information, etc. The hospital may have a billing system to generate invoices and send bills to insurance companies, and a lab system to manage diagnostic tests. Sometimes, the services provided by another system may be needed. For example, the administrative system may need to invoke services provided in the billing system to generate bills and services provided in the lab system to schedule diagnostic tests. There is a need to integrate diverse systems, such as an administrative system, a billing system and a lab system, by a communication framework.","Embodiments of the present application implement event-driven asynchronous communication between different software systems. Events may be pre-defined and generated at runtime by software systems in accordance with business needs (e.g., admission of a patient, input\/modification of insurance information for a patient, etc.). In one embodiment, events may be persisted in a database such that subsequent processing steps may be performed at a later time by scanning entries in the database. For example, an outbound processor may be implemented to periodically check the database and process events accumulated since the last check. The subsequent processing steps may include, but are not limited to, finding a service operation targeted by a respective event, filling context information for the service operation, and calling a proxy of the service operation. These steps will be described in detail below. The outbound processor may be scheduled to execute in the background (e.g., without user interface and\/or user interaction). In one or more embodiments, users may define and\/or modify service operations without modification to the framework of the system. The communication framework in accordance with embodiments of the present invention may be termed a healthcare communication framework (HCF).",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1","b":["100","100","110","100","120","120","100","130","110","120","130","140","110","120","130","100"]},"One way of communication between diverse systems may be synchronous communication. Synchronous communication establishes connections between different participating systems in a synchronized manner. In this manner, systems participating in the communication must be present during the whole time period the communication is in progress. Once synchronous communication is established, the initiating system will resume its own execution only after the synchronous communication is completed. That is, the initiating system has to complete the communication with other systems before continue its own execution. Thereby, synchronous communication may block execution of the initiating system. If a subsequent change is made in the initiating system, the change may cause the initiating system to start another round of synchronous communication. Resources (e.g., bandwidth of the network) may be spent by recurring communications between different systems running on different computers. For example, an update to a patient's information in the administrative system  may cause the administrative system  to invoke services provided in the lab system  and\/or billing system , thus a new round of synchronous communication is needed.","In one embodiment, communication between various systems ,  and  may be implemented as remote procedure calls. That is, each system may export certain procedures to represent service operations that can be called by another system. The remote procedure calls may be facilitated by proxies. Each proxy presents a corresponding remote procedure to be called by a calling system. The procedure calls may be performed synchronously and\/or asynchronously. For example, a patient information may be transmitted from the administrative system  to the billing system  when a bill for the patient needs to be generated. That is, the administrative system  may initiate a remote procedure call synchronously to invoke the service operation in the billing system  to generate the bill. Alternatively, the administrative system  may generate a request (e.g., an event) and submit the request to a system or queue to be fulfilled later (e.g., asynchronously). For example, the bill may be generated at night when there is less network communication and less computing activity by computers running the billing system .","In one embodiment, asynchronous communications may be implemented for certain types of remote procedure calls and synchronous communications may be implemented for other types. A system designer may define what types of remote procedure calls should be implemented as synchronous or asynchronous. It should be noted that the administrative system , lab system  and billing system  are exemplary systems of the health care institution . The health care institution  may include other systems not shown in  and may include systems less than shown in .",{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 2","FIG. 6"],"b":["200","200","110","120","130","200","208","204","206","208","202","208","204","204","110","632"]},"The events processing module  may be invoked by the communication module  for post processing of events that have been triggered for one business transaction (e.g., entry of a patient's information or a request to generate a bill by the user ). The events processing module  may aggregate events by keeping the order by which events are generated and writing the events into the events database . In one embodiment, the database  implements a runtime events table to store the events written by the event processing module . In one embodiment, events may be collected within the database  as persistent events.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3","b":["300","300","300","300","1"]},"Events stored in the runtime events table  may be processed at a later time (e.g., periodically, or a designated later time) by an outbound processor. If an error occurs during the process, an error may be recorded in an event errors table. The event errors table may be similar to the runtime events table  and contains data fields and information stored in the runtime events table . Additionally, the event errors table may store error information to facilitate diagnosis of the errors.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4","b":["400","400","100","400","400","300","400","400"]},"The out bound process  may start with step  and continue to step . At step , the out bound process  may try to retrieve an events package. Events in the runtime events table  and the event errors table are packaged in to events packages according to the context of each event. In one embodiment, an event manager may be implemented. The event manager may build events packages based on a pre-determined criteria. Each events package may be processed as a unit. That is, all events contained in one package may be processed together. For example, events may be grouped in one events package for one patient based on a patient context. The patient context may ensure that all events that might be relevant for later consolidation and may be written to the event errors table are contained in one package. The consolidation of events are described in detail below.","In one embodiment, events stored in both the runtime events table  and the event errors table need to be processed in chronological order. In case of any error occurring during the process, any subsequent related events may also be put in the event errors table. In one embodiment, any subsequent events with the same PATID may be related to same patient and may be treated as related events. For events without patent context, such as a patient identifier, a pre-defined criteria may be used to group events. The same pre-defined criteria may also be used for consolidation of events when processing events packages.","At step , the out bound process  may determine whether the retrieval step  is successful. If no package can be retrieved and thus no more packages are to be processed, the out bound process  may end at step . If a package is retrieved, the out bound process  continues to step .","At step , the out bound process  may check consistency for each event contained in the events package being processed. For example, the step  may check whether relevant patient context is provided. If an error occurs during the step , the step  may raise an error identified as basic consistency error and continue to step , which may store the error in the event errors table. In one embodiment, the events package may include a field identifying the last error that has occurred. This field of last error may contain error information that is existent to an event in the event errors table. Thus, this information in an events package may suppress multiple alerts for the same error. If no error occurs, the out bound process  may continue to step .","At step , the out bound process  may consolidate events contained in the current events package. In one embodiment, the out bound process  may implement a consolidation logic. The consolidation logic may be applied to each event in the events package to determine if the respective event may be consolidated with another event in the events package. Consolidation may be implemented as aggregation of events that were triggered between the last and current run of the out bound process , and may reduce and\/or eliminate redundant service operation calls during the out bound process . The events package may contain supplementary information reflecting the status of the consolidation steps. For example, the events package may have a field identifying whether an event has been consolidated with another event and the other event's identifier. The events package may further include a field about a status identifying whether a respective event is no longer the object of event processing steps of the out bound process . The status may be set to \u201cprocessed\u201d, when the event has been consolidated. The out bound process  may skip all events with a status of \u201cprocessed\u201d for further processing steps. However, the consolidated events are not deleted from the runtime events table yet because in case of error scenarios, they also have to be inserted in the event errors table.","In one or more embodiments, consolidation is implemented to reduce\/eliminate redundant service operation calls. The redundant service operation calls may be identified by certain patterns. Each pattern may use business objects and context to distinguish service operation calls. The term business object is described below. Context may be patient context, e.g., the same patient as identified by a patient identifier.","In one pattern, for example, two events may have identical service operation calls thus the two events may be consolidated. In this case, the second event may be marked as \u201cprocessed\u201d and only one service operation call is performed. The pattern may be identified by the same business object, the same context and the same action.","In another exemplary pattern, a change service operation call may follow a preceding creation service operation call. For example, after a patient's information has been entered into the administration system , the patient's information has been subsequently modified. An event may be stored in the runtime events table  for initial entry of the patient's information, and a subsequent event may be stored for the subsequent modification. The two events may have the same patient context and thus may be consolidated (e.g., modify information of the initial event with change from the subsequent event). The subsequent event may be treated as already processed (e.g., marking it as \u201cprocessed\u201d). The out bound process  may skip the subsequent event in later steps (e.g., for locating and calling the service operation). This exemplary pattern may be identified by the same business object, the same context and a creation action plus a change action.","In a further exemplary pattern, an event may cancel a service operation following a preceding event to create the service operation (e.g., canceling generation of a bill for a patient). The consolidation may cancel the creation service operation call and the out bound process  will invoke no service operation calls for these two events. This further exemplary pattern may be identified by the same business object, the same context and a creation action plus a cancel action.","If an error occurs during the step , the step  may raise an error identified as a consolidation error and continue to step , which may store the error in the event errors table. The error information may be stored in the last error field of the events package before being processed in step . If no error occurs, the out bound process  may continue to step .","At step , the out bound process  may find service operations for the events contained in the events package being processed. In one embodiment, the out bound process  may find service operations for each event in the events package with a status not set to \u201cprocessed.\u201d The service operations for each event may be determined by pre-defined configurations. The configurations to associate operation services with events may be stored in configuration information database tables or configuration files. During the step , if an event is marked as \u201cprocessed\u201d in the status field, the event may be skipped by the step  and no service operations will be searched for the event.","In one embodiment, the events package may contain supplementary information reflecting the status of the finding service operation steps. For example, the events package may include a field for service operations. One or more service operations may be associated with one event. That is, each event may cause one or more service operations to be invoked. The service operations may be implemented as a nested structure for each event. The nested structure may contain the service operations that are found for the given event. This field for service operations may be filled when the previous step  (e.g., consolidation) and current step  (e.g., service operation finding) are successful. If an error occurs during the step , the step  may raise an error identified as a service operations finding error and continue to step , which stores the error in the event errors table. The error information may be stored in the last error field of the events package before being processed in step . If no error occurs, the out bound process  may continue to step .","At step , service operations identified for each event in step  are invoked. In one or more embodiments, the out bound process  may implement procedures to fill in context information of each service operation and call respective proxies of the service operations. In one embodiment, invocation of service operation may be performed asynchronously, e.g., using message queues.","Embodiments of the present invention may use message queuing to provide an asynchronous communication. Message queuing is an asynchronous communications protocol. Using message queues, senders and receivers of messages do not need to interact with the message queues at the same time. Messages placed onto a queue are stored until the recipient retrieves them from the queue. Some message queues have set limits on the size of data that can be transmitted in a single message but some others do not. Some implementations of message queues allow the passing of messages between different computer systems, potentially connecting multiple applications and multiple operating systems. These message queuing systems typically provide enhanced resilience functionality to ensure that messages do not get \u201clost\u201d in the event of a system failure. Examples of commercial implementations of this kind of message queuing software (also known as Message Oriented Middleware) include IBM's WebSphere MQ (formerly MQ Series), Oracle Advanced Queuing (AQ) within an Oracle database, and Microsoft's MSMQ. The Java standard called Java Message Service has, associated with it, a number of implementations, both proprietary and free software. Embodiments of the present invention may use any existing message queuing systems or may develop custom message queuing systems.","If an error occurs during the step , the step  may raise an error identified as a process service operations error and continue to step , which stores the error in the event errors table. The error information may be stored in the last error field of the events package before being processed in step . If no error occurs, the out bound process  may continue to step  without raising an error.","At step , the out bound process  may perform clean up tasks before ending the process. In one embodiment, the step  may raise an alert for errors raised during any of previous steps. Also, the step  may store the errors in the event errors table. If there are no errors, the step  may delete entries in the events table because the current run successfully processed scanned events from the events table. If events from event errors table are also processed without error, corresponding entries in the event errors table may also be cleaned. In one embodiment, the out bound process  may implement transactions to protect data integrity in the step . For example, a transaction may be started as soon as the step  starts, if certain work has been performed before encountering the error, the work may be rolled back. The transaction may only be committed when the step  has executed successfully. Further, changes to either runtime events table and event errors table may also be wrapped around by the transaction and occur only after a successful execution of other functions in step .","In one or more embodiments, the out bound process  may skip integrity checks. Integrity checks normally make sure context information or data supplied to proxies conform to the remote procedure's requirement. A layered implementation of the software system may be implemented and the integrity checks may be implemented at an application layer not at the out bound process . However, the out bound process  is prepared to handle errors for each processing step. Thus, an integrity check framework may be added to the health care communication framework if needed. Further, in one embodiment, error situations that occur during out bound process  may be forwarded using one generic alert implementation. More complex alert framework may be employed if more complex errors than mere technical errors are anticipated.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 5","b":["500","502","504","506","502","502","504","500"]},"The business objects may access data stored in any underlying database through the data access objects (DAO) layer . The DAO layer  provides an abstract interface to an underlying database or persistence mechanism. It provides data specific operations without exposing details of the database. This isolation separates the concerns of what data accesses the HCF needs, in terms of business objects and data types, and how these needs can be satisfied with a specific DBMS, database schema, etc. In one or more embodiments, the DAO layer does not contain any control for transactions. That is, data access objects may not implement \u201ccommit\u201d for transaction and leave the transaction control to the business objects in the layer .","Errors may occur when a data access object is accessing data. In this case, one or more exceptions may be generated (e.g., thrown) in the DAO and propagated to the caller (e.g., a business object invoking the DAO). The exceptions may be of technical or business nature. For example, technical exceptions may be caused by customizing inconsistencies, inactive Data Dictionary (DDIC) and invalid parameters. Business exceptions may be errors caused by invalid application programming interface (API) calls (e.g., trying to access information for a non-existent patient). A business exception may be propagated by raising an alert to an administrator.","Errors and exceptions have been mentioned above. In one embodiment, problematic situations may be grouped into exceptions, errors, and conflicts. Exceptions may indicate that some unexpected condition has occurred which cannot be fixed by an end user. They might be fixed by the system administrator. Exemplary exceptions may be database inconsistencies, invalid customizing settings, code errors (e.g. invalid parameters passed to a method), authorization problems (if they cannot be corrected by the user), unexpected error situations in the proxy coding before and after the business logic calls. Errors may be problems that can be solved by a user, e.g., correcting the input data or by doing the action some time later, data inconsistencies with a (incoming) message (e.g. unknown service operation code). Conflicts may occur when there are process inconsistencies with a (incoming) message, e.g., choreographic errors.","The business object model  may be implemented across systems with each system exporting services to be invoked by other systems. As described above, service operations implemented in another system may be invoked through messaging queues. This service oriented architecture (SOA) using asynchronous messages may result in loose coupling of systems. Further, the SOA may use no cross system transactions (as DB LUW) and may use no cross system locks. This may lead to an optimistic approach where each system is responsible for its own process steps. Results of the steps are published via messages (e.g., invocation or acknowledgement). This also means that there are limited checks for the invoked systems, whereas many checks are done in the invoking system. In one or more embodiments, forward recovery may be chosen for resolution strategies (e.g., exception, error or conflict situations), which might come up in a subsequent system since rollback of a LUW is no longer possible (due to loose coupling). That is, errors at the receiver-side are to be handled independently from the sender.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 6","b":["600","600","630","632","614","630","602","608","632","634","608","634","606","614","600","616","618","620"]},"The healthcare information system  may comprise the application layer  described above in  and may raise events . The events  may be transmitted to the HCF runtime  in the order that they are raised. The HCF runtime  may process the events in the order they are received. Events  may be related to service operations provided in another system (e.g., a billing system not shown) and those service operations may need to be invoked in the same order on a proxy .","In one embodiment, to ensure a proper sequence for invoking the service operations, a named queue may be used. Instead of all messages sharing one message queue, multiple queues with unique names may be created. Thus, each message may be put into a specific named queue based on the message's target system, target service operation (e.g., a specific remote procedure), or a message context (e.g., a patient ID). With named queues, the HCF outbound proxy calls (e.g., outbound messages) may be enhanced to allow a strict sequencing (e.g., exactly once in order (EOIO)). In one embodiment, the sequencing context may be based on a patient ID. If a patient ID is available, the patient ID may be used for a queue name to ensure all service operations related to the patient are put in one queue and EOIO may be strictly enforced. If a message has no patient ID, a named queue is not used for the message. The message may be delivered to queues managed by the proxy framework (e.g., proxy ) to ensure exactly once (EO) delivery. However, the sequence for those services is not to be guaranteed. In one or more embodiments, the proxy  may create queues if there is no patient ID and HCF runtime  does not create named queues.","The exchange infrastructure  may also need to implement functions to ensure EOIO if EOIO is requested by the HCF runtime . In one or more embodiments, the infrastructure runtime  may further communicate with the external system  through an adapter . Thus, not only the infrastructure runtime  needs to perform the service operations in the sequence as set forth by the HCF runtime , it may further ensure messages sent to the external system  to be in that sequence. The adapter  may be required to be EOIO capable to facilitate the mission.","In one embodiment, the external system  may send messages to the HCF runtime . The messages may be termed inbound messages with regard to the HCF runtime . The inbound messages may be sent via the adapter  to the infrastructure runtime . The infrastructure runtime  may invoke service operations exported by the HCF runtime  via the proxy . Message queuing including named queues described above for the proxy  may also be used for the inbound messages as well. The external system  may also require EOIO behavior for inbound messages. To enforce the EOIO behavior, the adapter  may be required to be EOIO capable. Further, named queues may be required for invocation of service operations through the proxy .","If no error occurs and EOIO is used, then the inbound proxies at the proxy  will be called in the correct order. If an error occurs, then the sequence will only be guaranteed for subsequent errors, which may be caught by the business object model implemented by the healthcare communication solution system . In one embodiment, the first erroneous message will be persisted in a monitor in the exchange infrastructure . The follow-up messages may run into errors and also be persisted by the monitor. An administrator may be informed with an alert through the alert inbox  and he or she might restart the message at a later point in time. For example, if a service operation to create a patient object has an error and is not processed. A subsequent service operation to change the patient object may cause an exception to be raised in the HCF runtime , because the patient doesn't exist yet. So the subsequent message is not processed and will instead be put into the monitor. In one embodiment, messages like several change messages for the same patient might be processed not in the order the messages are generated.","HCF may be activated and\/or deactivated at an institutional level. The HCF runtime  and the infrastructure runtime  only run when the HCF is activated. For example, configuration database may be used to store the HCF procedures pre-defined for the institution. The various HCF procedures run in the HCF runtime  and infrastructure runtime  when the HCF is activated. An administrator may activate the HCF procedures through a user interface menu (e.g., through the healthcare information system ). In one embodiment, all exported operation services from either the HCF runtime  or infrastructure runtime  may be stored in one or more database tables.","In one embodiment, the HCF runtime  or infrastructure runtime  may implement exception handling by exception classes. These classes may have a hierarchical structure and have common attributes. Exceptions which are raised within HCF runtime  or infrastructure runtime  may be propagated to either the runtime caller or the inbound proxy  depending upon which is the caller. Succeeding actions may be taken at the caller. This may help restrain follow up actions taking place only at either of the two places. Follow up actions may include: raise an alert (e.g., send an alert to the alter inbox ); send an error notification\/message; write an application log entry; adjust the events table accordingly and any other action.","The healthcare communication solution system  may implement an alert management to provide a central notification system. The alert management may be accessed from all systems of the healthcare communication solution system  (except the external system). The healthcare communication solution system  may implement user functions\/components for watching alerts. In one embodiment, the UWL  may be implemented, which may be a component coupled to a portal to display alerts to an administrator. In another embodiment, the alert inbox  may be implemented to receive alerts from the healthcare information system , HCF runtime , the proxy  and the infrastructure runtime . In a further embodiment, the POWL  may be implemented for data other than alerts (e.g., message history) to be shown to an administrator.","The alert management and the exception handling of the healthcare communication solution system  may provide different approaches for error handling. For example, one type of error may be resolved by the system administrator only. In one embodiment, an administrator may be informed about the exception by an alert (e.g., via the alert inbox , UWL , and\/or POWL ) and the administrator can log in the system to resolve it. One exemplary alert may be caused by faulty environment settings. The alert may comprise some text with an error description (and\/or a call stack of the current procedure call context), link to the transaction for correcting the environment, and link to an monitor (leads directly to the concerned message).","Another type of error may be resolved by the end user only. An exemplary alert may be temporary errors, which couldn't be resolved by automatic retries or may be any unknown error. This kind of alert may also comprise some text with error description (and a call stack) and link to an monitor (leads directly to the concerned message). For the end users, only errors or conflicts may be relevant. These errors and conflicts may be defined by the business transactions implemented in the healthcare communication solution system . Such errors\/conflicts may occur in the HCF runtime  during inbound or out bound processing or in the infrastructure runtime . From both locations, alerts may be thrown, which may contain descriptive texts and links to the related transactions.","Another type of error may be resolved first by end user, then by system administrator. In one embodiment, the link to the monitor may be provided only if the proxy  is involved In some situations, resolution of an error or conflict may need involvement from both the end user and the administrator. In such cases, an alert will be send first to the end user, who might fix the issue with business transaction(s). After successfully changing data in the transaction that caused the error\/conflict, the end user may forward the alert to the administrator, who may then follow the link in the alert to the monitor and try to resend the message.","The alert management described above may also be applied if exception\/error\/conflict is caused by an inbound message initiated from the external system .","The healthcare communication solution system  may log its activities on request to support tracing and error finding for the initial setup of the system as well as during productive use. Logging may be switchable (active\/inactive) at an institution level (e.g., via a database table entry and\/or a user interface menu). Additionally, the log level can be set to different levels (e.g., just errors, errors and warnings or all messages). The HCF runtime logging may log activities from the HCF runtime . The exchange infrastructure  may offer additional logging and monitoring functionalities, e.g. to follow-up how a specific message was handled within infrastructure runtime . In one embodiment, the activities that may be logged in HCF runtime  are based on inbound or outbound processing (e.g., successful execution of a unit process, error occurring at a component). Logs may be stored in one or more database tables. User interface modules may be implemented to display logged data.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 7","b":["700","700","702","704","706","708","702","704","706","708","704","706","708"]},"In one embodiment, the data access objects in  may be used to access data represented by each node. One data access object may be defined to access data only for one node and from one data source. For example, patient data of node  may come from the healthcare information system  and external system . Two data access objects may be needed to access the patient data from two different data sources.","In one or more embodiments, acknowledgements to messages may be implemented. Acknowledgements may be requested by a message sender and the receiver(s) are to send requested information back to the sender. Acknowledgements may be useful for asynchronous messaging because unlike synchronous messaging, in which status information will be directly sent back, status information for asynchronous messaging is not available unless explicitly requested by the sender. Acknowledgments may differ from confirmations because acknowledgements are more of a technical nature and they may indicate that the processing of the message on the transport or application level has been successful. In contrast, confirmations may be outside the bounds of a transaction (e.g., confirming receipt of an order). In one embodiment, the HCF may supports various types of acknowledgements. For example, the default may be no acknowledgement (e.g., none). Alternatively, there may be system acknowledgement (e.g., by business objects), application acknowledgement (by application layer) and\/or a combination of system and application acknowledgement.","The various computer systems described herein may each include a storage component for storing machine-readable instructions for performing the various processes as described and illustrated. The storage component may be any type of machine readable medium (i.e., one capable of being read by a machine) such as hard drive memory, flash memory, floppy disk memory, optically-encoded memory (e.g., a compact disk, DVD-ROM, DVD\u00b1R, CD-ROM, CD\u00b1R, holographic disk), a thermomechanical memory (e.g., scanning-probe-based data-storage), or any type of machine readable (computer readable) storing medium. Each computer system may also include addressable memory (e.g., random access memory, cache memory) to store data and\/or sets of instructions that may be included within, or be generated by, the machine-readable instructions when they are executed by a processor on the respective platform. The methods and systems described herein may also be implemented as machine-readable instructions stored on or embodied in any of the above-described storage mechanisms.","Although the present invention has been described with reference to particular examples and embodiments, it is understood that the present invention is not limited to those examples and embodiments. Further, those embodiments may be used in various combinations with and without each other. The present invention as claimed therefore includes variations from the specific examples and embodiments described herein, as will be apparent to one of skill in the art."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS OF THE EXAMPLE EMBODIMENTS","p":[{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
