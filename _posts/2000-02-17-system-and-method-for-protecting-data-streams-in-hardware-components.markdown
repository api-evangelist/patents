---
title: System and method for protecting data streams in hardware components
abstract: A scrambling architecture protects data streams in the operating system and hardware components of a computer by scrambling the otherwise raw data prior to the data being handled by the operating system. The architecture has a scrambler implemented at either the client or the server that adds noise to the content. More specifically, the scrambler produces periodic sets of tone patterns having varying amplitudes based on a first key. The scrambler also generates a random signal based on the first key and a second key. The tone patterns and random signal are added to the content to scramble the content. The scrambled content is then passed to the filter graph (or other processing system) where the content is processed while scrambled. Any attacker attempting to siphon off the bits during processing will steal only noisy data, which is worthless for redistribution or copying purposes. After processing, the scrambled data is passed to a driver for output. The driver implements a descrambler to unscramble the content by subtracting out the random noise signal. The descrambler detects the tone patterns in the content and recovers the first key from the varying amplitudes of the tone patterns. The descrambler also receives the second key via a separate channel (e.g., a cryptographically secured path) and generates the same random signal using the recovered first key and the second key. The descrambler subtracts the tone patterns and the random signal from the scrambled content to restore the content.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07069590&OS=07069590&RS=07069590
owner: Microsoft Corporation
number: 07069590
owner_city: Redmond
owner_country: US
publication_date: 20000217
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["This invention relates to systems and methods for protecting data content, such as audio and video data. More particularly, this invention relates to protecting data streams in hardware components.","More and more content is being delivered in digital form online over private and public networks, such as Intranets and the Internet. For a user, digital form allows more sophisticated content and online delivery improves timeliness and convenience. For a publisher, digital content also reduces delivery costs. Unfortunately, these worthwhile attributes are often outweighed in the minds of publishers by a corresponding disadvantage that online information delivery makes it relatively easy to obtain pristine digital content and to pirate the content at the expense and harm of the publisher.","Piracy of digital content, especially online digital content, is not yet a great problem. Most premium content that is available on the Web is of low value, and therefore casual and organized pirates do not yet see an attractive business stealing and reselling content. Increasingly, though, higher-value content is becoming available. Books and audio recordings are available now, and as bandwidths increase, video content will start to appear. With the increase in value of online digital content, the attractiveness of organized and casual theft increases.","The unusual property of content is that the publisher (or reseller) gives or sells the content to a client, but continues to restrict rights to use the content even after the content is under the sole physical control of the client. For instance, a publisher will typically retain copyright to a work so that the client cannot reproduce or publish the work without permission. A publisher could also adjust pricing according to whether the client is allowed to make a persistent copy, or is just allowed to view the content online as it is delivered. These scenarios reveal a peculiar arrangement. The user that possesses the digital bits often does not have full rights to their use; instead, the provider retains at least some of the rights. In a very real sense, the legitimate user of a computer can be an adversary of the data or content provider.","\u201cDigital rights management\u201d is therefore fast becoming a central requirement if online commerce is to continue its rapid growth. Content providers and the computer industry must quickly address technologies and protocols for ensuring that digital content is properly handled in accordance with the rights granted by the publisher. If measures are not taken, traditional content providers may be put out of business by widespread theft or, more likely, will refuse altogether to deliver content online.","Traditional security systems have not fully addressed this problem. There are highly secure schemes for encrypting data on networks, authenticating users, revoking certificates, and storing data securely.  shows a representative prior art system  having a content producer\/provider  that produces original content (e.g., audio, video) and distributes the content over a network  to a client . The content producer\/provider  has a content storage  to store digital data streams of original content and a distribution server  that transfers the content over the network  (e.g., Internet). The distribution server  includes an encoder  that encrypts and compresses the data prior to distribution over the network. In this manner, the data is protected in route over the public network .","The client  is equipped with a processor , a memory , and one or more media output devices  (e.g., monitor, display, sound card, speakers, etc.). The processor  runs various tools to process the data stream, such as tools to decompress the stream, decrypt the data, filter the content, and apply controls (tone, volume, etc.). An operating system  is stored in the memory  and executes on the processor . The operating system  implements a media player  that is capable of playing streaming media content, including both audio and video data. The media player  has a decoder  that provides the tools run by the processor  to decompress and decrypt the content.","Once the content is stored on the machine, there are products designed to restrict rights after purchase. For instance, a product from Liquid Audio (www.liquidaudio.com) allows a content provider to restrict content to being played only on one machine. The product secures the source material by keeping an encrypted copy of the content on disk, and keeping a decryption key safely somewhere.","While this architecture safely protects the content from the provider  to the client  and even provides some protection while stored on the client, it does not address the assurance of content security after the content has been delivered to a client's operating system. Ultimately, useful content must be assembled within the client machine for display or audio output, and again, at this point the bits are subject to theft.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2","b":["60","52","54","52"]},"The media player  calls to an operating system API (application program interface) layer  to submit the PCM data to a mixer  (or other processing component). The mixer may be implemented, for example, using ACM (audio compression manager) or DirectX technology from Microsoft Corporation. The mixer  processes the PCM data with other sources to produce a desired output. At this point, the processed data is passed to a driver  (software and\/or hardware) which outputs the data to the media output device(s) , such as a sound card and speaker, or a display.","With this traditional architecture, the data is left unprotected throughout the operating system software and hardware of the client device. Regardless of the upstream encryption and compression, the data is eventually passed to the lower level software and hardware components in a clear (unencrypted) form, which can be stolen. For instance, an attacker might introduce a fake driver  to receive the data from the mixer  and store the raw data on a storage medium  for illicit use that is not contemplated by the content provider (e.g., redistribution, multiple plays, etc.). Suppose, for example, that the media player is implemented using DirectX API layers. DirectX is an open standard that allows software applications to read sound and video data. A software package (e.g., \u201cTotal Recorder\u201d software package) can install itself as if it were a sound card driver (i.e., fake driver ) and all audio or video that flows into this virtual sound driver can be captured into a standard sound file (e.g. in \u201c.wav\u201d format).","Accordingly, there is a need for an architecture that protects bits after they have been given to the operating system. It is also desirable that the architecture integrate with an existing multimedia processing system called \u201cDirectX\u201d from Microsoft Corporation, which runs atop Windows brand operating systems. The DirectX architecture defines how to control and process streams of multimedia data using modular components called filters. Examples of filters include compressors, decompressors, renderers, mixers, parsers, splitters, and tuners for both audio and video data types. The filters have input or output pins, or both, and are connected to each other in a configuration called a filter graph. Applications use an object called the filter graph manager to assemble the filter graph and move data through it. The filter graph manager provides a set of Component Object Model (COM) interfaces so that applications can access the filter graph. Applications can directly call the filter graph manager interfaces to control the media stream or retrieve filter events, or they can use the media player control to play back media files. The reader is directed to the Microsoft web site Microsoft.com, and the file path for \u201cdirectx\u201d for more background information on DirectX, filter graphs, and individual filters.","One of the main attractions to the DirectX architecture is that it is modular and extensible. Unfortunately, these same advantageous attributes may be manipulated for improper use. For instance, a thief may insert a \u201cT\u201d into the filter graph to siphon compressed or uncompressed data to disk.","One possible approach is to secure the filter graph and the device drivers using only certified components. The drawback with this approach is that it introduces the burden of obtaining certificates for components and authenticating them during use.","Another approach is to keep the data encrypted until it reaches the driver layer . This approach has a drawback in that it may lead to poor quality output because some processing results from the filters do not transfer cleanly through the decryption algorithm when the encrypted data is subsequently decrypted, oftentimes rendering the data unrecoverable. Consider, for example, an encrypted MPEG stream. It will lose the MPEG transport layer framing and the filter graph will be unable to handle it. Another example is PCM audio. If the encrypted audio is mixed with another signal (e.g., a \u201cding\u201d from a mail program), decryption is impossible. As a final example, a volume control that multiplies an encrypted audio bit stream by a constant renders an encrypted stream unrecoverable.","Thus, there is a need for an architecture that protects data while in the operating system and hardware components of the computer and integrates with the DirectX architecture, without deterioration of the signal quality when played.","This invention concerns an architecture for protecting data streams in the operating system and hardware components of a computer.","In one implementation, a server serves encrypted and compressed content over a network to a client. The client receives the content and decrypts and decompresses it. At this point, the content is in the form of a pulse code modulated (PCM) data stream, which is essentially the raw sequence of digitized samples without compression and encryption. The PCM data stream is ready for processing (e.g., adjusting volume, mixing other sources, etc.). The client implements a set of tools to process the PCM data, such as filter graph technologies at the operating system level.","To prevent theft of the raw bits while they are being processed, the client scrambles the PCM data. One technique is to add noise by adding a random signal to the content. More particularly, the client has a scrambler to produce periodic sets of deterministic tone patterns. The scrambler modulates the amplitude of the tone patterns based on a first key, thereby embedding the first key into the modulated tone patterns. The scrambler also generates a random signal based on the first key and a second key. The tone patterns and random signal are added to the PCM data to scramble the content.","The scrambled content is passed to a filter graph or other processing system. The content is processed while in its scrambled state. Any attacker attempting to siphon off the bits while being processed in the filter graph will capture only noisy data, which is worthless for redistribution or copying purposes.","After processing, the scrambled data is passed to a driver for output. The driver implements a descrambler to unscramble the content by subtracting out the noise. The descrambler detects the tone patterns in the content and recovers the first key from the varying amplitudes of the tone patterns. The descrambler also receives the second key via a separate channel (e.g., a cryptographically secured path) and generates the same random signal based on the recovered first key and the second key. The descrambler subtracts the tone patterns and the random signal from the scrambled content to restore the PCM data to an unscrambled state, but with the modifications resulting from the processing.","In another implementation, the server scrambles the content prior to distribution over the network. The server-based scrambler cooperates with, or is integrated into, a compressing unit that compresses the content so that the compression algorithm does not render the scrambled content unrecoverable.","Client-Based Architecture",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 3","b":"100"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 3","b":"100"},"The architecture  includes a communication layer or port  that receives encrypted and compressed data from a server over a network. The data is typically encrypted using well-know algorithms (e.g., RSA) and compressed using well-known compression techniques (e.g., AVI, MPEG, ASF, WMA, MP3). The data is passed to the media player , which is preferably implemented as the \u201cWindows Media Player\u201d from Microsoft Corporation. The \u201cWindows Media Player\u201d is implemented using DirectX API (application programming interface) layers, a group of technologies designed by Microsoft to make Windows-based computers a suitable platform for running and displaying applications rich in multimedia elements such as full-color graphics, video, 3-D animation, and surround sound.","The media player  implements decryption\/decompression tools  to decrypt and decompress the content stream. At this stage, the content is in the form of a pulse code modulated (PCM) data stream, which is essentially the raw sequence of digitized samples without compression and encryption. To prevent theft of the raw bits as underlying filters process them, the media player  also implements a scrambler  to scramble the PCM data. The scrambler  modifies the data to such an extent that the bits, if stolen, would be essentially useless. For instance, scrambled audio may have a large amount of noise that sounds awful and cannot be removed, thereby negating any value in the stolen data. Yet, at the same time, the scrambled version of the audio or video looks sufficiently like real audio or video to the filters in the filter graph that normal, unmodified decoders or signal processing components work well. Thus, the scrambled content \u201clooks like\u201d unmodified content, but still guards against theft.","The scrambled PCM data is passed through an operating system API layer  to a filter graph , which processes the PCM data by adding one or more other signals, adjusting volume or tone, and so forth. The filter graph  processes the scrambled PCM data as if the data were the original, unscrambled PCM data. The filter graph  has one or more filters, such as a mixer, volume, tone, encoder, render, and the like that process the PCM data. It is noted that the filter graph  is shown for discussion purposes, but other types of signal processing technologies may be substituted for the filter graph.","The processed data is passed to a driver , which may be implemented in software and\/or hardware. The driver  implements a descrambler  to unscramble the scrambled PCM data and restore the PCM data to its pre-scrambled condition, plus the modifications made as a result of the filter graph processing. The descrambler  outputs the unscrambled, modified PCM data to the media output device(s) .","The scrambler  and descrambler  utilize one or more secret keys  to generate the scrambling signal that is added to the PCM data. The keys  may be passed between the media player  and the driver  through an in-band channel accompanying the scrambled data, and\/or via an out-of-band channel separate from the data path (e.g. the IOCTL device I\/O control channel in DirectX). One implementation of the media player  and driver , and the keys utilized to scramble and unscramble PCM data, is described below in more detail with reference to .","The scrambling architecture protects the content while it is being processed by the operating system and lower level hardware components. An attacker hoping to siphon off raw bits from the filter graph  using a fake driver  instead receives scrambled data that is worthless from a recording or redistribution standpoint, thereby eliminating any financial incentive for the theft. Moreover, it is very difficult to unscramble the data without knowledge of the keys .","Scrambling Techniques","There are different ways to implement the scrambling architecture at the client to scramble the PCM data. One approach is to add noise to the signal. In the audio context, one noise-addition scheme is to generate a set of speech, music or noise-like functions using a session key and add those functions to the signal, either directly in the time domain or in a frequency or wavelet domain. The choice of function, its amplitude, phase, and dilation is selected on the basis of the key generator. Adding a few tens of noise bursts per second renders the signal worthless to an attacker, and the space that the attacker must \u201csearch\u201d to remove the noise is quite large, even if the attacker knows the noise basis. However, given the key (and assuming no overloads) the noise signal can be subtracted exactly to return to the unscrambled state.","An alternative approach, used in prior art, is to employ time-domain and frequency-domain scrambling. In time-domain scrambling, the signal is broken into frames (e.g., 2 or 3 seconds), and each frame is broken into several segments. Within each frame, segments are permuted and reassembled. Typically, each frame uses a different permutation. A secret key controls the sequence of permutations. In frequency-domain scrambling, the signal is partitioned into overlapping frames (e.g., 50 ms), which are then mapped to the frequency domain via an FFT-based filter bank. The frequency bands are permuted and sent through a synthesis filter bank. Again, a secret key controls the sequence of permutations. Frequency-domain scrambling is harder to break than time-domain scrambling, but has the disadvantage of the additional computations for the analysis and synthesis filter banks.","The main disadvantage of time-domain and frequency-domain scrambling is that the scrambled signal cannot go through a mixer (e.g. a filter graph mixer such as  in ), because after descrambling, the mixed signals would end up being scrambled. The scrambling based on noise addition, described below, overcomes this problem: signals mixed to the scrambled audio remain intact after descrambling.","Exemplary Noise-Addition-Based Scrambling",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 4","FIG. 4","FIG. 5","FIG. 4"],"b":["100","102","112","110"]},"The process begins with the receipt of an encrypted and compressed data stream (e.g., audio, video) at the media player  (steps  and ). The media player utilizes tools  to decrypt and decompress the stream, resulting in a PCM data stream (step ). The scrambler  scrambles the PCM data by adding noise to the data (step ). The scrambler  has a tone burst generator and modulator  to generate a synchronization tone and a cryptographic pseudo random number generator (PRNG)  to generate a random signal. Both the sync tone and the random signal are added to the PCM data to produce noisy or scrambled PCM data.","The tone burst generator  and PRNG  use two levels of keys to create the sync tone and random signal: (1) an \u201cin-band\u201d key , and (2) an \u201cout-of-band\u201d or \u201csession\u201d key . Both the tone burst generator  and the PRNG  use the in-band key , while only the PRNG  uses the out-of-band key . The keys may be implemented, for example, with large bit length, such as 56-bit or 128-bit keys.","The tone burst generator and modulator  uses the in-band key to generate sets of tone bursts that can be easily recognized at the descrambler (step  in ). The tone patterns are added periodically to the PCM data signal, such as every 100 ms.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 6","b":["300","302","304","124"]},"The sync tone  has a frequency that is preferably one-half the sampling frequency of the original signal. For audio data with a sampling frequency of 44.1 kHz, the tone burst generator  generates a synchronization tone at 22.05 kHz. The tone can be easily detected at the descrambler and removed. Alternatively, even if the descrambler does not remove completely the sync tone, a digital-to-analog converter used in the driver or sound card will remove this tone frequency.","With reference again to , the cryptographic PRNG  generates a pseudo random signal using the in-band key and the out-of-band session key (step  in ).  shows an exemplary random sequence  having a random pattern of data values with amplitudes of +1 or \u22121. The PRNG  is implemented to provide an equal chance of a +1 or \u22121 output, with the overall average being zero to avoid introducing a DC shift to the original data signal.","While the in-band key  is embedded into the tone sync signal, the session key  is kept independent of the data and passed over a separate channel  from the data path. The session key  is protected using a cryptographic key exchange (e.g., a Diffie-Hellman exchange and authentication) to ensure that the key  is safely transported from the media player  to the driver  over the channel  (which can be the IOCTL device control channel in DirectX, for example). Accordingly, the scrambler  or media player  is equipped with encryption and signing capabilities to encrypt and sign the session key for secure transportation to the driver  and descrambler .","The scrambler  adds the sync tone bursts and the random signal to the PCM data via adders  to scramble the data (step  in ). If desired, the original signal (i.e., PCM data) and the random signal can be normalized to return the composite signal to a range anticipated by the filter graph . For instance, the PCM data may be multiplied by a factor 0.75 and the random signal may be multiplied by a factor 0.25 prior to adding the two signals to normalize the resulting composite signal.","The scrambled PCM data is passed to the filter graph  where it is processed and mixed with other sources (step  in ). The filter graph may have one or more filters to process the data. As an example, the filter graph may adjust the volume of the signal or may impose an arbitrary delay as part of a processing step. The filters operate on the noisy data as if the data were the raw PCM data. The filter graph outputs the modified noisy data to the driver .","At step  in , the descrambler  at the driver  descrambles the modified noisy PCM data by removing the noise component from the data. The descrambler  has a tone detector and demodulator , a cryptographic PRNG , and a hardware interface . The tone detector and demodulator  detects the synchronization tone in the composite signal, measures any volume and delay introduced by the filter graph , and demodulates the tones to recover the in-band key  (step  in ). The tone detector  passes the recovered in-band key  to the PRNG .","The descrambler  also receives the session key  from the out-of-band channel , decrypts and authenticates it, and gives the key  to the PRNG . The descrambler is equipped with decryption and verification means to decrypt and authenticate the session key as having been sent from the media player . The PRNG  implements the same algorithm as that used in the media driver's PRNG . Given the same in-band key  and session key , the PRNG  recreates the same random signal that was previously added to the PCM data at the media player (step  in ).","The descrambler  subtracts the sync tone and random signal from the noisy PCM data via subtractors  to remove the noise (step  in ). The PCM data is passed through the hardware interface  to the output devices (e.g., sound card, display) where the process ends (steps  and ).",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 8","b":["140","112","500","500"]},{"@attributes":{"id":"p-0063","num":"0062"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"y","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"n"}},{"munderover":{"mo":"\u2211","mrow":{"mi":"l","mo":"=","mrow":{"mo":"-","mi":"L"}},"mi":"L"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mrow":[{"mi":"h","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"l"}},{"mi":"x","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["n","l"],"mo":"-"}}}],"mo":"\u2062"}}],"mo":"="}}},"br":{},"b":"506"},"The delay value and the noisy data are passed to a peak search module  that estimates any volume change imposed by the filter graph . The module estimates the appropriate gain  (by which the regenerated tone bursts and PRGN noise should be multiplied prior to the subtraction ) through a search procedure, in which a gain estimate is iteratively refined until the signal energy after tone subtraction is minimized. The regenerated sync tone with the correct gain and delay is produced in module .","Detection of the in-band key is performed by amplitude demodulation module . For each tone burst, the module compares the burst amplitude with the average tone burst amplitude measure over a few past intervals. If the amplitude is above the average (say the amplitude is equal to 1.0 and the average is 0.75), then a bit of the key is demodulated as having one binary value (say \u201cone\u201d). If the amplitude is below that average (say the amplitude is equal to 0.5 and the average is 0.75), then a bit of the key is demodulated as having the other binary value (say \u201czero\u201d). The process is repeated for subsequent tone burst until all bits of the in-band key  are recovered. The in-band key  can then be used by the cryptographic PRNG  to regenerate the random noise sequence to be subtracted from the scrambled signal.","In the above implementation, noise is introduced to the content by adding both a sync tone and a random signal. Alternatively, the content may be scrambled by XORing at least a portion of the content with a random bit stream generated by the PRNG . For instance, for 16 bit audio, the least significant 13 bits are XORed with bits generated by the PRNG . This effectively scrambles the content, with the additional property that one cannot \u201coverflow\u201d the integer representing the sound. To descramble the content, the lower bits are once again XORed with the same random bit stream.","The scrambling architecture is beneficial in that it protects the data content while in the operating system and hardware components of the computer. Another advantage is that the architecture integrates well with the existing DirectX technology. Although the invention has been described in language specific to structural features and\/or methodological steps, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or steps described. Rather, the specific features and steps are disclosed as preferred forms of implementing the claimed invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The same numbers are used throughout the drawings to reference like elements and features.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 5","FIGS. 3 and 4"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 8","FIG. 4"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
