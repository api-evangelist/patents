---
title: System and method for implementing a distributed keystore within an enterprise network
abstract: A keystore is described which provides unique views of certificates and keys to particular application components and/or users. Upon receiving a request from a user and/or an application component to view keystore data, the keystore system implements a first set of security restrictions associated with the request and provides a limited view of the keystore data to the requesting user and/or application component based on the results of the first set of security restrictions. Then, upon detecting an attempt by the user and/or application component to access specified portions of the keystore data provided in the view, the keystore system implements a second set of security restrictions associated with the attempt to access the specified portions of the keystore data, and provides access to the keystore data to the user and/or application component based on the results of the second set of security restrictions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07823190&OS=07823190&RS=07823190
owner: SAP AG
number: 07823190
owner_city: Walldorf
owner_country: DE
publication_date: 20040602
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","Multi-Tier Enterprise Computing Systems","Security within a Multi-Tier Architecture","SUMMARY","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS","An Exemplary Network Architecture","System and Method for Implementing a Distributed Keystore within an Enterprise Network","Using a Monitor Service to Monitor a Keystore"],"p":["1. Field of the Invention","This invention relates generally to the field of data processing systems. More particularly, the invention relates to a system and method for managing a keystore within a distributed enterprise architecture.","2. Description of the Related Art","JAVA\u2122 2 Enterprise Edition (\u201cJ2EE\u201d) is a specification for building and deploying distributed enterprise applications. Unlike traditional client-server systems, J2EE is based on a multi-tiered architecture in which server side program code is divided into several layers including a \u201cpresentation\u201d layer and a \u201cbusiness logic\u201d layer.",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1","b":["100","111","101","119","109","117"]},"As illustrated in , each layer of the J2EE architecture includes multiple containers. The Web container , for example, is itself comprised of a servlet container  for processing servlets and a JAVA\u2122 Server Pages (\u201cJSP\u201d) container  for processing JAVA\u2122 server pages. The EJB container  includes three different containers for supporting three different types of enterprise JAVA\u2122 beans: a session bean container  for session beans, a entity bean container  for entity beans, and a message driven bean container  for message driven beans. A more detailed description of J2EE containers and J2EE services can be found in RGKK, SAMS TYEJB 21 D(2003) (see, e.g., pages 353-376).","Distributed computing architectures such as J2EE employ a variety of techniques for implementing system security including authentication, authorization, encryption (both symmetric and asymmetric), and digital signatures and certificates. \u201cAuthentication\u201d refers to verifying the identity of a client or application component. The most well known form of authentication involves the submission by the client\/component of a unique user name and password. \u201cAuthorization\u201d involves controlling access to system resources (e.g., sections of the database, features of an application, . . . etc) based on the identify of the client or component. For example, once authenticated an \u201cadministrator\u201d will typically be authorized to access any area of a J2EE application server, whereas a typical user's access will be restricted to specified regions.","Data \u201cencryption\u201d refers to the process of encoding data so that it can only be decrypted by other applications\/users with an encryption \u201ckey.\u201d In symmetric encryption, the same key used to encrypt the data is used to decrypt the data. By contrast, asymmetric encryption uses two keys: one which is used to encrypt the data and another which is used to decrypt the data. One of the two keys us typically made public (the \u201cpublic key\u201d), while the other is kept private to the key owner (the \u201cprivate key\u201d). When data is encrypted using the public key, only the key owner can decrypt it. Conversely, when the data is encrypted using the private key, the data can only be decrypted using the public key. Thus, the ability to decrypt data using the public key verifies that the originator of the data must be the key owner.","A \u201cdigital signature\u201d represents a digital guarantee that a file has not been altered (e.g., as if it were carried in an electronically sealed envelope). The \u201csignature\u201d is an encrypted digest (e.g., one-way hash function) of the encrypted data. The recipient decrypts the digest that was transmitted with the data and also recomputes the digest from the received data. If the digests match, the data is verified as valid.","To verify that the data was sent by the person or organization claiming to send it requires a \u201cdigital certificate\u201d which is issued by a certification authority. A signed digital certificate contains a message digest of the certificate encrypted using the private key of the certificate authority. Thus, any recipient of the certificate can decrypt the digest using the certificate authority's public key (i.e., and verify that the reminder of the certificate has not been corrupted). Digital certificates are specified by the X509 international standard which specifies a format for representing public keys and other types of information related to an entity (e.g., a user, application, company or any other entity with a public key).","In a J2EE system, a storage unit referred to as a \u201ckeystore\u201d is used to manage all of the system's keys and certificates. Applications can access the keystore through an implementation of the KeyStore class in the JAVA\u2122 security package.","As illustrated in , a prior art keystore  is managed in a single, centralized location and is accessible via a single keystore application programming interface (\u201cAPI\u201d)  (developed by Sun Microsystems\u2122). As a result, applications and\/or other clients - must compete for access to the keystore, resulting in inefficient retrieval of keys - and\/or certificates -, particularly in a large enterprise network. In addition, the prior art keystore API  either grants access or denies access to particular keys and certificates within the keystore , but does not uniquely tailor the views of the keystore  based on the identity of the different application components and\/or users. Thus, each component and\/or user - will be provided with essentially the same view of the keystore .","A keystore is described which is designed to work more efficiently in a distributed enterprise environment. The keystore provides unique views of the certificates and keys to particular application components and\/or users. In one embodiment, upon receiving a request from a user and\/or an application component to view keystore data, the keystore system implements a first set of security restrictions associated with the request to view the keystore data and provides a limited view of the keystore data to the requesting user and\/or application component based on the results of the first set of security restrictions. Then, upon detecting an attempt by the user and\/or application component to access specified portions of the keystore data provided in the view (e.g., to use the keystore data), the keystore system implements a second set of security restrictions associated with the attempt to access the specified portions of the keystore data, and provides access to the keystore data to the user and\/or application component based on the results of the second set of security restrictions.","Described below is a system and method for managing multiple application server clusters using a central management arrangement. Throughout the description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, to one skilled in the art that the present invention may be practiced without some of these specific details. In other instances, well-known structures and devices are shown in block diagram form to avoid obscuring the underlying principles of the present invention.","Note that in this detailed description, references to \u201cone embodiment\u201d or \u201can embodiment\u201d mean that the feature being referred to is included in at least one embodiment of the invention. Moreover, separate references to \u201cone embodiment\u201d in this description do not necessarily refer to the same embodiment; however, neither are such embodiments mutually exclusive, unless so stated, and except as will be readily apparent to those skilled in the art. Thus, the invention can include any variety of combinations and\/or integrations of the embodiments described herein.","In one embodiment of the invention, the management techniques which are the focus of this application are used to manage resources within a cluster of application servers. An exemplary application server architecture will now be described, followed by a detailed description of the improved keystore architecture and associated processes.","An application server architecture employed in one embodiment of the invention is illustrated in . The architecture includes a central services \u201cinstance\u201d  and a plurality of application server \u201cinstances\u201d , . As used herein, the application server instances,  and , each include a group of server nodes , ,  and , , , respectively, and a dispatcher, , , respectively. The central services instance  includes a locking service  and a messaging service  (described below). The combination of all of the application instances ,  and the central services instance  is referred to herein as a \u201ccluster.\u201d Although the following description will focus solely on instance  for the purpose of explanation, the same principles apply to other instances such as instance .","The server nodes , ,  within instance  provide the business and\/or presentation logic for the network applications supported by the system. Each of the server nodes , ,  within a particular instance  may be configured with a redundant set of application logic and associated data. In one embodiment, the dispatcher  distributes service requests from clients and\/or application components to one or more of the server nodes , ,  based on the load on each of the servers. For example, in one embodiment, the dispatcher  implements a round-robin policy of distributing service requests (although various alternate load balancing techniques may be employed).","In one embodiment of the invention, the server nodes , ,  are JAVA\u2122 2 Enterprise Edition (\u201cJ2EE\u201d) server nodes which support Enterprise JAVA\u2122 Bean (\u201cEJB\u201d) components and EJB containers (at the business layer) and Servlets and JAVA\u2122 Server Pages (\u201cJSP\u201d) (at the presentation layer). Of course, certain aspects of the invention described herein may be implemented in the context of other software platforms including, by way of example, Microsoft\u00ae .NET platforms and\/or the Advanced Business Application Programming (\u201cABAP\u201d) platforms developed by SAP AG, the assignee of the present application.","In one embodiment, communication and synchronization between each of the instances ,  is enabled via the central services instance . As illustrated in , the central services instance  includes a messaging service  and a locking service . The message service  allows each of the servers within each of the instances to communicate with and synchronize with one another via a message passing protocol. For example, messages from one server may be broadcast to all other servers within the cluster via the messaging service . In addition, messages may be addressed directly to specific servers within the cluster (i.e., rather than being broadcast to all servers).","In one embodiment, the locking service  disables access to (i.e., locks) certain specified portions of configuration data and\/or other program code (e.g., such as keystore data) stored within a central database . A locking manager ,  employed within the server nodes locks data on behalf of various system components which need to synchronize access to specific types of data and program code (e.g., such as the configuration managers ,  illustrated in ). As described in detail below, in one embodiment, the locking service  enables a distributed caching architecture for caching copies of various types of server\/dispatcher data including keystore data (as described below).","In one embodiment, the messaging service  and the locking service  are each implemented on dedicated servers. However, the messaging service  and the locking service  may be implemented on a single server or across multiple servers while still complying with the underlying principles of the invention.","As illustrated in , each application server (e.g., , ) includes a lock manager ,  for communicating with the locking service ; a cluster manager ,  for communicating with the messaging service ; and a configuration manager ,  for communicating with a central database  (e.g., to store\/retrieve configuration data). Although the lock manager , , cluster manager ,  and configuration manager ,  are illustrated with respect to particular server nodes,  and , in FIG. , each of the server nodes , ,  and  and\/or on the dispatchers ,  may be equipped with equivalent lock managers, cluster managers and configuration managers.","In one embodiment of the invention, the distributed architecture described above is employed to distribute keystore data throughout the cluster. Referring now to , in one embodiment, keystore data  is stored within the central database . The keystore data may include private cryptographic keys, public certificates or any other type of security data associated with particular users and\/or application components.","To improve the speed at which the servers and dispatchers access the keystore data and to improve security, a keystore provider service  accessible throughout the cluster caches keystore data locally within local keystore caches , . In addition, in one embodiment, the keystore provider service  uses the cache synchronization policies of the configuration manager ,  to ensure the integrity of the keystore data in a distributed environment.","One embodiment of a method for synchronizing the keystore  across each of the application server instances ,  and the central services instance  is illustrated in . for the purpose of illustration, it is assumed initially that certain portions of the keystore data from the central database are cached locally within configuration cache  and configuration cache .","At  of , a user or network administrator attempts to access or modify the keystore data stored within configuration cache  on application server . In response, the configuration manager  attempts to acquire a lock on the relevant portions of the keystore data by transmitting a lock request to the locking service . If the keystore data is not being currently modified by another transaction, then the locking service locks the keystore data on behalf of the configuration manager . Once locked, the configuration managers  of other server nodes  will not be permitted to access or acquire a lock on the keystore data.","At , the keystore data within the configuration cache  of application server  is modified. At , the cluster manager  broadcasts an indication of the modified keystore data to the cluster manager  on server node  and the cluster manager of other server nodes (i.e., via the messaging service ). At , the modifications to the keystore data are committed to the keystore  within the central database . At , the cluster manager  notifies the cluster manager  on server node  and the cluster managers of other server nodes of the central database update. In response, the configuration manager  invalidates the modified keystore data from its cache  and, at , loads the new keystore data from the central database . In one embodiment, the configuration manager  only downloads the portion of the keystore data which has been modified (i.e., rather than the entire set of keystore data). In one embodiment, to determine whether it needs to update its keystore data, the configuration manager  compares the version of its keystore data with the version of the keystore data stored the central database.","Although described above in the context of a central keystore configuration in which keystore data is distributed to a plurality of keystore caches, it will be appreciated that a \u201ccentral\u201d keystore configuration is not required for complying with the underlying principles of the invention. For example, in one embodiment, multiple separated and independent physical key stores may be employed on each of the server nodes in the cluster. Different views of the separate, distributed keystores may then be provided to requesting application components and\/or users by the keystore provider service . In one embodiment, the independent keystore implementations are individual Sun Microsystems\u2122 keystore APIs managed by the keystore provider service . In this embodiment, each individual keystore API may be identified by a unique name (e.g., an alias) or other type of unique identification code.","In addition to distributing the keystore data throughout the cluster as described above, one embodiment of the invention improves security associated with the keystore by providing only limited views of the keystore to users and\/or application components. As illustrated in , this embodiment includes a keystore view manager  for generating different keystore views. In one embodiment, the different views are generated based on the identify of the user and\/or application component. As described in greater detail below, a set of view\/entry restrictions  are implemented by the keystore view manager  when generating specific views and providing limited keystore access for each user\/component. In the specific example shown in , while the keystore  is comprised of a full set of keys and\/or certificates -, a limited view of the keystore  is provided to each of three clients\/components -. Specifically, client\/component  is provided with a view of keys\/certificates -; client\/component  is provided with a view of keys\/certificates -; and client\/component  is provided with a view of keys\/certificates -. Each of these views may be defined within the set of view\/entry restrictions  (e.g., generated by an administrator or user).",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 7","FIG. 7","FIG. 7"],"i":["a ","b ","b"],"b":["602","700","710"]},"At , the keystore service implements a first set of security restrictions and allows access to the requested (i.e., from the user\/component) keystore view based on the user\/component identity. In , for example, different view level security requirements are applied to Applications K and M at . Various types of authentication may be employed to verify the identity each user and\/or application component requesting a particular view (e.g., via a valid ID code and password provided by the user\/component).","After the specific view is provided to a particular user\/component, at , the user\/component may attempt to access specified portions of keystore data provided in view, referred to herein as an \u201centry\u201d into the keystore from the view provided to the user\/component. For example, a particular application component may attempt to access a private key stored within the keystore .","At , in response to detecting the attempted entry from the specific view, the keystore provider service  implements a second set of security restrictions and provides access to the user\/component based on the results of the second set of restrictions. In , for example, different entry level security requirements are applied to Applications K and M at . The second set of security restrictions may include a separate authentication mechanism for the user\/component. The end result in the example shown in , is that Applications K and M are provided with unique views and storage contexts when accessing the keystore .","In one embodiment, the keystore provider service  may impose the first and\/or second set of security restrictions on both a per code and a per user basis. In one embodiment, the code-based and user-based security checks are executed independently of one another and both must succeed to pass a particular set of security restrictions.","For example, in an SSL server implementation, the SSL server may require two sets of keystore entries: server credentials (i.e., a private key and public key pair) and a set of public keys of all trusted certificates authorities (i.e., all SSL client public keys must be signed by some trusted CA public key, to be accepted from the SSL server). In prior systems, all of these keystore entries were stored in a single common keystore view. Using the embodiments of the invention described herein, however, the SSL server may be provided with two different views and access restrictions. One view, for example, may be provided for the server credentials (i.e., which includes all used private+public key pairs), and another view may be provided for the trusted CA certificates public keys. The trusted CA \u201cview\u201d may include free read access for all applications and users (which is logical because it contains only public keys), whereas the server credentials \u201cview\u201d may be is restricted to be accessible only for the SSL server and the users with administrator's rights.","Note that in the foregoing example, the application and the user may not receive the keystore instance if they both do not have the appropriate code-based and user-based security permissions. They may not even be able to see that this view of the keystore exists at all. In addition, even if a view is provided, the application and the user may not be provided with entry without the necessary code-based and user-based security permissions (i.e., an entry alias will not be listed in the view result).","When digital certificates such as X.509 certificates expire, they will no longer be accepted by remote peers and will fail the standard SSL handshake required to initiate SSL sessions. Thus, it is important for the system administrator to be notified before any such certificates expire so that undesirable connection failures can be prevented.","To this end, one embodiment of the invention employs a monitor service to monitor various aspects of the keystore  to ensure that the keystore is up-to-date and functioning properly. For example, one embodiment of the invention provides monitors to monitor the expiration of the certificates in use and notify the administrator when a certificate is about to expire.","In one embodiment of the invention, the monitor service is built around the JAVA\u2122 Management Extensions (\u201cJMX\u201d) Standard. Accordingly, a description of the JMX standard and certain enhancements to that standard will now be provided.","As illustrated in , the JMX architecture is divided into three levels: an \u201cinstrumentation\u201d level ; an \u201cagent\u201d level ; and a \u201cmanager\u201d level . At the instrumentation level , JAVA\u2122 management beans (\u201cMBeans\u201d) ,  are used to manage manageable system resources , , respectively. A \u201cmanageable\u201d resource is a resource that has been instrumented in accordance with the JMX instrumentation-level specification. By way of example, a manageable resource may include components of a business application, a device, or the implementation of a service or policy. MBeans ,  are JAVA\u2122 objects that represent the JMX manageable resources , .","An MBean server  at the agent level  is a registry for MBeans. A JMX \u201cagent\u201d is composed of an MBean server , a set of MBeans ,  registered with the MBean server  (i.e., representing managed resources , ), and one or more protocol adaptors and\/or connectors . The MBean server  is a J2EE component which provides services that allow the manipulation of MBeans. All management operations performed on MBeans are performed via the MBean server .","The manager level  provides management components that can operate as a manager or agent for distribution and consolidation of management services. Different management interfaces may be employed at the management level such as Web Browsers  and\/or proprietary management applications , . JMX managers  implemented within the manager level  provide an interface for management applications to interact with the agent, distribute or consolidate management information, and provide security.","A detailed description of the JMX specification can be found on the Sun Microsystems\u2122 Website.","In one embodiment of the invention, a management architecture specifically adapted to a clustered enterprise environment described above. Specifically, in one embodiment, each server, dispatcher, and\/or central services instance (referred to generally as \u201cnodes\u201d) within the system is provided with a dedicated MBean server to register MBeans for monitoring specified system resources.","Virtually any type of system resource may be monitored in this manner including, but not limited to application resources, kernel resources, services, managers, components, interfaces and libraries associated with the individual nodes within the system. By way of example, within a J2EE engine, state information related to memory management, thread management, locking and licensing may be of particular importance. Once collected, this information may be combined and provided in a comprehensive manner to the end user or system administrator.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 9","FIGS. 3-4"],"b":["904","910","920","904","910","920","312","318","300"]},"In the illustrated embodiment, separate MBean servers , , and , are executed on each of the nodes , , and , respectively. Different types of MBeans may register with each of the MBean servers to monitor different types of system\/node resources. For the purpose of illustration, only two MBeans are shown registered with each MBean server in . Specifically, MBeans  and  are registered with MBean server  on node ; MBeans  and  are registered with MBean server  on node ; and MBeans  and  are registered with MBean server  on node . It will be appreciated that, in an actual implementation, significantly more MBeans may be registered with each MBean server and a significantly greater number of nodes may be employed on the system.","In one embodiment, a central monitoring service  employed within the distributed configuration hides the clusterization of the various MBean servers and provides a unified view of managed resources at the manager level . Specifically, monitor integration logic  associated with the central monitoring service  combines the monitoring data collected from each of the individual MBean servers , ,  and generates an comprehensive, logical view of the monitored resources. The monitoring data may then be displayed on a visual administrator  and\/or any other type of graphical user interface  (e.g., such as a standard Web browser). In one embodiment, the integration logic  combines the monitoring data based on monitor configuration information  (e.g., node layout, monitoring parameters, . . . etc) stored within the central database . As described below with respect to -, in one embodiment, the monitor integration logic  includes monitor MBeans arranged in a logical monitor tree hierarchy.","The central monitor service , clients  and\/or any other module\/object may communicate with the MBean servers , ,  via protocol adapters and\/or connectors, represented in  as blocks , , , , , and . Protocol adapters and connectors are similar in that they serve the same general purpose\u2014i.e., to expose an MBean server to managing entities. The primary difference between them is how they accomplish this task. Protocol adapters generally listen for incoming messages that are constructed in a particular protocol (e.g., such as like HTTP or SNMP). As such, protocol adapters are comprised of only one component that resides in the MBean server. For example, if client  is a browser-equipped client, it may communicate with the MBean server  via an HTTP protocol adapter .","By contrast, connectors are generally comprised of two components, one which resides on the MBean server and the other which resides on the client-side applications. Thus, connectors hide the underlying protocol being used to contact the MBean server (i.e., the entire process happens between the connector's two components). Throughout this detailed description, it is assumed that communication with an MBean server occurs via a protocol adapter and\/or connector of that MBean server, notwithstanding the fact that the protocol adapter\/connector may not be explicitly described or illustrated.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 10","i":"a ","b":["1000","900","1001","1001","900","940"],"sub":["\u2014","\u2014"]},{"@attributes":{"id":"p-0072","num":"0071"},"figref":["FIG. 10","FIGS. 10"],"i":["b ","a","b "],"b":["1000","1005","1006","1006"]},"As described above, MBeans may be used to represent and provide data related to virtually any type of system resource (e.g., a manager, service, application, . . . etc). In one embodiment of the invention, during runtime, data may either be pulled periodically from the underlying MBean\/resource (\u201cpassive instrumentation\u201d) or, alternatively, the MBean\/resource may be configured to push the monitoring data to the monitor service using a specified event mechanism (\u201cactive instrumentation\u201d).","One particular embodiment, illustrated in , employs two different types of MBeans to perform passive and\/or active instrumentation functions: resource MBeans  (also referred to herein as \u201cruntime\u201d MBeans) and monitor MBeans . Resource MBeans, also referred to herein as \u201cruntime\u201d MBeans, are associated with the underlying system resources such as kernel resources, components, libraries, . . . etc. Monitor MBeans are generated by the central monitor service  and are mapped to the resource MBeans according to the monitoring configuration data  stored within the central database .",{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIG. 11","FIG. 11","FIG. 13"],"i":["b ","a"],"b":["1150","1152","1105","1154","1105","1105","940","230","1105","900","230"]},"At , the central monitor service  installs the monitor MBeans  based on the monitor configuration data  stored within the central database . In one embodiment, the central monitor service  arranges the Monitor MBeans  within a hierarchical monitor tree , representing the logical relationships between the resources in each of the nodes in the cluster. As mentioned above, monitor information from the monitor tree  (or subsections thereof) may be displayed within a graphical visual administrator  or other user interface.","At , resource MBeans  are mapped to monitor MBeans  within the monitor tree , thereby establishing a link between each monitor MBean and the resource which it represents. For example, each monitor MBean  within the monitor tree  may have a resource identifier associated therewith, identifying the resource (or resource MBean) which it represents. Once the mapping is complete, the monitoring architecture is executed and, at , monitor updates are provided from the resource MBeans to their associated monitor MBeans. The monitor updates may then be displayed as a monitor tree within the visual administrator .","As mentioned above, different types of monitor updates may be employed within the system. By way of example, and not limitation, this may include string monitors which monitor text as a string value; integer monitors which monitor an \u2018int\u2019 value; table monitors which monitor a table containing a header and contents (e.g., wherein each header element is a string and each table element is a serializable object); state monitors which are similar to string monitors but have the additional property of assigning colors (e.g., green, yellow, red) to the string values (e.g., for indicating the state of the associated resource within the visual administrator); availability monitors which monitor a boolean value indicating whether the resource is available; frequency monitors which compute a frequency according to reported number of events given at specific times; quality rate monitors which compute an average (and actual) quality rate according to reported number of total tries and successful tries (e.g., one successful try from a total amount of 10 tries would result in a quality rate of 10%); pool monitors which monitor a pool characterized by (a) configurable values for minimum\/maximum pool size, initial pool size and increment size when increasing the pool, and (b) runtime values for the number of current used objects and current pool size; and cache monitors which monitor a cache characterized by a configurable maximum cache size and\/or the number of current used objects. It should be noted, however, that the foregoing examples are for the purpose of illustration only. The underlying principles of the invention are not limited to any particular monitor types.","In addition, as mentioned above, resource data may either be pulled periodically from the underlying resource MBean (\u201cpassive instrumentation\u201d) or, alternatively, the resource MBean may be configured to push the monitoring data to the monitor service using a specified event mechanism (\u201cactive instrumentation\u201d). Different examples of resource data transmission are described below with respect to -",{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 12","i":"a ","b":["1102","1103","1102","1103"]},"By contrast, illustrates an embodiment in which the runtime MBean  transmits a runtime notification  to the monitor bean , thereby notifying the monitor MBean that new monitoring data related to the associated resource  is available. Upon receiving the notification  from the runtime MBean , the monitor bean  may send a request  to the runtime MBean  requesting the new monitoring data. In response, the runtime MBean  transmits the information  including monitoring data regarding the associated resource  to the monitor MBean . Alternatively, depending on the configuration of the monitor bean , it may choose not to retrieve the information .",{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 12","i":"c ","b":["1102","1202","1103","1206","1101","1112","1110","1112","1206"]},"In one embodiment, the specific data delivery mechanism employed for each monitor MBean and each Resource MBean is user-configurable (e.g., via the visual administrator  or other graphical management client). The user may employ an active data delivery mechanism for some types of resources and a passive data delivery mechanism for other types or resources. For example, resources identified as having a relatively higher priority may be configured with active data delivery mechanisms (such as those illustrated in -), whereas resources which are identified as having a relatively lower priority may be configured with passive mechanisms (such as those illustrated in ). Accordingly, high priority resource updates will be communicated immediately from runtime beans  to monitor beans  (and displayed for the administrator) in response to the resource reaching a predetermined threshold value.","By contrast, relatively low priority resource updates may only be provided by the runtime bean  upon request from the monitor bean . As mentioned above, the request may be triggered by the timer service  and\/or in response to a manual request for the resource information via the visual administrator or other graphical administration interface.","Whether a resource is identified as \u201chigh\u201d or \u201clow\u201d priority is dependent on the particular requirements of the end user. As a general rule, however, resources which are required for the application server to function properly (e.g., memory resources, threads, available mass storage space) may be placed above those resource which are not required for basic system functionality (e.g., logging and tracing functions). In one embodiment, a default\/suggested configuration for critical and non-critical resources is provided, which may then be modified by the system administrator.","In addition, in one embodiment, individual runtime beans and resource beans may be configured to provide both active and passive delivery functions, depending on the conditions of their monitored resources. For example, a particular runtime bean may be configured to provide passive updates in response to timer-triggered or user-triggered requests and to also provide active updates in response to the resource reaching a specified threshold value.","Various different resources may be monitored using the active\/passive data delivery techniques described above. By way of example, and not limitation, these may include network connection resources, threads, processor usage on each server node, classloaders, database connections, database transactions, HTTP cache size and\/or the number of current used objects, JAVA\u2122 Messaging Service (\u201cJMS\u201d) queues and topics, server socket connections, and sessions.",{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 13","b":["940","900","1300","1100","1304","1306","1305","230"]},"In one embodiment, the XML technology is integrated with a JAVA\u2122 2 Platform Enterprise Edition (J2EE) engine for electronic data interchange, and due to XML's characteristics of being broad and relatively easy to use. To support and build the XML technology, including the XML file , in the J2EE engine, application programming interfaces (\u201cAPIs\u201d)  may be employed to use the XML file  to configure various components and application modules. For example, the XML file  may be used to facilitate components and modules of the monitor service  to generate the monitor tree .","According to one embodiment, the API  may is a JAVA\u2122-compliant API. Examples of JAVA\u2122 APIs include the J2EE XML API, JAVA\u2122 API for XML Processing (\u201cJAXP\u201d), JAVA\u2122 Messaging Service (\u201cJMS\u201d) API, JAVA\u2122 API for XML Messaging (\u201cJAXM\u201d), JAVA\u2122 Transaction API (\u201cJTA\u201d), JAVA\u2122 API for XML-Remote Procedure Call (\u201cJAX-RPC\u201d), JAVA\u2122 API XML Binding (\u201cJAXB\u201d), and JAVA\u2122 API for XML Registries (\u201cJAXR\u201d), to name a few. The API  may facilitate both the creation and customization of the monitor tree  as well as the reporting of the monitoring information and values. Multiple XML files may be used and similarly, multiple API may be used to generate the monitor tree .","As mentioned above, the XML file  may include semantics  and directives  used by the monitor service  to generate the monitor tree . The semantics  of the XML file  comprises the primary information about the monitor tree , the monitor MBeans (monitor beans), and the resources to be monitored by each of the MBeans. The semantics  include a code or a set of instructions for generating the monitor tree . The set of instructions may include, for example, the instructions for setting color-coded marks representing corresponding status of the resources within the visual administrator  or other graphical interface or system  (e.g., within the displayed monitor tree). For example, in one embodiment, a green mark indicates monitoring of the corresponding resource; a yellow mark indicates continuous monitoring of the corresponding resource, and may also indicate that the resource being monitored may be reaching a critical value or stage; and a red mark indicates that the corresponding resource may have reached a critical value. Finally, a white mark may indicate inactivity, or that the corresponding resource is not being monitored. Of course, the underlying principles of the invention are not limited to any particular set of color-coded marks.","According to one embodiment, the directives  specify the form in which the monitor tree  is generated. Stated differently, the directives  provide installation instructions on how the semantics  are to be implemented. For example, the directives  may include one or more templates to match various monitor beans with corresponding associated resources at various nodes of the monitor tree . The monitor service  employs the API  to generate the monitor tree  based on the semantics  and the directives .","The semantics  and the directives  of the XML file  may include elements (e.g., similar to HyperText Markup Language (\u201cHTML\u201d) tags) to provide context to the information contained within the XML file . The XML file  may be document-centric to be used by humans or data-centric to be used by another software application or module containing data extracted from a database, such as the central database , and may be submitted to the API .",{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 14","b":["1305","1304","1306","1005","1402","1305","1406","1305","1402","1304","1306","1305"]},"The XML parser  may provide an application  (or other type of software module) with access to the elements of the XML file  to establish a link between the XML file  and other components or modules, such as the application programming interface (\u201cAPI\u201d) , of the monitoring architecture . For example, the API  and the XML parser  may be used to generate the monitor tree  (e.g., by assigning the various monitor MBeans  to their associated resources at various nodes within the monitor tree ). According to one embodiment, for the purposes of customizing the monitor tree , the API  may include a bootstrapper which includes a code or a sequence of codes to initiate relationships between component agents and the MBeans . Customizing of the monitor tree  may include establishing values (e.g., thresholds, descriptions, . . . etc) that may be registered along with each monitor MBean .","The XML file  may be parsed in several ways including using the Document Object Model (\u201cDOM\u201d), which reads the entire XML file  and forms a tree structure, or using the Simple API for XML (\u201cSAX\u201d), which is regarded as an event-driven parser that reads the XML file  in segments.","The API  may be a JAVA\u2122 Management Extensions (JMX)-based API. Examples of JAVA\u2122 or JMX-based APIs include J2EE XML API, JAVA\u2122 API for XML Processing (\u201cJAXP\u201d), JAVA\u2122 Messaging Service (\u201cJMS\u201d) API, JAVA\u2122 API for XML Messaging (\u201cJAXM\u201d), JAVA\u2122 Transaction API (\u201cJTA\u201d), JAVA\u2122 API for XML-Remote Procedure Call (\u201cJAX-RPC\u201d), JAVA\u2122 API XML Binding (\u201cJAXB\u201d), and JAVA\u2122 API for XML Registries (\u201cJAXR\u201d).","As described above with respect to , runtime MBeans  may be configured to actively transmit monitoring information related to the resource  with which they are associated. In addition, one embodiment illustrated in , employs a notification service  to provide a comprehensive view of all of the notifications generated by the runtime MBeans across the entire cluster. For example, certain MBeans may be configured to generate active \u201cnotifications\u201d to the notification service  on certain specified events such as start\/stop, get\/set properties, etc, of their associated resources. The notification service  then provides a cluster-wide indication of these specified events to any visual administrator (or other type of client) coupled to any node within the cluster. Two different users connected via two different machines may use the notification service to view a comprehensive, up-to-date state of the system.","Thus, referring to the specific example illustrated in , MBean  may be configured to generate active notifications in response to certain specified events. In response to detecting one of the events, the MBean  generates a notification which is received by the notification service  (i.e., via MBean server ). The notification service  then communicates the MBean notification to all other nodes within the cluster and provides the notification to any objects that are registered with the notification service  as listeners. Accordingly, the notification will be viewable from client  coupled directly to node , as well as client , coupled directly to the node on which the notification was generated. In other words, a single, unified view of cluster-wide notifications is available from any of the nodes in the cluster. In one embodiment, the notification service  utilizes the message passing architecture provided via the central services instance  shown in  to enable cluster-wide communication of MBean notifications (e.g., by exchanging notifications via the messaging service ).","Notifications may take on various forms while still complying with the underlying principles of the invention. In one embodiment, each notification will have a time stamp, sequence number, and a human-readable message indicating the type of notification, and the reason for the notification (e.g., a particular threshold value was reached, a resource went offline, . . . etc).","In one embodiment, a notification application programming interface is defined to enable use of notifications. For example, a \u201cNotification Broadcaster\u201d class may be employed for notification generators (e.g., MBean  in the previous example). In addition, a \u201cNotification Listener\u201d class may be employed for any objects interested in receiving notifications. In one embodiment, a \u201cNotification Filter\u201d class may also be defined for filtering out certain types of notifications (e.g., on behalf of certain specified Notification Listeners).",{"@attributes":{"id":"p-0102","num":"0101"},"figref":["FIG. 16","FIG. 11"],"b":["900","1501","1105","1208","1105","1110","900","1101","1110","1100","1101","1102","1102","1103"],"i":["a","b"]},"In one embodiment, the administration service  provides for registration of two logical types of MBeans: standard MBeans and specific beans. Standard MBeans may provide standard functionality of start\/stop and get\/set properties of their associated resources. Standard MBeans may be registered by default for all deployed components or resources (e.g., kernel, libraries, interfaces, services, etc). By contrast, specific beans may provide component-specific functionalities that may vary from one component to another. To have specific beans, a component may register an object that may implement a specific interface to list the processes available for its management and to extend the management interface (e.g., \u201ccom.company.engine.frame.state.ManagementInterface\u201d).","For kernel resources, a standard bean may be registered with each manager having a specific bean. A prerequisite for this may be to return a non-null value in a method (e.g., getManagementInterface( )) from the manager interface. For libraries and interfaces, only standard beans may be registered. For services, except for the already registered standard beans, each of the services may register specific beans, and implementation of the management interface may also cause a specific bean to be registered for that particular service.","The adapter service  employed in one embodiment of the invention is part of the manager level  of the monitoring architecture (see, e.g., ). The adapter service  may include the following components: (1) a remote connector ; (2) a \u201cconvenience\u201d interface ; (3) a \u201cswing-based\u201d Graphical User Interface (\u201cGUI\u201d) ; and (4) a shell command interface . The adapter service  provides remote access to the MBean server  via The remote connector . For example, users may connect from a remote client and view monitoring information relating to monitored resources  via the remote connector . Moreover, when used in conjunction with the notification service , users will be provided with a comprehensive view of monitoring data from the entire cluster, as described above with respect to ).","The convenience interface  may allow users to remotely access the MBean server  using remote administration tools. Remotely accessing the MBean server  may include remotely accessing and working with the MBeans as registered by the administration service  based on the semantics of the resources  that are instrumented and monitored by the MBeans. Stated differently, the adapter service  provides a high-level view of the MBean server  and all other MBean servers within the cluster (e.g., as represented by the monitor tree ). This higher level view may be represented by a monitor tree, the root of which is an MBean that instruments the cluster. The adapter service  may interpret the monitor tree  and provide interfaces for managing each type of node within the monitor tree . Various different node types may be defined. By way of example, the node types within the monitor tree may include a root node representing the cluster (\u201cTYPE_CLUSTER_MBEAN\u201d), a basic cluster node type representing a node within the cluster (\u201cTYPE_CLUSTER_NODE_MBEAN\u201d), a standard MBean that instruments the kernel of a cluster node (\u201cTYPE_KERNEL_MBEAN\u201d), a standard MBean that instruments a service (\u201cTYPE_SERVICE_MBEAN\u201d), a standard MBean that instruments a library (\u201cTYPE_LIBRARY_MBEAN\u201d), a standard MBean that instruments an interface (\u201cTYPE_INTERFACE_MBEAN\u201d), a standard MBean that instruments a defined group of clusters (\u201cTYPE_GROUP\u201d), and all other MBeans (\u201cTYPE_UNSPECIFIED_MBEAN\u201d). It should be noted, however, that the underlying principles of the invention are not limited to any particular set of MBean types.","The swing-based GUI  employed in one embodiment of the invention may use the convenience interface  and the monitor tree  to represent the management functionality of the monitoring architecture to a network administrator or end user. The console counterpart of the GUI administrator may consist of various shell commands  that may be grouped together in an administration command group.","As mentioned above, monitors may be provided to monitor different aspects of the keystore. In one embodiment, illustrated in , resource Mbeans  are associated with different keys or digital certificates -. The resource Mbeans  may be configured to monitor the status of the digital certificates and ensure that the digital certificates valid and up-to-date. For example, a particular resource Mbean may trigger an alert when the digital certificate with which it is associated reaches a certain age (e.g., when the certificate is within a week of expiring). When the certificate reaches this threshold, the resource MBean may generate a notification to the system administrator that the certificate needs to be replaced. In one embodiment, this is accomplished via the central monitor service  illustrated in  and\/or the notification service  illustrated in .","In addition, runtime Mbeans may be configured to deliver monitoring data related to the keystore using any of the data delivery mechanism described above with respect to -. For example, in an \u201cactive\u201d or \u201cpush\u201d data delivery paradigm the runtime MBean  actively transmits monitoring data related to the keystore certificate with which it is associated. By contrast, in one embodiment, runtime MBeans may also be configured to transmit runtime notifications to their respective monitor Mbean , thereby notifying the monitor MBean that new monitoring data related to the keystore is available. Upon receiving the notification  from the runtime MBean , the monitor bean  may send a request  to the runtime MBean  requesting the new monitoring data. In response, the runtime MBean  transmits the information  including monitoring data regarding the keystore to the monitor MBean . Alternatively, depending on the configuration of the monitor bean , it may choose not to retrieve the information .","Alternatively, in a \u201cpassive\u201d or \u201cpull\u201d paradigm (see ) the resource MBean  transmits information  related to the keystore only in response to a request  from the monitor MBean . As mentioned above, in this embodiment, the monitoring data transmission sequence may be controlled via a timer service  associated with the MBean server . For example, the timing service  may be programmed to trigger the monitor","MBean request  periodically (e.g., every few seconds).","In addition, as described above, in one embodiment, the specific data delivery mechanism employed for each monitor MBean and each piece of keystore data (e.g., key or certificate) is user-configurable (e.g., via the visual administrator  or other graphical management client). Thus, the user may employ an active data delivery mechanism for some types of keystore data and a passive data delivery mechanism for other types of keystore data. For example, keystore data identified as having a relatively higher priority (e.g., such as digital certificates) may be configured with active data delivery mechanisms (such as those illustrated in -), whereas resources which are identified as having a relatively lower priority may be configured with passive mechanisms (such as those illustrated in ). Accordingly, high priority resource updates will be communicated immediately from runtime beans  to monitor beans  (and displayed for the administrator) in response to the resource reaching a predetermined threshold value (e.g., a certificate reaching a specified age). By contrast, relatively low priority resource updates may only be provided by the runtime bean  upon request from the monitor bean .","Embodiments of the invention may include various steps as set forth above. The steps may be embodied in machine-executable instructions which cause a general-purpose or special-purpose processor to perform certain steps. Alternatively, these steps may be performed by specific hardware components that contain hardwired logic for performing the steps, or by any combination of programmed computer components and custom hardware components.","Elements of the present invention may also be provided as a machine-readable medium for storing the machine-executable instructions. The machine-readable medium may include, but is not limited to, flash memory, optical disks, CD-ROMs, DVD ROMs, RAMs, EPROMs, EEPROMs, magnetic or optical cards, or other type of machine-readable media suitable for storing electronic instructions.","Throughout the foregoing description, for the purposes of explanation, numerous specific details were set forth in order to provide a thorough understanding of the invention. It will be apparent, however, to one skilled in the art that the invention may be practiced without some of these specific details. For example, although the embodiments of the invention described above focus on a JMX implementation within a J2EE environment, certain underlying principles of the invention are not limited to any particular specification. For example, the invention may be implemented within the context of other object-oriented and non-object-oriented programming environments, and may also be employed within future releases of the JAVA\u2122 standard, or other standards (e.g., Microsoft's\u00ae .NET standard).","Moreover, while the embodiments described above employ a specific active and\/or passive data delivery mechanism in which runtime MBeans communicate resource data to monitor MBeans, management objects other than JAVA\u2122 MBeans may be employed while complying with the underlying principles of the invention. For example, different types of runtime management objects may be used instead of runtime MBeans and different types of monitor management objects may be used instead of monitor MBeans.","Accordingly, the scope and spirit of the invention should be judged in terms of the claims which follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A better understanding of the present invention can be obtained from the following detailed description in conjunction with the following drawings, in which:",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 10","i":["a","b "]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 11","i":"a "},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 11","i":"b "},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 12","i":["a","c "]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIGS. 13-14"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 17"}]},"DETDESC":[{},{}]}
