---
title: Regulation of resource requests to control rate of resource consumption
abstract: Controlling rate of resource consumptions improves manageability of resources in relation to the entities consuming the resource. A consumer's resource consumption behavior can be controlled with a mechanism that throttles its resource requests to conform to a threshold rate, such as a resource consumption rate. A set of one or more computations tracks a consumption measurement variable over a given time interval, such as number of resource requests for a given resource within the last 5 seconds. When a resource request is received, the set of computations determine whether servicing the resource request would exceed the threshold rate. If the threshold rate would be exceeded, then the computations sleep until servicing the resource request would not exceed the threshold rate.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08046763&OS=08046763&RS=08046763
owner: Oracle America, Inc.
number: 08046763
owner_city: Redwood City
owner_country: US
publication_date: 20040220
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED REALIZATION(S)"],"p":["1. Field of the Invention","The present invention relates to the field of computers. More specifically, the present invention relates to resource management.","2. Description of the Related Art","Traditionally, resource management is handled by operating system environments. Resource management includes management of CPU time, heap memory, and network bandwidth. Since resource management is typically handled by operating system environments, application and generation of resource management policies are limited by operating system environment constraints and complicated by native\/proprietary code or shell scripts necessary to interact with the operating system.","Meeting performance requirements and satisfying various tasks, such as load balancing or preventing denial of service attacks, are difficult if not impossible within the limitations of operating system controlled resource management. Safe languages, such as the Java\u00ae language, provide a vehicle for meeting performance requirements and satisfying various tasks that are difficult or impossible within the traditional operating system environment limitations.","A safe language (e.g., Java\u00ae, Tcl, TeleScript, etc.) allows untrusted program components to be incorporated in a framework where untrusted program components interact safely and efficiently with other program components. A safe language prohibits a program component from circumventing programming abstractions and access restrictions (e.g., illegal type casts, function calls with arguments of inappropriate type or causing stack overflow). An example design aspect for a safe language is removal of pointers. Many access protection problems stem from a program's ability to forge pointers. A program can use pointers and pointer arithmetic to violate access restrictions by accessing objects as something they are not (e.g., a byte array or an object with the same data layout as the actual object but without its access-restrictions). A safe language can provide separate name-spaces to prevent confusion of variables and functions between programs, and ways to insure provision of a service. Generally, safe languages use one or more of three approaches to ensure that a programs' access privileges are constrained: restrict or disallow access to the underlying system; analyze a program to ensure that it conforms to certain stipulated restrictions; or use a computational model that makes certain actions impossible to implement.","Safe languages are increasingly being used as the primary vehicle for organizing computing resources into applications, network services, etc. As part of this evolutionary trend, safe languages are being used to implement complete computing platforms, assuming responsibilities that have historically belonged to the underlying operating system environment.","However, the conventional use of safe languages to implement complete computing platforms falls short to the extent that safe languages do not provide some of the features of operating system environments. This shortfall and the lack of a standard, programmatic way to manage resources outside of the operating system environment has forced developers to take cognizance of the underlying operating system environment, thus leading to a number of awkward, ad-hoc techniques, limiting the expressiveness of safe languages.","Controlling the rate of resource consumption improves manageability of resources in relation to the entities consuming the resource. A consumer's resource consumption behavior can be controlled with a mechanism that throttles its resource requests to conform to a threshold rate, such as a resource consumption rate. Implementing such a mechanism in a resource consume request posting facility separates resource consumption rate control from consumers and the resources. This separation provides efficient fabrication of consume rate controls without becoming mired in the details of the consumers or the resources.","In accordance with embodiments of the invention, a set of one or more computations that manage resource requests, such as a dispenser isolate, resolves conditional statements when a resource request is received from a resource consumer. The set of computations determines if servicing the resource request would exceed a threshold indicated in the conditional statements. The threshold rate can be based on various metrics for measuring a resource consumer's past resource consumption behavior. If servicing or granting the resource request would exceed the threshold rate defined for that resource consumer, then the set of computations delay the resource request at least until servicing or granting of the resource request would not result in exceeding the threshold.","These and other aspects of the described invention will be better described with reference to the Description of the Preferred Embodiment(s) and accompanying Figures.","The use of the same reference symbols in different drawings indicates similar or identical items.","The description that follows includes exemplary systems, methods, techniques, instruction sequences and computer program products that embody techniques of the present invention. However, it is understood that the described invention may be practiced without these specific details. In other instances, well-known protocols, structures and techniques have not been shown in detail in order not to obscure the invention.","Overview","The following description uses several terms to describe the invention. These terms include computation, resource, isolate, and resource management policy. A computation is one or more executing pieces of code that cause one or more tasks to be performed. Computations include entities that occupy an address space in system memory (e.g., processes, threads, applications, etc.). A resource is a measurable entity that one or more computations consume. Availability of a resource impacts performance, such that a shortfall may negatively affect performance and an abundance may improve performance. Conventional examples of resources include heap memory, the number of database connections or server threads in use, and processor time. An isolate is one or more computations that do not share state or objects with other computations (i.e., isolates do not share objects or state with other isolates). Java Specification Request 121 entitled \u201cApplication Isolation API Specification\u201d provides an instance of a guideline for implementation of isolates. The described invention utilizes isolates as a unit of management. A resource management policy defines guidelines for consuming or unconsuming a resource, such as availability of a resource for computations requesting the resource.","Abstraction of resource management from platforms and native code (e.g., operating systems) provides extensibility and flexibility in resource management. Implementing an isolate that monitors and controls provision of a resource separate from definition of the resource, such as an intermediate posting facility for resource requests, abstracts management of the resource from consumption and provision of the resource. An isolate that monitors and controls provision of a resource is referred to herein as a dispenser isolate. A dispenser isolate monitors and controls provision of a resource by acting as a gateway for resource requests and responses.","Although management of a resource is separate from implementation of the managed resource, a dispenser isolate manages the resource based on some representation of the resource. Providing a generic representation of a resource facilitates abstraction of the resource while providing a basis for management of the resource. Common properties across a range of resources including conventional resources and new resources made possible by the described invention have been identified. These common properties or attributes across different resources allow a resource management facility (e.g., the dispenser isolate) to control and monitor resources without being aware of specific aspects of the resource's implementation. Abstracting resources from their implementation allows a dispenser class to be defined that is instantiable for any resource, regardless of specific implementation.","Providing a mechanism for representing association of a resource with a resource management policy, hereinafter referred to as a resource domain, and for binding isolates to resource domains provides efficient policy management and flexible application of resource management policies to isolates that consume resources. A single resource management policy independent of the particular resource implementation can be generated and associated with different resources. In addition, application of resource management policies to resource consuming isolates is not hindered by relationships between the resource consuming isolates, thus enhancing resource management in areas such as collaborative applications.","Furthermore, the separation of resource management and resource implementation illuminates novel techniques for controlling resource consumption. For example, a dispenser isolate can be used to control an isolate's rate of resource consumption by regulating or throttling resource requests.","Each of the described techniques and\/or concepts is described in more detail below. The described subject matter can be implemented in a range of combinations including separately implementing each of them to implementing a resource management interface that includes all of the techniques and\/or concepts described herein. The described invention also may be combined with other techniques or concepts not described herein.","Resource Management Interface",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 1","FIG. 1"],"b":["101","107","111","115","117","119","127","131","101","103","105"]},"The consumer isolate  generates a resource request, which corresponds to the resource implementation A, and sends the resource request to the dispenser isolate  at a time . The dispenser isolate  processes the resource request and invokes the policy imposing isolate  at a time . The policy imposing isolate  imposes resource management policies , , and . The policy  corresponds to the resource of the resource implementation A. At a time , the policy imposing isolate  makes a decision about the resource request based on the policy . At a time , the policy imposing isolate provides its policy decision to the dispenser isolate . In this scenario, multiple policies are applied for the resource of resource implementation A, so the dispenser isolate  invokes the policy imposing isolate  again at a time . Although the policy imposing isolate  is invoked for a second policy decision, different policy imposing isolates can be involved in various realizations of the invention. For example, a different policy imposing isolate may apply the policy . The policy imposing isolate  makes a decision based on the policy  at a time and provides the decision to the dispenser isolate  at a time . Although the separate policies are applied sequentially in , various realizations of the invention invoke policy imposing isolates differently (e.g., in parallel, in batches, etc.). In addition, the policies  and  may be combined into a single policy. At a time , the dispenser isolate  merges the decisions provided by the policy imposing isolate . Although  depicts the dispenser isolate  merging policy decisions from a single policy imposing isolate, the described invention is not limited to merging decisions from a single policy imposing isolate. Realizations of the invention merge policy decisions from different policy imposing isolates.","After receiving and merging the policy decisions, the dispenser isolate  invokes a policy imposing isolate  at a time . In , the invocation of the policy imposing isolate  is paired with one or more of the invocations of the policy imposing isolate . Various realizations of the invention implement association of pre-decision invocation and post-decision invocations differently (e.g., zero or more pre-decision invocations associated with zero or more post-decision invocations). At a time , the dispenser isolate  responds to the consumer isolate  indicating the merged policy decision. The decision may be a full grant of the requested resource amount, a partial grant of the requested resource amount, or a deny of the request. At a time , the policy imposing isolate  makes a policy decision with a policy . In , the policy imposing isolate  sends a notification to a third party isolate at a time . The policy  may be any of a variety of policies defined by a user or generated by one or more computations that causes one or more operations to be performed based at least in part on the notification from the dispenser (e.g., the policy imposing isolate  may modify its behavior according to the notification, modify another isolate's behavior, etc.). As previously stated, the timing illustrated in  is meant to aid in understanding the described invention and not meant to be limiting upon the invention. The response at time , the invocation at time , the decision at time , and the notification at time can occur in a myriad of different timings. In addition, the letters a-d are used to indicate the relationship of actions with isolates and not meant to indicate sequential time relationships.","Isolates","Modularization of resource consuming computations into isolates allows for unambiguous resource usage accounting and clean reclamation upon computation termination.  depict various examples of isolates according to some realizations of the invention.  depicts isolates comprising computations according to some realizations of the invention. An operating environment  (e.g., an operating system, virtual machine, etc.) includes isolates , , and . The isolate  includes computations  and . The isolate  includes a computation . The isolate  includes computations A-M. The isolates in  illustrate the possible various number of computations comprising an isolate.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 2B","FIG. 2B"],"b":["220","225","235","225","221","223","235","227","227"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 2C","b":["240","242","246","242","241","243","245","246","247","249","247","248","250","248"]},"The isolates depicted in  can assume any combination of the roles of a consumer isolate, a policy imposing isolate, and a dispenser isolate. In addition, an isolate can manage other isolates. For example, the isolate  may consume a resource, manage isolates  and , and impose policies on the isolates  and  that it manages. In another example, the isolates  and  consume a resource and the isolate  imposes that resource's management policy on the isolate  as well as on itself. The mechanism that allows for unrelated isolates to impose policies arbitrarily, referred to herein as a resource domain, will be described later.","Resource Management Policies","In addition to imposing resource management policies, isolates generate resource management policies. Resource management policies are configured directly by a user, loaded from a boot file, loaded from over a network, dynamically derived from another policy, etc. Various examples of types of resource management policies include usage limits, notifications, and reservations. A resource management usage limit policy defines when a computation may gain access to, or consume, one or more units of a given resource. Such a policy defines when a resource request is wholly granted, partially granted, or denied, or influences the decision to grant a particular request to consume a resource. Usage limit policies can range from simple to relatively complex. For example, a usage limit policy may be reactive (i.e., define provision of a decision based simply on being invoked). Another usage limit policy may define various calculations to be performed as a basis for a decision, define a threshold for comparison of proposed resource usage, or define various determinations with respect to another resource as a basis for providing a decision for the corresponding resource, etc. Resource management reservation policies specify reservations (guaranteed resource availability). Reservations are established and utilized in determining grant of a resource consume request.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 3","b":["301","303","306","302"]},"At block , the reservation is decreased accordingly.","At block , it is determined if the reservation request is within system wide availability of the resource. For example, the managing isolate would determine if other reservations will allow the requested reservation, if current usage allows the requested reservation, etc. If the reservation is not within system availability of the resource, then control flows to block . If the reservation is within system-wide availability of the resource, then control flows to block .","At block , the reservation request is denied.","At block , reservation of the resource is indicated. For example, an indication that 50 megabytes of system memory has been reserved is indicated. At block , grant of the reservation is communicated. For example, the managing isolate sends a message to the requesting isolate, either directly or indirectly, acknowledging establishment of the requested reservation.","As previously stated, policies include resource management notification type policies. Resource management notification policies notify interested isolates of an occurrence of a specific event, as with the depicted policy  of . An interested isolate's behavior is modified in accordance with the notification. These various policies allow for an expressive set of resource management policies to be coded.","Returning to , the consumer isolate  requests a resource that corresponds to the resource implementation A. The consumer isolate  communicates a resource request at a time to the dispenser isolate , which manages the corresponding resource. The isolate  includes resource implementations for different resources, A and A, and communicates with distinct dispensers, which handle requests for distinct resources. The dispenser isolate  handles requests for the resource that corresponds to the resource implementation A and the dispenser isolate A handles requests for the resource that corresponds to the resource implementation A. The dispenser isolate  invokes the policy imposing isolate  at a time . The policy imposing isolate  makes a decision about the resource request based on a policy  at a time and provides the decision to the dispenser isolate  at a time . The dispenser isolate  does not have additional policy decisions to merge and does not have another policy imposing isolate to invoke after the policy decision has been made, so the dispenser isolate  provides a response to the consumer isolate  at a time ","The consumer isolate  also requests the resource managed by the dispenser isolate . The requested resource is reflected in the consumer isolate  as a resource implementation B. The consumer isolate  causes a resource request to be generated and communicated by the consumer isolate  at a time to the dispenser isolate . At a time , the dispenser isolate  invokes the policy imposing isolate . The policy imposing isolate  makes a policy decision with the policy  at a time and passes the decision back to the dispenser isolate  at a time . At a time , the dispenser isolate  provides a response in accordance with the policy decision to the consumer isolate . The actions for the consumer isolate  to request the resource implemented in resource implementation B are similar to the already described request and response actions. The consumer isolate  requests the resource managed by the dispenser isolate . The resource implementation B causes a resource request to be generated at a time , which is sent from the consumer isolate  to the dispenser isolate . At a time , the dispenser isolate  invokes the policy imposing isolate . The policy imposing isolate  makes a policy decision with the policy  at a time and passes the decision back to the dispenser isolate  at a time . At time a , the dispenser isolate  provides a response in accordance with the policy decision to the consumer isolate .","Dispenser","If management of the resources requested by consumer isolates  and  is not separated from implementations of those resources, then specific pieces of code would be developed for each resource. A dispenser allows the same code to be utilized for handling resource requests for different resources and for different consumer isolates. As illustrated in , monitoring and controlling resource consumption can be centralized with separation of resource management and resource implementation using a dispenser mechanism.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 4","FIG. 1","FIG. 4"],"b":["401","411","412","401","401","403","403"]},"A dispenser isolate evaluates resource requests against a corresponding policy (e.g., a policy associated with the resource requestor, a policy associated with the dispenser isolate, a policy associated with the requested resource, a policy associated with a separate entity representing association between a resource and policies, etc.) Various realizations of the invention evaluate a resource request differently (e.g, directly against the corresponding policy, indirectly against one or more corresponding policies, against gate functions, etc.). For example, one or more policy decision actions may be executed upon receiving a resource request without resolving any triggers or gate functions; one or more triggers may be resolved before zero or more policy decision actions may be executed, etc.","Triggers function as gates in determining whether an associated policy decision action should be executed (e.g., whether a policy imposing isolate should be invoked). Triggers are executed by a dispenser and in an example implementation are serializable so they can be transported between isolates. The following is an illustration, in the form of Java\u00ae interface, of methods defined for a trigger:","public interface Trigger extends java.io.Serializable {","public boolean shouldFire(long current);","public boolean shouldFire(long current, long proposed);","}","As previously discussed, policy decision actions may be pre-decision (e.g., invocation of an isolate that imposes a usage limit policy) or post-decision (e.g., invocation of an isolate that imposes a notification policy). A dispenser utilizing the above exemplary definition of a trigger executes the shouldFire (long current) method from the trigger of a newly installed policy decision action to allow that action a chance to react to the resource's utilization state at the time of installation (perhaps by establishing a baseline that records current use. In addition, the dispenser, upon receiving a request to consume its resource, executes the shouldFire (long current, long proposed) method for each policy decision action to determine whether that action should be executed.","Triggers can be utilized to avoid unnecessary round trip inter-isolate communications by filtering out actions that do not need to be executed upon a given consume\/unconsume resource request action. For example, assume the policy that corresponds to the trigger A rejects requests to consume more than 64 total megabytes of memory. If a consume request is for 5 megabytes of memory when current usage is at 50 megabytes of memory, then the trigger will not execute the corresponding policy decision action, which invokes a policy imposing isolate that would grant the consume request. Instead, the trigger grants the request. Hence, an unnecessary inter-isolate communication is avoided.","In , the dispenser isolate  evaluates the triggers A and B. If the trigger A resolves to true, then a pre-decision policy action that invokes a policy imposing isolate  is executed. If the trigger B resolves to true, then a post-policy decision action that invokes a policy imposing isolate  is executed. If either trigger resolves to false, then their corresponding actions are not executed. This does not suggest that if no triggers resolve to true then a resource request is implicitly denied (e.g., the resource request is further processed, the resource request is implicitly granted, etc.). Although  depicts two separate policy imposing isolates corresponding to two separate policy decision actions, the same policy imposing isolate may be invoked by both pre- and post-decision policy actions.","In , the trigger A corresponds to a pre-decision action that invokes the policy imposing isolate , which imposes the usage limit policy . The trigger B corresponds to a post-decision action that invokes the policy imposing isolate , which imposes the notification policy . The triggers A and B correspond to only one policy decision action for purposes of providing an illustrative example. In accordance with some previously described realizations of the invention, the trigger A may correspond to pre- and post-decision actions of a varying number. For example, the trigger A may cause the dispenser to invoke both pre- and post-decision policy actions associated with the policy-imposing isolate . If the policy imposing isolate  is invoked, then the policy imposing isolate  returns a policy decision to the dispenser isolate . If the post-decision policy action is executed, then the dispenser isolate  communicates to the policy imposing isolate  information related to the policy decision provided by the policy imposing isolate  (e.g., the decision corresponding to the pre-decision policy action, a sum decision that takes the decision from the isolate  into account, additional criteria, such as common resource attribute values, which will be described later, etc.). The policy imposing isolate  evaluates the notification policy  with regard to the communicated information and acts accordingly (e.g., modifying its own behavior, communicating with another isolate regarding the resource, modifying another isolate's behavior, etc.).","Various realizations of the invention implement a dispenser isolate, triggers, and policy decision actions differently. For instance, a dispenser isolate may resolve all triggers that correspond to a resource request before executing policy decision actions that correspond to triggers that resolve to true, execute a policy decision action after each trigger is resolved, etc. Triggers may be resolved asynchronously or synchronously. Policy decision actions without corresponding triggers may be executed before triggers are resolved, while triggers are being resolved, or after triggers are resolved. In addition, policy decision actions and triggers may have a dynamic relationship with a resource request or static relationship (i.e., the same set of triggers and policy decision actions may be executed each time a given consume isolate requests a particular resource or the set of policy decision actions may be different over time because policy imposing isolates add, remove, and\/or modify triggers and\/or policy decision actions).",{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIGS. 5A-5B","FIG. 5A"],"b":["501","503","504","517","505","505","507","511","517"]},"At block , the one or more policy decision actions are executed. At block , the dispenser waits for policy decisions from the invoked policy imposing isolates. At block , the decisions are merged. At block , the requested amount is adjusted in accordance with the merged decision. Various realizations of the invention implement merging differently. A merging mechanism may select the lowest granted amount, the highest granted amount, the mean granted amount, etc. A merging mechanism may be dynamic, or adjustable. From block  control flows to block .",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 5B","FIG. 5A"],"b":["517","519","521"]},"At block , a response in accordance with the adjusted requested amount is provided to the requesting consumer isolate.","At block , it is determined if the adjusted requested amount exceeds the reservation. If the adjusted requested amount exceeds the reservation, then control flows to block . If the adjusted requested amount does not exceed the reservation, then control flows to block .","At block , it is determined if the adjusted requested amount violates other reservations. If the adjusted requested amount violates other reservations, then control flows to block . If the adjusted requested amount does not violate other reservations, then control flows to block .","At block , a response that indicates denial of the resource request is provided to the requesting consumer isolate. Denial of the resource request may be explicit (e.g., a deny response), or implicit (e.g., a response that indicates zero granted amount, a response that indicates the currently used amount of the resource, which indicates that no more is granted, etc.).","Providing a single class definition of an entity to manage availability of resources increases developer efficiency and reduces the size and complexity of code. The following is an example class definition of a dispenser:","public abstract class Dispenser {",{"@attributes":{"id":"p-0070","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["public static Dispenser newInstance(String name,String[ ] args);","public static void registerDispenser(Dispenser dispenser);","public static void unregisterDispenser(Dispenser dispenser);","protected boolean is Global( );","protected final void setTotalQuantity(long totalQuantity);","protected ResourceAttributes getResourceAttributes( );\n\n}\n"]}}}},"A dispenser is created by invoking newInstance( ). This method takes the name of a Dispenser subclass as an argument, along with other arguments that define a particular instance of a dispenser. Once the dispenser is created, it can be registered\u2014from that moment until de-registration, the dispenser is active. An active dispenser instance can begin to manage its resource. Once the instance of the dispenser is unregistered, it becomes inactive and cannot manage its resource unless registered again. After the instance of the dispenser becomes inactive, the dispenser can be destroyed.","The exemplary class definition above also provides for instantiating two kinds of dispensers: 1) a global dispenser and 2) a local dispenser. A global dispenser is shared by all isolates making use of the resource it manages. There is one global dispenser per resource per system (e.g., single computer system, a distributed system, etc.). However, there can be multiple instances of local dispensers in the system, but not more than one for the same resource in an isolate. Global dispensers model resources with a single source of \u201cproduction.\u201d Some examples are heap memory in a single-heap system and the number of open sockets. Local dispensers model resources with multiple independent sources of production.","An example of multiple independent sources of production is execution of several web servers in a single virtual machine where each instance of the web server and each servlet is a separate isolate. Each server may independently control the maximum number of concurrent requests each of its servlets can execute. A dispenser can be instantiated locally for each server instance, because the servers need not coordinate with each other.","The example dispenser class also provides for associating the instantiated dispenser with the resource to be managed. The routine setTotalQuantity( ) sets a total quantity of a resource, if applicable, to be managed by the instantiated dispenser. The routine getResourceAttributes( ) attains attributes of a dispenser's resource to manage the resource. The attributes attained for the dispenser instance are common attributes across a broad range of resources. A dispenser instance manages a resource based on these common attributes. With these common attributes, a dispenser can be defined regardless of the resource.","Characterization of Resources Based on Common Attributes","The dispenser manages resource requests separately from the resource definitions, but the dispenser monitors and controls the resource requests based on more than the name of the resource. Various attributes have been identified that are common across conventional resources and that can be utilized to treat objects or entities, both logical (e.g., sockets, ports, servlets, etc.) and physical (e.g., CPU time, memory, etc.), as new resources in a uniform manner. Characterizing resources with a set of common attributes allows separation of resource management from resource definition and eases defining new resources. The single dispenser class handles resource requests based at least on the following attributes: disposable, revocable, bounded, and reservable. These four common attributes, and possibly more, determine the semantics of handling resource requests.","A resource is disposable if it is possible to identify a span of program execution over which a given resource instance is considered to be consumed. Outside of this span, the resource instance is available for (re)use. As a consequence, usage is not necessarily monotonic. A page of memory is a disposable resource; CPU time is not. An example of the usefulness of this attribute is in allowing unconsuming (i.e., returning to the pool of resources) of disposable resources only. The same operation for a non-disposable resource is erroneous.","A resource is revocable if units of the resource previously granted to the resource consumer can be withdrawn without affecting the consumer's behavior, except possibly for its rate of progress. An example is physical memory: the operating system can alter the size of the page frame pool it dedicates to a process's address space without the process noticing.","A resource is bounded if there is a fixed limit on the amount available. For example, in the absence of a constraint, such as a policy that constrains availability of a resource to a requestor when imposed, (perhaps issued by the underlying host platform), \u201cabsolute CPU time\u201d is an unbounded resource.","After a successful reservation request of a reservable resource, it is guaranteed that the system is able to supply the reserved units of resource. This does not imply that a client may consume the resource, as that is also dependent on the resource usage limit policy. The definition is phrased in terms of resulting usage, rather than in terms of number of units requested. This distinction is emphasized, since the sum of requested units might overstate actual usage.","With the identified common attributes, dispensers can be instantiated from a single class definition to handle resource requests for a variety of resources (e.g., CPU time, memory, sockets, network bandwidth, interconnect bandwidth, etc.). Characterizations of resources with common attributes allows flexible management of an array of resources, both conventional and unconventional.","In addition to the described common resource attributes, the following additional attributes provide for precise accounting: granularity and measurement delay. The granularity of a resource is the indivisible amount of the resource in a given implementation. For instance, a heap might be managed as a set of pages; in this case, although the resource's unit is bytes or kilobytes, the deliverable granularity is the underlying system's page size, e.g., four kilobytes. Various realizations of the invention automatically round specified resource quantities to conform to granularity of the resource or round results of policy decisions to conform to granularity of the particular resource.","The measurement delay is the maximum amount of time that can pass between resource consumption and updating the usage information. For example, controlling the number of open file descriptors can be done accurately at any time (measurement delay is zero), whereas controlling CPU time usage via sampling once a second has a measurement delay of one second. An implication of measurement delay is the possibility of uncontrolled consumption during the delay interval. To reduce the possibility of uncontrolled consumption during a delay interval, the measurement delay can be made as small as desired.","Another common attribute that can be used to characterize resources is explicit. A resource is explicit if it is possible to identify a proper subset of the resource consumer's bytecodes such that a bytecode in the subset corresponds to a point at which the resource is consumed. A file descriptor is an example of an explicit resource; CPU time is not explicit. This property supports determination of whether and where in the program error handling related to resource shortage should be placed.","The following is an example of a resource attributes class definition:","public abstract class ResourceAttributes {","public abstract long getGranularity( );","public abstract long getMeasurementDelayMillis( );","public final String getName( )\n\n","public abstract Unit getUnit( );","public abstract boolean is Disposable( );","public abstract boolean is Reservable( );","public abstract boolean is Revokable( );","public abstract boolean is Unbounded( );","public static ResourceAttributes getInstance(String name);","public static ResourceAttributes[ ] getRegistered( );","}","Quantities of resources are expressible as long integers for usage, reservations, etc., in accordance with the exemplary dispenser class definition from above. An integer comparison is employed to tell whether two values are the same or one of them is greater than the other. The getUnit( ) method of ResourceAttributes returns a description of the unit, which may be expressed in several different systems (e.g., metric, US, etc.) and which can contain standard scaling prefixes (e.g., milli, kilo, etc.).","Resource Domains","With the dispenser class and the common resource attributes, resource management policies can be written abstractly for resources exhibiting common behavior as indicated by the common attributes, without regard for specific implementation of the resources. Resource domains extend policy utility from a different angle. Resource domains encapsulate a policy for a resource and allow for application of resource management policies to various unrelated computations. The resource domain provides a mechanism for associating a resource, a policy, and isolates that consume the resource. The representation of a resource and a particular policy for that resource allows for expression of numerous resource management scenarios and flexible application of resource management policies across isolates.",{"@attributes":{"id":"p-0097","num":"0102"},"figref":"FIG. 6","b":["601","603","605","607","609","613","613"]},"A consumer isolate  is bound to the resource domain . A consumer isolate  is also bound to the resource domain . Even though the consumer isolates  and  are otherwise unrelated, both are bound to the same resource domain. Both of the consumer isolates  and  will be subject to the policies  and . Without resource domains, a single policy was applicable only to related processes and not applicable to unrelated processes. With resource domains, arbitrary application of policies to isolates allows for flexibility in resource management scenarios. For example, resources for a collaborative application can be managed with a set of policies applied to various isolates that cooperate on the collaborative application regardless of relationship. Hence, a set of policies for the collaborative application can be applied to unrelated computations without replicating the policy for each computation and without making such multiple policies coordinate their own operation.","In , the consumer isolate  is also bound to the resource domain . A consumer isolate  is bound to the resource domain  and the resource domain . The resource domain  includes a resource management policy  for resource A that is distinct from the policy for resource A defined by resource domain . From , it can be seen that resource domains enhance the expressiveness of policies. A policy can be written and applied to different resources with resource domains. For example, the policy  may be the same as the policy , or a combination of the policies  and , but applied to different resources via resource domains. The ability to utilize non-resource specific policies and apply them to different resources reduces the occurrence of redundant policies and allows users to more efficiently develop policies. In addition, relationships can be constructed between various client isolates and policies and modified over time using resource domains.",{"@attributes":{"id":"p-0100","num":"0105"},"figref":"FIG. 7","b":["715","709","1","715","2","707","707"]},"At a time , a consumer isolate  retrieves resource domain information from the resource domain registry . At a time , a consumer isolate  retrieves resource domain information from the resource domain registry . Assuming both of the consumer isolates  and  are bound to the same resource domain, the resource domain registry provides the same resource domain indication to the consumer isolates  and . For example, the consumer isolates  and  communicate their isolate identifier to the resource domain registry . An isolate that manages the resource domain registry  looks up the consumer isolate identifiers (e.g., a structure of resource domain references may be keyed or indexed by bound consumer isolate identifiers, a hash of bound consumer isolate identifiers, etc.). The consumer isolates  and  utilize the resource domain indications to access an appropriate one of the resource domain structures A-F. In , a resource domain structure indicates a resource domain identifier, a resource (e.g., a resource name and\/or resource attributes, one or more policy actions and triggers, reservations, and consumer isolates bound to the resource domain). The described resource domain structure and resource domain registry are exemplary and not meant to be limiting upon the invention. Various realizations of the invention implement a mechanism for relaying resource domain information to consumer isolates differently (e.g., a single access without indirection for looking up resource domain information, multiple levels of indirection, etc.) and\/or encode resource domain information differently (e.g., with any of a variety of data structures, hardware, and organization of the resource domain information, which may include more or less than illustrated in ). At a time , the consumer isolate  retrieves resource domain information from the appropriate one of the resource domain structures A-F.","At a time the consumer isolate  invokes a policy imposing isolate  according to the retrieved resource domain information. The consumer isolate  also invokes, at a time , the policy imposing isolate  according to the retrieved resource domain information. The policy imposing isolate  provides policy decisions to both consumer isolates  and . The policy imposing isolate  provides policy decisions to the consumer isolates  and  at times and , respectively.","The following provides an example class definition for a resource domain:","public final class ResourceDomain {","public static ResourceDomain[ ] currentDomains( );","public static ResourceDomain currentDomain(String name);","public static ResourceDomain newDomain(String name);","public ResourceAttributes getResourceAttributes( );","public void bind(Isolate isolate);","public void unbind(Isolate isolate);","public Isolate[ ] getIsolates( );","public long consume(long quantity);","public long consumeAllOrNothing(long quantity);","public long unconsume(long quantity);","public void setConsumeAction(ConsumeAction action);","public void removeConsumeAction(ConsumeAction action);","public Reservation getReservation( );","public void setReservation(Reservation reservation);","public long getUsage( );","public void terminate( );","public boolean is Terminated( );","}","The static routines of the exemplary resource domain class return the set of resource domains to which the current isolate is bound, return a specific current resource domain given the resource name (throwing an exception if the resource is registered but not bound in the current isolate), and create a new resource domain. The attributes for the resource for which a resource domain is created are obtained via getResourceAttributes( ). This example shows how an isolate can discover all the resource domains it is bound to:","ResourceDomain[ ] rds=ResourceDomain.currentDomains( );","for (int i=0; i<rds.length; i++) {","String name=rds[i].getResourceAttributes( ).getName( );","System.out.println(\u201cI am bound to\u201d+ name);","}","The bind( ) method binds an isolate to a resource domain. This method fails if the isolate is already bound to a domain for the same resource. The unbind( ) routine succeeds when the isolate has been terminated, when its consumption of the resource is zero or when the resource is non-disposable. An array of isolates bound to a given domain can be obtained via get Isolates( ). This is useful, for example, in determining whether an isolate is the only one bound to the domain and, consequently, the only one subject to the given resource management policy. Any isolate bound to a resource domain can request to consume units of the resource as well as unconsume units previously obtained, provided that the resource is disposable. These operations typically are invoked by core or middleware code implementing the resource. For example, client applications opening and closing sockets remain unchanged, but some of the socket operations may invoke consume( ) and unconsume( ) on the client's resource domain.","The consume( ) method can return less of a resource quantity than requested. Such partial grants of requests may be acceptable for certain resources. If an entire requested quantity is necessary for a given operation to succeed, resource implementations should use consumeAllOrNothing( ) (e.g., an attempt to allocate a 1 MB array should fail if only 512 KB of heap memory can be allocated). Invoking this routine does not guarantee the success of the request, but does prevent futile partial request satisfaction. Resource management policies are dynamically set by setting and removing consume actions and reservations on resource domains. Setting the reserved value to 0 removes a reservation.","Computations can learn about the quantities reserved. The getUsage( ) routine returns the number of resource units consumed by the resource domain. In realizations of the invention, all usage and reservation statements are with respect to resource domains, and no provisions are made for distinguishing consumption and reservations within isolates bound to the same resource domain. How much a given isolate consumes a given resource is not known unless it is the only isolate bound to its resource domain. Various realizations of the invention account resource usage based on individual requestors and\/or provide mechanisms for distinguishing between reservations and consumption of resources for current usage.","Defining and generating a single set of one or more policies and applying the set of policies without replication to a group of unrelated computations provides efficient policy management and flexible application of resource management policies to consumer isolates. Resource domains reduce the burden on developers by providing an alternative to computation specific resource policies and reduce the burden of resource policy management on users.","Utilizing Resource Domains with Dispensers","A resource management interface that implements both a dispenser and a resource domain provides a powerful mechanism for managing resources and policies.",{"@attributes":{"id":"p-0129","num":"0134"},"figref":"FIG. 8","b":["801","803","805","807","811"]},"At block , the resource domain is associated with the local dispenser.","At block , it is determined if there is a parent isolate. If there is a parent isolate for the current isolate, then control flows to block . If there is not a parent isolate, then control flows to block . At block , an association with the global dispenser is retained.","At block , the current isolate is set to the parent isolate. Control flows from  to . After association of a resource domain with a dispenser, client isolates (i.e., consumer isolates) can be bound and unbound by isolates through the dispenser.",{"@attributes":{"id":"p-0133","num":"0138"},"figref":["FIGS. 9A-9B","FIG. 9A"],"b":["901","903","907","908","910","909"]},"At block , the available amount of the resource is indicated. An unconsume request will probably not be submitted for an unbounded resource. In realizations of the invention, the dispenser isolate verifies the legitimacy of an unconsumed resource request with the resource's disposable attribute. If the resource is disposable, then the unconsume resource request is legitimate. Otherwise, the unconsumed resource request is not legitimate, and an error indication is provided.","At block , triggers and policy decision actions for the indicated resource domain are retrieved (it may be that one or more policy imposing isolates have not installed triggers or actions with the resource domain). At block , the retrieved triggers are evaluated and a set of pre-decision policy actions to execute are determined. The set of pre-decision policy actions to execute includes those associated with triggers that resolved to true. At block , it is determined if there are any pre-decision policy actions to execute. If there are pre-decision policy actions to execute, then control flows to block . If there are no pre-decision policy actions to execute, then control flows to block .","At block , the appropriate pre-decision policy actions are executed. From block , control flows to block .",{"@attributes":{"id":"p-0137","num":"0142"},"figref":["FIG. 9B","FIG. 9A"],"b":["921","923","925","925","927","929","937"]},"At block , it is determined if the merged decision to be communicated (or policy decision without merging to be communicated) is valid against a reservation (e.g., does it exceed a corresponding reservation, violate another reservation, etc.). If the decision to be communicated is valid against the reservation, then control flows to block . If the decision to be communicated is not valid against the reservation, then control flows to block .","At block , it is indicated that a response should not grant any additional resources to the requestor. As previously stated, a request may be denied in accordance with different techniques (e.g., an explicit deny response indicating a negative value or flag, an implicit deny indicating a granted amount equal to current usage, an explicit deny indicating a granted amount of zero, etc.). A post-decision policy action may be executed that notifies interested isolates that the request has been denied.","At block , those post-decision policy actions whose triggers resolved to true are executed. At block , a response is provided in accordance with the merged policy decision. At block , availability of the resource is updated accordingly.",{"@attributes":{"id":"p-0141","num":"0146"},"figref":"FIG. 10A","b":["1007","1","1001","1007","1001","2","1001","1005","3","1005","1006","1001","4","1005","5","1005","1021","1021","6","1021","1005","1005","7"],"i":["a","a","a","a","a","a","a. "]},"Although not illustrated in , post-decision actions may be executed between times and . For example, the set of actions determined at times and may include post-decision actions. After the policy decision is provided at time , a post-decision actions may be executed that causes the policy imposing isolate  or another policy imposing isolate (in addition or instead of the policy imposing isolate ) to modify its own behavior, another isolate's behavior, etc.","Likewise, a consumer isolate  determines its current resource domain from the resource domain registry  at a time . In various realizations of the invention, a consumer determines its corresponding resource domain a first time and maintains an indication of its resource domain as long as the consumer isolate persists if the binding between the consumer isolate and its resource domain is static. At a time , the consumer isolate  communicates a request that indicates the determined resource domain to the dispenser isolate . At a time the dispenser isolate  determines a set of actions and triggers from a resource domain  as indicated by the consumer isolate . At a time , the dispenser isolate  determines the set of actions and triggers. If the consumer isolate  was bound to the same resource domain as the consumer isolate , then the dispenser isolate would evaluate the same set of triggers. In some realizations of the invention a set of triggers and actions are static in the dispenser across different consumer isolates bound to the same resource domain. If the set of triggers and actions are static, then the dispenser  maintains the set of triggers and policy actions with an indication of the corresponding resource domain. The information indicated by the resource domains  and  may be the same as the resource domain information indicated by the resource domain structures illustrated in , possibly including less information or more information, such as current usage.","At a time , the dispenser isolate  invokes a policy imposing isolate (i.e., executes actions of triggers that resolve to true), which happens to be the consumer isolate  in this example. The consumer isolate  provides a policy decision to the dispenser  at a time . At a time , the dispenser isolate  provides a response to the consumer isolate . As discussed above, post-decision policy actions may be executed between times and ",{"@attributes":{"id":"p-0145","num":"0150"},"figref":["FIG. 10B","FIG. 10B"],"b":["1021","1","2","1005","1006","2","1005","1006","1007","1006","2","2","2","2","2","2","3","1021","4","1021","1005","1005","1021","1006","5","1021","1006","6","1021","1006","1005","1007","7","1005"],"i":["a","b","a ","b ","a ","b","b ","a"]},"An exemplary resource management interface as described in  utilizing the exemplary class definitions described above may also include the following routines in the resource domain class definition:","public long getTotalUsage( );","public long getTotalQuantity( );","public long getTotalReservedQuantity( );","These routines are provided to obtain information related to all resource domains associated with the same dispenser: getTotalUsage( ) returns the total amount of consumption, getTotalQuantity( ) returns the total amount of the resource in care of the dispenser, and getTotalReservedQuantity( ) returns the sum of all reservations on the resource domains associated with the dispenser. These routines are particularly useful in determining how large new reservations can be.","A resource management application programming interface that provides for a dispenser and\/or a resource domain is applicable to a variety of resource management scenarios and allows for expression of numerous resource management policies. Such a resource management API hides from computations whether a resource is managed by an underlying operating system, a virtual machine, a core library, trusted middleware code, etc. Although implementation based on such a resource management API may take advantage of specialized hardware support of a particular platform, the implementation will not depend on such support.","The following is example code implemented with the exemplary class definitions provided above. The following code example refers to policy decision actions as \u201ccallbacks.\u201d Accordingly, pre-decision policy actions are referred to a pre-consume callbacks and post-decision policy actions are referred to as post-consume callbacks.",{"@attributes":{"id":"p-0150","num":"0155"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public static void main(String[ ] args) { \/\/ class Manager"]},{"entry":[{},"\u2003String R = args[0]; \/\/ get name of resource to manage"]},{"entry":[{},"\u2003ResourceDomain rd0 = ResourceDomain.currentDomain(R);"]},{"entry":[{},"\u2003ResourceDomain rd1 = ResourceDomain.newDomain(R);"]},{"entry":[{},"\u2003long reservation = rd0.getReservation( ).getValue( );"]},{"entry":[{},"\u2003rd0.setReservation(new Reservation(reservation \u2212 100));"]},{"entry":[{},"\u2003rd1.setReservation(new Reservation(100));"]},{"entry":[{},"\u2003ConsumeCallback.Pre preCallback = new ConsumeCallback.Pre( )"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003public long preConsume(ResourceDomain rd,long current,"]},{"entry":[{},"\u2003\u2003long proposed) {"]},{"entry":[{},"\u2003\u2003\u2003String name = rd.getResourceAttributes( ).getName( );"]},{"entry":[{},"\u2003\u2003\u2003log(\u201cReject \u201d + (proposed \u2212 current) + \u201c of \u201d + name);"]},{"entry":[{},"\u2003\u2003\u2003return current; \/\/ veto the request"]},{"entry":[{},"\u2003}};"]},{"entry":[{},"\u2003Trigger trigger = Triggers.newAbsoluteUp(100);"]},{"entry":[{},"\u2003ConsumeAction action ="]},{"entry":[{},"\u2003\u2003new ConsumeAction(false, true, preCallback, trigger);"]},{"entry":[{},"\u2003rd1.setConsumeAction(action);"]},{"entry":[{},"\u2003Isolate iA = new Isolate(\u201cTrusted\u201d, new String[0]);"]},{"entry":[{},"\u2003rd0.bind(iA);"]},{"entry":[{},"\u2003Isolate iB = new Isolate(\u201cApp\u201d, new String[0]);"]},{"entry":[{},"\u2003rd1.bind(iB);"]},{"entry":[{},"\u2003iA.start(new Link[0]);"]},{"entry":[{},"\u2003iB.start(new Link[0]);"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Manager is the initial isolate, which is assumed to be bound to a domain for a resource denoted by a string variable R. R can be any resource for this particular example of the resource management interface\u2014the code to manage it is the same. The example code illustrates that policies can be expressed abstractly and parameterized by resource names.","The manager obtains a handle rd to its domain and creates another domain rd for the same resource. Then it sets a reservation for 100 units of R on the new resource domain after lowering its own reservation by the same amount and sets a consume action. The action consists of a non-persistent (removed after the first execution; the false argument), synchronous (blocking the consume request; the true argument) pre-event (also referred to as a pre-callback) (\u201cpre\u201d indicates that it is invoked before requests to consume resources are granted) and a trigger, which determines under what circumstances the callback should be executed. A trigger is predefined that causes the action's callback to be executed when usage increases to or beyond the specified threshold value. The callback, an example of which will be provided later, itself has three arguments: the resource domain against which the requested usage will be charged if granted (it is the same domain on which the consume action has been set), the current usage, and the proposed usage.","Returning the current usage value indicates that the request for an additional quantity (proposed minus current) is refused. This consume action constitutes a constraint that prevents isolates bound to rd from using more than 100 units of R. After completing this setup, the manager creates a new isolate iA, which will execute the Trusted main class and binds it to rd\u2014from now on the manager and iA will share rd. This means that any usage of R by the manager or by Trusted is accounted against rd, and the two isolates share the same resource management policy (reservations, consume actions, etc.) Finally, a new isolate iB executing main class App is created and bound to rd; iB is thus subject to the policy the manager defined.","An example implementation of callbacks is as follows:",{"@attributes":{"id":"p-0155","num":"0160"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public interface ConsumeCallback {",{}]},{"entry":[{},"\u2003public interface Pre extends ConsumeCallback {",{}]},{"entry":[{},"\u2003\u2003public long preConsume(ResourceDomain domain,long",{}]},{"entry":[{},"\u2003\u2003\u2003currentUsage,long proposedUsage);",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003public interface Post extends ConsumeCallback {",{}]},{"entry":[{},"\u2003\u2003public void postConsume(ResourceDomain domain,long",{}]},{"entry":[{},"\u2003\u2003\u2003previousUsage,long grantedUsage);",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003public interface PreAndPost extends Pre, Post { }",{}]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Pre-consume callbacks are executed prior to the dispenser's handling of the consume request. The preConsume( ) routine has three arguments: the resource domain on which the consume request has been issued, the current usage, and the proposed usage\u2014that is, the current usage increased by the requested amount, rounded up to meet granularity requirements. The value returned by preConsume( ) indicates to the dispenser how much of the request should be granted. A pre-consume callback that always denies the request would return currentUsage. Return values outside of the [currentUsage, proposedUsage] range are ignored. As multiple consume actions may be invoked on any consume, the dispenser combines the return values of pre-callbacks (merges policy decisions). The default policy is to take the minimum, rounded up to the nearest granularity multiple. Finally, pre-consume callbacks are executed synchronously with respect to the consume request and prior to its completion.","Pre-consume callbacks and their triggers can be thought of as programmable constraints. In addition to denying the request, they can lower it or grant it unaltered, and, regardless of the outcome, they can arbitrarily modify the behavior of an isolate bound to the resource domain.","In contrast to pre-consume callbacks, post-consume callbacks execute after the dispenser executes the triggered constraints and decides how much of the request should be granted. Post-consume callbacks can be viewed as notifications. They inform the isolate that set them about resource consumption decisions and allow for adjusting behavior to operate in changed conditions. A callback may implement any of ConsumeCallback's subinterfaces, including ConsumeCallback itself. For example, a callback that implements ConsumeCallback itself can be useful in conjunction with rate-limiting triggers that never actually fire. There is no requirement that all consume actions to which a given isolate is bound be set by the same entity. Isolates can impose notifications on themselves so that they can react to triggered constraints. An isolate can impose constraints on other isolates and thereby act as a resource manager for a set of isolates. For instance, a computation may require notification whenever its heap memory usage exceeds a certain threshold, and upon receiving the notification, it may remove some items from its private in memory cache to lower its memory consumption and thus avoid violating a constraint. In the following example, an isolate sender is bound by its creator to resource domains for CPU time and outgoing network traffic:","ResourceDomain.currentDomain(CPU_TIME).bind(sender);","ResourceDomain.currentDomain(NET_OUT).bind(sender);","The isolate can then specify notification policies for these two resources to be informed about excessive usage of either of the two resources and switch between two states: sending data in the uncompressed format if the most recent callback was caused by using more than 90% of the CPU time or sending data in the compressed format if the most recent callback was caused by using more than 1 MB\/s of network bandwidth. An example code implementation is provided below:",{"@attributes":{"id":"p-0160","num":"0165"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ code in sender's main:"},{"entry":"class ToggleCallback implements ConsumeCallback.Post {"},{"entry":"\u2003public void postConsume(ResourceDomain rd, long"},{"entry":"\u2003\u2003previousUsage,long grantedUsage) {"},{"entry":"\u2003\u2003String name = rd.getResourceAttributes( ).getName( );"},{"entry":"\u2003\u2003if (name.equals(CPU_TIME))"},{"entry":"\u2003\u2003\u2003setCompressing(false);"},{"entry":"\u2003\u2003else if (name.equals(NET_OUT))"},{"entry":"\u2003\u2003\u2003setCompressing(true);"},{"entry":"\u2003}}"},{"entry":"ConsumeCallback callback = new ToggleCallback( );"},{"entry":"\u2003ResourceDomain.currentDomain(CPU_TIME).setConsumeAction(new"},{"entry":"\u2003\u2003ConsumeAction(true, false, callback, new"},{"entry":"\u2003\u2003RateDetectingTrigger(1000, 900))); \/\/ ms"},{"entry":"\u2003ResourceDomain.currentDomain(NET_OUT).setConsumeAction(new"},{"entry":"\u2003\u2003ConsumeAction(true, false, callback, new"},{"entry":"\u2003\u2003RateDetectingTrigger(1000, 1 * MB)));"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"RateDetectingTrigger triggers the associated callback when the rate of consumption is too high.","Another example code implementation with the already described exemplary class definitions is provided below to further illustrate realizations of the invention.",{"@attributes":{"id":"p-0163","num":"0168"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public static void main(String[ ] args) { \/\/ class App"]},{"entry":[{},"\u2003String R = args[0]; \/\/ get name of resource to manage"]},{"entry":[{},"\u2003ResourceDomain rd = ResourceDomain.currentDomain(R);"]},{"entry":[{},"\u2003long reserved = domain.getReservation( ).getValue( );"]},{"entry":[{},"\u2003if (rd.getIsolates( ).length != 1 \u2225 reserved < 50)"]},{"entry":[{},"\u2003\u2003error(\u201cI don't like this . . . \u201d);"]},{"entry":[{},"\u2003ConsumeCallback cRed = new ConsumeCallback.Post( ) {"]},{"entry":[{},"\u2003\u2003void postConsume(ResourceDomain rd, long previous, long"]},{"entry":[{},"\u2003\u2003\u2003granted) {"]},{"entry":[{},"\u2003\u2003\u2003\/\/ Arrange to decrease consumption immediately! "]},{"entry":[{},"\u2003\u2003}};"]},{"entry":[{},"\u2003Trigger tRed = Triggers.newAbsoluteUp(reserved \u2212 5);"]},{"entry":[{},"\u2003ConsumeAction red = new ConsumeAction(true, false, cRed,"]},{"entry":[{},"\u2003\u2003tRed);"]},{"entry":[{},"\u2003rd.setConsumeAction(red);"]},{"entry":[{},"\u2003ConsumeCallback cGreen = new ConsumeCallback.Post( ) {"]},{"entry":[{},"\u2003\u2003void postConsume(ResourceDomain rd, long previous, long"]},{"entry":[{},"\u2003\u2003\u2003granted) {"]},{"entry":[{},"\u2003\u2003\u2003\/\/ R abundant, OK to increase its consumption"]},{"entry":[{},"\u2003\u2003}};"]},{"entry":[{},"\u2003Trigger tGreen = Triggers.newAbsoluteDown(5);"]},{"entry":[{},"\u2003ConsumeAction green = new ConsumeAction(true, false, cGreen,"]},{"entry":[{},"\u2003\u2003tGreen);"]},{"entry":[{},"\u2003rd.setConsumeAction(green);"]},{"entry":[{},"\u2003\u2003\u2003\/\/ go about consuming . . ."]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"After obtaining a handle to its domain for R, App makes sure that there are no other isolates bound to it and that at least 50 units of the resource are available. It then creates two consume actions. Both are persistent, asynchronous, and \u201cpost,\u201d which means that when they trigger, they are executed asynchronously immediately after the dispenser commits to allowing (or denying) a resource consumption request. The red consume action triggers when usage is just five units below the reserved quantity; the goal of its associated callback is to inform the rest of the computation that lowering its consumption of R is imperative. The green consume action has a dual goal: whenever R is abundant (its consumption drops to no more than five units), the imperative conservation state is rescinded, and the computation may resume consuming R freely. Both of these actions behave as notifications; they inform the application of a change in its resource consumption state.","Controlling Rate of Resource Consumption","In addition to exerting control over the amount of resource consumption, actions can be utilized for controlling the rate of resource consumption. Instead of extending a conventional thread scheduler with interfaces for influencing its scheduling decisions, or adding a set of rate-controlling routines to the resource management class definitions, consumption requests can be throttled until they match a desired or threshold consumption rate. Throttling resource requests to control resource consumption rate utilizes the ability to gain control at every resource consumption point with an intermediate resource request handler (e.g., the dispenser) and implies the ability to delay the consuming computation or isolate at each of those points.",{"@attributes":{"id":"p-0166","num":"0171"},"figref":"FIG. 11","b":["1101","1105","1109","1107"]},"At block , the remaining triggers are evaluated and their actions invoked accordingly.","At block , a sleep time is computed. At block , the dispenser sleeps for the computed sleep time. Control flows from block  to block .","For example, assume control over rate of bandwidth consumption is desired. Rate of bandwidth consumption per client is allowed up to 3 Mb\/s. A client first requests transmission of 2 Mb. Next, the client requests transmission of another 2 Mb. If the client submits both of these requests within a second, then the first request will be granted (assuming there are no contrary resource management policies or shortage of bandwidth). When the second request is received, then the dispenser goes to sleep with the request until a sufficient amount of time has passed so that granting of the request will be within the threshold rate. If the client requests 5 Mb of bandwidth, then the dispenser may grant the request and sleep with the next request, deny the request, or initially sleep with the request until a sufficient amount of time has passed.",{"@attributes":{"id":"p-0170","num":"0175"},"figref":"FIG. 12","b":["1201","1203","1207","1205"]},"At block , a potential consumption rate is determined based on the current consume request and a given interval. Control flows from block  to block .","At block , the amount previously consumed over the given interval is determined. At block , a potential consumption rate is determined based on the determined previously consumed amount and the current consume request. At block , rate monitoring parameters are updated to reflect the current request. For example, historical requests are updated to include the current request (i.e., currently requested amount) and historical data that falls outside of the given interval is removed. Various realizations of the invention will implement tracking of resource consumption rate differently (e.g., taking unconsume requests into consideration, maintaining a data structure separate from a managing dispenser to persist even if the dispenser is destructed, maintaining a data structure that tracks resource requests with the dispenser, tracking consume requests with a persistent action, tracking requests in the resource domain, etc.). At block , it is determined if the determined potential consumption rate exceeds a threshold or desired rate of consumption. If the determined potential consumption rate exceeds the threshold rate, then control flows to block . If the determined potential consumption rate does not exceed the threshold rate, then control flows to block .","At block , processing of the consume request continues.","At block , a sleep time is determined based on the given interval, the previous consumption, and the consume request. At block , the controlling computation (e.g., a dispenser instance) sleeps for the determined sleep time. Control flows from block  to block .","The following code is an exemplary implementation of controlling consumption rate, similar to that illustrated in , utilizing previously described example class definitions.",{"@attributes":{"id":"p-0176","num":"0181"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ The time and current usage of the previous request.",{}]},{"entry":[{},"long previousTime = \u22121, previousUsage = \u22121;",{}]},{"entry":[{},"boolean shouldFire(long currentUsage, long proposedUsage) {",{}]},{"entry":[{},"\u2003if (previousTime != \u22121)",{}]},{"entry":[{},"\u2003\u2003record(previousTime, currentUsage \u2212 previousUsage);",{}]},{"entry":[{},"\u2003previousUsage = currentUsage;",{}]},{"entry":[{},"\u2003previousTime = currentTime;",{}]},{"entry":[{},"\u2003removeRecordsWithTstampsBefore(currentTime \u2212 interval);",{}]},{"entry":[{},"\u2003long amount = totalAmountRequestedInRecordedEvents( );",{}]},{"entry":[{},"\u2003long delta = proposedUsage \u2212 currentUsage;",{}]},{"entry":[{},"\u2003if (amount + delta > threshold) {",{}]},{"entry":[{},"\u2003\u2003\u2003long interval1 = (interval * (amount + delta)) \/",{}]},{"entry":[{},"\u2003\u2003threshold;",{}]},{"entry":[{},"\u2003\u2003\u2003Thread.sleep(interval1 \u2212 interval);",{}]},{"entry":[{},"\u2003}",{}]},{"entry":[{},"\u2003return false; \/\/ no need to invoke callback",{}]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"As in the above examples, triggers are invoked as the first step of processing a consume request. The shouldFire( ) routine above can know how much of the current request has been granted subsequent to the first time it is invoked. The first lines of shouldFire( ) are responsible for this: if this is not the first time the routine is invoked, the time of the previous request was recorded along with the quantity granted, which is the difference between the usage then and now. Afterwards, records older than interval are removed, and the total amount of requested quantities is computed over the remaining records. If the amount increased by the quantity currently being requested exceeds the threshold, the trigger sleeps long enough to bring the rate of consumption down to the required range. Since triggers in various realizations of the invention operate within a critical section within the dispenser path, other potential consumers are held off during such a sleep. An alternative to controlling consumption rate is to control the rate of consume requests themselves.","Throttling resource requests with an intermediate request handler provides a mechanism for developers to adjust consumption rate (or request rate) independent of the platform, native code, or middleware code. Providing such a mechanism that can be implemented in a safe language facilitates development of diverse techniques for controlling resource consumption rates. In addition, these techniques can take advantage of the flexibility and portability of safe language instead of being hampered by constraints of proprietary code.","While the flow diagrams show a particular order of operations performed by certain realizations of the invention, it should be understood that such order is exemplary (e.g., alternative realizations may perform the operations in a different order, combine certain operations, overlap certain operations, perform certain operations in parallel, etc.). For example, in , as each policy decision action is determined it can be set aside and the next policy action determined, the respective operations of the determined policy action be performed before the next policy decision action is determined, a thread can be spawned to perform respective operations as each policy decision action is determined, etc. Also in , triggers may be evaluated in parallel or sequentially. As each trigger is evaluated, its one or more corresponding policy decision actions may be executed upon evaluation, its one or more corresponding policy decision actions may be executed after all other triggers are evalutated, etc. In addition, after evaluation of triggers, their corresponding policy decision actions may be executed in parallel or sequentially. Blocks that indicate operations related to merging decisions and reservations may not be performed;  may not take into account global and local dispensers; block  of  may be performed in parallel or combined with block ; etc.","Exemplary System","The described invention may be provided as a computer program product, or software, that may include a machine-readable medium having stored thereon instructions, which may be used to program a computer system (or other electronic devices) to perform a process according to the present invention. A machine readable medium includes any mechanism for storing or transmitting information in a form (e.g., software, processing application) readable by a machine (e.g., a computer). The machine-readable medium may include, but is not limited to, magnetic storage medium (e.g., floppy diskette); optical storage medium (e.g., CD-ROM); magneto-optical storage medium; read only memory (ROM); random access memory (RAM); erasable programmable memory (e.g., EPROM and EEPROM); flash memory; electrical, optical, acoustical or other form of propagated signal (e.g., carrier waves, infrared signals, digital signals, etc.); or other types of medium suitable for storing electronic instructions.",{"@attributes":{"id":"p-0181","num":"0186"},"figref":["FIG. 13","FIG. 13"],"b":["1300","1301","1300","1307","1307","1300","1303","1305","1309","1309","1307","1307","1301","1309","1309","1305","1303","1307","1307","1303"]},"While circuits and physical structures are generally presumed, it is well recognized that in modern semiconductor and design fabrication, physical structures and circuits may be embodied in computer readable descriptive form suitable for use in subsequent design, test, or fabrication stages as well as in resultant fabricated semiconductor integrated circuits. Accordingly, claims directed to traditional circuits or structure may, consistent with particular language thereof, read upon computer readable encodings and representations of same, whether embodied in media or combined with suitable reader facilities to allow fabrication, test, or design refinement of the corresponding circuits and\/or structures.","While the invention has been described with reference to various realizations, it will be understood that these realizations are illustrative and that the scope of the invention is not limited to them. Many variations, modifications, additions, and improvements are possible. More generally, realizations in accordance with the present invention have been described in the context of particular realizations. These realizations are meant to be illustrative and not limiting. Accordingly, plural instances may be provided for components described herein as a single instance. Boundaries between various components, operations and data stores are somewhat arbitrary, and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of claims that follow. Finally, structures and functionality presented as discrete components in the exemplary configurations may be implemented as a combined structure or component. These and other variations, modifications, additions, and improvements may fall within the scope of the invention as defined in the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention may be better understood, and its numerous objects, features, and advantages made apparent to those skilled in the art by referencing the accompanying drawings.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIGS. 2A-2C","FIG. 2A","FIG. 2B","FIG. 2C"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIGS. 5A-5B","FIG. 5A","FIG. 5B","FIG. 5B"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIGS. 9A-9B","FIG. 9A","FIG. 9B","FIG. 9A"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 10A","FIG. 10B"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
