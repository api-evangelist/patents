---
title: System and method for user interface automation
abstract: A system and method for language-neutral runtime user interface automation by: providing an automation script for automating use of the user interface in an application; intercepting a call from the automation script to a function simulating a user action on the application; retrieving a translated text string associated with the function call; and calling the function simulating the user action with the translated text string. This provides the advantages of not attaching any extra burden on the script developer and requiring little extra from the user (other than providing a native-language reference file).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08171460&OS=08171460&RS=08171460
owner: International Business Machines Corporation
number: 08171460
owner_city: Armonk
owner_country: US
publication_date: 20031114
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["1. Technical Field","This invention relates to the general field of user interface automation, and particularly (though not exclusively) runtime graphical user interface automation.","2. Background Art","User interface automation involves the development of technical test scripts which will execute and which will allow an application to be navigated and tested in an automated way, i.e., with no user intervention. If the automation scripts are well written then errors\/bugs will be automatically recorded so that an engineer can acknowledge and address these bugs when the automation scripts have run to completion. Once the bugs are fixed it is a common practice to execute the automation scripts again, thereby proving that the application being tested is bug free.","Automation scripts are commonly written so as to 1) significantly speed up the software testing process, 2) allow automation to run when engineers are away from the office (e.g., at night), and 3) develop test cases which are complete and comprehensive. Automation is therefore a useful tool\/methodology for reducing costs of quality engineering and testing, as it speeds up the same activity that would otherwise be done manually.","One of the main problems\/drawbacks with automation scripts is that they need to be heavily modified so as to execute on translated versions of an application (and it is common knowledge that testing on translated versions of the application accounts for over 80% of a corporation's worldwide testing effort). This process of modification (so that the automation can be run against translated versions of an application) is time consuming and error prone in a number of ways. Once the automation is developed it traditionally needs to be \u201cre-engineered\u201d to accommodate the characteristics of different language versions of the application. In particular, references that the automation makes to textual components on screen are invalid when the automation is executed on a translated version of the same application. Re-engineering implies fundamental structural changes to the automation to allow it to run on the translated versions of the application. Subsequent testing, revision and re-testing of the automation is also time consuming. Finally, when the automation is modified to cater for a subsequent version of the application (e.g. Version 2) the cycle of re-engineering, revision and re-testing needs to happen again. Therefore, the current industry methodology for developing automation results in a process which is time consuming and expensive when translated\/language versions of the same application are considered. Because of this, few companies develop automation to run on translated versions of the application (i.e., it is generally written and designed for English versions of the application).","From U.S. Pat. No. 5,475,843 ('843 patent) there are known a system and methods for automated program testing which require predetermined, systematic and complex interception of the running application at run time. The level of interception is intrusive, and has the disadvantage of creating a high probability of compromising the natural execution of the application. In Quality Engineering terms, methods of automation are gauged on their effectiveness, and one measure is the level of interference for the running application being tested. The methods used in the '843 patent rely on an interception-based methodology or system, rather than allowing the application to run unhindered.","A second drawback to the methodology used in the '843 patent is that it cannot intercept and control the resolution and management of complex user interface control types (such as InfoBox panels in IBM\u00ae Notes\u2122 and Smartsuite\u2122 products, or a number of the more complex user interface classes in Sun Microsystems' J2EE\u2122\u2014Java\u2122 2 Platform, Enterprise Edition).","Further, in the '843 patent's methodology the application is centric, i.e., the interception of all application messages, events (keyboard, mouse, system), states, etc., is a pre-requisite to success. Such a model once again interferes with the natural execution of the application. This gives rise to quality and engineering considerations which can undermine the true value of the automation being run.","Finally, the methodology used in the '843 patent encourages a level of abstraction which can potentially take some degree of control from the script writer. In this regard the script writer is somewhat dependent on the methodology and characteristics of the '843 patent's interception and event handling engine. This limits the degree of control that the script writer can have in the '843 patent's natural test abstraction development methodology.","In summary, the '843 patent's automated testing solution behaves in a way which encourages interference and interception of the running application. The '843 patent relies on the specific interception of the running application to achieve its goals, and relies on the need to write ATUs (Application Translation Units).","A need therefore exists for a system and method for language-neutral runtime user interface automation wherein the abovementioned disadvantage(s) may be alleviated.","In accordance with a first aspect of the present invention there is provided a system for user interface automation, the system comprising: automation script means for receiving an automation script for automating use of the interface in an application; and script translation means for intercepting a call from the automation script to a function simulating a user action on the application, retrieving a translated text string associated with the function call, and calling the function simulating the user action with the translated text string.","In accordance with a second aspect of the present invention there is provided a method for user interface automation, the method comprising: providing an automation script for automating use of the user interface in an application; intercepting a call from the automation script to a function simulating a user action on the application; retrieving a translated text string associated with the function call; and calling the function simulating the user action with the translated text string.","In accordance with a third aspect of the present invention there is provided a computer program element comprising computer program means for: providing an automation script for automating use of the user interface in an application; intercepting a call from the automation script to a function simulating a user action on the application; retrieving a translated text string associated with the function call; and calling the function simulating the user action with the translated text string.","The present invention allows the above problems to be solved and provides a framework for a solution which will allow automation scripts to be developed once and re-used unmodified against translated versions of the same application.","In a preferred embodiment, the present invention allows run-time mapping of user interface components of an automation script using an original-language (e.g., English) automation script as the reference; this has great potential because it does not attach any extra burden on the script developer and requires little extra from the user\u2014other than providing an English reference file.","A typical test automation tool provides the following features: scripting language which is used to describe the logic of the test case, e.g., including basic flow control semantics; a library of functions which will simulate user actions on the application graphical user interface, e.g., a button click; result reporting library which will record test script execution, passes and failures; and test script interpreter which will execute the test cases.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1","b":["110","120","130","140"]},"In the following example a section of the test script such as  will log a user on. A pictorial illustration of such a test script section is shown in , in which the test script  is associated with an interactive \u2018Log On\u2019 dialog  displayed on a user display (not shown). The user interacts with the displayed dialog  by entry of text via a keyboard (not shown) and movement of a display pointer (not shown) and clicking of a selection device such as a mouse (not shown) in conventional manner. The script includes a line \u2018EditSet Text (\u201cUser name\u201d, \u201cJohn Doe\u201d)\u2019 which is associated (as shown by arrow ) with a \u2018User name\u2019 text input field in the dialog , a line \u2018EditSet Text (\u201cPassword\u201d, \u201cpassword\u201d)\u2019 which is associated (as shown by arrow ) with a \u2018Password\u2019 text input field in the dialog , and a line \u2018ButtonClick (\u201cLog On\u201d)\u2019 which is associated (as shown by arrow ) with a \u2018Log On\u2019 button (or a \u2018Cancel\u2019 button) in the dialog . To achieve the desired result, the user must enter the text \u2018John Doe\u2019 in the \u2018User name\u2019 field, must enter the text \u2018password\u2019 in the \u2018Password\u2019 field, and must click \u2018Log On\u2019 button.","A test tool provides functions that allow the automation of the manual user steps of: (1) selecting the \u2018User name\u2019 edit control; (2) typing a user's name; (3) selecting the \u2018Password\u2019 edit control; (4) typing a user's password; and (5) clicking the \u2018Log On\u2019 button.","In the above example the edit controls and button are identified by the text label associated with them, which would be intuitive for the test script author.","Now consider what happens when the application to be tested is translated (in this example into German), as shown in .","Because the text labels have been translated, the translated \u2018Anmeldung\u2019 dialog  (corresponding to the dialog , shown in this figure\u2014for comparison only\u2014by dashed line) is displayed to the user by the translated application. As shown, the translated \u2018Anmeldung\u2019 dialog  comprises a text input field labeled \u2018Benutzemame\u2019, a text input field labeled \u2018Kennwort\u2019, and buttons labeled \u2018Anmeldung\u2019 and \u2018Abbrechen\u2019. Consequently, it will be understood that the test script will fail (as indicated by the crossed arrow ) at the first step \u2018EditSet Text (\u201cUser name\u201d, \u201cJohn Doe\u201d)\u2019 described above and will report an error.","To prevent the failure of the test script, the following testing scheme is employed to provide a mechanism to automatically translate the text string used to identify the control being manipulated.  illustrates the modified system  for the execution of test automation which takes into account the translation of the target application, i.e., the application being tested. As shown, the system  includes test script , script translation engine  (which will be described in greater detail below) and supporting libraries of source resources  and target resources , script interpreter , target application  and test results .","As will be described in greater detail below, the Script Translation Engine is a new component, which performs the following functions: intercept calls to functions which simulate user actions on the application, retrieve the resource identifier associated with the text string which identifies the target control, retrieve the translated string associated with the resource identifier, and call the original function which simulates the user action but with the translated string.","The Script Translation Engine  includes a Message Translation Engine (MTE)  which is responsible for supplying the translated text for the automation script's run time execution, and an Intelligent Text Locator (ITL)  which is responsible for selectively supplying the appropriate text to the automation script's run time execution. For example, the ITL  should not parse the externalized resources in a generic way. It should source these in the context of the instruction being applied. If the script engine is processing a button (e.g. \u2018press OK\u2019, \u2018press Cancel\u2019) then the ITL must provide the relevant dialog text. The MTE  differs from the ITL  in a number of ways, a key one of which is that the MTE could search for a translation to a textual object, but the search may get satisfied with an incorrect translation. This can typically happen when there are multiple instances of a textual object (i.e. a word or a sentence can appear in multiple places). It is the job of the ITL to ensure that during a search the correct translation is returned and that it respects the nature and type of control that the textual object belongs to\u2014as opposed to simply taking the first match from the MTE.","When the call for a user action is intercepted the control type and translatable text must be identified. This can be inferred from the name of the function being called, e.g., \u2018ButtonClick\u2019 refers to push buttons, and the signature of the function (i.e., \u2018ButtonClick\u2019 takes a single argument which is the text label of the button to be clicked).","There are numerous examples of how the calls could be intercepted but the goal is to do this without requiring any test script alteration. For example, as shown in , this goal can be achieved by providing a library of functions which have the same signatures as the calling functions but which call the script translation engine before calling the underlying user action function from the test tool, then: either providing modified\/renamed \u2018include\u2019 files which reference the script translation enabled library and having the test script reference that library, or naming the script translation enabled library with the same name as the test tool library and having the test script reference it (in this case, the script translation enabled library would still reference the original functions).","As shown in the , this process  of steps for implementing intercept and execution of a user interface action includes a first step  of intercepting the user interface action and identifying (i) the action's control type and (ii) its translatable text. At step  look up of the resource identifier is performed. At step  look up of the translated text is performed. Finally, at step  the user interface action is executed with the translated text.","Look up of the resource identifier uses the control type to allow for the case where the same text string is translated differently depending on context. The lookup can be implemented on the resource files or the compiled application binary files.","Look up of the translated text uses the resource ID. This will be a standard operation and can be executed on the compiled application binary files.","Thus, as shown in , the first line (for example) of script section  is performed under control of the script translation engine  as follows with respect to translated user dialog \u2018Anmeldung\u2019 : the script line \u2018EditSetText (\u201cUser name\u201d, \u201cJohn Doe\u201d)\u2019 with causes the user action \u2018ID_USER_NAME \u201cUser name\u201d\u2019 to be looked up (as indicated by arrow ) in source (English) resources library ; the entry (user action \u2018ID_USER_NAME \u201cBenutzemame\u201d\u2019) with same resource ID is then looked up (as indicated by the arrow ) in the target (German) resources library ; and the user action \u2018ID_USER_NAME \u201cBenutzername\u201d\u2019 is then passed back (as indicated by the arrow ) to the script , where it is associated (as indicated by the arrow ) with the text entry field \u2018Benutzername\u2019 in the user dialog , resulting in successful completion of the source line in the script .","Thus, test execution in the modified system may be summarized as follows: the Script Translation Engine (STE)  uses the control type and text string to identify the resource identifier; the STE  then finds the equivalent resource in the translated version of the resources; the STE  substitutes the translated text string into the user action function; and the original user action function is called with the translated text.","It may be noted that if the translated text cannot be located, the test script will fail as previously described above in relation to . However, in this case the failure is valid, e.g., it could be that the version of the translated application differs from the one for which the test script was written.","It will therefore be appreciated that the modified automated test system described above is based on the two important features: (1) replacement of the default library of test functions (which simulate user actions) with a script translation engine enabled set of test functions, and (2) implementation of the script translation engine such that execution of an unmodified test script which will successfully run against a translated version of the application.","The sample code included in the following description is written in Java\u2122 and uses features of the Java\u2122 platform to illustrate a practical implementation of the key concepts. However, it will of course be understood that the present invention is not limited to such implementation, and may alternatively be implemented using a different programming language for a different platform.","Sample Test Script","Continuing from the example described above, only a subset of the test functions that would typically be provided are considered below, i.e., a function to simulate a user typing text in an editable text field, and a function to simulate a user clicking a button.","To simplify the example, a set of dummy test functions are provided which only output a text description of what the real test functions would do. These are implemented as static methods in a Java\u2122 class as follows:",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class TestMethods {"]},{"entry":[{},"\u2003static public void EditSetText(String label, String text) {"]},{"entry":[{},"\u2003\u2003System.out.println(\u201cType\\\u201d\u201c + text +\u201d\\\u201cin"]},{"entry":[{},"\u2003\u2003the \\\u201d\u201c + label + \u201d\\\u201c text edit field.\u201d);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003static public void ButtonClick(String label) {"]},{"entry":[{},"\u2003\u2003System.out.println(\u201cClick the button \\\u201d\u201c + label + \u201d\\\u201c.\u201d);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"An extract of a test script which uses these functions could look like this:",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class TestScript {"]},{"entry":[{},"\u2003public static void main(String[ ] args) {"]},{"entry":[{},"\u2003\u2003\/\/ test initialization"]},{"entry":[{},"\u2003\u2003\/\/ perform user log on"]},{"entry":[{},"\u2003\u2003TestMethods.EditSetText(\u201cUser name\u201d, \u201cJohn Doe\u201d);"]},{"entry":[{},"\u2003\u2003TestMethods.EditSetText(\u201cPassword\u201d, \u201cpassword\u201d);"]},{"entry":[{},"\u2003\u2003TestMethods.ButtonClick(\u201cLog On\u201d);"]},{"entry":[{},"\u2003\u2003\/\/ remainder of the test case"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This test script is run using this command-line (assuming environment is correctly configured):","java TestScript","And the following output would be generated:","Type \u201cJohn Doe\u201d in the \u201cUser name\u201d text edit field.","Type \u201cpassword\u201d in the \u201cPassword\u201d text edit field.","Click the button \u201cLog On\u201d.","It is clear that the original English control labels are used to identify which editable text fields will have text entered and which button will be clicked. As described earlier this test script will fail when run against a translated version of the product.","Script Translation Enabled Test Methods","The original test function library needs to be shadowed by an alternative implementation of the test functions which are enabled for script translation. The preferred way to implement this is as follows: prevent the original test library from being loaded during test script execution, e.g., by renaming the library or changing its location; and make the script translation enabled version of the test functions available to be loaded. It is the responsibility of this implementation to ensure that the new functions can be used without any test script modification.","Continuing from the example started above, at runtime the test script will use the TestMethods class; to prevent it being loaded the class file is renamed from TestMethods.class to TestMethods.impl.","A script translation enabled version of the TestMethods class is provided. This implementation will: load the original implementation so the test functions can be called after script translation, and call the script translation engine to translate any text before calling the test function.","Loading the original implementation in Java\u2122 requires the use of a class loader. This could be implemented as follows:",{"@attributes":{"id":"p-0062","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"import java.io.FileInputStream;"},{"entry":"public class TestMethodsClassLoader extends ClassLoader {"},{"entry":"\u2003Class loadTestMethods(String name) throws ClassNotFoundException {"},{"entry":"\u2003\u2003FileInputStream fi = null;"},{"entry":"\u2003\u2003try {"},{"entry":"\u2003\u2003\u2003String path = name.replace(\u2018.\u2019, \u2018\/\u2019);"},{"entry":"\u2003\u2003\u2003fi = new FileInputStream(path + \u201c.impl\u201d);"},{"entry":"\u2003\u2003\u2003byte[ ] classBytes = new byte[fi.available( )];"},{"entry":"\u2003\u2003\u2003fi.read(classBytes);"},{"entry":"\u2003\u2003\u2003return defineClass(null, classBytes, 0, classBytes.length);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003catch (Exception e) {"},{"entry":"\u2003\u2003\u2003\/\/ we could not find the class"},{"entry":"\u2003\u2003\u2003\/\/ so indicate the problem with an exception"},{"entry":"\u2003\u2003\u2003throw new ClassNotFoundException(name);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003finally {"},{"entry":"\u2003\u2003if (null != fi) {"},{"entry":"\u2003\u2003\u2003\u2003try {"},{"entry":"\u2003\u2003\u2003\u2003\u2003fi.close( );"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003catch (Exception e) {"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"This implementation of a Java class loader simply loads the renamed file (i.e., \u2018TestMethods.impl\u2019) and then defines a new Java class from the loaded bytes. In the script translation engine enabled implementation of the TestMethods class this class loader is used as follows:",{"@attributes":{"id":"p-0064","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ load the script translation engine"},{"entry":"scriptTranslationEngine = new ScriptTranslationEngine( );"},{"entry":"\/\/ use a custom classloader to load the original implementation"},{"entry":"TestMethodsClassLoader classLoader = new TestMethodsClassLoader( );"},{"entry":"testMethods = classLoader.loadTestMethods(\u201cTestMethods\u201d);"},{"entry":"editSetText = testMethods.getMethod(\u201cEditSetText\u201d, editSetTextArgs);"},{"entry":"buttonClick = testMethods.getMethod(\u201cButtonClick\u201d, buttonClickArgs);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The renamed class file is loaded and references to the original test functions can be created and saved for later use. An instance of the script translation engine is also loaded and saved for later use.","The script translation enabled test function would look like this:",{"@attributes":{"id":"p-0067","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"static public void EditSetText(String label, String text) {"},{"entry":"\u2003try {"},{"entry":"\u2003\u2003label = scriptTranslationEngine.getTranslatedText(\u201cEDIT\u201d, label);"},{"entry":"\u2003\u2003Object[ ] args = new Object[ ] { label, text };"},{"entry":"\u2003\u2003editSetText.invoke(null, args);"},{"entry":"\u2003}"},{"entry":"\u2003catch (Exception e) {"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Before calling the original test function the script translation engine is first called to get the translated text.","Script Translation Engine","The script translation engine implements the following features: load the resource files for the version of the application for which the test script was written and on which the test script is to be executed; build a lookup table for resolving resource identifiers from resource strings and control types; and perform lookups to get the translated text from a resource string and control type.","In Java\u2122 the resource files are typically implemented as property bundles (text files containing resource identifier and resource values name\/value pairs). This implementation below assumes the names of the source (the version for which the test script was written) and target (the version on which the test script will be run) resource files names are specified as parameters to the Java\u2122 runtime library. Other runtime libraries will provide a mechanism to allow configuration settings to be configured from an external source, e.g., \u2018.ini\u2019 files.",{"@attributes":{"id":"p-0071","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ resource files to be used for this test run"},{"entry":"String sourceFile = System.getProperty(\u201csource_file\u201d);"},{"entry":"String targetFile = System.getProperty(\u201ctarget_file\u201d);"},{"entry":"\/\/ if they are the same or not specified then no translation is required"},{"entry":"if (sourceFile == null \u2225 sourceFile.equals(targetFile)) return;"},{"entry":"\/\/ load the language files"},{"entry":"sourceBundle = ResourceBundle.getBundle(sourceFile);"},{"entry":"targetBundle = ResourceBundle.getBundle(targetFile);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The lookup table uses the source resource strings as keys and the resource identifiers as values. In the case where the same string has multiple resource identifiers then all of them will be saved.",{"@attributes":{"id":"p-0073","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ populate the resource id lookup table with all resource values"},{"entry":"\/\/ using the resource strings as the keys and the resource ids as the"},{"entry":"\/\/ values. if a resource string has multiple resource ids then all of"},{"entry":"\/\/ the values are stored in a Vector."},{"entry":"for (Enumeration e = sourceBundle.getKeys( ); e.hasMoreElements( );) {"},{"entry":"\u2003String key = e.nextElement( ).toString( );"},{"entry":"\u2003String val = sourceBundle.getString(key.toString( ));"},{"entry":"\u2003if (resourceIdLookup.containsKey(val)) {"},{"entry":"\u2003\u2003Object keyObject = resourceIdLookup.get(val);"},{"entry":"\u2003\u2003Vector vals = null;"},{"entry":"\u2003\u2003if (keyObject instanceof Vector) {"},{"entry":"\u2003\u2003\u2003vals = (Vector) keyObject;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003else {"},{"entry":"\u2003\u2003\u2003vals = new Vector( );"},{"entry":"\u2003\u2003\u2003vals.add(keyObject);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003vals.add(key);"},{"entry":"\u2003\u2003resourceIdLookup.put(val, vals);"},{"entry":"\u2003}"},{"entry":"\u2003else {"},{"entry":"\u2003\u2003resourceIdLookup.put(val, key);"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Lookups require the control type and also the resource string to be specified. The example below demonstrates one strategy for resolving a resource ID where there are multiple resource IDs for a single string. This is important because in the translated version of the resource file the string could be translated in two different ways depending on context.",{"@attributes":{"id":"p-0075","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"String getTranslatedText(String control, String text) {"]},{"entry":[{},"\u2003if (resourceIdLookup.containsKey(text)) {"]},{"entry":[{},"\u2003\u2003Object key = resourceIdLookup.get(text);"]},{"entry":[{},"\u2003\u2003if (key instanceof Vector) {"]},{"entry":[{},"\u2003\u2003\u2003\/\/ simple strategy for finding the correct resource id"]},{"entry":[{},"\u2003\u2003\u2003\/\/ is to assume the id starts with the control type"]},{"entry":[{},"\u2003\u2003\u2003for (Enumeration e = ((Vector)key).elements( );"]},{"entry":[{},"\u2003\u2003\u2003e.hasMoreElements( );) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003String nextKey = e.nextElement( ).toString( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003if (nextKey.toString( ).startsWith(control)) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003text = targetBundle.getString(nextKey);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003break;"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003else {"]},{"entry":[{},"\u2003\u2003\u2003text = targetBundle.getString(key.toString( ));"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003return text;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"To run the previous test script with script translation enabled the following command-line is used (assume environment is correctly configured):","java-Dsource_file=resources_en-Dtarget_file=resources_de TestScript","The following files need to be available on the local file system: (1) \u2018resources_en.properties\u2019\u2014the English version of the application resources; (2) \u2018resources_de.properties\u2019\u2014the German version of the application resources; (3) \u2018TestMethods.impl\u2019\u2014the original implementation of the test functions.","And the following output would be generated:","Type \u201cJohn Doe\u201d in the \u201cBenutzemame\u201d text edit field.","Type \u201cpassword\u201d in the \u201cKennwort\u201d text edit field.","Click the button \u201cAnmeldung\u201d.","Thus, it will be understood that the novel scheme described above provides a method for overriding relevant Automation Script APIs (Application Programming Interfaces) which is easy to install\/uninstall\/integrate with an automation test tool, which allows Fast Resource lookup, \u2018write once read many\u2019 functionality, and easy subclassing of automation functions. It allows interception of selected runtime methods (of the automation environment) to perform translation on the fly of their parameters and subsequent calling of the native, unmodified automation environment methods with the translated parameters. Also, it permits runtime lookup of the original tested application translated resources, i.e., the same ones used by the tested application. It also allows fast resource lookup, resource lookup across multiple resource files in multiple directories, and resource lookup for partial strings. Also, it readily permits a log file of activity to be created.","It will be understood that the system and method described above provides language-neutral runtime user interface automation offering the following advantages:","(1) run-time mapping of the user interface components of the automation script using the original English automation script as the reference. This has great potential because it does not attach any extra burden on the script developer and requires little extra from the user\u2014other that providing the English reference file.","(2) Non interception methodology when compared with the prior art U.S. Pat. No. 5,475,843.","(3) Speed\u2014as the methodology in this idea incorporates a non-interference directive the application is allowed to execute in an unhindered way. It is common knowledge that interception based methodologies have the side effect of slowing down the running application.","(4) Less complexity for Script Writer, i.e., the script writer can write the automation script and in so doing is not concerned with designing the script to accommodate language\/translated characteristics.","(5) Supports a level of cooperation from the application with regard to proprietary custom controls, i.e., respects proprietary controls and provides an accessibility methodology based on what the application exposes by way of its application programming interface (API) and user interface (UI).","(6) Is automation centric in that the automation is seen as the driver of the application's natural execution. In the methodology of the prior art U.S. Pat. No. 5,475,843 the application is centric, in that the interception of all application messages, events (keyboard, mouse, system), states, etc., is a pre-requisite to success. This prior art methodology can be considered a flawed model as once again it interferes with the natural execution of the application. This gives rise to quality and engineering considerations which can undermine the true value of the automation being run.","(7) The methodology used in the prior art U.S. Pat. No. 5,475,843 encourages a level of abstraction which can potentially take some degree of control from the script writer. In this regard the script writer is somewhat dependent on the methodology and characteristics of the prior art patent's interception and event handling engine. This limits the degree of control that the script writer can have in the prior art patent's natural test abstraction development methodology. The novel scheme described above assumes a non-interference directive, and therefore looks to a cooperating application to achieve the test automation goals. This can be seen as a key difference: the novel scheme described above supports non-interference, while the prior art patent relies on interference. In summary, the prior art patent's solution solves a similar class of problem to that of the novel scheme described above, but in a way which encourages interference and interception of the running application. In contrast, the novel scheme described above protects the application's natural run-time execution, i.e., during the application's run time a language setting decides what language is being tested, and the script writer's additional effort is minimized in supporting the run-time testing of this localized application. Also, the novel scheme described above simply takes the localized components of existing translated applications and seamlessly makes these available during the script's run time\u2014therefore not depending on a database. The novel scheme described above may be considered as effectively subclassing the script to allow a language-neutral execution of the script. This differs to the prior art patent's solution which relies on the specific interception of the running application to achieve its goals. Therefore the need to write ATUs (as seen in the prior art patent) is unnecessary in the methodology of the novel scheme described above.","(8) Test script is written once and re-used across all languages.","(9) No need to translate the test script to run on translated products or applications.","(10) No test script modifications required when running on different language versions.","(11) Solution is independent from the target control type implementations (i.e., the automation environment is left unmodified to deal with those aspects), platforms, technologies, etc.","(12) Can be applied to various automation environments independently of them.","(13) No additional effect on the runtime environment of the tested application compared to the same automation running without the novel scheme described above.","It will be appreciated that the method described above for language-neutral automation of test scripts will typically be carried out in software running on a processor (not shown) within the system, and that the software may be provided as a computer program element carried on any suitable data carrier (also not shown) such as a magnetic or optical computer disc.","It will be understood and appreciated that alternatives to the aspects of the novel scheme described above will be apparent to a person of ordinary skill in the art, without departing from the underlying inventive concept. For example, although the novel scheme has been described in the context of a graphical user interface, it will be appreciated that the invention may be employed in the context an alternative user interface such as a text user interface."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["One system and method for language-neutral runtime user interface automation incorporating the present invention will now be described, by way of example only, with reference to the accompanying drawing(s), in which:",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 6","FIG. 5"]}]},"DETDESC":[{},{}]}
