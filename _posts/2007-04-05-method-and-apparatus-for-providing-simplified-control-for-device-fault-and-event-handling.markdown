---
title: Method and apparatus for providing simplified control for device fault and event handling
abstract: A method identifies, prior to runtime, a first device that is added to a system. Further, the method generates, prior to runtime, a statically precompiled database for the device that provides a first set of error handling data. In addition, the method identifies, during runtime, a second device that is added to the system. Finally, the method generates, during runtime, a dynamically allocated database for the second device that provides a second set of error handling data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07694185&OS=07694185&RS=07694185
owner: General Instrument Corporation
number: 07694185
owner_city: Horsham
owner_country: US
publication_date: 20070405
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims priority to U.S. Provisional Application Ser. No. 60\/777,731 entitled \u201cMethod and Apparatus for Providing Simplified Control for Device Fault and Event Handling,\u201d filed on Feb. 28, 2006, the content of which is incorporated herein by reference in its entirety.","1. Field","This disclosure generally relates to the field of systems. More particularly, the disclosure relates to device error and fault handling.","2. General Background","Most embedded computerized systems include a number of devices that are focused on specialized functionalities for a particular system. The devices may be hardware devices such as a set top box, cable modem, or any other hardware device known to one skilled in the art. Further, the devices may also be software components that are added to the system.","Software development for an embedded computerized system may involve controlling and configuring the hardware components within a device to interpret the incoming radio frequency (\u201cRF\u201d) signals and generate signals in MPEG2 format for television broadcasting. However, any of the hardware components can degenerate or malfunction. As a result, a hardware component may not perform the intended functionality. A safe run of the hardware devices can be performed to test whether the hardware devices are operating properly. For instance, an internal auditing task may continuously run in the background to assess the health status of a hardware device. If a faulty hardware device is detected, the reporting of the error to the end user may be very complicated based on the number of errors that could be the cause of the hardware device not working properly.","Event though a software project is essentially complete once the core software code has been developed, the time frame for device fault and event handling is often significant. Further, significant additional resources are often needed for analysis and preparation of code for the device fault and event handling.","In one aspect of the disclosure, a method is disclosed. The method identifies, during runtime, a device that is added to a system. Further, the method generates, during runtime, a dynamically allocated database for the device that provides error handling data in a tabular format.","In another aspect, a method is disclosed. The method identifies, prior to runtime, a first device that is added to a system. Further, the method generates, prior to runtime, a statically precompiled database for the device that provides a first set of error handling data. In addition, the method identifies, during runtime, a second device that is added to the system. Finally, the method generates, during runtime, a dynamically allocated database for the second device that provides a second set of error handling data.","In yet another aspect, a method is disclosed. The method identifies, prior to runtime, a first device that is added to a system. Further, the method generates, prior to runtime, a statically precompiled database for the device that provides a first set of error handling data in a first tabular format. In addition, the method identifies, during runtime, a second device that is added to the system. Finally, the method generates, during runtime, a dynamically allocated database for the second device that provides a second set of error handling data in a second tabular format.","A method and apparatus are disclosed, which provide simplified control for device fault and event handling. The method and apparatus may be utilized to simplify the often complicated and tedious task of handling a potentially enormous number of errors that could occur within the system. A table driven algorithm is utilized to handle the control of fault and the recovery. As a result, the amount of coding for identifying the hardware origin of an error, deciding the appropriate time to act on the error, executing the error, and recovering from the error in all of the potential error scenarios is reduced.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1","b":["100","100","102","104","106","108","100"]},"A table having a pre-defined data structure type may be created for each of the hardware devices. A pre-defined data structure type may be composed for each of the hardware interfaces supported by the system . Accordingly, the utilization of a table for each of the devices allows errors to be grouped for each of the identified hardware devices. As a result, device fault and event handling issues can be systematically resolved more quickly and with fewer resources.","During the system power up sequence, the system  discovers each of these devices and a corresponding interface for the respective device. Each of the discovered device interfaces registers itself with an event handling manager  in the system . The event handling manager  can be implemented as a task, thread, process, module, component, etc. in the system . Once a device is registered, the pre-defined table for the hardware interface corresponding to the device is retrieved. A copy of the pre-defined table is then generated. Further, the copy of the pre-defined table is then populated with known values for handling all the potential errors for the particular hardware interface.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2","b":["200","200","200","202","204","206","200","200","202","204","206"]},"The table  also has a set of known values that are populated for each of the predefined fields corresponding to an error and a hardware interface. For instance, the event error id X\u2032, event error id X\u2032, thresh count X\u2032, reset count X\u2032, timer count X\u2032, error message X\u2032, and alarm event X\u2032 are known values that are populated for the potential error X for the particular hardware interface. As a result, a set of events to identify and correct the potential error X  is preplanned. Similarly, sets of events can be preplanned to identify and correct the potential error Y  and the potential error Z . If a distinct table is generated for a different hardware interface that also has the potential error X , a different set of known values, e.g., event error id X\u2033, event error id X\u2033, thresh count X\u2033, reset count X\u2033, timer count X\u2033, error message X\u2033, and alarm event X\u2033, may be utilized to deal with the particular nuances of that hardware interface.","The predefined fields in the table  are utilized because they provide helpful information to simplify control for device fault and event handling. In another embodiment, additional or different fields may be utilized.","In yet another embodiment, a subset of all the potential errors that may occur for the particular hardware interface is pre-defined in the table . A subset may be utilized because of the difficulty in identifying all the potential errors or size constraints for storing a large number of potential errors.","In one embodiment, a table is generated for each identified hardware interface. Accordingly, the pre-defined data structure for one hardware interface may be different than another hardware interface. In other words, a different set of errors and values may be pre-defined and populated for different hardware interfaces.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 3","FIG. 1"],"b":["300","110","100","110","302","304","110","306","308","306","308","306","308"]},"In one embodiment, the event managing handler  composes a table for each hardware device and stores the table in the statically precompiled database  or the dynamically allocated database . The table lists the potential errors for the hardware device. The event managing handler  utilizes routines in the API  to compose a table for a hardware device with a fixed configuration. The event managing handler  retrieves data for the particular hardware device with the fixed configuration from a hardware interface database . In one embodiment, the event managing handler  retrieves the data by calling a routine in the API . The event managing handler  then predetermines events and corresponding responses for errors of the particular hardware device with the fixed configuration. Finally, the event managing handler  composes a table  with the predetermined events and corresponding responses for storage in the statically precompiled database .","The API  may have various routines that may be utilized by the event managing handler  and\/or module tasks in the system kernel . For example, a routine entitled \u201cEVENT_MGR_CPU_REGISTER\u201d may be utilized to associate the statically precompiled database  with a central processing unit (\u201cCPU\u201d) hardware database. In one embodiment, the statically precompiled database  is a static error tracking and error responding database predefined at compiling time. Accordingly, the EVENT_MGR_CPU_REGISTER routine may be utilized to associate the statically precompiled database with the CPU hardware database for tracking down runtime software errors. In addition, a routine entitled \u201cEVENT_MGR_CPU_RESOURCE_REGISTER\u201d may be utilized to associate the statically precompiled database  with a CPU resource hardware database to control the operational state of the system  initiated by the user. Other and\/or different routines may be utilized as the routines are provided above for illustrative purposes. Further, a routine entitled \u201cEVENT_MGR_ALARM_PANEL_REGISTER\u201d may be utilized to associate the statically precompiled database  with the components of an Alarm Panel hardware database to track down errors detected against Alarm Panel hardware.","Conversely, the event managing handler  may also utilize routines in the API  to compose a table for a hardware device having an interface discovered at the time of system power up. At the time of system power up, the event managing handler  identifies any newly added devices to the system  and retrieves data the particular hardware device during runtime from the hardware interface database . In one embodiment, the event managing handler  retrieves the data by calling a routine in the API . The event managing handler  then predetermines events and corresponding responses for errors of the particular newly added hardware device. Finally, the event managing handler  composes a table  with the predetermined events and corresponding responses for storage in the dynamically allocated database .","The API  may also have various routines to register newly identified hardware devices. For example, the API  may have a routine entitled \u201cEVENT_MGR_MUX_REGISTER\u201d that is utilized when a multiplexer (\u201cMUX\u201d) DSP is discovered. In one embodiment, the dynamically allocated database  is a dynamic error tracking and error responding database generated at runtime when a particular device is discovered. The EVENT_MGR_MUX_REGISTER routine may be utilized to register the dynamically allocated database  for the particular MUX DSP. In another embodiment, multiple copies of the dynamically allocated database  may be utilized for multiple devices, such as multiple MUXs or any other device. The API  may also have a routine entitled \u201cEVENT_MGR_QLP_REGISTER\u201d that is utilized when a QuantiLization Processor (\u201cQLP\u201d) DSP is discovered. The EVENT_MGR_QLP_REGISTER routine may be utilized to register the dynamically allocated database  for the particular QLP DSP. Further, the API  may also have a routine entitled \u201cEVENT_MGR_TPE_REGISTER\u201d that is utilized when a Transcoding Processing Element (\u201cTPE\u201d) is discovered. The EVENT_MGR_TPE_REGISTER routine may be utilized to register the dynamically allocated database  for the particular TPE DSP. In addition, the API  may also have a routine entitled \u201cEVENT_MGR_INP_REGISTER\u201d that is utilized when an input board is discovered. The EVENT_MGR_INP_REGISTER routine may be utilized to register the dynamically allocated database  for the particular input board DSP.","Further, the API  may provide routines that are potentially accessed for both the statically precompiled database  and the dynamically allocated database . For example, the API  may have a routine entitled \u201cEVENT_MGR_MSG_FOUND\u201d that may be utilized as the entry point for the error handling and responding. Each error is updated to its own database, e.g., the statically precompiled database  or the dynamically allocated database  for the corresponding device. The accumulated error counts are checked against a predefined threshold. Increased severity level is raised each time the predefined threshold is reached, and the corresponding device database is updated. When the error reaches an allowed severity level, a predefined message is generated and sent to all the devices that are listening. A corrective action may also be taken to prevent the system  from malfunctioning.","As an example, an interface for a first hardware device may be detected by the event managing handler  prior to runtime. Further, the event managing handler  determines that the first hardware device has a fixed configuration. Accordingly, the event managing handler  may construct a table  for the first hardware device by searching through the hardware interface database  and generating the statically precompiled database  with the table . Further, a registration is performed to link the hardware interfaced database  with the statically precompiled database . In another embodiment, the statically precompiled database  already exists, and the event managing handler  adds the table  to the existing statically precompiled database . At a time when an error for the first hardware device is encountered, the event managing handler  may retrieve the predetermined response for the predetermined event from the table. A module task in the system kernel  may call a routine from the API  that is provided to the module task by the event managing handler  to initiate the predetermined response for the predetermined event indicated in the table.","Further, an interface for a second hardware device may be detected by the event managing handler  during runtime. The event managing handler  detects a new interface for a hardware device during system power up. Accordingly, the event managing handler  may construct a table  for the second hardware device by searching through the hardware interface  and generating, during runtime, the dynamically allocated database . Further, a registration is performed to link the hardware interfaced database  with the dynamically allocated database . At a time when an error for the second hardware device is encountered, the event managing handler  may retrieve the predetermined response for the predetermined event from the table . A module task in the system kernel  may call a routine from the API  that is provided to the module task by the event managing handler  to initiate the predetermined response for the predetermined event indicated in the table.","In one embodiment, the errors detected by the system  may be posted to a task, e.g., a task entitled \u201ceventMgrTask.\u201d The error code from the faulty module is utilized by the eventMgrTask to update the database of the module, raise the severity, post the offending alarm to the corresponding hardware interface database, and communicate to the peer device if the module becomes non-operational.","Various data structures may be utilized to implement the databases and table discussed above. The following code is provided for illustrative purposes of code that may be utilized for the data structures and flow control:",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"EventDataTable"},{"entry":"typedef struct EVENT_DATA_TABLE"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003int","eventStatusId;"]},{"entry":["\u2003EventStatusConst","*pEventStatusConst;"]},{"entry":["\u2003EventErrorsConst","*pEventErrorsConstTable;"]},{"entry":["\u2003EventStatusData","*pEventStatusDataTable;"]},{"entry":"} EventDataTable;"},{"entry":"\u2002EventStatusConst"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct EVENT_STATUS_CONST"},{"entry":"{"},{"entry":"\u2003int \u2003eventErrorRepeatType;"},{"entry":"\u2003int \u2003trapEventId;"},{"entry":"\u2003int \u2003threshConst;"},{"entry":"\u2003int \u2003resetConst;"},{"entry":"\u2003int \u2003timerConst;"},{"entry":"\u2003char \u2009errorMsg[ERR_BUFFER_MAX];"},{"entry":"} EventStatusConst;"},{"entry":"EventErrorConst"},{"entry":"typedef struct EVENT_ERRORS_CONST"},{"entry":"{"},{"entry":"\u2003int \u2003errorId;"},{"entry":"\u2003int \u2003eventCtlType;"},{"entry":"\u2003int \u2003trapEventGenerationCtl;"},{"entry":"} EventErrorsConst;"},{"entry":"EventStatusData"},{"entry":"typedef struct EVENT_STATUS_DATA"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003int","eventStatusIsOn;"]},{"entry":["\u2003EventBitErrorDataList","*pEventBitErrorDataList;"]},{"entry":["\u2003EventErrorsData","*pEventErrorDataTable;"]},{"entry":["\u2003EventBitErrorMsgHandle","*pEventBitErrorMsgHandle;"]},{"entry":"} EventStatusData;"},{"entry":"EventBitErrorDataList"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef struct EVENT_BIT_ERROR_DATA_LIST"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003int","eventBitErrorBitId;"]},{"entry":["\u2003EventErrorsData","eventErrorsData;"]},{"entry":["\u2003struct","*pNextEventBitErrorData;"]},{"entry":"\u2003EVENT_BIT_ERROR_DATA_LIST"},{"entry":"} EventBitErrorDataList;"},{"entry":"EventErrorsData"},{"entry":"typedef struct EVENT_ERRORS_DATA"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003int","errorBitPatten;"]},{"entry":["\u2003int","accumCount;"]},{"entry":["\u2003int","resetCount;"]},{"entry":["\u2003int","timerCount;"]},{"entry":["\u2003int","currentMode;"]},{"entry":["\u2003struct timespec","registerTimeStamp;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} EventErrorsData;"},{"entry":"EventBitErrorMsgHandle"},{"entry":"typedef struct EVENT_BIT_ERRORS_MSG"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003char","errorBitMsg[80];"]},{"entry":["\u2003int","trapEventId;"]},{"entry":["\u2003int","trapEventGenerationCtl;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} EventBitErrorMsgHandle;"},{"entry":"Flow Control"},{"entry":"\u2003\u2003findEventStatusDataTable( )"},{"entry":"\u2003\u2003doEventHandle( )"},{"entry":"\u2003\u2003\u2003\u2003resetThresholdEvent( )"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003doResetThresholdEvent( )"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003mapEventModeToLogLevel"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003updateUnitStateAlarmStatus( )"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003updateIdentIfAlarmStatus( )"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003adjustDspErrorCode( )"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003executeLogMessage( )"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003requestTmxSpecificTrap( )"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003informRdnOfEvent( )"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003generateTmxSpecificTrap( )"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003doAlarmPanelReset( )"},{"entry":"\u2003\u2003\u2003\u2003setThresholdEvent( )"},{"entry":"\u2003\u2003\u2003\u2003aggregateEventBitErrorDataList( )"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003findDuplicate( )"},{"entry":"\u2003\u2003\u2003\u2003handleDynamicType( )"},{"entry":"\u2003\u2003\u2003\u2003doSetThresholdEvent( )"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003mapEventModeToLogLevel( )"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003updateUnitStateAlarmStatus"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003updateIdentIfAlarmStatus( )"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003adjustDspErrorCode( )"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003executeLogMessage( )"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003requestTmxSpecificTrap( )"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003informRdnOfEvent( )"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003generateTmxSpecificTrap( )"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003doAlarmPanelHandle( )"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 4","FIG. 2"],"b":["400","402","404","400","200"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 5","b":["500","502","500","504","500","506","500","508","500"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 6","b":["600","602","600","604","600","606","600","608","600"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 7","b":["700","700","700","710","720","740","730"]},"It should be understood that the device fault and event handling module  may be implemented as one or more physical devices that are coupled to the processor  through a communication channel. Alternatively, the device fault and event handling module  may be represented by one or more software applications (or even a combination of software and hardware, e.g., using application specific integrated circuits (ASIC)), where the software is loaded from a storage medium, (e.g., a magnetic or optical drive or diskette) and operated by the processor in the memory  of the computer. As such, the device fault and event handling module  (including associated data structures) of the present invention may be stored on a computer readable medium, e.g., RAM memory, magnetic or optical drive or diskette and the like.","It is understood that the simplified control for device fault and event handling described herein may also be applied in other types of systems. Those skilled in the art will appreciate that the various adaptations and modifications of the embodiments of this method and apparatus may be configured without departing from the scope and spirit of the present method and system. Therefore, it is to be understood that, within the scope of the appended claims, the present method and apparatus may be practiced other than as specifically described herein."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The above-mentioned features of the present disclosure will become more apparent with reference to the following description taken in conjunction with the accompanying drawings wherein like reference numerals denote like elements and in which:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
