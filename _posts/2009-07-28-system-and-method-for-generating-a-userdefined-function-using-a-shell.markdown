---
title: System and method for generating a user-defined function using a shell
abstract: A method is provided for generating a user-defined function (UDF) on a database engine of a database server. A user-function is sent to the database engine. The user-function includes a relational declaration with application and query logic. When the database engine receives the user-function, the database engine generates a function shell. The UDF processes the relational declaration of the user-defined function. The UDF includes the user-function and the function shell. The function shell returns a final data result of the user-defined function through the shell from the database engine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08112408&OS=08112408&RS=08112408
owner: Hewlett-Packard Development Company, L.P.
number: 08112408
owner_city: Houston
owner_country: US
publication_date: 20090728
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION","A Detailed Embodiment"],"p":["Databases are used to store and retrieve data. Data is retrieved through a data request called a query. The retrieved data can be selected, sorted, and organized based on the query. Sometimes the retrieved data has further computations or analytics applied beyond the query functions of the database language. Running these computations is often performed on a processor external to the database, such as a user, calling, or client device.","Running data-intensive analytic computations outside the database causes significant overhead in data access and transfer, which can be a major performance bottleneck in business intelligence applications. Pushing-down data-intensive analytics to the database layer for fast data access and reduced data transfer has some challenges. While a query processing engine is technically sophisticated, the query processing engine is primarily used for relational query evaluation. More general applications rely on User Defined Functions (UDFs). However, the existing UDF technology suffers from some limitations. First, tuple-wise pipelined UDF execution restricts the capability or efficiency in dealing with complex applications, and a tuple-set input is not supported. Second, the UDFs are coded in non-SQL language such as C, which either involves hard-to-follow Database Management System (DBMS) internal system calls for interacting with the query executor or sacrifices performance by converting DBMS defined relation objects to strings in passing arguments.","Existing database systems can only use scalar, aggregate and table input for UDFs, where a scalar or aggregate function cannot return a set. An existing database table UDF is limited to a single-tuple argument. Further, existing UDFs are typically executed during query execution in the tuple-wise pipeline of query processing, which may prohibit in-function batch and parallel processing.","An existing UDF is run in the query processing environment with a number of interactions with the query executor for parsing parameters, converting data, and switching memory contexts. Efficiently executed UDFs may be coded using DB engine internal data structures and system calls, but analytics users may have to deal with hard-to-follow system details. Coding efficiently executed UDFs may be too difficult and cumbersome for a database analytics user due to the complexity of the database system data structures and system development language. Converting existing UDF input data to strings from system internal formats can cause significant overhead in converting data and parsing parameters.","Alterations and further modifications of the inventive features illustrated herein, and additional applications of the principles of the inventions as illustrated herein, which would occur to one skilled in the relevant art and having possession of this disclosure, are to be considered within the scope of the invention. The same reference numerals in different drawings represent the same element.","Most conventional analytics platforms treat databases merely as a storage engine rather than a computation engine. As a result, the transfer of a massive amount of data between the storage platform and a computation platform can cause serious problems in performance and scalability. Relying on User Defined Functions (UDFs) to compute the analysis operations which are beyond the standard relational database operations, analytic computations may be pushed down to the database engine for faster data access and reduced data transfers.","Relation Valued Functions (RVFs) can be used to enhance the power of UDFs by removing hard-to-follow Database Management System (DBMS) internal data structures and system calls from user applications. A RVF can be schema aware user defined functions that contain relation inputs and relation output. In addition, RVFs make modeling complex applications using UDFs manageable where dataflow can be track through to a result.","The UDF technology extends both semantic terminology and system functionality. RVFs have UDF functionality tightly integrated with query processing but allow RVF developers to develop applications without having an understanding of DBMS internal system details. An RVF may contain two parts. First, an RVF shell can contain system utilities, and second, an RVF user-function can contain application logic without DBMS system calls. The term RVF shell, function shell, and shell may be used interchangeably.","RVF system support may be based on the notion of an invocation pattern, a mechanism for generating an RVF-shell automatically based on the schemas of the user-function's argument and return relations, and a data conversion protocol. RVF-shells may be generated based on invocation patterns. The header files for user-side relation object declarations may be automatically generated from the relation schemas of the invocation patterns. A set of pattern specific application programming interfaces (APIs) may be used by analytic users to write or create user-functions, which can be much simpler for analytic users to use and may use higher level application functions than the DBMS internal system calls of the query executor. A complete RVF-shell may be made by combining a user-function with application logic that is free of any DBMS internal data structures and system calls to form the RVF-shell. The generation of the RVF-shell may separate DBMS internal details from applications.","As illustrated in , a user of a calling device or user device  may send a user-function  to the database engine  on the database . The user-function may be a relational declaration with application logic that is free of any DBMS internal data structures and system calls. The database engine may generate a RVF shell when the database receives a user-function's relational declaration or relational query. The RVF shell may be any shell or interface operating on the database engine designed to be used with the user-function, where the shell has the functionality described herein. The RVF shell may process the user-function's relational declaration and return a result  to the user device after the user-function is processed by the database engine. The result may include a relational schema. The RVF shell may close after a last return of data of the result to the user device based on the user-function.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2","b":["130","110","210"]},"A user-function may be sent to a database engine on database server from an application on a user device  or any device or application that can make a request to a database server. The application may be a client application. The user-function may contain a relational declaration which includes a relational schema input. The relational schema may include relational operators, sub-queries, and references to database tables. The relational declarations may include a series of non-nested relational schemas or non-nested queries.","After the user-function  is received by the database engine , the database engine generates a shell  to execute the user-function. The database engine may be the underlying software component that a database management system (DBMS) uses to create, retrieve, update and delete data from a database.","The relational declaration of the user-function  may be converted into a tuple data structure  that is used internal to the DBMS. A tuple may be a sequence or ordered list of database elements (columns) of finite length. An n-tuple may be a tuple with n elements. Tuples can be written within parenthesis. For example, (2, 7, 4, 1, 7) is a 5-tuple. A tuple data structure may be an array or list of elements.","The shell or function shell may call a database system function or call  using the DBMS tuple data structure . The database system call can be run on a query executor . The query executor may produce an intermediate result  (in contrast to a final result  that can be returned to a user device) that may be returned to the shell for further processing. Each relationship of the relational schema of the user-function may be stored in memory or cached before any queries or system calls are processed by the query executor. The system calls or queries of the shell may run on a plurality of database engines, database processors, query executors, or query processors.","The RVF shell  may initialize the values of each parameter of the DBMS tuple data structure with start values. The shell may maintain cross-call data from sub-queries relations and database system calls of the user-function between each execution of the query executor.","In an embodiment as illustrated in , the RVF shell  may generate a query  from an argument in the user-function . The query executor may generate an intermediate result  after the query is sent to the query executor. The intermediate result may be presented in a data structure format utilized by and internal to the DBMS. The intermediate result may be returned to the RVF shell. The shell may convert the intermediate result into a simple relation-object mapping (SROM) structure . The SROM structure is a structure that can be processed and manipulated by the shell, but still maps to the underlying data of the intermediate result in the DBMS format used by the query executor. The SROM structure may be efficiently processed with a non-database programming language. The shell may perform intermediate processing  of the intermediate result, the relational declaration of the user function, and\/or the arguments of the user-function expanded by the shell.","The shell may evaluate the relational declaration for syntax errors prior to or during processing the relational declaration. During processing the relational declaration, the shell may allocate memory  and release memory in a memory module according to the life-span of each data element of the relation or query in the relational declaration.","In another configuration, a user-defined function may be sent to the database engine with a relational function declaration, where the relational function declaration has application and query logic, a data mapping scheme, and an invocation pattern. An invocation pattern can be an input mode included in a user-function that can create an input data structure within the shell and generate a predefined function sequence for the UDF. A UDF may include the combination of a user-function and a RVF or function shell. An invocation pattern can be a return or output mode included in a user-function that can create an return or output data structure within the shell and generate a predefined function sequence for the UDF. The receipt of the user-function by the database engine may generate a shell. With the generation of the shell, the shell may also generate header files for the UDF and construct a shell structure with instructions on the frequency of calling each argument, tuple, or query referenced in the user-defined function. For example, the frequency may be a call for a first call, normal or repeat call, or last call of the query instruction.","Processing the user-defined function may include retrieving query relations based on the invocation pattern. The processing may include converting an application and query logic data structure to DBMS tuple data structure, and converting DBMS tuple data structure resulting from a query executor to a data structure that can be manipulated by application and query logic or a programming language, such as C or C++. The shell may allocate and de-allocate memory in a memory module according to a life-span of the relation or query in the user-defined function. Life-span of the relation or query may be determined by a one call, multi-call, or per-call in the user-defined function.","Supporting Relation-Valued Functions (RVF) at a database language level (e.g. SQL) allows RVF \u201cpatterns\u201d to be explicitly declared for focused system support. An RVF pattern represents a specific mechanism for applying the RVF to its input relations. For example, passing in an input relation tuple by tuple or as a whole may represent different invocation patterns of invocation functions. Regulating RVF execution to well-defined patterns can ensure well-defined function behavior and system interface, which not only allows the system to optimally process the data flows involving RVFs, but makes providing high-level APIs for interacting with the DBMS possible.","In another embodiment, generating an RVF shell frees applications of making DBMS system internal calls. A shell may be embedded in a query executor, and an RVF invocation can interact with the query executor. During RVF invocation, the input relations can be checked for syntax errors and passed in to the RVF shell. Depending on the invocation pattern in processing one query, an RVF argument may be called once and return an entire tuple-set in the single call, or called multiple times, one for each returned tuple. Across multiple calls, the initial data used for every call and the carry-on data across calls, can be managed and maintained to reduce initialization of data.","The memory life span of RVF arguments and results can be managed for efficient memory use with RVF invocation. A RVF container may manage the interaction of the RVF shell with the query executor in terms DBMS internal system utilities. An RVF shell may contain DBMS system utilities. Generating the RVF-shell automatically allows the \u201cuser-function\u201d to be plugged in the shell, where the user-function can contain the application logic without DBMS internal system calls. RVF-shells can vary from invocation pattern to invocation pattern although they may have common components. An RVF shell may be independent of the application code of the user-function.","The RVF shell may use a Simple Relation Object Mapping (SROM) protocol to convert the relation objects (e.g. tuple-sets) in DBMS specific data structures into simple C-structs or C++ objects (or other similar structures in other programming languages) explicitly defined in the header files generated from relation schemas. The simple structures may be used by the user-function for calculations and manipulations inside the RVF shell. An RVF shell may be generated, together with the above header files, based on the invocation pattern and the schemas of the argument relation. The actual DBMS specific relation objects passed in from the query executor may be converted to arrays of C-structs defined in the header files. The RVF developer may provide the plugged in user-function which is free of DBMS internal data structures and system calls.","In another more detailed embodiment of the method and system of generating a UDF on a database engine of the database server over the limitations of the current UDF technology are illustrated. The method and system may provide formal support of relational input and outputs and may combine the easy-coding of UDF's user-functions with efficient UDF execution.","An RVF may be a type of a UDF. RVFs may be classified based on their \u201cinvocation patterns\u201d, which includes the mechanisms for dealing with input (e.g. passing in an input relation tuple by tuple, or as a whole) and return values (e.g. per-tuple return or set return). A well-defined invocation pattern with designated input-modes and return-modes can underlie the system interface and system support.","A function body, the code for system utilities, and the code for application logic may be interleaved in the RVF. A specific invocation pattern can make the steps of the system interaction deterministic, which makes it possible to single out the application logic from the system utilities and to abstract high-level APIs for interacting RVF execution with query processing.","A Simple Relation Object Mapping (SROM) protocol can be used to converting relation objects from their DBMS internal data structures into simplified ones to be manipulated by applications. SROM can be used to compose the User Defined Types (UDTs) from primitive types and collections provided by the DBMS. Using SROM, the data structure declarations in header files of the involved relation objects can be much simpler than the DBMS internal formats and can be generated from the corresponding relation schemas.","The RVF shell can distinguish the user's responsibility from the system's responsibility. RVF can be separated into at least two general parts: the RVF shell and the \u201cuser-function.\u201d First, the RVF-shell can contain the system utilities for running the RVF in the query processing environment, and second, the \u201cuser-function\u201d can contain application logic but without DBMS internal system calls. An RVF shell can be created by plugging a user function in its shell. System utilities can be developed to generate an RVF shell from its function declaration, data mapping scheme and the designated invocation pattern.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 4","b":["200","400","240","130"]},"The user-function with its RVF shell on a query executor may be implemented on the open-sourced database engine, like Postgres, or on a commercial and proprietary parallel database engine, like SQL. RVFs can be used to intelligently to alleviate the shortcomings of SQL which is cumbersome in expressing data flow logic. Separating the RVF shell from the user-function and generating the shell automatically improves the system intelligence by scaling the UDF applications for data-intensive analytics.","Extend Relation Operation with Relation Valued Function","Relation Valued Functions (RVFs) can be used on relation-input, relation-output and database schema-aware functions. RVFs can allow data intensive applications to be executed inside the database engine for fast data access and reduced data movement, and where the RVFs can be composed with relational operators to form integrated dataflow pipelines. RVFs can be coded in non-database and non-SQL languages, such as C. RVFs have the advantage of expressive power, execution efficiency, and seamless integration with relational operators in database queries.","Expressive Power","For example, the set of tuples in a relation may represent a set of objects. When an application involves the inter-relationship and global behavior of these objects, coding the application in a typical UDF with per-tuple input can be cumbersome and difficult. The difficulty can be illustrated by the Minimum Spanning Tree (MST) problem shown in . The MST problem involves finding a spanning tree in a connected, undirected graph with weighted edges that connects all the vertices together with a weight less than or equal to the weight of every other spanning tree. The MST problem exists widely in pipeline planning, network designing, and business optimization.","Kruskal's Algorithm provides an approach to deal with the MST problem. The Kruskal's Algorithm briefly summarized is as follows. Sort the edges of G in increasing order by weight. Then, keep a subgraph M of G, initially empty for each edge e in sorted order. If the endpoints of e are disconnected in M, add e to M, then return M as the resulting MST.","Stored in a database, the vertices  can be kept in one table  and the edges  in second table. A UDF for solving the MST problem has input data read from these two tables and an output relation  generated to represent the edges of the MST. RVF supporting relation input\/output overcomes the inability of a scalar UDF with tuplewise input for computing the MST.","Execution Efficiency","Tuple-wise computation by scalar UDFs can lead to performance penalties incurred from parameter setups of a large volume of calls and from repeatedly loading the data commonly used across calls. Analyzing the corner kick possibilities in a soccer game can illustrate the advantages of RVF over scalar UDFs.","In soccer games, a corner kick is awarded to the attacking team when the ball leaves the field of play by crossing the goal line without a score having been last touched by a defending player. A corner kick may result in a good scoring opportunity such as by a \u201cheader\u201d. The defending team may choose to form a wall of players in an attempt to force the ball to be played to an area which is more easily defended.","To analyze the strategies in taking and defending a corner statistically, a given collection of sample images of \u201ctypical\u201d corner kick scenes can be ranked by their popularity through comparing them with a large set of images on corner kicks.","From each corner kick image, the SIFT features can be extracted which consist of hundreds to thousands of key points, where each corner kick image may be a 128-dimensional vector. The comparison may be on the similarity of the whole image, allowing the comparison to leverage the order-less bag-of-features model to avoid the data intensive processing of pairwise point matching. The corner kick analysis process can work as follows: In an image the key points, or SIFT feature vectors can be extracted and clustered. A histogram of key points in clusters can be generated as the signature of the image, which is itself can be a vector, referred to as the composite feature vector of the image. Then, the closeness of two images can be determined by the similarities of their composite feature vectors using a dot product. The computation can involve a large table of corner kick images represented by CKImages [ID, feature] and a small table of sample corner kick images, CKSamples [ID, feature], with the same schema. An image may have several feature vectors that can be composed into a single long vector. A UDT (User Defined Type) can be defined for feature vector. A function sim can compute the similarity of two images based on the similarity of their composite feature vectors.","The query Q represents problems with per-tuple basis of current conventional queries. The SQL query Q can first derive the closest sample image of each corner kick image (by maximal similarity), then for each sample image s calculate the number of corner images taking s as the closest sample and ranks the sample images by that number.",{"@attributes":{"id":"p-0054","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["[Q1]","SELECT Sid, COUNT(Neighbor) AS n FROM"]},{"entry":[{},"\u2002(SELECT P.ID AS Neighbor, (SELECT S.ID FROM"]},{"entry":[{},"\u2002CKSamples S"]},{"entry":[{},"\u2003\u2009WHERE sim(P.feature, S.feature) = (SELECT"]},{"entry":[{},"\u2003\u2009MAX(sim(P2.feature, S2.feature))"]},{"entry":[{},"\u2003\u2009\u2009FROM CKSamples S2, CKImages P2 WHERE P2.ID =P.ID))"]},{"entry":[{},"\u2003\u2009\u2009AS Sid FROM CKImages P)"]},{"entry":[{},"GROUP BY Sid ORDER BY n;"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"For example p, the closest sample image of each corner-kick image, is computed by comparing p with all the sample images. Since the UDF, sim, is invoked on the per-tuple basis and unable to receive the whole CKSamples relation as input argument, then at least 2 efficiency problems can result. First, the CKSamples relation is not cached but retrieved for each CKImages instance p. And second, the CKSamples relation is also retrieved in a nested query for each (tuple) instance p of CKImages, for the MAX similarity between p and the sample images. Repeated relation retrieval can be a quantitative performance bottleneck. The kind of inefficient computation pattern illustrated in the example widely exists in database and SQL queries due to the lack of RVFs.","Composed with Relational Operators in Queries","The conventional scalar, aggregate and table UDFs are unable to express relational transformations and to be composed with other relational operators in a query since either their inputs or outputs are not relations. RVFs extend UDF technology for overcoming the scalar, aggregate and table UDF limitation. RVFs may allow UDFs with relation input and output. An RVF may have at least one input relation or tuple-set returned from a query. An RVF may be able generate a new relation as its output. With an input relation and output relation, the RVF may be viewed as a relational operator and a relation data source.","An RVF may be defined as illustrated in . The relation schemas R , R  and R  denote the \u201cschema\u201d of user-function f , the actual relation instances or query results compliant to those schemas can be bound to f as actual parameters. The BLOCK input mode  can mean the input relations are passed in at once. The SET return mode  can mean all the resulting tuples are returned at once. The RVF function f definition  may include a return relation R , scalar variables , and a procedure fn .","In another embodiment, a user may provide a declaration to a system. A shell generator may generate the RVF shell according to the declaration on the user device. The user may write the user-function using the RVF on a user device. The user may deploy or send the user-function and RVF shell together to the database server as UDF. The user may invoke the UDF by sending a database or SQL query to database server. The SQL query may include the invocation of the UDF. During execution of the SQL inside database engine, the UDF may be invocated. During the invocation of the UDF, the RVF shell may input and output the data based on invocation, definition, or declaration of the user-function.","RVFs can be composed with other relational operators or sub-queries in a database query. The relation arguments of an RVF can be expressed by queries represented by query Q and illustrated in . Q expresses dataflow pipelines of an application where Q , Q , Q , and Q  are queries in RVF functions rvf  and rvf .","[Q] SELECT*FROM rVf(Q, rvf(Q, Q, Q));","The RVF may have capability of receiving chunks of initial data in addition to stacking in data tuple by tuple, which can underlie efficient computation and open in-function parallel processing of using multi-cores or GPUs. The synergy of RVFs and other relational operators in queries extends the database and SQL framework for handling richer applications. RVF can be an extension at a database level or SQL level which is supported by extending the query processor, rather than using by ad-hoc user programs.","Invocation Pattern with Respect to Input Mode and Return Mode","In relational database engines, the argument of a relation operator of an RVF shell may be fed in tuple by tuple, or by a set of tuples. If an operator has any tuple-wise input, the operator may be called multiple times with respect to that input during execution. In a tuple-wise evaluated query, a parent operator may demand its child operator to return the \u201cnext\u201d tuple, and recursively the child operator demands its own child operator to return the \u201cnext\u201d tuple, recursively in a top-down demand driven and bottom-up dataflow fashion.","The relationship between RVFs and relational operators allows them to be invoked compositionally in a query and allows the notion of invocation pattern to be applied to RVFs. The input mode and return mode of an RVF may represent the specific mechanisms for applying the RVF to its input relations and to deliver the resulting relation.","PerTuple Input Mode can be a simple input mode. PerTuple can be defined such that applying PerTuple to RVF f with a single input relation R means f is to be invoked for every tuple in R or pipelined. In query Q illustrated in , RVF per_image_summery  may be applied to table CKSamples  and acts as the relation data source although per_image_summery is invoked under the PerTuple mode . The PerTuple input mode may be the only input mode under which the use of an RVF and a scalar UDF can be interchangeable.",{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Q3]","SELECT ID, Summary FROM"]},{"entry":[{},{},"\u2002per_image_summery_rvf"]},{"entry":[{},{},"\u2002(\u201cSELECT feature FROM CKSamples\u201d);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Under the Block Input Mode, as represented by query Q and illustrated in  for the corner-kick image ranking example, the RVF ck_rvf  may be called only once in processing a query with both relations, CKImages  and CKSamples , cached. The block input mode allows for \u201cin-RVF data parallel computation.\u201d When the input relation is sizable, block input invocation mode may cause the query to exceed the memory capacity of the database engine.",{"@attributes":{"id":"p-0067","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Q4]","SELECT r.sid, COUNT(r.neighbor) AS n FROM"]},{"entry":[{},{},"\u2002ck_rvf1 (\u201cSELECT * FROM CKImages\u201d,"]},{"entry":[{},{},"\u2002\u2009\u201cSELECT * FROM CKIsamples\u201d) r"]},{"entry":[{},{},"\u2003\u2003\u2003\u2002GROUP BY r.sid ORDER BY n;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"An input relation can be cached in a RVF as a whole when the relation is declared as static, which can be a default condition. An RVF may be treated as a block operation when the RVF's input relations are static.","Under PerTuple\/Block Input Mode, RVF f may be applied to 2 or more input relations where the first argument relation may be denoted by R, which can mean that f is to be invoked for every tuple in R(pipelined) and in combination with the whole tuple-sets of other relations. In the above corner-kick image ranking example, the query Q with RVF ch_rvf  under the PerTuple\/Block invocation mode may be executed image by image  on the CKImages table , but may cache in all sample images of the CKSamples  table as the initial data, as illustrated in .",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[Q5]","SELECT Sid, COUNT(Neighbor) AS n FROM ("]},{"entry":[{},{},"\u2002SELECT P.ID AS Neighbor, ck_rvf2 (P.ID, P.feature,"]},{"entry":[{},{},"\u2003\u2002\u201cSELECT * FROM CKIsamples\u201d) AS Sid"]},{"entry":[{},{},"\u2002FROM CKImages P)"]},{"entry":[{},{},"GROUP BY Sid ORDER BY n;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"An RVF under Tuple Return Mode or TUPLE_MODE may return one tuple-per-call in multiple calls when invoked in a query, typically once for each input tuple. An RVF under Set Return Mode or SET_MODE may return the entire resulting tuple-set in a single call. Batch modes can be a return mode format between the Tuple Return Mode and Set Return Mode. Confining RVF invocation to designated input and return mode may allow focused system support of RVF execution with efficient query processing. With well-defined RVF execution characteristics, a user-function with an RVF shell can provide high-level APIs to remove DBMS internal details from users, and generate system code automatically to ease RVF development.","RVF Shell Separate from User-Function","A characteristic of an RVF can be the application logic. The RVF may utilize system support to execute the RVF in the query processing environment. The RVF system and method may use a RVF shell and an user-function where the RVF shell handles the interaction with query processing in parameter passing, data conversion, initial data preparation, memory management. The user-function may contain application logic and may be \u201cplugged in\u201d the shell. The RVF shell may provide some query processing functionality.","The RVF shell may provide for multi-calls. Like other relational operators, a user-function executed in a query may be called multiple times, one for each returned tuple. As illustrated in , the initial data  used for every call and the carry-on data across calls, may be handled by the query executor through a function manager. A function may be coded with at least three cases: FIRST_CALL, NORMAL_CALL and LAST_CALL (also referred to as INIT_CALL, NEXT_CALL and FINAL_CALL). The FIRST_CALL may be executed only once in the first time the UDF is called in the hosting query which provides initial data. The NORMAL_CALL may be executed in each call including the first call, for doing the designated application. Multiple NORMAL_CALLs may be made if the UDF is called one tuple at a time, or a single NORMAL_CALL may be made if the UDF is called only once. LAST_CALL may be made after the last normal call for a cleanup purpose. The query executor may keep track the number of calls of the UDF during processing a query, and check the end-of-data condition for determining these cases.","The RVF shell may provide for memory context. Memory spaces allocated for function execution may have different life-spans. For example, the life-spans of RVF arguments or tuples may be per-query with one call, multi-calls, or per-call. When a function interacts with the query executor, switching memory context may be used.","The RVF shell may provide for argument passing. Each actual input argument may be instantiated. For example, if the argument is an expression then the argument may be evaluated. Dynamic arguments may be per-call evaluated at the function argument-evaluation phase. Static arguments may be instantiated or evaluated once in the FIRST_CALL. In RVF execution, when an argument represents a relation but is expressed by the user-function name or by a query statement, the corresponding static relation instance (not per-tuple input) may be retrieved in the FIRST_CALL once.","The RVF shell may provide for argument conversion. The basic data in query processing may be sets of tuples. The data may be represented in the query engine internal data structure for tuples and in the \u201cuser-function\u201d application code which may be different. Application code may use a data structure that is simpler than the query engine internal data structure. Conversion can be made between the two formats used.","The RVF shell may provide for a return mode. An RVF may return a relation or tuple-set. The RVF shell may use the return modes of TUPLE_MODE for returning one tuple-per-call in multiple calls, once for each input tuple, and SET_MODE for returning the entire tuple-set in a single call. With the TUPLE_MODE, multiple NORMAL_CALLs may each generates one output tuple. With the SET_MODE, a single NORMAL_CALL may generate the entire output relation. In SET_MODE, the resulting tuples may be kept in a tuple-store or memory before returning the result.","The RVF shell may have functionality in the RVF execution with the host query processing. When an RVF is defined, the information may include the function name, arguments, input mode, return mode, and dll entry-point, which may be registered into the FUNCTIONS meta-table and the FUNCTION_PARAMS meta-table. The FUNCTIONS meta-table and the FUNCTION_PARAMS meta-table may be retrieved by the RVF shell programs.","When the RVF is invoked, several handle data structures may be provided by sub-classing the corresponding data structures in query executor. Handle of RVF Execution (hFE) may track the information about input\/output relation argument schemas, input mode, return mode, and result set. The handle of RVF Invocation Context (hFIC) may be used to control the execution of the RVF across calls. hFIC may have a pointer to the hFE, and track the information on number of calls, end-of-data status, memory context (e.g. life span one or multi-calls), and include a pointer to user-provided context known as scratchpad  for retaining certain application data between calls. hFIC may have a pointer to hARG, a data structure that can be generated from RVF definition for keeping actual argument values across calls.","During function execution, the RVF container may use several system functions and macros to manipulate the hFIC structure and perform RVF execution. For example, the steps of RVF invocation for multi-calls may include the following:","In the first call, the RVF container may initialize the hFIC to persist across calls. The RVF container may evaluate each relation argument expressed by a relation name or a query in terms of launching a query evaluation sub-process where the argument query may be parsed, planned and executed. The RVF container may convert the complex DBMS internal tuple structures to an array of simple data structures to be passed into the \u201cuser-function.\u201d The RVF container may initiate other arguments and the scratchpad.","In a function call, the RVF container may set up for the hFIC and clearing any data left over from the previous pass. The RVF container may get non-static input argument values, and invoke user-function where the input and returned relations may be arrays of structures defined in the corresponding header files. DBMS internal call may not be made within the user-function body. The RVF container may convert the data generated by user-function back to DBMS internal data structures, and store them in the result-set pointed by hFE. If the return mode is TUPLE_MODE, the RVF container may return the first resulting tuple to the caller, or if the return mode is SET_MODE, the RVF container may return the entire result-set to the calling device. The RVF container may do clean up and end the RVF execution.","To ease the development of RVFs for analytics users, an RVF may be separated into at least two parts: RVF shell and user-function parts under specific input and return modes. Development of RVFs may be facilitated by providing high-level RVF Shell APIs for building the shell but the DBMS internal details can be hidden from RVF developers, and by generating RVF shells based on RVF specifications, input and return modes, and SROM. An analytics user may plug the \u201cuser-function\u201d into  the shell that may contain only application logic and may be free of DBMS internal data structures and calls.","Simple Relation-Object Mapping (SROM)","A functionality provided by RVF shells can be to convert DBMS internal data structures for relation objects into simplified data structures to be manipulated in \u201cuser-functions\u201d. Coding a conversion in terms of DBMS \u201csystem programs\u201d can demand the developer have familiarity with system internal details which may be beyond the expertise of the typical analytical users. RVF development can be facilitated for the typical analytical users by defining the mappings from a relation schema to the data structures of the corresponding tuple (as C-struct) and tuple-set (as array of such C-structs). A language specific simple relation-object mapping protocol (SROM) may be used to represent the data mapping. For example, the SROM for C may be used to generate C typedefs in a header file  based on the given relation schema and the correspondence between SQL types and C-types. User Defined Types (UDTs) with basic components may be used.","In the corner-kick image analysis example, the composite feature vector of an image may be represented by a FloatVector object. The SROM types may be declared as the following composite UDTs using Postgres.",{"@attributes":{"id":"p-0086","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CREATE TYPE FloatVectorType AS ("]},{"entry":[{},"\u2003mask BIT VARYING(100),"]},{"entry":[{},"\u2003floatVector float4 [ ]"]},{"entry":[{},"\u2003\u2003\u2003\u2003);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The CKImages and CKSamples may use the following types.",{"@attributes":{"id":"p-0088","num":"0087"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CREATE TABLE CKImages ("]},{"entry":[{},"\u2003ID INTEGER NOT NULL,"]},{"entry":[{},"\u2003feature FloatVectorType"]},{"entry":[{},");"]},{"entry":[{},"CREATE TABLE CKSamples ("]},{"entry":[{},"\u2003ID INTEGER NOT NULL,"]},{"entry":[{},"\u2003feature FloatVectorType"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Based on the relation declarations, the following header file may generated for the user-function.",{"@attributes":{"id":"p-0090","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[HF1]","typedef struct {"]},{"entry":[{},{},"\u2003\u2002byte * mask;"]},{"entry":[{},{},"\u2003\u2002float4 * vector;"]},{"entry":[{},{},"} FloatVectorType;"]},{"entry":[{},"[HF2]","typedef struct {"]},{"entry":[{},{},"\u2003int ID;"]},{"entry":[{},{},"\u2003FloatVectorType feature;"]},{"entry":[{},{},"} CKImage;"]},{"entry":[{},"[HF3]","typedef struct {"]},{"entry":[{},{},"\u2003int ID;"]},{"entry":[{},{},"\u2003FloatVectorType feature;"]},{"entry":[{},{},"} CKSample;"]},{"entry":[{},"[HF4]","typedef struct {"]},{"entry":[{},{},"\u2003CKImage * CKImageArray;"]},{"entry":[{},{},"\u2003int tuple_num;"]},{"entry":[{},{},"} CKImages;"]},{"entry":[{},"[HF5]","typedef struct {"]},{"entry":[{},{},"\u2003CKSample * CKSampleArray;"]},{"entry":[{},{},"\u2003int tuple_num;"]},{"entry":[{},{},"} CKSamples;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Based on these typedefs the user can provide functions allocCKImages(n) and deallocCKImages( ). The user-functions may be invoked in some API functions and passed in as pointers allowing separate generic APIs to be separated from application specific functions. The hARG data structure for holding the initial arguments of the RVF, like ck_rvf_args, may be generated.","RVF-Shell APIs","Based on RVF specifications, invocation patterns, and SROM, a set of high-level RVF shell APIs may be provided for building the shell. These APIs can hide or remove the DBMS internal details from RVF developers or typical analytics users. RVF ck_rvf used as an example in Q may be used to show the use of these APIs.","The RVF may be constructed with TUPLE_MODE return for the closest sample image of each given image. The user-function find_closest_sample( ) may not involve any DBMS system internal data structure and function. The user-function may take ID and feature of an image and the array of KCSamples as input and return a relation as output. The input\/output data of ck_rvf may be converted from\/to the query processing internal objects by the appropriate shell APIs. The APIs (upper-case with RVF_prefix) may be illustrated by the following pseudo RVF that may be specific to the already registered input and return mode. Exception handling and on-error early returns may be used. For simplicity in the example, all exception handling and on-error early returns are omitted. A FIRST_CALL may be a NORMAL_CALL.",{"@attributes":{"id":"p-0094","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SQLUDR_INT32 ck_rvf2(RVF_ARGS) {"]},{"entry":[{},"\u2002int rv; RVFCallContext *h; ck_rvf2_args *hARGS; CKSamples"]},{"entry":[{},"\u2002*samples;"]},{"entry":[{},"\u2002if (RVF_IS_FIRST_CALL( )) {"]},{"entry":[{},"\u2003\u2002h = RVF_FIRST_CALL_BEGIN( );"]},{"entry":[{},"\u2003\u2002RVF_ALLOC_ARGS(h->hARGS, &allocCk_rvf2_args);"]},{"entry":[{},"\u2003\u2002h->hARGS->Samples = (Samples *)"]},{"entry":[{},"\u2003\u2003\u2003\u2002RVF_GET_INPUT_RELATION(RVF_ARG(2),"]},{"entry":[{},"\u2003\u2003\u2003\u2002&allocSamples);"]},{"entry":[{},"\u2003\u2002RVF_FIRST_CALL_END(h);"]},{"entry":[{},"\u2002}"]},{"entry":[{},"\u2002if (RVF_IS_NORMAL_CALL( )) {"]},{"entry":[{},"\u2003\u2002h = RVF_NORMAL_CALL_BEGIN( );"]},{"entry":[{},"\u2003\u2002Samples *samples = h->hARG->Samples;"]},{"entry":[{},"\u2003\u2002int ID ="]},{"entry":[{},"\u2003\u2002(int) RVF_GET_INPUT_TUPLE_FIELD(RVF_ARGS(0));"]},{"entry":[{},"\u2003\u2002FloatVectorType *feature = (FloatVectorType *)"]},{"entry":[{},"\u2003\u2003\u2002RVF_GET_INPUT_TUPLE_FIELD(RVF_ARGS(1),"]},{"entry":[{},"\u2003\u2003\u2002&allocFeature( ));"]},{"entry":[{},"\u2003\u2002\/*user-function*\/"]},{"entry":[{},"\u2003\u2002int sid = find_closest_sample (ID, feature, samples);"]},{"entry":[{},"\u2003\u2002RVF_RETURN_NEXT(sid);"]},{"entry":[{},"\u2003\u2002RVF_NORMAL_CALL_END(h);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003if (RVF_IS_LAST_CALL( )) {"]},{"entry":[{},"\u2003\u2002RVF_FREE (samples, &deallocSamples);"]},{"entry":[{},"\u2003\u2002RVF_FREE (h->hARGS, &deallocCk_rvf2_args);"]},{"entry":[{},"\u2003\u2002RVF_FINALIZE(h);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003return rv;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"API RVF_GET_INPUT_RELATION( ) may retrieve the tuple-set of the specified relation or query result and populate the corresponding C-structure objects based on SROM. API RVF_RETURN_NEXT( ) may convert the result into the tuple format recognized by the query processor. API RVF_FREE may de-allocate memory using both the DBMS specific memory management utilities and memory management utilities provided for the data structures. The data structure memory management utilities may be used inside the user-function with the data structure passed in as a function pointer for keeping the generality of the API.","RVF-Shell Generation","RVF shell provisioning may be automated, e.g. the method and system may be generated from RVF specifications under the given input mode and return mode. Based on a well defined invocation pattern, the development of the \u201cuser-function\u201d that contains application logic can be separated from the generation of the RVF-shell, and tools can be used for generating the RVF-shell automatically.","An embodiment of RVF-shell generation mechanism is illustrated in , where the separation of the system responsibilities  from the user responsibilities  are shown, and the system responsibility for generating RVF shell  may be automated. Based on the RVF declaration  that can be stored in system meta tables, the system may generate  the header file containing the RVF argument data structure declarations to be used in the \u201cuser-function\u201d. The system may generate the RVF shell skeleton including FIRST_CALL, NORMAL_CALL, and LAST_CALL from the RVF declaration. The system with the RVF declaration may generate API calls for retrieving argument relations, converting data structures; switching memory contexts, and allocating and de-allocating memories.","The user may provide the user-function containing application logic only without DBMS internal system calls and data structures. The user may interact and manipulate other initial data accessible to the user-function using the scratchpad . A complete RVF may be created by plugging the user-function in the RVF-shell.","For example, the declaration of RVF ck_rvf which may be stored in meta-tables may be built with the following mechanisms: A header generation utility RVF_RO_META_GEN (\u201cck_rvf\u201d) which may be responsible for generating the header files HF-HF. A shell generation utility may be responsible for generating the RVF shell with RVF_SHELL_GEN (\u201cck_rvr\u201d). The FIRST_CALL, NORMAL_CALL, LAST_CALL in the generated RVF shell may provide the following functionalities in the execution of the RVF. In the FIRST_CALL, the shell generation utility may launch a system internal query to get the tuple-sets for CKSamples table in their DBMS-internal data structure. The shell generation utility may convert the results to the instance of C-structure CKSamples that contains an array of CKSample data structures as defined in the generated header file for passing in the user-function. In the NORMAL_CALL, the shell generation utility may make data conversion for the dynamic arguments and invoke the user-function. The shell generation utility may then convert the returned array of C-structures to DBMS-internal tuple-sets that may be accessible by the query executor. The shell generation utility may switch memory contexts according to the specified input and return mode (e.g. memory context for single query or for multi-calls). In the LAST_CALL, the shell generation utility may cleanup.","The RVF developer may code a function, illustrated in find_closest_sample:","find_closest_sample (ID, feature, samples);","The scratchpad  for holding other initial data (other than CKSamples) may be null, as in the corner-kick example, but the scratchpad may contain an extern pointer to user defined initial values, and the user may be able to add any other data to be carried-on across calls.","The complete RVF may be built by plugging  the user-function  into the shell . The pure application oriented user-function may be made independent of platform specific system calls. While a common set of invocation patterns may be provided, many applications can be easily pushed down to the DBMS layer as RVFs.","RVFs may be used to create set input and output for application modeling and generate efficiency of execution of UDFs by improving integration of UDFs with the query engine. RVFs allow the use of UDFs for complex applications. Efficiency in UDF execution is improved by tightly integrating the UDF with the query engine. The RVFs may remove the analytics users from the system internal details. The user-function with RVF shells makes the UDF technology practically usable in the syntheses of data intensive analytics computation and data management.","A UDF may contain system calls and system internal data structures, which may make the UDF hard to implement by users. A UDF may separate a shell from a user function where the shell handles system interactions and the user-function deals with application logic. A mechanism may generate the shell automatically based on the invocation pattern, and the entire UDF may be made by plugging-in the user-function to the shell. Building a UDF this way can focus the user's responsibility to the user-function without system details, such as internal database system calls.","Another embodiment provides a method  for generating a user-defined function (UDF) on a database engine of a database server, as shown in the flow chart in . The method includes the operation of sending a user-function to the database engine . The user-function may include a relational declaration with application and query logic. The operation of generating a function shell within the database engine when the database engine receives the user-function  follows.","The method further includes processing the relational declaration of the user-function using the UDF . The UDF includes the user-function and the function shell. The next operation of the method may be returning a final data result of the user-defined function through the function shell from the database engine .","The method and system for generating or executing a user-defined function (UDF) on a database engine of a database server may be implemented using a computer readable medium having executable code embodied on the medium. The computer readable program code may be configured to provide the functions described in the method. The computer readable medium may be a RAM, ROM, EPROM, floppy disc, flash drive, optical drive, magnetic hard drive, or other medium for storing electronic data. Additionally, the method and system for generating or executing a user-defined function (UDF) on a database engine of a database server may be downloaded as a computer program product transferred from a server or remote computer to a requesting or client device by way of machine readable data signals embodied in a carrier wave or other propagation medium.","While the forgoing examples are illustrative of the principles of the present invention in one or more particular applications, it will be apparent to those of ordinary skill in the art that numerous modifications in form, usage and details of implementation can be made without the exercise of inventive faculty, and without departing from the principles and concepts of the invention. Accordingly, it is not intended that the invention be limited, except as by the claims set forth below."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
