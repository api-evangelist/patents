---
title: Method of constructing causality network graphs and visual inference presentations for business rule applications
abstract: A method is described for collecting inference execution events from forward-chaining business rule engines and constructing causality network graphs for visual presentation to an end user. Using the causality network graph, the user may navigate logic paths leading to particular conclusions or actions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08510149&OS=08510149&RS=08510149
owner: ABB Research Ltd.
number: 08510149
owner_city: Zurich
owner_country: CH
publication_date: 20090527
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION","TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS"],"p":["This application claims the benefit of U.S. provisional patent application No. 61\/056,093 filed on May 27, 2008 and entitled Method of Constructing Causality Network Graphs and Visual Inference Presentations for Business Rule Applications, which is hereby incorporated by reference in its entirety.","The present invention relates to software programs for constructing causality networks graphs and building visual inference presentations for business rule applications.","For complex logic processing, commercial business rule engines provide many advantages over traditional procedural based programming languages. These advantages include externalization of business logic and rule transparency. However, for complex logic processing, the end-user often must determine how the final conclusions are made in order to be confident of the results. Most commercial business rule engines only support forward-chaining (FC) reasoning, which does not provide explanation capabilities that are naturally supported by backward-chaining rule engines. Explanation capability is an important capability for rule-based expert systems and helps users understand why a conclusion is made. A typical use case is when a system carries a conversation with an end user and the user can ask \u201cWhy\u201d and \u201cHow\u201d questions at any stage. \u201cWhy\u201d displays the rules under consideration and \u201chow\u201d searches the history tree and displays the rules and data leading to the current solution. The lack of easy-to-use explanation capability often hinders the acceptance of the rule based solutions.","Forward-chaining rule engines begin with existing facts and identify all rules with conditions that are satisfied. The engine then executes the consequence or action part of the rules which results in the modification, deletion, or creation of new facts. This in turn could cause more rules to be satisfied, and consequently trigger their execution. This process continues until no more rules are satisfied and the decision or result is reached. Often, when multiple rules are involved in multi-step reasoning, the chain of cause and effect relationships is not obvious from the conclusion alone.","Inference back-track capability is not provided in mainstream business rule engine products because of the difficulty of performing such a function with forward-chaining rule engines. This is due to the fact that forward chaining rule engines are data driven, which means forward chaining starts with the available data and uses inference rules to generate more data until an optimal goal is reached. An inference engine using forward chaining searches the rules until it finds one where the antecedent (If clause) is known to be true. When found, it concludes the consequent (Then clause), resulting in the addition of new information to its data. In contrast, backward chaining starts with a list of goals (or a hypothesis) and works backwards from the consequent to the antecedent to see if there is data available that will support any of these consequents. An inference engine using backward chaining would search the rules until it finds one which has a consequent (Then clause) that matches a desired goal. If the antecedent (If clause) of that rule is not known to be true when evaluated against available data, then it is added to the list of goals. This process is often called goal seeking. As a result, backward chaining rule engines provide a natural way to explain why and how a conclusion is made, whereas it is not easy to do so in forward chaining rule engines.","Thus, there is a need in the art for a method of analyzing business rule engines and providing visual presentations showing facts, rules and reasoning paths leading to a conclusion.","In accordance with one aspect of the present invention, a method is provided for analyzing the conclusions of a business rule engine wherein execution of the business rule engine includes rule execution events and object modification events. The method includes capturing the rule execution events and the object modification events. A unique global sequence identifier is assigned to each rule execution event and object modification event. An if collection and a then collection is built for each captured rule execution event. Attribute information is collected for each captured object modification event. A rule backward link is created from each rule execution event, to each object modification event in the if collection of the rule execution event. An object backward link is created from each object modification event to the rule execution event that created the object modification event. The rule execution events, object modification events, rule backward links and object backward links are then visually displayed.","In accordance with another aspect of the present invention, a computer readable medium is provided containing computer executable instructions which, when executed by a computer, perform a method for analyzing the conclusions of a business rule engine wherein execution of the business rule engine includes rule execution events and object modification events. The method includes capturing the rule execution events and the object modification events. A unique global sequence identifier is assigned to each rule execution event and object modification event. An if collection and a then collection is built for each captured rule execution event. Attribute information is collected for each captured object modification event. A rule backward link is created from each rule execution event, to each object modification event in the if collection of the rule execution event. An object backward link is created from each object modification event to the rule execution event that created the object modification event. The rule execution events, object modification events, rule backward links and object backward links are then visually displayed.","It should be noted that in the detailed description that follows, identical components have the same reference numerals, regardless of whether they are shown in different embodiments of the present invention. It should also be noted that in order to clearly and concisely disclose the present invention, the drawings may not necessarily be to scale and certain features of the invention may be shown in somewhat schematic form.","The present invention is a method of collecting inference execution events from forward-chaining business rule engines. Thereafter, a causality network graph is constructed and presented visually to an end user. Using the network graph, the user may navigate logic paths leading to particular conclusions or actions. The present invention allows a user to perform an inference back-trace (also referred to as a logic back-trace), which refers to the capability to back-track through the reasoning paths that lead to given conclusion or action. By tracing and displaying the reasoning in an easily understood manner, a user may inspect the inference logic for debugging, auditing and validation purposes.","The present invention uses the rule engine application programming interface (API) to capture modification of facts in the working memory and rule engine execution events. Event messages of each rule execution are captured, as well as any modification of the facts, using the same API. This may be done automatically during rule executions so that when the executions are over, the data is acquired and ready to be analyzed. The captured data is analyzed to determine the logical dependence between the rule execution instances and the states of the objects. The resulting causality network graph can be presented visually and provides interactive capability to the user.","For purposes of the present disclosure, the following terms are defined as follows. A \u201crule\u201d is an IF-THEN statement defined by an end user, which represents the inference logic to be applied by the rule engine. A rule may reference one or more objects in the IF or THEN clauses. An \u201cobject\u201d is the software representation of a real world object, such as a customer. An object consists of on or more \u201cattributes\u201d (i.e. qualities or features, such as, for example, a name) and\/or related behavior (e.g., get the name of this customer). A \u201cfact\u201d is an instantiated object that contains specific data about that object at a given time or event. A fact represents a particular state of an object. An \u201cevent\u201d represents either a rule firing instance (i.e., rule engine execution instance) or a fact insertion, modification, deletion. An event is represented as a circle node or a square node in the visual graph produced by the graphical user interface (GUI). A \u201cnode\u201d is either a rule execution event node (often called rule node, represented as squares) or a fact insertion\/modification event node (often called fact node, represented as circles). An object can be modified several times and have different states during rule executions. Thus, the same object can have multiple fact nodes in the visual graph, each one representing a fact insertion or modification event. Likewise, a rule might be fired multiple times during rule executions. As a result, the same rule can have several rule nodes in the visual graph, each one representing a rule firing event. A \u201cconclusion\u201d is an event after the rule engine starts to evaluate rules. It can be any node in the visual graph that is not an initial fact.","The graphical user interface (GUI) of the present invention visually presents rule engine execution instances, initial facts, intermediate conclusions, and the final conclusions. A user may select a conclusion from a list of conclusions or directly from the visual display. Once selected, the back-tracing display shows all the rules and facts that contributed to a selected conclusion. A user may navigate the back trace paths graphically, and select each rule execution instance or intermediate fact for more detailed information.","With reference now to , an illustrative causality network graph is shown. As discussed above, each node represents an event. The circle shaped nodes represent fact events. As discussed above a fact is an instantiated object, thus a fact may represent the instantiated initial object or an updated object. An example of a fact event may be changing the status of a breaker from open to closed, or changing the membership level of a customer from standard to VIP. Rectangle shaped nodes represent rule execution events. Fact nodes - represent the insertion of a fact into working memory (i.e. initial facts). Fact nodes , , , , , , , , , ,  and  represent the updating of an existing fact in the working memory. As can be seen, each node includes a unique number, which represents the time sequence of rule execution events. For example, node  represents an event in which a fact is inserted. This event occurs after node , which also represents a fact insertion event.","The arrows or links from the circle shaped nodes to the rectangle shaped nodes indicate that the objects represented in the circle nodes are involved in the activation of the rule. For example, in , arrows extend from nodes  and  to node  indicating that the two objects represented by nodes  and  are used to evaluate the rule that is processed in node . The arrows from the rectangular shaped nodes to the circle shaped nodes represent one or more objects that are modified in the rule represented in the rectangle nodes, thereby creating new facts. For example, the arrow from rectangular shaped node  to circle shaped node  represents an object that is updated in the rule executing event .","As shown in , in one embodiment the initial fact states are indicated in a vertically extending column at a left hand side of the display. These represent the facts prior to execution of any rules. Different states of the same object are shown in the same horizontally extending row. Thus, for example, circle shaped nodes ,  and  are in the same horizontally extending row and are therefore three different states of the same object.","Detailed information about each node is available by moving a mouse pointer over that node, or otherwise highlighting or selecting a particular node. For example, node  is rectangular and thus represents a rule execution event. When selected, as shown in , a text box is displayed below indicating that the rule name is CapacityConstraints, one object is involved named GeneratorOperation object, and its attributes are shown as name=XYZ, energy(2)=40, Reserve(2)=79, etc. Further, the darkened arrows indicate all nodes that contributed to the rule execution event of node . In this manner, a user may quickly review the rule being executed as well as the factors preceding the execution of the rule.","With reference now to , a flowchart is provided describing the method of the present invention. At a first step , the rule engine is executed and all execution events are captured. At step , a causality network graph is constructed from the captured execution events. At step  the causality network graph is presented visually to a user. At step  a node is selected by the user for logic tracing. As discussed above, the selection may be made by, for example, moving a mouse cursor over a node. At step , back-tracing is performed in a manner to be described below. At step  the causality network graph is updated with visual signifiers that indicate the relationship between a selected node and the contributing nodes. Any approach may be used to provide visual signifiers to a user. For example, as shown in , the back-tracing links are darkened in comparison to the remaining links. In other embodiments, different colors may be use, different line weight or blinking lines may be used. At step  a user may select a new fact to back-trace, or may end the use of the causality network graph.","With reference now to , it is shown how rule execution events are captured. In a first step , a rule instance execution is acquired. At step , a global sequence index is assigned to the event. The global sequence index is a globally unique number assigned to each event and serves two purposes. First, an event may be looked up and identified by index number, and second, the index number establishes a temporal order among the events. At step , an input object collection is built for that rule execution instance. The input object collection includes all objects reference in the \u201cIF\u201d clause of a rule execution instance. At step  an output object collection is build for that rule instance execution. The output object collection includes all objects referenced in the \u201cTHEN\u201d clause of the rule instance execution. The input and output object collections for that rule execution instance are then written to a logging store at step . Each rule execution instance is processed in this manner until the rule engine completes its run.","The other major event when running a business rule engine is the modification of an object. With reference now to , it is shown how the object change events are captured. In a first step , a object change event is acquired. At step , a global sequence index number is assigned to the event. At step , attribute information is collected along with the reference to the rule instance that leads to the object change events. The attribute information and rule instance reference for that object change event are then written to a logging store at step . Each object change event is processed in this manner until the rule engine completes its run.","When the business rule engine completes its run and all the object change and rule execution events are acquired, the causality network graph may be generated. To generate the graph, event relationships must first be determined. With reference now to , it is shown how the nodal relative relationships are determined. At step , a global sequence index and identifier is selected (typically beginning at index value 1) and it is determined at step  whether the corresponding node\/event has already been resolved. For purposes of the present disclosure, resolved or resolution references the identification of the logical dependence of a node. Thus, resolution of a rule firing event node, means that all the fact nodes referenced in the IF and THEN clauses have been identified. For nodes corresponding to initial objects, resolution is trivial, as they do not depend on any other objects or rule executions. Intermediate and final nodes are resolved by capturing the rule execution events, and correlating them with known nodes. The dependence of a node \u201cx\u201d on another node \u201cy\u201d may be represented by an ordered pair (x,y) and are shown graphically by an arrow or link directed from \u201cx\u201d to \u201cy\u201d.","If at 252 it is determined that the node has not yet been resolved, at 254 it is determined whether the node is a rule execution node or a fact node. If the node is a rule execution node, at 256 a variable CURRENT FACT is set to the first fact from the IF collection correlating to that node.","At step  the global sequence index number of the CURRENT FACT is retrieved. At step  the fact node matching the global sequence index is located. At step , the rule node's backward link is updated to include the fact node identified in step . At step  the fact node identified at step  is resolved. Because the process ordinarily begins at the first global sequence index value and proceeds chronologically, this test should always pass (i.e. the fact node should already be resolved) and is primarily an error checking mechanism. At  it is determined whether all fact nodes from the IF collection of the current rule execution node have been resolved. If not, at  the CURRENT FACT is set to the next fact in the IF collection and the loop returns to step . If all facts in the IF collection are resolved, the rule node is resolved, and the process moves to the next node in the global sequence index.","If, at step  it is determined that the node is a fact node, at  a search is performed for the rule execution node that modified the fact node. This search is straightforward because the information is already collected during the event collection stage as shown at step  in . If a rule modified the fact node, at  the fact node's backward link to the rule execution node is updated. At step  the rule node identified at step  is resolved. As discussed above, because the process ordinarily begins at the first global sequence index value and proceeds chronologically, this test should always pass (i.e. the rule node should already be resolved) and is primarily an error checking mechanism. Thereafter, the process continues to the next node in the global sequence index. The process continues until all nodes in the global sequence index are resolved. In this manner, the causal relationship between all fact and rule nodes is determined and a causality network graph may be created. These relationships may then be visually displayed to a user as arrows or links between the various nodes. Thereafter, a user may select any node on the causality network graph, and the back-tracing will be highlighted for a user to review.","When an end user selects a node in the visual graph as shown in step  in , the algorithms described in  and  iteratively determine the event history of the selected node and highlights that history. If the selected node is fact node, the algorithm of  is used to find the event history. If the selected node is a rule execution node, the algorithm of  is used to find the event history.","With reference now to , the process is shown for determining whether a rule execution node modified a given fact. At a step , search index \u201cs\u201d is set to the fact node's global index value. Next, the search index is reduced by one at . At  it is determined whether the search index \u201cs\u201d is valid. If the search index \u201cs\u201d is not valid (i.e. no node exists having that index value), the process returns to step . If the search index \u201cs\u201d is valid, the node is retrieved at . At  it is determined whether the node is a fact node or a rule node. If a fact node is recognized, the process returns to step . If a rule node is recognized, the process proceeds to step  wherein it is determined whether the \u201cthen\u201d collection of the rule node includes the fact. If the \u201cthen\u201d collection does not contain the fact, the process returns to step . If the \u201cthen\u201d collection does contain the fact, the rule execution node is found and the path from this node to the fact node is highlighted visually to the user at . The search is then continued from this newly found rule firing node using the process shown in . This process continues until global sequence index reaches the first index value.","With reference now to , the process is shown for determining whether a fact is used for a given rule execution node. At a step , search index \u201cs\u201d is set to the rule node's global index value. Next, the search index is reduced by one at . At  it is determined whether the search index \u201cs\u201d is valid. If the search index \u201cs\u201d is not valid (i.e. no node exists having that index value), the process returns to step . If the search index \u201cs\u201d is valid, the node is retrieved at . At  it is determined whether the node is a fact node or a rule node. If a rule node is recognized, the process returns to step . If a fact node is recognized, the process proceeds to step  wherein it is determined whether the \u201cif\u201d collection of the rule node includes the fact. If the \u201cif\u201d collection does not contain the fact, the process returns to step . If the \u201cif\u201d collection does contain the fact, the fact is part of the condition that triggers this rule to be executed. Thus, the path from the fact node to the rule firing event node is highlighted visually to the user at . The process then returns to step  to locate any other fact nodes in the \u201cif\u201d collection. After all fact nodes involved in the rule firing event are located, the search is then continued from the newly found fact node(s) using the process shown in . This process continues until global sequence index reaches the first index.","As a first example, a scenario is provided having only two rules. In this example, a retail store provides customers different discount rates based on the membership level, purchase history, status (e.g., students, seniors, and veterans), etc. The following rules are defined for Store ABC to offer discount rate for customers:","Rule 1: If a silver level customer has a year-to-date total purchase equal to or greater than $5000, promote the customer to gold level.","Rule 2: For gold level customers with a current purchase equal to or greater than $2000, apply 25% discount to the current purchase.","The following attributes (YTD purchase total, membership level) are provided for John (an object). The collection of attributes associated with John is a fact:\n\n","The following attributes are provided for a transaction (an object):\n\n","Once the business rule engine completes its run and the relevant data is collected in the manner described above, a causality network graph may be created according to process shown in . Each event is shown as a node in the graph. As shown in , the first event is shown as node one and because it is an inserted object, it is already resolved. Likewise, in , the second event is shown as node two and because it is an inserted object, it is already resolved. Turning to , the third event is shown as node three. According to the logic tracing process shown in , it is determined that the node is not resolved, the node is a rule node and therefore the CURRENT FACT is set to John (YTD purchase total=3200, membership level=silver). The identifier of the CURRENT FACT is retrieved (node one) and the fact node matching the identifier is found. Next, the rule node's backward link is updated to link to the fact node (node one). This is shown visually as an arrow directed from node three to node one. Next, the fact node is resolved (already resolved as discussed above). Finally, a check is performed to determine whether all fact nodes are resolved for this rule node (all fact nodes are resolved). As can be seen, the causality network graph now has three nodes and one link.","As shown in , the fourth event is shown as node four in the graph. According to the process shown in , because the node is a fact node, a search is performed for the rule node that modified the fact node. Rule one, node three modified the fact node. The backward link to node  is updated and is shown visually as an arrow directed from node four to node three. Next the rule node is resolved (already resolved). As can seen, the causality network graph now has four nodes and two links.","Referring now to , the fifth event is shown as node five in the causality network graph. Because the node is a rule execution node, According to the logic tracing process shown in , it is determined that the node is not resolved, the node is a rule node and therefore the CURRENT FACT is set to John (YTD purchase total=5300, membership level=gold). The identifier of the CURRENT FACT is retrieved (node four) and the fact node matching the identifier is found. Next, the rule node's backward link is updated to link to the fact node (node four). This is shown visually as an arrow directed from node five to node four. Next, the fact node is resolved (already resolved as discussed above). Finally, a check is performed to determine whether all fact nodes are resolved for this rule node. In this case, a second fact is stored in the \u201cif\u201d collection. The CURRENT FACT is thus set to Transaction (Amount=2100, discount rate=0). The identifier of the current fact is retrieved (node two) and the fact node matching the identifier is found. Next the rule node's backward link is updated to link to the fact node (node two). This is shown visually as an arrow directed from node five to node two. Next the fact node is resolved (already resolved as discussed above). Finally, a check is again performed to determine whether all fact nodes in the \u201cif\u201d collection are resolved for this rule (all fact nodes are resolved). The causality network graph now has five nodes and four links.","As shown in , the sixth event is shown as node six in the graph. According to the process shown in , because the node is a fact node, a search is performed for the rule node that modified the fact node. Rule two, node five modified the fact node. The backward link to node five is updated and is shown visually as an arrow directed from node six to node five. Next the rule node is resolved (already resolved). As can seen, the causality network graph now has six nodes and five links.","In this manner, the causality network graph is formed. If a user selects a node in the graph, all the links that lead to this event are visually highlighted according to the links formed in the process discussed above.","The above example has relatively few events, and is shown primarily to provide a simplified example. The benefits of the present invention are most apparent when a rule engine includes many more objects, and many more rules. In such instances it virtually impossible for a user back-trace manually.  show exemplary rules and data sets that a power system business rule engine might use. In particular, the rules\/data are for a generator capacity constraint validation problem in a business management system. Each generator must run within its capacity at any given time. The capacity of a generator at a given timestamp is a function of several parameters, such as the base capacity, base ramp rate, maximum capacity, maximum ramp rate, capacity at a previous timestamp, and current ramp rate.","After the rule engine runs and the causality network graph is generated, the resulting visual display shown in  is provided to a user. If a user wishes to know more about node , the user may point and click node . As is shown in , the paths that lead to node  are highlighted and the current value of objects in node  are shown in a text box. This interface enables quick and easy validation and error analysis.","As will be appreciated by one of ordinary skill in the art, the present invention may be embodied as or take the form of the method and system previously described, as well as of a computer readable medium having computer-readable instructions stored thereon which, when executed by a processor, carry out the operations of the present inventions as previously described and defined in the corresponding appended claims. The computer-readable medium may be any medium that can contain, store, communicate, propagate, or transport the computer-readable instructions for use by or in connection with the instruction execution system, apparatus, or device and may by way of example but without limitation, be an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, device, or propagation medium or other suitable medium upon which the program is printed. More specific examples (a non-exhaustive list) of the computer-readable medium would include: a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a transmission media such as those supporting the Internet or an intranet, or a magnetic storage device. Computer program code or instructions for carrying out operations of the present invention may be written in any suitable programming language provided it allows achieving the previously described technical results.","It is to be understood that the description of the foregoing exemplary embodiment(s) is (are) intended to be only illustrative, rather than exhaustive, of the present invention. Those of ordinary skill will be able to make certain additions, deletions, and\/or modifications to the embodiment(s) of the disclosed subject matter without departing from the spirit of the invention or its scope, as defined by the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The features, aspects, and advantages of the present invention will become better understood with regard to the following description, appended claims, and accompanying drawings where:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 17"}]},"DETDESC":[{},{}]}
