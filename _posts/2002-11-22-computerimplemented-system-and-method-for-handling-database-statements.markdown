---
title: Computer-implemented system and method for handling database statements
abstract: A computer-implemented system and method for handling a database statement from a first database system. The database statement is formatted according to a language format used by the first database system. Database language difference data is accessed so that a database specific statement may be generated which is operational within a different type of database system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07447686&OS=07447686&RS=07447686
owner: SAS Institute Inc.
number: 07447686
owner_city: Cary
owner_country: US
publication_date: 20021122
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present invention relates generally to computer-implemented database systems and more particularly to database statement operations.","Data access across different database platforms proves difficult due to the platforms using varying database commands. For example, although the structured query language (SQL) is based on a well-documented ANSI standard, in reality most database systems, such as those from Oracle, Sybase, Business Objects, SAS, or Brio, implement a superset of the ANSI standard. Variations in the superset provide an obstacle in cross-platform database operations.","In accordance with the teachings provided herein, a system and method are provided for handling a database statement from a first database system. The database statement is formatted according to a language format used by the first database system. Database language difference data is accessed so that a database specific statement may be generated which is operational within a different type of database system.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["30","32","32","40","42","44","46"]},"Within the system , a textualization process  addresses the complexity of translating a native database statement  dialect into a variety of third party database dialects (, , ) by allowing the common parts of the default syntax of functionality to be shared between a native database and a third party database. The textualization process  utilizes database specific textualizations  to translate the common parts to the third party database dialect.","For example, if a native database system  uses an outer join syntax to be specified in an SQL query statement  that is different from what a third party database system  uses, then the textualization process  creates based upon the specific textualizations  a processed SQL command  for the third party database system  that employs the third party's outer join syntax. The processed SQL command  is then able to be executed within the third party database system . As another example, a native database system  and a third party database system  may both support a function that performs an identical operation but differs in name and\/or format. Using the specific textualizations , the textualization process  translates the SQL statement  having the function in the native format into an SQL statement  having the function in the third party's format. It should be understood that the terms \u201cnative\u201d and \u201cthird party\u201d are relative terms in that what is a native database system for one company may be a third party database system for another company. Accordingly, the terms \u201cnative\u201d and \u201cthird party\u201d database systems may be generalized to a first type of database system that generates a database statement that is processed by the textualization process  and provided to a different type of database system. It should be further understood that different types of databases refer to database systems that contain differences in their respective database statement format and\/or syntax, such as utilizing a different superset of an ANSI database statement standard.","The textualization system  is highly flexible in that a third party database system  may utilize the textualization process  to convert and send database commands to the native database system . It is also noted that a native database system  may send database statements  to other third party database systems ( and ). The textualization system  contains textualization information and\/or operations  that are specific to each of the third party database systems (, , ). The textualization system  has the flexibility of providing an SQL statement  from the native database system  to a single third party database system , or may provide the same native SQL statement  to multiple third party database systems (, , ) substantially concurrently or serially.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2","b":["60","50","32","60","32","60","32","60"]},"The textualization process  compartmentalizes an SQL statement  into logical text pieces or components which are initially provided based on a default SQL dialect. The logical text pieces are represented in the SQL tree . Any of these text pieces can be overridden by a third party SQL provider that utilizes a different SQL dialect than the default, hence allowing for granular customization and code reuse. As an illustration, a database system from SAS Institute Inc. has an SQL language which has differences from other vendor's SQL. The textualization process  allows a SAS SQL statement to be converted into a third party vendor-specific SQL in order to successfully submit a table request to the third party's relational database system (RDBMS). This is accomplished by representing the SAS SQL statement as an SQL tree . The SQL tree  is passed to the textualization process  to convert the tree  into the text of the third party vendor-specific SQL query, taking into account any DBMS-specific SQL. The textualization operation happens in this example just prior to the call to a prepare( ) or executeDirect( ) routine. These standardized routines then pass the SQL query to an RDBMS in the form of text. It is noted that in an SQL-centric table services model, an SQL query typically gets passed to either the prepare( ) or executeDirect( ) routines (depending on context). A call to either of these routines, therefore, constitutes a request to an RDBMS.","An application or program that operates within a native database system may wish to access data in a remote third party database system under such situations as when the application is a data mining application that needs data from the third party system for operations to be performed within the data mining application. Other application examples include requests for metadata that are stored in a different type of database system. It should be understood that any system that uses SQL or a similar type of database technique may utilize the textualization system.","The textualization system may be implemented in many ways and through different types of programming languages.  illustrates an object-oriented approach  to creating disparate SQL text for third party data access. The object-oriented approach  contains SQL component objects  where each component corresponds to a logical \u201cpiece\u201d  of an SQL statement (as may be found in an SQL tree). An SQL component defaults to a provided base or default native SQL text method . However, when there are third party-specific differences for a particular component, then the component utilizes the third party specific textualization method(s)  to handle the differences.","As shown in , when there are third party-specific differences for a particular component, a driver object  is responsible for creating an \u201coverride\u201d  to the default method . The driver object  specifies to a component object  when a component object  is to point to specific textualization method  instead of its base textualization methods. Optionally, only the driver  knows about its datasource-specific SQL syntax .","In order to textualize for multiple different types of database systems, different drivers (, ) are associated with different third party platforms. For example, a first driver object  might point a component object  to use an \u201coverride\u201d  to the default method  so that the component object  may textualize an SQL statement that can be used within a Sybase datasource system. A second driver object  might point the component object  to use an \u201coverride\u201d  to the default method  so that the component object  may textualize an SQL statement that can be used within an Oracle datasource system.","The net effect of this object-oriented mechanism  is a driver-customized set of components where the driver need only supply an override method when a specific SQL construct differs from the default SAS SQL syntax. This design maximizes code reusability while pushing any DBMS-specific SQL text processing down to the driver, thereby distributing functionality more equitably.","With reference to , components may be assigned to handle different pieces of the native SQL statement. The different components may be: phrase components ; identifier components ; and expression components . Phrase components  handle textualization of SQL statement clauses or phrases, such as WHERE clauses or FROM clauses found in SQL select statements. To understand phrase components , the following exemplary SQL query statement is dissected:","select a.empid, b.sal from emp a, hr b where b.hdat >\u201801jan1998\u2019d order by b.sal;","At the highest level we can think of this query as a group of ordered phrases (, , , ) as shown in . Phrase  of the query is a SELECT phrase; phrase  is a FROM phrase; phrase  is a WHERE phrase; and phrase  is an ORDER BY phrase. These phrases (, , , ) provide the high-level context for the query. Each phrase is represented and processed by a component object (, , , ) whose default text method can be overridden by a driver at this \u201chigh level\u201d. The phrase components (, , , ) textualize large pieces of a query that correspond to high-level SQL operations, e.g., FROM clauses, WHERE clauses, ORDER BY clauses, etc.","Typically, a driver would not have to override phrase component methods because the general syntactical layout of phrases tends to be relatively standard across RDBMSs. However, exceptions may exist, such as those involving RDBMSs that support non-standard outer joins. In addition, some ERP (enterprise resource planning) systems may have the need for phrase overrides since their \u201cSQL\u201d tends to be proprietary and very non-standard.","Identifier components are next discussed in reference to  using the query example above. We can further break down the phrases as collections of low-level \u201cphysical\u201d entities. These low-level \u201centities\u201d can be thought of as identifiers because they represent a real physical entity in an SQL query. Fully qualified table names, column names, literals, and aliases fall into this category of components. As shown in , the identifier component GenColName  textualizes the column names a.empid  and b.sal  within the SELECT phrase; the identifier component GenTableName  textualizes the table names emp  and hr  within the FROM phrase; the identifier component GenAlias textualizes the aliases a  and b  within the FROM phrase. It is noted that aliases are a unique class of identifiers in that they are only valid in GenSelectList and GenFrom (and typically not allowed in filter clauses). The identifier component GenColName  textualizes the column name b.hdat  within the WHERE phrase; the identifier component GenDateValue  textualizes the date value  within the WHERE phrase; the identifier component GenColName  textualizes the column name b.sal  within the ORDER BY phrase.","Components may use overrides to handle third party identifier differences, such as differences with respect to the date literal components. As another example, drivers may be used for several third party datasources to provide overrides for numeric literal components.","Expression components are discussed next. So far we have seen components that operate on high-level SQL phrases and low-level physical identifiers. The SQL \u201centities\u201d in the query example above have, thus far, been limited to column names, table names, and literals\u2014all of which are physical entities. It should be noted, however, that the SQL syntax allows for much greater complexity in its entities\u2014all or a portion of which the textualization system may handle. An SQL \u201centity\u201d can be:\n\n","An example of component processing is shown in  using SELECT and UPDATE commands. Two SQL commands are shown in column \u2014a SELECT command and an UPDATE command. Column  lists that the command expression component GenQuery is used to determine what command phrase components are needed to textualize the SELECT command. Column  lists the order in which the phrases are processed, and column  lists the command phrase components that deal with a command phrase. As an illustration, the select list command phrase is textualized by its corresponding phrase component GenSelectList.","The expression components discussed so far are conveniently categorized in . Column  denotes the expression components which operate upon their respective expression types shown in column . Column  shows an example of the expression types listed in column . However, it should be noted that command expressions can be extended to include other SQL statements.",{"@attributes":{"id":"p-0039","num":"0050"},"figref":"FIG. 10","b":["350","352","352","360","354","356","358","368"]},"The granular expression components (, , ) have more context than GenExpression , that is, they represent a specific type of expression like a compound expression 354, function expression 356, or command expression 358. Block  illustrates several compound situations where the GenCompoundExpr component would be used, such as to handle a concatenation operation \u201cA\u2225B\u201d or an addition operation \u201cX+i\u201d. Block  illustrates several function expression components that could be compound situations where the GenCompoundExpr component would be used, such as to handle a concatenation operation \u201cA\u2225B\u201d or an addition operation \u201cX+1\u201d. Block  illustrates several command expression components, such as a SELECT or UPDATE command expression. Because commands contain phrases, command expression components  invoke phrase components  to textualize phrases as shown in block .","Similar to GenExpression , granular expression components (, , ) also call identifier components  and other expression components, but within a more specific context. For example, the GenSASFunction component and the GenSQLFunction component (shown in block ) have the context to know the type of function and how many arguments to process. They then call the GenExpression component  for each function argument.","To further illustrate the exemplary component operational flow, the example query described above is used and is as follows:","select a.empid, b.sal from emp a, hr b where b.hdat>\u201801jan1998\u2019d order by b.sal;","We can see that at the highest level the entire query is a command expression that will be processed by the GenQuery expression component  shown in . Since GenQuery is itself an expression (as are all SQL commands), GenExpression  is the entry point into the text component system. It should be understood that the system may have different entry points, such as an entry point where the converted tree calls directly other component objects or the entry point is to a program that checks the syntax of the input SQL command with respect to the native database system's query language format.","After the driver loads the software appendage, exports its overrides, and does setup operations, it calls GenExpression  once to produce the entire SQL text from a provided SQL tree. In this example, this is true for all SQL commands, and all driver-provided overrides automatically get applied as needed because components utilize a common call interface. Drivers may also be free to perform setup operations. It should be noted that a query may also appear as an SQL entity within a query (referred to as a subquery or inline view), so GenQuery  may be called multiple times.",{"@attributes":{"id":"p-0045","num":"0056"},"figref":["FIG. 11","FIG. 11"],"b":["380","380","390","390","400","404","410","420","400","404","410","420","401","405","411","421","401","402","405","406","411","412","414","414","416","421","422","404","408"]},"The following table lists what statement portions are textualized by which components (shown in ):",{"@attributes":{"id":"p-0047","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"COMPONENT","STATEMENT PIECE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"GenSelectList 400A","select 400B"]},{"entry":[{},"GenColName 402A","a.empid 402B"]},{"entry":[{},{},"b.sal 402C"]},{"entry":[{},"GenFrom 404A","from 404B"]},{"entry":[{},"GenTableName 406A","emp 406B"]},{"entry":[{},{},"hr 406C"]},{"entry":[{},"GenAlias 408A","a 408B"]},{"entry":[{},{},"b 408C"]},{"entry":[{},"GenWhere 410A","where 410B"]},{"entry":[{},"GenCompoundExpr 412A","( . . . ) 412B and 412C"]},{"entry":[{},"GenColName 414A","b.hdat 414B"]},{"entry":[{},"GenDate Value 416A","\u201801jan98\u2019d 416B"]},{"entry":[{},"GenOrderBy 420A","order by 420B"]},{"entry":[{},"GenColName 422A","b.sal 422B"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"A driver may have no need to override either GenExpression  or GenQuery  because they are both high-level expression components that utilize components common to all standard SQL implementations.","It is noted that GenSASFunction and GenSQLFunction components are much more driver-specific. Most third party drivers will need overrides to GenSASFunction since any SAS function would require a driver replacement function for a successful prepare. GenSQLFunction processes SQL-defined functions. This includes the standard aggregate functions along with any other SQL-defined functions (e.g., COALESCE, any new SQL-99 functions, etc.). Some drivers may need an override to GenSQLFunction.","Some drivers will also need overrides to GenCompoundExpr as well. Consider the case where a driver does not support \u201ca\u2225b\u201d but instead supports \u201cconcat(a,b)\u201d. Or the driver may not support a default operator\u2014for example, Sybase uses \u2018+\u2019 instead of \u2018\u2225\u2019 for a concatenation operator). Driver overrides will be required for such cases.",{"@attributes":{"id":"p-0051","num":"0062"},"figref":"FIG. 12","b":["450","452","454"]},"While examples have been used to disclose the invention, including the best mode, and also to enable any person skilled in the art to make and use the invention, the patentable scope of the invention is defined by the claims, and may include other examples that occur to those skilled in the art. For example, different component objects may be used instead of or in addition to the above-listed component objects. As an illustration and with reference to , a \u201cparent\u201d component type  may be used in conjunction with overrides to other components. A \u201cparent\u201d component  is a static component that always points to a specific default method and is called from a corresponding override method when necessary. That is, when a driver exports an override to a given method, the parent component  gives the driver a mechanism to call back to the overridden default method. This may be used when an override method wishes to call back into the corresponding default (or parent) method to do the work when an override method does not require driver-specific processing for all cases of that method.","To illustrate this point, consider the concatenation situation in the GenCompoundExpr component. Suppose a driver does not support the default \u201ca\u2225b\u201d construct but instead requires \u201cconcat(a,b)\u201d or \u201ca+b\u201d. Suppose further that concatenation is the only compound expression that differs from the default (given the assumption that there are many types of compound expressions). Although the driver will write an override to GenCompoundExpr to handle concatenation, the driver should not have to code for the other compound expression types since the default method already does that. Calling the parent method from the driver's GenCompoundExpr accomplishes this. The Sybase database system has this concatenation difference.","A driver for the Sybase database system may handle the concatenation override in a manner shown in . If it is determined at  that an SQL tree node is a concatenation node that requires Sybase-specific textualization, then code is executed at  to textualize the Sybase-specific concatenation. If it is not a node that requires special textualization, then the parent component of the GenCompoundExpr component is executed at .","As another example involving parent components, the handling of outer joins is described. Some RDBMSs do not support standard outer join syntax in their older versions. Oracle presently is one of these RDBMSs. A driver for such an Oracle database system provides overrides to GenFrom and GenWhere to allow for these syntactical differences. With reference to , the GenWhere component  would be required at  to put \u2018(+)\u2019 outer join operators on WHERE conditions. Suppose the query only references INNER joins or we are dealing with a newer version of Oracle that does support standard outer join syntax. The default GenWhere may be used at  for those cases.","From the above examples we can see how the parent components are named with respect to the standard components. Optionally, a parent component has the same name as its corresponding standard component but prefixed with the term \u201cParent\u201d, and standard components have a corresponding parent as shown in .","We can now see how the parent components allow the drivers to be very granular in how they implement their override methods. Using this override mechanism combined with parent components, a driver may write just those cases of a method that differ from the default. Such a design maximizes code reuse. However, it should be noted that less optimal implementations may be used and still achieve advantages of the textualization system. As another example of the applicability and extensions of the textualization system, the textualization system may be applied to database system dialects other than SQL. As yet another example of the many applications and extensions of the system, the textualization system has general applicability to third party data store systems which are SQL-based. Such drivers can access RDBMSs as well as ERP systems and other such systems.","As yet another example of the wide variation of the textualization system, a textualization process  may textualize an input SQL statement  (which is formatted in a particular native database query format) as one or a set of application programming interface (API) calls . The API calls  are textualized so as to be compatible and directly executable within another database system  that utilizes API calls to perform database operations. It should be understood that the textualized API calls  may need to be compiled into machine code for execution within the second database system. The textualization process  accesses API specific textualizations  to translate the input SQL statement  to third party API call(s). As shown at , API calls may be textualized for a database system  which can also execute textualized third party formatted SQL statements .",{"@attributes":{"id":"p-0059","num":"0070"},"figref":["FIG. 18","FIG. 2"],"b":["634","630","32","634","636","632","60","630","634","632","630","602"]},"While not required, the textualization of API calls or the program call creation may employ the object-oriented technique described above. For example based upon the type of input SQL statement, the proper textualization components may be invoked in order to access the API textualization specific data. As another illustration and as shown in , the output from the components  may not be textualized database statements or textualized API calls. Instead, the components  may contain an override mechanism  wherein the components' output may be API calls to a third party database system.","It should be understood that the system disclosed herein is not limited to database systems that utilize APIs but includes database systems that can handle in general program calls that instruct database systems to access data contained within the database systems. Also, the providing of textualized database statements or API calls to third party database systems may be across one or more network connections in order to access the third party database systems."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIGS. 3-5"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIGS. 14 and 15"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIGS. 17 and 18"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 19"}]},"DETDESC":[{},{}]}
