---
title: Cross-environment communication framework
abstract: A mobile computing device with a mobile operating system and desktop operating system running concurrently and independently on a shared kernel without virtualization. The mobile operating system provides a user experience for the mobile computing device that suits the mobile environment. The desktop operating system provides a full desktop user experience when the mobile computing device is docked to a secondary terminal environment. Applications of the desktop operating system communicate with applications and services of the mobile operating system through a cross-environment communication framework. The cross-environment communication framework may include interfaces to remotable objects allowing processes in the mobile operating system and processes in the desktop operating system to share memory in a thread-safe manner. The mobile computing device may be a smartphone running the Android mobile operating system and a full desktop Linux distribution on a modified Android kernel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09098437&OS=09098437&RS=09098437
owner: Z124
number: 09098437
owner_city: George Town
owner_country: KY
publication_date: 20110824
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This Application is a non-provisional of and claims the benefit of the filing date of U.S. Provisional Application Nos. 61\/389,117, filed Oct. 1, 2010, entitled \u201cMulti-Operating System Portable Docking Device\u201d; 61\/507,201, filed Jul. 13, 2011, entitled \u201cCross-Environment Communication Framework\u201d; 61\/507,203, filed Jul. 13, 2011, entitled \u201cMulti-Operating System\u201d; 61\/507,206, filed Jul. 13, 2011, entitled \u201cAuto-Configuration of a Docked System in a Multi-OS Environment\u201d; 61\/507,199, filed Jul. 13, 2011, entitled \u201cDockable Mobile Software Architecture\u201d; and 61\/507,209, filed Jul. 13, 2011, entitled \u201cAuto-Waking of a Suspended Secondary OS in a Dockable System.\u201d","1. Field","This Application relates generally to the field of mobile computing environments, and more particularly to supporting multiple user environments through the use of multiple operating systems in a single mobile computing device.","2. Relevant Background","Mobile computing devices are becoming ubiquitous in today's society. For example, as of the end of 2008, 90 percent of Americans had a mobile wireless device. At the same time, the capabilities of mobile devices are advancing rapidly, including smartphones that integrate advanced computing capabilities with mobile telephony capabilities. Mobile providers have launched hundreds of new smartphones in the last three years based upon several different platforms (e.g., Apple\u2122 iPhone\u2122, Android\u2122, BlackBerry\u2122, Palm\u2122, and Windows\u2122 Mobile). In the U.S., smartphone penetration reached almost 23% by the middle of 2010, and over 35% in some age-groups. In Europe, the smartphone market grew by 41% from 2009 to 2010, with over 60 million smartphone subscribers as of July 2010 in the five largest European countries alone.","While smartphones are gaining in popularity and computing capability, they provide a limited user experience. Specifically, they typically have an operating system that is modified for mobile device hardware and a restricted set of applications that are available for the modified operating system. For example, many smartphones run Google's\u2122 Android\u2122 operating system. Android runs only applications that are specifically developed to run within a Java\u2122-based virtual machine runtime environment. In addition, while Android is based on a modified Linux\u2122 kernel, it uses different standard C libraries, system managers, and services than Linux. Accordingly, applications written for Linux do not run on Android without modification or porting. Similarly, Apple's iPhone uses the iOS\u2122 mobile operating system. Again, while iOS is derived from Mac OS X\u2122, applications developed for OS X do not run on iOS. Therefore, while many applications are available for mobile operating systems such as Android and iOS, many other common applications for desktop operating systems such as Linux and Mac OS X are not available on the mobile platforms.","Accordingly, smartphones are typically suited for a limited set of user experiences and provide applications designed primarily for the mobile environment. In particular, smartphones do not provide a suitable desktop user experience, nor do they run most common desktop applications. As a result, many users carry and use multiple computing devices including a smartphone, laptop, and\/or tablet computer. In this instance, each device has its own CPU, memory, file storage, and operating system.","Connectivity and file sharing between smartphones and other computing devices involves linking one device (e.g., smartphone, running a mobile OS) to a second, wholly disparate device (e.g., notebook, desktop, or tablet running a desktop OS), through a wireless or wired connection. Information is shared across devices by synchronizing data between applications running separately on each device. This process, typically called \u201csynching,\u201d is cumbersome and generally requires active management by the user.","Embodiments of the present invention are directed to providing the mobile computing experience of a smartphone and the appropriate user experience of a secondary terminal environment in a single mobile computing device. A secondary terminal environment may be some combination of visual rendering devices (e.g., monitor or display), input devices (e.g., mouse, touch pad, touch-screen, keyboard, etc.), and other computing peripherals (e.g., HDD, optical disc drive, memory stick, camera, printer, etc.) connected to the computing device by a wired (e.g., USB, Firewire\u2122, Thunderbolt\u2122, etc.) or wireless (e.g., Bluetooth\u2122, WiFi, etc.) connection. In embodiments, a mobile operating system associated with the user experience of the mobile environment and a desktop operating system associated with the user experience of the secondary terminal environment are run concurrently and independently on a shared kernel.","According to one aspect consistent with various embodiments, an application of a desktop operating system communicates with a service of a mobile operating system by requesting to bind to a remotable interface of the service of the mobile operating system, receiving a remotable object from the service of the mobile operating system, the remotable object instantiated by the service of the mobile operating system in response to the request by the desktop operating system, sending a call to the remotable object, the call to the remotable object including a first parcel object, and receiving, by the application of the desktop operating system, a second parcel object from the service of the mobile operating system.","According to other aspects consistent with various embodiments, the mobile operating system and the desktop operating system run concurrently on a shared kernel. An inter-process communication driver of the shared kernel may marshal the first parcel object to the process space of the service of the mobile operating system. The first parcel object may include an action to be performed by the service of the mobile operating system. The mobile operating system may return the second parcel object after performing the action of the first parcel object. The first parcel object may include a reference to a shared memory space and\/or a file descriptor. An inter-process communication library that includes base classes for the remotable object may be compiled against user libraries of the desktop operating system. The inter-process communication library may be a binder library.","According to other aspects consistent with various embodiments, a first application of a mobile operating system and a second application of a desktop operating system communicate by receiving, by a remote communication service of the mobile operating system, a request by the first application to bind to the remote communication service, instantiating, in response to the request by the first application, a remotable object, passing the remotable object from the remote communication service to the first application, receiving, by the remote communication service of the mobile operating system, a request by the second application to bind to the remote communication service through an inter-process communication channel, and passing the remotable object from the remote communication service to the second application.","According to other aspects consistent with various embodiments, the mobile operating system and the desktop operating system may run concurrently on a shared kernel. The communication between the first application and the second application may further include receiving, by the remote communication service of the mobile operating system, a call to the remotable object from the first application, the call including a first parcel object. The call may be a synchronous or asynchronous call. The remote communication service of the mobile operating system may return a second parcel object in response to receiving the call to the remotable object. The first parcel object may include a reference to a shared memory space.","According to other aspects consistent with various embodiments, a computing device includes a computer readable medium storing instructions for a physical processor, the instructions, when executed, causing the processor to perform steps comprising receiving, by a service of a mobile operating system, a request to bind to the service by an application of a desktop operating system, instantiating, by the service of the mobile operating system, a remotable object in response to the request to bind to the service by the application of the desktop operating system, sending, by the service of the mobile operating system, the remotable object through an inter-process communication channel to the application of the desktop operating system, receiving, by the service of the mobile operating system, a call to the remotable object by the application of the desktop operating system, the call to the remotable object including an action to be performed by the service, and returning, from the service of the mobile operating system, a reference to the remotable object in response to receiving the call to the remotable object.","According to other aspects consistent with various embodiments, the instructions may further cause the processor to perform the steps of running the mobile operating system in a first execution environment on a shared kernel, and concurrently running the desktop operating system in a second execution environment on the shared kernel. The action may include invoking a remotable method of the service. The service may be a bound service.","Traditionally, handheld mobile telephony devices (i.e., \u201chandsets\u201d) were developed independently and served a separate and distinct purpose from that of personal computers (\u201cPCs\u201d) such as desktops and laptops. Handheld mobile telephony devices were focused primarily on communication while PCs were focused on computing tasks such as creating and editing documents, text-based communication (e.g., email, etc.), multimedia, and web browsing. However, mobile telephony devices are including ever-increasing computing ability and users increasingly desire convergence of communication and computing capabilities into multi-use mobile devices.","For example, mobile telephony devices called \u201csmartphones\u201d that include computing capabilities are increasing in popularity. Many of these smartphones include a mobile operating system (\u201cOS\u201d) running on a mobile processor. While mobile processors and mobile OS's have increased the capabilities of these devices, smartphones have not tended to replace PC environments such as desktop or notebook computers at least because of the limited user experience provided. In particular, for some tasks such as typing or editing documents, a full-size keyboard and large display are easier to use than the user interface components typically found on a smartphone. For example, smartphones typically use a small thumb-style QWERTY keyboard, touch-screen display, click-wheel, and\/or scroll-wheel as user interface components. Selecting menu options or items typically involves either using a touch-screen display, or using the click-wheel or scroll-wheel to navigate menus and select items. This interface is suited to the small display screens and limited menu options typically found in smartphones, but not suited to controlling more traditional programs with a larger number of menu options, larger screen area, and user interface built around a pointing device such as a traditional mouse.","Embodiments of the invention are directed to an innovative cross-environment communications framework (\u201cCECF\u201d) that allows for fast communications between applications and services of multiple operating systems running independently and concurrently on the same shared kernel. For example, embodiments allow fast communication between applications and services of an Android mobile OS running on a shared kernel and applications and services of a Linux desktop OS running on the same shared kernel. Embodiments include an extension to the Android \u201cBinder\u201d inter-process communication (\u201cIPC\u201d) mechanism that allows for app-to-app communications within the Android OS. For example, Android OS applications within can register with the remote communication service to be able to communicate (e.g., synchronize data, settings, etc.) in a synchronous and\/or asynchronous way. Other embodiments include base classes of the Binder mechanism for a Linux desktop OS that allow communication between applications of the Linux desktop OS and Android OS applications and services. For example, Android applications running on the Android OS can share data, settings, and preferences with Linux applications running on the Linux desktop OS.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 1","b":["100","100","110","110","110","114","116","118","120","110","130","160","130","160","110","130","116","118","130","116","118","116","130","130","116"]},"Mobile computing device  may be connected to I\/O devices ,  and\/or  through port . I\/O devices , , and\/or  may make up a secondary terminal environment . In some instances, secondary terminal environment  may be more suited to desktop OS  than mobile OS . For example, secondary terminal environment  may include a keyboard , pointing device , and a display device . In these instances, desktop OS  can be associated with secondary terminal environment  to provide the full capabilities of a notebook or desktop computer environment through secondary terminal environment . In other instances, secondary terminal environment  may be more suited for mobile OS  than desktop OS . For example, secondary terminal environment  may include a touch-screen display. In these instances, mobile OS  may be associated with secondary terminal environment .","In , port  is shown as connected to port  of secondary terminal environment  through interface . However, port  may include separate connections to each I\/O device ,  and  through interface . Interface  may be any suitable wired or wireless interface or combination of wired and wireless interfaces for connecting devices such as keyboards, monitors, pointing devices, etc. For example, interface  may be a combination of a display interface (e.g., VGA, DVI, HDMI, etc.) and a device communications interface (e.g., USB, Bluetooth, Firewire, other serial communications interface, etc.). Alternatively, interface  may be a single communications interface that supports both video and device communications signals (e.g., Thunderbolt, etc.).","Traditionally, the hardware and software development paths for the handset environment and the PC environment have been completely independent because of different use models and competing constraints on product design. PCs, including desktop and laptop computers, are designed to be flexible and powerful. Specifically, PC hardware architecture is typically based around a general purpose PC processor connected to memory, graphics, and external components through various general purpose interfaces on a motherboard. For example, a personal computer motherboard may include a processor connected through a logic chipset to a graphics processor, system memory (e.g., RAM), and various other components through communication interfaces (PCI, USB, ISA, IDE, etc.). Some more highly integrated PC processors include an interface to a graphics processor (e.g., AGP, etc.) and\/or interface to system memory (e.g., SDR, DDR, DDR2, DDR3, DRDRAM, etc.) on the processor.","PC processors are optimized for high processor clock speed and computationally intensive tasks. The personal computer market is presently dominated by processors based on the x86 CPU architecture. Current x86-based PC processors for desktop computers have multiple 64-bit central processing units (\u2018CPUs) (or \u201ccores\u201d) with clock speeds exceeding 2.5 GHz and power consumption approaching 100 Watts. Current x86-based PC processors for laptop computers typically run at clock speeds up to 2.0 GHz and have power consumption in the range of 15-45 Watts. Because of the large power consumption of these processors, desktop and laptop computers may require cooling devices such as fans or heat-sinks to remove waste heat from the processor. In addition, the battery life of laptop computers using x86-based PC processors is typically less than four hours.","In contrast, mobile processors for handsets are optimized for low power consumption and a high level of integration to reduce the overall size of the handset. For example, mobile processors for handsets such as smartphones typically run at clock speeds lower than 2.0 GHz, have power consumption of less than 1 Watt, and integrate functions common to the mobile environment such as graphics controllers, communications interfaces, and camera controllers. The most common mobile processor architectures are reduced instruction set computing (\u201cRISC\u201d) processor architectures. Specifically, the \u201cARM\u201d mobile processor architecture is currently the predominant architecture for mobile processors designed for smartphones and other ultra-portable and low power computing devices. Some PC processor manufacturers also refer to PC processors designed for use in laptop computers as \u201cmobile processors.\u201d However, as used herein, the term \u201cmobile processor\u201d refers to a processor suited for use in a handset or smartphone, typically consuming less than 1 Watt and integrating mobile functionality.","Personal computers and handsets also typically have different system resources, input\/output (\u201cI\/O\u201d) devices, and peripherals. For example, desktop and laptop computers typically have much larger amounts of system memory and storage capacity than handsets. While a typical laptop computer may have more than 2 GB of RAM and a hard-drive with a capacity of more than 250 GB, handsets typically have less than 512 MB of RAM and a solidstate drive with a capacity of less than 32 GB. User interface components of personal computers typically include a display screen larger than 9 inches diagonally, a full keyboard, and pointing device(s) for user input. In contrast, handsets typically include a display screen smaller than 7 inches diagonally and user interface components such as a thumb-style QWERTY keyboard, touch-screen display, click-wheel, and\/or scroll-wheel. Peripherals found on personal computers typically include an optical disk drive (e.g., CD, DVD, DVD-RW, etc.), expansion ports (e.g., PCMCIA, SCSI, Express Card, etc.), video output port (e.g., VGA, DVI, HDMI, etc.), and generic device ports (e.g., USB, etc.). In contrast, handsets typically do not have optical disk drives or expansion ports. However, other devices are typically integrated into handsets including wireless communications interface(s) (e.g., GSM, CDMA, LTE, EDGE, WiFi, WiMax, etc.), GPS chipset, accelerometer, camera(s), and\/or solid-state memory port (SD, Memory Stick, etc.).","Software for personal computers and handsets has also traditionally been developed independently. For example, personal computers including desktops and laptops typically run different operating systems than mobile devices. An operating system is software that manages computer hardware and resources and provides common services for execution of applications software on the computer hardware. Operating systems are generally described as having various abstraction layers, where each layer interfaces with the layer below through an interface.","Generally, the kernel of an operating system refers to the core OS layer that manages the computing devices resources such as the CPU(s) (CPU scheduling), memory, and I\/O (including peripheral and file system access). A kernel will usually provide features for low-level scheduling of processes (dispatching), inter-process communication, process synchronization, context switching, manipulation of process control blocks, interrupt handling, process creation and destruction, and process suspension and resumption. The OS kernel mayor may not include device drivers. Other layers of the OS interface with the kernel through system calls or an application programming interface (\u201cAPI\u201d) layer.","Generally, other as layers include the libraries layer, application framework layer, and application layer. The libraries layer typically includes system libraries and other user libraries. The application framework layer includes services, managers, and runtime environments. The application layer includes user applications, which may run within a runtime environment of the application framework layer. A user interacts with the OS through the OS GUI. The GUI presents menus, buttons, and controls that the user selects to control and use applications running on the OS. Commonly, the term \u201cdesktop environment\u201d is used to refer to a style of GUI through which the user interfaces with the OS using icons, windows, toolbars, folders, and\/or desktop widgets, and is not limited to a desktop OS. For example, a mobile OS could have a desktop environment, referring to the look and feel of the mobile OS GUI.","Operating systems for personal computers (desktop OSs) were designed for multitasking, larger screen areas, and to provide a flexible environment for application developers. As used herein, the term desktop as refers to an operating system designed for use with a personal computer environment, for example a desktop or laptop use environment. Examples of desktop OS's include various distributions of Linux, Mac OS X, and Windows 7, among many others.","Operating systems for mobile devices (mobile OSs) were developed for the smaller screen area, lower processing power, smaller memory, and smaller disk space typically found on handsets and smartphones. Example mobile OSs include Android, Apple's iOS (for the iPhone and iPad\u2122), Microsoft's Windows Mobile (superseded by Windows Phone 7), Nokia's Symbian\u2122 and Palm's Palm OS\u2122 (superseded by HP webOS\u2122). As used herein, the term mobile OS refers to an operating system designed for use with a mobile environment including running on a low-power processor with reduced system resources compared to the PC environment (i.e., desktop or laptop computer system).","Mobile operating systems generally have a particular application development environment that is used to create application programs (i.e., \u201capps\u201d) that run on the mobile OS. The application development environment both facilitates application development by providing common tools and APIs for accessing system resources and services, and limits what applications are allowed to do such that the mobile device is able to continue to provide other required functions. For example, incoming phone calls and texts may interrupt a running application to notify the user of the incoming call or text.","The most widely adopted mobile OS is Google's Android. While Android is based on Linux, it includes modifications to the kernel and other OS layers for the mobile environment and mobile processors. In particular, while the Linux kernel is designed for the x86 CPU architecture, the Android kernel is modified for ARM-based mobile processors. Android device drivers are also particularly tailored for devices typically present in a mobile hardware architecture including touch-screens, mobile connectivity (GSM\/EDGE, CDMA, Wi-Fi, etc.), battery management, GPS, accelerometers, and camera modules, among other devices.","In Android, applications run within the Dalvik virtual machine on an object-oriented application framework designed specifically for the memory and processor speed constraints of mobile hardware architectures. Applications are developed for the Dalvik virtual machine through the Android SDK. In addition, Android does not have a native X Window System nor does it support the full set of standard GNU libraries, and this makes it difficult to port existing GNU\/Linux applications or libraries to Android.","Apple's iOS operating system (run on the iPhone) and Microsoft's Windows Phone 7 are similarly modified for the mobile environment and mobile hardware architecture. For example, while iOS is derived from the Mac OS X desktop OS, common Mac OS X applications do not run natively on iOS. Specifically, applications are developed for iOS through an SDK to run within the \u201cCocoa Touch\u2122\u201d runtime environment of iOS, which provides basic application infrastructure and support for key iOS features such as touch-based input, push notifications, and system services. Therefore, applications written for Mac OS X do not run on iOS without porting them through the iOS SDK. In addition, it may be difficult to port Mac OS X applications to iOS because of differences between user libraries and application framework layers of the two OSs, and differences in system resources of the mobile and desktop hardware.","Because of the differences in processing requirements, system resources, and application development, applications developed for desktop OSs typically do not run on mobile OSs. Additionally, desktop applications may not be easily ported to mobile OSs because they are optimized for a larger screen area, more processing speed, more system memory, different libraries, and commonly a different GUI. As a result, users typically use separate computing devices for each user environment, including a smartphone, tablet computer, laptop computer, and\/or desktop computer. In this instance, each device has its own CPU, memory, file storage, and OS.","Connectivity and file sharing between smartphones and other devices involves linking one device (e.g., smartphone, running a mobile OS) to a second, wholly disparate device (e.g., notebook, desktop, or tablet running a desktop OS), through a wireless or wired connection. Information is shared across devices by synchronizing data between applications running separately on each device. This process, typically called \u201csynching,\u201d is cumbersome and generally requires active management by the user.","Recently, some attempts have been made to provide a more complete user experience with a single mobile computing device. For example, a smartphone may be connected to an external monitor and input devices such as a full keyboard to provide a more desktop-like user experience, with the mobile OS graphical user interface extended to the larger screen and accepting input from the input devices. However, because the external monitor and input devices are only an extension of the smartphone's operating system and user interface, the capabilities of the docked environment are limited by the smartphone's mobile OS. For example, many software applications available on desktop OSs are not available or have limited functionality on mobile OSs. Accordingly, these devices do not present a full desktop user experience when connected to an external environment.","Referring still to , computing environment  provides multiple user computing experiences without the above limitations. Specifically, because mobile computing device  includes multiple OSs, where each OS is suited to a particular computing environment, mobile computing device  may be adapted with external devices to provide a broad range of user experiences with a single mobile computing device. For example, a user may have a mobile computing device  and a secondary terminal environment  that provides the user experience of a laptop when connected to mobile computing device . In this instance, desktop OS  of the mobile computing device is associated with the secondary terminal environment  when the secondary terminal environment is connected to mobile computing device . To the user, the full capabilities of desktop OS  are available through secondary terminal environment .",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 2","b":["110","112","114","204","220","112","206","208","212","116","214","216","218","222","224","114","110","224","220"]},"Processor  may be an ARM-based mobile processor. In embodiments, mobile processor  is a mobile ARM-based processor such as Texas Instruments OMAP3430\u2122, Marvell PXA320\u2122, Freescale iMX51\u2122, or Qualcomm QSD8650\/8250\u2122. However, mobile processor  may be another suitable ARM-based mobile processor or processor based on other processor architectures such as, for example, x86-based processor architectures or other RISC-based processor architectures.","While  illustrates one exemplary hardware implementation 112 for mobile computing device , other architectures are contemplated as within the scope of the invention. For example, various components illustrated in  as external to mobile processor  may be integrated into mobile processor . Optionally, external display interface , shown in  as integrated into mobile processor , may be external to mobile processor . Additionally, other computer architectures employing a system bus, discrete graphics processor, and\/or other architectural variations are suitable for employing aspects of the present invention.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 3","FIG. 3"],"b":["300","130","160","110","130","160","130","160","300","110","300","208","112"]},"As illustrated in , mobile OS  has libraries layer , application framework layer , and application layer . In mobile OS , applications  and  run in application layer  supported by application framework layer  of mobile OS . Application framework layer  includes manager(s)  and service(s)  that are used by applications running on mobile OS . For example, application framework layer  may include a window manager, activity manager, package manager, resource manager, telephony manager, gesture controller, and\/or other managers and services for the mobile environment. Application framework layer  may include a mobile application runtime environment that executes applications developed for mobile OS . The mobile application runtime environment may be optimized for mobile computing resources such as lower processing power or limited memory space. The mobile application runtime environment may rely on the kernel for process isolation, memory management, and threading support. Libraries layer  includes user libraries  that implement common functions such as I\/O and string manipulation (\u201cstandard C libraries\u201d), graphics libraries, database libraries, communication libraries, and\/or other libraries.","As illustrated in , desktop OS  has libraries layer , framework layer , and application layer . In desktop OS , applications  and  run in application layer  supported by application framework layer  of desktop OS . Application framework layer  includes manager(s)  and service(s)  that are used by applications running on desktop OS . For example, application framework layer  may include a window manager, activity manager, package manager, resource manager, and\/or other managers and services common to a desktop environment. Libraries layer  may include user libraries  that implement common functions such as I\/O and string manipulation (\u201cstandard C libraries\u201d), graphics libraries, database libraries, communication libraries, and\/or other libraries.","In various embodiments of the present disclosure, desktop OS  runs in a separate execution environment from mobile OS . For example, mobile OS  may run in a root execution environment and desktop OS  may run in a secondary execution environment established under the root execution environment. Processes and applications running on mobile OS  access user libraries , manager(s)  and service(s)  in the root execution environment. Processes and applications running on desktop OS  access user libraries , manager(s)  and service(s)  in the secondary execution environment.","Generally applications developed for mobile OS  do not run directly on desktop OS , and applications developed for desktop OS  do not run directly on mobile OS . For example, application  running in application layer  of desktop OS  may be incompatible with mobile OS , meaning that application  could not run on mobile OS . Specifically, application  may use manager(s)  and service(s)  of application framework layer  of desktop OS  that are either not available or not compatible with manager(s)  and service(s)  in application framework layer  in mobile OS . In addition, application  may attempt to access user libraries  that exist in libraries layer  of desktop OS  but are either not available or not compatible with user libraries  available in libraries layer  of mobile OS .","In OS architecture , mobile OS  and desktop OS  run concurrently on shared kernel . This means that mobile OS  and desktop OS  are running on shared kernel  at the same time. Specifically, mobile OS  and desktop OS  both interface to shared kernel  through the same kernel interface , for example, by making system calls to shared kernel . Shared kernel  manages task scheduling for processes of both mobile OS  and desktop OS . In this regard, mobile OS  and desktop OS  are running independently and concurrently on shared kernel . In addition, shared kernel  runs directly on mobile processor  of mobile computing device hardware , as illustrated by hardware interface . Specifically, shared kernel  directly manages the computing resources of mobile computing device hardware  such as CPU scheduling, memory access, and I\/O. In this regard, hardware resources are not virtualized, meaning that mobile OS  and desktop OS  make system calls through kernel interface  without virtualized memory or I\/O access.","There are several known techniques for providing multiple OS's on the same computing device. However, none of these techniques provide multiple different OS's running concurrently and independently on a shared kernel. More particularly, none of these techniques provide a solution for a mobile OS and a desktop OS running on a shared kernel.","In one technique, known as dual-boot, multiple OS's are loaded on the computing device one at a time. For example, at boot time, a user may select one OS from multiple available OSs to be run on the device, where each OS has its own kernel, libraries, framework, and applications. The system then boots up into that operating system and the other OS(s) are not running (i.e., no processes of the other OS(s) are loaded concurrently with the running OS). Therefore, this technique does not run multiple OS's on a shared kernel, nor does this technique run multiple OSs concurrently.","Another technique for running multiple OS's on the same device is to use a Virtual Machine Manager (\u201cVMM\u201d), or \u201cHypervisor.\u201d A VMM or Hypervisor runs directly on the hardware and separates the individual kernels of each OS from the hardware, controlling which computer hardware resources are available to each OS at any given time. A Hypervisor effectively creates multiple virtual machines from one device, such that each OS sees a separate virtual machine. Therefore, multiple OSs running on the same device through Hypervisor and VMM are not running on a shared kernel. The Hypervisor adds system overhead due to each OS having to access system resources through virtualization in the Hypervisor. Additionally, because the Hypervisor must allocate CPU and other computing resources, each OS may not be able to effectively schedule processes and tasks.","Yet another technique for running multiple OSs on the same device is to use a hosted virtual machine. In this technique, each OS has its own kernel, with the kernel of the guest OS running on a virtual machine in the host OS. The virtual machine may be a virtualized hardware platform different than the physical hardware platform. The virtual machine in the host OS may be implemented in the kernel of the host OS. In this instance, the kernel of the host OS acts as a hypervisor through which the kernel of the guest OS accesses the processor and hardware resources. Regardless of where the virtual machine is implemented in this technique, the host OS and the guest OS have separate kernels. Therefore, hosted virtual machines do not have multiple OSs running on a shared kernel. System performance using this technique may be reduced due to virtualization of hardware resources for the guest OS.","Another form of virtualization is operating system level virtualization. In this technique, multiple isolated user-space instances may be created on the kernel of an operating system, which look like separate OS instances from the point of view of users of each user-space instance. In this technique, the host OS and guest OS(s) must be the same OS. Accordingly, this technique does not provide a solution for a mobile OS and desktop OS running independently and concurrently on a shared kernel. Further, similarly to a hosted virtual machine, this technique uses disk space and memory virtualization for the guest OS(s). Accordingly, this technique does not provide direct access to memory and system resources for each concurrent OS.","These techniques of running multiple OS's have limitations with regard to running both operating systems concurrently and independently. For example, virtualization involves setting up a distinct address space for the guest OS and simulating I\/O to the guest OS. Therefore, access to hardware including system memory has higher overhead for the guest OS using virtualization. Additionally, techniques using Hypervisors result in lack of certainty in process control of each OS. Specifically, the Hypervisor manages the amount of CPU time allocated to each OS, and each OS then allocates CPU time for processes within the OS, without knowledge of what is occurring in the other OS. In this regard, high priority processes within one OS may not be given the required CPU time to complete their tasks because the OS is sharing CPU time through the Hypervisor, which cannot account for the relative priorities of processes running within each OS. Because processing power may be limited in mobile processor architectures relative to desktop processor architectures, techniques that depend on virtualization, including hypervisors, and operating system level virtualization, may not offer optimal performance for a desktop OS running concurrently with a mobile OS on a mobile processor.","In one embodiment consistent with OS architecture , an Android mobile OS and a full Linux OS run independently and concurrently on a modified Android kernel. In this embodiment, the Android OS may be a modified Android distribution while the Linux OS (\u201cHydroid\u2122\u201d) may be a modified Debian\u2122 Linux desktop OS.  illustrate Android mobile OS , Android kernel , and Hydroid OS  that may be employed in OS architecture  in more detail, according to various embodiments.","As illustrated in , Android OS  includes a set of C\/C++ libraries in libraries layer  that are accessed through application framework layer . Libraries layer  includes the \u201cbionic\u201d system C library  that was developed specifically for Android to be smaller and faster than the \u201cglibc\u201d Linux C-library. Libraries layer  also includes interprocess communication (\u201cIPC\u201d) library , which includes the base classes for the \u201cBinder\u201d IPC mechanism of the Android OS. Binder was developed specifically for Android to allow communication between processes and services. Other libraries shown in libraries layer  in  include media libraries  that support recording and playback of media formats, surface manager  that managers access to the display subsystem and composites graphic layers from multiple applications, 2D and 3D graphics engines , and lightweight relational database engine . Other libraries that may be included in libraries layer  but are not pictured in  include bitmap and vector font rendering libraries, utilities libraries, browser tools (i.e., WebKit, etc.), and\/or secure communication libraries (i.e., SSL, etc.).","Application framework layer  of Android OS  provides a development platform that allows developers to use components of the device hardware, access location information, run background services, set alarms, add notifications to the status bar, etc. Framework layer  also allows applications to publish their capabilities and make use of the published capabilities of other applications. Components of application framework layer  of Android mobile OS  include activity manager , resource manager , window manager , dock manager , hardware and system services , desktop monitor service , multi-display manager , and remote communication service . Other components that may be included in framework layer  of Android mobile OS  include a view system, telephony manager, package manager, location manager, and\/or notification manager, among other managers and services.","Applications running on Android OS  run within the Dalvik virtual machine  in the Android runtime environment  on top of the Android object-oriented application framework. Dalvik virtual machine  is a register-based virtual machine, and runs a compact executable format that is designed to reduce memory usage and processing requirements. Applications running on Android OS  in application layer  include home screen , email application , phone","application , browser application , and\/or other application(s) (\u201cApp(s)\u201d) .","For these reasons, applications written for Android do not generally run on Hydroid OS  and applications written for standard Linux distributions do not generally run on Android OS . In this regard, applications for Android OS  and Hydroid OS  are not bytecode compatible, meaning compiled and executable programs for one do not run on the other.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 5","b":["520","520","521","522","523","524","525","526","527","528","529","528","110","120","520"]},{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 6","b":["660","662","660","662","664","666","661","674","673","672","670","680","681"]},{"@attributes":{"id":"h-0007","num":"0000"},"b":["682","683","684","685"]},"In one embodiment, Hydroid OS  includes components of a cross-environment communication framework that facilitates communication with Android OS  through shared kernel . These components include IPe library  that includes the base classes for the Binder IPe mechanism of the Android OS and remote communications service .","In one embodiment, Hydroid OS  is run within a chrooted (created with the \u2018chroot\u2019 command) secondary execution environment created within the Android root environment. Processes and applications within Hydroid OS  are run within the secondary execution environment such that the apparent root directory seen by these processes and applications is the root directory of the secondary execution environment. In this way, Hydroid OS  can run programs written for standard Linux distributions without modification because Linux user libraries  are available to processes running on Hydroid OS  in the chrooted secondary execution environment.","In preemptive multi-tasking operating systems, direct communication between independent processes is typically prevented for security and reliability reasons. Instead, a form of IPC must be used to send information across process boundaries (i.e., between process address spaces). Objects sent from one process to another process must be marshaled across the process boundaries. Marshaling is the process of packaging and unpackaging data and parameters so an IPC communication can take place. Some forms of IPC can be used to pass information between processes on different computers on a network. One method of IPC is to allow a process in one address space to cause a subroutine or procedure to execute in another address space. This method of IPC is called a remote procedure call (\u201cRPC\u201d).","Some methods of IPC are platform independent. For example, Internet sockets or network sockets are a mechanism of bidirectional IPC across an Internet Protocol (\u201cIP\u201d) based computer network. Internet sockets can be used to deliver data packets to application processes or threads based on local or remote IP addresses and port numbers. The operating systems of each local or remote machine maintain mappings of each socket to the appropriate application process or thread.","Referring back to , OS architecture  includes OS  and desktop OS  running concurrently on shared kernel . As illustrated in , mobile computing device  can be docked with secondary terminal environment . Secondary terminal environment  may have a user experience profile that is associated with desktop OS . In this instance, mobile OS  provides a mobile computing experience through touch-screen display  and I\/O devices  of mobile computing device hardware . At the same time, desktop OS  provides a desktop computing experience through secondary terminal environment .","Accordingly, the user is able to use and interact with mobile applications (for example, applications  and ) running on mobile OS  through the mobile computing experience provided on the user interface components of mobile computing device  while using and interacting with desktop applications (for example, applications  and ) running on desktop OS  through secondary terminal environment . In this instance, applications of mobile OS  are independent from applications of desktop OS . In this regard, settings, user preferences, user data, and application states of applications of mobile OS  are separate and independent from settings, user preferences, user data, and application states of applications of desktop OS . For example, application  of mobile OS  and application  of desktop OS  may be spreadsheet applications. When the user opens a spreadsheet file with application  and begins editing data, the spreadsheet file and associated data are locked by application . Application  is not able to access the edited spreadsheet data as that data is maintained in the process space of application .","Embodiments of the invention include a cross-environment communications framework that extends IPe between applications and services of a mobile OS running on a shared kernel and applications and services of a desktop OS running on the same shared kernel. The cross-environment communications framework supports communication between applications of the desktop OS and applications and services of the mobile OS. The cross-environment communications framework also supports communication between mobile OS applications and other mobile OS applications.",{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 7","b":["700","352","741","354","130","382","384","160"]},"Services are components that perform background operations (i.e., not directly involving user interaction with the application) for applications and\/or assist in interactions between applications and hardware. While various operating systems may refer to these components by other names, a service, as used herein, is intended to be construed broadly as a component including one or more processes that implements functionality not directly involving user interaction that may be used by applications, the operating system, and\/or other services.","As illustrated in , desktop application , running on desktop OS , communicates with service  running on mobile OS  through an inter-process communication channel that includes IPe driver  in kernel . Initially, desktop application  sends a call through IPe driver  to bind to service . Service  creates an instance of a remotable object , which defines the IPe interface through which desktop application  communicates with service . Service  returns remotable object  to desktop application  through IPC driver . Subsequently, desktop application  can make calls to remotable object  to communicate with service  through IPC driver .","In one form of communication of cross-environment communication framework , desktop application  may call remotable methods of service  by making calls to remotable object . A call to remotable object  may include zero or more parameters passed to a remotable method of service  and\/or zero or more parameters to be returned from the remotable method of service . Parameters are parceled by the IPC interface to the remotable object and marshaled across process boundaries by IPC driver . In this regard, desktop application  may pass parameters in a call to remotable object  in the form of a parcel object. IPC driver  marshals the parcel object to the process space of service . Service  unparcels the parcel object and performs the remotable method in its process space using the unparceled parameters and returns another parcel object to desktop application . The returned parcel object may include a reference to the remotable object.","Calls to the remotable object may be synchronous or asynchronous. For example, if desktop application  makes a synchronous call to the remotable object, the calling thread in desktop application  blocks and waits for the return from the remotable object before continuing. Alternatively, if desktop application  makes an asynchronous call to the remotable object, the calling thread in desktop application  continues and does not wait for the call to the remotable object to return.","Remotable object  allows desktop application  and service  to both access a shared memory space in a thread-safe manner. For example, a reference to the shared memory space may be included in parcel objects passed by calls to remotable object . Because remotable object  is reference counted across process boundaries, application  and service  can share memory across process boundaries in a thread-safe manner. In various instances, the reference to a shared memory space may be a file descriptor or file handle.","In embodiments, service  may be a core service of the mobile OS such as a telephony service, camera service, location service. Service  may also be a custom service that performs operations related to an application of mobile OS  or desktop OS .","In one embodiment, service  may be a service that enables app-to-app communication. For example, service  may be a remote communications service that implements aspects of the cross-environment communications framework to provide app-to-app communication between applications running on mobile OS . The remote communication service may also enable communication between desktop applications running on desktop OS  and mobile applications running on mobile OS . In one embodiment, remote communication service  of Android OS  facilitates app-to-app communication between applications running on Android OS  and\/or Hydroid OS .","For example, mobile application  may bind to service . Service  then instantiates remotable object  and returns remotable object  to mobile application . Mobile application  may also bind to service  and service  may return remotable object  to mobile application . With mobile applications  and  may communicate through calls to remotable object . For example, mobile application  may pass parcel objects using calls to remotable object . The parcel objects may include data and\/or references to shared memory. Mobile application may access the shared memory by also making calls to remotable object . In the same manner, desktop application  may also bind to service  and communicate with mobile applications  and  using calls to remotable object .","In one embodiment, Android mobile OS  and a Linux desktop OS  run concurrently on shared kernel . The Android OS includes a lightweight remote procedure call mechanism called \u201cBinder.\u201d The Binder mechanism uses shared memory to achieve efficient, secure IPe. The Binder mechanism includes Binder IPe driver  in the Android kernel  and user class libraries including Binder IPe library  that contain the base classes for Binder objects. In Android OS , Binder IPe library  is compiled against Bionic e library . A Binder reference is a descriptor maintained by Binder driver  to an interface of a remotable Binder object. A process can call the remotable Binder object through the interface. The Android Binder mechanism provides reference counting and manages mapping of object references across processes. However, the Android Binder mechanism only provides communication between Android applications and globally registered Android services. Therefore, Android applications may not communicate directly with each other through the Binder mechanism.","The IPC mechanisms available in the Linux OS are pipes, named pipes, system V message queues, system V semaphores, system V shared memory segments, and networking sockets. These IPe mechanisms are not directly compatible with the Binder IPe mechanism in the Android OS or the Binder kernel driver used for the Android Binder IPe mechanism. Therefore, Linux applications running cannot use these standard Linux IPe mechanisms to communicate with applications and\/or service(s) running on an Android OS.","In one embodiment, the cross-environment communications framework extends the Binder mechanism to allow applications of Linux desktop OS  to access services of Android OS . In one embodiment, the cross-environment communication framework includes a remote communication service that allows app-to-app communication within Android OS . In other embodiments, the remote communication services allows Linux applications running on Linux desktop OS  to communicate with Android applications running on Android OS .","In embodiments, the cross-environment communications framework also supports use of the user datagram protocol (\u201cUDP\u201d) for cross-environment communication. UDP is part of the suite of protocols of the Internet Protocol (\u201cIP\u201d). UDP is an asynchronous data transmission mechanism without an implicit handshaking dialogue. Accordingly, UDP does not provide a reliable transmission protocol, not does it guarantee data ordering or data integrity during transmission. However, because UDP has minimal overhead, it may be a preferable transmission mechanism for time-sensitive information in a real-time system. For example, where dropping packets is preferable to delaying transmission, UDP may be a preferred transmission mechanism.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 8","b":["800","800","852","430","448","802","448","804","806","808","854","448","448","804","854","810"]},"Android application , running on Android OS , can communicate with Android application  using remotable object  by making calls to the remotable object. Calls to the remotable object may include remote method invocations and\/or parceled data. The parceled data may include various data types including integers, strings, arrays, and\/or file descriptors, among other possible data types. At step  of communication flow , Android application  invokes remote method FNI of remote communication service . Kernel IPC driver  marshals the remote call across the process boundaries and remote communication service  receives the call to the remotable object at step . Remote communication service  then unparcels data of the remote call and runs the remote method in its process space using the data at step . Remote communication service  returns another parcel object through the interface to the remotable object at steps  and .","At step , Android application  makes a call to remotable object . For example, Android application  may invoke a remote method (FN2) of remote communication service . Application  may pass a parcel object to the remote method that includes parameters for the remote method. Kernel IPC driver  marshals the parcel object to the process space of remote communication service  and remote communication service  receives the parcel object at step . Remote communication service  then unparcels the data and runs the remote method in its process space using the data at step . Remote communication service  returns another parcel object through the interface to the remotable object at step . Kernel IPC driver  marshals the parcel object across the process boundaries and Android application  receives the parcel object at step .","In one embodiment, remote communication service  may be a bound service of Android OS . In this embodiment, the bound service is created by Android OS  when an client binds to the service through the Context class of Android OS . The bound service runs as long as clients (applications and\/or services that bind to the service) are bound to the service and is destroyed when the last client unbinds from the service. The bound service may implement a shared memory interface allowing clients to share user preferences, settings, and\/or user data.","Communications flow  provides thread-safe cross-process communication for sharing data between Android applications  and  running on Android OS . Android applications  and  may share data in a shared memory space in a thread-safe manner by passing references to the shared data using remotable object . For example, Android applications  and  may pass a parcel object that includes a reference to a shared memory space through remotable object .","Communications flow  illustrates synchronous communication between Android applications  and  and remote communication service . However, communication between Android applications  and  and remote communication service  may be asynchronous, meaning that Android applications  and  will return immediately from calls to the remotable object and not wait for a result from the remote method invocation.",{"@attributes":{"id":"p-0100","num":"0099"},"figref":"FIG. 9","b":["900","900","682","660","941","430"]},"Service  exposes a Binder interface to clients and at step , Hydroid application  registers with service  by binding to service  using the exposed interface though Binder kernel driver . Service  returns in interface to a remotable object , which Hydroid application  receives at step . At step , Hydroid application  makes a call to remotable object . For example, Hydroid application  may invoke a remotable method (FN1) of service . The remote method call may include a parcel object that includes parameters for the remote method call. Binder driver  marshals the parcel object to the process space of service  and service  receives the data at step . Service  unparcels the data and runs the method in its process space using the unparceled data at step . Service  returns a parcel object that includes return values of the method through binder driver  at steps  and . Using communication flow , Hydroid application , running on Hydroid OS , can access methods and data of service  of Android OS .","Communications flow  provides thread-safe cross-process communication for sharing data between processes of Android OS  and applications of Hydroid OS . For example, Hydroid application  may access shared data of services of Android OS  through shared memory by passing references to the shared memory using remotable object .","Communication flow  may be used to allow applications running on Hydroid OS  to access various services of Android OS . For example, service  of Android OS  may be a core service of Android OS  such as a telephony service, camera service, location service, etc. Alternatively, service  may be a custom service such as remote communication service .",{"@attributes":{"id":"p-0104","num":"0103"},"figref":"FIG. 10","b":["1000","448","1002","852","430","448","448","448","1004","1004","852","1006"]},"At step , Hydroid application  of Hydroid OS  registers with remote communication service  by binding to remote communication service  using the exposed interface though binder kernel driver . Remote communication service  returns remotable object , which Hydroid application  receives at step .","At step , Android application  makes a call to remotable object . For example, Android application  may invoke a remote method (FN1) of remote communication service . Android application  may pass a parcel object to the remote method that includes parameters for the remote method. The parcel object may include a reference to a shared memory space. Binder driver  marshals the parceled data across the process boundaries and remote communication service  receives the data at step . Remote communication service  unparcels the data and runs the method in its process space using the unparceled data at step  and returns the remotable object through binder driver  at steps  and .","At step , Hydroid application  calls a remote method (FN2) of remote communication service  through the remotable object . The remote method call may include data that is parceled into remotable object . Binder driver  marshals the parceled data across the process boundaries and remote communication service  receives the data at step . Remote communication service  then unparcels the data and runs the method in its process space using the data at step  and returns remotable object  through binder driver  at steps  and .","Communications flow  provides thread-safe cross-process communication for sharing data between applications of Android OS  and applications of Hydroid OS . For example, Hydroid application  of Hydroid OS  and Android application  of Android OS  may share data through shared memory by passing references to the shared memory using remotable object . In communications flow , Android application  and Hydroid application  block on return of the remote method invocation. Accordingly, communications flow  provides synchronous communication between Android application  and Hydroid application . However, remote method invocations from Android application  and Hydroid application  may be asynchronous, meaning that applications  and  will return immediately from calls to remotable object  and not wait for a result to be returned.","In one embodiment of communications flow , remote communication service  is a bound service of Android OS . In this embodiment, the bound service is created by Android OS  when either an Android application or a Hydroid application binds to the service. The service may implement a shared memory interface allowing Android applications and Hydroid applications to share user preferences, settings, and\/or user data.","In one example consistent with communications flow , Android application  and Hydroid application  are spreadsheet programs. User data is stored in shared memory accessed through a remotable object. In this example, Android spreadsheet application  and Hydroid spreadsheet application  both may manipulate the user data by passing a parcel object that includes a reference to the shared memory through calls to remotable object . In this way, Android spreadsheet application  and Hydroid spreadsheet application  can manipulate user data of a spreadsheet stored in shared memory in a thread-safe manner.","Accordingly, communication flow  allows applications running on Hydroid OS  to communicate with applications running on Android OS  using the Android Binder mechanism. In this way, Android application  running on Android OS  and Hydroid application  running on Hydroid OS  can share settings, user preferences, and\/or user data fast and efficiently.",{"@attributes":{"id":"p-0112","num":"0111"},"figref":["FIG. 11","FIG. 11"],"b":["1100","448","430","1146","674","660","1176","1100","982","660","852","430","1146","430","1176","660"]},"In one example, Android application  binds to a socket of socket driver(s)  in shared kernel  through UDP module . Hydroid application  of Hydroid OS  also binds to the socket of socket driver(s)  through UDP module . Android application  then sends UDP packets to the socket and Hydroid application  receives the UDP packets through UDP module  of Hydroid OS .","As described above, UDP does not include handshaking for providing reliability or implicit data ordering. Accordingly, communication flow  may be suitable for communications between applications of Android OS  and Hydroid OS  where data reliability is not a primary concern. For example, communication flow  may be used for a Linux streaming audio client to receive a streaming audio signal from an Android streaming audio application or service. In this instance, it may be more important for the Linux streaming audio client to keep receiving packets through communication flow  rather than wait for handshaking or resending of any dropped packets.","As described above, in one embodiment an Android mobile OS and a Linux desktop OS (\u201cHydroid\u201d) run concurrently on the same shared kernel of a single mobile computing device. The Android mobile OS provides a mobile computing experience through mobile computing hardware and the Linux desktop OS provides a desktop computing experience through a secondary terminal environment having a user experience profile associated with the Linux OS. However, other OS combinations are contemplated as within various embodiments of the invention. For example, various aspects of the invention may be used to run Windows Mobile and Windows 7 on a shared kernel or sharing common kernel-mode processes. As another example, iOS and Mac OS X running on a shared kernel is also within the scope of various embodiments. Furthermore, aspects of the invention may be used advantageously by combinations of embedded OS's and desktop or mobile OS's running on a shared kernel.","The foregoing description has been presented for purposes of illustration and description. Furthermore, the description is not intended to limit embodiments of the invention to the form disclosed herein. While a number of exemplary aspects and embodiments have been discussed above, those of skill in the art will recognize certain variations, modifications, permutations, additions, and sub-combinations thereof.","The various operations of methods described above may be performed by any suitable means capable of performing the corresponding functions. The means may include various hardware and\/or software component(s) and\/or module(s), including, but not limited to a circuit, an application specific integrated circuit (ASIC), or processor.","The various illustrative logical blocks, modules, and circuits described may be implemented or performed with a general purpose processor, a digital signal processor (DSP), an ASIC, a field programmable gate array signal (FPGA), or other programmable logic device (PLD), discrete gate, or transistor logic, discrete hardware components, or any combination thereof designed to perform the functions described herein. A general purpose processor may be a microprocessor, but in the alternative, the processor may be any commercially available processor, controller, microcontroller, or state machine. A processor may also be implemented as a combination of computing devices, e.g., a combination of a DSP and a microprocessor, a plurality of microprocessors, one or more microprocessors in conjunction with a DSP core, or any other such configuration.","The steps of a method or algorithm described in connection with the present disclosure, may be embodied directly in hardware, in a software module executed by a processor, or in a combination of the two. A software module may reside in any form of tangible storage medium. Some examples of storage media that may be used include random access memory (RAM), read only memory (ROM), flash memory, EPROM memory, EEPROM memory, registers, a hard disk, a removable disk, a CD-ROM and so forth. A storage medium may be coupled to a processor such that the processor can read information from, and write information to, the storage medium. In the alternative, the storage medium may be integral to the processor. A software module may be a single instruction, or many instructions, and may be distributed over several different code segments, among different programs, and across multiple storage media.","The methods disclosed herein comprise one or more actions for achieving the described method. The method and\/or actions may be interchanged with one another without departing from the scope of the claims. In other words, unless a specific order of actions is specified, the order and\/or use of specific actions may be modified without departing from the scope of the claims.","The functions described may be implemented in hardware, software, firmware, or any combination thereof. If implemented in software, the functions may be stored as one or more instructions on a tangible computer-readable medium. A storage medium may be any available tangible medium that can be accessed by a computer. By way of example, and not limitation, such computer-readable media can comprise RAM, ROM, EEPROM, CD-ROM, or other optical disk storage, magnetic disk storage, or other magnetic storage devices, or any other tangible medium that can be used to carry or store desired program code in the form of instructions or data structures and that can be accessed by a computer. Disk and disc, as used herein, include compact disc (CD), laser disc, optical disc, digital versatile disc (DVD), floppy disk, and Blu-ray\u00ae disc where disks usually reproduce data magnetically, while discs reproduce data optically with lasers.","Thus, a computer program product may perform operations presented herein. For example, such a computer program product may be a computer readable tangible medium having instructions tangibly stored (and\/or encoded) thereon, the instructions being executable by one or more processors to perform the operations described herein. The computer program product may include packaging material.","Software or instructions may also be transmitted over a transmission medium. For example, software may be transmitted from a website, server, or other remote source using a transmission medium such as a coaxial cable, fiber optic cable, twisted pair, digital subscriber line (DSL), or wireless technology such as infrared, radio, or microwave.","Further, modules and\/or other appropriate means for performing the methods and techniques described herein can be downloaded and\/or otherwise obtained by a user terminal and\/or base station as applicable. For example, such a device can be coupled to a server to facilitate the transfer of means for performing the methods described herein. Alternatively, various methods described herein can be provided via storage means (e.g., RAM, ROM, a physical storage medium such as a CD or floppy disk, etc.), such that a user terminal and\/or base station can obtain the various methods upon coupling or providing the storage means to the device. Moreover, any other suitable technique for providing the methods and techniques described herein to a device can be utilized.","Other examples and implementations are within the scope and spirit of the disclosure and appended claims. For example, due to the nature of software, functions described above can be implemented using software executed by a processor, hardware, firmware, hardwiring, or combinations of any of these. Features implementing functions may also be physically located at various positions, including being distributed such that portions of functions are implemented at different physical locations. Also, as used herein, including in the claims, \u201cor\u201d as used in a list of items prefaced by \u201cat least one of\u2019 indicates a disjunctive list such that, for example, a list of at least one of A, B, or C\u201d means A or B or C or AB or AC or BC or ABC (i.e., A and B and C). Further, the term \u201cexemplary\u201d does not mean that the described example is preferred or better than other examples.","Various changes, substitutions, and alterations to the techniques described herein can be made without departing from the technology of the teachings as defined by the appended claims. Moreover, the scope of the disclosure and claims is not limited to the particular aspects of the process, machine, manufacture, composition of matter, means, methods, and actions described above. Processes, machines, manufacture, compositions of matter, means, methods, or actions, presently existing or later to be developed, that perform substantially the same function or achieve substantially the same result as the corresponding aspects described herein may be utilized. Accordingly, the appended claims include within their scope such processes, machines, manufacture, compositions of matter, means, methods, or actions."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the present invention are illustrated in referenced figures of the drawings, in which like numbers refer to like elements throughout the description of the figures.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
