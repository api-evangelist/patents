---
title: Network centric quality of service using active network technology
abstract: Systems and methods for improving network centric quality of service using active network technology are disclosed. In one embodiment, a method includes controlling how a packet is passed over at least one of the interfaces using a differentiated services portion of a network management architecture, monitoring a request for a Quality of Service (QoS) level from at least one QoS-aware application, and adjusting at least one service rate of packet travel controlled by the differentiated services portion based on at least one of the requested QoS level and an available bandwidth. In an alternate embodiment, the controlling of how a packet is passed over at least one of the interfaces includes using at least one of a queuing discipline, a class, and a filter.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07561521&OS=07561521&RS=07561521
owner: The Boeing Company
number: 07561521
owner_city: Chicago
owner_country: US
publication_date: 20041209
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This patent application is related to co-pending, commonly-owned U.S. patent application Ser. No. 60\/634,489 entitled \u201cMethods and Systems for Intelligent Network Management\u201d filed on Dec. 9th, 2004, which application is incorporated herein by reference.","This invention relates to computer networks, and more specifically, to improving network centric quality of service using active network technology.","Quality of service (QoS) is desired by most customers operating in a network centric organization (NCO). Traditional networks are based on destination-based routing and typically do not actively manage network resources (e.g., bandwidth (BW), routers, etc.) in determining resource allocation. Over-provisioning of the network to satisfy end-to-end user and application QoS requirements is not feasible for technical and economical reasons. Thus, there is a need for network management systems that better account for the dynamic link state and bandwidth characteristics in dynamic mobile environments.","The present invention is directed to methods and systems for improving network centric quality of service using active network technology. Embodiments of methods and systems in accordance with the present invention may better account for the dynamic link state and bandwidth characteristics in dynamic mobile environments.","In one embodiment, a method of managing a network having a plurality of interfaces includes controlling how a packet is passed over at least one of the interfaces using a differentiated services portion of a network management architecture, monitoring a request for a Quality of Service (QoS) level from at least one QoS-aware application, and adjusting at least one service rate of packet travel controlled by the differentiated services portion based on at least one of the requested QoS level and an available bandwidth. In an alternate embodiment, the controlling of how a packet is passed over at least one of the interfaces includes using at least one of a queuing discipline, a class, and a filter. In another embodiment, the adjusting of at least one service rate of packet travel includes notifying a kernel portion of a variation in the available bandwidth, and effecting a change in control of the packet rate of travel by the differentiated services portion.","The present invention relates to methods and systems for improving network centric quality of service using active network technology. Many specific details of certain embodiments of the invention are set forth in the following description and in  to provide a thorough understanding of such embodiments. One skilled in the art, however, will understand that the present invention may have additional embodiments, or that the present invention may be practiced without several of the details described in the following description.","Generally speaking, embodiments of the present invention use end-to-end resource allocation to help to ensure that QoS requirements of various traffic flows are at least partially satisfied.  is a schematic view of a plurality of QoS technologies  that may be used to achieve an end-to-end QoS provisioning in accordance with embodiments of the present invention. The QoS technologies  that enable performance assurance and service differentiation in a network stack , such as the Internet, can be broadly classified into two categories: resource allocation  and performance management .  illustrates resource allocation technologies  and performance management QoS technologies  and their scope of applicability within the network stack .","As shown in , the architectural components of resource allocation  may include network QoS management , application QoS management , and policy based management . Network QoS management  may include a set of industry standards  (e.g., IEEE 802.1p) at a link layer , and integrated services  and differentiated services  at a network layer  and a transport layer . Application QoS management  may include middleware  and QoS-aware applications  at the application layer , presentation layer , and session layer  of the network stack . Finally, policy based management  is applicable to all layers of the network stack .","One possible objective of performance management  is to determine and establish a path that each traffic flow should take in order to maximize the number of end-to-end user application sessions whose QoS requirements have been satisfied while maximizing the overall network utilization. Traditional networks are based on destination-based routing. However, in order to achieve the performance management objectives, the network may preferably have the ability to establish alternate paths for traffic flows between source\/destination pairs through efficient provisioning of resources and greater control of the network flows. Thus, as shown in , architectural components of performance management  may include Multi-Protocol Label Switching (MPLS)  and constraint-based routing  at the network layer  and traffic engineering  that is applicable to all layers of the network stack .",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2","b":["200","210","200","212","214","216","252","254","216","230","214","216","230","214","214","250","230"]},"As further shown in , the network QoS management architecture  also includes components within the user mode  and kernel mode  portions of the operating system. QoS-aware Applications  interact with QoS Service Provider  and Socket API . QoS-aware Applications  establish the session with peer application via QoS Service Provider . QoS Service Provider  performs session admission control and appropriately performs QoS provisioning for the requested session. Once QoS Service Provider  accepts a session connection request from QoS-aware Applications , it then establishes socket level session via Socket API . Following the establishment of the session between the QoS-aware Applications  and the peer application, QoS-aware Applications  transmit and receive data via Socket API . Legacy applications  interact with peer applications by setting up sessions via Sockets API . They also transmit and receive data via Socket API . Socket API  interact with AF_INET  and NETLINK . Socket level session communication with peer entity is directed to and from AF_INET . QoS Service Provider  uses the NETLINK  to configure and monitor underlying Traffic Control (TC) components  such as a scheduler. In one embodiment, the scheduler may be a Differentiated Services (DiffServ) scheduler. In addition, QoS Service Provider  also interacts with NETLINK  which in turn interacts with the underlying Device Driver  via the Emulated Filter Driver  to query and obtain Link State Events .","In one particular embodiment, the network QoS management architecture  includes a standard Differentiated Services (DiffServ) portion. Various Differentiated Services architectures are known and may be suitable for this purpose, including, for example, those architectures generally disclosed in by S. Blake et al., The Internet Society, RFC 2475, December 1998, incorporated herein by reference. Generally, the standard DiffServ portion assumes a stable link bandwidth capacity and interconnectivity state in QoS provisioning, but this is generally not valid within a dynamic ad hoc mobile heterogeneous network environment. Thus, embodiments of the present invention include an extension portion to account for the dynamic link state and bandwidth characteristics in such a dynamic mobile environment, thereby dynamically updating the packet transmit scheduler as link states change.",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3","b":["300","302","304","306","308","302","302","304","302","304","306","304","304","302","306","310","310"]},"In one particular embodiment, the QoS Service Provider  may be adapted to look at local statistics acquired through queries to rtnetlink socket connections. The QoS Service Provider  may also request statistics locally or from another host on the network through some mechanism such as an SNMP subagent that implements a DiffServ Management Information Base (MIB). In further embodiments, the QoS Service Provider  may provide two main services. A first service is a QoS API function through which QoS-aware applications may request certain levels of QoS for network connections. A second service is a mechanism for the underlying DiffServ implementation to adjust the service rates of its classes based on the available bandwidth as reported by the network device.","The QoS Service Provider  may also be implemented as a user-level daemon that listens on a UNIX address family socket (i.e. local socket) for requests from the QoS API and also listens on a netlink address family socket for reported changes to the available bandwidth of the network device. The QoS API function may be implemented as a library of C functions that send the QoS requests from the application to the QoS Service Provider  through the local socket. The QoS Service Provider  may attempt to map a QoS request to a DiffServ class that will be able to provide the requested level of QoS. If successful, the QoS Service Provider  will create a classifier to map the packets of that network connection to the appropriate DiffServ class. The QoS API will then just use the native socket functionality of the operating system to create the actual network connection.","In one embodiment, the QoS Service Provider  manages the DiffServ implementation on only one network interface and does not check that the QoS API connection actually goes through the monitored interface. In alternate embodiments, the QoS Service Provider  is adapted to manage multiple network interfaces. The QoS Service Provider  may be adapted to process Transmission Control Protocol (TCP) connections, User Datagram Protocol (UDP) connections, or any other suitable protocols and connections.","As noted above, embodiments of the present invention include an extension portion to account for the dynamic link state and bandwidth characteristics in a dynamic mobile environment, thereby dynamically updating the packet transmit scheduler as link states change. The extension portion is adapted to modify the service rates of its classes based on the bandwidth available to the network device. This is especially important for wireless devices. The problem can be divided into two parts. The first part is how the device notifies the kernel mode  of the new bandwidth. The second part is how the kernel mode  effects changes in the standard DiffServ portion based on the new bandwidth. Device notification to the kernel mode  of the new bandwidth may be accomplished by the specific device driver associated with the given interface.","Regarding the second part of the problem, how the kernel mode  effects changes in the standard DiffServ portion based on emulated new bandwidth updates, a hierarchical token bucket (HTB) qdisc may be used as a scheduler with a plurality of classes. The plurality of classes may include a separate HTB class for each DiffServ class of expedited forwarding (EF), the four classes of assured forwarding (AF, AF, AF, AF), and best effort (BE). Each class may be assigned a guaranteed rate and a maximum rate. In addition, the filters that classify packets into the various classes can have policers attached to them that meter the flows going into particular classes in order to perform such actions as dropping or marking. Each policer has a specified rate. The specified rates may be specified as absolute values. In a static environment the network administrator can simply divide up the available bandwidth, as per local policy. However, in a dynamic environment, the sum of the rates of the service classes may be unequal to the bandwidth actually available to the network device at least some of the time.","In one embodiment, the HTB class for EF is a class of the HTB qdisc, while all the other classes are subclasses of another class of the HTB qdisc at the same level of the EF class. This may be done to isolate the EF class from the other classes, while allowing the other classes to borrow bandwidth from each other if they are not being used. In preferred embodiments, the EF class has the highest priority, the AF classes have the next highest priority and the BE class has the lowest priority. Thus, the AF classes get the first use of any unused bandwidth and the BE class gets to borrow any extra bandwidth only if the AF classes are not using it.","The architecture  may be adapted to perform a notification of a user-level daemon program by the kernel mode (or kernel portion)  that the available bandwidth has changed, and may be further adapted to perform a calculation of new rates for the HTB classes and the policers based on the new bandwidth and the update of the corresponding TC elements in the kernel mode  by way of rtnetlink sockets. In one embodiment, the notification of the user-level daemon of the change in bandwidth is performed using the NETLINK_ROUTE family of the AF_NETLINK socket protocol, a socket protocol generally known in the relevant art. The AF_NETLINK protocol may be used to transfer information between kernel modules and user space processes. The AF_NETLINK protocol also has a broadcast capability. More specifically, the daemon process may open a NETLINK_ROUTE socket and, when binding to that socket, may specify that it wishes to receive broadcast information on an RTMGRP_LINK group. The kernel mode  may then send a broadcast message to the RTMGRP_LINK group whenever the link status has changed on a network device. A bandwidth component may be added to the broadcast message.","In the event that it is desirable to emulate a change in link status as if it was reported by the network device through the device driver, a file in a \/proc file system may be used. In one embodiment, files in the \/proc file system are simply linked to functions in the kernel mode  that are executed whenever any user-level process reads from one of the \/proc files. The functions in the kernel mode  may return data from the kernel mode  as if the data were in the files. In one particular embodiment, a file \/proc\/net\/bw-eth1 may be implemented with a function that will change the reported bandwidth value periodically as well as call the netlink function that initiates the broadcasts to the RTMGRP_LINK group. In alternate embodiments, the \/proc file system based mechanism may be implemented to emulate dynamic changes in link state, or alternately, the device driver  () will monitor the actual links state  and report updates.","In operation, a user-level daemon may initially read a configuration file that specifies the percentages of available bandwidth that are to be allocated to each DiffServ class, the DiffServ class to HTB class mapping, a list of policers and their percentages, and a list of which filters are using which policers. The daemon may then request to be notified of RTMGRP_LINK group messages. When the daemon receives notification of a bandwidth change through the netlink socket, it may recalculate all of the rates, and may make changes to the appropriate qdiscs and filters in the kernel mode  by way of rtnetlink sockets. The daemon may also notify any application that has requested to be notified of any change in the link status as described more fully below.","In one embodiment, the architecture  includes a link state change notification capability. As mentioned above, the AF_NETLINK socket protocol has a broadcast capability. A broadcast function in \/usr\/src\/linux\/net\/core\/rtnetlink.c that performs a broadcast for the RTMGRP_LINK group is, in one embodiment, designated as rtmsg_ifinfo. The broadcast function first calls a rtnetlink_fill_ifinfo function and then calls a netlink_broadcast function to send the message to all processes listening to the RTMGRP_LINK group. The rtnetlink_fill_ifinfo function retrieves data from the netdevice data structure and fills in the socket message buffer. It also uses the message tags IFLA_*, such as IFLA_ADDRESS, IFLA_MTU, etc., to indicate what data is being returned in the socket message buffer. These tags are defined in a folder, such as \/usr\/src\/linux\/include\/linux\/rtnetlink.h. A flag tag IFLA_UNSPEC may be used to return the new bandwidth value. The new bandwidth value may be stored in the netdevice data structure, or alternately, it may be stored in a new global variable, such as a global variable called bandwidth_for_our_test. This variable may, for example, be set by the function tied to the \/proc\/net\/bw-eth1 file. Another function, designated as bw_get_info, may return the value of bandwidth_for_our_test whenever \/proc\/net\/bw-eth1 is read. It may also have a counter that causes it to toggle the value of bandwidth_for_our_test. In one particular embodiment, for example, the bw_get_info function may toggle between 10 Mbps and 100 Mbps every twenty reads. Whenever the bw_get_info function changes the value of bandwidth_for_our_test, it may also call another function designated rtmsg_ifinfo in order to initiate an RTMGRP_LINK group broadcast message. A perl script may be adapted to periodically drive the changes, for example, at 1 second intervals.","The architecture  may be adapted to perform a traffic control function. In one embodiment, when the user-level daemon program starts, the Linux Traffic Control (TC) elements may have no concept of the different DiffServ classes, so the architecture  must be told which HTB classes represent which DiffServ classes. The architecture  may also need to be told what percentage of available bandwidth is to be allocated to the different DiffServ classes, as well as what percentages to use for the different policers and which filters use which policers. The information about filters may be necessary since the parameters of the policers may not be changeable. In one embodiment, rates may be changed by changing the filters and attaching a new policer to the new filters with the newly calculated rates, effectively discarding the old policers.","After reading in the configuration information, the daemon may open a socket connection with the AF_NETLINK socket protocol and then may bind to that socket after setting the nl_groups field in the sockaddr_nl data structure to RTMGRP_LINK group. The daemon may then listen to the socket, using select, and may wait for any broadcast message. After receiving a link-change message, the program may retrieve the new bandwidth value from the netlink message buffer and may recalculate the rates for the HTB classes and policers based on the percentages defined in the configuration file. All the necessary information may then be put into netlink message buffers and sent to the TC elements in the kernel mode  by way of a netlink socket.","The architecture  may be further adapted to allow QoS-aware applications to call a set of QoS enhanced Socket functions for QoS provisioning, which may, in turn, use the standard BSD Socket functions for the actual network connection. Based on the information in a QoS request from the QoS-aware application, the QoS Service Provider  will map the connection to the appropriate QoS provisioning mechanism. For example, if the underlying QoS mechanism is DiffServ, the QoS Service Provider  may set up TC configurations in order to route packets from that connection into the assigned DiffServ class, and may perform DSCP marking based on the configuration associated with a given tuple space. The QoS Service Provider  may also be adapted to provide notification to remote applications when network resource conditions change.","The QoS Service Provider  may be further adapted to use the QoS API functions to send strings to and from a server, in order to illustrate the use of the API and verify that the QoS API functions are performing correctly. In one particular embodiment, for example, an FTP client in the generally-known netkit-ftp-0.17 may be modified to call the QoS API functions.","As described above, the QoS Service Provider  may listen on an AF_UNIX socket, waiting on messages from applications using the QoS API. Upon receiving a request, the QoS Service Provider  may attempt to satisfy the request and then return success or failure. The QoS Service Provider  may also be adapted to map a request to a DiffServ class in the underlying DiffServ implementation. It could be enhanced to use IntServ as well, using some runtime option to decide which mechanism to use. The QoS-aware application would be unaware which QoS provisioning mechanism was being used.","In one aspect, a QSocket function creates an endpoint for communication and returns a file descriptor on success, or \u22121 if an error occurred. The QSocket function may open a standard socket and send a request message to the QoS Service Provider , which may include the file descriptor of the socket, the process id of the application, and the parameters in the qos_info structure. The QoS Service Provider  may use the file descriptor of the socket and the process id of the application as the unique index for this connection. Since the socket call does not specify an endpoint, the QoS Service Provider  cannot map this connection to a DiffServ class yet, so it merely creates a soft state for this connection and saves the parameters in the qos_info structure.","In one particular embodiment, a QConnect function connects to a specific host and port combination and returns a zero on success, or \u22121 if an error occurred. The QConnect function may call the standard connect function which may assign a local address and port number. The QConnect function may then call getsockname to retrieve the assigned local address and port number. The destination address and port number are retrieved from the sockaddr structure. The QConnect function may finally send a setup message to the QoS Service Provider , which consists of the file descriptor of the socket, the process id of the application, the local address and port, and the destination address and port. The QoS Service Provider  may then analyze the DiffServ status on the network interface for this connection. The QoS Service Provider  may first consider the value of the qosmech field in the qos_info structure that was stored in the call to QSocket, which may have the value of QOS_ANY, QOS_DIFFSERV, or QOS_INTSERV. If the qosmech field has the value of QOS_ANY, the QoS Service Provider  may consult two parameters in the flow_spec substructure of the qos_info structure. If there is a latency requirement, the QoS Service Provider  attempts to map this connection to the EF class. The QoS Service Provider  compares the rate requirement to what is available for that class (allocated rate minus current usage). If there is not a latency requirement, the QoS Service Provider  attempts to map this connection to an AF class in the same way as for the EF class. If the qosmech field has the value of QOS_DIFFSERV, the QoS Service Provider  will attempt to map this connection to the DiffServ class as specified in the diffservclassrequest field of the qos_info structure in the same manner as described above. In one particular embodiment, the QOS_INTSERV mechanism may be treated in the same manner as QOS_ANY. If the request is successfully mapped to a DiffServ class, the QoS Service Provider  may then create a TC filter to map packets for this connection to the HTB class that represents the selected DiffServ class and return success to the QConnect function. If the QoS Service Provider  is unsuccessful, it returns failure to the QConnect function, which will close the socket and return an error.","A QChange function updates the QoS information associated with an existing file descriptor and returns a zero on success, or \u22121 if an error occurred. The QChange function may attempt to map the request to a DiffServ class as described in the QConnect function. If successful, the QChange function may have been mapped to the same class or a different class. If unsuccessful, the QChange function will retain the current mapping.","A QClose function closes the associated file descriptor created via a QSocket function and returns a zero on success, or \u22121 if an error occurred. The QClose function will close the standard socket and send a clear request to the QoS Service Provider , which includes the file descriptor of the socket and the process id of the application. The QoS Service Provider  may free all memory associated with this connection, delete the TC filter for it, and, if the application had requested any notifications, may remove the message queue to that application and any pending event notifications.","A QAttach function may associate an existing socket file descriptor with QoS information and may return a zero on success, or \u22121 if an error occurred. A QSendto function may send a message over an existing QSocket to a peer and returns the number of bytes sent on success, or \u22121 if an error occurred. A QSend function sends a message over an existing QSocket in connected state to a peer and returns the number of bytes sent on success, or \u22121 if an error occurred. The QSend function will directly call the standard Send function.","A QStateUpdateNotification function sets a callback function and returns a zero on success, or a \u22121 if an error occurred. The QStateUpdateNotification function will send a callback message to the QoS Service Provider , which may include a file descriptor of the socket, a process id of the application, and an event type from the notification_type structure. The QoS Service Provider  will add this request to the pending event list. The QStateUpdateNotification function may add the file descriptor, event type, context block, and callback function to its pending event list. When there is an event of that type, the QoS Service Provider  may remove the notification from the pending event list, create a message queue for the application process and put a message on the queue. In one particular embodiment, every function in the QoS API immediately checks to see if there are any messages on its message queue. If there are, then the function reads each message, matches it up with the appropriate entry in it pending event list, removes that entry, and calls the designated callback function.","A QStatus function retrieves status information associated with an existing file descriptor and returns a zero on success, or \u22121 if an error occurred. The QStatus function will send a status message to the QoS Service Provider , which may include the file descriptor of the socket and the process id of the application. The QoS Service Provider  may retrieve the current statistics from the DiffServ implementation and may return the data to the QStatus function, which fills in values of the qos_status structure.","While preferred and alternate embodiments of the invention have been illustrated and described, as noted above, many changes can be made without departing from the spirit and scope of the invention. Accordingly, the scope of the invention is not limited by the disclosure of these preferred and alternate embodiments. Instead, the invention should be determined entirely by reference to the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Preferred and alternate embodiments of the present invention are described in detail below with reference to the following drawings.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
