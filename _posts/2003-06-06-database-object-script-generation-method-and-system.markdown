---
title: Database object script generation method and system
abstract: An automatic scripting of objects of various complexities in a relational database includes creating a hierarchical object tree from a single or multiple reference object reference passed into the system. Duplicate object references are eliminated in the formation of the hierarchical tree. A dependency list is generated from the hierarchical tree. The dependency list represents a linear list of objects sequenced in the manner they should be created to satisfy dependency constraints. A script is generated from the dependency list which permits the deployment of varying complexity objects onto a target database. Script is generated by instantiating each object in the dependency list and calling a pre-constructed script method on the object. Each phase may be operated independently.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07136868&OS=07136868&RS=07136868
owner: Microsoft Corporation
number: 07136868
owner_city: Redmond
owner_country: US
publication_date: 20030606
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS"],"p":["The invention relates generally to the field of computer databases and more specifically to the field of automatic script generation for complex objects in relational databases.","The structured query language (SQL) is an American National Standards Institute (ANSI) standard used to communicate with a relational database. SQL is the standard language for relational database management systems. SQL statements are used to perform tasks such as update data or retrieve data from a relational database. Although many database systems use SQL, many of them also have their own additional proprietary extensions that are usually only used on their system. However, the standard SQL commands such as \u201cSelect\u201d, \u201cInsert\u201d, \u201cUpdate\u201d, \u201cDelete\u201d, \u201cCreate\u201d, and \u201cDrop\u201d can be used to accomplish many things that one desires to do with a relational database.","Relational databases are generally structured as tables containing rows and columns. The data entries for any row and column intersection, or cells, normally conform to a set of data constraints that are used to define the data types allowed in the cells. One historical problem with such data entries is the lack of definition for large and complex objects which may be desired to be placed in a database. Constraints on the SQL data types utilized generally limit the kinds of data that can be entered into a relational database such as SQL. A large object, if placed into a SQL database, could slow down database processing or utilize system resources such as memory and processing time to accommodate one or more bulky and complex objects.","Scripting queries and utilizing objects in a relational database such as SQL can be both time consuming and expertise intensive. The author of such script must understand the dependencies of the new and complex object in relation to other objects in order to properly instantiate the object along with appropriate metadata onto the target relational database. This scripting expertise may be beyond the experience of the average user who wishes to utilize his relational database for tracking and searching of complex objects related to his business, for example. Alternately, system managers may use scripting to assist in the maintenance of relational databases. This scripting activity takes time and care to prepare and run. Auto generation of script for relational databases concerning complex objects currently cannot be easily accomplished.","Thus, there is a need for a unifying representation for objects desired to be referenced and acted upon in a SQL database. Additionally, there is a need for a mechanism to generate script to facilitate the deployment of objects into relational databases such as SQL for both application and system maintenance work. The invention addresses the aforementioned needs and solves them with various systems, methods and techniques that create complex dependency trees and lists and modify these to generate script without requiring intricate knowledge of the relational database metadata structures.","The invention includes a scripter for relational databases that may be applied specifically to a SQL database management system. Multiple independent software modules or a concatenation of multiple functions input object references and output script. An exemplary phase or module of the invention creates a hierarchical object tree from one or more object references that are passed in. The complex objects, which use object references, may be expressed with uniform resource names. The module eliminates duplicate object references and produces a dependency tree. The module also offers the opportunity to edit the tree as it is being created as well as after completion.","Another exemplary module or phase inputs a hierarchical dependency tree, either from a user or from the previous module and produces a dependency list. The dependency list is a linear list expressing the order of creation that an object may use in order to satisfy dependency constraints. This module also offers the opportunity to edit the dependency list as it is being created as well as after completion.","Another exemplary module or phase generates script from a dependency list. The dependency list may be either user generated or it may be input from a previous module. This module instantiates the object on the dependency list and calls a scripting method corresponding to the object. This module offers a wide range of flexibility for the user or controlling program to edit the script as it is being generated as well as after completion.","Overview","The invention provides for automatic scripting of objects of various complexities in a relational database. Technologies are provided wherein a dependency list is input into the process and a dependency or hierarchical tree is generated reflecting the relationships of the various objects. The dependency or hierarchical tree may then be input into another portion of the process wherein the hierarchical tree is processed into an ordered dependency list. The dependency list may then be processed into a script that can be used to deploy relational database objects in a given target database. The various phases or modules of the invention may be operated separately or may be operated in tandem.","Exemplary Computing Device",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},"Although not required, the invention can be implemented via an operating system, for use by a developer of services for a device or object, and\/or included within application software that operates according to the invention. Software may be described in the general context of computer-executable instructions, such as program modules, being executed by one or more computers, such as client workstations, servers or other devices. Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer configurations. Other well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers (PCs), automated teller machines, server computers, hand-held or laptop devices, multi-processor systems, microprocessor-based systems, programmable consumer electronics, network PCs, appliances, lights, environmental control elements, minicomputers, mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network\/bus or other data transmission medium. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices, and client nodes may in turn behave as server nodes.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["100","100","100","100"]},"With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer system . Components of computer system  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus).","Computer system  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer system  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, Random Access Memory (RAM), Read Only Memory (ROM), Electrically Erasable Programmable Read Only Memory (EEPROM), flash memory or other memory technology, Compact Disk Read Only Memory (CDROM), compact disc-rewritable (CDRW), digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computer system . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer system , such as during startup, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer system  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD ROM, CDRW, DVD, or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer readable instructions, data structures, program modules and other data for the computer system . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer system  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface , which may in turn communicate with video memory (not shown). In addition to monitor , computer systems may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer system  may operate in a networked or distributed environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer system , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks\/buses. Such networking environments are commonplace in homes, offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer system  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer system  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer system , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Various distributed computing frameworks have been and are being developed in light of the convergence of personal computing and the Internet. Individuals and business users alike are provided with a seamlessly interoperable and Web-enabled interface for applications and computing devices, making computing activities increasingly Web browser or network-oriented.","For example, MICROSOFT\u00ae's .NET\u2122 platform, available from Microsoft Corporation, One Microsoft Way, Redmond, Wash. 98052, includes servers, building-block services, such as Web-based data storage, and downloadable device software. While exemplary embodiments herein are described in connection with software residing on a computing device, one or more portions of the invention may also be implemented via an operating system, application programming interface (API) or a \u201cmiddle man\u201d object between any of a coprocessor, a display device and a requesting object, such that operation according to the invention may be performed by, supported in or accessed via all of .NET\u2122's languages and services, and in other distributed computing frameworks as well.","Exemplary Embodiments of the Invention","A relational database management object scripter generates script for objects. In an embodiment, the objects are implemented in a SQL database. The invention may be described in terms of its general applicability as well as in terms of the SQL environment embodiment. An example of such script is Transact-SQL script. Scripting permits the automation of system management tasks involving objects on a SQL database. The scripter object is a object that exists in the SQL management object namespace, but there is no SQL management object which depends on the use of the scripter. The scripter may use two operations that are implemented by each instance class: the create and the drop operation. Therefore, instance objects are only responsible for scripting their own instance in order to generate script text for either a creation or a deletion of these objects on SQL database. As a result, the scripter is responsible for the rest of the functionality including finding dependencies, outputting script to memory, file or display, calling the instance objects in order to script these objects, and controlling the context and progress of a scripting operation.","A scripter object model may be used in part to implement the invention. The scripter object model is one entry point for scripting. The object model holds context of the scripting operations. Objects in the model may be uniquely identified by the use of a uniform resource name. For example, a SQL management object that has a database name of \u201cpubs\u201d that contains a table \u201cauthors\u201d owned by \u201cdbo\u201d may be uniquely referenced by the uniform resource name:","Server\/Database[@Name=\u2018pubs\u2019]\/table[@Name=\u2018authors\u2019 and schema=\u2018dbo\u2019]","The use of a uniform resource name provides a standard format that uniquely identifies the object and comports with other standard uses allowing flexibility and future growth in application of the invention.","The scripter operates in a number of distinct phases that allows intermediate manipulation of the underlying data structures. These phases can be executed as a whole, allowing minimal manipulation, or can be executed independently, which gives maximum freedom of amending the underlying data structures. The exemplary phases that the scripter executes are to discover dependencies, generate a dependency list, and generate script from the dependency list.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2","b":"260"},"Each phase is desirably decoupled, and the input for each phase does not necessarily need to be generated by the scripter. The user program can create its own data structures based on its own internal algorithms and provide these data structures to the scripter as input. Therefore, the scripter phases can be seen as three individual components.","Returning to , the discovery phase receives object references  from the user program  to initiate the dependency discovery mechanism . The objects may be referenced using uniform resource names. Dependency data and instance data (metadata)  are called in from the system to aide in the discovery process. In particular, dependency data may be located via dependencies retrievable from the server or system catalog . It is noted that the granularity of the dependency also determines the granularity of the dependency discovery operation. Once a dependency between two or more objects is discovered using a dependency search and discovery or detection algorithm, object relationship data  is entered into a dependency tree . The process may return  to the discovery mechanism  to continue the creation of entries for the dependency tree. At the end of the process, a dependency tree  is generated and made available  to the user program .","The dependency search and detection technique may be described in terms of its operations. Additionally, the algorithm may be described as graphing parent objects, graphing the original object, and then graphing child objects. The graphing is essentially the constructing of a dependency tree. Initially, the dependency discovery mechanism  sees the object reference and calls the object as an enumerated object. Actual instantiation of the object is not needed at this point, therefore the object itself is not called; only a reference for the object need be invoked. The object is added to the known object list. The dependency discovery mechanism finds each parent of the added object that is not in the known object list. The dependency mechanism may then call the parent object and adds it to the known object list. When the highest tier parent has been detected, the highest tier parent is added to the dependency tree, which is a hierarchical tree. The dependency discovery mechanism then searches downward for all children of objects on the known object list. It adds the original object to the dependency tree as well as children of discovered parents, the original object, and child and grandchild objects. This recursive algorithm generates correct dependency ordering.","Phase  of  involves dependency list generation. A dependency tree may be acquired from phase  () or it may be acquired via an interface  to the user program . In either case, a dependency tree  is received and the list generation mechanism  is activated to the task of generating an object list, which is also known as a dependency list, . The list generation mechanism  interfaces ,  with the dependency tree  and instance data (metadata)  to produce an entry  to an object list . The object list entry may be produced once an object and its relational data are detected. The process returns to read additional items from the dependency tree and generates an object list until the dependency tree elements have been exhausted. As events such as object list entries are detected, events  are generated to offer an opportunity to the user program to manipulate the process by editing the object list. At the end of the process, an object or dependency list,  is generated and made available  to the user program  and is fully editable by the user program.","Phase  of  generates script (e.g. Transact-SQL script) via a script generation mechanism  using an object list and scripter options . The object list may be the same object list as was generated by the previous phase  or may be an object list received via an interface  to the user program . In either event, the script generation mechanism  receives scripting options  selected or defaulted by the user program along with instance data (metadata) . The script generator mechanism  may generate script entries  as the object list  is processed , . As the script  is being generated, events  such as new entries or opportunities to edit the generated script may be presented to the user program . Eventually, the object list  is fully processed and a full script  is generated. The process may then deliver the script  to the user program for subsequent processing or delivery to a user or an equivalent interface.","As is shown in , the overall process of scripting may be viewed as one process starting with reception of object references  and ending with the production of script . Alternately, the process may be seen as multiple independent processes which can be concatenated. ,  and  depict the individual processes of phases ,  and , respectively.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 3","b":["300","310","320"]},"As dependencies are detected, a dependency or hierarchical tree is generated  representing the dependency data and the related objects. The algorithm that is used to create the hierarchical tree or graph eliminates duplicates , as it is possible that while scripting a complex hierarchy, references occur to the same object. These objects that are referenced more than one time may be scripted out. The dependency tree or hierarchical tree may include parent, first child, next sibling, grandchildren, and great grandchildren type dependency structures, for example. While the dependencies are being detected, the process tests if the dependency tree is complete . If not, the process may allow the editing of objects . If no edits  are requested, the process continues by moving to the next object reference . If edits  are desired, the tree can be edited . For example, a deleted object may result in not only the deletion of an object but also all subsequent child objects in a relational branch. This allows users to manipulate or filter objects before they are added to the final graph. After an edit is completed, the process moves to the next object reference  and continues the search for dependency data .","If no object edits are requested by either a controlling process or a user, the dependency detection  continues to the next object reference and the search for dependency data  resumes. Eventually, the dependency tree or hierarchical tree is completed  and the dependency tree is made available  as an output  to a subsequent process or as a user output.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 4","FIG. 3"],"b":["400","410","399"]},"Returning to , the dependency discovery walk method  continues with the detection of relational dependencies  derived from the dependency tree. As dependencies are detected, the process generates a dependency list entry . The dependency list is preferably a linear list which lists the order in which an object should be created in order to satisfy dependency constraints. For example, a user defined data type may have to exist as part of the object, possibly as metadata, prior to a table being created that relies on the object or user data type.","Assuming the process is not complete on the first pass through, , the process  allows an edit to the created list. If the list is to be edited , then the edit may be allowed , wherein a removal or modification of the referenced object in the dependency list may be made. After the edit is complete, the process continues to the next object in the dependency tree  and the detection for relational dependencies continues . If an edit was not desired, , then the process progress is noted  and the program indexes to the next tree object and the continued detection of relational dependencies .","Eventually, the process iterates until the tree has been fully checked and the process of dependency list entry creation completed . The dependency list may then be made available  to either a subsequent process or an output  for user availability.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 5","FIG. 4","FIG. 4"],"b":["500","510","499","500","520","530","540"]},"Assuming the process is not complete , the process  allows for the editing of the script . If edits are desired, the user or other controlling process may edit the script  and then continue to the next object in the dependency list  allowing the next instantiation of the next object reference . If edits are not desired , a progress notification is indicated to a controlling process or user  and the process  continues to the next object reference for instantiation.","Eventually, the process steps through all of the objects on the dependency list and the process is complete . Thereafter, the accumulated script is made available  to a subsequent process or as an output for user availability .","It should be noted that the processes in ,  and  may be modified to either include or exclude progress notification at any point or editing at any point in the process without deviating from the intent of the invention. For example, in , a script progress monitor point may be placed after a script accumulator write , or after a completion check , or after an edit , or after the script is made available  without varying from the invention. This modification of optional point monitoring to the flow diagram applies equally well to ,  and  without variation of the spirit of the invention.","An embodiment of the current invention is presented in the architecture represented by the uniform modeling language (UML) diagram of . The UML diagram  pictorially describes each class within the scripter object model. This embodiment assumes the utility is within a SQL database. The dependency walker  provides functionality to discover dependencies or relationships between classes that are contained in the SQL Server database. This is the base class for the scripter class. The dependency walker  uses a filter delegate  and a progress report delegate . The filter delegate  is an event that allows modification and\/or rejection of classes that are found during the discovery phase. The progress report delegate  is an event that provides progress information about the dependency and\/or scripting phase progress.","The scripter  is the main scripting class that exposes scripting functionality to the end-users. The scripter  uses a progress report delegate  and a error event delegate  The scripting options  is a class that allows modification of the scripter  behavior. The scripting options  is exposed as a property of the scripter  class. However, the scripting options class  can be instantiated separately which allows this class to be passed in as an argument of the script method on an individual class.","The dependency node class  contains the URN as the object reference. The dependency node  class is the base class for all dependency tree or list classes. The dependency tree node class  is that class which holds information about parent and child relationships. It extends the dependency node class . The dependency tree class  contains scripter relationships. This class may extend the dependency tree node class . The dependency tree class  is exposed as a property of the scripter class .","The array list  is a standard class from the .NET framework that can hold references in a linear list of 0 to n classes. The array list class serves as the base list for the dependency list class . The dependency list class  may hold a linear list of the dependency list node  classes It is used by dependency list  class and is exposed as a property of the scripter class . The dependency list node  contains information about whether or not object was part of the original list, (i.e., root object). It extends the dependency node class .","According to one embodiment of the invention, the scripter may have options allowing flexibility in both operation and utility. The process of  may also be manipulated by applying a filter. This filter may be called during phases  and  allowing objects to be removed or modified during these phases. The scripter generator may implement a property that can be used to exclude objects (including child or lower tier objects). Furthermore, objects that are modified during one of the scripting phases may also be scripted out including modifications.","Object names can be changed by modifying a naming property, if available on the object. The objects do not need to be persisted for that purpose. If desired, the schema can be changed by setting a schema property, if available on the object. A scripting error event may be set to receive errors that occur during the script creation phase. It is contemplated to continue when an error occurs (i.e., when an object cannot be found on the server) by allowing an option to continue on an error occurrence.","System objects may be scripted to allow users to create new (non-system) objects based on the structure of a system object. The following scripting rules may apply to system objects:","(1) Users should be allowed to pass in a system object to the scripter and generate script;","(2) This script should not be executed on a server without prior modification, as the server may not allow system objects to be created; and","(3) If the user passes in multiple objects and one of the objects is a system object, the system object may be allowed. An option to stop scripting if a system object is detected during discovery may be selected. This may be important when scripting out an entire database, or a large number of objects including dependencies.","The different script operations are used to script one or more objects in one pass. Optionally, a filter function can be passed that can be used to filter out uniform resource names which are used to uniquely identify objects. This filter is called when an object is added to the dependency tree during discovery phase (e.g., phase  of ). This can be helpful for customization purposes. A filtered object and all of its dependencies are not scripted.","In another embodiment, scripting options may be provided as part of the invention. These options allow a user or a controlling program, such as an executive or an application program, to exercise control over the scripting process. Some of the options are described below:",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Script Output Format Options"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Scripter Option","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Append To File;","Append to indicated output file. By default, Script"]},{"entry":[{},"method overwrites the existing file."]},{"entry":["ANSI File;","Generated script file uses multibyte characters."]},{"entry":["Drops;","Generate Transact-SQL to remove referenced"]},{"entry":[{},"component. Script tests for existence prior to"]},{"entry":[{},"attempting to remove component."]},{"entry":["Encrypt PWD;","Encrypt passwords with script."]},{"entry":["Include Headers;","Generated script is prefixed with a header containing"]},{"entry":[{},"date and time of generation and other descriptive"]},{"entry":[{},"information."]},{"entry":["Include If","Transact-SQL creating a component is prefixed by a"]},{"entry":["Not Exists;","check for existence. When script is executed,"]},{"entry":[{},"component is created only when a copy of the named"]},{"entry":[{},"component does not exist."]},{"entry":["No Command","Individual Transact-SQL statements in the script are"]},{"entry":["Term;","not delimited using the connection-specific command"]},{"entry":[{},"terminator. By default, individual Transact-SQL"]},{"entry":[{},"statements are delimited."]},{"entry":["Schema Qualify;","Object names in Transact-SQL generated to remove an"]},{"entry":[{},"object are qualified by the owner of the referenced"]},{"entry":[{},"object. Transact-SQL generated to create the"]},{"entry":[{},"referenced object qualify the object name using the"]},{"entry":[{},"current object owner."]},{"entry":["Schema Qualify","Schema qualify table references for foreign key"]},{"entry":["Foreign Keys;","constraints."]},{"entry":["Timestamp","When scripting object creation for a table or user-"]},{"entry":["To Binary;","defined data type, convert specification of timestamp"]},{"entry":[{},"data type to binary."]},{"entry":["To File Only;","Most SQL object scripting methods specify both a"]},{"entry":[{},"return value and an optional output file. When used,"]},{"entry":[{},"and an output file is specified, the method does not"]},{"entry":[{},"return the script to the caller, but only writes the script"]},{"entry":[{},"to the output file. Specify this option whenever string"]},{"entry":[{},"output is not desired, as scripting out dependencies can"]},{"entry":[{},"potentially yield a very large string."]},{"entry":["Unicode File;","Unicode output is generated by default."]},{"entry":["Login SID;","Include security identifiers for logins scripted."]},{"entry":["DDL Header","Only script the DDL header for objects that have a"]},{"entry":["Only;","body text, such as Stored Procedure. Default is to"]},{"entry":[{},"script out complete DLL."]},{"entry":["DDL Body Only;","Only script the DDL body for objects that have a body"]},{"entry":[{},"text, such as Stored Procedure. Default is to script out"]},{"entry":[{},"complete DLL."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0064","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Script Dependency Options"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Scripter Option","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["With","Expands the output Script List to include all dependent"]},{"entry":["Dependencies;","objects."]},{"entry":["Database","Generated Transact-SQL database privilege defining"]},{"entry":["Permissions;","script. Database permissions grant or deny statement"]},{"entry":[{},"executing rights."]},{"entry":["Script Indexes;","Clustered indexes, Non Clustered Indexes, and DRI"]},{"entry":[{},"Indexes combined using an OR logical operator."]},{"entry":[{},"Applies to both table and view objects."]},{"entry":["Permissions;","SQL SMO Script Object Permissions and SQL SMO"]},{"entry":[{},"Script Database Permissions combined using an OR"]},{"entry":[{},"logical operator."]},{"entry":["Primary Object;","Generate Transact-SQL creating the referenced"]},{"entry":[{},"component."]},{"entry":["Extended","Include extended property scripting as part of object"]},{"entry":["Property;","scripting."]},{"entry":["XML","Include XML namespaces as part of object scripting."]},{"entry":"Namespaces;"},{"entry":["Full Text","Command batch includes Transact-SQL statements"]},{"entry":["Catalogs;","creating search full-text catalogs."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Cross Server-Level Scripting"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Scripter Option","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["No Collation;","The default is to generate collation."]},{"entry":[{},"Specific for table objects."]},{"entry":["Full Text Index;","Command batch includes statements defining"]},{"entry":[{},"search full-text indexing."]},{"entry":["Bindings;","Generate sp-bindefault and sp-bindrule statements."]},{"entry":[{},"Applies only when scripting references a SQL Server"]},{"entry":[{},"table."]},{"entry":["Clustered","Generate Transact-SQL defining clustered indexes."]},{"entry":["Indexes;","Applies only when scripting references a SQL Server"]},{"entry":[{},"table."]},{"entry":["DRI-All;","All values defined as DRI combined using an OR"]},{"entry":[{},"logical operator."]},{"entry":["DRI-All","DRI-Checks, DRI Defaults, DRI Foreign Keys,"]},{"entry":["Constraints;","DRI Primary Key, DRI Unique Keys, DRI XML Keys"]},{"entry":[{},"combined using an OR logical operator."]},{"entry":["DRI-All Keys;","DRI Foreign Keys, DRI Primary Key, DRI Unique"]},{"entry":[{},"Keys, combined using an OR logical operator."]},{"entry":["XML Indexes;","Generated script creates XML indexes."]},{"entry":["DRI-Checks;","Generated script creates column-specified CHECK"]},{"entry":[{},"constraints. Directs scripting when declarative"]},{"entry":[{},"referential integrity establishes dependency"]},{"entry":[{},"relationships. Applies only when scripting references"]},{"entry":[{},"a SQL Server table."]},{"entry":["DRI-Clustered;","Generated script creates clustered indexes. Directs"]},{"entry":[{},"scripting when declarative referential integrity"]},{"entry":[{},"establishes dependency relationships. Applies only"]},{"entry":[{},"when scripting references a SQL Server table."]},{"entry":["DRI-Defaults;","Generated script includes column-specified defaults."]},{"entry":[{},"Directs scripting when declarative referential integrity"]},{"entry":[{},"establishes dependency relationships. Applies only"]},{"entry":[{},"when scripting references a SQL Server table."]},{"entry":["DRI-Foreign","Generated script creates foreign key constraints."]},{"entry":["Keys;","Directs scripting when declarative referential integrity"]},{"entry":[{},"establishes dependency relationships. Applies only"]},{"entry":[{},"when scripting references a SQL Server table."]},{"entry":["DRI-Non","Generated script creates nonclustered indexes. Directs"]},{"entry":["Clustered;","scripting when declarative referential integrity"]},{"entry":[{},"establishes dependency relationships. Applies only"]},{"entry":[{},"when scripting references a SQL Server table."]},{"entry":["DRI-Primary","Generated script creates PRIMARY KEY constraints."]},{"entry":["Key;","Directs scripting when declarative referential integrity"]},{"entry":[{},"establishes dependency relationships. Applies only"]},{"entry":[{},"when scripting references a SQL Server table."]},{"entry":["DRI-Unique","Generated script creates candidate keys defined using a"]},{"entry":["Keys;","unique index. Directs scripting when declarative"]},{"entry":[{},"referential integrity establishes dependency"]},{"entry":[{},"relationships. Applies only when scripting references"]},{"entry":[{},"a SQL Server table."]},{"entry":["DRI Indexes;","Script PRIMARY KEY constraints using a unique"]},{"entry":[{},"index to implement the declarative referential integrity."]},{"entry":[{},"Applies only when scripting references a SQL Server"]},{"entry":[{},"table."]},{"entry":["DRI With","When using DRI Checks, or DRI Foreign Keys,"]},{"entry":["No Check;","generated script includes the WITH NO CHECK"]},{"entry":[{},"clause optimizing constraint creation. Applies only"]},{"entry":[{},"when scripting references a SQL Server table."]},{"entry":["No Identity;","Generated Transact-SQL statements do not include"]},{"entry":[{},"definition of identity property, seed, and increment."]},{"entry":[{},"Applies only when scripting references a SQL Server"]},{"entry":[{},"table."]},{"entry":["Non Clustered","Generate Transact-SQL defining nonclustered"]},{"entry":["Indexes;","indexes. Applies only when scripting references a SQL"]},{"entry":[{},"Server table."]},{"entry":["Object","Include Transact-SQL privilege defining statements"]},{"entry":["Permissions;","when scripting database objects."]},{"entry":["Triggers;","Generate Transact-SQL defining triggers. Applies only"]},{"entry":[{},"when scripting references a SQL Server table."]},{"entry":["User Types To","Convert specification of user-defined data types to the"]},{"entry":["Base Type;","appropriate SQL Server base data type. Applies only"]},{"entry":[{},"when scripting references a SQL Server table."]},{"entry":["No File Groups;","Command batch does not include \u2018ON <filegroup>\u2019"]},{"entry":[{},"clause that directs filegroup use."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Miscellaneous"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Scripter Option","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Allow System Objects","Allows scripting of system objects. If not"]},{"entry":["(Boolean);","specified system objects are"]},{"entry":[{},"filtered out."]},{"entry":["Agent Alert Job;","Generate Transact-SQL script creating"]},{"entry":[{},"SQL Server Agent service jobs and alerts."]},{"entry":["Agent Notify;","When scripting an alert, generate script"]},{"entry":[{},"creating notifications for the alert."]},{"entry":["ANSI Padding;","Command batch includes Transact-SQL"]},{"entry":[{},"statements SET ANSI PADDING ON and"]},{"entry":[{},"SET ANSI PADDING OFF statements"]},{"entry":[{},"before and after CREATE TABLE"]},{"entry":[{},"statements in the generated script."]},{"entry":["No What If Index;","Command batch does not include"]},{"entry":[{},"CREATE STATISTICS statements."]},{"entry":["NoTablePartitioningSchemes;","Command batch does not include partition"]},{"entry":[{},"schemes for Table objects."]},{"entry":["NoIndexPartitioningSchemes;","Command batch does not include partition"]},{"entry":[{},"schemes for Index objects."]},{"entry":["No Assemblies;","Command batch does not include"]},{"entry":[{},"Assemblies."]},{"entry":["No View Columns;","Do not script the specified columns for a"]},{"entry":[{},"View object. View columns are recorded"]},{"entry":[{},"at the time of the view creation, either"]},{"entry":[{},"by specifying these specifically, or as"]},{"entry":[{},"defined by the select statement."]},{"entry":["Include Database Context;","Add a USE [database] statement in the"]},{"entry":[{},"header of the script. The [database] is the"]},{"entry":[{},"containing database name of the object"]},{"entry":[{},"that is scripted."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"As mentioned above, while exemplary embodiments of the invention have been described in connection with various computing devices and network architectures, the underlying concepts may be applied to any computing device or system in which it is desirable to implement an automated scripter. Thus, the methods and systems of the present invention may be applied to a variety of applications and devices. While exemplary programming languages, names and examples are chosen herein as representative of various choices, these languages, names and examples are not intended to be limiting. One of ordinary skill in the art will appreciate that there are numerous ways of providing object code that achieves the same, similar or equivalent systems and methods achieved by the invention.","The various techniques described herein may be implemented in connection with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers, the computing device will generally include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs that may utilize the signal processing services of the present invention, e.g., through the use of a data processing API or the like, are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","The methods and apparatus of the present invention may also be practiced via communications embodied in the form of program code that is transmitted over some transmission medium, such as over electrical wiring or cabling, through fiber optics, or via any other form of transmission, wherein, when the program code is received and loaded into and executed by a machine, such as an EPROM, a gate array, a programmable logic device (PLD), a client computer, a video recorder or the like, or a receiving machine having the signal processing capabilities as described in exemplary embodiments above becomes an apparatus for practicing the invention. When implemented on a general-purpose processor, the program code combines with the processor to provide a unique apparatus that operates to invoke the functionality of the discussed invention. Additionally, any storage techniques used in connection with the invention may invariably be a combination of hardware and software.","While the present invention has been described in connection with the preferred embodiments of the various figures, it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. Furthermore, it should be emphasized that a variety of computer platforms, including handheld device operating systems and other application specific operating systems are contemplated, especially as the number of wireless networked devices continues to proliferate. Therefore, the invention should not be limited to any single embodiment, but rather should be construed in breadth and scope in accordance with the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of preferred embodiments, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating the invention, there is shown in the drawings exemplary constructions of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
