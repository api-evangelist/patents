---
title: Extensible framework for handling different mark up language parsers and generators in a computing device
abstract: A computing device programmed with an extensible framework that accepts one or more mark-up language parsers and/or generators, each implemented as plug-ins to the framework, with different plug-ins enabling different kinds of mark up languages to be handled by the device. In this way, the client is no longer tied to a single kind of parser or generator; it can operate with any different kind of parser compatible with the intermediary layer, yet it remains far simpler that prior art clients that are hard-coded to operate directly with several different kinds of parsers and generators.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08695018&OS=08695018&RS=08695018
owner: Nokia Corporation
number: 08695018
owner_city: Espoo
owner_country: FI
publication_date: 20041007
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","DESCRIPTION OF THE PRIOR ART","SUMMARY OF THE PRESENT INVENTION","DETAILED DESCRIPTION"],"p":["This application claims the priority of PCT\/GB2004\/004276 filed on Oct. 7, 2004 and GB 0323442.4 filed on 7 Oct. 2003; GB 0323439.0 filed on 7 Oct. 2003; and, GB 0323440.8 filed on 7 Oct. 2003 filed on Oct. 7, 2003, the entire contents of which are hereby incorporated in total by reference.","This invention relates to an extensible framework for handling different mark up language parsers and generators. The invention finds application in a computing device. Its advantages are especially valuable for a resource constrained mobile computing device, i.e. a battery powered, portable device in which there are power and memory constraints, but are relevant to other kinds of computing devices, such as desktop PCs, set top boxes etc.","Mark-up language is a set of codes in a text or binary file that enable a computing device to format the text for correct display or printing. A client (i.e. any process that requests a service from another process) in a software system creates mark-up language using a \u2018generator\u2019. It reads and interprets mark-up language using a \u2018parser\u2019.","In the prior art, parsers and generators have been specific to certain kinds of mark-up languages. For example, a client could use an XML (extensible mark-up language) parser to interpret and handle XML files; it could use a separate WBXML (WAP binary XML) parser to interpret and handle WBML files. In recent years, there has been a proliferation of different mark-up languages: the conventional approach has been to deploy in device ROM several separate fully functioning parsers for each mark up language that the device needs to parse. This inevitably takes up valuable ROM space; as there may need to be an instantiation of each parser at the same time, valuable RAM may also be occupied.","Furthermore, in the prior art, the client talks directly to the XML parser and the separate WBXML parser. Also, when the client needs to generate mark-up language format files, there could be an XML generator and a separate WBXML generator. Again, the client would talk directly to each generator. Clients therefore have had to be hard-coded to handle and talk directly with these specific kinds of parsers and generators; in practice, this has meant that clients are either extremely complex if they need to handle several different mark up language formats (further increasing the demand on both ROM and also RAM memory) or else they are restricted to a single mark-up language format.","The present invention is a computing device programmed with an extensible framework that accepts one or more mark-up language parsers and\/or generators, each implemented as plug-ins to the framework, with different plug-ins enabling different kinds of mark up languages to be handled by the device.","The framework is an API (which term includes a set of APIs) that enables different types of mark-up parsers and generators to be included in the framework by means of the parser\/generator plug-ins. A plug-in is a replaceable item of executable code that provides specific services to a loosely coupled application that can load or invoke it at run-time; it can therefore extend the framework at run-time (i.e. there is no need to recompile or change the framework for a plug-in to work).","This approach has many advantages over the conventional approach of hard-coding clients to specific parsers and generators. Because of the extensible plug-in design, it is possible to allow new kinds of parsers and generators to be loaded onto a device after that device has been shipped to an end-user. The only requirement is that they are implemented as plug-ins that are compatible with the extensible framework. This is especially useful in the context of mark up language parsers and generators since there are many potential languages that might need to be handled by a device but it is impractical to hard-code the capability to handle all of these when the device is designed because of the memory overhead.","Hence, a core further technical advantage offered by the present invention is that it reduces memory requirements; this in turn can lead to faster loading of code and\/or less use of virtual memory. These advantages are especially useful in mobile computing devices, where techniques that reduce power consumption and extend battery life are very valuable. The term \u2018mobile computing device\u2019 should be expansively construed to cover mobile telephones, smartphones, personal organisers, wireless information device and any other kind of portable, mobile computing device. But these advantages are also valuable in fixed computing devices such as PCs, set top boxes, games consoles etc. and can lead directly to lower BOM (bill of material) costs because of the lower memory requirements.","Also, since new mark up languages (or extensions\/variants to existing languages, including new schemas) are frequently developed, the ability to extend an existing design of computing device to handle these new or extended languages is very useful. The extensible framework may be a stand alone application or may form part of a device operating system: if the latter, a particular version of the operating system that includes the extensible framework can be developed and included in device ROM for a broad range of computing devices: this version will be able to handle different kinds of mark up languages when appropriate parser\/generator plug ins are used.","In one implementation, the extensible framework (i) insulates a client running on the device from having to communicate directly with a parser or generator and (ii) is generic in that it presents a common API to the client irrespective of the specific kind of parser or generator deployed. An advantage of this is that it allows not only different parsers and generators to be readily used by the same client, but it allows also several different clients to share the same parsers and generators as well. In addition, clients can be far simpler than prior art designs that could handle several different mark-up language parsers or generators: this leads to smaller memory requirements in both ROM and RAM.","Because the framework (e.g. the API) is extensible, extensions to its capabilities (e.g. to enable a new\/extended mark-up language of a document to be handled) can be made without affecting compatibility with existing clients or existing parsers and generators. This may be achieved through an updated\/extended namespace plug-in; this plug-in sets-up all the elements, attributes and attribute values for a namespace. Similarly, new kinds of clients can be provided for loading onto a device after that device has been shipped to an end-user. The only requirement is that they are compatible with the intermediary layer.","The API is typically implemented as a header file.","The specific kind of parser or generator being used is not known to the client: the intermediary layer fully insulates the client from needing to be aware of these specifics. Instead, the client deals only with the intermediary layer, which presents to the client as a generic parser or a generic generator\u2014i.e. a parser or generator which behaves in a way that is common to all parsers or generators.","For example, the SyncML the protocol supports both XML and WBXML. By using both XML and WBXML parser and generator plug-ins in to the framework, a SyncML client can use either or both type of parser and generator without knowing about the type of mark-up language; as a result, the design of the SyncML client is greatly simplified. Since WBXML and X are quite different in the way they represent their data, one very useful feature of the invention is the mapping of WBXML tokens to a string in a static string pool table. Appendix C expands on this idea.","The present invention may provide a flexible and extensible file conversion system: for example, the device could parse a document written in one mark up language format and then use the parsed document data to generate an equivalent document in a different file format.","Another feature of the present invention is that the mark-up language parser or generator may access components to validate, pre-filter or alter data, in which the components are plug-in components to the extensible framework that operate using a \u2018chain of responsibility\u2019 design pattern. They may be plug-ins to the extensible framework described above.","Because of the plug-in design of the these components, the system is inherently flexible and extensible compared with prior art systems in which a component (for validating, pre-filtering or altering data from a parser or generator) would be tied exclusively to a given parser. Hence, if a mark up language of a document is extended, or a new one created, it is possible to write any new validation\/pre-filter\/altering plug-in that is needed to work with the extended or new language. These new kinds of validation\/pre-filter\/altering plug-ins can be provided for loading onto a device even after that device has been shipped to an end-user. Further, any of these plug-ins will work with any existing parser or generator that is itself a plug-in to the extensible framework, i.e. uses the same generic API.","Overview of Key Features","The present invention is implemented in a system called the Mark-Up Language Framework, used in SymbianOS from Symbian Limited, London, United Kingdom. SymbianOS is an operating system for smart phones and advanced mobile telephones, and other kinds of portable computing devices.","The Mark-Up Language framework implements three key features.","1. Generic Parser Extensible Framework","Clients are separated from mark-up language parsers\/generators by an extensible framework that accepts one or more mark-up language parsers and\/or generators, each implemented as plug-ins to the framework, with different plug-ins enabling different kinds of mark up languages to be handled by the device. The extensible framework is in effect an intermediary (i.e. abstraction) layer that (a) insulates the client from having to communicate directly with the parser or generator and is (b) generic in that it presents a common API to the client irrespective of the specific kind of parser or generator the intermediary layer interfaces with.","2. Data Validation\/Pre-Filtering and Altering Components in a Chain of Responsibility","Mark-up language parser or generator plug-ins to the extensible framework can access components to validate, pre-filter or alter data; the components are plug-in components to the extensible framework that operate using a \u2018chain of responsibility\u2019 design pattern.","3. Generic Data Supplier API","The mark-up language parsers or generators can access data from a source using a generic data supplier API, insulating the parser or generator from having to communicate directly with the data source.","Each of this features will now be discussed in more detail.","1. Generic Parser Extensible Framework","The essence of this approach is that the parsers and generators are plug-ins to an extensible framework; the framework is in one implementation part of the operating system of the device. The present invention may hence readily allow the device to operate with different kinds of parsers and generators: this extensibility is impossible to achieve with prior art hard-coded systems.","The client interfaces with a mark up language parser or a generator via the extensible framework intermediary layer: this layer (a) insulates the client from having to communicate directly with the parser or generator and is (b) generic in that it presents a common API to the client irrespective of the specific kind of parser or generator the intermediary layer interfaces with.","In this way, the client is no longer tied to a single kind of parser or generator; it can operate with any different kind of parser compatible with the intermediary layer, yet it remains far simpler than prior art clients that are hard-coded to operate directly with several different kinds of parsers and generators.","The API is typically implemented as a header file. The specific kind of parser or generator being used is not known to the client: the intermediary layer fully insulates the client from needing to be aware of these specifics. Instead, the client deals only with the intermediary layer, which presents to the client as a generic parser or a generic generator\u2014i.e. a parser or generator which behaves in a way that is common to all parsers or generators.","For example, the SyncML the protocol supports both XML and WBXML. By using both XML and WBXML parser and generator plug-ins in to the framework, a SyncML client can use either or both type of parser and generator without knowing about the type of mark-up language; as a result, the design of the SyncML client is greatly simplified. Since WBXML and XML are quite different in the way they represent their data, one very useful feature of the invention is the mapping of WBXML tokens to a string in a static string pool table. Appendix C expands on this idea.","The present invention may provide a flexible and extensible file conversion system: for example, the device could parse a document written in one mark up language format and then use the parsed document data to generate an equivalent document in a different file format. Because of the extensible plug-in design of an implementation of the system, it is possible to provide far greater kinds of file conversion capabilities than was previously the case. New kinds of parsers and generators can be provided for loading onto a device after that device has been shipped to an end-user. The only requirement is that they are compatible with the intermediary layer.","Another advantage of the present invention is that it allows not only different parsers and generators to be readily used by the same client, but it allows also several different clients to share the same parsers and generators as well. The API may itself be extensible, so that extensions to its capabilities (e.g. to enable a new\/extended mark-up language of a document to be handled) can be made without affecting compatibility with existing clients or existing parsers and generators. Similarly, new kinds of clients can be provided for loading onto a device after that device has been shipped to an end-user. The only requirement is that they are compatible with the intermediary layer.","2. Data Validation\/Pre-Filtering and Altering Components in a Chain of Responsibility","The essence of this approach is that the mark-up language parser or generator can access components to validate, pre-filter or alter data, in which the components are plug-in components that operate using a chain of responsibility. They may be plug-ins to the extensible framework described above.","Because of the plug-in design of the components, the system is inherently flexible and extensible compared with prior art systems in which a component (for validating, pre-filtering or altering data from a parser or generator) would be tied exclusively to a given parser. Hence, if a mark up language of a document is extended, or a new one created, it is possible to write any new validation\/pre-filter\/altering plug-in that is needed to work with the extended or new language. These new kinds of validation\/pre-filter\/altering plug-ins can be provided for loading onto a device even after that device has been shipped to an end-user. The \u2018chain of responsibility\u2019 design pattern, whilst known in object oriented programming, has not previsouly been used in the present context.","The plug-in components may all present a common, generic API to the parser and generator. Hence, the same plug-in can be used with different types of parsers and generators (e.g. a XML parser, a WBXML parser, a RTF parser etc.). The plug-ins also present a common, generic API to a client component using the parser or generator. Hence, the same plug-ins can be used by different clients.","For example a DTD validator plug-in could be written that validates the mark-up of a document and can report errors to the client. Or for a web browser an auto correction plug-in filter could be written that tries to correct errors found in the mark-up language, such as a missing end element tag, or a incorrectly placed element tag. The auto correction plug-in will, if it can, fix the error transparently to the client. This enables a web browser to still display a document rather then just displaying an error reporting that there was an error in the document","Because the plug-ins can be chained together, complex and different type of filtering and validation can take place. In the example above the parser could notify the validator plug-in of elements it is parsing and these in turn would go to the auto correction plug-in to be fixed if required and finally the client would receive these events.","The mark-up framework allows parser plug-ins to expose the parsed element stack to all validation\/pre-filter\/altering plug-ins. (The parsed element stack is a stack populated with elements from a document extracted as that document is parsed; this stack is made available to all validation\/pre-filter\/altering plug-ins to avoid the need to duplicate the stack for each of these plug-ins). This also enables the plug-ins to use the stack information to aid in validation and filtering. For example an auto corrector plug-in may need to know the entire element list that is on the stack in order to figure out how to fix a problem.","The use of filter\/validator plug-ins in mark-up language generators is especially useful for developers writing a client to the framework and generating mark-up documents as the same validator plug-in used by the parser can be used in the generator. Errors are reported to the client when the mark-up does not conform to the validator which will enable the developer to make sure they are writing well formed mark-up that conforms to the DTD and catch error early on during development.","The mark-up framework incorporates a character conversion module that enables documents written in different character sets (e,g, ASCII, various Kanji character sets etc.) to be parsed and converted to UTF8. This means a client obtains the results from the parser in a generic way (UTF8) without having to know the original character set that was used in the document. Clients hence no longer need to be able to differentiate between different character sets and handle the different character sets appropriately.","3. Generic Data Supplier API","The mark-up language parser or generator accesses data from a source using the extensible framework\u2014i.e. a generic data supplier API. Hence, the parser or generator is insulated from having to talk directly to a data source; instead, it does so via the generic data supplier API, acting as an intermediary layer. This de-couples the parser or generator from the data source and hence means that the parser or generator no longer have to be hard coded for a specific data supplier. This in turn leads to a simplification of the parser and generator design.","The present invention allows parsing and generation to be carried out with any data source. For example, a buffer in memory could be used, as could a file, as could streaming from a socket (hence enabling the ability to parse in real-time from data streamed over the internet). There is no requirement to define, at parser\/generator build time, what particular data source will be used. Instead, the system allows any source that can use the generic data supplier API to be adopted. New types of data sources can be utilised by computing device, even after those devices have been shipped to end-users.","The present invention is implemented in a system called the Mark-Up Language Framework, used in SymbianOS from Symbian Limited, London, United Kingdom. SymbianOS is an operating system for smart phones and advanced mobile telephones, and other kinds of portable computing devices.","The following describes the Mark-Up Language Framework in more detail. Appendix C describes a particular technique, referred to as \u2018String Pool\u2019, which is used in the Mark-Up Language Framework. Various SymbianOS specific programming techniques and structures are referred to. There is an extensive published literature describing these techniques; reference may for example be made to \u201cProfessional Symbian Programming\u201d Wrox Press Inc. ISBN: 186100303X, the contents of which are incorporated by reference.","Design Overview","Block Diagrams","The mark-up language extensible framework is shown schematically in . This is implemented as part of the operating system of a computing device. The Client  is the application using the mark-up framework for parsing or generating a document. The Parser  and Generator  components are plug-ins specific to a mark-up language (e.g. XML or WBXML); they are plug-ins to the extensible framework\u2014i.e. a set of genetic APIs that enable the client  to communicate with Parser  and Generator . The plug-ins conform to Symbian OS requirements known as \u2018ECOM\u2019.","Because of the framework architecture, many new kinds of parsers and generators (e.g. to handle extensions to mark up languages, new languages or new schemas) can readily be loaded onto the device, even after the device has shipped. Further, different clients running on the device can share the same parser or generator; these clients are simpler than prior art clients since they need to operate with a single, generic API. The API is shown symbolically as the API abstraction or intermediary layer . The Parser  and Generator  components use the Namespace collection  to retrieve information about a specific namespace during the parsing or generating phase.","The Namespace Plug-in  component is an ECOM plug-in that sets-up all the elements, attributes and attribute values for a namespace. For each namespace used, there must be a plug-in that describes the namespace. The namespace information is stored in a string pool. The string pool is a way of storing strings that makes comparison almost instantaneous at the expense of string creation. It is particularly efficient at handling string constants that are known at compile time, which makes it very suitable for processing documents. Appendix C includes more detail on string pools. The Namespace collection  owns the string pool that the Parser , Generator  and Client  can gain access to.","The Namespace Plug-in  simply sets-up the string pool with the required strings for the namespace the plug-in represents. The Client  may get access to the Namespace Collection  via the Parser  or Generator  to pre-load namespaces prior to parsing or generating documents which may speed up the parsing or generating session.","The Plug-in components (A-D) are optional and allow further processing of the data before the client receives it, such as DTD validators or document auto correctors. Validators check the elements and attributes conform to the DTD. Document auto correction plug-ins are used to try to correct errors reported from DTD validators. These components are also plug-ins to the extensible framework and hence share at least some of the same APIs  as the Parser  and Generator . The Parser  is event driven and sends events to the various plug-ins and UI during parsing.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 2","b":["21","22","23","10","21","24","24","22","23","22","24","22","23","22","23","23","21"]},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 3","b":["31","34","32","33","10"]},"The Client  sends a build request to the Generator . The first thing the Generator  does is to send the request as an event to the DTD validator plug-in . The situation is similar to the parser: the DTD validator plug-in  validates that the data in the event it received is correct. If it is not correct, it will send the same event the Generator  sent to the Validator  to the Auto corrector  except for an error code that will describe the problem the Validator  encountered. It the event data is valid the same event will be sent to the Auto corrector . Now the Auto corrector  receives the event and can check for any errors. If there is an,error it can attempt to correct it. If it can correct the error it will modify the data in the event and remove the error code before sending the event back to the Generator . The major difference between the events during parsing and generating is that with generating, once the final plug-in has dealt with the event it gets sent back to the generator. The generator receives the event and builds up part of the document using the details from the event.","Parsing and Generating WBXML","Parsing WBXML is quite different to parsing XML or HTML. The main difference is elements and attributes are defined as tokens rather than using their text representation. This means a mapping needs to be stored between a WBXML token and its static string representation. The Namespace plug-in for a particular namespace will store these mappings. A WBXML parser and generator can then obtain a string from the namespace plug-in given the WBXML token and vice versa. Appendix C deals with this in more detail.","Class Diagram","The class diagram for the mark-up framework is shown in . The diagram also depicts plug-ins that makes use of the framework. The dark grey classes are the plug-ins that provide implementation to the mark-up framework. CxmlParser  and CwbxmlParser  provide an implementation to parse XML and WBXML documents respectively. In the same way CxmlGenerator  and CwbxmlGenerator  generate XML and WBXML documents respectively. Cvalidator  is a plug-in which will validate the mark-up document during parsing or generating. CautoCorrector  is a plug-in that corrects invalid mark-up documents.","When parsing a document and the Client  receives events for the start of an element for example (OnStartElementL), the element RString in the event is a handle to a string in the string pool. If this is a known string, i.e. one that has been added by the Namespace Plug-in then the string will be static. Otherwise, if it is an unknown string, the parser will add the string to the string pool as a dynamic string and return a RString with a handle of this string. It is not possible to know if a RString is dynamic or static so the parser or generator that obtains a RString must be sure to close it to ensure any memory is released if the string is dynamic. A client that wishes to use the RString after the event returns to the parser must make a copy of it which will increase the reference count and make sure it is not deleted when the parser closes it. The key to the  shading is as follows:",{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},"NAME","TYPE OF CLASS"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RNamespaceCollection","Mark-up framework class"]},{"entry":[{},"RParserSession","Mark-up framework class"]},{"entry":[{},"RGeneratorSession","Mark-up framework class"]},{"entry":[{},"CMarkupPluginBase","Mark-up framework class"]},{"entry":[{},"CMarkupNamespace","Mark-up framework class"]},{"entry":[{},"RTableCodePage","Mark-up framework class"]},{"entry":[{},"CMarkupCharSetConverter","Mark-up framework class"]},{"entry":[{},"CMarkupPlugin","Mark-up framework class"]},{"entry":[{},"CParserSession","Mark-up framework class"]},{"entry":[{},"CGeneratorSession","Mark-up framework class"]},{"entry":[{},"RAttribute","Mark-up framework class"]},{"entry":[{},"RElementStack","Mark-up framework class"]},{"entry":[{},"MMarkupCallback","Mix-in class used for call-backs"]},{"entry":[{},"MDataSupplierReader","Mix-in class used for call-backs"]},{"entry":[{},"MDataSupplierWriter","Mix-in class used for call-backs"]},{"entry":[{},"CActive","System class in the Symbian OS"]},{"entry":[{},"RAttributeArray","System class in the Symbian OS"]},{"entry":[{},"CNamespace","Implementation plug-in classes"]},{"entry":[{},"CValidator","Implementation plug-in classes"]},{"entry":[{},"CAutoCorrector","Implementation plug-in classes"]},{"entry":[{},"CXMLParser","Implementation plug-in classes"]},{"entry":[{},"CWbxmlParser","Implementation plug-in classes"]},{"entry":[{},"CXmlGenerator","Implementation plug-in classes"]},{"entry":[{},"CWbxmlGenerator","Implementation plug-in classes"]},{"entry":[{},"CDescriptorDataSupplier","Implementation plug-in classes"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 5","b":["51","52","53"]},"The key to the  shading is as follows:",{"@attributes":{"id":"p-0068","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},"NAME","TYPE OF CLASS"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RParserSession","Mark-up framework class"]},{"entry":[{},"CMarkupPluginBase","Mark-up framework class"]},{"entry":[{},"RNamespaceCollection","Mark-up framework class"]},{"entry":[{},"CParserSession","Mark-up framework class"]},{"entry":[{},"CMarkupNamespace","Mark-up framework class"]},{"entry":[{},"MMarkupCallback","Mix-in class used for call-backs"]},{"entry":[{},"MDataSupplierReader","Mix-in class used for call-backs"]},{"entry":[{},"CActive","System class in the Symbian OS"]},{"entry":[{},"CDescriptorDataSupplier","Implementation plug-in classes"]},{"entry":[{},"CWbxmlParser","Implementation plug-in classes"]},{"entry":[{},"CSyncMLNamespace","Implementation plug-in classes"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},{},"Associated"]},{"entry":[{},{},"(owned\/dependant)"]},{"entry":["Object name","Description","objects"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["MMarkupCallback","A call-back that a client must","Inherited by clients and"]},{"entry":[{},"implement so that the parser","plug-ins."]},{"entry":[{},"can report events back to the",{}]},{"entry":[{},"client during the parsing",{}]},{"entry":[{},"session.",{}]},{"entry":["RNamespaceCollection","Contains a collection of","Owned by either"]},{"entry":[{},"namespaces. Contains","CParserSession or"]},{"entry":[{},"reference counter so multiple","CGeneratorSession."]},{"entry":[{},"parsers or generators may use","Owns an array of"]},{"entry":[{},"the same namespace","CMarkupNamespace"]},{"entry":[{},"collection.","plug-ins."]},{"entry":["CMarkupNamespace","ECOM interface to","Inherited by any"]},{"entry":[{},"implement a namespace.","namespace plug-ins."]},{"entry":["RParserSession","Public interface for a client to","Owned by the client."]},{"entry":[{},"create a parser session.",{}]},{"entry":["RGeneratorSession","Public interface for a client to","Owned by the client."]},{"entry":[{},"create a generator session.",{}]},{"entry":["CMarkupCharSetConverter","Helper function which uses","Owned by RParserSession"]},{"entry":[{},"CCnvCharacterSetConverter","and RGeneratorSession."]},{"entry":[{},"for the client, parser and",{}]},{"entry":[{},"generator to do any character",{}]},{"entry":[{},"set conversions or resolving",{}]},{"entry":[{},"MIB Enums or Internet-",{}]},{"entry":[{},"standard names of character",{}]},{"entry":[{},"sets.",{}]},{"entry":["CMarkupPluginBase","Generic interface for any type","Inherited by"]},{"entry":[{},"of plug-in.","CMarkupPlugin,"]},{"entry":[{},{},"CParserSession and"]},{"entry":[{},{},"CGeneratorSession."]},{"entry":["CMarkupPlugin","ECOM interface for plug-ins","Owned by"]},{"entry":[{},"to be used by the parser and","CParserSession or"]},{"entry":[{},"generator.","CGeneratorSession."]},{"entry":["MDataSupplierReader","Pure virtual interface to be","Inherited by the client's"]},{"entry":[{},"implemented by a data","data provider."]},{"entry":[{},"supplier for reading data.",{}]},{"entry":["MDataSupplierWriter","Pure virtual interface to be","Inherited by the client's"]},{"entry":[{},"implemented by a data","data provider."]},{"entry":[{},"supplier for writing data.",{}]},{"entry":["CParserSession","ECOM interface for parser","Inherited by a concrete"]},{"entry":[{},"plug-ins.","parser implementation."]},{"entry":["CGeneratorSession","ECOM interface for generator","Inherited by a concrete"]},{"entry":[{},"plug-ins.","generator implementation."]},{"entry":["RAttribute","Contains the name and value","Used by the parse,"]},{"entry":[{},"of an attribute.","generator and client."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"The classes below are not part of the framework but illustrate how the framework"},{"entry":"can be used."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CValidator","A DTD, schema or some","Owned by"]},{"entry":[{},"other type of validator.","RParserSession or"]},{"entry":[{},{},"RGeneratorSession."]},{"entry":["CAutoCorrector","Used to auto correct invalid","Owned by"]},{"entry":[{},"data.","RParserSession or"]},{"entry":[{},{},"RGeneratorSession."]},{"entry":["CXmlParser","An XML parser","Owned by"]},{"entry":[{},"implementation.","RParserSession."]},{"entry":["CWbxmlParser","A WBXML parser","Owned by"]},{"entry":[{},"implementation.","RParserSession."]},{"entry":["CXmlGenerator","An XML generator","Owned by"]},{"entry":[{},"implementation.","RGeneratorSession."]},{"entry":["CWbxmlGenerator","A WBXML generator","Owned by"]},{"entry":[{},"implementation.","RGeneratorSession."]},{"entry":["CNamespace","A namespace plug-in to use","Owned by"]},{"entry":[{},"with a parser and generator.","RNamespaceCollection."]},{"entry":["RElementStack","A stack of the currently","Owned by"]},{"entry":[{},"processed elements during","CParserSession and"]},{"entry":[{},"parsing or generating.","CGeneratorSession."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":[{},{}]},"The following is the public API for this class:",{"@attributes":{"id":"p-0071","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Method","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void OpenL(","Opens a parser session."]},{"entry":["MDataSupplierReader& aReader,","aReader is the data supplier reader to use during"]},{"entry":["const TDesC8&","parsing."]},{"entry":["aMarkupMimeType,","aMarkupMimeType is the MIME type of the"]},{"entry":["const TDesC8&","parser to open."]},{"entry":["aDocumentMimeType,","aDocumentMimeType is the MIME type of"]},{"entry":["MMarkupCallback& aCallback)","the document to parse."]},{"entry":[{},"aCallback is a reference to the call-back so the parser"]},{"entry":[{},"can report events."]},{"entry":["void OpenL(","Opens a parser session."]},{"entry":["MDataSupplierReader& aReader,","aReader is the data supplier reader to use during"]},{"entry":["const TDesC8&","parsing."]},{"entry":["aMarkupMimeType,","aMarkupMimeType is the MIME type of the"]},{"entry":["const TDesC8&","parser to open."]},{"entry":["aDocumentMimeType,","aDocumentMimeType is the MIME type of"]},{"entry":["MMarkupCallback& aCallback,","the document to parse."]},{"entry":["RMarkupPlugins aPlugins)","aCallback is a reference to the call-back so the"]},{"entry":[{},"parser can report events."]},{"entry":[{},"aPlugins is an array of plug-ins to use with the"]},{"entry":[{},"parser. The first plug-in in the list is the first plug-"]},{"entry":[{},"in to be called back from the parser. The first"]},{"entry":[{},"plug-in will then call-back to the second plug-in"]},{"entry":[{},"etc."]},{"entry":["void OpenL(","Opens a parser session."]},{"entry":["MDataSupplierReader& aReader,","aReader is the data supplier reader to use during"]},{"entry":["const TDesC8&","parsing."]},{"entry":["aMarkupMimeType,","aMarkupMimeType is the MIME type of the"]},{"entry":["const TDesC8&","parser to open."]},{"entry":["aDocumentMimeType,","aDocumentMimeType is the MIME type of"]},{"entry":["MMarkupCallback& aCallback,","the document to parse."]},{"entry":["RMarkupPlugins aPlugins[ ],","aCallback is a reference to the call-back so the"]},{"entry":["RNamespaceCollection","parser can report events."]},{"entry":["aNamespaceCollection)","aPlugins is an array of plug-ins to use with the"]},{"entry":[{},"parser. The first plug-in in the list is the first plug-"]},{"entry":[{},"in to be called back from the parser. The first"]},{"entry":[{},"plug-in will then call-back to the second plug-in"]},{"entry":[{},"etc."]},{"entry":[{},"aNamespaceCollection is a handle to a"]},{"entry":[{},"previous namespace collection. This is useful if a"]},{"entry":[{},"generator or another parser session has been"]},{"entry":[{},"created so that same namespace collection can be"]},{"entry":[{},"shared."]},{"entry":["void Close( )","Closes the parser session."]},{"entry":["void Start( )","Start parsing the document."]},{"entry":["void Stop( )","Stop parsing the document."]},{"entry":["void Reset(","Resets the parser ready to parse a new document."]},{"entry":["MDataSupplierReader& aReader,","aReader is the data supplier reader to use during"]},{"entry":["MMarkupCallback& aCallback)","parsing."]},{"entry":[{},"aCallback is a reference to the call-back so the"]},{"entry":[{},"parser can report events."]},{"entry":["TInt SetParseMode(","Selects one or more parse modes."]},{"entry":["TInt aParseMode)","aParseMode is one or more of the following:"]},{"entry":[{},"EConvertTagsToLowerCase - Converts"]},{"entry":[{},"elements and attributes to lowercase. This can"]},{"entry":[{},"be used for case-insensitive HTML so that a"]},{"entry":[{},"tag can be matched to a static string in the"]},{"entry":[{},"string pool."]},{"entry":[{},"EErrorOnUnrecognisedTags - Reports an"]},{"entry":[{},"error when unrecognised tags are found."]},{"entry":[{},"EReportUnrecognisedTags - Reports"]},{"entry":[{},"unrecognised tags."]},{"entry":[{},"EReportNamespaces - Reports the"]},{"entry":[{},"namespace."]},{"entry":[{},"EReportNamespacePrefixes - Reports the"]},{"entry":[{},"namespace prefix."]},{"entry":[{},"ESendFullContentInOneChunk - Sends all"]},{"entry":[{},"content data for an element in one chunk."]},{"entry":[{},"EReportNameSpaceMapping - Reports"]},{"entry":[{},"namespace mappings via the"]},{"entry":[{},"DoStartPrefixMapping( ) &"]},{"entry":[{},"DoEndPrefixMapping( ) methods."]},{"entry":[{},"If this function is not called the default will be:"]},{"entry":[{},"EReportUnrecognisedTags |"]},{"entry":[{},"EReportNamespaces"]},{"entry":[{},"If the parsing mode is not supported"]},{"entry":[{},"KErrNotSupported is returned."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"RGeneratorSession","The following is the public API for this class:",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Method","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void OpenL(","Opens a generator session."]},{"entry":["MDataSupplierWriter& aWriter,","aWriter is the data supplier writer used to generate"]},{"entry":["TUid aMarkupMimeType,","a document."]},{"entry":["const TDesC8&","aMarkupMimeType is the MIME type of the"]},{"entry":["aDocumentMimeType)","generator to open."]},{"entry":[{},"aDocumentMimeType is the MIME type of"]},{"entry":[{},"the document to parse."]},{"entry":["void OpenL(","Opens a generator session."]},{"entry":["MDataSupplierWriter& aWriter,","aWriter is the data supplier writer used to"]},{"entry":["TUid aMarkupMimeType,","generate a document."]},{"entry":["const TDesC8&","aMarkupMimeType is the MIME type of the"]},{"entry":["aDocumentMimeType,","generator to open."]},{"entry":["RMarkupPlugins aPlugins[ ])","aDocumentMimeType is the MIME type of"]},{"entry":[{},"the document to parse."]},{"entry":[{},"aPlugins is an array of plug-ins to use with the"]},{"entry":[{},"generator."]},{"entry":["void OpenL(","Opens a generator session."]},{"entry":["MDataSupplierWriter& aWriter,","aWriter is the data supplier writer used to"]},{"entry":["TUid aMarkupMimeType,","generate a document."]},{"entry":["const TDesC8&","aMarkupMimeType is the MIME type of the"]},{"entry":["aDocumentMimeType,","generator to open."]},{"entry":["RMarkupPlugins aPlugins[ ],","aDocumentMimeType is the MIME type of"]},{"entry":["RNamespaceCollection","the document to parse."]},{"entry":["aNamespaceCollection)","aPlugins is an array of plug-ins to use with the"]},{"entry":[{},"generator."]},{"entry":[{},"aNamespaceCollection is a handle to a"]},{"entry":[{},"previous namespace collection. This is useful if a"]},{"entry":[{},"generator or another parser session has been"]},{"entry":[{},"created so that same namespace collection can be"]},{"entry":[{},"shared."]},{"entry":["void Close( )","Closes the generator session."]},{"entry":["void Reset(","Resets the generator ready to generate a new"]},{"entry":["MDataSupplierWriter& aWriter,","document."]},{"entry":["MMarkupCallback& aCallback)","aWriter is the data supplier writer used to"]},{"entry":[{},"generate a document."]},{"entry":[{},"aCallback is a reference to the call-back so the"]},{"entry":[{},"generator can report events."]},{"entry":["void BuildStartDocumentL(","Builds the start of the document."]},{"entry":["RDocumentParameters","aDocParam specifies the various parameters of"]},{"entry":["aDocParam);","the document. In the case of WBXML this would"]},{"entry":[{},"state the public ID and string table."]},{"entry":["void BuildEndDocumentL( )","Builds the end of the document."]},{"entry":["void BuildStartElementL(","Builds the start element with attributes and"]},{"entry":["RTagInfo& aElement,","namespace if specified."]},{"entry":["RAttributeArray& aAttributes)","aElement is a handle to the element's details."]},{"entry":[{},"aAttributes contains the attributes for the"]},{"entry":[{},"element."]},{"entry":["void BuildEndElementL(","Builds the end of the element."]},{"entry":["RTagInfo& aElement)","aElement is a handle to the element's details."]},{"entry":["void BuildContentL(","Builds part or all of the content. Large content"]},{"entry":["const TDesC8& aContentPart)","should be built in chunks. I.e. this function"]},{"entry":[{},"should be called many times for each chunk."]},{"entry":[{},"aBytes is the raw content data. This data must be"]},{"entry":[{},"converted to the correct character set by the"]},{"entry":[{},"client."]},{"entry":["void BuildPrefixMappingL(","Builds a prefix - URI namespace for the next"]},{"entry":["RString& aPrefix,","element to be built. This method can be called"]},{"entry":["RString& aUri)","for each namespace that needs to be declared."]},{"entry":[{},"aPrefix is the Namespace prefix being declared."]},{"entry":[{},"aUri is the Namespace URI the prefix is mapped"]},{"entry":[{},"to."]},{"entry":["void BuildProcessingInstructionL(","Build a processing instruction."]},{"entry":["RString& aTarget,","aTarget is the processing instruction target."]},{"entry":["RString& aData)","aData is the processing instruction data."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The following is the public API for this class:",{"@attributes":{"id":"p-0076","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Method","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void Open(","Sets the tag information for an element or"]},{"entry":["RString& aUri,","attribute."]},{"entry":["RString& aPrefix,","aUri is the URI of the namespace."]},{"entry":["RString& aLocalName)","aPrefix is the prefix of the qualified name."]},{"entry":[{},"aLocalName is the local name of the qualified"]},{"entry":[{},"name."]},{"entry":["void Close( )","Closes the tag information."]},{"entry":["RString& Uri( )","Returns the URI."]},{"entry":["RString& LocalName( )","Returns the local name."]},{"entry":["RString& Prefix( )","Returns the prefix."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The following is the public API for this class:",{"@attributes":{"id":"p-0078","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Method","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void Connect( )","Every time this method is called a reference counter"]},{"entry":[{},"is incremented so that the namespace collection is only"]},{"entry":[{},"destroyed when no clients are using it."]},{"entry":["void Close( )","Every time this method is called a reference counter is"]},{"entry":[{},"decremented and the object is destroyed only when the reference"]},{"entry":[{},"counter is zero."]},{"entry":["const CMarkupNameSpace&","Opens a namespace plug-in and returns a"]},{"entry":["OpenNamespaceL(","reference to the namespace plug-in. If the"]},{"entry":["const TDesC8& aMimeType)","namespace plug-in is not loaded it will be"]},{"entry":[{},"automatically loaded."]},{"entry":[{},"aMimeType is the MIME type of the plug-in to"]},{"entry":[{},"open."]},{"entry":["const CMarkupNameSpace&","Opens a namespace plug-in and returns a"]},{"entry":["OpenNamespaceL(","reference to the namespace plug-in."]},{"entry":["TUint8 aCodePage)","aCodePage is the code page of the plug-in to"]},{"entry":[{},"open."]},{"entry":["void Reset( )","Resets the namespace collection and string pool."]},{"entry":["RStringPool StringPool( )","Returns a handle to the string pool object."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The following is the API for this class:",{"@attributes":{"id":"p-0080","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Method","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void NewL(RStringPool","Creates the namespace plug-in."]},{"entry":["aStringPool)","aStringPool is a handle of the string pool to add"]},{"entry":[{},"static string tables."]},{"entry":["RString& Element(","Returns a handle to the string."]},{"entry":["TUint8 aWbxmlToken) const","aWbxmlToken is the WBXML token of the"]},{"entry":[{},"element."]},{"entry":["void AttributeValuePair(","Returns a handle to the attribute and value"]},{"entry":["TUint8 aWbxmlToken","strings."]},{"entry":["RString& aAttribute,","aWbxmlToken is the WBXML token of the"]},{"entry":["RString& aValue) const","attribute."]},{"entry":[{},"aAttribute is the handle to the attribute string."]},{"entry":[{},"aValue is the handle to the value string."]},{"entry":["RString& AttributeValue(","Returns a handle to an attribute value."]},{"entry":["TUint8 aWbxmlToken) const","aWbxmlToken is the WBXML token of the attribute."]},{"entry":["RString& NamespaceUri( ) const","Returns the namespace name."]},{"entry":["TUint8 CodePage( ) const","Returns the code page for this namespace."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The following is the API for this class:",{"@attributes":{"id":"p-0082","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Method","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["RString NameSpaceUri( )","Returns the namespace URI for"]},{"entry":[{},"this code page."]},{"entry":["TInt StringPoolIndexFromToken(","Gets a StringPool index from"]},{"entry":["TInt aToken);","a token value. \u22121 is returned"]},{"entry":[{},"if the item is not found."]},{"entry":["TInt TokenFromStringPoolIndex(","Gets a token value from a"]},{"entry":["TInt aIndex);","StringPool index. \u22121 is returned"]},{"entry":[{},"if the item is not found."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The following is the API for this ECOM class:",{"@attributes":{"id":"p-0084","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Method","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CMarkupPluginBase& RootPlugin( )","Returns a reference to the root plug-in. This must"]},{"entry":[{},"be either a parser or generator plug-in."]},{"entry":["CMarkupPluginBase&","Returns a reference to the Parent plug-in."]},{"entry":["ParentPlugin( )",{}]},{"entry":["RElementStack& ElementStack( )","Returns a handle to the element stack."]},{"entry":["RNameSpaceCollection&","Returns a handle to the namespace collection."]},{"entry":["NamespaceCollection( )",{}]},{"entry":["CMarkupCharSetConverter&","Returns a reference to the character set converter"]},{"entry":["CharSetConverter( )","object."]},{"entry":["TBool IsChildElementValid(","Checks if the aChildElement is a valid child of"]},{"entry":["RString& aParentElement,","aParentElement."]},{"entry":"RString& aChildElement)"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The following is the API for this ECOM class:",{"@attributes":{"id":"p-0086","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Method","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CMarkupPlugin*","Creates an instance of a mark-up plug-in."]},{"entry":["NewL","aCallback is a reference to the call-back to"]},{"entry":["(MMarkupCallback&","report events."]},{"entry":"aCallback)"},{"entry":["void SetParent(","Sets the parent plug-in for this plug-in."]},{"entry":["CMarkupPluginBase*","aParentPlugin is a pointer to the parent plug-in"]},{"entry":["aParentPlugin)","or NULL if there is no parent. A parser or"]},{"entry":[{},"generator does not have a parent so this must not"]},{"entry":[{},"be set, as the default NULL will indication there"]},{"entry":[{},"is not parent."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The following is the API for this ECOM class:",{"@attributes":{"id":"p-0088","num":"0087"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Method","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["CParserSession* NewL(","Opens a parser session."]},{"entry":["MDataSupplierReader& aReader,","aReader is the data supplier reader to use during"]},{"entry":["const TDesC8&","parsing."]},{"entry":["aMarkupMimeType,","aMarkupMimeType is the MIME type of the"]},{"entry":["const TDesC8&","parser to open."]},{"entry":["aDocumentMimeType,","aDocumentMimeType is the MIME type of"]},{"entry":["MMarkupCallback& aCallback,","the document to parse."]},{"entry":["RNamespaceCollection*","aCallback is a reference to the call-back so the"]},{"entry":["aNamespaceCollection,","parser can report events."]},{"entry":["CMarkupCharSetConverter&","aNamespaceCollection is a handle to a"]},{"entry":["aCharSetConverter)","previous namespace collection. Set to NULL if a"]},{"entry":[{},"new RNamespaceCollection is to be used."]},{"entry":[{},"aCharSetConverter is a reference to the"]},{"entry":[{},"character set conversion class."]},{"entry":["void Start( )","Start parsing the document."]},{"entry":["void Stop( )","Stop parsing the document."]},{"entry":["void Reset(","Resets the parser ready to parse a new document."]},{"entry":["MDataSupplierReader& aReader,","aReader is the data supplier reader to use during"]},{"entry":["MMarkupCallback& aCallback)","parsing."]},{"entry":[{},"aCallback is a reference to the call-back so the"]},{"entry":[{},"parser can report events."]},{"entry":["void SetParseMode(","Selects one or more parse modes."]},{"entry":["TInt aParseMode)","See RParserSession for details on aParseMode."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The following is the API for this ECOM class:",{"@attributes":{"id":"p-0090","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Method","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void OpenL(","Opens a generator session."]},{"entry":["MDataSupplierWriter& aWriter,","aWriter is the data supplier writer used to"]},{"entry":["TUid aMarkupMimeType,","generate a document."]},{"entry":["const TDesC8&","aMarkupMimeType is the MIME type of the"]},{"entry":["aDocumentMimeType,","generator to open."]},{"entry":["MMarkupCallback& aCallback,","aDocumentMimeType is the MIME type of"]},{"entry":["RNamespaceCollection*","the document to parse."]},{"entry":["aNamespaceCollection,","aCallback is a reference to the call-back so the"]},{"entry":["CMarkupCharSetConverter&","generator can report events."]},{"entry":["aCharSetConverter)","aNamespaceCollection is a handle to a"]},{"entry":[{},"previous namespace collection. Set to NULL if a new"]},{"entry":[{},"RNamespaceCollection is to be used."]},{"entry":[{},"aCharSetConverter is a reference to the"]},{"entry":[{},"character set conversion class."]},{"entry":["void Reset(","Resets the generator ready to generate a new"]},{"entry":["MDataSupplierWriter& aWriter,","document."]},{"entry":["MMarkupCallback& aCallback)","aWriter is the data supplier writer used to"]},{"entry":[{},"generate a document."]},{"entry":[{},"aCallback is a reference to the call-back so the"]},{"entry":[{},"generator can report events."]},{"entry":["void BuildStartDocumentL(","Builds the start of the document."]},{"entry":["RDocumentParameters","aDocParam specifies the various parameters of"]},{"entry":["aDocParam);","the document."]},{"entry":["void BuildEndDocumentL( )","Builds the end of the document."]},{"entry":["void BuildStartElementL(","Builds the start element with attributes and"]},{"entry":["RTagInfo& aElement,","namespace if specified."]},{"entry":["RAttributeArray& aAttributes)","aElement is a handle to the element's details."]},{"entry":[{},"aAttributes contains the attributes for the"]},{"entry":[{},"element."]},{"entry":["void BuildEndElementL(","Builds the end of the element."]},{"entry":["RTagInfo& aElement)","aElement is a handle to the element's details."]},{"entry":["void BuildContentL(","Builds part or all of the content. Large content"]},{"entry":["const TDesC8& aContentPart)","should be built in chunks. I.e. this function"]},{"entry":[{},"should be called many times for each chunk."]},{"entry":[{},"aBytes is the raw content data. This data must be"]},{"entry":[{},"converted to the correct character set by the"]},{"entry":[{},"client."]},{"entry":["void BuildProcessingInstructionL(","Build a processing instruction."]},{"entry":["RString& aTarget,","aTarget is the processing instruction target."]},{"entry":["RString& aData)","aData is the processing instruction data."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The following is the API for this class:",{"@attributes":{"id":"p-0092","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Method","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["RTagInfo& Attribute( )","Returns a handle to the attribute's name details."]},{"entry":["TAttributeType Type( )","Returns the attribute's type. Where"]},{"entry":[{},"TAttributeType is one of the following"]},{"entry":[{},"enumeration:"]},{"entry":[{},"CDATA"]},{"entry":[{},"ID"]},{"entry":[{},"IDREF"]},{"entry":[{},"IDREFS"]},{"entry":[{},"NMTOKEN"]},{"entry":[{},"NMTOKENS"]},{"entry":[{},"ENTITY"]},{"entry":[{},"ENTITIES"]},{"entry":[{},"NOTATION"]},{"entry":["RString& Value( )","Returns a handle to the attribute value. If the"]},{"entry":[{},"attribute value is a list of tokens (IDREFS,"]},{"entry":[{},"ENTITIES or NMTOKENS), the tokens will be"]},{"entry":[{},"concatenated into a single RString with each"]},{"entry":[{},"token separated by a single space."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The following is the API for this mix-in class:",{"@attributes":{"id":"p-0094","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Method","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["TUint8 GetByteL( )","Get a single byte from the data supplier."]},{"entry":["const TDesC8& GetBytesL(","Gets a descriptor of size aNumberOfChars. If the number"]},{"entry":["TInt aNumberOfBytes)","of bytes is not available this method leaves with KErrEof."]},{"entry":[{},"The returned descriptor must not be deleted until another"]},{"entry":[{},"call to GetBytesL or EndTransactionL( ) is made."]},{"entry":["void StartTransactionL( )","The parser calls this to indicate the start of a transaction."]},{"entry":["void EndTrasactionL( )","The parser calls this to indicate the transaction has ended."]},{"entry":[{},"Any data stored for the transaction may now be deleted."]},{"entry":["void RollbackL( )","The parse calls this to indicate the transaction must be rolled"]},{"entry":[{},"back to the exact state as when StartTransactionL( ) was"]},{"entry":[{},"called."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The following is the API for this mix-in class:",{"@attributes":{"id":"p-0096","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Method","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void PutByteL(","Put a byte in the data supplier."]},{"entry":[{},"TUint8 aByte)"]},{"entry":[{},"void PutBytesL(","Puts a descriptor in the data supplier."]},{"entry":[{},"const TDesC8& aBytes)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The following is the API for this mix-in class:",{"@attributes":{"id":"p-0098","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Method","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["void OnStartDocumentL(","Callback to indicate the start of the document."]},{"entry":["RDocumentParameters","aDocParam specifies the various parameters of the"]},{"entry":["aDocParam,","document."]},{"entry":["TInt aErrorCode);","aErrorCode is the error code. If this is not KErrNone then"]},{"entry":[{},"special action may be required."]},{"entry":["void OnEndDocumentL(","Indicates the end of the document has been reached."]},{"entry":["TInt aErrorCode);","aErrorCode is the error code. If this is not KErrNone then"]},{"entry":[{},"special action may be required."]},{"entry":["void OnStartElementL(","Callback to indicate an element has been parsed."]},{"entry":["RTagInfo& aElement,","aElement is a handle to the element's details."]},{"entry":["RAttributeArray& aAttributes,","aAttributes contains the attributes for the element."]},{"entry":["TInt aErrorCode);","aErrorCode is the error code. If this is not KErrNone then"]},{"entry":[{},"special action may be required."]},{"entry":["void OnEndElementL(","Callback to indicate the end of the element has been"]},{"entry":["RTagInfo& aElement,","reached."]},{"entry":["TInt aErrorCode);","aElement is a handle to the element's details."]},{"entry":[{},"aErrorCode is the error code. If this is not KErrNone then"]},{"entry":[{},"special action may be required."]},{"entry":["void OnContentL(","Sends the content of the element. Not all the content may"]},{"entry":["const TDesC8& aBytes,","be returned in one go. The data may be sent in chunks."]},{"entry":["TInt aErrorCode)","When an OnEndElementL is received this means there is"]},{"entry":[{},"no more content to be sent."]},{"entry":[{},"aBytes is the raw content data for the element. The client is"]},{"entry":[{},"responsible for converting the data to the required character"]},{"entry":[{},"set if necessary. In some instances with WBXML opaque"]},{"entry":[{},"data the content may be binary and must not be converted."]},{"entry":[{},"aErrorCode is the error code. If this is not KErrNone then"]},{"entry":[{},"special action may be required."]},{"entry":["void OnStartPrefixMappingL(","Notification of the beginning of the scope of a prefix-URI"]},{"entry":["RString& aPrefix,","Namespace mapping. This method is always called before"]},{"entry":["RString& aUri,","the corresponding OnStartElementL method."]},{"entry":["TInt aErrorCode)","aPrefix is the Namespace prefix being declared."]},{"entry":[{},"aUri is the Namespace URI the prefix is mapped to."]},{"entry":[{},"aErrorCode is the error code. If this is not KErrNone then"]},{"entry":[{},"special action may be required."]},{"entry":["void OnEndPrefixMappingL(","Notification of the end of the scope of a prefix-URI"]},{"entry":["RString& aPrefix,","mapping. This method is called after the corresponding"]},{"entry":["TInt aErrorCode)","DoEndElementL method."]},{"entry":[{},"aPrefix is the Namespace prefix that was mapped."]},{"entry":[{},"aErrorCode is the error code. If this is not KErrNone then"]},{"entry":[{},"special action may be required."]},{"entry":["void OnIgnoreableWhiteSpaceL(","Notification of ignorable whitespace in element content."]},{"entry":["const TDesC8& aBytes,","aBytes are the ignored bytes from the document being"]},{"entry":["TInt aErrorCode)","parsed."]},{"entry":[{},"aErrorCode is the error code. If this is not KErrNone then"]},{"entry":[{},"special action may be required."]},{"entry":["void OnSkippedEntityL(","Notification of a skipped entity. If the parser encounters an"]},{"entry":["RString& aName,","external entity it does not need to expand it \u2014it can return"]},{"entry":["TInt aErrorCode)","the entity as aName for the client to deal with."]},{"entry":[{},"aName is the name of the skipped entity."]},{"entry":[{},"aErrorCode is the error code. If this is not KErrNone then"]},{"entry":[{},"special action may be required."]},{"entry":["void OnProcessingInstructionL(","Receive notification of a processing instruction."]},{"entry":["const TDesC8& aTarget,","aTarget is the processing instruction target."]},{"entry":["const TDesC8& aData,","aData is the processing instruction data. If empty none was"]},{"entry":["TInt aErrorCode)","supplied."]},{"entry":[{},"aErrorCode is the error code. If this is not KErrNone then"]},{"entry":[{},"special action may be required."]},{"entry":["void OnOutOfDataL( )","There is no more data in the data supplier to parse. If there"]},{"entry":[{},"is more data to parse Start( ) should be called once there is"]},{"entry":[{},"more data in the supplier to continue parsing."]},{"entry":["void OnError(TInt aError)","An error has occurred where aError is the error code"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}]},{"@attributes":{"id":"p-0099","num":"0098"},"figref":"FIG. 6"},"Element Not Valid at Current Level in DTD","Auto correction is left up to the plugin implementers to decide how and what should be corrected. The sequence diagram in  shows an example of what is possible with the case where the format of the document is valid, however, there is a invalid element (C) that should be at a different level as shown in an example document below:",{"@attributes":{"id":"p-0101","num":"0100"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<A>Content"]},{"entry":[{},"\u2003\u2003<B>"]},{"entry":[{},"\u2003\u2003\u2003\u2003<C> \/\/ Not valid for the DTD, should be a root element."]},{"entry":[{},"\u2003\u2003\u2003\u2003Some content"]},{"entry":[{},"\u2003\u2003\u2003\u2003<\/C>"]},{"entry":[{},"\u2003\u2003<\/B>"]},{"entry":[{},"<\/A>"]},{"entry":[{},"\/\/ <C> should go here"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The bad element is detected by the DTD validator and sent to the auto correct component. The auto corrector realises that this element has an error from the error code passed in the call-back and tries to find out where the element should go, and send back the appropriate OnEndElementL( ) call-backs to the client.","Scenarios","Set-up a parser to parse WBXML without any plug-ins.","Scenario to parse the following document:",{"@attributes":{"id":"p-0105","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<A>"]},{"entry":[{},"\u2003\u2003<B>"]},{"entry":[{},"\u2003\u2003Content"]},{"entry":[{},"\u2003\u2003<\/B>"]},{"entry":[{},"<A>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":["1. The client creates a data supplier that contains the data to be parsed.","2. The client creates an RParserSession passing in the data supplier, MIME type for WBXML, the MIME type of the document to be parsed and the call-back pointer where parsing events are to be received.","3. The client begins the parsing by calling Start( ) on the parser session.","4. The parser makes the following call-backs to the client:\n    \n    "]}},"The same document as 5.1 is used in this scenario.\n\n","The document in 5.1 is to be generated in this scenario.\n\n","Testing","The data supplier and parser generator set-up components can be tested individually\u2014all the functions are synchronous and therefore no active objects need to be created for testing.","The following steps can be carried out to test parsing and generation of WBXML or XML:\n\n","Additional tests are carried out to test error conditions of parsing, such as badly formatted documents and corrupt documents.","Glossary","The following technical terms and abbreviations are used within this document.",{"@attributes":{"id":"p-0113","num":"0156"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Term","Definition"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["XML","Extensible Markup Language"]},{"entry":["WBXML","WAP Binary Extensible Markup Language"]},{"entry":["SAX","Simple API for XML"]},{"entry":["DOM","Document Object Model"]},{"entry":["Element","This is a tag enclosed by angle brackets."]},{"entry":[{},"E.g <Name>, <Address>,"]},{"entry":[{},"<Phone> etc"]},{"entry":["Attributes","These are the attributes associated with an element."]},{"entry":[{},"E.g. <Phone Type=\u201dMobile\u201d> The attribute"]},{"entry":[{},"here is \u201cType\u201d."]},{"entry":["Values","These are the actual value of an attribute. E.g. <Phone"]},{"entry":[{},"Type=\u201dMobile\u201d> The value here is \u201cMobile\u201d"]},{"entry":["Content","This is the actual content for an element. E.g."]},{"entry":[{},"<Name>Symbian<\/Name>. Here \u201cSymbian\u201d is the"]},{"entry":[{},"content for the element \u201cName\u201d."]},{"entry":["DTD","Document Type Definition"]},{"entry":["MIME","Multipurpose Internet Mail Extensions"]},{"entry":["Code Page","Since only 32 elements can be defined In WBXML, code"]},{"entry":[{},"pages are created so that each code page can have"]},{"entry":[{},"32 elements."]},{"entry":["XSLT","Extensible Style-sheet Language Transformations"]},{"entry":["SOAP","Simple Object Access Protocol"]},{"entry":["URI","Uniform Resource Identifiers"]},{"entry":["qualified name","A qualified name specifies a prefix: local name e.g."]},{"entry":[{},"\u2018HTML:B\u2019"]},{"entry":["prefix","From the qualified name example this is \u2018HTML\u2019"]},{"entry":["local name","From the qualified name example this is \u2018B\u2019"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Table A1 shows a situation where the end tags are the wrong way round for A and B. This is very easy to fix since the DTD validator keeps a stack of the tags, it knows what the end tag should be.",{"@attributes":{"id":"p-0115","num":"0158"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE A1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"End tags that are the wrong way round"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<A>Content"]},{"entry":[{},"\u2003\u2003<B>"]},{"entry":[{},"\u2003\u2003More content"]},{"entry":[{},"\u2003\u2003<\/A>"]},{"entry":[{},"<\/B>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Table A2 shows the situation where the B end tag is missing. Since the end tag does not match a guess can be made that there should be an end tag for B before the end tag of A.",{"@attributes":{"id":"p-0117","num":"0160"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE A2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Missing end tag"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<A>Content"]},{"entry":[{},"\u2003\u2003<B>"]},{"entry":[{},"\u2003\u2003More content"]},{"entry":[{},"<\/A>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Table A3 shows the situation where there are no end tags for A and B. The DTD validator will detect the problem and send an end tag for B to the client. The auto correct component will query the DTD validator if the C tag is valid for the parent element A. If it is valid a OnStartELementL( ) will be sent to the client, otherwise the auto correct component can check further up the element stack to find where this element is valid. If it is not valid anywhere in the stack then it will be ignored together with any content and end element tag.",{"@attributes":{"id":"p-0119","num":"0162"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE A3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Missing end tags"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<A>Content"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<B>"]},{"entry":[{},"More content"]},{"entry":[{},"<C>"]},{"entry":[{},"Some content"]},{"entry":[{},"<\/C>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"The tables below show the WBXML tokens for the example namespace. Tables 1 to 3 each represent a static string table. Tables 1 shows the elements for code page 0. Tables 2 and 3 are for attribute value pairs respectively. Each attribute index on Table 2 refers to the values of the same index in Table 3. These token values must match up in Tables 2 and 3. If an attribute does not have a value then there must be a blank as shown in Table 3 with token . For attribute values, these also appear in Table 3 but have a WBXML token value of 128 or greater.",{"@attributes":{"id":"p-0121","num":"0164"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"ElementTable0, code page 0"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"WBXML"]},{"entry":[{},"Element type name","token"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Addr","5"]},{"entry":[{},"AddType","6"]},{"entry":[{},"Auth","7"]},{"entry":[{},"AuthLevel","8"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0122","num":"0165"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"AttributeValuePairNameTable, code page 0"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Attribute name\/value pair","WBXML"]},{"entry":[{},"(attribute part)","token"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"TYPE","6"]},{"entry":[{},"TYPE","7"]},{"entry":[{},"NAME","8"]},{"entry":[{},"NAME","9"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0123","num":"0166"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"AttributeValuePairValueTable, code page 0"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Attribute name\/value pair","WBXML"]},{"entry":[{},"(value part)","token"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ADDRESS","6"]},{"entry":[{},"URL","7"]},{"entry":[{},{},"8"]},{"entry":[{},"BEARER","9"]},{"entry":[{},"GSM\/CSD","128"]},{"entry":[{},"GSM\/SMS","129"]},{"entry":[{},"GSM\/USSD","130"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"The following string table files (.st) are created for each table:",{"@attributes":{"id":"p-0125","num":"0168"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"String table for Table 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"# Element table for code page 0"]},{"entry":[{},"stringtable ElementCodePage0"]},{"entry":[{},"EAddr Addr"]},{"entry":[{},"EAddType AddType"]},{"entry":[{},"EAuth Auth"]},{"entry":[{},"EAuthLevel AuthLevel"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0126","num":"0169"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"String table for Table 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"# Attributes table for code page 0"]},{"entry":[{},"stringtable AttributesCodePage0"]},{"entry":[{},"EType Type"]},{"entry":[{},"EType Type"]},{"entry":[{},"EName Name"]},{"entry":[{},"EName Name"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0127","num":"0170"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"String Table for Table 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"# Attribute values table for code page 0"]},{"entry":[{},"stringtable AttributeValuesCodePage0"]},{"entry":[{},"EAddress Address"]},{"entry":[{},"EURL URL"]},{"entry":[{},"EBearer BEARER"]},{"entry":[{},"EGSM_CSD GSM\/CSD"]},{"entry":[{},"EGSM_SMS GSM\/SMS"]},{"entry":[{},"EGSM_USSD GSM\/USSD"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Below shows an example of how to setting up the parser and generator with DTD checking and auto correction.\n\n","The Mark-up Language framework design relies on the fact that it is possible (using the \u2018String Pool\u2019 techniques described below, although other mapping techniques can also be used) to provide the same interface to clients no matter if text or binary mark-up language is used.","Text based mark up languages use strings, i.e. sequences of characters or binary data. In the String Pool technique, static tables of these strings are created at compile time, with one string table per namespace, for all the elements, attributes and attribute values needed to describe a particular type of mark-up document. Each element, attribute and attribute value is assigned an integer number and these integer \u2018handles\u2019 form an index of the strings. A string in an XML document can be rapidly compared to all strings in the string table by the efficient process of comparing the integer representation of the string with all of the integer handles in the static string table. The main benefit of using a string pool for parsing is therefore that it makes it very easy and efficient for the client to check for what is being parsed, since handles to strings are used instead of actual strings. This means only integers are compared rather than many characters, as would be the normal case if string pools were not used. Also, comparisons can be carried out in a simple switch statement in the code, making the code efficient, and easier to read and maintain. Hence, the string pool is used to make string comparisons efficient at the expense of creation of the strings.","For binary mark-up language (e.g. WBXML) the situation is more complex since there are no strings in WBXML. In WBXML, everything is tokenised (i.e. given a token number). We get around the absence of strings as follows: a table of mappings of each of the WBXML tokens to the index of the string in the string table is created (see ). Each mapping is given a unique integer value\u2014a handle. Since it is required to map from tokens to strings and vice versa, two lists of integer value handles are created: one indexed on tokens and the other indexed on the index of the position in the string table. This is so that it is quick to map from one type to the other. All this is encapsulated in the namespace plug-in and therefore is insulated from the client, parser and generator. The client can therefore parse a binary or text document without having to know about the specific format\u2014it simply uses the integer handle (RString), which will work correctly for both text and binary mark-up languages."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention will be described with reference to the acompanyuing drawings, in which:",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
