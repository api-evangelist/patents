---
title: Portable distributed application framework
abstract: A portable distributed application framework that uses a definition file describing a structure of data and commands to be used by the framework to interface with an application. A proxy, responsive to a definition file, creates and receives messages based on the definition file. The created messages contain data and commands used to control the application while the received messages contain data from the application. A control, responsive to the definition file, relays messages between the proxy and the application. A housing, responsive to the definition file and the messages from the proxy, provides the application with configuration information and receives data from the application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07467078&OS=07467078&RS=07467078
owner: Agilent Technologies Inc.
number: 07467078
owner_city: Santa Clara
owner_country: US
publication_date: 20040716
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION","Overview","Emulation Control","Emulation Housing","Proxy Control","Tcl Interface","GUI","Protocol Emulation Definition","Parcel Link","CONCLUSION"],"p":["Network devices, such as routers, are extensively tested to ensure that erroneous transmissions and fatal errors are minimized. A variety of test devices are available on the marketplace, including the ROUTER TESTER from AGILENT TECHNOLOGIES, assignee of the present application. Such test devices typically monitor the router's response to a variety of simulated input.","The process of routing can be quickly summarized as a node finding the path to every possible destination. Routing is present in everything from layer 1 (the physical layer) on up. The routing that most people are familiar with, however, occurs at layer 3 (the network layer) and as such, only layer 3 (and more specifically) Internet Protocol (IP) routing will be referenced herein. Routers use tables to determine where to forward packets. Updating these tables is a function performed by routing protocols. Each router is responsive to one or more protocols.","Protocols for exchanging routing information connect multiple routers around the world to provide them with a common view of the network through their heterogeneous, though generally consistent routing tables. Routing tables store all information necessary for the router to reach every destination on the network irrespective of size. There are a wide variety of routing protocols used to contribute to the routing tables across a network. Protocols such as BGP, OSPF, RIP and ISIS help to convey a correct and coherent picture of the network to all routers on the network.","Known router tester simulate network traffic using specifically created \u201ctest packets\u201d of data that are typical of the live data present on the network. These test packets are transmitted to the network device over a network under test. Parameters tested by traffic simulator systems (including ROUTER TESTER) include routing verification, achievement of Quality of Service (QoS) levels under load, and correct inter-working with other devices. Many of these so-called \u201cpacket blasters\u201d also test the ability of the network device to adhere to protocols by formulating and transmitting data in accordance with the protocols.",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1","b":["100","100","102","104","102","102","106","106","108"],"i":["n ","n ","n "]},"The test packets produced by the protocol emulation cards are built according to the rules and interpretations of communications protocols, such as those defined by the many standards bodies in the industry. There are many communications protocols in use and new protocols continue to be developed. Typically, new protocols are initially developed by equipment manufacturers and are proprietary in nature. Often, the protocols are subsequently adopted by standards bodies for widespread implementation in industry. The protocol emulation cards use protocol state machines to create data for transmission in accordance with the subject protocol. The state machines are similar in operation to the state machines used in the routers themselves.","The current software architecture associated with traffic simulator test systems requires hard-coding all parts of the protocol emulation solution including the graphical user interface, scripting API, configuration and control components, along with the protocol state machine itself. The hard coding required for each protocol has resulted in the use of an enormous amount of human talent to create the large body of code. Much of this code is dedicated to interfacing the computer  with each new protocol emulation card ","The traditional approach to interfacing the computer  with each new protocol emulation card requires methods and associated parameters to be known at the time the interface is written and hard coded in an interface description language (IDL). Under this paradigm, new methods and parameters are continually being created each time new protocol emulations are written or old protocols are extended. This has resulted in a vast API (application programming interface) containing many hundreds of methods and parameters, resulting in a body of code that is expensive to maintain. Further, the known approaches result in the API being replicated at several different layers, thereby compounding the problems. Thus, each change to the API (no matter how small) requires the updating of a significant amount of code and different levels within the system. One side effect of this approach is that a unique GUI (graphical user interface) must be generated for each protocol and each update thereof. As with the API, as the number of protocols grow, so do the required GUI implementations.","Efforts are now being made to design generic systems that alleviate some of the foregoing problems. One example is described in co-pending U.S. patent application Ser. No.: 10\/266,507, Publication No.: U.S. 20040068681 A1, entitled: Building packets of data. U.S. 20040068681 A1, incorporated herein by reference, uses an external protocol emulation description to drive a generic protocol data unit (PDU) encode\/decode engine. A next step is to build a generic interface to the protocol emulators that do not require new code or hard coded interfaces changes for each new emulator or change thereto.","On approach to this situation is to develop a proprietary compiled language for controlling protocols. Language statements are written and compiled on the host computer and the resulting object files are distributed to the embedded software modules for execution. Under this approach, new language statements are needed for each protocol developed. This requires continual reworking of the compiler, which by its nature is a complex, highly skilled task. Further, GUI development remains a large ongoing task for each protocol.","Another approach is to develop a conventional, non-generic, application framework. This approach requires protocol emulations to be built within fixed, pre-defined APIs and data structures, or the framework be heavily customized for each protocol. Experience with real-world protocols suggests that heavy customization is necessary, making this approach unsatisfactory.","Accordingly, the present inventors have recognized a need for a generic framework that interfaces with applications based on definition files external to framework. To adapt the framework for a different application would only require the creation of a new definition file as opposed to the reworking of the framework itself. In the context of a protocol state machine, such a framework would enable the use of a plurality of user interfaces, including a generic GUI, capable of supporting all protocol emulations; a generic control and command host component; and a generic protocol housing on the embedded device.","In the description contained hereinafter, the use of a lowercase \u201cn\u201d adjacent to an element identifier denotes a non-specific instance of an element within a group of elements rather than a specific element as shown in the figures or discussed in the specification with a non-italicized letter adjacent to the element number. In the case of a group of elements sharing a common element identifier, the use of such element identifier without an adjacent letter refers to the group of elements as a whole.","Reference will now be made to embodiments of the present invention, examples of which are illustrated in the accompanying drawings, wherein like reference numerals refer to like elements throughout. The detailed description which follows presents methods that may be embodied by routines and symbolic representations of operations of data bits within a computer readable medium, associated processors, data generation and acquisition cards, and the like. A routine is here, and generally, conceived to be a sequence of steps or actions leading to a desired result, and as such, encompasses such terms of art as \u201cprogram,\u201d \u201cobjects,\u201d \u201cfunctions,\u201d \u201csubroutines,\u201d and \u201cprocedures.\u201d These descriptions and representations are the means used by those skilled in the art effectively convey the substance of their work to others skilled in the art. For the sake of convenience, the word \u201cnetwork\u201d will hereinafter in the description and claims be used to refer to any one or more of: a communication network, a network device, any other communication device, and any aspect or aspects of a communication system which can be tested using test packets of data.","Embodiments which comprise methods are described with respect to implementation on a router tester having a configuration similar to the AGILENT ROUTER TESTER. However, the methods recited herein may operate on any of a variety of router testers. More to the point, the methods presented herein are not inherently related to any particular device; rather, various devices may be used with routines in accordance with the teachings herein. In particular the methods described herein for transfer of data from one device to another, while being described with respect to router tester function, may be applicable to the data communication field in general. Machines that may perform the functions described herein include those manufactured by such companies as AGILENT TECHNOLOGIES, INC., HEWLETT PACKARD, and TEKTRONIX, INC. as well as other manufacturers of communication equipment.","With respect to the software described herein, those of ordinary skill in the art will recognize that there exist a variety of platforms and languages for creating software for performing the procedures outlined herein. Embodiments of the present invention can be implemented using any of a number of varieties of C, including C. However, those of ordinary skill in the art also recognize that the choice of the exact platform and language is often dictated by the specifics of the actual system constructed, such that what may work for one type of system may not be efficient on another system. It should also be understood that the routines and calculations described herein are not limited to being executed as software on a computer, but can also be implemented in a hardware processor. For example, the routines and calculations could be implemented with HDL (Hardware Design Language) in an ASICS or in an FGPA using a variety of design tools.","The present invention is directed toward a portable distributed application framework that may be easily adapted to interface with and control a variety of applications. In general, the framework comprises a housing that interfaces with an application, a proxy that interfaces with one or more client interface mechanisms (such as a GUI), and a control that facilitates communication between the proxy and the housing. Each of the housing, proxy and control are configured using the same (or perhaps a copy thereof) description file. The description file contains descriptions of data structures and commands used by the framework to interface with and control the application. The following description will focus on describing the present invention as implement for use in interfacing with and controlling sessions of protocol emulation software. However, the present invention is not limited in use to protocol emulation software but may be suited for use in a variety of environments, especially where management of remote applications is desirable.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2","i":["a ","a","n ","a","b","c","d","n"],"b":["200","202","204","206","102","208","208","208","208","208","208","202","204","206"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 2","FIG. 2"],"i":["b ","b ","n ","b","n. "],"b":["200","210","210","210","210","202","204","206","210","212","210","210","212"]},"As used herein the term \u201cgeneric\u201d is used in the sense that each generic component is written without knowledge of specific protocol emulations. One method to accomplish this goal is to define commands and data structures external of the components in a protocol emulation definition file(s) . In perhaps the preferred embodiment, the protocol emulation definition files  describe: the hardware pattern matchers needed to select emulation packets from the incoming data stream; details of the TCP\/IP sockets used by the emulation, including socket parameters and socket options; a set of generic data-structures used to describe the commands, configuration and results data used by the emulation; and formatting information needed by the GUI to present emulation data to the user. The protocol definition files  may be used to create data structures that are used during run time to configure the GPF  to interact with a particular protocol.","In one embodiment, the protocol emulation definition files  use XML tags to organize services and control data. For example, the configuration of the hardware pattern match filters may be described using an XML <filter> tag. Similarly, the specification of the TCP\/IP sockets required for the emulation may be made using a <socket> tag. The commands and data structures communicated to and from emulations may be described using a <parcel> tag. Finally, an <emulation> tag may be used to assemble the data referenced by such tags. During run time, the assembled data is used to create a data structure accessible by the various components of the GPF . The data structure is referred to herein as a reference model. Static values can be stored in the PROTOCOL EMULATION definition files  and pre-loaded into the reference model. Dynamic values or values that require user input may be externally supplied and communicated to the appropriate component of the GPF  using a communication process based on the data structures described in the <parcels> section. In general each protocol emulation instance, termed a \u201csession\u201d, running on the system will access one or more reference models to obtain configuration and control data. It may prove beneficial to define and create a reference model (or set of reference models) for each type of protocol emulation to be activated on the system.","A general structure of reference models along with a suitable XML syntax is presented in co-pending U.S. patent application Ser. No. 10\/851,303 entitled DISTRIBUTED DATA MODEL. The '303 application focuses on specifics of a particular sub-set of the XML syntax, that contained with <parcels> tags (used to describe the commands and communication data structures). The '303 application was filed on May 21, 2004, is assigned to the assignee of the present application, and is incorporated herein by reference. The present invention extends some of the concepts described in the '303 application to the entire suite of protocol emulation software. Further aspects of the present invention will become apparent upon review of the detailed description and appended claims.","In one embodiment, the GPF  further comprises a generic, self-documenting API. The commands and parameters associated with such an API can be described in the protocol emulation definition files , along with any help text. This allows new commands to be created without writing any framework code. Through the use of tools such as tool control language (\u201cTcl\u201d), entire protocol emulations can be defined in XML and Tcl to run within the framework. This empowers users and technical support engineers to test new protocols immediately without waiting for a supplier to deliver a custom protocol module (e.g. module ). Such a generic emulation would appear identical to the API and GUI as a regular emulation. While there may be performance limitations to such a completely generic solution, the time-to market window is substantially improved. Should higher performance be required, custom module may be provided.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 3","FIG. 1"],"b":["300","300","300","304","308","314","304","302","304","302","308","308","304","306","306","102","314","304","314","310","312"],"i":["n","n","n ","n ","n","n ","n ","n ","n "]},"Each component is provided with protocol emulation definitions . In general, the protocol emulation definitions are all the same for any given protocol. What may vary is whether any particular component is provided with the same set of protocol emulation definitions. For example, an emulation housing does not require a protocol emulation definition for a protocol that will not be executed on that particular port ","From the definitions, as discussed hereinafter in more detail, the components generate reference models . The reference models store data that allows each component to configure, execute and communicate with the other components. This data includes data structures, configuration data, data communication structures (and in effect methods), commands, and descriptions of the foregoing to facilitate their use.","In at least one embodiment, communication to and from the emulation control  is accomplished using messages created (or instantiated) using information contained within the reference models . Such messages, termed \u201cparcels\u201d may contain data or commands. The commands may be used to direct the emulation control  to undertake an action, such as the creation of a protocol emulation session. The data may include information necessary to complete a command or for reporting data from or to the emulation control . In particular parcels are used to communicate data, including data referenced within other segments of the reference model(s), including for example information associated with <filter> and <socket> tags.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 4","FIG. 3","FIG. 3"],"b":["304","304","410","420","310","410","420","420","314"]},"The API  is generally responsible for the creation and transmission of messages between the client  and the emulation control . An API  is provided in an emulation housing to similarly act as a conduit between a protocol state machine  and the emulation control . In at least some embodiments, and as described herein below, the messages are created based upon data contained within <parcel> tags in the protocol emulation definition file . The message creation process, more fully described in co-pending U.S. application #10\/851,303, basically comprises the creation of a reference model based upon the contents of the protocol emulation definition file , followed by the instantiation of an object based on the reference model, or portion thereof. The object is populated with data from any number of sources, including the protocol emulation definition file , the reference model created based on the protocol emulation definition file , and a user. By pre-defining the data structure in a document external to the API, the API can be structured in a generic manner without requiring emulation specific provisions. Other benefits such as the enabling of a generic user interface and reduced messaging bandwidth are discussed hereinafter.","The messages that the API  forms and transmit perform a variety of functions. One such function is the creation, configuration and removal of sessions. As noted above, as used herein the term session generally refers to an instance of a protocol emulation. Table 1 is a portion of self-documenting Ccode describing a management interface to an emulation control forming part of an API suitable for use with the APIs  and  along with the proxy controls .",{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"308pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#ifndef APF_EMULATION_CONTROL_H"},{"entry":"#define APF_EMULATION_CONTROL_H"},{"entry":"\/\/ =========================================================================="},{"entry":"\/\/"},{"entry":"\/\/ = LIBRARY"},{"entry":"\/\/ \u2003\u2003APF Agilent Protocol Framework"},{"entry":"\/\/"},{"entry":"\/\/ = FILENAME"},{"entry":"\/\/ \u2003\u2003apfEmulationControl.h"},{"entry":"\/\/"},{"entry":"\/\/ = DESCRIPTION"},{"entry":"\/\/"},{"entry":"\/\/ The Emulation Control interface"},{"entry":"\/\/"},{"entry":"\/\/ = AUTHORS"},{"entry":"\/\/ \u2003\u2003Geoff Smith"},{"entry":"\/\/"},{"entry":"\/\/ = COPYRIGHT"},{"entry":"\/\/ \u2003\u2003(C) Copyright 2004 Agilent Technologies"},{"entry":"\/\/"},{"entry":"\/\/ =========================================================================="},{"entry":"#include \u201capfParcelStore.h\u201d"},{"entry":"#include \u201capfParcelLink.h\u201d"},{"entry":"\/\/---------------------------------------------------------------------"},{"entry":"\/\/ = TITLE"},{"entry":"\/\/ \u2003\u2003Emulation Control Interface"},{"entry":"\/\/"},{"entry":"\/\/ = CLASS TYPE"},{"entry":"\/\/ \u2003\u2003Interface"},{"entry":"\/\/"},{"entry":"\/\/ = DESCRIPTION"},{"entry":"\/\/ \u2003\u2003Management interface to the emulation framework"},{"entry":"class APB_EXPORT_CLASS IApfEmulationControl"},{"entry":"{"},{"entry":"public:"},{"entry":"\u2003virtual ~IApfEmulationControl( ) { }"},{"entry":"\u2003\/\/ = EMULATION INFORMATION"},{"entry":"\u2003\/\/ Each protocol emulation definition is identified by a unique emulation name"},{"entry":"\u2003virtual void"},{"entry":"\u2003listEmulations(AtoList<AtoString>& emulationList) const = 0;"},{"entry":"\u2003\/\/ List the emulation names defined in XML"},{"entry":"\u2003virtual IApfRefEmulation*"},{"entry":"\u2003getRefEmulation(const AtoString& aEmulation) = 0;"},{"entry":"\u2003\/\/ Access the reference database for an emulation"},{"entry":"\u2003virtual IApfRefEmulation*"},{"entry":"\u2003getRefEmulation(uint32_t aSession) const = 0;"},{"entry":"\u2003\/\/ Access the reference database for an emulation, identified by session handle"},{"entry":"\u2003\/\/ = SESSION MANAGEMENT"},{"entry":"\u2003\/\/ One or more emulation sessions may be created from a specified emulation"},{"entry":"\u2003virtual uint32_t"},{"entry":"\u2003createSession(uint32_t aPort, const AtoString& aEmulation, uint32_t alterationCount = 1) = 0;"},{"entry":"\u2003\/\/ Add a new emulation session. Returns a unique session handle"},{"entry":"\u2003virtual void"},{"entry":"\u2003removeSession(uint32_t aSession) = 0;"},{"entry":"\u2003\/\/ Remove an existing emulation session"},{"entry":"\u2003virtual void"},{"entry":"\u2003removeSessionsOnPort(uint32_t aPort) = 0;"},{"entry":"\u2003\/\/ Remove all emulations sessions running on the specified port"},{"entry":"\u2003virtual void"},{"entry":"\u2003listAllSessions(AtoVector<uint32_t>& sessionList) const = 0;"},{"entry":"\u2003\/\/ List all emulation sessions on all ports"},{"entry":"\u2003virtual void"},{"entry":"\u2003listPorts(AtoVector<uint32_t>& portList) const = 0;"},{"entry":"\u2003\/\/ Ports are managed by the application, so this method is not strictly necessary,"},{"entry":"\u2003\/\/ but it is provided for convenience, and for testing."},{"entry":"\u2003virtual void"},{"entry":"\u2003listSessionsOnPort(uint32_t aPort, AtoVector<uint32_t>& sessionList) = 0;"},{"entry":"\u2003\/\/ List emulation sessions on the specified port"},{"entry":"\u2003virtual bool"},{"entry":"\u2003isValidSession(uint32_t aSession) const = 0;"},{"entry":"\u2003virtual bool"},{"entry":"\u2003isValidPort(uint32_t aPort) const = 0;"},{"entry":"\u2003\/\/ = PARCEL STORE"},{"entry":"\u2003virtual IApfParcelStore&"},{"entry":"\u2003sessionStore(uint32_t aSession) = 0;"},{"entry":"\u2003virtual IApfParcelStore&"},{"entry":"\u2003globalStore( ) = 0;"},{"entry":"\u2003\/\/ = SESSION COMMANDS"},{"entry":"\u2003virtual const AtoString&"},{"entry":"\u2003sessionName(uint32_t aSession) const = 0; \/\/ returns \u201cunknown\u201d if aSession not known"},{"entry":"\u2003virtual EApbResult"},{"entry":"\u2003setSessionName(uint32_t aSession, const AtoString& aName) = 0;"},{"entry":"\u2003\/\/ Session status is available from the \u201csessionStatus\u201d parcel defined in AgtEmu_GlobalSession.xml"},{"entry":"\u2003virtual EApbResult"},{"entry":"\u2003setSessionIterationCount(uint32_t aSession, uint32_t alterationCount) = 0;"},{"entry":"\u2003\/\/ Set the session iteration count. Minimum valid iteration count is 1"},{"entry":"\u2003virtual EApbResult"},{"entry":"\u2003enableSession(uint32_t aSession) = 0;"},{"entry":"\u2003\/\/ Enable the specified sessions. Enabled sessions may process and transmit packets."},{"entry":"\u2003virtual EApbResult"},{"entry":"\u2003disableSession(uint32_t aSession) = 0;"},{"entry":"\u2003\/\/ Disable the specified sessions. Disabled sessions will not receive or transmit packets."},{"entry":"\u2003virtual EApfSessionState"},{"entry":"\u2003sessionState(uint32_t aSession) = 0;"},{"entry":"\u2003\/\/ Retrieve the current session state. Also available from the sessionStatus parcel"},{"entry":"\u2003virtual EApbResult"},{"entry":"\u2003tcpOpen(uint32_t aSession, const AtoString& aSocket) = 0;"},{"entry":"\u2003\/\/ Request a connection over the specified TCP socket. As this call is not blocking,"},{"entry":"\u2003\/\/ the socket may not be open immediately on return."},{"entry":"\u2003virtual EApbResult"},{"entry":"\u2003tcpClose(uint32_t aSession, const AtoString& aSocket) = 0;"},{"entry":"\u2003\/\/ Close a connection over the specified TCP socket"},{"entry":"\u2003\/\/ Packet Transmit"},{"entry":"\u2003virtual EApbResult"},{"entry":"\u2003setTransmitCaptureMode(uint32_t aSession, EApfTransmitCaptureMode aMode) = 0;"},{"entry":"\u2003virtual EApbResult"},{"entry":"\u2003transmitPacket(uint32_t aSession, const AtoString& aSocket, const AtoByteString& aPacketData) = 0;"},{"entry":"\u2003\/\/ Transmit the specified packet data over the specified socket"},{"entry":"\u2003\/\/ = PORT COMMANDS"},{"entry":"\u2003\/\/ Port status is available from the \u201cportStatus\u201d parcel defined in AgtEmu_GlobalPort.xml"},{"entry":"\u2003\/\/ Message log"},{"entry":"\u2003virtual void"},{"entry":"\u2003getMessageLog(uint32_t aPort) = 0;"},{"entry":"\u2003virtual void"},{"entry":"\u2003setMessageTraceLevel(uint32_t aPort, EApbMsgTraceLevel aTraceLevel) = 0;"},{"entry":"\u2003virtual void"},{"entry":"\u2003setMessageLogMaxLines(uint32_t aPort, uint32_t aMaxLines) = 0;"},{"entry":"\u2003\/\/ = UTILITY"},{"entry":"\u2003virtual IApfParcelLink*"},{"entry":"\u2003parcelLink( ) = 0;"},{"entry":"\u2003\/\/ Access the inbound parcelLink interface for this emulation control"},{"entry":"\u2003virtual const AtoString&"},{"entry":"\u2003versionString( ) const = 0;"},{"entry":"};"},{"entry":"#endif \/\/ APF_EMULATION_CONTROL_H"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"To facilitate communication, such as between the emulation control  and the emulation housing , a series of buffers (in this example buffers through ) may be created in the emulation control . In turn, the emulation housing , under the guidance of an API , creates a series of buffers (in this example buffers through ) corresponding to the buffers in the emulation control . A similar series of buffers is created for each protocol sate machine hosted by a port. The type of buffer used may be specified in the reference model  by parcel type. For example, the buffer type can appear as an attribute in the XML parcel definition. Alternatively, this could be made configurable by a client application, such as a proxy control . The buffers are connected by a parcel link  that generally comprises a serial communication path.  illustrates the providing of matching buffers for each of the illustrated parcel types, however, it may also prove preferable to provide only the receiving buffer where the flow of data is unidirectional.","While the exact nature of the buffers  will vary for any given implementation of the present invention, it may prove preferable to create a separate buffer for each type of parcel to be passed between the emulation control  and the emulation housing . In general, the type of parcel is determined by the data encapsulated therein. There exist a variety of buffer types any of which may prove beneficial depending on how the data in the parcel is to be used. It may prove beneficial to define different buffer types for different parcel types.","In general, buffering means the temporary holding of parcels (or segments thereof) until the receiving (or transmitting) system is prepared to process the information contained in the parcel. For example, to minimize host load, a client from a buffer on the transmitting side can pull parcels. Alternatively, parcels can be pushed by the transmitting side to a variety of types of buffers on the receiving side to optimize responsiveness. A type of buffer may be specified for each parcel and\/or parcel type. Alternatively, a bank of different buffer types may be initialized and messages can be deposited in a buffer based on the type of the buffer. Some examples of suitable buffer types are disclosed in Table 2:",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Buffer",{}]},{"entry":["Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["retain","(Push) Each new parcel version received is retained in a circular"]},{"entry":[{},"buffer until deleted by the client"]},{"entry":["fifo","(Push) Parcels are placed in a FIFO buffer and deleted from the"]},{"entry":[{},"buffer when read by the client"]},{"entry":["newest","(Push) The buffered parcel is replaced by the most recent"]},{"entry":[{},"incoming version. Parcels with a root key specified may be"]},{"entry":[{},"consolidated according to the key value. This feature allows"]},{"entry":[{},"parcels from many sources to be automatically consolidated into"]},{"entry":[{},"a summary parcel at the destination."]},{"entry":["fetch","(Pull) Parcels are not sent to the destination store until requested"]},{"entry":[{},"by the destination"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0047","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},"Definition",{},{}]},{"entry":["Message Type","Context","Buffer","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Parcel Class","Global","Newest","Status information about a protocol state machine."]},{"entry":["sessionData","Per Session","Newest","Data associated with setting up the protocol state"]},{"entry":[{},{},{},"machine."]},{"entry":["TopologySummary","Per Emulation","Newest","Summary information about the topology in a"]},{"entry":[{},{},{},"protocol state machine."]},{"entry":["destinationPools","Global","Fetch","Destination address information used for traffic"]},{"entry":[{},{},{},"integration"]},{"entry":["TopologyData","Per Emulation","Fetch","Detail topology data for a protocol state machine."]},{"entry":["Globalstatistics","Global","Newest","Pre-defined statistics"]},{"entry":["Statistics","Per Emulation","Newest","Per-emulation statistics"]},{"entry":["EventLog","Global","Fetch","Event data for an emulation"]},{"entry":["messageTrace","Global","FIFO","Tx\/Rx message trace for an emulation"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"The buffers and the routines that facilitate their operation are collectively part of a set of procedures are termed herein a parcel store  and . In one embodiment, the functional component of the parcel stores  and  are created and maintained by the APIs  and  respectively. Further functions of the parcel store include the storing and maintaining of parcel reference model from which message objects can be instantiated. The parcel objects themselves are stored in and retrieved from the buffers . Table 4 is a portion of self-documenting Ccode describing the functions of a parcel store. \n\n\n\n\n\n\n\n\n\n\n\n","The parcel store can be configured to retain a copy of the most recent of each parcel sent to an emulation housing . Utilizing this configuration, a backup function can be implemented that saves the current configuration of the emulation control  by saving the parcels in the parcel store including the most recently transferred parcels. The backup is effected by serialising each active session. Each active session is serialised by serialising all the parcels in the parcel store. The configuration can then be restored by recreating each saved session and populating it with the restored parcels.","The emulation housings  generally function as an interface between the GPF  and the an embedded custom component, such as a protocol state machine . The emulation housings  receive messages in the form of serialized parcels, reconstructs the parcels, and distributes the data in the parcel to the components of the embedded custom component. In turn the emulation housings  receive data from the components of the embedded custom components, creates parcels based thereon and transmits said parcels to the emulation control . In the context of a protocol emulation system, each session is provided with an emulation housing which in turn communicate with the emulation control .",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 5","FIG. 5"],"b":["1","8","306","306","306","304","502"],"i":["x ","y","n "]},"The emulation control  provides API services and buffers for each session. As described hereinabove, the API and buffers facilitate communication between the emulation control  and the sessions Sn. Emulation housings and provide an API and buffers for each session Sn running on a port . The emulation housings are responsible for creating and deleting sessions on a specified port ","Each session Sn requires several resources to operate. These resources include: hardware pattern matches; a socket over which to operate (such as a TCP\/IP socket); and an API for communication and control.  is block diagram of a protocol infrastructure in accordance with embodiments of the present invention. In  a protocol state machine  is shown in communication with an API  (which may be an instance of the API  shown in ); sockets manager ; and matcher manager . The API , sockets manager  and matcher manager  collectively form an embodiment of the emulation housing  (see ).","On startup the API  generates reference models based on protocol emulation definition files . The protocol emulation definition files  are copies of the protocol emulation definition files  which should mean that the reference models generated under control of the API  match the reference models generated under control of the API . Thus, the API  is able to communicate with the emulation control  (see ) on the host  using instantiated instances of parcels.","The API  receives data from the emulation control  and distributes data to the other components of the emulation housing and the protocol state machine . In turn the API  receives, and forwards to the emulation control , data from the other components of the emulation housing  and the protocol state machine . Communication with the emulation control  may take place using the series of parcel stores and their attendant buffers described hereinabove.","The API  also manages configuration data to the protocol state machine , the matcher manager  and the sockets manager . In one embodiment, the reference model is configured to store static information pertaining to all sessions of a particular emulation type. The socket manager  combines static information with volatile information pertaining to the specific session by reading values transmitted from the emulation control , for example using session data parcels. The socket definition in the reference model can be configured to cross-reference values in the session data parcel.","The sockets manager  sets up and maintains a communication channel. In the example shown in , the sockets manager  maintains a TCP\/IP stack . When a protocol emulation session is enabled within the emulation housing , the reference model constructed by the API  is consulted to find the sockets configuration required for the session. For each socket, the socket manager  uses the reference model to construct the required socket. Sockets may be created individually per session, per interface, or globally for the housing. Therefore the socket manager  maintains a reference count of sockets that are shared by multiple sessions. For example, when global sockets are used, a socket is created the first time a session requests it. Subsequent sessions may be given the existing global socket\u2014a new one is not created. The global socket is destroyed only when all sessions using that socket are also disabled or destroyed.","The emulation matcher manager  manages hardware matchers, also termed \u201cfilters.\u201d Filters may be used to select messages, or portions thereof, of protocol messages received by the protocol state machine  from a router under test. The selected messages may be stored for analysis and reporting. One possible implementation of such filters is discussed in co-pending U.S. application Ser. No. 10\/861,618 filed Jun. 15, 2004 that is incorporated herein by reference. When a protocol emulation session is enabled within the emulation housing , the reference model is consulted to find the filters required for the session. For each filter, the matcher manager  (or filter manager), uses the reference model to construct the required filter. In general, filters may be completely defined by the static information in the reference model. Filters may be shared by all sessions of the same type. Therefore the matcher manager  maintains a reference count to ensure that hardware resources are not unnecessarily consumed by creating duplicate filters of a particular type. When a session is disabled, the corresponding filters are removed only when all sessions using that filter are disabled.","Referring to , the proxy controllers generally comprise an API similar to those discussed hereinabove and associated protocol emulation definition files. Such an API provides a convenient encapsulated solution for communication with the emulation control  on the host . As messaging is accomplished using parcel objects control over the emulation can reside in any device with the ability to create the parcel objects, e.g. any device with the appropriate API. In the example shown in , proxy controllers and are provided to GUI  and a Tcl API . Such embedding permits the control of sessions, including the creation, configuring, control and deletion thereof, using Tcl scripts.","The proxy controllers  may be formed by implementing the lapfEmulationControl set forth in Table 1. Each proxy control maintains a reference model identical to that in the emulation control . Each proxy controller registers with an associated emulation control . When a parcel is received by the emulation control  from a housing , the parcel is forwarded as is to each registered proxy control . Similarly, when a proxy control sends a parcel to a housing , it is sent via the emulation control . The emulation control  retains a copy of the parcel and replicates it to any other proxy controls . In this way, the emulation control  and all proxy controls maintain a mirrored set of parcel buffers (see ). It is the set of parcel buffers that drive the client interface.","Table 5 is a screen shot showing an example of the use of an interface created in Tcl for controlling sessions on a port via an emulation control.",{"@attributes":{"id":"p-0062","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"C:\\Program Files\\Agilent\\N2X\\RouterTester900\\6.4.0.0\\bin> tclsh83"},{"entry":"% load emuframework.dll"},{"entry":"Generic Protocol Framework"},{"entry":"Type \u201cgpfServerHostname <host>\u201d to use a remote server"},{"entry":"\u2003\u2003\u201cgpfConnect <session>\u201d to connect to a test session"},{"entry":"\u2003\u2003\u201cgpfDisconnect\u201d to disconnect from the session"},{"entry":"% gpfConnect"},{"entry":"1"},{"entry":"Generic Protocol Framework ( ). Copyright (C) 2004 Agilent Technologies"},{"entry":"Type \u201cgpfHelp\u201d for list of commands"},{"entry":"Global %"},{"entry":"Global % gpfCreateSession 2 bgp4 1"},{"entry":"bgp4-2 % gpfListBuffers"},{"entry":"bgpSessionData packetCapture test_parcel2"},{"entry":"bgp4-2 % gpfCreateParcel bgpSessionData"},{"entry":"0"},{"entry":"bgp4-1 bgpSessionData % gpfHelpParcel"},{"entry":"Parameters for bgpSessionData:"},{"entry":"\u2003local_port = integer \u2003(default=179)"},{"entry":"\u2003remote_port = integer \u2003(default=179)"},{"entry":"\u2003subinterface = integer \u2003(default=0)"},{"entry":"\u2003prefix_length = integer \u2003(default=24)"},{"entry":"\u2003local_ip = ipv4_address \u2003(default=0.0.0.0)"},{"entry":"\u2003remote_ip = ipv4_address \u2003(default=0.0.0.0)"},{"entry":"\u2003server_port = integer \u2003(default=0)"},{"entry":"\u2003server_ip = ipv4_address \u2003(default=0.0.0.0)"},{"entry":"bgp4-1 bgpSessionData % gpfSetValues local_ip=192.1.1.2,"},{"entry":"remote_ip=192.1.1.1, subinterface=100"},{"entry":"0"},{"entry":"bgp4-1 bgpSessionData % gpfPrintParcel"},{"entry":"bgp4 Parcel, class=sessionData, 9 nodes - showing current rows only"},{"entry":"Current node: 3 subinterface"},{"entry":"\u20030 Set \u201cbgpSessionData\u201d 8 members: local_port (1), remote_port (2),"},{"entry":"subinterface (3), prefix_length (4), local_ip (5), remote_ip (6),"},{"entry":"server_port (7), server_ip (8)"},{"entry":"\u20031 \u2003Value \u201clocal_port\u201d = 179"},{"entry":"\u20032 \u2003Value \u201cremote_port\u201d = 179"},{"entry":"* 3 \u2003Value \u201csubinterface\u201d = 100"},{"entry":"\u20034 \u2003Value \u201cprefix_length\u201d = 24"},{"entry":"\u20035 \u2003Value \u201clocal_ip\u201d = 192.1.1.2"},{"entry":"\u20036 \u2003Value \u201cremote_ip\u201d = 192.1.1.1"},{"entry":"\u20037 \u2003Value \u201cserver_port\u201d = 0"},{"entry":"\u20038 \u2003Value \u201cserver_ip\u201d = 0.0.0.0"},{"entry":"bgp4-1 bgpSessionData %"},{"entry":"bgp4-1 bgpSessionData % gpfSendParcel"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Using a scripting language such as Tcl, it is possible to replicate functions performed by the protocol state machine . In essence, the various protocol states would be defined using XML tags, and a set of Tcl procedures would be embedded in the definition to process state changes. A decode services library can be provided to the Tcl interpreter for decoding an incoming PDU stream, along with an encode services library for encoding a PDU stream for transmit. Table 6 is an XML file that in conjunction with the appropriate Tcl functions, described in the remarks, may be used to mimic certain functions of a protocol state machine within the GPF .",{"@attributes":{"id":"p-0064","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<?xml version=\u201c1.0\u201d standalone=\u201cyes\u201d?>"},{"entry":"<EmulationSet xmlns=\u201cx-schema:AgtEmulSchema.xml\u201d version=\u201c1\u201d"},{"entry":"providedBy=\u201cAgilent Technologies\u201d>"},{"entry":"<!-- -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~- -->"},{"entry":"<!-- \u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009\u2009Agilent Protocol Framework -->"},{"entry":"<!-- -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~- -->"},{"entry":"<!-- \u2009\u2009File type: protocol emulation -->"},{"entry":"<!-- \u2009\u2009Content : MLD version 1 -->"},{"entry":"<!-- -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~- -->"},{"entry":"<!-- \u2009\u2009Copyright 2004 Agilent Technologies -->"},{"entry":"<!-- -~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~- -->"},{"entry":"<filter name=\u201cICMPv6_routerAlert\u201d>"},{"entry":"\u2003<!-- Hardware pattern matchers -->"},{"entry":"\u2003<!-- hop by hop option (for Router Alert) -->"},{"entry":"\u2003<hwMatch type=\u201cipv6_emulation\u201d offset=\u201c48\u201d length=\u201c8\u201d value=\u201c0\u201d\/>"},{"entry":"\u2003<!-- ICMPv6 -->"},{"entry":"\u2003<hwMatch type=\u201cipv6_emulation\u201d offset=\u201c320\u201d length=\u201c8\u201d value=\u201c58\u201d\/>"},{"entry":"<\/filter>"},{"entry":"<!-- EMULATION -->"},{"entry":"<emulation name=\u201cMLDv1\u201d"},{"entry":"\u2003standard=\u201cRFC 2710\u201d"},{"entry":"\u2003protocols=\u201cIPv6 ICMP_v6\u201d"},{"entry":"\u2003filter=\u201cICMPv6_routerAlert\u201d>"},{"entry":"\u2003<!-- SESSION SUMMARY -->"},{"entry":"\u2003<parcel name=\u201cmldSessionSummary\u201d type=\u201cdata\u201d class=\u201csessionSummary\u201d>"},{"entry":"\u2003\u2003<value name=\u201cnum_address_pools\u201d"},{"entry":"\u2003\u2003\u2003fullName=\u201cNumber of address pools\u201d"},{"entry":"\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003format=\u201cinteger\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201cnum_addresses\u201d"},{"entry":"\u2003\u2003\u2003fullName=\u201cNumber of addresses\u201d"},{"entry":"\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003format=\u201cinteger\u201d\/>"},{"entry":"\u2003<\/parcel>"},{"entry":"\u2003<!-- SESSION DATA -->"},{"entry":"\u2003<!-- Define the variables used by each emulation session -->"},{"entry":"\u2003<parcel name=\u201cmldSessionData\u201d type=\u201cdata\u201d class=\u201csessionData\u201d>"},{"entry":"\u2003\u2003<value name=\u201ctester_11_address\u201d"},{"entry":"\u2003\u2003\u2003fullName=\u201cTester IPv6 link-local address\u201d"},{"entry":"\u2003\u2003\u2003length=\u201c128\u201d"},{"entry":"\u2003\u2003\u2003defaultBinding=\u201ctester_native_ipv6_11_address\u201d"},{"entry":"\u2003\u2003\u2003format=\u201cipv6_address\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201csub_interface\u201d"},{"entry":"\u2003\u2003\u2003fullName=\u201cSub-interface identifier\u201d"},{"entry":"\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003defaultValue=\u201c0\u201d"},{"entry":"\u2003\u2003\u2003format=\u201cinteger\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201crobustness\u201d"},{"entry":"\u2003\u2003\u2003fullName=\u201cRobustness variable\u201d"},{"entry":"\u2003\u2003\u2003length=\u201c16\u201d"},{"entry":"\u2003\u2003\u2003format=\u201cinteger\u201d"},{"entry":"\u2003\u2003\u2003defaultValue=\u201c2\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201cqueryResponseInterval\u201d"},{"entry":"\u2003\u2003\u2003fullName=\u201cQuery response interval (mSec)\u201d"},{"entry":"\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003format=\u201cinteger\u201d"},{"entry":"\u2003\u2003\u2003defaultValue=\u201c10000\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201cunsolicitedReportInterval\u201d"},{"entry":"\u2003\u2003\u2003fullName=\u201cQuery response interval (mSec)\u201d"},{"entry":"\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003format=\u201cinteger\u201d"},{"entry":"\u2003\u2003\u2003defaultValue=\u201c10000\u201d\/>"},{"entry":"\u2003<\/parcel>"},{"entry":"\u2003<!-- TOPOLOGY SUMMARY -->"},{"entry":"\u2003<parcel name=\u201cmldTopologySummary\u201d"},{"entry":"\u2003\u2003fullName=\u201cMLD Topology summary\u201d"},{"entry":"\u2003\u2003class=\u201ctopologySummary\u201d>"},{"entry":"\u2003\u2003<use ref=\u201cmldSessionData:tester_11_address\u201d\/>"},{"entry":"\u2003\u2003<use ref=\u201cmldSessionData:sub_interface\u201d\/>"},{"entry":"\u2003<\/parcel>"},{"entry":"\u2003<!-- TOPOLOGY DATA -->"},{"entry":"\u2003<parcel name=\u201cpoolList\u201d"},{"entry":"\u2003\u2003fullName=\u201cMulticast address pools\u201d"},{"entry":"\u2003\u2003class=\u201ctopologyData\u201d>"},{"entry":"\u2003\u2003<parcel ref=\u201c:destinationPools\u201d\/>"},{"entry":"\u2003<\/parcel>"},{"entry":"\u2003<!-- STATISTICS -->"},{"entry":"\u2003<!-- Any statistics defined here are additional to the pre-defined"},{"entry":"statistics -->"},{"entry":"\u2003<parcel name=\u201cmldStats\u201d class=\u201cstatistics\u201d"},{"entry":"\u2003\u2003fullName=\u201cMLD Version 1 Statistics\u201d>"},{"entry":"\u2003\u2003<value name=\u201cReportMessagesSent\u201d"},{"entry":"\u2003\u2003\u2003fullName=\u201cOutgoing MLD Report messages count\u201d"},{"entry":"\u2003\u2003\u2003type=\u201ccount\u201d"},{"entry":"\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003format=\u201cinteger\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201cDoneMessagesSent\u201d"},{"entry":"\u2003\u2003\u2003fullName=\u201cOutgoing MLD Done messages count\u201d"},{"entry":"\u2003\u2003\u2003type=\u201ccount\u201d"},{"entry":"\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003format=\u201cinteger\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201cQueryMessagesReceived\u201d"},{"entry":"\u2003\u2003\u2003fullName=\u201cIncoming MLD Query messages count\u201d"},{"entry":"\u2003\u2003\u2003type=\u201ccount\u201d"},{"entry":"\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003format=\u201cinteger\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201cReportMessagesReceived\u201d"},{"entry":"\u2003\u2003\u2003fullName=\u201cIncoming MLD Report messages count\u201d"},{"entry":"\u2003\u2003\u2003type=\u201ccount\u201d"},{"entry":"\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003format=\u201cinteger\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201cMulticastAddressCount\u201d"},{"entry":"\u2003\u2003\u2003fullName=\u201cNumber of active multicast addresses\u201d"},{"entry":"\u2003\u2003\u2003type=\u201ccount\u201d"},{"entry":"\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003format=\u201cinteger\u201d\/>"},{"entry":"\u2003<\/parcel>"},{"entry":"\u2003<!-- BINDINGS -->"},{"entry":"\u2003<bind name=\u201cmldSocket\u201d"},{"entry":"\u2003\u2003socket Type=\u201csubinterface\u201d"},{"entry":"\u2003\u2003subInterface=\u201c$sub_interface\u201d"},{"entry":"\u2003\u2003filter=\u201cICMPv6_routerAlert\u201d>"},{"entry":"\u2003\u2003<importPdu protocol=\u201cIPv6\u201d packetType=\u201c\u201d>"},{"entry":"\u2003\u2003\u2003<decodeMatch pdu=\u201cmldQuery\u201d"},{"entry":"\u2003\u2003\u2003\u2003protocol=\u201cICMPv6\u201d"},{"entry":"\u2003\u2003\u2003\u2003protocolInstance=\u201c1\u201d"},{"entry":"\u2003\u2003\u2003\u2003field=\u201cmld_query_v1\u201d"},{"entry":"\u2003\u2003\u2003\u2003statistic=\u201cQueryMessagesReceived\u201d"},{"entry":"\u2003\u2003\u2003\u2003proc=\u201conMldQuery\u201d\/>"},{"entry":"\u2003\u2003\u2003<decodeMatch pdu=\u201cmldReport\u201d"},{"entry":"\u2003\u2003\u2003\u2003protocol=\u201cICMPv6\u201d"},{"entry":"\u2003\u2003\u2003\u2003protocolInstance=\u201c1\u201d"},{"entry":"\u2003\u2003\u2003\u2003field=\u201cmld_report_v1\u201d"},{"entry":"\u2003\u2003\u2003\u2003statistic=\u201cReportMessagesReceived\u201d"},{"entry":"\u2003\u2003\u2003\u2003proc=\u201conMldReport\u201d\/>"},{"entry":"\u2003\u2003<\/importPdu>"},{"entry":"\u2003<\/bind>"},{"entry":"\u2003<tclProc name=\u201conMldQuery\u201d>"},{"entry":"\u2003\u2003set multicastAddress [value [findElement ICMPv6 multicast_address 1]]"},{"entry":"\u2003\u2003aebLog info \u201cMLD Query message received for address: [formatValue"},{"entry":"$multicastAddress ipv6_address]\u201d"},{"entry":"\u2003\u2003# notify the state machine of the incoming packet. Notification will"},{"entry":"be dropped"},{"entry":"\u2003\u2003# if no instance is present for $multicastAddress"},{"entry":"\u2003\u2003aebNotify mld_listener $multicastAddress query_received"},{"entry":"\u2003<\/tclProc>"},{"entry":"\u2003<tclproc name=\u201conMldReport\u201d>"},{"entry":"\u2003\u2003set multicastAddress [value [findElement ICMPv6 multicast_address 1]]"},{"entry":"\u2003\u2003aebLog info \u201cMLD Report message received for address: [formatValue"},{"entry":"$multicastAddress ipv6_address]\u201d"},{"entry":"\u2003\u2003# notify the state machine of the incoming packet. Notification will"},{"entry":"be dropped if no"},{"entry":"\u2003\u2003# instance is present for $multicastAddress"},{"entry":"\u2003\u2003aebNotify mld_listener $multicastAddress report_received"},{"entry":"\u2003<\/tclProc>"},{"entry":"\u2003<!-- COMMANDS -->"},{"entry":"\u2003<command name=\u201cjoin\u201d"},{"entry":"\u2003\u2003fullName=\u201cJoin a set of multicast addresses\u201d"},{"entry":"\u2003\u2003proc=\u201cjoin\u201d>"},{"entry":"\u2003\u2003<parcel ref=\u201cpoolList\u201d\/>"},{"entry":"\u2003<\/command>"},{"entry":"\u2003<command name=\u201cleave\u201d>"},{"entry":"\u2003\u2003fullName=\u201cLeave a set of multicast addresses\u201d"},{"entry":"\u2003\u2003proc=\u201cleave\u201d\/>"},{"entry":"\u2003\u2003<parcel ref=\u201cpoolList\u201d\/>"},{"entry":"\u2003<\/command>"},{"entry":"\u2003<command name=\u201cleaveAll\u201d"},{"entry":"\u2003\u2003fullName=\u201cLeave all multicast addresses\u201d"},{"entry":"\u2003\u2003proc=\u201cleaveAll\u201d\/>"},{"entry":"\u2003<\/command>"},{"entry":"\u2003<command name=\u201clistPools\u201d"},{"entry":"\u2003\u2003fullName=\u201cList all multicast pools\u201d"},{"entry":"\u2003\u2003proc=\u201clistPools\u201d"},{"entry":"\u2003\u2003event=\u201cpoolList\u201d\/>"},{"entry":"\u2003<!-- SESSION PRIVATE DATA -->"},{"entry":"\u2003<value name=\u201callRoutersMcastAddress\u201d"},{"entry":"\u2003\u2003\u2003fullName=\u201cAll routers multicast address\u201d"},{"entry":"\u2003\u2003\u2003length=\u201c128\u201d"},{"entry":"\u2003\u2003\u2003format=\u201cipv6_address\u201d"},{"entry":"\u2003\u2003\u2003value=\u201c0xff02 0000 0000 0000 0000 0000 0000 0001\u201d\/>"},{"entry":"\u2003<!-- PDU TEMPLATES -->"},{"entry":"\u2003<pduTemplate name=\u201creportPdu\u201d protocol=\u201c\u201d packetType=\u201cMLD\u201d"},{"entry":"proc=\u201ccreateReportPdu\u201d\/>"},{"entry":"\u2003<pduTemplate name=\u201cdonePdu\u201d protocol=\u201c\u201d packetType=\u201cMLD\u201d"},{"entry":"proc=\u201ccreateDonePdu\u201d\/>"},{"entry":"\u2003<tclProc name=\u201ccreateReportPdu\u201d>"},{"entry":"\u2003\u2003set eIcmp [findProtocol \u201cICMP_v6\u201d 1]"},{"entry":"\u2003\u2003setContainedElements $eIcmp mld_report_v1"},{"entry":"\u2003\u2003set eSrcAddr [findElement \u201cIPv6 source_address 1\u201d]"},{"entry":"\u2003\u2003setValue $eSrcAddr $tester_11_address"},{"entry":"\u2003<\/tclProc>"},{"entry":"\u2003<tclProc name=\u201ccreateDonePdu\u201d>"},{"entry":"\u2003\u2003set eIcmp [findProtocol \u201cICMP_v6\u201d 1]"},{"entry":"\u2003\u2003setContainedElements $eIcmp mld_done"},{"entry":"\u2003\u2003set eSrcAddr [findElement \u201cIPv6 source_address 1\u201d]"},{"entry":"\u2003\u2003set eDstAddr [expr $eSrcAddr + 1]"},{"entry":"\u2003\u2003setValue $eSrcAddr $tester_11_address"},{"entry":"\u2003\u2003setValue $eDstAddr $allRoutersMcastAddress"},{"entry":"\u2003<\/tclProc>"},{"entry":"\u2003<!-- COMMAND IMPLEMENTATIONS -->"},{"entry":"\u2003<tclProc name=\u201cjoin\u201d packet=\u201cpoolList\u201d>"},{"entry":"\u2003\u2003# Check whether this is a new pool or a changed pool"},{"entry":"\u2003\u2003if {[packetChanged \u201cpoolList\u201d]} {"},{"entry":"\u2003\u2003\u2003# Existing pool - delete the old one first"},{"entry":"\u2003\u2003\u2003leave"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003# Create the new pool"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003set poolFirstAddr($handle)","$firstAddr"]},{"entry":["\u2003\u2003set poolModifier($handle)","$modifier"]},{"entry":["\u2003\u2003set poolCount($handle)","$count"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003for {set i 0} {$i < $count} {incr i} {"},{"entry":"\u2003\u2003\u2003set addr [aebCalculateIpv6Address $firstAddr $modifier $i]"},{"entry":"\u2003\u2003\u2003if {[info exists stateMachineRefCount($addr)]} {"},{"entry":"\u2003\u2003\u2003\u2003incr stateMachineRefCount($addr)"},{"entry":"\u2003\u2003\u2003} else {"},{"entry":"\u2003\u2003\u2003\u2003set stateMachineRefCount($addr) 1"},{"entry":"\u2003\u2003\u2003\u2003aebCreate mld_listener $addr"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003<\/tclProc>"},{"entry":"\u2003<tclProc name=\u201cleave\u201d parameters=\u201chandle\u201d>"},{"entry":"\u2003\u2003if {[info exists $poolFirstAddr($handle) == 0} {"},{"entry":"\u2003\u2003\u2003\u2003aebLog error \u201cLeave command for unknown handle $handle\u201d"},{"entry":"\u2003\u2003} else {"},{"entry":"\u2003\u2003\u2003aebLog info \u201cLeaving pool $handle\u201d"},{"entry":"\u2003\u2003\u2003for {set i 0} {$i < $poolCount($handle)} {incr i} {"},{"entry":"\u2003\u2003\u2003\u2003set addr [aebCalculateIpv6Address $poolFirstAddr($handle)"},{"entry":"$poolModifier($handle) $i]"},{"entry":"\u2003\u2003\u2003\u2003if {[info exists stateMachineRefCount($addr)} {"},{"entry":"\u2003\u2003\u2003\u2003\u2003incr stateMachineRefCount($addr) \u22121"},{"entry":"\u2003\u2003\u2003\u2003\u2003if {stateMachineRefCount($addr) == 0} {"},{"entry":"\u2003\u2003\u2003\u2003\u2003aebNotify mld_listener $addr stop_listening"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003unset stateMachineRefCount($addr)"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003<\/tclProc name=\u201cleaveAll\u201d>"},{"entry":"\u2003\u2003foreach handle [array names $poolFirstAddr] {"},{"entry":"\u2003\u2003\u2003leave $handle"},{"entry":"\u2003\u2003}"},{"entry":"\u2003<\/tclProc>"},{"entry":"\u2003<tclProc name=\u201clistAddresses\u201d>"},{"entry":"\u2003\u2003aebCreatePacket poolList"},{"entry":"\u2003\u2003foreach handle [array names $poolFirstAddr] {"},{"entry":"\u2003\u2003\u2003aebAppendList pool_list {$handle $poolFirstAddr($handle)"},{"entry":"$poolModifier($handle) $poolCount($handle)}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003aebSendEvent poolList"},{"entry":"\u2003<\/tclProc>"},{"entry":"\u2003<!-- STATE MACHINE -->"},{"entry":"\u2003<stateMachine name=\u201cmld_listener\u201d>"},{"entry":"\u2003\u2003createProc=\u201clistenToAddress\u201d"},{"entry":"\u2003\u2003createParameter=\u201cmulticast_address\u201d"},{"entry":"\u2003\u2003firstState=\u201cdelaying_listener\u201c>"},{"entry":"\u2003\u2003<!-- State machine variables (maintained by framework for each state"},{"entry":"machine instance) -->"},{"entry":"\u2003\u2003<value name=\u201csmMulticastAddress\u201d fullName=\u201cMulticast Address\u201d"},{"entry":"format=\u201cipv6_address\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201csmActiveFlag\u201d defaultValue=\u201c1\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201csmDelayTimeout\u201d"},{"entry":"defaultValue=\u201c$unsolicitedReportInterval\u201d\/>"},{"entry":"\u2003\u2003<!-- State definitions -->"},{"entry":"\u2003\u2003<state name=\u201cdelaying_listener\u201d>"},{"entry":"\u2003\u2003\u2003<onEntry>"},{"entry":"\u2003\u2003\u2003\u2003<startTimer name=\u201cdelay_timer\u201d minTimeout=\u201c0\u201d"},{"entry":"maxTimeout=\u201c$smDelayTimeout\u201d expireAction=\u201ctimer_expire\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<tclEval \u201cset smDelayTimeout $queryResponseInterval\u201d>"},{"entry":"\u2003\u2003\u2003<\/onEntry>"},{"entry":"\u2003\u2003\u2003<action name=\u201cstop_listening\u201d"},{"entry":"\u2003\u2003\u2003\u2003fullName=\u201cStop listening to a multicast address\u201d"},{"entry":"\u2003\u2003\u2003\u2003proc=\u201csendDoneIfActive\u201d"},{"entry":"\u2003\u2003\u2003\u2003newState=\u201caebDestroyInstance\u201d\/>"},{"entry":"\u2003\u2003\u2003<action name=\u201creport_received\u201d"},{"entry":"\u2003\u2003\u2003\u2003fullName=\u201cReport for this address received from another node\u201d"},{"entry":"\u2003\u2003\u2003\u2003newState=\u201cidle_listener\u201d"},{"entry":"\u2003\u2003\u2003\u2003pdu=\u201cmldReport\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<tclEval \u201cset smActiveFlag 0\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<stopTimer name=\u201cdelay_timer\u201d\/>"},{"entry":"\u2003\u2003\u2003<\/action>"},{"entry":"\u2003\u2003\u2003<action name=\u201ctimer_expire\u201d"},{"entry":"\u2003\u2003\u2003\u2003fullName=\u201cDelay timer expired\u201d"},{"entry":"\u2003\u2003\u2003\u2003proc=\u201csendReport\u201d"},{"entry":"\u2003\u2003\u2003\u2003newState=\u201cidle_listener\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<tclEval \u201cset smActiveFlag 1\u201d\/>"},{"entry":"\u2003\u2003\u2003<\/action>"},{"entry":"\u2003\u2003\u2003<action name=\u201cquery_received\u201d"},{"entry":"\u2003\u2003\u2003\u2003fullName=\u201cQuery received from router\u201d"},{"entry":"\u2003\u2003\u2003\u2003proc=\u201cconditionalResetTimer\u201d>"},{"entry":"\u2003\u2003\u2003<\/action>"},{"entry":"\u2003\u2003<\/state>"},{"entry":"\u2003\u2003<state name=\u201cidle_listener\u201d"},{"entry":"\u2003\u2003\u2003<action name=\u201cquery_received\u201d"},{"entry":"\u2003\u2003\u2003\u2003fullName=\u201cQuery received from router\u201d"},{"entry":"\u2003\u2003\u2003\u2003newState=\u201cdelaying_listener\u201d>"},{"entry":"\u2003\u2003\u2003<action name=\u201cstop_listening\u201d"},{"entry":"\u2003\u2003\u2003\u2003fullName=\u201cStop listening to a multicast address\u201d"},{"entry":"\u2003\u2003\u2003\u2003proc=\u201csendDoneIfActive\u201d"},{"entry":"\u2003\u2003\u2003\u2003newState=\u201caebDestroyInstance\u201d\/>"},{"entry":"\u2003\u2003<\/state>"},{"entry":"\u2003\u2003<!-- State machine procedures -->"},{"entry":"\u2003\u2003<tclProc name=\u201clistenToAddress\u201d parameters=\u201cmulticast_address\u201d>"},{"entry":"\u2003\u2003\u2003set smMulticastAddress $multicast_address"},{"entry":"\u2003\u2003\u2003sendReport"},{"entry":"\u2003\u2003<\/tclProc>"},{"entry":"\u2003\u2003<tclProc name=\u201csendReport\u201d>"},{"entry":"\u2003\u2003\u2003copyPdu reportPdu"},{"entry":"\u2003\u2003\u2003set eDstAddr [findElement \u201cIPv6 destination_address 1\u201d]"},{"entry":"\u2003\u2003\u2003# report messages are sent to the address being reported"},{"entry":"\u2003\u2003\u2003setValue $eDstAddr $smMulticastAddress"},{"entry":"\u2003\u2003\u2003set eMrd [findElement ICMPv6 max_response_delay 1]"},{"entry":"\u2003\u2003\u2003set eAddr [expr $eMrd + 2] ;# mcastAddress is 2nd field past mrd"},{"entry":"\u2003\u2003\u2003setValue $eMrd $smDelayTimeout"},{"entry":"\u2003\u2003\u2003setValue $eAddr $smMulticastAddress"},{"entry":"\u2003\u2003\u2003aebSendPdu mldSocket"},{"entry":"\u2003\u2003\u2003aebLog info \u201cMLD report sent for [formattedvalue $addrelem]\u201d"},{"entry":"\u2003\u2003\u2003aebIncrementStatistic ReportMessagesSent"},{"entry":"\u2003\u2003<\/tclProc>"},{"entry":"\u2003\u2003<tclProc name=\u201csendDoneIfActive\u201d>"},{"entry":"\u2003\u2003\u2003if {$smActiveFlag == 0} { return }"},{"entry":"\u2003\u2003\u2003copyPdu donePdu"},{"entry":"\u2003\u2003\u2003set eMrd [findElement ICMPv6 max_response_delay 1]"},{"entry":"\u2003\u2003\u2003set eAddr [expr $eMrd + 2] ;# mcastAddress is 2nd field past mrd"},{"entry":"\u2003\u2003\u2003setValue $eMrd $smDelayTimeout"},{"entry":"\u2003\u2003\u2003setValue $eAddr $smMulticastAddress"},{"entry":"\u2003\u2003\u2003aebSendPdu mldSocket"},{"entry":"\u2003\u2003\u2003aebLog info \u201cMLD done sent for [formattedvalue $addrelem]\u201d"},{"entry":"\u2003\u2003\u2003aebIncrementStatistic DoneMessagesSent"},{"entry":"\u2003\u2003<\/tclProc>"},{"entry":"\u2003\u2003<tclProc name=\u201cconditionalResetTimer\u201d>"},{"entry":"\u2003\u2003\u2003# Current pdu is an mld query - retrieve the max response"},{"entry":"\u2003\u2003\u2003set maxResponse [value [findElement ICMPv6 max_response_delay 1]]"},{"entry":"\u2003\u2003\u2003aebLog info \u201cReceived MLD query max response = $maxResponse\u201d"},{"entry":"\u2003\u2003\u2003if {$maxResponse == 0 \u2225 [aebGetTimer delay_timer] <"},{"entry":"$maxResponse} {"},{"entry":"\u2003\u2003\u2003\u2003aebExpireTimer delay_timer ;# will trigger timer action"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003<\/tclProc>"},{"entry":"\u2003<\/stateMachine>"},{"entry":"<\/emulation>"},{"entry":"<!-- ===================================================================== --"},{"entry":">"},{"entry":"<\/EmulationSet>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Tcl scripts can be created that provide simple emulation and conformance testing. The emulation housing is configured to pass through protocol packets received by the port to the control of the Tcl API . Similarly, the emulation housing may be configured to pass through the network under test protocol packets generated by the Tcl API . The Tcl API  can be configured to interface with packet building software such as that disclosed in U.S. patent application Ser. No. 10\/266,507, Publication No.: US20040068681 A1. Alternatively, certain concepts of the present invention can be extended to the protocol state machine by making the state machine configurable based on definitions similar in format to the protocol emulation definitions .","In perhaps the preferred embodiment, the GUI  is constructed in a generic manner wherein the layout of elements on the display is responsive to the structure of the message reference models and objects. Referring to , the GUI  is driven using the protocol emulation definitions in that for each piece of data to be displayed, attributes may be created that describe how such display is to be formatted. Similarly, in instances where input is required from the user, attributes of the data element for which such input is sought may be used to format the display seeking such input. Perhaps advantageously, the GUI  will have pre-designed and built dialogs for each major functional block of data. The formatting of the display of each block will vary by implementation; however, it may prove advantageous to provide each block with its own window. The specific content of the GPF dialogs (fields, columns etc) will be populated by the data received.","One example of a suitable list of major functional blocks includes: session manager, session editor, topology editor, session statistics, session log, and message trace. The session manager block could include data for the creation, deletion, enabling and disabling of sessions, along with views of session status and summary information. The session editor block could include data for the creation, viewing, and editing of session global data, such as SUT addresses, options and timers. The topology editor block could include data for the creation of viewing of session topology, such as simulated routes or routers. The topology editor block may also include functionality for the sending of commands or the injection of PDUs into the emulation session. The session statistic block could provide a view of real-time statistics particular to each session type. The session log block could provide a view of an event message log generated by each session. Lastly, the message trace block could provide a view of a live message trace of messages sent and received by each session.","Perhaps the underlying concept of embodiments of the present invention is the use of protocol emulation definitions logically external to the GPF .  is diagram of an XML tag hierarch suitable for use in a generic protocol framework in accordance with embodiments of the present invention. In accordance with certain embodiments of the present invention, reference models are formed based upon protocol emulation definition files using the XML tag hierarch set forth in . While protocol emulation definitions are described as being formatted in XML, those of ordinary skill in the art will recognize that other formats may be used. More specifically, it is desirable to format the protocol emulation description in an easily accessible format to facilitate creation and modification thereof.","The preferred data structure of a file is hierarchical, wherein each node can contain a value, sub nodes, a function, an array of values or a table of values. The nested tag structure provided by XML facilitates the documentation of hierarchal relationships and table structures. A message definition may be as simple as a text file that provides a list of functional units and specifies the elements (referred to herein as the \u201cnodes\u201d) that comprise each functional unit, the type of each node and the interrelationship of the nodes. Each node may be annotated using descriptive attributes (examples of which are discussed herein after).","Each section of an emulation definition file may comprise a header and a set of elements. Elements generally fall into two categories, container elements that provide structure and data elements that store a value or series of values. XML tags may be used to organize the headers and elements. For example, the data and commands required for a single type of protocol emulation may be encapsulated within an <emulationset> tag. Within the <emulationset> tags, the elements may be further organized based upon their function. Looking at , one possible organization scheme is shown wherein the elements are encapsulated using the following tags: <parcel>, <command>, <filter>, <emulation>, and <enumset>.","The form and format of the <parcel> section is discussed in co-pending U.S. patent application #10\/851,303. The <command> section follows the same basic format as the <parcel> section. An example of a set of element types for a <parcel> message segment are shown in TABLE 7.",{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Element Type","Container","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["value","No","A single value. (Boolean, Numeric or string)."]},{"entry":[{},{},"A value may be any length."]},{"entry":["array","No","A set of homogeneous values (all the same"]},{"entry":[{},{},"type)"]},{"entry":["set","Yes","A parcel element containing other parcel"]},{"entry":[{},{},"elements, e.g. value, array, set, table or"]},{"entry":[{},{},"keyed table."]},{"entry":["table","Yes","A table. Each member of the table represents"]},{"entry":[{},{},"a column. Rows in the table are indexed."]},{"entry":["keyed table","Yes","A table. Each member of the table represents"]},{"entry":[{},{},"a column. One column, which must be a"]},{"entry":[{},{},"value, is specified as the key column. Each"]},{"entry":[{},{},"row in the table must have a unique value in"]},{"entry":[{},{},"the key column. Rows are accessed by key"]},{"entry":[{},{},"value."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The commands used by the API may also be defined using XML definitions. This may be achieved by adding a level of indirection, so that instead of the API having many hundreds of protocol specific commands, just a few general commands are provided by the API itself. For example, the commands described in Table 8 represent a minimalist set of commands that permit the user to identify and invoke the commands defined in a protocol definition.",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Command","Parameters","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["listCommands","Emulation","List the commands available"]},{"entry":[{},"name or blank","for the emulation, or if no"]},{"entry":[{},{},"emulation is specified, list the"]},{"entry":[{},{},"global commands"]},{"entry":["help","Command name","Display help information"]},{"entry":[{},{},"about the command"]},{"entry":["invoke","XML defined","Invoke a command"]},{"entry":[{},"command and parameters"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The commands provided for each emulation may defined in the protocol emulation definition . For example see Table 9:",{"@attributes":{"id":"p-0076","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<command name=\u201dsetKeepalive\u201d fullName=\u201dSet the value of the Keep"},{"entry":"alive timer\u201d>"},{"entry":"\u2003<value name=\u201dkeepalive\u201d fullName=\u201dKeepalive Value\u201d length=\u201d16\u201d"},{"entry":"\u2003defaultValue=\u201d100\u201d\/>"},{"entry":"<\/command>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In this simple case, the required parameters are defined as one or more values. In other situations, it is useful to define the command parameters as a table row in a parcel, e.g. see Table 10:",{"@attributes":{"id":"p-0078","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 10"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<command name=\u201dadvertise\u201d fullName=\u201dAdvertise route pool\u201d>"]},{"entry":[{},"\u2003<use rowRef=\u201droutePools\u201d\/>"]},{"entry":[{},"<\/command>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"For this example, we can assume that we have defined a parcel called \u201croutePools\u201d, which is a table for which each row represents an individual route pool. The command \u201cadvertise\u201d operates on a route pool, and we associate the two using the \u201crowRef\u201d attribute.","This style of command is very useful for the GUI, as it allows the user to select a row in the route pool tables and click \u201cadvertise\u201d. The command definition allows the appropriate command and parameters to be automatically associated.","One possible implementation for the <filter> section is discussed in co-pending U.S. application Ser. No. 10\/861,618. In one embodiment a single tag <hwMatch> is defined for the <filter>. As filters are generally formatted as predefined bit streams, the <hwMatch> contains a bitstream (either in binary or hex) corresponds directly to the implemented emulation matchers. By way of example, the <hwMatch> parameters for the AGILENT ROUTERTESTER 900 are the IP protocol id and the first 32 bits of the IP payload, along with associated masks. In summary, the payload of the <hwMatch> tag simply contains the data needed to program the hardware interface.","The emulation> section contains the <socket> and <parcel> tags pertaining to a specific protocol emulation. The <emulation> may also make reference to one or more filters defined externally to the <emulation>.","TABLE 11 contains a sample set of element types for a <socket> message segment.",{"@attributes":{"id":"p-0084","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Element Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Enumset","Table of name\/value pairs - see description below."]},{"entry":["option","Defines a socket option. All standard TCP\/IP socket options are"]},{"entry":[{},"supported"]},{"entry":["parameter","specify a parameter used to configure the socket. Example"]},{"entry":[{},"parameters include: localPort, remotePort, localAddress,"]},{"entry":[{},"remoteAddress, subInterface, prefixLength and protocol."]},{"entry":[{},"Different socket types (eg BPF, Raw or TCP client) have different"]},{"entry":[{},"requirements as to which parameters are mandatory. Parameter"]},{"entry":[{},"values may be specified statically in the XML, or may reference a"]},{"entry":[{},"value in the sessionData parcel."]},{"entry":["tcpReassembly","A TCP socket provides a streaming interface. Most applications"]},{"entry":[{},"require the TCP payload to be assembled into discrete packets,"]},{"entry":[{},"identified by a length field embedded in the data. This tag is used"]},{"entry":[{},"to program a TCP reassembly routine for performing this"]},{"entry":[{},"operation."]},{"entry":["bpfMatch","The BPF socket is a generic layer 2 socket that selects packets"]},{"entry":[{},"using the industry standard \u201cBerkeley Packet Filter\u201d software"]},{"entry":[{},"matcher. Traditionally, BPF filters are hardcoded by embedded"]},{"entry":[{},"software. In the GPF, the <bpfMatch> tags provide a simple XML"]},{"entry":[{},"interface for programming the BPF filter from the emulation definition."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Table 12 contains a segment of a protocol emulation definition that illustrates <filter> and <socket> sections.",{"@attributes":{"id":"p-0086","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<?xml version=\u201c1.0\u201d standalone=\u201cyes\u201d?>"},{"entry":"<EmulationSet version=\u201c1\u201d providedBy=\u201cAgilent Technologies\u201d>"},{"entry":"<!-- Copyright 2004 Agilent Technologies -->"},{"entry":"<!-- ===================================================================== -->"},{"entry":"<!-- Note: protocolMask defaults to 0xFF, dataMask defaults to 0xFFFFFFFF -->"},{"entry":"<filter name=\u201cbgp4_filter\u201d>"},{"entry":"\u2003<hwMatch type=\u201cipv4\u201d protocolValue=\u201c6\u201d dataValue=\u201c0xb3\u201d dataMask=\u201c0xffff\u201d\/>"},{"entry":"\u2003<hwMatch type=\u201cipv4\u201d protocolValue=\u201c6\u201d dataValue=\u201c0xb30000\u201d dataMask=\u201c0xffff0000\u201d\/>"},{"entry":"\u2003<hwMatch type=\u201cipv6\u201d protocolValue=\u201c6\u201d dataValue=\u201c0xb3\u201d dataMask=\u201c0xffff\u201d\/>"},{"entry":"\u2003<hwMatch type=\u201cipv6\u201d protocolValue=\u201c6\u201d dataValue=\u201c0xb30000\u201d dataMask=\u201c0xffff0000\u201d\/>"},{"entry":"<\/filter>"},{"entry":"<filter name=\u201cisis_filter\u201d>"},{"entry":"\u2003<hwMatch type=\u201cbpf\u201d\/>"},{"entry":"<\/filter>"},{"entry":"<emulation name=\u201cbgp4\u201d filters=\u201cbgp4_filter\u201d >"},{"entry":"\u2003<socket name=\u201cclientSkt\u201d id=\u201c1\u201d type=\u201ctcp\u201d role=\u201cclient\u201d instance=\u201csession\u201d>"},{"entry":"\u2003\u2003<tcpReassembly offset=\u201c128\u201d length=\u201c16\u201d lengthMultiplier=\u201c8\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<option name=\u201cso_linger\u201d value=\u201c0\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<option name=\u201cso_reuseaddr\u201d value=\u201c0\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<option name=\u201cip_ttl\u201d value=\u201c1\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<option name=\u201cip_tos\u201d value=\u201c64\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<parameter name=\u201clocal_ip\u201d purpose=\u201clocal_address\u201d"},{"entry":"\u2002valueRef=\u201cbgpSessionData:local_ip\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<parameter name=\u201cremote_ip\u201d purpose=\u201cremote_address\u201d"},{"entry":"\u2002valueRef=\u201cbgpSessionData:remote_ip\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<parameter name=\u201cremote_port\u201d purpose=\u201cremote_port\u201d"},{"entry":"\u2002valueRef=\u201cbgpSessionData:remote_port\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<parameter name=\u201csubinterface\u201d purpose=\u201csubinterface\u201d"},{"entry":"\u2002valueRef=\u201cbgpSessionData:subinterface\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<parameter name=\u201cprefix_length\u201d purpose=\u201cprefix_length\u201d"},{"entry":"\u2002valueRef=\u201cbgpSessionData:prefix_length\u201d\/>"},{"entry":"\u2003<\/socket>"},{"entry":"\u2003<socket name=\u201cserverSkt\u201d id=\u201c2\u201d type=\u201ctcp\u201d role=\u201cserver\u201d instance=\u201cglobal\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<option name=\u201cso_linger\u201d value=\u201c0\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<option name=\u201cso_reuseaddr\u201d value=\u201c0\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<parameter name=\u201clocal_port\u201d purpose=\u201clocal_port\u201d"},{"entry":"\u2002valueRef=\u201cbgpSessionData:local_port\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<\/socket>"},{"entry":"\u2003<packet name=\u201cbgpSessionData\u201d class=\u201csessionData\u201d>"},{"entry":"\u2003\u2003<value name=\u201clocal_port\u201d"},{"entry":"\u2003\u2003\u2003fullName=\u201cLocal port\u201d"},{"entry":"\u2003\u2003\u2003length=\u201c16\u201d"},{"entry":"\u2003\u2003\u2003format=\u201cinteger\u201d"},{"entry":"\u2003\u2003\u2003defaultValue=\u201c179\u201d"},{"entry":"\u2003\u2003\u2003writable=\u201cno\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201cremote_port\u201d"},{"entry":"\u2003\u2003\u2003fullName=\u201cRemote port\u201d"},{"entry":"\u2003\u2003\u2003length=\u201c16\u201d"},{"entry":"\u2003\u2003\u2003format=\u201cinteger\u201d"},{"entry":"\u2003\u2003\u2003defaultValue=\u201c179\u201d"},{"entry":"\u2003\u2003\u2003writable=\u201cno\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201csubinterface\u201d"},{"entry":"\u2003\u2003\u2003fullName=\u201cSub-interface identifier\u201d"},{"entry":"\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003format=\u201cinteger\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201cprefix_length\u201d"},{"entry":"\u2003\u2003\u2003fullName=\u201cAddress prefix length\u201d"},{"entry":"\u2003\u2003\u2003format=\u201cinteger\u201d"},{"entry":"\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003defaultValue=\u201c24\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201clocal_ip\u201d"},{"entry":"\u2003\u2003\u2003fullName=\u201cSource IP Address\u201d"},{"entry":"\u2003\u2003\u2003format=\u201cipv4_address\u201d"},{"entry":"\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003initialise=\u201crequired\u201d\/>"},{"entry":"\u2003\u2003<value name=\u201cremote_ip\u201d"},{"entry":"\u2003\u2003\u2003fullName=\u201cDestination IP Address\u201d"},{"entry":"\u2003\u2003\u2003format=\u201cipv4_address\u201d"},{"entry":"\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003initialise=\u201crequired\u201d\/>"},{"entry":"\u2003\u2002<\/packet>"},{"entry":"\u2003<\/emulation>"},{"entry":"\u2003<emulation name=\u201cisis\u201d filters=\u201cisis_filter\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<socket name=\u201ctx\u201d type=\u201cbpf\u201d instance=\u201csubinterface\u201d>"},{"entry":"<!-- By default bpf will drop all incoming packets -->"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<parameter name=\u201csubinterface\u201d purpose=\u201csubinterface\u201d"},{"entry":"\u2003\u2002valueRef=\u201cisisSessionData:subinterface\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<\/socket>"},{"entry":"\u2003\u2003<socket name=\u201cL1_rx_broadcast\u201d type=\u201cbpf\u201d instance=\u201csubinterface\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<bpfMatch program=\u201coffsetMatch\u201d offset=\u201c0\u201d length=\u201c48\u201d"},{"entry":"\u2003matchRef=\u201cisisSessionData:L1_mac_address\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<bpfMatch program=\u201coffsetMatch\u201d offset=\u201c112\u201d length=\u201c16\u201d match=\u201c0xFEFE\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<\/bpfMatch>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<parameter name=\u201csubinterface\u201d purpose=\u201csubinterface\u201d"},{"entry":"\u2003valueRef=\u201cisisSessionData:subinterface\u201d\/>"},{"entry":"\u2003\u2003<\/socket>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<socket name=\u201cL2_rx_broadcast\u201d type=\u201cbpf\u201d instance=\u201csubinterface\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<bpfMatch program=\u201coffsetMatch\u201d offset=\u201c0\u201d length=\u201c48\u201d"},{"entry":"\u2003matchRef=\u201cisisSessionData:L2_mac_address\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<bpfMatch program=\u201coffsetMatch\u201d offset=\u201c112\u201d length=\u201c16\u201d match=\u201c0xFEFE\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<parameter name=\u201csubinterface\u201d purpose=\u201csubinterface\u201d"},{"entry":"\u2003valueRef=\u201cisisSessionData:subinterface\u201d\/>"},{"entry":"\u2003\u2003<\/socket>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<socket name=\u201crx_ptop\u201d type=\u201cbpf\u201d instance=\u201csubinterface\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<bpfMatch program=\u201coffsetMatch\u201d offset=\u201c16\u201d length=\u201c16\u201d match=\u201c0x0023\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<bpfMatch program=\u201coffsetMatch\u201d offset=\u201c32\u201d length=\u201c8\u201d match=\u201c0x83\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<bpfMatch program=\u201coffsetMatch\u201d offset=\u201c32\u201d length=\u201c8\u201d match=\u201c0x82\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<\/bpfMatch>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<parameter name=\u201csubinterface\u201d purpose=\u201csubinterface\u201d"},{"entry":"\u2003\u2002valueRef=\u201cisisSessionData:subinterface\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<\/socket>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<packet name=\u201cisisSessionData\u201d class=\u201csessionData\u201d>"},{"entry":"\u2003\u2003\u2003<value name=\u201csubinterface\u201d"},{"entry":"\u2003\u2003\u2003\u2003fullName=\u201cSub-interface identifier\u201d"},{"entry":"\u2003\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003\u2003format=\u201cinteger\u201d\/>"},{"entry":"\u2003\u2003\u2003<value name=\u201cL1_mac_address\u201d"},{"entry":"\u2003\u2003\u2003\u2003fullName=\u201cL1 Destination MAC address\u201d"},{"entry":"\u2003\u2003\u2003\u2003format=\u201cmac_address\u201d"},{"entry":"\u2003\u2003\u2003\u2003length=\u201c48\u201d"},{"entry":"\u2003\u2003\u2003\u2003defaultValue=\u201c0x0180C2000014\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003writable=\u201cno\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<value name=\u201cL2_mac_address\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cL2 Destination MAC address\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003format=\u201cmac_address\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003length=\u201c48\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003defaultValue=\u201c0x0180C2000015\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003writable=\u201cno\u201d\/>"},{"entry":"\u2003\u2003<\/packet>"},{"entry":"\u2003<\/emulation>"},{"entry":"\u2003<\/emulationSet>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"An <enumSet> is a table of name\/value pairs, and is used to map meaningful names to specific values or value ranges. This is especially useful for GUI presentation of certain data, where raw values are better presented alongside a meaningful value. Additionally, the enumSet concept can be extended to allow parcels or parcel values to reference each other based on a particular value. An example of an <enum> set is shown in Table 12.",{"@attributes":{"id":"p-0088","num":"0087"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<enumSet name=\u201cTopology Types\u201d>"},{"entry":"\u2003\u2003<enum value=\u201c1\u201d name=\u201cRoute Pool\u201d parcelRef=\u201cRoutePool\u201d\/>"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003<enum value=\u201c2\u201d name=\u201cGrid\u201d","parcelRef=\u201cGrid\u201d\/>"]},{"entry":["\u2003\u2003<enum value=\u201c2\u201d name=\u201cRing\u201d","parcelRef=\u201cRing\u201d\/>"]},{"entry":"<\/enumSet>"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Here a specific value, e.g. \u201c1\u201d is mapped to a name \u201cRoute Pool\u201d, and also to a parcel. This could be used in a GUI, where for example a summary table of topology items is listed. When the user selects a row in the table, he will see detailed data extracted from the parcel referenced according to the topology type.","Each element in a may be annotated using descriptive attributes. Such attributes document the element, allowing the message definition to be self-documenting. By storing the attributes with the message definition and perhaps the message reference model, the routines provided to manipulate and interface with messages may be generic in nature, e.g. the data structure is not coded in the routines, rather the data structure is provided during run-time. For example, attributes can be used to provide all the information needed to present and edit any message or segment using a generic graphical user interface. Some examples of possible attributes are shown in Table 13. Those of ordinary skill in the art will recognize that the list present in table 2 is not exhaustive\u2014other attributes may prove beneficial depending on the implementation of the present invention.",{"@attributes":{"id":"p-0091","num":"0090"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Attribute","Purpose"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["fullName","GUI presentation name for the parcel element"]},{"entry":["description","Description of purpose and usage"]},{"entry":["length","For value and array elements, the length attribute defines"]},{"entry":[{},"the number of bits required to hold the value."]},{"entry":["format","The presentation format. Defined formats include \u201cinteger\u201d,"]},{"entry":[{},"\u201chex\u201d, \u201cBoolean\u201d, \u201cipv4_address\u201d etc."]},{"entry":["minValue\/","Allowed value ranges, allowing the GUI or API to perform"]},{"entry":["maxValue","automated range checking"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"By way of example, Table 14 contains an example of a protocol emulation definition in XML. In particular, Table 14 contains a sample bgp4 definition file.",{"@attributes":{"id":"p-0093","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 14"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<?xml version=\u201c1.0\u201d standalone=\u201cyes\u201d?>"},{"entry":"<EmulationSet version=\u201c1\u201d providedBy=\u201cAgilent Technologies\u201d>"},{"entry":"<!-- Copyright 2004 Agilent Technologies -->"},{"entry":"<!--"},{"entry":"=================================================== -"},{"entry":"->"},{"entry":"<filter name=\u201cbgp4_filter\u201d>"},{"entry":"\u2003\u2003<hwMatch type=\u201cipv4\u201d protocolValue=\u201c6\u201d dataValue=\u201c0xb3\u201d"},{"entry":"dataMask=\u201c0xffff\u201d\/>"},{"entry":"\u2003\u2003<hwMatch type=\u201cipv4\u201d protocolValue=\u201c6\u201d dataValue=\u201c0xb30000\u201d"},{"entry":"dataMask=\u201c0xffff0000\u201d\/>"},{"entry":"\u2003\u2003<hwMatch type=\u201cipv6\u201d protocolValue=\u201c6\u201d dataValue=\u201c0xb3\u201d"},{"entry":"dataMask=\u201c0xffff\u201d\/>"},{"entry":"\u2003\u2003<hwMatch type=\u201cipv6\u201d protocolValue=\u201c6\u201d dataValue=\u201c0xb30000\u201d"},{"entry":"dataMask=\u201c0xffff0000\u201d\/>"},{"entry":"<\/filter>"},{"entry":"<!--"},{"entry":"=================================================== -"},{"entry":"->"},{"entry":"<emulation name=\u201cbgp4\u201d"},{"entry":"\u2003\u2003shortName=\u201cBGP4\u201d"},{"entry":"\u2003\u2003fullName=\u201cBGP4 emulation\u201d"},{"entry":"\u2003\u2003standard=\u201cRFC 1771\u201d"},{"entry":"\u2003\u2003description=\u201cSample BGP4 emulation description\u201d"},{"entry":"\u2003\u2003filter=\u201cbgp4_filter\u201d >"},{"entry":"\u2003\u2003<socket name=\u201cclientSkt\u201d type=\u201ctcpClient\u201d instance=\u201csession\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<option name=\u201csoLinger\u201d value=\u201c0\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<option name=\u201csoReuseaddr\u201d value=\u201c0\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<option name=\u201cipTtl\u201d value=\u201c1\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<option name=\u201cipServiceOctet\u201d value=\u201c64\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<parameter purpose=\u201clocalAddress\u201d"},{"entry":"valueRef=\u201cbgpSessionData:local_ip\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<parameter purpose=\u201cremoteAddress\u201d"},{"entry":"valueRef=\u201cbgpSessionData:remote_ip\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<parameter purpose=\u201cremotePort\u201d"},{"entry":"valueRef=\u201cbgpSessionData:remote_port\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<parameter purpose=\u201csubinterface\u201d"},{"entry":"valueRef=\u201cbgpSessionData:subinterface\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<parameter purpose=\u201cprefixLength\u201d"},{"entry":"valueRef=\u201cbgpSessionData:prefix_length\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<tcpReassembly offset=\u201c128\u201d length=\u201c16\u201d"},{"entry":"\u2003\u2003\u2003\u2003lengthMultiplier=\u201c8\u201d\/>"},{"entry":"\u2003\u2003<\/socket>"},{"entry":"\u2003\u2003<socket name=\u201cserverSkt\u201d type=\u201ctcpServer\u201d client=\u201cclientSkt\u201d"},{"entry":"instance=\u201cglobal\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<option name=\u201csoLinger\u201d value=\u201c0\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<option name=\u201csoReuseaddr\u201d value=\u201c0\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<parameter purpose=\u201clocalPort\u201d"},{"entry":"valueRef=\u201cbgpSessionData:local_port\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<parameter purpose=\u201clocalAddress\u201d"},{"entry":"valueRef=\u201cbgpSessionData:local_ip\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<parameter purpose=\u201csubinterface\u201d"},{"entry":"valueRef=\u201cbgpSessionData:subinterface\u201d\/>"},{"entry":"\u2003\u2003<\/socket>"},{"entry":"\u2003\u2003<parcel name=\u201cbgpSessionData\u201d"},{"entry":"\u2003\u2003\u2003\u2003fullName=\u201cBGP4 Session Data\u201d"},{"entry":"\u2003\u2003\u2003\u2003class=\u201csessionData\u201d"},{"entry":"\u2003\u2003\u2003\u2003flow=\u201ctoServer\u201d"},{"entry":"\u2003\u2003\u2003\u2003buffer=\u201cnewest\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201clocal_port\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cLocal port\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003purpose=\u201clocalPort\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003length=\u201c16\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003format=\u201cinteger\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003defaultValue=\u201c179\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cremote_port\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cRemote port\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003purpose=\u201cremotePort\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003length=\u201c16\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003format=\u201cinteger\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003defaultValue=\u201c179\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201csubinterface\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cSub-interface identifier\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003purpose=\u201csubinterface\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003format=\u201cinteger\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cprefix_length\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cAddress prefix length\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003format=\u201cinteger\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003purpose=\u201cprefixLength\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003defaultValue=\u201c24\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201clocal_ip\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cSource IP Address\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003format=\u201cipv4_address\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003purpose=\u201clocalAddress\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003length=\u201c32\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cremote_ip\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cDestination IP Address\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003format=\u201cipv4_address\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003purpose=\u201cremoteAddress\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003length=\u201c32 \u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cserver_port\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cServer TCP Port\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003format=\u201cinteger\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003purpose=\u201clocalPort\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003length=\u201c16\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cserver_ip\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cServer IP Address\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003format=\u201cipv4_address\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003purpose=\u201clocalAddress\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003length=\u201c32\u201d\/>"},{"entry":"\u2003\u2003<\/parcel>"},{"entry":"\u2003\u2003<parcel name=\u201crouteSummary\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003class=\u201ctopologySummary\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003buffer=\u201cnewest\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cv4Pools\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cNumber of IPv4 Pools\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003format=\u201cinteger\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cv4Addresses\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cNumber of IPv4 Addresses\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003format=\u201cinteger\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cv6Pools\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cNumber of IPv6 Pools\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003format=\u201cinteger\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cv6Addresses\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cNumber of IPv6 Addresses\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003format=\u201cinteger\u201d\/>"},{"entry":"\u2003\u2003<\/parcel>"},{"entry":"\u2003\u2003<enumSet name=\u201cpoolState\u201d fullName=\u201cRoute Pool State\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<enum value=\u201c0\u201d name=\u201cWithdrawn\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<enum value=\u201c1\u201d name=\u201cAdvertised\u201d\/>"},{"entry":"\u2003\u2003<\/enumSet>"},{"entry":"\u2003\u2003<parcel name=\u201croutePools\u201d"},{"entry":"\u2003\u2003\u2003\u2003fullName=\u201cRoute Pools\u201d"},{"entry":"\u2003\u2003\u2003\u2003class=\u201ctopologyData\u201d"},{"entry":"\u2003\u2003\u2003\u2003buffer=\u201cfetch\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<table name=\u201cipv4Pools\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cIPv4 Route Pools\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<value name=\u201cv4StartAddr\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cStart Address\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003length=\u201c32\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003format=\u201cipv4_address\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<value name=\u201cv4PrefixLen\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cPrefix Length\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003minValue=\u201c1\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003defaultValue=\u201c24\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003maxValue=\u201c32\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<value name=\u201cv4Count\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cCount\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<value name=\u201cstate\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cState\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003length=\u201c1\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003enumRef=\u201cpoolState\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<\/table>"},{"entry":"\u2003\u2003\u2003\u2003<table name=\u201cipv6Pools\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cIPv6 Route Pools\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<value name=\u201cv6StartAddr\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cStart Address\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003length=\u201c128\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003format=\u201cipv6_address\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<value name=\u201cv6PrefixLen\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cPrefix Length\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003minValue=\u201c1\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003defaultValue=\u201c64\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003maxValue=\u201c128\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<value name=\u201cv6Count\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cCount\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<value name=\u201cstate\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cState\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003length=\u201c1\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003enumRef=\u201cpoolState\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<\/table>"},{"entry":"\u2003\u2003<\/parcel>"},{"entry":"\u2003\u2003<command name=\u201cadvertise\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<use rowRef=\u201croutePools:ipv4Pools\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<use rowRef=\u201croutePools:ipv6Pools\u201d\/>"},{"entry":"\u2003\u2003<\/command>"},{"entry":"\u2003\u2003<command name=\u201cwithdraw\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<use rowRef=\u201croutePools:ipv4Pools\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<use rowRef=\u201croutePools:ipv6Pools\u201d\/>"},{"entry":"\u2003\u2003<\/command>"},{"entry":"\u2003\u2003<parcel name=\u201cstatistics\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003class=\u201cstatistics\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003buffer=\u201cnewest\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cOpenTx\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cTransmitted Open messages\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cOpenRx\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cReceived Open messages\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cUpdateTx\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cTransmitted Update messages\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cUpdateRx\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cReceived Update messages\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cKeepAliveTx\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cTransmitted KeepAlive messages\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cKeepAliveRx\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cReceived KeepAlive messages\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cNotificationTx\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cTransmitted Notification messages\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<value name=\u201cNotificationRx\u201d"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003fullName=\u201cReceived Notification messages\u201d\/>"},{"entry":"\u2003\u2003<\/parcel>"},{"entry":"<\/emulation>"},{"entry":"<!--"},{"entry":"=================================================== -"},{"entry":"->"},{"entry":"<\/EmulationSet>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Often default values for elements need to be set which vary according to other values specified internally or externally of the definition. In such cases it may be beneficial to integrate Tool Command Language (TCL) procedures that can be invoked to perform such tasks. Such function can be specified in the protocol emulation definition files. Integration of TCL is within the capabilities of those of ordinary skill in the art and as such the specific details of such integration will not be discussed herein. An example of a portion of a parcel definition incorporating TCL functions is shown in Table 15:",{"@attributes":{"id":"p-0095","num":"0094"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 15"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<value name=\u201dholdTimer\u201d fullName=\u201dHold Timer\u201d length=\u201d16\u201d"},{"entry":"\u2003\u2003defaultValue=\u201d30\u201d\/>"},{"entry":"<value name=\u201dkeepalive\u201d fullName=\u201dKeepalive Value\u201d length=\u201d16\u201d"},{"entry":"\u2003\u2003valueFunction=\u201dmultiply :holdTimer 2\u201d \/>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In this example, the default value for keepalive is maintained at twice the holdTimer, no matter what value is set for holdTimer. The TCL functions can be executed when instantiating a parcel, e.g. creating an instance of a parcel. Further, routines can be created to review the message definition and\/or model and update the values affected by such functions during runtime.","Referring to , the protocol emulation definitions may be stored on the host  and retrieved at run time by the emulation control . Similarly, any remote process (such as the ports , the GUI , and the Tcl API ) that communicates with the host  may be provided with the copies of the protocol emulation definitions.","At run-time, the protocol emulation definitions are parsed to create reference models. In general, the reference model is a data structure, such as in C. The reference model serves two functions. The first function is to hold data that is referenced by the various functional elements of the system. The second function is to serve as a model for the creation of parcels used to communicate data to and from the emulation control . Such parcels may comprise instances of a protocol emulation definition or one or more segments thereof. Perhaps the closest analogous structure to a reference model would be a generic type in c. One difference is that while generic types must be defined at compile, a reference model can be introduced during run time. In at least one embodiment of the present invention, the reference model from which parcels are derived defines the type. In use, it may prove beneficial to parse all protocol emulation definitions at system startup so as to generate a reference model of all potential parcels that may be required during operation. However, if time and storage are considerations, it may be advisable to generate only those reference models that are likely to be needed for the current session.","Each major element of the GPF  (e.g. the emulation control , the emulation housings , and the proxy controls ) should have a copy of the protocol emulation definitions . This may be accomplished by providing the protocol emulation definitions  to one element, typically the emulation control , and subsequently distributing copies to the other elements. One manner in which this can be accomplished is to manually provide each element of the GPF  with a bootstrap definition file that enables the configuration and operation of the parcel stores. Thereafter, upon system initialization, the parcel stores can be used to transmit the current set of protocol emulation definitions files  by encapsulating them in a parcel and transmitting them using the parcel stores ","As stated hereinabove, communication to and from the emulation control  preferably occurs via a pre-defined messaging format based on the concept of parcels as described in co-pending U.S. patent application #10\/851,303. The parcels may be transmitted using the concept of a parcel link  (see ).","The parcel link  may comprise a simple interface that simply sends and receives byte strings making it straightforward to implement over a serial interface if required, or any type of network. The physical implementation details should be transparent to the GPF and further discussion will be dispensed with.","One method for transmitting parcels is to serializing the data in the parcel by extracting the data from the structure. Enough data structure should be provided to identify the reference model (or portion thereof) that can be used to decode the binary stream and recreate the parcel on the receiving side. During this reconstruction, the structural information contained in the reference model maybe used to parse the data in the binary stream. Accordingly, the recipient of the serialized message should be provided with a copy of the appropriate message definitions. The recipient must parse the message definition to generate a reference model, which should be a copy of the reference model . Upon receipt of the serialized message, the recipient forms a message object by instantiating the reference model (or portion thereof) and populates the resultant data structure with the binary data thereby re-creating the message object.","Table 16 is a portion of self-documenting C++ code describing a communication link suitable for use in transmitting messages in accordance with embodiments of the present invention.",{"@attributes":{"id":"p-0104","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 16"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#ifndef APF_PARCEL_LINK_H"},{"entry":"#define APF_PARCEL_LINK_H"},{"entry":"\/\/ =================================================="},{"entry":"\/\/"},{"entry":"\/\/ = LIBRARY"},{"entry":"\/\/\u2003\u2003APF Agilent Protocol Framework"},{"entry":"\/\/"},{"entry":"\/\/ = FILENAME"},{"entry":"\/\/\u2003\u2003ApfParcelLink.h"},{"entry":"\/\/"},{"entry":"\/\/ = DESCRIPTION"},{"entry":"\/\/"},{"entry":"\/\/ Interface linking one parcel store with another."},{"entry":"\/\/"},{"entry":"\/\/ = AUTHORS"},{"entry":"\/\/\u2003\u2003Geoff Smith"},{"entry":"\/\/"},{"entry":"\/\/ = COPYRIGHT"},{"entry":"\/\/\u2003\u2003(C) Copyright 2004 Agilent Technologies"},{"entry":"\/\/"},{"entry":"\/\/ =================================================="},{"entry":"#include \u201cacl\/acl.h\u201d"},{"entry":"#include \u201cacl\/afc\/afc.h\u201d"},{"entry":"#include \u201cpdubuilder\/include\/apbExport_.h\u201d"},{"entry":"\/\/---------------------------------------------------------------------"},{"entry":"\/\/ = TITLE"},{"entry":"\/\/\u2003\u2003Parcel Link"},{"entry":"\/\/"},{"entry":"\/\/ = CLASS TYPE"},{"entry":"\/\/\u2003\u2003Interface"},{"entry":"\/\/"},{"entry":"\/\/ = DESCRIPTION"},{"entry":"\/\/ Interface linking one parcel store with another. Proxies and Stubs for"},{"entry":"\/\/ this interface may be implemented by intervening system layers outside"},{"entry":"\/\/ of the GPF for linking GPF parcel stores residing on different platforms."},{"entry":"\/\/"},{"entry":"\/\/ Implementation of this interface is provided by the parcel store at each"},{"entry":"\/\/ end of a link. Note that each parcel store both provides and uses an"},{"entry":"\/\/ implementation of this interface to communicate with another"},{"entry":"parcel store."},{"entry":"class APB_EXPORT_CLASS IApfParcelLink"},{"entry":"{"},{"entry":"public:"},{"entry":"\u2003\/\/ = FOUNDATION"},{"entry":"\u2003virtual ~IApfParcelLink( ) { }"},{"entry":"\u2003\u2003\u2009\u2009virtual void"},{"entry":"\u2003parcelData(uint32_t aPort,"},{"entry":"\u2003\u2003\u2009\u2009uint32_t aSession,"},{"entry":"\u2003\u2003\u2009\u2009const AtoString& aName,"},{"entry":"\u2003\u2003\u2009\u2009const AtoByteString& aParcel) = 0;"},{"entry":"};"},{"entry":"#endif \/\/ APF_PARCEL_LINK_H"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Ultimately, the present invention realizes the possibility of generic protocol emulations, where entire protocol emulations can be defined in XML and Tcl to run within the framework. This would empower customers and technical support engineers with the ability to test new protocols immediately without waiting for the supplier to deliver the protocol module. Such a generic emulation would appear identical to the API and GUI as an inbuilt emulation, although there may be performance limitations. However, the time-to market window is addressed, providing the opportunity to follow up with a high performance in-built emulation solution if required. A standalone framework easily deployable in a variety of target platforms. Protocol modules can be developed and tested in a self-contained GPF environment, and deployed on whatever platform the GPF is deployed. The GPF can be easily deployed in a variety of target platforms or even distributed environments due to the flexible star-wired nature of the three GPF components, and the very simple, asynchronous parcelLink API that is used to connect the components together."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["An understanding of the present invention can be gained from the following detailed description of certain embodiments of the present invention, taken in conjunction with the accompanying drawings of which:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2","i":"a "},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2","i":"b "},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
