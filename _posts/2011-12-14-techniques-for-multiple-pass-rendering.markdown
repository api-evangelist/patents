---
title: Techniques for multiple pass rendering
abstract: Techniques for multiple pass rendering include receiving vertex data for one or more objects to be enhanced. Parameters in a display list may be determined using the vertex data. Multiple pixel rendering passes may be run using the parameters in the display list. An enhanced depiction of the one or more objects may be rendered based on the multiple pixel rendering passes. Other embodiments are described and claimed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09177412&OS=09177412&RS=09177412
owner: INTEL CORPORATION
number: 09177412
owner_city: Santa Clara
owner_country: US
publication_date: 20111214
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["Three dimensional technology plays a crucial role in the graphics development domain. Three dimensional technology is implemented in mobile devices such as smart phones, tables and netbooks. The performance and power consumption of the three dimensional technology on the mobile devices is typically correlated to the user's visual experience and influences a product's competitive advantage.","Many three dimensional games use special effects such as, transparency, shadowing and\/or adaptive textures\/skins to make the games more attractive to end users. However, the applications running on current graphical processing units require many passes through the entire three dimensional pipeline on the same set of three dimensional objects in order to create these special effects.","For example, to create a transparent effect, the application has to do depth peeling first to get the frame buffer for each depth layer and then blend the layers according to the depth value. During the process of depth peeling, the application must run through the three dimensional pipeline multiple times on the same set of three dimensional objects in order to obtain the data from the different layers. During each run through the three dimensional pipeline, both the vertex phase and the pixel phase of the three dimensional pipeline is computed. However, during the runs, there is no change in the vertex phase. As a result, the vertex phase computing in these passes is duplicative and redundant. It is with respect to these and other considerations that the present improvements have been needed.","Various embodiments are directed to multi-pass rendering. In an embodiment, the multi-pass rendering may occur without redundantly processing vertex data. In an embodiment, vertex data for one or more objects to be enhanced may be received. In an embodiment, parameters in a display list may be determined using the vertex data. Multiple pixel rendering passes may be run using the parameters in the display list. An enhanced depiction of the one or more objects may be rendered based on the multiple pixel rendering passes.","The rendering of three dimensional effects may be improved by using the separate vertex phase and pixel phase within the three dimensional pipeline. By running the vertex phase a single time to create a display list and then reusing the display list while running the pixel phase multiple times, a three dimensional effect may be achieved with better performance and less power consumption. As a result, the embodiments can improve affordability, scalability, modularity, extendibility, or interoperability for an operator, device or network.","Reference is now made to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding thereof. It may be evident, however, that the novel embodiments can be practiced without these specific details. In other instances, well known structures and devices are shown in block diagram form in order to facilitate a description thereof. The intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the claimed subject matter.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","100","100","100"]},"The system  may comprise the multiple pass rendering application . In an embodiment, the multiple pass rendering application  may run on a graphical processing unit. In an embodiment, the multiple pass rendering application  may run through a three dimensional pipeline in order to create a three dimensional special effect. For example, a multiple pass rendering application  may create special effects such as, but not limited to, transparency, shadowing, adaptive texture and\/or adaptive skins.","In an embodiment, the system  may improve performance of rendering three dimensional effects by having a graphics application programming interface  and a graphics driver  within the multiple pass rendering application .","In an embodiment, the graphics driver  may be a three dimensional driver. The graphics driver  may work with a graphics processing unit to process the three dimensional pipeline into two separate phases. In an embodiment, the three dimensional pipeline may include a vertex phase  and a pixel phase . In an embodiment, the graphics driver  may run a vertex phase . The vertex phase  may be processed and an interrupt may be generated to the graphics driver . The graphics driver  may store a result of the vertex phase  in a display list. By storing the result in the display list, the pixel phase  may later use the display list for pixel processing.","In an embodiment, the graphics driver  may run the pixel phase  multiple times through the three dimensional pipeline in order to create a desired special effect. By separating the vertex phase  from the pixel phase , the vertex phase can be run a single time and the result stored. The stored result may be used during the multiple passes of the pixel phase by the pixel component . As a result, power is saved as the vertex component  does not have to be rerun each time the pixel component  is run in the three dimensional pipeline.","In an embodiment, the vertex phase  may be operative to receive vertex data based on one or more objects. In an embodiment, vertex data  may be input data  for the multiple pass rendering application . In an embodiment, the vertex data  may be data from one or more objects to which a special effect may be applied. The vertex phase  may run the vertex data  from an object through the vertex pipeline to process the data. The vertex phase  may determine primitive data. In an embodiment, primitive data may include one or more of transforming, lighting, color and position data.","In an embodiment, the vertex phase  may store the primitive data in a display list. In an embodiment, the display list may include multiple parameters. In an embodiment, the parameters for the display list may include the primitive data determined by the vertex phase using the vertex data. In an embodiment, the parameters for the display list may include pointers to command data buffers. For example, the parameters for the display list may include a pointer to a texture buffer, a pointer to a pixel shader buffer and\/or a pointer to a depth\/render buffer. In an embodiment, a depth\/render buffer may be two separate buffers with respective depth and render information. In an embodiment, a depth buffer may include depth information. The depth information may be used to reflect an object's distance. In an embodiment, a render buffer may include a render result. In an embodiment, a render buffer may be referred to as a frame buffer.","In an embodiment, after the vertex phase  is finished processing, the graphics driver  may begin the pixel phase  using the parameters from the display list generated by the vertex phase . In an embodiment, a pixel phase  may be independent from the vertex phase . In other words, a pixel phase  may be run multiple times without rerunning the vertex phase . In an embodiment, the pixel phase  may be operative to run multiple pixel rendering passes using the display list. In an embodiment, a pixel rendering pass may be run for a first time to obtain a depth\/render or frame buffer for a closest depth layer. In an embodiment, each pixel rendering pass may obtain a frame buffer from the next closest depth layer. In an embodiment, a pixel rendering pass may be run for a final time to obtain a frame buffer for a farthest depth layer.","In an embodiment, after the pixel phase  runs multiple pixel rendering passes and the furthest layer is reach by depth peeling, the pixel phase  may render an enhanced depiction of the one or more objects to be enhanced. In an embodiment, an enhanced depiction of the one or more objects may be the output  of the multiple pass rendering application . The output  may include the rendering of the one or more objects with a special effect. For example, after the depth peeling, the pixel phase  of the multiple pass rendering application  may blend the depth\/render or frame buffer from the further layer to the closest layer to obtain a transparency effect for the one or more objects.","Included herein is a set of flow charts representative of exemplary methodologies for performing novel aspects of the disclosed architecture. While, for purposes of simplicity of explanation, the one or more methodologies shown herein, for example, in the form of a flow chart or flow diagram, are shown and described as a series of acts, it is to be understood and appreciated that the methodologies are not limited by the order of acts, as some acts may, in accordance therewith, occur in a different order and\/or concurrently with other acts from that shown and described herein. For example, those skilled in the art will understand and appreciate that a methodology could alternatively be represented as a series of interrelated states or events, such as in a state diagram. Moreover, not all acts illustrated in a methodology may be required for a novel implementation.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2","b":["200","200"]},"In the illustrated embodiment shown in , the logic flow  may receive vertex data for one or more objects to be enhanced at block . For example, the vertex data may be received during a first phase of a three dimensional pipeline. In an embodiment, the three dimensional pipeline may have two phases. In an embodiment, the first phase may include a vertex phase. The vertex phase may receive vertex data for one or more objects to be enhanced. For example, a user may want an object or a set of objects in a scene to appear transparent. As a result, vertex data associated with the object or set of objects in a scene may be received during the vertex phase in the three dimensional pipeline.","The logic flow  may determine a display list using the vertex data during a single run of the first phase at block . For example, the vertex data may be processed during the vertex phase. In an embodiment, the vertex data may be processed and\/or compiled to determine position, color and other information regarding the vertex data. The embodiments are not limited to this example.","In an embodiment, the vertex phase may create a display list based on the processed vertex data. The display list may include one or more parameters. In an embodiment, the display list parameters may include primitive data. In an embodiment, the display list parameters may include command buffers. Command buffers may include control buffers. Command buffers may include pointers to various buffers associated with the second or pixel phase. In an embodiment, the pointers to the various buffers may be used in the pixel phase. In an embodiment, command buffers may include, but are not limited to, a pointer to a texture buffer, a pointer to a pixel shader buffer and a pointer to a depth\/render buffer.","In an embodiment, the command buffers set during the vertex phase may be changed prior to the pixel phase. In an embodiment, the command buffers set during the vertex phase may be a default texture buffer, pixel shader buffer, and\/or depth\/render buffer. In an embodiment, a user may determine that a particular buffer should be used and the parameter may be redefined so that the pointer may point to that particular buffer. For example, if after the vertex phase was run a user specifies a particular texture buffer, the particular texture buffer can be used for the pixel phase instead of the default texture buffer to which the pointer pointed to on the display list. In an embodiment, the display list may replace the pointer to the default textual buffer with a pointer to the texture buffer chosen by a user. As the vertex phase and pixel phase are separated within the three dimensional pipeline, a user may choose one or more buffers after the vertex phase was run, but before the pixel phase is run for a first time.","The logic flow  may run multiple second phase pixel rendering passes using the display list at block . For example, the pixel phase may be run multiple times in order to achieve the desired special effect. Each time the pixel phase is run, the display list may be used without having to rerun the vertex phase. The pointers in the display list may be updated so that the pixel phase may use the information from the parameters in the display list without needing to rerun the vertex phase.","For example, the pixel phase may be run multiple times with each time removing a layer of depth from the object. The pixel phase may continue to run until the pixel phase determines that the last layer of depth has been removed from the image. The embodiments are not limited to this example.","The logic flow  may render an enhanced depiction of the one or more objects based on the multiple second phase pixel rendering passes at block . For example, by running the vertex phase a single time and using the display list generated from the vertex phase to run the pixel phase multiple times, an enhanced depiction of one or more objects may be rendered. In an embodiment, three dimensional special effects may be rendered. For example, various textures may be depicted on the one or more objects, the objects may be shown as partially or completely transparent and\/or the objects may be shown with shadows. The embodiments are not limited to this example.","For example, a building may be an object in a scene to be enhanced. A user may want to make the building object appear transparent. Vertex data may be determined for the building object. The vertex data may be received by a graphical processing unit. The vertex data may be received during the vertex phase of the three dimensional pipeline. The compiled and processed vertex data may be primitive data. During a single run of the vertex phase, a display list may be determined. The display list may contain parameters, such as, but not limited to primitive data and control buffers.","The graphics processing unit may determine whether to run the pixel phase. The graphics driver may wait to run the pixel phase until a command is received. In an embodiment, a command from a user may be received to use a particular buffer to process the primitive data. The graphics processing unit may redefine and\/or update the parameters in the display list based on the particular buffer. For example, the graphics processing unit may update one or more pointers in the command buffer so that a pointer points to the particular pixel shader buffer chosen by a user. This allows the pixel shader buffer specified by a user to be used in the pixel phase.","In an embodiment, multiple second phase pixel rendering passes may be run. In an embodiment, a first pixel rendering pass may remove a first layer from the building object. In an embodiment, a second pixel rendering pass may remove a second layer from the building object. Subsequent second phase pixel rendering passes may be run until the last layer of the building object is determined.","For example, an enhanced transparent image may be rendered of the building object. When multiple pixel rendering phases have been run on the building object, multiple depth\/render frame buffers may be determined for the multiple depth peeling layers. In order to render a transparent object, the graphics processing unit may blend the layers using the frame buffers from furthest layer to closest layer according a depth value. A transparent image of the building object may be rendered. In an embodiment, the transparent building object may be rendered on a display of a mobile device. The embodiments are not limited to this example.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 3","b":["300","402","301","300","322","326","122"]},"In an embodiment, the graphics processing unit  may process the vertex phase  using a vertex pipeline. The graphics processing unit  may process the vertex phase  and then generate an interrupt to the graphics driver . The graphics driver  may run a vertex phase . The graphics driver  may receive an interrupt to store a result of the vertex phase  in an output buffer, such as, but not limited to, the display list . By storing the result in the display list , the pixel phase  may later use the display list  for pixel processing. In an embodiment, the graphics driver  may run the pixel phase .","In an embodiment, the display list  may include information needed for pixel processing. In an embodiment, the display list  may include one or more parameters. In an embodiment, the parameters in a display list  may include primitive data . In an embodiment, the primitive data  may include vertex data processed by the vertex phase . As discussed above, primitive data  may include one or more of transforming, lighting, color and position data.","In an embodiment, parameters in the display list  may include command buffers. In an embodiment, the command buffers  may include control stream information. In an embodiment, the command buffers  may include pointers to various buffers needed in the pixel phase  for pixel processing. For example, the command buffers  may include a pointer to texture buffers . The texture buffer may include a texture image which may be rendered for one or more objects in a scene. In an embodiment, texture coordinate information may be vertex primary attribute data. In an embodiment, texture coordinate information may be used to determine how to map a texture image onto a three dimensional object. The information in the texture buffer  and the primitive data  may be inputs for processing during the pixel phase .","In an embodiment, a pointer to the pixel shader buffer  may be included in the display list . The pixel shader buffer  may include information for processing the inputs during the pixel phase . In particular, the pixel shader buffer  may include information for processing information in the texture buffer  and primitive data . In an embodiment, the pixel shader buffer  may include programming code. In an embodiment, the code stored in the pixel shader buffer  may be loaded by the graphical processing unit  during the pixel phase .","In an embodiment, a pointer to the depth\/render buffer  may be included in the display list . In an embodiment, a depth\/render buffer  may include two separate buffers with respective depth and render information. In an embodiment, a depth buffer may include depth information. The depth information may be used to reflect an object's distance. In an embodiment, a render buffer may include a render result. In an embodiment, the depth\/render buffer  may include the output information after the pixel shader buffer  processes the primitive data  and the texture buffer . In an embodiment, the depth\/render buffer  may store the pixels at each depth layer as the pixel phase  runs a pixel pass removing a closest layer.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 4"},"The objects may be run through the vertex phase to create a display list with multiple parameters based on the circle with a line objects. The circle and line objects may be run through a first phase in the three dimensional pipeline. The first phase may be a vertex phase. After the vertex phase is complete, the circle and line objects may be ready for the second phase in the three dimensional pipeline. The second phase may be a pixel phase for pixel processing. The pixel phase may include multiple runs of pixel rendering passes using parameters from the display list.","For example, a first pixel rendering pass may obtain a depth\/render or frame buffer for a closest depth layer. As shown in , the first layer (layer )  may include a first pass through the pixel phase. In a first depth peeling layer , the closest layer may be removed.","The multiple pass rendering application  may determine that there are more layers to the circle and line object. As a result, the multiple pass rendering application  may update the pointers to the buffers from the display list and may rerun the pixel phase on the circle plus line objects. As the display list may be used for subsequent pixel passes, the vertex phase does not need to be rerun. Accordingly, the vertex phase can be run a single time and the pixel phase can be rerun to remove the various depth layers.","The second pass through the pixel phase may determine the second layer (layer )  of the circle plus line objects. The pixel phase may determine the next closest layer by using parameters from the first layer  and removing pixels from the first layer . The multiple pass rendering application  may remove the pixels from the first layer  to obtain the next closest layer . The next closest layer may be the second layer . The second phase pixel rendering pass may be run to obtain a frame buffer for a second depth layer .","The third pass through the pixel phase may determine the third and final layer (layer ) . As the first and second layers were removed during the first two passes, the closest layer may be the third layer . The pixel phase may determine the next closest layer by using parameters from the second layer  and removing pixels from the first layer  and second layer . The multiple pass rendering application  may remove the pixels from the first layer  and second layer  to obtain the next closest layer . A pixel rendering pass may be run to obtain a frame buffer for a farthest depth layer . The pixel rendering pass may determine that the farthest layer  has been reached by running another pixel pass and determining that there are no further depth layers. In an embodiment, when the final pixel pass is run, the subsequent depth\/render buffer may be the same as the previous depth\/render buffer. In an embodiment, when the final pixel pass is run, there may be no pixels in the depth\/render buffer. In an embodiment, when the final pixel pass is run, no further layer may exist as there may be no larger depth value to replace the existing value in depth buffer and no rendering pixels to be stored in render buffer.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 5","FIG. 5"],"b":["520","525","530","535"]},"For example, a first run  through the pixel phase may use the primitive data  as input. The first run  through the pixel phase may not have any texture data from the texture buffer  as no comparison is needed with a previous layer. During the first run  through the pixel phase, the pixel shader buffer information  may process the primitive data and the closest layer of pixels may be placed in the depth\/render buffer  as output.","Prior to the second run  of the pixel phase, the buffers may be updated. The output data from the depth\/render buffer  may be placed in the texture buffer . The pixel data from the texture buffer  may then be used, along with the primitive data , as input for the second run  of the pixel phase. The second run  may use data from the pixel shader buffer  to process the pixel data from the texture buffer  and the primitive data . In an embodiment, the pixel shader buffer  may compare the primitive data  with the pixel data from the texture buffer  to determine the next layer. The result of the processing may be pixel data which may be placed in the depth\/render buffer .","Prior to the third run  of the pixel phase, the buffers may be updated. The output data from the depth\/render buffer  may be placed in the texture buffer . The pixel data from the texture buffer  may be used, along with the primitive data , as input for the third run  of the pixel phase. The third run  may use data from the pixel shader buffer  to process the pixel data from the texture buffer  and the primitive data . In an embodiment, the pixel shader buffer  may compare the primitive data  with the pixel data from the texture buffer  to determine the next layer. The result of the processing may be pixel data which may be placed in the depth\/render buffer . As the pixel data in the depth\/render buffer  may be from the final or last layer of the object, the depth peeling of the pixel phase may be complete. The embodiments are not limited to this example.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 6","b":["620","625"]},"After the multiple pass rendering application  receives the command to open the application, the multiple pass rendering application  may send information to the graphics driver . For example, the information sent to the graphics driver  may include vertex data to determine the three dimensional primitives for one or more objects in a scene. The graphics driver  may generate one or more command buffers and store pointers for a pixel phase . For example, the graphics driver  may prepare the command buffer. For example, the graphics driver  may record where the texture buffer, the pixel shader buffer and the depth\/render buffer are used in the command buffer. In an embodiment, the graphics driver  may store pointers to the texture buffer, the pixel shader buffer and the depth\/render buffer.","The multiple pass rendering application  may begin the vertex phase . The multiple pass rendering application  may send the information to the graphics driver  so that the graphics driver  may begin the vertex phase to determine a display list . The graphics driver  may stop processing after the vertex phase is completed. In an embodiment, the graphics driver  may wait for a command from the multiple pass rendering application  prior to beginning the pixel phase. In an embodiment, the graphics driver  may receive input from the multiple pass rendering application  that is used in the pixel phase.","In an embodiment, the multiple pass rendering application  may setup the texture buffer, pixel shader buffer and depth\/render buffer . In an embodiment, a command may be received to setup the command buffers. In an embodiment, the buffers may be determined via user input into the multiple pass rendering application . For example, after the vertex phase, a user may determine a texture buffer to be used during the pixel phase. For example, a user may determine a pixel shader buffer to be used during the pixel phase. The embodiments are not limited to this example.","Based on the setup by the multiple pass rendering application , the graphics driver  may replace the pointers of the texture buffer, the pixel shader buffer and\/or the depth\/render buffer within the command buffer of the display list .","The multiple pass rendering application  may begin the pixel phase  by communicating with the graphics driver  to run a pixel pass . After each pixel pass , the pointers within the command buffer may be replaced . The multiple pass rendering application  may determine whether it is the last pass . If the graphics driver  was able to determine a new depth layer, then the graphics driver  may run another pixel pass .","When the pixel phase is finished and the last pass  has run , then the multiple pass rendering application  may command the graphics driver  to generate the final scene using the results of the previous passes . The graphics driver  may display the rendered results . The rendered results  may include a scene with a three dimensional object.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 7","b":["700","700","100","720"]},"In an embodiment, the computing device  may be a mobile device. A mobile device may include, without limitation, a computer, server, workstation, notebook computer, handheld computer, telephone, cellular telephone, personal digital assistant (PDA), combination cellular telephone and PDA, and so forth.","The computing device  may execute processing operations or logic for the system  using a processing component . The processing component  may comprise various hardware elements, software elements, or a combination of both. Examples of hardware elements may include devices, components, processors, microprocessors, circuits, circuit elements (e.g., transistors, resistors, capacitors, inductors, and so forth), integrated circuits, application specific integrated circuits (ASIC), programmable logic devices (PLD), digital signal processors (DSP), field programmable gate array (FPGA), memory units, logic gates, registers, semiconductor device, chips, microchips, chip sets, and so forth. Examples of software elements may include software components, programs, applications, computer programs, application programs, system programs, machine programs, operating system software, middleware, firmware, software modules, routines, subroutines, functions, methods, procedures, software interfaces, application program interfaces (API), instruction sets, computing code, computer code, code segments, computer code segments, words, values, symbols, or any combination thereof. Determining whether an embodiment is implemented using hardware elements and\/or software elements may vary in accordance with any number of factors, such as desired computational rate, power levels, heat tolerances, processing cycle budget, input data rates, output data rates, memory resources, data bus speeds and other design or performance constraints, as desired for a given implementation.","The computing device  may execute communications operations or logic for the system  using communications component . The communications component  may implement any well-known communications techniques and protocols, such as techniques suitable for use with packet-switched networks (e.g., public networks such as the Internet, private networks such as an enterprise intranet, and so forth), circuit-switched networks (e.g., the public switched telephone network), or a combination of packet-switched networks and circuit-switched networks (with suitable gateways and translators). The communications component  may include various types of standard communication elements, such as one or more communications interfaces, network interfaces, network interface cards (NIC), radios, wireless transmitters\/receivers (transceivers), wired and\/or wireless communication media, physical connectors, and so forth. By way of example, and not limitation, communication media  includes wired communications media and wireless communications media. Examples of wired communications media may include a wire, cable, metal leads, printed circuit boards (PCB), backplanes, switch fabrics, semiconductor material, twisted-pair wire, co-axial cable, fiber optics, a propagated signal, and so forth. Examples of wireless communications media may include acoustic, radio-frequency (RF) spectrum, infrared and other wireless media .","The computing device  may communicate with other devices ,  over a communications media  using communications signals  via the communications component . In an embodiment, the computing device  may include, but is not limited to, smart phones, tablets, laptops, etc.","In an embodiment, computing device  may comprise a display . In one embodiment, the display  may comprise a liquid crystal display (LCD). In one embodiment, the display  may comprise an organic light emitting diode (OLED) display. In one embodiment, an OLED display may be used as it provides better color saturation and viewing angles then a liquid crystal display (LCD). In one embodiment, the display  may comprise one or more OLED display screens.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 8","b":["800","800"]},"In one embodiment, the computing architecture  may comprise or be implemented as part of an electronic device. Examples of an electronic device may include without limitation a mobile device, a personal digital assistant, a mobile computing device, a smart phone, a cellular telephone, a handset, a one-way pager, a two-way pager, a messaging device, a computer, a personal computer (PC), a desktop computer, a laptop computer, a notebook computer, a handheld computer, a tablet computer, a server, a server array or server farm, a web server, a network server, an Internet server, a work station, a mini-computer, a main frame computer, a supercomputer, a network appliance, a web appliance, a distributed computing system, multiprocessor systems, processor-based systems, consumer electronics, programmable consumer electronics, television, digital television, set top box, wireless access point, base station, subscriber station, mobile subscriber center, radio network controller, router, hub, gateway, bridge, switch, machine, or combination thereof. The embodiments are not limited in this context.","The computing architecture  includes various common computing elements, such as one or more processors, co-processors, memory units, chipsets, controllers, peripherals, interfaces, oscillators, timing devices, video cards, audio cards, multimedia input\/output (I\/O) components, and so forth. The embodiments, however, are not limited to implementation by the computing architecture .","As shown in , the computing architecture  comprises a processing unit , a system memory  and a system bus . The processing unit  can be any of various commercially available processors. Dual microprocessors and other multi-processor architectures may also be employed as the processing unit . The system bus  provides an interface for system components including, but not limited to, the system memory  to the processing unit . The system bus  can be any of several types of bus structure that may further interconnect to a memory bus (with or without a memory controller), a peripheral bus, and a local bus using any of a variety of commercially available bus architectures.","The computing architecture  may comprise or implement various articles of manufacture. An article of manufacture may comprise a computer-readable storage medium to store logic. Embodiments of the invention may also be at least partly implemented as instructions contained in or on a non-transitory computer-readable medium, which may be read and executed by one or more processors to enable performance of the operations described herein. Examples of a computer-readable storage medium may include any tangible media capable of storing electronic data, including volatile memory or non-volatile memory, removable or non-removable memory, erasable or non-erasable memory, writeable or re-writeable memory, and so forth. Examples of logic may include executable computer program instructions implemented using any suitable type of code, such as source code, compiled code, interpreted code, executable code, static code, dynamic code, object-oriented code, visual code, and the like.","The system memory  may include various types of computer-readable storage media in the form of one or more higher speed memory units, such as read-only memory (ROM), random-access memory (RAM), dynamic RAM (DRAM), Double-Data-Rate DRAM (DDRAM), synchronous DRAM (SDRAM), static RAM (SRAM), programmable ROM (PROM), erasable programmable ROM (EPROM), electrically erasable programmable ROM (EEPROM), flash memory, polymer memory such as ferroelectric polymer memory, ovonic memory, phase change or ferroelectric memory, silicon-oxide-nitride-oxide-silicon (SONOS) memory, magnetic or optical cards, or any other type of media suitable for storing information. In the illustrated embodiment shown in , the system memory  can include non-volatile memory  and\/or volatile memory . A basic input\/output system (BIOS) can be stored in the non-volatile memory .","The computer  may include various types of computer-readable storage media in the form of one or more lower speed memory units, including an internal hard disk drive (HDD) , a magnetic floppy disk drive (FDD)  to read from or write to a removable magnetic disk , and an optical disk drive  to read from or write to a removable optical disk  (e.g., a CD-ROM or DVD). The HDD , FDD  and optical disk drive  can be connected to the system bus  by a HDD interface , an FDD interface  and an optical drive interface , respectively. The HDD interface  for external drive implementations can include at least one or both of Universal Serial Bus (USB) and IEEE 1394 interface technologies.","The drives and associated computer-readable media provide volatile and\/or nonvolatile storage of data, data structures, computer-executable instructions, and so forth. For example, a number of program modules can be stored in the drives and memory units , , including an operating system , one or more application programs , other program modules , and program data .","The one or more application programs , other program modules , and program data  can include, for example, the vertex phase  and the pixel phase .","A user can enter commands and information into the computer  through one or more wire\/wireless input devices, for example, a keyboard  and a pointing device, such as a mouse . Other input devices may include a microphone, an infra-red (IR) remote control, a joystick, a game pad, a stylus pen, touch screen, or the like. These and other input devices are often connected to the processing unit  through an input device interface  that is coupled to the system bus , but can be connected by other interfaces such as a parallel port, IEEE 1394 serial port, a game port, a USB port, an IR interface, and so forth.","A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adaptor . In addition to the monitor , a computer typically includes other peripheral output devices, such as speakers, printers, and so forth.","The computer  may operate in a networked environment using logical connections via wire and\/or wireless communications to one or more remote computers, such as a remote computer . The remote computer  can be a workstation, a server computer, a router, a personal computer, portable computer, microprocessor-based entertainment appliance, a peer device or other common network node, and typically includes many or all of the elements described relative to the computer , although, for purposes of brevity, only a memory\/storage device  is illustrated. The logical connections depicted include wire\/wireless connectivity to a local area network (LAN)  and\/or larger networks, for example, a wide area network (WAN) . Such LAN and WAN networking environments are commonplace in offices and companies, and facilitate enterprise-wide computer networks, such as intranets, all of which may connect to a global communications network, for example, the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a wire and\/or wireless communication network interface or adaptor . The adaptor  can facilitate wire and\/or wireless communications to the LAN , which may also include a wireless access point disposed thereon for communicating with the wireless functionality of the adaptor .","When used in a WAN networking environment, the computer  can include a modem , or is connected to a communications server on the WAN , or has other means for establishing communications over the WAN , such as by way of the Internet. The modem , which can be internal or external and a wire and\/or wireless device, connects to the system bus  via the input device interface . In a networked environment, program modules depicted relative to the computer , or portions thereof, can be stored in the remote memory\/storage device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers can be used.","The computer  is operable to communicate with wire and wireless devices or entities using the IEEE 802 family of standards, such as wireless devices operatively disposed in wireless communication (e.g., IEEE 802.11 over-the-air modulation techniques) with, for example, a printer, scanner, desktop and\/or portable computer, personal digital assistant (PDA), communications satellite, any piece of equipment or location associated with a wirelessly detectable tag (e.g., a kiosk, news stand, restroom), and telephone. This includes at least Wi-Fi (or Wireless Fidelity), WiMax, and Bluetooth\u2122 wireless technologies. Thus, the communication can be a predefined structure as with a conventional network or simply an ad hoc communication between at least two devices. Wi-Fi networks use radio technologies called IEEE 802.11x (a, b, g, n, etc.) to provide secure, reliable, fast wireless connectivity. A Wi-Fi network can be used to connect computers to each other, to the Internet, and to wire networks (which use IEEE 802.3-related media and functions).",{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 9","b":["900","900","900"]},"As shown in , the communications architecture  comprises includes one or more clients  and servers . The clients  may implement the client systems . The clients  and the servers  are operatively connected to one or more respective client data stores  and server data stores  that can be employed to store information local to the respective clients  and servers , such as cookies and\/or associated contextual information.","The clients  and the servers  may communicate information between each other using a communication framework . The communications framework  may implement any well-known communications techniques and protocols, such as those described with reference to system . The communications framework  may be implemented as a packet-switched network (e.g., public networks such as the Internet, private networks such as an enterprise intranet, and so forth), a circuit-switched network (e.g., the public switched telephone network), or a combination of a packet-switched network and a circuit-switched network (with suitable gateways and translators).","Some embodiments may be described using the expression \u201cone embodiment\u201d or \u201can embodiment\u201d along with their derivatives. These terms mean that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification are not necessarily all referring to the same embodiment. Further, some embodiments may be described using the expression \u201ccoupled\u201d and \u201cconnected\u201d along with their derivatives. These terms are not necessarily intended as synonyms for each other. For example, some embodiments may be described using the terms \u201cconnected\u201d and\/or \u201ccoupled\u201d to indicate that two or more elements are in direct physical or electrical contact with each other. The term \u201ccoupled,\u201d however, may also mean that two or more elements are not in direct contact with each other, but yet still co-operate or interact with each other.","It is emphasized that the Abstract of the Disclosure is provided to allow a reader to quickly ascertain the nature of the technical disclosure. It is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims. In addition, in the foregoing Detailed Description, it can be seen that various features are grouped together in a single embodiment for the purpose of streamlining the disclosure. This method of disclosure is not to be interpreted as reflecting an intention that the claimed embodiments require more features than are expressly recited in each claim. Rather, as the following claims reflect, inventive subject matter lies in less than all features of a single disclosed embodiment. Thus the following claims are hereby incorporated into the Detailed Description, with each claim standing on its own as a separate embodiment. In the appended claims, the terms \u201cincluding\u201d and \u201cin which\u201d are used as the plain-English equivalents of the respective terms \u201ccomprising\u201d and \u201cwherein,\u201d respectively. Moreover, the terms \u201cfirst,\u201d \u201csecond,\u201d \u201cthird,\u201d and so forth, are used merely as labels, and are not intended to impose numerical requirements on their objects.","What has been described above includes examples of the disclosed architecture. It is, of course, not possible to describe every conceivable combination of components and\/or methodologies, but one of ordinary skill in the art may recognize that many further combinations and permutations are possible. Accordingly, the novel architecture is intended to embrace all such alterations, modifications and variations that fall within the spirit and scope of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 7","FIG. 1"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
