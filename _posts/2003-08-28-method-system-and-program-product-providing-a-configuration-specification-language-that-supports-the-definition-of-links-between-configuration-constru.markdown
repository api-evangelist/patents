---
title: Method, system and program product providing a configuration specification language that supports the definition of links between configuration constructs
abstract: Methods, data processing systems, and program products are disclosed that support the definition and accessing of links indicating a relationship between configuration construct instances, such as Dial and Dial group instances, within a digital design. According to one method, first and second latches within the digital design are specified in at least one HDL statement within one or more HDL files representing the digital design. In the one or more HDL files, a first configuration construct instance referencing the first latch and a second configuration construct instance referencing the second latch are also defined. The first and second configuration construct instances provide interfaces through which values of the first and second latches can be accessed. In addition, a link indicating a relationship between the first and second configuration construct instances is also defined within the one or more HDL files.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07143387&OS=07143387&RS=07143387
owner: International Business Machines Corporation
number: 07143387
owner_city: Armonk
owner_country: US
publication_date: 20030828
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENT"],"p":["The present application is related to co-pending U.S. patent application Ser. No. 10\/425,096, which is assigned to the assignee of the present application and incorporated herein by reference in its entirety.","1. Technical Field","The present invention relates in general to designing, simulating and configuring digital devices, modules and systems, and in particular, to methods and systems for computer-aided design, simulation, and configuration of digital devices, modules and systems described by a hardware description language (HDL) model.","2. Description of the Related Art","The above-referenced patent application introduces a configuration specification language that permits a designer to define configuration constructs called Dials in order to provide an interface through which the latches of a digital design may be conveniently read and set. A number of different types of Dials may be defined and instantiated within the digital design, and the various types of Dial instances may be accessed during simulation, laboratory testing, and field deployment of the digital design in order to set and read the configuration of the digital design.","Various relationships between Dial instances may also be defined. For example, as described in the above-referenced application, a Control Dial (or CDial) instance is a Dial instance having a controlling relationship with one or more hierarchically related lower-level child Dial instances controlled by the CDial instance. That is, the CDial instance has an input\/output relationship with one or more lower level child Dial instances according to which the output of the CDial instance controls the input settings of one or more lower level child Dial instances.","Dial instances may also be aggregated into configuration constructs referred to as Dial groups. Grouping of Dial instances into Dial group instances ensures that any set operation affecting Dial instances within a Dial group instance will fail unless the set operation is performed for every Dial instance in the Dial group instance. The configuration constraints enforced by Dial group instances promote coherent configuration of the digital design.","The present invention recognizes that, in addition to these defined relationships between Dial instances, it would be useful and desirable to permit the definition of additional relationships between Dial instances that may or may not be causative (as is the relationship of a CDial instance to its child Dial instances) or restrictive (as is the relationship between Dial instances within a Dial group instance). For example, the present invention recognizes that it would be useful to define a relationship between Dial instances to alert diagnostic or other software examining Dial instance values that a predefined or designer-defined relationship exists between two Dial instances in order to enhance understanding of the operation of the digital design.","In view of the foregoing, the present invention provides methods, systems, and program products supporting the definition and accessing of links indicating a relationship between configuration construct instances, such as Dial and Dial group instances. According to one method, first and second latches within the digital design are specified in at least one HDL statement within one or more HDL files representing the digital design. In the one or more HDL files, a first configuration construct instance referencing the first latch and a second configuration construct instance referencing the second latch are also defined. The first and second configuration construct instances provide interfaces through which values of the first and second latches can be accessed. In addition, a link indicating a relationship between the first and second configuration construct instances is also defined within the one or more HDL files. The link may have an associated type field that permits the designer to designate a type of the link.","All objects, features, and advantages of the present invention will become apparent in the following detailed written description.","The present invention discloses a configuration specification language and associated methods, systems, and program products for configuring and controlling the setup of a digital system (e.g., one or more integrated circuits or a simulation model thereof). In at least one embodiment, configuration specifications for signals in the digital system are created in HDL code by the designer responsible for an associated design entity. Thus, designers at the front end of the design process, who are best able to specify the signal names and associated legal values, are responsible for creating the configuration specification. The configuration specification is compiled at model build time together with the HDL describing the digital system to obtain a configuration database that can then be utilized by downstream organizational groups involved in the design, simulation, and hardware implementation processes.","With reference now to the figures, and in particular with reference to , there is depicted an exemplary embodiment of a data processing system in accordance with the present invention. The depicted embodiment can be realized, for example, as a workstation, server, or mainframe computer.","As illustrated, data processing system  includes one or more processing nodes \u2013, which, if more than one processing node  is implemented, are interconnected by node interconnect . Processing nodes \u2013may each include one or more processors , a local interconnect , and a system memory  that is accessed via a memory controller . Processors \u2013are preferably (but not necessarily) identical and may comprise a processor within the PowerPC\u2122 line of processors available from International Business Machines (IBM) Corporation of Armonk, N.Y. In addition to the registers, instruction flow logic and execution units utilized to execute program instructions, which are generally designated as processor core , each of processors \u2013also includes an on-chip cache hierarchy that is utilized to stage data to the associated processor core  from system memories .","Each of processing nodes \u2013further includes a respective node controller  coupled between local interconnect  and node interconnect . Each node controller  serves as a local agent for remote processing nodes  by performing at least two functions. First, each node controller  snoops the associated local interconnect  and facilitates the transmission of local communication transactions to remote processing nodes . Second, each node controller  snoops communication transactions on node interconnect  and masters relevant communication transactions on the associated local interconnect . Communication on each local interconnect  is controlled by an arbiter . Arbiters  regulate access to local interconnects  based on bus request signals generated by processors  and compile coherency responses for snooped communication transactions on local interconnects .","Local interconnect  is coupled, via mezzanine bus bridge , to a mezzanine bus . Mezzanine bus bridge  provides both a low latency path through which processors  may directly access devices among I\/O devices  and storage devices  that are mapped to bus memory and\/or I\/O address spaces and a high bandwidth path through which I\/O devices  and storage devices  may access system memory . I\/O devices  may include, for example, a display device, a keyboard, a graphical pointer, and serial and parallel ports for connection to external networks or attached devices. Storage devices  may include, for example, optical or magnetic disks that provide non-volatile storage for operating system, middleware and application software. In the present embodiment, such application software includes an ECAD system , which can be utilized to develop, verify and simulate a digital circuit design in accordance with the methods and systems of the present invention.","Simulated digital circuit design models created utilizing ECAD system  are comprised of at least one, and usually many, sub-units referred to hereinafter as design entities. Referring now to , there is illustrated a block diagram representation of an exemplary design entity  which may be created utilizing ECAD system . Design entity  is defined by a number of components: an entity name, entity ports, and a representation of the function performed by design entity . Each design entity within a given model has a unique entity name (not explicitly shown in ) that is declared in the HDL description of the design entity. Furthermore, each design entity typically contains a number of signal interconnections, known as ports, to signals outside the design entity. These outside signals may be primary input\/outputs (I\/Os) of an overall design or signals connected to other design entities within an overall design.","Typically, ports are categorized as belonging to one of three distinct types: input ports, output ports, and bi-directional ports. Design entity  is depicted as having a number of input ports  that convey signals into design entity . Input ports  are connected to input signals . In addition, design entity  includes a number of output ports  that convey signals out of design entity . Output ports  are connected to a set of output signals . Bi-directional ports  are utilized to convey signals into and out of design entity . Bi-directional ports  are in turn connected to a set of bidirectional signals . A design entity, such as design entity , need not contain ports of all three types, and in the degenerate case, contains no ports at all. To accomplish the connection of entity ports to external signals, a mapping technique, known as a \u201cport map\u201d, is utilized. A port map (not explicitly depicted in ) consists of a specified correspondence between entity port names and external signals to which the entity is connected. When building a simulation model, ECAD software  is utilized to connect external signals to appropriate ports of the entity according to a port map specification.","As further illustrated in , design entity  contains a body section  that describes one or more functions performed by design entity . In the case of a digital design, body section  contains an interconnection of logic gates, storage elements, etc., in addition to instantiations of other entities. By instantiating an entity within another entity, a hierarchical description of an overall design is achieved. For example, a microprocessor may contain multiple instances of an identical functional unit. As such, the microprocessor itself will often be modeled as a single entity. Within the microprocessor entity, multiple instantiations of any duplicated functional entities will be present.","Each design entity is specified by one or more HDL files that contain the information necessary to describe the design entity. Although not required by the present invention, it will hereafter be assumed for ease of understanding that each design entity is specified by a respective HDL file.","With reference now to , there is illustrated a diagrammatic representation of an exemplary simulation model  that may be employed by ECAD system  to represent a digital design (e.g., an integrated circuit chip or a computer system) in a preferred embodiment of the present invention. For visual simplicity and clarity, the ports and signals interconnecting the design entities within simulation model  have not been explicitly shown.","Simulation model  includes a number of hierarchically arranged design entities. As within any simulation model, simulation model  includes one and only one \u201ctop-level entity\u201d encompassing all other entities within simulation model . That is to say, top-level entity  instantiates, either directly or indirectly, all descendant entities within the digital design. Specifically, top-level entity  directly instantiates (i.e., is the direct ancestor of) two instances, and , of the same FiXed-point execution Unit (FXU) entity  and a single instance of a Floating Point Unit (FPU) entity . FXU entity instances , having instantiation names FXU and FXU, respectively, in turn instantiate additional design entities, including multiple instantiations of entity A  having instantiation names A and A, respectively.","Each instantiation of a design entity has an associated description that contains an entity name and an instantiation name, which must be unique among all descendants of the direct ancestor entity, if any. For example, top-level entity  has a description  including an entity name  (i.e., the \u201cTOP\u201d preceding the colon) and also includes an instantiation name  (i.e., the \u201cTOP\u201d following the colon). Within an entity description, it is common for the entity name to match the instantiation name when only one instance of that particular entity is instantiated within the ancestor entity. For example, single instances of entity B  and entity C  instantiated within each of FXU entity instantiations and have matching entity and instantiation names. However, this naming convention is not required by the present invention as shown by FPU entity  (i.e., the instantiation name is FPU, while the entity name is FPU).","The nesting of entities within other entities in a digital design can continue to an arbitrary level of complexity, provided that all entities instantiated, whether singly or multiply, have unique entity names and the instantiation names of all descendant entities within any direct ancestor entity are unique with respect to one another.","Associated with each design entity instantiation is a so called \u201cinstantiation identifier\u201d. The instantiation identifier for a given instantiation is a string including the enclosing entity instantiation names proceeding from the top-level entity instantiation name. For example, the design instantiation identifier of instantiation of entity C  within instantiation of FXU entity  is \u201cTOP.FXU.B.C\u201d. This instantiation identifier serves to uniquely identify each instantiation within a simulation model.","As discussed above, a digital design, whether realized utilizing physical integrated circuitry or as a software model such as simulation model , typically includes configuration latches utilized to configure the digital design for proper operation. In contrast to prior art design methodologies, which employ stand-alone configuration software created after a design is realized to load values into the configuration latches, the present invention introduces a configuration specification language that permits a digital designer to specify configuration values for signals as a natural part of the design process. In particular, the configuration specification language of the present invention permits a design configuration to be specified utilizing statements either embedded in one or more HDL files specifying the digital design (as illustrated in ) or in one or more external configuration files referenced by the one or more HDL files specifying the digital design (as depicted in ).","Referring now to , there is depicted an exemplary HDL file , in this case a VHDL file, including embedded configuration statements in accordance with the present invention. In this example, HDL file  specifies entity A  of simulation model  and includes three sections of VHDL code, namely, a port list  that specifies ports ,  and , signal declarations  that specify the signals within body section , and a design specification  that specifies the logic and functionality of body section . Interspersed within these sections are conventional VHDL comments denoted by an initial double-dash (\u201c--\u201d). In addition, embedded within design specification  are one or more configuration specification statements in accordance with the present invention, which are collectively denoted by reference numerals  and . As shown, these configuration specification statements are written in a special comment form beginning with \u201c--##\u201d in order to permit a compiler to easily distinguish the configuration specification statements from the conventional HDL code and HDL comments. Configuration specification statements preferably employ a syntax that is insensitive to case and white space.","With reference now to , there is illustrated an exemplary HDL file \u2032 that includes a reference to an external configuration file containing one or more configuration specification statements in accordance with the present invention. As indicated by prime notation (\u2032), HDL file \u2032 is identical to HDL file  in all respects except that configuration specification statements ,  are replaced with one or more (and in this case only one) configuration file reference statement  referencing a separate configuration file  containing configuration specification statements , .","Configuration file reference statement , like the embedded configuration specification statements illustrated in , is identified as a configuration statement by the identifier \u201c--##\u201d. Configuration file reference statement  includes the directive \u201ccfg_file\u201d, which instructs the compiler to locate a separate configuration file , and the filename of the configuration file (i.e., \u201cfile00\u201d). Configuration files, such as configuration file , preferably all employ a selected filename extension (e.g., \u201c.cfg\u201d) so that they can be easily located, organized, and managed within the file system employed by data processing system .","As discussed further below with reference to , configuration specification statements, whether embedded within an HDL file or collected in one or more configuration files , are processed by a compiler together with the associated HDL files.","In accordance with a preferred embodiment of the present invention, configuration specification statements, such as configuration specification statements , , facilitate configuration of configuration latches within a digital design by instantiating one or more instances of a configuration entity referred to herein generically as a \u201cDial.\u201d A Dial's function is to map between an input value and one or more output values. In general, such output values ultimately directly or indirectly specify configuration values of configuration latches. Each Dial is associated with a particular design entity in the digital design, which by convention is the design entity specified by the HDL source file containing the configuration specification statement or configuration file reference statement that causes the Dial to be instantiated. Consequently, by virtue of their association with particular design entities, which all have unique instantiation identifiers, Dials within a digital design can be uniquely identified as long as unique Dial names are employed within any given design entity. As will become apparent, many different types of Dials can be defined, beginning with a Latch Dial (or \u201cLDial\u201d).","Referring now to , there is depicted a representation of an exemplary LDial . In this particular example, LDial , which has the name \u201cbus ratio\u201d, is utilized to specify values for configuration latches in a digital design in accordance with an enumerated input value representing a selected ratio between a component clock frequency and bus clock frequency.","As illustrated, LDial , like all Dials, logically has a single input , one or more outputs , and a mapping table  that maps each input value to a respective associated output value for each output . That is, mapping table  specifies a one-to-one mapping between each of one or more unique input values and a respective associated unique output value. Because the function of an LDial is to specify the legal values of configuration latches, each output  of LDial  logically controls the value loaded into a respective configuration latch . To prevent conflicting configurations, each configuration latch  is directly specified by one and only one Dial of any type that is capable of setting the configuration latch .","At input , LDial  receives an enumerated input value (i.e., a string) among a set of legal values including \u201c2:1\u201d, \u201c3:1\u201d and \u201c4:1\u201d. The enumerated input value can be provided directly by software (e.g., by a software simulator or service processor firmware) or can be provided by the output of another Dial, as discussed further below with respect to . For each enumerated input value, the mapping table  of LDial  indicates a selected binary value (i.e., \u201c0\u201d or \u201c1\u201d) for each configuration latch .","With reference now to , there is illustrated a diagrammatic representation of a simulation model logically including Dials. Simulation model \u2032 of , which as indicated by prime notation includes the same design entities arranged in the same hierarchical relation as simulation model  of , illustrates two properties of Dials, namely, replication and scope.","Replication is a process by which a Dial that is specified in or referenced by an HDL file of a design entity is automatically instantiated each time that the associated design entity is instantiated. Replication advantageously reduces the amount of data entry a designer is required to perform to create multiple identical instances of a Dial. For example, in order to instantiate the six instances of LDials illustrated in , the designer need only code two LDial configuration specification statements utilizing either of the two techniques illustrated in . That is, the designer codes a first LDial configuration specification statement (or configuration file reference statement pointing to an associated configuration file) into the HDL file of design entity A  in order to automatically instantiate LDials , ,  and  within entity A instantiations , ,  and , respectively. The designer codes a second LDial configuration specification statement (or configuration file reference statement pointing to an associated configuration file) into the HDL file of design entity FXU  in order to automatically instantiate LDials and within FXU entity instantiations and , respectively. The multiple instances of the LDials are then created automatically as the associated design entities are replicated by the compiler. Replication of Dials within a digital design can thus significantly reduce the input burden on the designer as compared to prior art methodologies in which the designer had to individually enumerate in the configuration software each configuration latch value by hand. It should be noted that the property of replication does not necessarily require all instances of a Dial to generate the same output values; different instances of the same Dial can be set to generate different outputs by providing them different inputs.","The \u201cscope\u201d of a Dial is defined herein as the set of entities to which the Dial can refer in its specification. By convention, the scope of a Dial comprises the design entity with which the Dial is associated (i.e., the design entity specified by the HDL source file containing the configuration specification statement or configuration file reference statement that causes the Dial to be instantiated) and any design entity contained within the associated design entity (i.e., the associated design entity and its descendents). Thus, a Dial is not constrained to operate at the level of the design hierarchy at which it is instantiated, but can also specify configuration latches at any lower level of the design hierarchy within its scope. For example, LDials and , even though associated with FXU entity instantiations and , respectively, can specify configuration latches within entity C instantiations and , respectively.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 5B","FIG. 5B"],"b":["506","514","512","510","522","520","512","520","514","522"]},"Referring now to , there is depicted another diagrammatic representation of a simulation model including an LDial. As indicated by prime notation, simulation model \u2033 of  includes the same design entities arranged in the same hierarchical relation as simulation model  of .","As shown, simulation model \u2033  includes an LDial  associated with top-level design entity . LDial  specifies the signal states of each signal sig , which is determined by a respective configuration latch , the signal states of each signal sig , which is determined by a respective configuration latch , the signal state of signal sig , which is determined by configuration latch , and the signal state of signal sig , which is determined by configuration latch . Thus, LDial  configures the signal states of numerous different signals, which are all instantiated at or below the hierarchy level of LDial  (which is the top level).","As discussed above with respect to , LDial  is instantiated within top-level entity  of simulation model \u2033 by embedding within the HDL file of top-level entity  a configuration specification statement specifying LDial  or a configuration file reference statement referencing a separate configuration file containing a configuration specification statement specifying LDial . In either case, an exemplary configuration specification statement for LDial  is as follows:",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LDial bus ratio (FXU0.A0.SIG1, FXU0.A1.SIG1,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003FXU0.B.C.SIG2(0..5),"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003FXU1.A0.SIG1, FXU1.A1.SIG1,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003FXU1.B.C.SIG2(0..5),"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003FPU0.SIG3, SIG4(0..3)"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003) ="]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003{2:1 =>0b0, 0b0, 0x00,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u20030b0, 0b0, 0x00,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u20030b0, 0x0;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u20033:1 => 0b1, 0b1, 0x01,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u20030b1, 0b1, 0x01,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u20030b0, 0x1;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u20034:1 => 0b1, 0b1, 0x3F,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u20030b1, 0b1, 0x3F,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u20030b1, 0xF"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The exemplary configuration specification statement given above begins with the keyword \u201cLDial,\u201d which specifies that the type of Dial being declared is an LDial, and the Dial name, which in this case is \u201cbus ratio.\u201d Next, the configuration specification statement enumerates the signal names whose states are controlled by the LDial. As indicated above, the signal identifier for each signal is specified hierarchically (e.g., FXU0.A0.SIG1 for signal ) relative to the default scope of the associated design entity so that different signal instances having the same signal name are distinguishable. Following the enumeration of the signal identifiers, the configuration specification statement includes a mapping table listing the permitted enumerated input values of the LDial and the corresponding signal values for each enumerated input value. The signal values are associated with the signal names implicitly by the order in which the signal names are declared. It should again be noted that the signal states specified for all enumerated values are unique, and collectively represent the only legal patterns for the signal states.","Several different syntaxes can be employed to specify the signal states. In the example given above, signal states are specified in either binary format, which specifies a binary constant preceded by the prefix \u201c0b\u201d, or in hexadecimal format, which specifies a hexadecimal constant preceded by the prefix \u201c0x\u201d. Although not shown, signal states can also be specified in integer format, in which case no prefix is employed. For ease of data entry, the configuration specification language of ECAD system  also preferably supports a concatenated syntax in which one constant value, which is automatically extended with leading zeros, is utilized to represent the concatenation of all of the desired signal values. In this concatenated syntax, the mapping table of the configuration specification statement given above can be rewritten as:",{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{2:1 =>\u2003\u20030,"]},{"entry":[{},"\u20023:1 =>\u2003\u20030x183821,"]},{"entry":[{},"\u20024:1 =>\u2003\u20030x1FFFFF"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"With reference now to , there is illustrated a diagrammatic representation of a special case of an LDial having a one-bit output, which is defined herein as a Switch. As shown, a Switch  has a single input , a single 1-bit output  that controls the setting of a configuration latch , and a mapping table  that maps each enumerated input value that may be received at input  to a 1-bit output value driven on output .","Because Switches frequently comprise a significant majority of the Dials employed in a digital design, it is preferable if the enumerated value sets for all Switches in a simulation model of a digital design are the same (e.g., \u201cON\u201d\/\u201cOFF\u201d). In a typical embodiment of a Switch, the \u201cpositive\u201d enumerated input value (e.g., \u201cON\u201d) is mapped by mapping table  to an output value of 0b1 and the \u201cnegative\u201d enumerated input value (e.g., \u201cOFF\u201d) is mapped to an output value of 0b0. In order to facilitate use of logic of the opposite polarity, a Negative Switch or NSwitch declaration is also preferably supported that reverses this default correspondence between input values and output values in mapping table .","The central advantage to defining a Switch primitive is a reduction in the amount of input that designers are required to enter. In particular, to specify a comparable 1-bit LDial, a designer would be required to enter a configuration specification statement of the form:",{"@attributes":{"id":"p-0076","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LDial mode (signal) ="]},{"entry":[{},"\u2003\u2003{ON =>b1;"]},{"entry":[{},"\u2003\u2003\u2002OFF =>b0"]},{"entry":[{},"\u2003\u2003};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":"Switch mode (signal);\n\nAlthough the amount of data entry eliminated by the use of Switches is not particularly significant when only a single Switch is considered, the aggregate reduction in data entry is significant when the thousands of switches in a complex digital design are taken into consideration.\n"}}}},"Referring now to , there is depicted a diagrammatic representation of an Integer Dial (\u201cIDial\u201d) in accordance with a preferred embodiment of the present invention. Like an LDial, an IDial directly specifies the value loaded into each of one or more configuration latches  by indicating within mapping table  a correspondence between each input value received at an input  and an output value for each output . However, unlike LDials, which can only receive as legal input values the enumerated input values explicitly set forth in their mapping tables , the legal input value set of an IDial includes all possible integer values within the bit size of output . (Input integer values containing fewer bits than the bit size of output(s)  are right justified and extended with zeros to fill all available bits.) Because it would be inconvenient and tedious to enumerate all of the possible integer input values in mapping table , mapping table  simply indicates the manner in which the integer input value received at input  is applied to the one or more outputs .","IDials are ideally suited for applications in which one or more multi-bit registers must be initialized and the number of legal values includes most values of the register(s). For example, if a 4-bit configuration register comprising 4 configuration latches and an 11-bit configuration register comprising 11 configuration latches were both to be configured utilizing an LDial, the designer would have to explicitly enumerate up to 2input values and the corresponding output bit patterns in the mapping table of the LDial. This case can be handled much more simply with an IDial utilizing the following configuration specification statement:",{"@attributes":{"id":"p-0079","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IDial cnt_value (sig1(0..3), sig2(0..10));"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":["1","2","1","2","1","2","603","603"]},"IDials may also be utilized to specify the same value for multiple replicated configuration registers, as depicted in . In the illustrated embodiment, an IDial , which can be described as an IDial \u201csplitter\u201d, specifies the configuration of three sets of replicated configuration registers each comprising 15 configuration latches  based upon a single 15-bit integer input value. An exemplary configuration specification statement for instantiating IDial  may be given as follows:",{"@attributes":{"id":"p-0081","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IDial cnt_value(A0.sig1(0..7), A0.sig2(8..14);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003A1.sig1(0..7), A1.sig2(8..14);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003A3.sig1(0..7), A3.sig2(8..14)"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2002);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":["0","1","0","2","1","3"]},"Although the configuration of a digital design can be fully specified utilizing LDials alone or utilizing LDials and IDials, in many cases it would be inefficient and inconvenient to do so. In particular, for hierarchical digital designs such as that illustrated in , the use of LDials and\/or IDials alone would force many Dials to higher levels of the design hierarchy, which, from an organizational standpoint, may be the responsibility of a different designer or design group than is responsible for the design entities containing the configuration latches controlled by the Dials. As a result, proper configuration of the configuration latches would require not only significant organizational coordination between design groups, but also that designers responsible for higher levels of the digital design learn and include within their HDL files details regarding the configuration of lower level design entities. Moreover, implementing Dials at higher levels of the hierarchy means that lower levels of the hierarchy cannot be independently simulated since the Dials controlling the configuration of the lower level design entities are not contained within the lower level design entities themselves.","In view of the foregoing, the present invention recognizes the utility of providing a configuration entity that supports the hierarchical combination of Dials to permit configuration of lower levels of the design hierarchy by lower-level Dials and control of the lower-level Dials by one or more higher-level Dials. The configuration specification language of the present invention terms a higher-level Dial that controls one or more lower-level Dials as a Control Dial (\u201cCDial\u201d).","Referring now to , there is depicted a diagrammatic representation of a CDial in accordance with the present invention. CDial , like all Dials, preferably has a single input , one or more outputs , and a mapping table  that maps each input value to a respective associated output value for each output . Unlike LDials and IDials, which directly specify configuration latches, a CDial  does not directly specify configuration latches. Instead, a CDial  controls one or more other Dials (i.e., CDials and\/or LDials and\/or IDials) logically coupled to CDial  in an n-way \u201cDial tree\u201d in which each lower-level Dial forms at least a portion of a \u201cbranch\u201d that ultimately terminates in \u201cleaves\u201d of configuration latches. Dial trees are preferably constructed so that no Dial is instantiated twice in any Dial tree.","In the exemplary embodiment given in , CDial receives at input  an enumerated input value (i.e., a string) among a set of legal values including \u201cA\u201d, . . . , \u201cN\u201d. If CDial (or an LDial or IDial) is a top-level Dial (i.e., there are no Dials \u201cabove\u201d it in a Dial tree), CDial receives the enumerated input value directly from software (e.g., simulation software or firmware). Alternatively, if CDial forms part of a \u201cbranch\u201d of a dial tree, then CDial receives the enumerated input value from the output of another CDial. For each legal enumerated input value that can be received at input , CDial specifies a selected enumerated value or bit value for each connected Dial (e.g., Dials ,  and ) in mapping table . The values in mapping table  associated with each output  are interpreted by ECAD system  in accordance with the type of lower-level Dial coupled to the output . That is, values specified for LDials and CDials are interpreted as enumerated values, while values specified for IDials are interpreted as integer values. With these values, each of Dials ,  and  ultimately specifies, either directly or indirectly, the values for one or more configuration latches .","With reference now to , there is illustrated another diagrammatic representation of a simulation model containing a Dial tree including a top-level CDial that controls multiple lower-level LDials. As indicated by prime notation, simulation model \u2032\u2033 of  includes the same design entities arranged in the same hierarchical relation as simulation model  of  and contains the same configuration latches and associated signals as simulation model \u2033 of .","As shown, simulation model \u2032\u2033 of  includes a top-level CDial  associated with top-level design entity . Simulation model \u2032\u2033 further includes four LDials , ,  and . LDial , which is associated with entity instantiation A , controls the signal states of each signal sig , which is determined by a respective configuration latch , and the signal state of signal sig , which is determined by configuration latch . LDial , which is a replication of LDial associated with entity instantiation A , similarly controls the signal states of each signal sig, which is determined by a respective configuration latch , and the signal state of signal sig , which is determined by configuration latch . LDial , which is associated with top-level entity , controls the signal state of signal sig , which is determined by configuration latch . Finally, LDial , which is associated with entity instantiation FPU , controls the signal state of signal sig , which is determined by configuration latch . Each of these four LDials is controlled by CDial  associated with top-level entity .","As discussed above with respect to , CDial  and each of the four LDials depicted in  is instantiated within the associated design entity by embedding a configuration specification statement (or a configuration file reference statement pointing to a configuration file containing a configuration specification statement) within the HDL file of the associated design entity. An exemplary configuration specification statement utilized to instantiate each Dial shown in  is given below:",{"@attributes":{"id":"p-0089","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CDial BusRatio (FXU0.BUSRATIO, FXU1.BUSRATIO,"]},{"entry":[{},"FPU0.BUSRATIO, BUSRATIO2)="]},{"entry":[{},"\u2003\u2003\u2003\u2003{2:1 => 2:1, 2:1, 2:1, 2:1;"]},{"entry":[{},"\u2003\u2003\u2003\u20033:1 => 3:1, 3:1, 3:1, 3:1;"]},{"entry":[{},"\u2003\u2003\u2003\u20034:1 => 4:1, 4:1, 4:1, 4:1"]},{"entry":[{},"\u2003\u2003\u2003\u2003};"]},{"entry":[{},"LDial BusRatio (A0.sig1, A1.sig1, B.C.sig2(0..5)) ="]},{"entry":[{},"\u2003\u2003\u2003\u2003{2:1 => 0b0, 0b0, 0x00;"]},{"entry":[{},"\u2003\u2003\u2003\u20033:1 => 0b1, 0b1, 0x01;"]},{"entry":[{},"\u2003\u2003\u2003\u20034:1 => 0b1, 0b1, 0x3F;"]},{"entry":[{},"\u2003\u2003\u2003\u2003};"]},{"entry":[{},"LDial BusRatio (sig3) ="]},{"entry":[{},"\u2003\u2003\u2003\u2003{2:1 => 0b0;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u20023:1 => 0b0;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u20024:1 => 0b1"]},{"entry":[{},"\u2003\u2003\u2003\u2003};"]},{"entry":[{},"LDial BusRatio2 (sig4(0..3)) ="]},{"entry":[{},"\u2003\u2003\u2003\u2003{2:1 => 0x0;"]},{"entry":[{},"\u2003\u2003\u2003\u20033:1 => 0x1;"]},{"entry":[{},"\u2003\u2003\u2003\u20034:1 => 0xF"]},{"entry":[{},"\u2003\u2003\u2003\u2003};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"By implementing a hierarchical Dial tree in this manner, several advantages are realized. First, the amount of software code that must be entered is reduced since the automatic replication of LDials  within FXU entity instantiations and allows the code specifying LDials  to be entered only once. Second, the organizational boundaries of the design process are respected by allowing each designer (or design team) to specify the configuration of signals within the design entity for which he is responsible. Third, coding of upper level Dials (i.e., CDial ) is greatly simplified, reducing the likelihood of errors. Thus, for example, the CDial and LDial collection specified immediately above performs the same function as the \u201clarge\u201d LDial specified above with reference to , but with much less complexity in any one Dial.","Many Dials, for example, Switches utilized to disable a particular design entity in the event an uncorrectable error is detected, have a particular input value that the Dial should have in nearly all circumstances. For such Dials, the configuration specification language of the present invention permits a designer to explicitly specify in a configuration specification statement a default input value for the Dial. In an exemplary embodiment, a Default value is specified by including \u201c=default value\u201d following the specification of a Dial and prior to the concluding semicolon. For example, a default value for a CDial, can be given as follows:",{"@attributes":{"id":"p-0092","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CDial BusRatio (FXU0.BUSRATIO, FXU1.BUSRATIO,"]},{"entry":[{},"FPU0.BUSRATIO, BUSRATIO)="]},{"entry":[{},"\u2003\u2003\u2003\u2003{2:1 => 2:1, 2:1, 2:1, 2:1;"]},{"entry":[{},"\u2003\u2003\u2003\u20033:1 => 3:1, 3:1, 3:1, 3:1;"]},{"entry":[{},"\u2003\u2003\u2003\u20034:1 => 4:1, 4:1, 4:1, 4:1"]},{"entry":[{},"\u2003\u2003\u2003\u2003} = 2:1;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"A default value for an IDial can similarly be specified as follows:",{"@attributes":{"id":"p-0094","num":"0094"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IDial cnt_value(A0.sig1(0..7), A0.sig2(8..14);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003A1.sig1(0..7), A1.sig2(8..14);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003A3.sig1(0..7), A3.sig2(8..14)"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2002) = 0x7FFF;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The use of default values for Dials is subject to a number of rules. First, a default value may be specified for any type of Dial including LDials, IDials (including those with split outputs) and CDials. Second, if default values are specified for multiple Dials in a multiple-level Dial tree, only the highest-level default value affecting each \u201cbranch\u201d of the Dial tree is applied (including that specified for the top-level Dial), and the remaining default values, if any, are ignored. Despite this rule, it is nevertheless beneficial to specify default values for lower-level Dials in a Dial tree because the default values may be applied in the event a smaller portion of a model is independently simulated, as discussed above. In the event that the combination of default values specified for lower-level Dials forming the \u201cbranches\u201d of a Dial tree do not correspond to a legal output value set for a higher-level Dial, the compiler will flag an error. Third, a default value is overridden when a Dial receives an input to actively set the Dial.","By specifying default values for Dials, a designer greatly simplifies use of Dials by downstream organizational groups by reducing the number of Dials that must be explicitly set for simulation or hardware configuration. In addition, as discussed further below, use of default values assists in auditing which Dials have been actively set.","In addition to defining syntax for configuration specification statements specifying Dials, the configuration specification language of the present invention supports at least two additional HDL semantic constructs: comments and attribute specification statements. A comment, which may have the form:\n\n","Attribute specification statements are statements that declare an attribute name and attribute value and associate the attribute name with a particular Dial name. For example, an attribute specification statement may have the form:\n\n","Referring now to , there is depicted a high level flow diagram of a model build process in which HDL files containing configuration statements are compiled to obtain a simulation executable model and a simulation configuration database for a digital design. The process begins with one or more design entity HDL source code files , which include configuration specification statements and\/or configuration file reference statements, and, optionally, one or more configuration specification reference files . HDL compiler  processes HDL file(s)  and configuration specification file(s) , if any, beginning with the top level entity of a simulation model and proceeding in a recursive fashion through all HDL file(s)  describing a complete simulation model. As HDL compiler  processes each HDL file , HDL compiler  creates \u201cmarkers\u201d in the design intermediate files  produced in memory to identify configuration statements embedded in the HDL code and any configuration specification files referenced by an embedded configuration file reference statement.","Thereafter, the design intermediate files  in memory are processed by a configuration compiler  and model build tool  to complete the model build process. Model build tool  processes design intermediate files  into a simulation executable model , that when executed, models the logical functions of the digital design, which may represent, for example, a portion of an integrated circuit, an entire integrated circuit or module, or a digital system including multiple integrated circuits or modules. Configuration compiler  processes the configuration specification statements marked in design intermediate files  and creates from those statements a configuration documentation file  and a configuration database .","Configuration documentation file  lists, in human-readable format, information describing the Dials associated with the simulation model. The information includes the Dials' names, their mapping tables, the structure of Dial trees, if any, instance information, etc. In addition, as noted above, configuration documentation file  includes strings contained in comment statements describing the functions and settings of the Dials in the digital design. In this manner, configuration documentation suitable for use with both a simulation model and a hardware implementation of a digital design is aggregated in a \u201cbottom-up\u201d fashion from the designers responsible for creating the Dials. The configuration documentation is then made available to all downstream organizational groups involved in the design, simulation, laboratory hardware evaluation, and commercial hardware implementation of the digital design.","Configuration database  contains a number of data structures pertaining to Dials. As described in detail below, these data structures include Dial data structures describing Dial entities, latch data structures, and Dial instance data structures. These data structures associate particular Dial inputs with particular configuration values used to configure the digital design (i.e., simulation executable model ). In a preferred embodiment, the configuration values can be specified in terms of either signal states or configuration latch values, and the selection of which values are used is user-selectable. Configuration database  is accessed via Application Programming Interface (API) routines during simulation of the digital design utilizing simulation executable model  and is further utilized to generate similar configuration databases for configuring physical realizations of the digital design. In a preferred embodiment, the APIs are designed so that only top-level Dials (i.e., LDials, IDials or CDials without a CDial logically \u201cabove\u201d them) can be set and all Dial values can be read.","As described above, the configuration specification language of the present invention advantageously permits the specification of the output values of LDials and IDials by reference to signal names (e.g., \u201csig\u201d). As noted above, a key motivation for this feature is that designers tend to think in terms of configuring operative signals to particular signal states, rather than configuring the associated configuration latches. In practice, however, a signal that a designer desires to configure to a particular state may not be directly connected to the output of an associated configuration latch. Instead, a signal to be configured may be coupled to an associated configuration latch through one or more intermediate circuit elements, such as buffers and inverters. Rather than burdening the designer with manually tracing back each configurable signal to an associated configuration latch and then determining an appropriate value for the configuration latch, configuration compiler  automatically traces back a specified signal to the first storage element (i.e., configuration latch) coupled to the signal and performs any necessary inversions of the designer-specified signal state value to obtain the proper value to load into the configuration latch.","With reference now to , there is illustrated a portion of a digital design including an LDial  that controls the states of a plurality of signals \u2013within the digital design. When configuration compiler  performs a traceback of signal , no inversion of the designer-specified signal states is required because signal is directly connected to configuration latch . Accordingly, configuration compiler  stores into configuration database  the designer-specified values from the configuration specification statement of LDial  as the values to be loaded into configuration latch . Traceback of signal to configuration latch similarly does not result in the inversion of any designer-specified values from the configuration specification statement of LDial  because the only intervening element between signal and configuration register is a non-inverting buffer .","Configuration latches, such as configuration latches and , are frequently instantiated by designers through inclusion in an HDL file  of an HDL statement referencing a latch primitive in an HDL design library. The latch entity , inserted into the simulation executable model in response to such HDL library references may include inverters, such as inverters , , which are not explicitly \u201cvisible\u201d to the designer in the HDL code. The automatic traceback performed by configuration compiler  nevertheless detects these inverters, thus preventing possible configuration errors.","Accordingly, when performing a traceback of signal , configuration compiler  automatically inverts the designer-specified configuration value specified for signal before storing the configuration value for configuration latch in configuration database  because of the presence of an inverter  between signal and configuration latch . When configuration compiler  performs traceback of signal , however, configuration compiler  does not invert the designer-specified signal state values despite the presence of inverters ,  and buffer  in the signal path because the logic is collectively non-inverting. It should be noted that configuration compiler  can accurately process both \u201chidden\u201d inverters like inverter  and explicitly declared inverters like inverter .",{"@attributes":{"id":"p-0107","num":"0109"},"figref":"FIG. 9A","b":["904","902","902","916","808","902","902","904","808","900","902","902","902"],"i":["e ","e ","f ","e","f ","e","e","f "]},"Referring now to , there is depicted a high level logical flowchart of the traceback process implemented by configuration compiler  for each signal name specified in a configuration specification statement. As shown, the process begins at block  and then proceeds to block \u2013, which illustrate configuration compiler  initializing an inversion count to zero and then locating the signal identified by the signal name specified in a configuration specification statement.","The process then enters a loop comprising blocks \u2013, which collectively represent configuration compiler  tracing back the specified signal to the first latch element in the signal path. Specifically, as illustrated at blocks \u2013, configuration compiler  determines whether the next \u201cupstream\u201d circuit element in the signal path is a latch (), buffer () or inverter (). If the circuit element is a latch, the process exits the loop and passes to block , which is described below. If, however, the circuit element is a buffer, the process passes to block , which illustrates configuration compiler moving to the next upstream circuit element to be processed without incrementing the inversion count. If the circuit element is an inverter, the process passes to blocks  and , which depicts incrementing the inversion count and then moving to the next upstream circuit element to be processed. In this manner, configuration compiler traces back a specified signal to a configuration latch while determining a number of inversions of signal state implemented by the circuit elements in the path. As noted above, if configuration compiler  detects a circuit element other than a buffer or inverter in the signal path, configuration compiler  preferably flags an error, as shown at block . The process thereafter terminates at block .","Following detection of a configuration latch at block , configuration compiler  determines whether the inversion count is odd or even. As shown at blocks \u2013, if the inversion count is odd, configuration compiler inverts the designer-specified configuration values for the signal at block  prior to inserting the values into configuration database . No inversion is performed prior to inserting the configuration values into configuration database  if the inversion count is even. The process thereafter terminates at block .","As has been described, the present invention provides a configuration specification language that permits a designer of a digital system to specify a configuration for the digital system utilizing configuration statements embedded in the HDL design files describing the digital system. The configuration statements logically instantiate within the digital design one or more Dials, which provide configuration values for the digital design in response to particular inputs. The Dials, like the design entities comprising the digital design, may be hierarchically arranged. The configuration specification statements are compiled together with the HDL files describing the digital design to produce a configuration database that may be accessed to configure a simulation executable model or (after appropriate transformations) a physical realization of the digital design. The compilation of the configuration specification statements preferably supports a traceback process in which designer-specified configuration values for a signal are inverted in response to detection of an odd number of inverters coupled between the signal and an associated configuration latch.","With reference again to , recall that an exemplary configuration specification statement for LDial  includes a parenthetical signal enumeration of the form:",{"@attributes":{"id":"p-0113","num":"0115"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LDial bus ratio (FXU0.A0.SIG1, FXU0.A1.SIG1,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003FXU0.B.C.SIG2(0..5),"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003FXU1.A0.SIG1, FXU1.A1.SIG1,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003FXU1.B.C.SIG2(0..5),"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003FPU0.SIG3, SIG4(0..3)"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003) ="]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003..."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"In order to reduce the amount of input required to input the signal (or Dial) enumeration sections of configuration specification statements and to reduce the burden of code maintenance as new signal and Dial instances are added to the digital design, an ECAD system  in accordance with the present invention also supports a \u201ccompact expression\u201d syntax for the signal (or Dial) enumeration sections of configuration specification statements. This syntax is referred to herein more specifically as \u201ccompact signal expression\u201d when applied to the configuration specification statements of LDials and IDials and is referred to as \u201ccompact Dial expression\u201d when referring to the configuration specification statements of CDials.","In a compact expression of a signal or Dial enumeration, all instances of an entity within a selected scope for which a common configuration is desired can be enumerated with a single identifier. For example, in , if the designer wants a common configuration for all four instantiations of signal sig , the designer could enumerate all four instantiations in the configuration specification statement of LDial  with the single compact signal expression \u201c[A].sig\u201d, where the bracketed term is the name of the entity in which the signal of interest occurs. In compact expressions, the default scope of the expression is implied as the scope of the design entity (in this case top-level entity ) with which the Dial is associated. The identifier \u201c[A].sig\u201d thus specifies all four instantiations of signal sig  within A entity instantiations  within the default scope of top-level entity .","The scope of the identifier in a compact expression can further be narrowed by explicitly enumerating selected levels of the design hierarchy. For example, the compact expression \u201cFXU.[A].sig\u201d refers only to signal sig instantiations  and  within FXU entity instantiation , but does not encompass signal sig instantiations  and 1 within FXU entity instantiation ","Of course, when only a single instance of a signal or Dial is instantiated at higher levels of the design hierarchy, the compact expression and the full expression will require approximately the same amount of input (e.g., \u201cFPU.sig\u201d versus \u201c[FPU].sig\u201d to identify signal sig ). However, it should be noted that if another FPU entity  were later added to simulation model \u2033, the compact expression of the identification would advantageously apply to any later added FPU entities within the scope of top-level entity .","Utilizing compact expression, the configuration specification statement for LDial  can now be rewritten more compactly as follows:",{"@attributes":{"id":"p-0119","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LDial bus ratio ([A].SIG1, [C].SIG2(0..5),"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003FPU0.SIG3, SIG4(0..3)"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003) ="]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003{2:1 =>0b0, 0x00, 0b0, 0x0;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u20023:1 =>0b1, 0x01, 0b0, 0x1;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u20024:1 =>0b1, 0x3F, 0b1, 0xF"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0120","num":"0122"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{2:1 =>0;"]},{"entry":[{},"\u20023:1 =>0x821;"]},{"entry":[{},"\u20024:1 =>0xFFF"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":["1","2","0","3","4","524"]},"Compact Dial expressions are constructed and parsed by the compiler in the same manner as compact signal expressions. For example, the configuration specification statement for CDial  of  can be rewritten utilizing compact Dial expression as follows:",{"@attributes":{"id":"p-0122","num":"0124"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"CDial BusRatio ([FXU].BUSRATIO, [FPU].BUSRATIO, BUSRATIO)="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{2:1 => 2:1, 2:1, 2:1;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u20023:1 => 3:1, 3:1, 3:1;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u20024:1 => 4:1, 4:1, 4:1"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003};"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":["710","300","304","314"]},"Referring now to , there is depicted a high level logical flowchart of an exemplary method by which configuration compiler  parses each signal or Dial identification within a configuration specification statement in accordance with the present invention. As described above, each signal or Dial identification is constructed hierarchically from one or more fields separated by periods (\u201c.\u201d). The last field specifies an instance name of a signal (e.g., \u201csig\u201d) or Dial (e.g., \u201cBus_Ratio\u201d), and the preceding fields narrow the scope from the default scope, which by convention is the scope of the design entity with which the Dial is associated.","As shown, the process begins at block  and then proceeds to block , which illustrates configuration compiler  determining whether the first or current field of the signal or Dial identification contains an entity identifier enclosed in brackets (e.g., \u201c[A]\u201d), that is, whether the identification is a compact expression. If so, the process passes to block , which is described below. If not, configuration compiler  determines at block  whether the identification is a full expression, by determining whether the first or current field of the identification is the last field of the identification. If so, the signal or Dial identification is a full expression, and the process passes to block . If, on the other hand, the current field of the identification is not the last field, configuration compiler  narrows a current scope to the design entity instantiation identified in the current field of the identification, as depicted at block . For example, if configuration compiler  were processing the identification \u201cFPU0.SIG3\u201d within the configuration specification statement of CDial  of , configuration compiler  would narrow the scope from the default scope of top entity  to FPU entity instantiation . If the entity instantiation indicated by the current field of the identification exists, as shown at block , the process returns to block  after updating the current field to be the next field, as shown at block . If, however, the entity instantiation specified by the current field does not exist within the current scope, configuration compiler  flags an error at block  and terminates processing of the signal or Dial identification.","Referring again to block , when configuration compiler  detects that it has reached the last field of a full expression, the process shown in  passes from block  to block . Block  illustrates configuration compiler  attempting to locate within the current scope the single signal or Dial instance having a name matching that specified in the last field of the signal or Dial identification. If configuration compiler  determines at block  that no matching instance is found within the current scope, the process passes to block , and configuration compiler  flags an error. However, if configuration compiler  locates the matching signal or Dial instance, then configuration compiler  makes an entry in configuration database  binding the signal or Dial instance to the parameters specified in the mapping table of the configuration specification statement of the Dial being processed, as shown at block . Thereafter, processing of the signal or Dial identification terminates at block .","With reference now to block  and following blocks, the processing of a signal or Dial identification employing compact expression will now be described. Block  depicts configuration compiler  attempting to locate, within each of one or more instances in the current scope of the entity indicated by the bracketed field, each Dial or signal instance matching that specified in the signal or Dial identification. For example, when processing the compact expression \u201cFXU.[A].sig\u201d for simulation model \u2032\u2033 of , configuration compiler , upon reaching the field \u201c[A]\u201d, searches FXU for instantiations of entity A , and upon finding entity instantiations  and , searches within each of these two entity instantiations to locate signals instantiations sig  and . If configuration compiler  determines at block  that no matching signal or Dial instance is found within the current scope, the process passes to block , which depicts configuration compiler  terminating processing of the signal or Dial identification after flagging an error. However, if configuration compiler  locates one or more matching signal or Dial instances, then the process passes from block  to block . Block  illustrates configuration compiler  making one or more entries in configuration database  binding each matching signal or Dial instance to the parameters specified in the mapping table of the configuration specification statement of the Dial being processed. Thereafter, processing of the signal or Dial identification terminates at block .","Utilizing the compact expressions supported by the present invention, the amount of code a designer must enter in a configuration specification statement can be advantageously reduced. The use of compact expressions not only reduces input requirements and the likelihood of input errors, but also simplifies code maintenance through the automatic application of specified configuration parameters to later entered instances of signals and Dials falling within a selected scope.","As described above, every Dial has a one-to-one mapping between each of its input values and a unique output value of the Dial. In other words, each input value has a unique output value different than the output value for any other input value. For CDials and LDials, the mapping table must explicitly enumerate each legal input value and its associated mapping.","The requirement that the input values must be explicitly enumerated in the mapping table limits the overall complexity of any given LDial or CDial. For example, consider the case of an integrated circuit (e.g., a memory controller) containing 10 to 20 configuration registers each having between 5 and 20 legal values. In many cases, these registers have mutual dependencies\u2014the value loaded in one register can affect the legal possibilities of one or more of the other registers. Ideally, it would be convenient to specify values for all of the registers utilizing a Dial tree controlled by a single CDial. In this manner, the configuration of all of the 10 to 20 registers could be controlled as a group.","Unfortunately, given the assumptions set forth above, the 10 to 20 registers collectively may have over 300,000 legal combinations of values. The specification of a CDial in such a case, although theoretically possible, is undesirable and practically infeasible. Moreover, even if a looping construct could be employed to automate construction of the configuration specification statement of the CDial, the configuration specification statement, although informing simulation software which input values are legal, would not inform users how to set a CDial of this size.","In recognition of the foregoing, the configuration specification language of the present invention provides a \u201cDial group\u201d construct. A Dial group is a collection of Dials among which the designer desires to create an association. The runtime APIs utilized to provide Dial input values observe this association by preventing the individual Dials within a Dial group from being set individually. In other words, all Dials in a Dial group must be set at the same time so that individual Dials are not set independently without concern for the interactions between Dials. Because software enforces an observance of the grouping of the Dials forming a Dial group, use of Dial groups also provides a mechanism by which a designer can warn the \u201cdownstream\u201d user community that an unstated set of interdependencies exists between the Dials comprising the Dial group.","With reference now to , there is illustrated a diagrammatic representation of a Dial group . A Dial group is defined by a group name  (e.g., \u201cGroupG\u201d) and a Dial list  listing one or more Dials or other Dial groups. Dial groups do not have any inputs or outputs. The Dials listed within Dial list , which are all top-level Dials \u2013, may be LDials, CDials and\/or IDials.",{"@attributes":{"id":"p-0133","num":"0135"},"figref":"FIG. 11A","b":["1100","1100","1100","1104","1110","1110","1110","1110"],"i":["a ","b","n ","g","k ","m","r "]},"One motivation for implementing Dial groups hierarchically is to coordinate configuration of groups of Dials spanning organizational boundaries. For example, consider a digital system in which 30 Dials logically belong in a Dial group and 10 of the Dials are contained within a first design entity that is the responsibility of a first designer and 20 of the Dials are contained within a second design entity that is the responsibility of a second designer. Without a hierarchical Dial group, a single Dial group explicitly listing all 30 Dials in its Dial list  would have to be specified at a higher level of the design hierarchy encompassing both of the first and second design entities. This implementation would be inconvenient in that the designer (or design team) responsible for the higher-level design entity would have to know all of the related Dials in the lower-level design entities and specifically identify each of the 30 Dials in the Dial list  of the Dial group.","An alternative hierarchical approach would entail creating a first Dial group containing the 10 Dials within the first design entity, a second Dial group containing the 20 Dials within the second design entity, and a third higher-level Dial group that refers to the first and second Dial groups. Importantly, the Dial list  of the higher-level Dial group must only refer to the two lower-level Dial groups, thus shielding designers responsible for higher levels of the design hierarchy from low-level details. In addition, code maintenance is reduced since changing which Dials belong to the two lower-level Dial groups would not affect the Dial list  of the upper-level Dial group.","Dial groups are subject to a number of rules. First, no Dial or Dial group may be listed in the Dial list  of more than one Dial group. Second, a Dial group must refer to at least one Dial or other Dial group in its Dial list . Third, in its Dial list , a Dial group can only refer to Dials or Dial groups within its scope, which by convention (and like the concept of scope as applied to Dials) is that of its associated design entity (i.e., the design entity itself and any lower level design entity within the design entity). Fourth, each Dial referred to in a Dial list  of a Dial group must be a top-level Dial.","Referring now to , there is depicted an exemplary simulation model  illustrating the use of Dial groups. Exemplary simulation model  includes a top-level design entity  having instantiation identifier \u201cTOP:TOP\u201d. Within top-level design entity , two design entities  and  are instantiated, which have entity names FBC and L, respectively. FBC entity instantiation  in turn instantiates a Dial instance  having Dial name \u201cC\u201d, a Z entity instantiation  containing a Dial instance  having Dial name \u201cB\u201d, and two instantiations of entity X , which are respectively named \u201cX\u201d and \u201cX\u201d. Each entity X instantiation  contains two entity Y instantiations , each further instantiating a Dial instance  having Dial name \u201cA\u201d. L entity instantiation  contains a Dial instance  having Dial name \u201cD\u201d and two entity L instantiations , each containing a Dial instance  having Dial name \u201cE\u201d.","As shown, FBC entity instantiation  has an associated Dial group instance  having a group name \u201cF\u201d. As indicated by arrows, Dial group instance  includes each of Dials instances ,  and  within FBC entity instantiation . L entity instantiation  similarly has an associated Dial group instance  that includes each of Dial instances  and  within L entity instantiation . Both of these Dial group instances in turn belong to a higher-level Dial group instance  having group name \u201cH\u201d, which is associated with top-level design entity .","Each Dial group instance is created by including within the HDL file of the associated design entity an appropriate configuration statement. For example, exemplary syntax for configuration statements creating Dial groups \u201cF\u201d, \u201cG\u201d and \u201cH\u201d are respectively given as follows:",{"@attributes":{"id":"p-0140","num":"0142"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"GDial F(C, [Z].B, [Y].A);"]},{"entry":[{},"GDial G(D, [L].E);"]},{"entry":[{},"GDial H(FBC.F, L2.G);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In each configuration statement, a Dial group is declared by the keyword \u201cGDial\u201d, which is followed by string (e.g., \u201cF\u201d) representing the group name. Within the parenthesis following the group name, the Dial list for the Dial group is specified. As indicated in the configuration statement for Dial group \u201cH\u201d, the Dial list for a hierarchical Dial group specifies other Dial groups in the same manner as Dials. It should also be noted that the compact dial expression syntax discussed above can be employed in specifying Dials or Dial groups in the Dial list, as indicated in the configuration statements for Dial groups \u201cF\u201d and \u201cG\u201d. In addition, default values may be applied to a Dial group by specifying a default value for each top-level Dial included in the Dial group.","Now that basic types of Dials, syntax for their specification, and the application and Dial groups have been described, a description of an exemplary implementation of configuration database  and its use will be provided. To promote understanding of the manner in which particular Dial instantiations (or multiple instantiations of a Dial) can be accessed in configuration database , a nomenclature for Dials within configuration database  will be described.","The nomenclature employed in a preferred embodiment of the present invention first requires a designer to uniquely name each Dial specified within any given design entity, i.e., the designer cannot declare any two Dials within the same design entity with the same Dial name. Observing this requirement prevents name collisions between Dials instantiated in the same design entity and promotes the arbitrary re-use of design entities in models of arbitrary size. This constraint is not too onerous in that a given design entity is usually created by a specific designer at a specific point in time, and maintaining unique Dial names within such a limited circumstance presents only a moderate burden.","Because it is desirable to be able to individually access particular instantiations of a Dial entity that may have multiple instantiations in a given simulation model (e.g., due to replication), use of a Dial name alone is not guaranteed to uniquely identify a particular Dial entity instantiation in a simulation model. Accordingly, in a preferred embodiment, the nomenclature for Dials leverages the unique instantiation identifier of the associated design entity required by the native HDL to disambiguate multiple instances of the same Dial entity with an \u201cextended Dial identifier\u201d for each Dial within the simulation model.","As an aside, it is recognized that some HDLs do not strictly enforce a requirement for unique entity names. For example, conventional VHDL entity naming constructs permit two design entities to share the same entity name, entity_name. However, VHDL requires that such identically named entities must be encapsulated within different VHDL libraries from which a valid VHDL model may be constructed. In such a circumstance, the entity_name is equivalent to the VHDL library name concatenated by a period (\u201c.\u201d) to the entity name as declared in the entity declaration. Thus, pre-pending a distinct VHDL library name to the entity name disambiguates entities sharing the same entity name. Most HDLs include a mechanism such as this for uniquely naming each design entity.","In a preferred embodiment, an extended Dial identifier that uniquely identifies a particular instantiation of a Dial entity includes three fields: an instantiation identifier field, a design entity name, and a Dial name. The extended Dial identifier may be expressed as a string in which adjacent fields are separated by a period (\u201c.\u201d) as follows:\n\n","In the extended Dial identifier, the design entity field contains the entity name of the design entity in which the Dial is instantiated, and the Dial name field contains the name declared for the Dial in the Dial configuration specification statement. As described above, the instantiation identifier specified in the instantiation identifier field is a sequence of instantiation identifiers, proceeding from the top-level entity of the simulation model to the direct ancestor design entity of the given Dial instance, with adjacent instance identifiers separated by periods (\u201c.\u201d). Because no design entity can include two Dials of the same name, the instantiation identifier is unique for each and every instance of a Dial within the model.","The uniqueness of the names in the design entity name field is a primary distinguishing factor between Dials. By including the design entity name in the extended Dial identifier, each design entity is, in effect, given a unique namespace for the Dials associated with that design entity, i.e., Dials within a given design entity cannot have name collisions with Dials associated with other design entities. It should also be noted that it is possible to uniquely name each Dial by using the instantiation identifier field alone. That is, due to the uniqueness of instantiation identifiers, Dial identifiers formed by only the instantiation identifier field and the Dial name field will be necessarily unique. However, such a naming scheme does not associate Dials with a given design entity. In practice, it is desirable to associate Dials with the design entity in which they occur through the inclusion of the design entity field because all the Dials instantiations can then be centrally referenced without the need to ascertain the names of all the design entity instantiations containing the Dial.","As noted above, use of extended Dial identifiers permits the unique identification of a particular instantiation of a Dial and permits the re-use of design entities within any arbitrary model without risk of Dial name collisions. For example, referring again to , Dial A entity instantiations , ,  and  can be respectively uniquely identified by the following extended Dial identifiers:",{"@attributes":{"id":"p-0150","num":"0153"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FBC.X0.Y0.Y.A"]},{"entry":[{},"FBC.X0.Y1.Y.A"]},{"entry":[{},"FBC.X1.Y0.Y.A"]},{"entry":[{},"FBC.X1.Y1.Y.A"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"With an understanding of a preferred nomenclature of Dials, reference is now made to , which is a diagrammatic representation of an exemplary format for a configuration database  created by configuration compiler . In this exemplary embodiment, configuration database  includes at least four different types of data structures: Dial definition data structures (DDDS) , Dial instance data structures (DIDS) , latch data structures  and top-level pointer array . Configuration database  may optionally include additional data structures, such as Dial pointer array , latch pointer array , instance pointer array  and other data structures depicted in dashed-line illustration, which may alternatively be constructed in volatile memory when configuration database  is loaded, as described in the above-referenced application. Generating these additional data structures only after configuration database  is loaded into volatile memory advantageously promotes a more compact configuration database .","A respective Dial definition data structure (DDDS)  is created within configuration database  for each Dial or Dial group in the digital system. Preferably, only one DDDS  is created in configuration database  regardless of the number of instantiations of the Dial (or Dial group) in the digital system. As discussed below, information regarding particular instantiations of a Dial described in a DDDS  is specified in separate DIDSs .","As shown, each DDDS  includes a type field  denoting whether DDDS  describes a Dial or Dial group, and if a Dial, the type of Dial. In one embodiment, the value set for type field  includes \u201cG\u201d for Dial group, \u201cI\u201d for integer Dial (IDial), \u201cL\u201d for latch Dial (LDial), and \u201cC\u201d for control Dial (CDial). DDDS  further includes a name field , which specifies the name of the Dial or Dial group described by DDDS . This field preferably contains the design entity name of the Dial (or Dial group), followed by a period (\u201c.\u201d), followed by the name of Dial (or Dial group) given in the configuration specification statement of the Dial (or Dial group). The contents of name field  correspond to the design entity name and Dial name fields of the extended dial identifier for the Dial.","DDDS  also includes a mapping table  that contains the mapping from the input of the given Dial to its output(s), if required. For LDials and CDials, mapping table  specifies relationships between input values and output values much like the configuration specification statements for these Dials. For Dial groups and IDials not having a split output, mapping table  is an empty data structure and is not used. In the case of an IDial with a split output, mapping table  specifies the width of the replicated integer field and the number of copies of that field. This information is utilized to map the integer input value to the various copies of the integer output fields. If the configuration specification statement for the Dial has a default specified, DDDS  indicates the default value in default field ; if no default is specified, default field  is NULL or is omitted.","Finally, DDDS  may include an instance pointer array  containing one or more instance pointers \u2013pointing to each instance of the Dial or Dial group defined by the DDDS . Instance pointer array  facilitates access to multiple instances of a particular Dial or Dial group.","As further illustrated in , configuration database  contains a DIDS  corresponding to each Dial instantiation or Dial group instantiation within a digital design. Each DIDS  contains a definition field  containing a definition pointer  pointing to the DDDS  of the Dial for which the DIDS  describes a particular instance. Definition pointer  permits the Dial name, Dial type and mapping table of an instance to be easily accessed once a particular Dial instance is identified.","DIDS  further includes a parent field  that, in the case of an IDial, CDial or LDial, contains a parent pointer  pointing to the DIDS  of the higher-level Dial instance, if any, having an output logically connected to the input of the corresponding Dial instance. In the case of a Dial group, parent pointer  points to the DIDS  of the higher-level Dial group, if any, that hierarchically includes the present Dial group. If the Dial instance corresponding to a DIDS  is a top-level Dial and does not belong to any Dial group, parent pointer  in parent field  is a NULL pointer. It should be noted that a Dial can be a top-level Dial, but still belong to a Dial group. In that case, parent pointer  is not NULL, but rather points to the DIDS  of the Dial group containing the top-level Dial.","Thus, parent fields  of the DIDSs  in configuration database  collectively describe the hierarchical arrangement of Dial entities and Dial groups that are instantiated in a digital design. As described in the above-referenced application, the hierarchical information provided by parent fields  advantageously enables a determination of the input value of any top-level Dial given the configuration values of the configuration latches ultimately controlled by that top-level Dial.","Instance name field  of DIDS  gives the fully qualified instance name of the Dial instance described by DIDS  from the top-level design entity of the digital design. For Dial instances associated with the top-level entity, instance name field  preferably contains a NULL string.","Finally, DIDS  includes an output pointer array  containing pointers \u2013pointing to data structures describing the lower-level instantiations associated with the corresponding Dial instance or Dial group instance. Specifically, in the case of IDials and LDials, output pointers  refer to latch data structures  corresponding to the configuration latches coupled to the Dial instance. For non-split IDials, the configuration latch entity referred to by output pointer receives the high order bit of the integer input value, and the configuration latch entity referred to by output pointer receives the low order bit of the integer input value. In the case of a CDial, output pointers  refer to other DIDSs  corresponding to the Dial instances controlled by the CDial. For Dial groups, output pointers  refer to the top-level Dial instances or Dial group instances hierarchically included within the Dial group instance corresponding to DIDS .","Configuration database  further includes a respective latch data structure  for each configuration latch in simulation executable model  to which an output of an LDial or IDial is logically coupled. Each latch data structure  includes a parent field  containing a parent pointer  to the DIDS  of the LDial or IDial directly controlling the corresponding configuration latch. In addition, latch data structure  includes a latch name field  specifying the hierarchical latch name, relative to the entity containing the Dial instantiation identified by parent pointer . For example, if an LDial X having an instantiation identifier a.b.c refers to a configuration latch having the hierarchical name \u201ca.b.c.d.latch1\u201d, latch name field  will contain the string \u201cd.latch1\u201d. Prepending contents of an instance name field  of the DIDS  identified by parent pointer  to the contents of a latch name field  thus provides the fully qualified name of any instance of a given configuration latch configurable utilizing configuration database .","Still referring to , as noted above, configuration database  includes top-level pointer array , and optionally, Dial pointer array  and latch pointer array . Top-level pointer array  contains top-level pointers  that, for each top-level Dial and each top-level Dial group, points to an associated DIDS  for the top-level entity instance. Dial pointer array  includes Dial pointers  pointing to each DDDS  in configuration database  to permit indirect access to particular Dial instances through Dial and\/or entity names. Finally, latch pointer array  includes latch pointers  pointing to each latch data structure  within configuration database  to permit easy access to all configuration latches.","Once a configuration database  is constructed, the contents of configuration database  can be loaded into volatile memory, such as system memory  of data processing system  of , in order to appropriately configure a simulation model for simulation. In general, data structures , ,  and  can be loaded directly into system memory , and may optionally be augmented with additional fields, as described in the above-referenced application. However, as noted above, if it is desirable for the non-volatile image of configuration database  to be compact, it is helpful to generate additional data structures, such as Dial pointer array , latch pointer array  and instance pointer arrays , in the volatile configuration database image in system memory .","Referring now to , there is depicted a high level logical flowchart of a method by which configuration database  is expanded within volatile memory of a data processing system, such as system memory  of data processing system . Because  depicts logical steps rather than operational steps, it should be understood that many of the steps illustrated in  may be performed concurrently or in a different order than that shown.","As illustrated, the process begins at block  and then proceeds to block , which illustrates data processing system  copying the existing data structures within configuration database  from non-volatile storage (e.g., disk storage or flash memory) into volatile system memory . Next, at block , a determination is made whether all top-level pointers  within top-level pointer array  of configuration database  have been processed. If so, the process passes to block , which is discussed below. If not, the process proceeds to block , which illustrates selection from top-level array  of the next top-level pointer  to be processed.","A determination is then made at block  of whether or not parent pointer  within the DIDS  identified by the selected top-level pointer  is a NULL pointer. If not, which indicates that the DIDS  describes a top-level Dial belonging to a Dial group, the process returns to block , indicating that the top-level Dial and its associated lower-level Dials will be processed when the Dial group to which it belongs is processed.","In response to a determination at block  that the parent pointer  is a NULL pointer, data processing system  creates an instance pointer  to the DIDS  in the instance array  of the DDDS  to which definition pointer  in definition field  of DIDS  points, as depicted at block . Next, at block , data processing system  creates a Dial pointer  to the DDDS  of the top-level Dial within Dial pointer array , if the Dial pointer  is not redundant. In addition, as shown at block , data processing system  creates a latch pointer  within latch pointer array  pointing to each latch data structure , if any, referenced by an output pointer  of the DIDS  of the top-level Dial. As shown at block , each branch at each lower level of the Dial tree, if any, headed by the top-level Dial referenced by the selected top-level pointer  is then processed similarly by performing the functions illustrated at block \u2013 until a latch data structure  terminating that branch is found and processed. The process then returns to block , representing the processing of each top-level pointer  within top-level pointer array .","In response to a determination at block  that all top-level pointers  have been processed, the process illustrated in  proceeds to block . Block  illustrates the creation of a Set field  in each DIDS  in the configuration database. Set field  is a Boolean-valued field that in initialized to FALSE and is updated to TRUE when the associated Dial instance is explicitly set. In addition, as depicted at block , data processing system  creates a latch value field  and latch set field  in each latch data structure  to respectively indicate the current set value of the associated configuration latch and to indicate whether the configuration latch has been explicitly set. Although the creation of the three fields indicated at block \u2013 is illustrated separately from the processing depicted at blocks \u2013 for purposes of clarity, it will be appreciated that it is more efficient to create Dial set field  as each DIDS  is processed and to create latch value and latch set fields ,  as the latch data structures  at the bottom of each Dial tree are reached. The process of loading the configuration database into volatile memory thereafter terminates at block .","With the configuration database loaded into volatile memory, a simulation model can be configured and utilized to simulate a digital design through the execution of simulation software. With reference now to , there is illustrated a block diagram depicting the contents of system memory  () during a simulation run of a simulation model. As shown, system memory  includes a simulation model , which is a logical representation of the digital design to be simulated, as well as software including configuration APIs , a simulator  and an RTX (Run Time eXecutive) .","Simulator  loads simulation models, such as simulation model , into system memory . During a simulation run, simulator  resets, clocks and evaluates simulation model  via various APIs . In addition, simulator  reads values in simulation model  utilizing GETFAC API  and writes values to simulation model  utilizing PUTFACAPI . Although simulator  is implemented in  entirely in software, it will be appreciated in what follows that the simulator can alternatively be implemented at least partially in hardware.","Configuration APIs  comprise software, typically written in a high level language such as C or C++, that support the configuration of simulation model . These APIs, which are dynamically loaded by simulator  as needed, include a first API that loads configuration model  from non-volatile storage and expands it in the manner described above with reference to  to provide a memory image of configuration database . Configuration APIs  further include additional APIs to access and manipulate configuration database , as described in detail below.","RTX  controls simulation of simulation models, such as simulation model . For example, RTX  loads test cases to apply to simulation model . In addition, RTX  delivers a set of API calls to configuration APIs  and the APIs provided by simulator  to initialize, configure, and simulate operation of simulation model . During and after simulation, RTX  also calls configuration APIs  and the APIs provided by simulator  to check for the correctness of simulation model  by accessing various Dials, configuration latches, counters and other entities within simulation model .","RTX  has two modes by which it accesses Dials instantiated within simulation model : interactive mode and batch mode. In interactive mode, RTX  calls a first set of APIs to read from or write to one or more instances of a particular Dial within configuration database . The latch value(s) obtained by reference to configuration database  take immediate effect in simulation model . In batch mode, RTX  calls a different second set of APIs to read or write instantiations of multiple Dials in configuration database  and then make any changes to simulation model  at the same time.","In either interactive or batch mode, RTX  must employ some syntax in its API calls to specify which Dial or Dial group instances within simulation model  are to be accessed. Although a number of different syntaxes can be employed, including conventional regular expressions employing wildcarding, in an illustrative embodiment the syntax utilized to specify Dial or Dial group instances in API calls is similar to the compact expression hereinbefore described. A key difference between the compact expressions discussed above and the syntax utilized to specify Dial or Dial group instances in the RTX API calls is that, in the illustrative embodiment, Dial and Dial group instances are specified in the RTX API calls by reference to the top-level design entity of simulation model  rather than relative to the design entity in which the Dial or Dial group is specified.","In the illustrative embodiment, each RTX API call targeting one or more Dial or Dial group instances in simulation model  specifies the Dial or Dial group instances utilizing two parameters: an instance qualifier and a dialname qualifier. To refer to only a single Dial or Dial group instantiation, the instance qualifier takes the form \u201ca.b.c.d\u201d, which is the hierarchical instantiation identifier of the design entity in which the single Dial or Dial group instantiation occurs. To refer to multiple Dial or Dial group instances, the instance qualifier takes the form \u201ca.b.c.[X]\u201d, which identifies all instantiations of entity X within the scope of entity instance a.b.c. In the degenerate form, the instance qualifier may simply be \u201c[X]\u201d, which identifies all instantiations of entity X anywhere within simulation model .","The dialname qualifier preferably takes the form \u201cEntity.dialname\u201d, where \u201cEntity\u201d is the design entity in which the Dial or Dial group is instantiated and \u201cdialname\u201d is the name assigned to the Dial or Dial group in its configuration specification statement. If bracketed syntax is employed to specify the instance qualifier, the \u201cEntity\u201d field can be dropped from the dialname qualifier since it will match the bracketed entity name.","As noted above, when a user accesses Dials controlling simulation model  via configuration APIs  (or accesses a hardware configuration database  describing a hardware realization of a digital design as disclosed in the above-referenced application), it is useful in diagnosing logical failures or simply understanding system operation if the Dials have designer-defined links between them. Such links thus provide a way for a designer to express arbitrary relationships between Dials.","Referring now to , there is illustrated a diagrammatic representation of an exemplary simulation model  that may be utilize to represent a digital design (e.g., an integrated circuit chip or a computer system) in which configuration constructs, such as Dials, are related by links in accordance with a preferred embodiment of the present invention. As can be seen by comparison of  to , simulation model  has the same design entities and Dials arranged in the same hierarchical arrangement as simulation model \u2032\u2033 of . However, in , a designer has also created a link  from LDial  to LDial and a link  to LDial . Several attributes of links are illustrated by links  and .","First, links are preferably independent entities, like Dials, Dial groups, and design entities, and, as such, are instantiated at a particular level in the design hierarchy. For example, links  and  are instantiated at the top level of the design hierarchy within top-level design entity . In a preferred embodiment, links can reference any Dial (or Dial group) instance contained within the design entity containing the link.","Second, links may have an associated type. In the illustrated embodiment, each of links  and  is of the type \u201cdefault\u201d. As will be appreciated, designers may define any number of link types to facilitate analysis, processing, and manipulation of configuration constructs related by links of selected types. If no type is specified for a link, the link is, by convention, of type \u201cdefault\u201d. To reduce input, it is preferred is the default type if represented by a NULL string.","Third, a link defines a relationship between configuration construct (e.g., Dial or Dial group) instances, not between abstract Dial or Dial group definitions. As a consequence, a separate link is preferably defined for each instance pair, rather than a single \u201clink\u201d for all instances of a particular Dial or Dial group. Thus, although LDials and are instances of the same LDial, a respective one of links  and  is defined for each of LDials and ","Fourth, as represented by the arrows, links define a logical ordering between configuration construct instances, such as Dial and Dial group instances. For example, in , link  indicates that LDial  logically precedes LDial , and link  indicates that LDial  logical precedes LDial . This logical ordering can infer a causative relationship (i.e., the setting of LDial  and its underlying latch  will cause a particular setting of LDial and\/or its underlying latch(es)  and\/or ), a chronological relationship (i.e., LDial  should be set prior to LDial ), or some other relationship inferred by the type of the link.","A number of different syntaxes can be employed to instantiate links , . In an exemplary embodiment, the following configuration specification language expressions can be included within the HDL file of top-level entity  to instantiate links , :",{"@attributes":{"id":"p-0184","num":"0187"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"--## Fpu0.busratio.LINK(fxu0.busratio);"]},{"entry":[{},"--## Fpu0.busratio.LINK(fxu1.busratio);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0185","num":"0188"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"--## Fpu0.busratio.LINK(fxu0.busratio, fxu1.busratio);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":["1502","1504"]},{"@attributes":{"id":"p-0186","num":"0189"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"--## Fpu0.busratio.LINK([FXU].busratio);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":["0","716","302","302","716","712","712"],"i":["a ","b. "]},"In each of the foregoing link declarations, no type is specified. Accordingly, when the link declarations are processed by configuration compiler , the default type, represented by a NULL string, will be assigned to links , , as shown in . If, however, the designer wishes to instantiate a different type of link, the type identifier can be appended to the link declaration as follows:",{"@attributes":{"id":"p-0188","num":"0191"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"--## Fpu0.busratio.LINK([FXU].busratio):type_identifier;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"With reference now to , there is illustrated a diagrammatic representation of a simulation configuration database \u2032 supporting links in accordance with a preferred embodiment of the present invention. As indicated by the use of prime notation (\u2032) and like reference numerals, configuration database \u2032 of  is identical to configuration database  of , with the exception of the addition of a link array  that records links between configuration constructs (e.g., Dials and Dial groups). Link array  is preferably created by configuration compiler  in response to processing configuration specification language link declaration statements during the model build process illustrated in .","As shown in , link array  includes a number of entries  that each corresponds to a respective link entity. Each entry  has three fields: a primary instance field , a secondary instance field , and a type field . Primary instance field  contains a primary instance pointer  pointing to the DIDS  of the configuration construct instance (e.g., Dial instance or Dial group instance) having primary logical ordering. Secondary instance field  similarly contains a secondary instance pointer  pointing to the DIDS  of the configuration construct instance attributed secondary logical ordering by the link. As indicated by its name, type field  stores an indication of the type of the link. If the type is default, type field  preferably contains a NULL string.","Two features of the exemplary embodiment of configuration database \u2032 can be observed in the diagrammatic representation given in . First, as discussed above, links are entities indicating a logical ordering between instances of configuration constructs, not the configuration constructs (e.g., Dials or Dial groups) themselves. Accordingly, primary instance pointer  and secondary instance pointer  point to data structures representative of particular configuration construct instances (i.e., DIDS ) rather than data structures defining the configuration constructs (i.e., DDDS ). Second, each entry  within link array  preferably corresponds to a single link. This arrangement facilitates processing of entries  according to link type.","It should also be noted that that link array  created by configuration compiler  within configuration database \u2032 will also be present within any hardware configuration database created from configuration database , for example, utilizing the database transformation process illustrated in  of the above-referenced patent application. The resulting hardware configuration database may then be accessed to analyze the operation of a hardware realization of the digital design.","Referring now to , there is depicted a high level logical flowchart of an exemplary Application Programming Interface (API) routine that may be utilized to locate within link array  the first link of a given type associated with a particular configuration construct instance. The illustrated API routine may be utilized to access a link array  within either a simulation configuration database or a hardware configuration database.","As shown, the process begins at block , which illustrates the API routine receiving a first_link API call that indicates an instance identifier of a configuration construct instance, as well as a link type (which may be the default NULL string). Next, at block , the API routine enters a processing loop in which the API routine processes entries  within link array  until all entries  are processed or the indicated link type for the indicated configuration construct instance is located. If the API routine processes all entries  within link array  without locating the indicated link type for the indicated configuration construct instance, the process passes to block . Block  depicts the API setting a static link array pointer to NULL to indicate that link array  does not contain any entry  for a link of the indicated type for the indicated configuration construct instance. Thereafter, the API routine returns an empty result set and terminates at block .","Referring again to block , if the API routine determines that fewer than all entries  within link array  have been processed, the process proceeds to block . Block  illustrates the API routing selecting the DIDS  pointed to by the primary instance pointer  within the next entry  of link array . Next, at block , the API routine then forms the instance identifier of the configuration construct corresponding to the DIDS  by concatenating the contents of the name field  () of the DDDS  identified by parent pointer  to the contents of instance name field . This instance identifier is then compared to the instance identifier parameter specified in the API call. If the two instance identifiers match, the API routine makes a further determination of whether or not the link type parameter of the API call matches the link type indicated in the type field  of entry  under consideration. If a negative result is obtained for either of the determinations illustrated at block  and , the process shown in  returns to block , which has been described.","If, on the other hand, positive results are obtained for both of the determinations depicted at blocks  and , the API routine returns as a result the instance identifier of the Dial or Dial group instance determined at block , as depicted at block . In addition, as shown at block , the API routine updates the static link array pointer to point to the last processed entry  of link array  and stores the instance identifier and link type specified in the API call. By marking which entry  contains the first \u201chit\u201d for the specified instance identifier and link type, future searches for the same instance identifier and link type can be accelerated, as described further below. Following block , the process illustrated in  terminates at block .","If a call to the first_link API is successful (i.e., it returns a non-null string), a subsequent call can be made to a next_link API routine that locates any subsequent link of the same type that references the same primary configuration construct instance. The next_link API routine preferably receives no input parameters and begins the search of link array  from the entry  following that identified by the static link array pointer created by the first_link API routine. In this manner, subsequent calls to next_link( ) will return successive links of the specified type that reference the given dial instance.","With reference now to , there is depicted a high level logical flowchart of an exemplary embodiment of a next_link API routine in accordance with the present invention. Like the first_link API routine described above, the next_link API routine illustrated in  may be utilized to access a link array  within either a simulation configuration database or a hardware configuration database.","As shown, the process begins at block , which illustrates the API routine receiving a next_link API call that preferably requires no parameters. Next, at block , the API routine determines if the link array pointer is set to NULL. As noted above, the first_link API routine sets the link array pointer to NULL if a specified instance identifier is not found within link array . Accordingly, if a determination is made at block  that the link array pointer is set to NULL, no \u201cnext link\u201d will be present within link array , and the process simply terminates at block . If, on the other hand, the link array pointer is not set to NULL, the process proceeds from block  to block . Block  represents the API routine entering a processing loop in which the API routine processes entries  within link array  following the one identified by the static link array pointer until the last entry  is processed or until a match is found for the link type and instance identifier previously stored at block  of  . If the API routine processes the remaining entries  within link array  without locating the indicated link type for the indicated configuration construct instance, the process passes to block . Block  depicts the API routine setting the static link array pointer to NULL to indicate that link array  does not contain another entry  for a link of the indicated type for the indicated configuration construct instance. Thereafter, the API routine returns an empty result set and terminates at block .","Referring again to block , if the API routine determines that the last entry  within link array  has not yet been processed, the process proceeds to block . Block  illustrates the API routine selecting the DIDS  pointed to by the primary instance pointer  within the next entry  following the one identified by the static link array pointer. Next, at block , the API routine then forms the instance identifier of the configuration construct corresponding to the DIDS  by concatenating the contents of the name field  () of the DDDS  identified by parent pointer  to the contents of instance name field . This instance identifier is then compared to the instance identifier previously stored at block  of . If the two instance identifiers match, the API routine makes a further determination of whether or not the stored link type matches the link type indicated in the type field  of entry  under consideration. If a negative result is obtained for either of the determinations illustrated at block  and , the process shown in  returns to block , which has been described.","If, on the other hand, positive results are obtained for both of the determinations depicted at blocks  and , the API routine returns as a result the instance identifier of the Dial or Dial group instance determined at block , as depicted at block . In addition, as shown at block , the API routine updates the static link array pointer to point to the last processed entry  of link array . By marking which entry  contains the \u201chit\u201d for the specified instance identifier and link type, future calls to the next_link API will locate subsequent matching entries , if any. Following block , the process illustrated in  terminates at block .","As will be appreciated, the configuration construct instance identifiers returned by the first_link and next_link API routines can be further processed by other API routines. For example, a subsequent API routine may create a list of the latches underlying the configuration construct instance represented by a DIDS  identified in an API result by following the output pointers  () in the output pointer array  of the DIDS . Such latch listings may be useful for error tracing, the construction of Dial groups, or other processing by diagnostic software.","As has been described, the present invention provides methods, systems and program products that support the definition and accessing of links between configuration construct instances, such as Dial and Dial group instances, within a digital design. Such links preferably define a logical ordering between the linked instances and have an associated type that allows the designer to indicate a particular relationship between the linked instances.","While the invention has been particularly shown as described with reference to a preferred embodiment, it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention. For example, it will be appreciated that the concepts disclosed herein may be extended or modified to apply to other types of configuration constructs having different rules than the particular exemplary embodiments disclosed herein. In addition, although aspects of the present invention have been described with respect to a computer system executing software that directs the functions of the present invention, it should be understood that present invention may alternatively be implemented as a program product for use with a data processing system. Programs defining the functions of the present invention can be delivered to a data processing system via a variety of signal-bearing media, which include, without limitation, non-rewritable storage media (e.g., CD-ROM), rewritable storage media (e.g., a floppy diskette or hard disk drive), and communication media, such as digital and analog networks. It should be understood, therefore, that such signal-bearing media, when carrying or encoding computer readable instructions that direct the functions of the present invention, represent alternative embodiments of the present invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The novel features believed characteristic of the invention are set forth in the appended claims. However, the invention, as well as a preferred mode of use, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5C"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5D"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 9B"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 11A"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 11B"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 17A"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 17B"}]},"DETDESC":[{},{}]}
