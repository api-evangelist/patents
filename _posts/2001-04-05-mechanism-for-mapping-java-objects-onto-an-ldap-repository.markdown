---
title: Mechanism for mapping Java objects onto an LDAP repository
abstract: A method and apparatus for dynamically storing objects of an object-oriented programming application in a LDAP repository so that useful information from the objects may be read by other applications are disclosed. Embodiments of the method preferably comprise dynamically determining persistent attributes, which are a subset of each object's attributes, for each object being stored and mapping the persistent attributes to LDAP attributes in the LDAP repository. Embodiments of the invention preferably comprise a persistent data manager that is a component of the object-oriented programming application and that acts as an interface to the LDAP repository, storing objects in the LDAP repository when requested. The objects may be Java objects.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07107595&OS=07107595&RS=07107595
owner: Hewlett-Packard Development Company, L.P.
number: 07107595
owner_city: Houston
owner_country: US
publication_date: 20010405
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The invention relates to data storage, and more specifically to standardized storage of object attributes.","Object-oriented programming is a method of programming that pairs programming tasks and data into re-usable chunks known as objects. Each object comprises attributes (i.e., data) that define and describe the object. Java classes are meta-definitions that define the structure and characteristics for groups of objects in object-oriented parlance. Java classes when instantiated create instances of the Java classes and are then considered Java objects. Methods within Java objects are used to get or set attributes of the Java object and to change the state of the Java object. Associated with each method is code that is executed when the method is invoked.","Java objects of an application, when instantiated, are resident within a computer's memory (e.g., ROM). However, when the computer is turned off or restarted, the objects are flushed from the memory. As such, the objects need to be loaded back into the computer's memory in order to be accessed. Consequently, there is a need for the objects and, particularly, the object attributes to be stored in persistent repository.","The Java objects may be stored as basic system files with a flat file structure. Basic systems files are a simple way of storing the Java objects that would be easily accessible to the application from which the Java objects originated. Unfortunately, other applications would need to learn the application's application programming interfaces (\u201cAPIs\u201d) in order to be able to access the object data from the basic system files. Having to learn these APIs is generally a deterrent that would effectively prevent the basic systems files from being usable outside of the originating application.","Storing the Java objects according to a standard protocol would seem to be a necessary improvement. Indeed, there are known methods for serializing Java objects and their attributes and storing them in a Lightweight Directory Access Protocol (\u201cLDAP\u201d) repository. LDAP is an industry standard for storing information into a quickly accessible database. Serializing a Java object comprises converting the Java object's physical memory representation into a string of characters and storing the string of characters in the LDAP repository.","Unfortunately, simply serializing the Java objects and storing them in a LDAP repository does not make the stored Java objects readable or useable by other applications that do not have the same Java object structures. The string of characters has to be converted into the Java object from which it originated in order to be readable. Moreover, serializing the whole Java object necessarily stores attributes that are unimportant to other applications (e.g., attributes that represent internal operations of the Java object).","LDAP does include a plurality of data objects including different types of attributes (e.g., commonName, description, ipHostNumber, host, uidNumber). These LDAP data objects and their attributes, unfortunately, may not directly correspond to an application's Java objects and their attributes. In order to be usable, the LDAP data objects need to be mapped to Java objects. New LDAP data objects and attributes need to be created. If the Java objects are mapped to LDAP data objects, then the Java objects may be stored in a LDAP repository in a manner that is readable and useable by other applications.","A method and apparatus for dynamically storing Java objects in a LDAP repository in a manner useable to other applications are disclosed. According to an embodiment of the invention, a persistent data manager maps certain persistent attributes of Java objects to corresponding LDAP attributes. The certain persistent attributes are preferably chosen as attributes that are of interest to other outside applications. The LDAP attributes are named with a syntax that easily identifies the attributes. The persistent data manager is preferably a software component that executes processes to dynamically determine the persistent attributes of the Java objects as well as the path or distinguished name (\u201cdn\u201d) of the corresponding LDAP attributes. The persistent data manager also preferably uses reflection, a known Java technique, to determine the persistent attribute values. The persistent data manager preferably invokes the LDAP API(s) necessary, either directly or indirectly through a utility class, to read and write the persistent attribute values from and to the LDAP repository.","These and other advantages are achieved by a method for mapping objects onto a lightweight directory access protocol repository, comprising requesting that an object be stored in a lightweight directory access protocol (\u201cLDAP\u201d) repository, wherein the object includes attributes and is used in an object-oriented programming application, retrieving a list of persistent attributes from the object, wherein the persistent attributes are a subset of the attributes and the persistent attributes each comprise a persistent attribute value, determining a path, wherein the path identifies a location in the LDAP repository, retrieving the persistent attribute values from the object, and storing the object in the LDAP repository so that the persistent attributes are stored in a format that is useable to applications other than the object-oriented programming application.","Likewise, these and other advantages are achieved by a method for retrieving objects mapped onto a lightweight directory access protocol repository, comprising, requesting that an object be retrieved from a lightweight directory access protocol (\u201cLDAP\u201d) repository, wherein the object includes attributes and is used in an object-oriented programming application, retrieving a list of persistent attributes from the object, wherein the persistent attributes are a subset of the attributes and the persistent attributes each comprise a persistent attribute value, determining a path, wherein the path identifies a location in the LDAP repository, retrieving the persistent attribute values from the location in the LDAP repository identified by the path, and setting the persistent attributes in the object with the retrieved persistent attribute values.","These and other advantages are also achieved by a computer readable medium containing instructions for mapping objects onto a lightweight directory access protocol repository, by requesting that an object be stored in a lightweight directory access protocol (\u201cLDAP\u201d) repository, wherein the object includes attributes and is used in an object-oriented programming application, retrieving a list of persistent attributes from the object, wherein the persistent attributes are a subset of the attributes and the persistent attributes each comprise a persistent attribute value, determining a path, wherein the path identifies a location in the LDAP repository, retrieving the persistent attribute values from the object, and storing the object in the LDAP repository so that the persistent attributes are stored in a format that is useable to applications other than the object-oriented programming application.","A computer system that supports mapping objects onto a lightweight directory access protocol repository, comprising a lightweight directory access protocol (\u201cLDAP\u201d) repository, a processor that runs an object-orient programming application, wherein the object-oriented programming application generates, an object, wherein the object includes attributes and is used in an object-oriented programming application, a persistent data manager, that acts as a layer between the object and the LDAP repository, wherein the persistent data manager stores the object in the LDAP repository by, retrieving a list of persistent attributes from the object, wherein the persistent attributes are a subset of the attributes and the persistent attributes each comprise a persistent attribute value, determining a path, wherein the path identifies a location in the LDAP repository, retrieving the persistent attribute values from the object, and storing the object in the LDAP repository so that the persistent attributes are stored in a format that is useable to applications other than the object-oriented programming application.","The present invention may be used with computer systems that utilize object-oriented applications and need to store data (e.g., object attributes) in a format that is readable by different applications.  illustrates a computer network system  with which the present invention may be used. The network system  comprises a ServiceControl Manager (\u201cSCM\u201d)  running on a Central Management Server (\u201cCMS\u201d)  and one or more nodes  managed by the SCM on the CMS . Together the one or more nodes  managed by the SCM  make up an SCM cluster . A group of nodes  may be organized as a node group .","The CMS  preferably is an HP-UX 11.x server running the SCM  software. The CMS  includes a memory (not shown), a secondary storage device , a processor , an input device (not shown), a display device (not shown), and an output device (not shown). The memory, a computer readable medium, may include, RAM or similar types of memory, and it may store one or more applications for execution by processor, including the SCM  software. The secondary storage device , a computer readable medium, may include a hard disk drive, floppy disk drive, CD-ROM drive, or other types of non-volatile data storage.","The processor  executes the SCM  software and other application(s), which are stored in memory  or secondary storage , or received from the Internet or other network  in order to provide the functions and perform the methods described in this specification, and the processing may be implemented in software, such as software modules, for execution by the CMS  and modes . In addition to the that described above, the CMS  preferably also comprises a data repository  for the SCM cluster , a web server  that allows web access to the SCM  and a depot  comprising products used in the configuring of nodes, and a I\/UX server .","Referring to , the SCM  preferably supports managing a single SCM cluster  from a single CMS . All tasks performed on the SCM cluster  are initiated on the CMS  either directly or remotely, for example, by reaching the CMS  via a web connection . Therefore, a workstation  at which a user sits may use a web connection  over a network  to the CMS  in order to perform tasks on the SCM cluster . The workstation  preferably comprises a display, a memory, a processor, a secondary storage, an input device and an output device.","The nodes  are preferably HP-UX servers or other servers and they may be referred to as \u201cmanaged nodes\u201d or simply as \u201cnodes\u201d. The concept of a node  is that it represents a single instance of HP-UX running on some hardware. The node  may comprise a memory, a secondary storage device, a processor, an input device, a display device, and an output device.","Although the CMS  is depicted with various components, one skilled in the art will appreciate that this server can contain additional or different components. In addition, although aspects of an implementation consistent with the present invention are described as being stored in memory, one skilled in the art will appreciate that these aspects can also be stored on or read from other types of computer program products or computer-readable media, such as secondary storage devices, including hard disks, floppy disks, or CD-ROMs; a carrier wave from the Internet or other network; or other forms of RAM or ROM. The computer-readable media may include instructions for controlling the CMS  (and\/or the nodes ) to perform a particular method, such as those described herein.","The SCM  is an application preferably programmed in Java that operates in a Java object-oriented environment. The SCM  comprises objects (e.g., Java objects) that provide the functionality of the SCM . In the system , each user, node, node group, role, tool, authorization, user name, node name, and node group name is, for each instance, represented by a single Java object. A role defines the role (e.g., administrator, database manager, web manager, etc.) a user may have on a certain node(s) or node group(s), where each role has one or more tools associated with it that a user with the role may execute. A tool is an executable(s) that performs a process. An authorization defines the node(s) and node group(s) a user is authorized to access and what roles the user has on the authorized node(s) or node group(s).","When the attributes of any of the above (i.e., user, node, node group, etc.) are changed or need to be accessed, the representative object is instantiated and a mutator (e.g., set) or accessor (e.g., get) method of the representative object is invoked. When a new user, node, node group, etc. is added, a new, empty representative object (e.g., a user object, node object, node group object, etc.) is instantiated and its attributes are then populated with the new user's, node's, node group's, etc. attributes.","The SCM  preferably stores these objects in the data repository . The data repository  preferably is a LDAP repository that is maintained in the secondary storage device  of the CMS . Accordingly, the SCM  preferably comprises an embodiment of the present invention, the persistent data manager , as illustrated in . The persistent data manager  is a software component that stores objects  in and reads the stored objects  from the LDAP data repository . Preferably, the LDAP data repository  is password-protected so that only the persistent data manager  may write to the LDAP data repository . The persistent data manager  acts as an interface to the LDAP data repository  for various consumers, such as object managers .","Referring to , in an embodiment of the present invention, a plurality of object managers  corresponding to each type of object (e.g., user, node, node group, etc.) interact with and direct the persistent data manager  to store the objects  in and read the stored objects  from the LDAP data repository . Object managers  preferably are software components that manage the objects , providing access to the objects  to various consumers and instantiating the objects when necessary.","Since objects  are defined by their attributes, the persistent data manager  stores objects  by storing persistent attributes of the objects  in the LDAP data repository . Accordingly, when directed to store an object  in the LDAP data repository , the persistent data manager  stores the persistent attributes in the LDAP data repository . Likewise, when directed to read a stored object  from the LDAP data repository , the persistent data manager  reads the persistent attributes from the LDAP data repository .","The persistent data manager  preferably stores the persistent attributes by mapping the persistent attributes to certain defined LDAP attributes. These LDAP attributes are preferably grouped within LDAP objects (not shown) that correspond to the objects . These LDAP objects and their attributes are defined within the LDAP data repository . In an embodiment of the present invention, the persistent data manager  is responsible for defining, in the LDAP data repository , most of the LDAP attributes and the LDAP objects that correspond to the objects . Some of the LDAP attributes may be standard LDAP attributes that already exist. These LDAP attributes and objects, referred to as persistent data schema, may be defined and created using known LDAP methods for creating LDAP attributes and objects.","The persistent data manager  may map the persistent attributes of the objects  to the LDAP attributes utilizing a simple mapping methodology. For example, the created LDAP attributes may be defined to have the same names as the persistent attributes with a simple prefix (or suffix or other notation) indicating a source (e.g., an organization and an application) from which the persistent attributes originate. For example, a time stamp attribute of an object , named \u201cCreatedTime\u201d may map to a created LDAP attribute named \u201chpmxCreatedTime.\u201d The prefix \u201chpmx\u201d may indicate, for example, that the source organization is Hewlett-Packard Co.\u00ae and the source application is the SCM  (also known as MX or MUXPlex). As noted above, the persistent data manager  may map some of the persistent attributes to existing standard LDAP attributes (e.g., commonName, description, ipHostNumber, host and uidNumber).","The LDAP data repository  preferably includes a standard LDAP directory structure. In an embodiment of the present invention, the persistent data manager  sets up the LDAP data repository , creating a directory structure for the source. For example, a file (e.g., a text file) may be sent to the persistent data manager  describing and defining the source application (e.g., SCM ), which may be used for a main LDAP container, various container names, which may be sub-containers of the source application container and are preferably identified by object types, various LDAP objects, which preferably correspond to the objects  and are organized by the container names, and the LDAP attributes of these LDAP objects, which preferably correspond to the persistent attributes. The persistent data manager  may then parse the above information out of the file and set-up the LDAP data repository , creating the directory structure, the LDAP objects and LDAP attributes, using known, LDAP methods. A LDAP data repository  may be set up in this manner for each application for which it is used.  illustrates an exemplary directory structure or tree of a LDAP data repository  for the SCM  set up at the source organization Hewlett-Packard, Inc.\u00ae.","In the example shown, the LDAP data repository  is accessible via the Internet. Accordingly, the first level of the directory tree is o=hp.com, indicating a web-accessible directory of the Hewlett-Packard, Inc.\u00ae organization. The LDAP data repository  may be directly accessible from the first level of the directory tree. Accordingly, in the example shown, the LDAP data repository  is indicated by the second level named hpmxName=\u201cBMC Data Center.\u201d The LDAP syntax for the second level path or distinguished name (\u201cdn\u201d) is, therefore, dn=hpmxName=BMC Data Center, o=hp.com.","In , the SCM  is referred to by an application commonName (\u201ccn\u201d) \u201cSysMgmt\u201d. Accordingly, a branch of the third level of the directory tree, identifying the source application, is named cn=SysMgmt, indicating that the objects  of the SCM  are stored, as described herein, within the SysMgmt container of the LDAP data repository . In other words, the LDAP objects and attributes to which the attributes of the objects  map are located within the SysMgmt container. The SysMgmt container preferably is password protected so that only the persistent data manager  may write to it. The LDAP syntax for this third level branch path is the distinguished name cn=SysMgmt,hpmxName=BMC Data Center, o=hp.com.","Preferably, the objects  are stored within different containers determined by the type of object . In other words, the LDAP objects and attributes to which the attributes of the objects  map are located within different containers determined by the type of the object . For example, as described above, the SCM  may comprise node, user, node group, tool and role objects. Accordingly, the directory tree shown in  includes a fourth level comprising containers (also known as groupOfNames). The containers shown include the following: cn=NodeContainer (for node objects); cn=UserContainer (for user objects); cn=NodeGroupContainer (for node group objects); cn=ToolContainer (for tool objects); and, cn=RoleContainer (for role objects). The LDAP syntax for the path of these containers is illustrated by the distinguished name cn=NodeContainer,cn=SysMgmt,hpmxName=BMC Data Center, o=hp.com.","Referring to , the fifth level of the directory tree shown includes specific LDAP objects corresponding to existing objects  that have been stored in the LDAP data repository  (i.e., existing objects  that have had their attributes mapped to LDAP attributes).  illustrates two exemplary objects for each container (i.e., for each object type). For example, the container cn=NodeContainer is shown including LDAP objects cn=hoffman and cn=windcave. These LDAP objects correspond to node objects  named hoffman and windcave. The LDAP syntax for the path of these LDAP objects is illustrated by the distinguished name cn=hoffman,cn=NodeContainer,cn=SysMgmt,hpmxName=BMC Data Center,o=hp.com.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIGS. 4","FIGS. 4"],"i":["a ","b ","a ","b "],"b":["4","40","44","48","44","40","48","26","4","60","62","44","40","64","48","26","66","40","26","68","40","48","70","72","44","48"]},"The LDAP utility class  preferably comprises standard LDAP methods for adding, reading, modifying and deleting LDAP entries (e.g., LDAP objects and attributes) from a LDAP repository. The static structure diagram  also includes a data repository interface  (e.g., MxPersistentDataManagerIfc), as seen in , that may be implemented if the data repository  is not an LDAP repository, but is some other type of repository (e.g., an Oracle\u00ae database). If the data repository  is, for example an Oracle database, the Oracle database preferably implements the MxPersistentDataManagerIfc.","The exemplary static structure diagram  in and include subsets of the methods of the exemplary classes and interfaces illustrated. For example, the PDM implementation class  may include additional methods beyond those shown in . Likewise, the PDM implementation class  may include less or different methods than the methods shown in . Moreover, the names of the methods shown are not crucial to the implementation of the persistent data manager  and different names may be used for the same methods without deviating from the scope of the invention. In other words, the static structure diagram  is exemplary in nature.","The PDM implementation class  preferably comprises private methods, indicated by the \u201c\u2212\u201d in front of the method names, and public methods, indicated by the \u201c+\u201d in front of the method names. The persistent data manager  uses the private methods internally. For example, the \u2212connectToServer( ) method may be invoked by the persistent data manager  to connect to the LDAP data repository . The \u2212connectToServer( ) method, when invoked, may in turn invoke a LDAP utility class  LDAP method +connect( ) to connect to the LDAP data repository . Likewise, a \u2212disconnectFromServer( ) method may be invoked by the persistent data manager  to disconnect from the LDAP data repository  in the same manner. An \u2212authenticateToServer( ) may be used to pass a LDAP data repository  password when the LDAP data repository  is password protected, as described above.","The public methods of the PDM implementation class  are preferably invoked by object managers  in order to store, delete, read, etc. the objects  in the LDAP data repository . Associated with each of these public methods is coding necessary to execute the processes described herein for performing these tasks. As illustrates by the method invocation lines , the object managers  (represented by the object manager utility classes ) invoke a public method of the PDM implementation class  when seeking to store an object  in the LDAP data repository . The public method of the PDM implementation class  in turn uses the objects  (represented by the object implementation classes ), the series of reflection classes , and the LDAP utility class  to determine the names of the objects'  attributes that are supposed to be stored in the LDAP data repository  (i.e., the persistent attributes described above), to reflect the persistent attributes' values and to store the persistent attributes' values in the LDAP data repository . The reading of objects  from the LDAP data repository  is preferably implemented in a similar way, as described below.","As noted above, objects  that are to be stored in the LDAP data repository  preferably implement the persistent object interface . By implementing this persistent object interface , the objects  will return data requested by the \u201cget\u201d methods of the persistent object interface  when the persistent data manager  invokes these get methods. Accordingly, when an invoked public method of the PDM implementation class  uses the objects , as described above and shown in , the persistent data manager  preferably invokes the persistent object interface  get methods shown in . The invoked get methods return data identifying the persistent attributes, as well as data used to determine the LDAP data repository  directory path or dn for the objects  being stored. In other words, the persistent data manager  uses \u201creflection\u201d on the objects  to get the objects  to \u201clook in a mirror\u201d and provide the requested data. Reflection is a known Java technique to determine an object's attributes in this manner.","For example, the getPersistentAttrs( ): String returns a lists of the persistent attributes for the object  to be stored, the getApplicationName( ): String returns a string identifying the source application (e.g., SysMgmt for the SCM ) corresponding to the third level of the directory tree shown in , the getCategoryName( ) String returns a string identifying the container (e.g., Node Group Container) corresponding to the fourth level of the directory tree shown in  and getCommonName( ): String returns a string identifying an attribute of the object  that contains the name of the object . Preferably, the persistent data manager  uses a reflection (represented by a reflection class ) to get the value of this name attribute of the object . The value of this name attribute of the object  (i.e., the name of the object ) corresponds to a LDAP object in the to the fifth level of the directory tree shown in .","The persistent attributes and dn are dynamically determined each time an object  is stored in the LDAP data repository. By dynamically determining the persistent attributes and dn, the persistent data repository can store any object  passed to it. The persistent data manager  may be coded with the persistent attributes of each type of object . However, this would bloat the persistent data manager  with excess code and require that the persistent data manager  be re-coded any time a new object type was created or an existing object type modified (e.g., if additional attributes were added to the persistent attributes for a type of objects ). By dynamically determining the persistent attributes, these disadvantages are avoided.","As noted above, the persistent data manager  uses reflection to retrieve the values of the persistent attributes. Accordingly, invoked public methods, of the PDM implementation class , instantiate the reflection classes  shown in order to reflect these values. Referring again to , the reflection::Field reflection class  represents a reflection used to get the data type of each of the persistent attributes. Accordingly, a getType( ) method is invoked for each certain persistent attribute, with the name of each certain persistent attribute passed with the method invocation, to retrieve the data type of the certain persistent attribute. The data type is needed to avoid exceptions for mismatched data types (e.g., the persistent data manager  gets a String when a Long or Int is expected).","Referring to , the reflection::Method reflection class  represents a reflection used to get method names that are invoked to get or set the persistent attributes of the objects . It is preferably a matter of convention that each of the objects  includes a pair of methods that allow the persistent data manager  to get or set the persistent attributes' values by adding the words \u201cget\u201d or \u201cset\u201d to each persistent attributes' name. Accordingly, a getMethod( ) method is invoked for each certain persistent attribute of an object , with the name of each certain persistent attribute passed with the method invocation, to generate series of get or set method objects (depending on whether a store or read is intended) for all of the persistent attributes. Once the get or set method objects are returned to the persistent data manager , the get or set methods are invoked to get or set the persistent attributes' values from or to the object .","Referring to , the reflection::Array reflection class  represents a reflection used create an array for those persistent attributes that have multiple values (e.g., that are arrays). Since an array is an object in Java, the reflection::Array reflection class  comprises a newInstance( ) method that is invoked to create a new instance of an array object. Invoking the appropriate get or set method may then fill in the instantiated array object. The filled-in array object is passed to the object  or the LDAP data repository, depending on whether a read or store of the object  is intended.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIGS. 5","FIG. 5"],"i":["a ","b ","a"],"b":["5","80","81","48","82","83","84","85","86","87","81","44","62","81","62","62"]},"Requesting that an object be stored  preferably comprises an object manager  requesting that a persistent data manager  store an object . The object manager  may accomplish this by invoking a PDM implementation class  method addEntry( ) (or \u201caddObject\u201d) seen in and passing the object  with the method invocation. When invoked, the addEntry( ) method preferably starts a process to store the object  in the LDAP data repository  and invokes the method steps described below.","Retrieving a list of the object's attributes  is preferably a step in the process started by the addEntry( ) method invocation; retrieving the list of the object's attributes  may be the first step. The list of the object's attributes preferably comprises the names of only those attributes of the object  that are to be stored in the LDAP data repository (i.e., the persistent attributes). Therefore, retrieving the list of the object's attributes  comprises the persistent data manager  retrieving the persistent attributes from the object , preferably by invoking the persistent object interface  method to get the persistent attributes (e.g., getPersistentAttrs( )). As noted above, an object  being stored in the LDAP data repository  preferably implements the persistent object interface  so that this method invocation will return the persistent attributes.","Determining a repository path  comprises determining the path, or dn, in the LDAP data repository  of the LDAP object that corresponds to the object  that is being stored. Since the path, or dn, of the LDAP object is preferably determined from information in the object , determining a repository path  preferably comprises the persistent data manager  retrieving the information from the object . Preferably, the persistent data manager  retrieves this information by invoking persistent object interface  methods to get the application name (e.g., getApplicationName( )), to get the container or category name (e.g., getCategoryName( )), to get the name of the object  (e.g., getCommonName( )).","As discussed above, these methods may actually retrieve the name of an attribute(s) of the object  that contains the object name, container name and\/or application name. In such an implementation, the persistent data manager  may then retrieve the actual name(s) from the attribute(s) using reflection. The path, or dn, in a LDAP data repository  at Hewlett-Packard Co. Inc. may then be determined as dn=cn=CommonName (e.g., hoffman), cn=CategoryName (e.g., NodeContainer), cn=ApplicationName (e.g., SysMgmt), hpmxName=BMC Data Center, o=hp.com. The execution of steps  and  are basically the object  entering a contract with the persistent data manager  to store the persistent attributes at the determined dn in the LDAP data repository , and may be performed in any order (e.g., step  and then step ).","Connecting to the repository  preferably comprises the repository data manager  connecting to the LDAP data repository . The repository data manager  may connect to the LDAP data repository  by invoking an internal connect to server method (e.g., connectToServer( )), which in turn invokes a LDAP utility class constructor method (e.g., LDAPConnection( )) instantiating the LDAP utility class , which in turn invokes a LDAP method (e.g. connect( )) to connect to the LDAP data repository . The connecting step  need not precede all of the following steps, but the connecting step  should precede storing the object in the repository .","Retrieving the object's attribute values  preferably comprises the persistent object manager  getting the value of each persistent attribute of the object  that is being stored. Preferably, the persistent object manager  retrieves the object's attributes' values using the reflection technique, described above with reference to and . For example, the data type of each of the persistent attributes is determined via reflection, a get method object for each of the certain persistent attribute is created via reflection and the get method for each persistent attribute in the object  is invoked, thereby retrieving the value of each persistent attribute. If a persistent attribute is an array, an array object is instantiated and the values are retrieved into the instantiated array object.","Once the persistent attributes of the object  being stored are retrieved, the object  may be stored in the LDAP data repository . The persistent data manager  may map the persistent attributes to LDAP attributes by appending the simple pre-fix (or suffix or other notation) indicating the source onto the persistent attributes' names, as described above. For example, using the prefix described above, a createdBy persistent attribute maps to the LDAP attribute hpmxcreatedBy. Accordingly, storing the object  in the repository  preferably comprises the repository data manager  passing the LDAP object and the dn for the LDAP object by mapping the persistent attributes to LDAP attributes, populating the LDAP attributes with the persistent attributes' value and passing the LDAP attributes and the dn to the LDAP data repository . The persistent data manager  may achieve this by directly invoking a LDAP API or by invoking a LDAP uitlity class  method to add an entry to the LDAP data repository  (e.g., add( )) and passing the LDAP object and dn for the LDAP object with this method invocation. The LDAP utility class  method in turn invokes the LDAP API to store the mapped object  in the LDAP data repository .","As shown in , the method  for reading Java objects from a LDAP repository comprises starting a persistent data manager , requesting that an object  be read , retrieving a list of the object's attributes , determining a repository path , connecting to the repository , retrieving the object's attribute values from the repository  and setting the object's attribute values . Starting a persistent data manager  may be accomplished as described above with reference to ","Requesting that an object  be read  preferably comprises an object manager  requesting that a persistent data manager  retrieve or load the object  from a LDAP data repository . The object manager  may accomplish this by invoking a PDM implementation class  method readEntry( ) (or \u201creadObject\u201d) seen in and passing an empty object  with the method invocation. When invoked, the readEntry( ) method preferably starts a process to read the object  from the LDAP data repository  and invokes the method steps described below.","Retrieving a list of the object's attributes  is preferably a step in the process started by the readEntry( ) method invocation; retrieving the list of the object's attributes  may be the first step in this process. The list of the object's attributes preferably comprises the names of only those attributes of the object  that are stored in the LDAP data repository  (i.e., the persistent attributes). Therefore, retrieving the list of the object's attributes  comprises the persistent data manager  retrieving the persistent attributes from the empty object , preferably by invoking the persistent object interface  method to get the persistent attributes (e.g., getPersustentAttrs( )). As noted above, an object  stored in the LDAP data repository , in this case the empty object , preferably implements the persistent object interface  so that this method invocation will return the persistent attributes.","Determining a repository path  comprises determining the path, or dn, in the LDAP data repository  of the LDAP object that corresponds to the empty object . Since the path, or dn, of the LDAP object is preferably determined from information in the empty object , determining a repository path  preferably comprises the persistent data manager  retrieving the information from the empty object . Preferably, the persistent data manager  retrieves this information by invoking persistent object interface  methods to get the application name (e.g., getApplicationName( )), to get the container or category name (e.g., getCategoryName( )), to get the name of the object  (e.g., getCommonName( )).","As discussed above, these methods may actually retrieve the name of an attribute(s) of the empty object  that contains the object name, container name and\/or application name. In such an implementation, the persistent data manager  may then retrieve the actual name(s) from the attribute(s) using reflection. The path, or dn, in a LDAP data repository  at Hewlett-Packard Co. may then be determined as dn=cn=CommonName (e.g., hoffman), cn=CategoryName (e.g., NodeContainer), cn=ApplicationName (e.g., SysMgmt), hpmxName=BMC Data Center, o=hp.com. The execution of steps  and  are basically the object  entering a contract with the persistent data manager  to read the persistent attributes from the determined dn in the LDAP data repository , and may be performed in any order (e.g., step  and then step ).","Connecting to the repository  may be accomplished as described above with reference to . Referring again to , retrieving the object's attribute values from the repository  preferably comprises the persistent data manager  reading the empty object's  persistent attributes' values from the LDAP data repository . This may comprise the persistent data manager  mapping the persistent attributes to LDAP attributes, as described above, passing the dn for the LDAP object, determined as described above in steps  and , to the LDAP data repository  and populating the mapped persistent attributes with the values of the corresponding LDAP attributes stored in the LDAP data repository . The persistent data manager  may achieve this by directly invoking a LDAP API or by invoking a LDAP uitlity class  method to read an entry from the LDAP data repository  (e.g., read( )) and passing the dn for the LDAP object with this method invocation. The LDAP utility class  method in turn invokes the LDAP API to read the LDAP attributes' values located by the dn from the LDAP data repository .","Once the values of the LDAP attributes corresponding to the persistent attributes of the empty object  have been read from the LDAP data repository , the empty object  may be populated with these values. Setting the object's attribute values  may comprise the persistent data manager  populating the persistent attributes with the LDAP attributes' values. As with the method described above with regard to , Java reflection, or a similar technique, is preferably used to get the data types and method names of the persistent attributes. For setting the object's attribute values , the method names are \u201cset\u201d methods, since the persistent attributes are being set with the LDAP attributes' values. As above, if any of the persistent attributes are arrays, a reflection is preferably used to create an instance of an array object. Once the data types and method names are retrieved, the persistent data manager  preferably invokes the set methods to set each of the persistent attributes of the empty object  and populate the empty object .",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIGS. 6","i":["a ","b "],"b":["6","102","104","106","108"]},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 6","i":"a ","b":["100","48","26","48","26","106","104","102","102","44","40","44","40","48","26","106","44","48","40"]},"The invoked addEntry( ) method in turn invokes a process to store the node group object  in the LDAP data repository . As part of the process, the attributes of the node group object  that are to be stored in the LDAP data repository (e.g., the persistent attributes) are determined. Likewise, the path or dn of the LDAP object to which the node group object  will be mapped is determined. As noted above, the persistent attributes and dn are dynamically determined for each object . The getApplicationName( ), getCategoryName( ), getCommonName( ) and getPersistentAttrs( ) method call-lines  represent methods of the node group object  invoked by the persistent data manager  to dynamically determine the dn and persistent attributes. In response to these method invocations, the node group object  returns the node group object  attributes with the application name (e.g., SysMgmt), the category or container name (e.g., node group container) and the common name of the node group object  (e.g., Oracle Server Group), in order to build the dn, as well as the persistent attributes. As described above, these methods may be persistent object interface  methods implemented by the node group object . The order of execution of these methods may be changed without deviating from the scope of the invention.","Referring again to , a LDAPConnection( ) method call-line  indicates that the persistent data manager  instantiates the LDAP utility class . A getType( ) method call-line  indicates that the persistent data manager  invokes a Reflection::Field class method to get the data type of a node group object  persistent attribute. The data type for each of the persistent attributes is retrieved using reflection. Accordingly, the persistent data manager  repeats the getType( ) method invocation until the data type for each of the persistent attributes is retrieved. The dashed-line pointing from Reflection::Field class time-line  to the PDM implementation class  time-line  indicates that the Reflection::Field class returns control to the persistent data manager .","A getMethod( ) method call-line  indicates that the persistent data manager  invokes a Reflection::Method class method to get a method name of the node group object  get method to retrieve one of the persistent attributes. Method names for get methods to retrieve each of the persistent attributes are retrieved using reflection. Accordingly, the persistent data manager  repeats the getMethod( ) method invocation until the method name for each of the persistent attributes is retrieved.","A getMemberObjects( ) method call-line  indicates that the persistent data manager  invokes the get methods, retrieved above, to get the values of all of the persistent attributes of the node group object . Once all the persistent attributes of the node group object  are retrieved, the persistent data manager  can store the node group object  in the LDAP data repository  by mapping the persistent attributes to corresponding LDAP attributes of a LDAP object. Referring to , an add( ) method call-line  indicates that the persistent data manager  invokes a LDAP utility class  method to add the node group object  to the LDAP data repository . The persistent data manager  passes the mapped persistent attributes' values, and the dn determined above, to the LDAP utility class  with the add( ) method invocation. The LDAP utility class  preferably executes the LDAP API(s) necessary to store the mapped persistent attributes' values in the LDAP data repository .","As shown by the dashed-line labeled add( ) pointing from the LDAP utility class time-line  to the persistent data manager  time-line , and the addEntry( ) dashed-line pointing from the persistent data manager time-line  to the node group manager time-line , the LDAP utility class  returns control to the persistent data manager , which in turn returns control to the node group manager , when the process of storing the node group object  in the LDAP data repository  is complete.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 6","FIG. 6"],"i":["b ","b"],"b":["101","26","48","26","101","100","48","44","62","48","26","106","48","26"]},"As a part of that process, the persistent data manager  invokes the node group  methods to determine the persistent attributes and the dn for the persistent attribute values in the LDAP data repository . The getApplicationName( ), getCategoryName( ), getCommonName( ) and getPersistentAttrs( ) method call-lines  represent these invoked methods. After instantiating LDAP utility class , the persistent data manager  invokes a LDAP utility class  method to read the persistent attribute values from the LDAP data repository . This is indicated by read( ) method call-line . The persistent data manager  preferably passes the dn for the persistent attribute values (i.e., the dn for the LDAP attributes mapped to by the persistent attributes) to the LDAP utility class  with the read( ) method invocation. The LDAP utility class  preferably executes the LDAP API(s) necessary to read the persistent attribute values from the location identified by the dn.","Once the persistent attribute values are retrieved, the persistent data manager  retrieves the data type and method names for persistent attributes, as described above and as indicated by the getType( ) and getMethod( ) method call-lines  shown in . In the process illustrated by the sequence diagram , however, the method names are set methods, since the persistent attributes of the node group object are being populated or set with the persistent attribute values retrieved from the LDAP data repository .","Once the method names for the set methods of the persistent attributes have been retrieved using reflection, the persistent data manager  sets all of the persistent attributes using these set methods and the persistent attribute values retrieved from the LDAP data repository . This is indicated by the setMemberObjects( ) method call line  from the persistent data manager time-line  to the node group time line . Once the persistent attributes of the node group object have been set, the persistent data manager preferably returns control to the node group manager .","The persistent data manager  can perform processes similar to those shown in and for adding and reading different types of Java objects  to and from the LDAP data repository . By dynamically determining the persistent attributes and dn of the objects  and using reflection to determine the values of the persistent attributes, the persistent data manager  maintains the flexibility to handle numerous types of objects .","Some of the objects and classes discussed herein are named with a prefix \u201cmx\u201d. The mx prefix is indicative of the application utilizing the objects and classes (e.g., the SCM ) and is merely exemplary. Indeed, the names of classes, objects and methods discussed herein are exemplary, are not intended to be limiting, and are merely used for ease of discussion.","While the invention has been described with reference to the exemplary embodiments thereof, those skilled in the art will be able to make various modifications to the described embodiments of the invention without departing from the true spirit and scope of the invention. The terms and descriptions used herein are set forth by way of illustration only and are not meant as limitations. Those skilled in the art will recognize that these and other variations are possible within the spirit and scope of the invention as defined in the following claims and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 4","i":["a ","b "],"b":"4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIGS. 5","i":["a ","b "],"b":"5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 6","i":["a ","b "],"b":"6"}]},"DETDESC":[{},{}]}
