---
title: Integrated processor platform supporting wireless handheld multi-media devices
abstract: A direct memory access system consists of a direct memory access controller establishing a direct memory access data channel and including a first interface for coupling to a memory. A second interface is for coupling to a plurality of nodes. And a processor is coupled to the direct memory access controller and coupled to the second interface, wherein the processor configures the direct memory access data channel to transfer data between a programmably selectable respective one or more of the plurality of nodes and the memory. In some embodiments, the plurality of nodes are a digital signal processor memory and a host processor memory of a multi-media processor platform to be implemented in a wireless multi-media handheld telephone.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07089344&OS=07089344&RS=07089344
owner: Motorola, Inc.
number: 07089344
owner_city: Schaumburg
owner_country: US
publication_date: 20000609
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS","Dynamic Memory Refresh Methods"],"p":["The present invention relates to wireless handheld multi-media devices, such as digital telephones, and more specifically to processor platforms in wireless handheld multi-media devices. Even more specifically, the present invention relates to such processor platforms having minimal size and power consumption and that enable efficient data transfers between multiple processors of the processor platform and multiple peripherals.","New standards for digital cellular systems incorporate high speed packet data network capability in addition to traditional circuit switched voice and data channels. At the same time, among the general public, there is wide spread use of the Internet which offers a host of personal communication, information, electronic commerce and entertainment services. The next generation cellular systems offers the opportunity to market wireless products which have voice, data, and personal information management capabilities, i.e. multi-media devices. These products are destined to become portable information appliances with the potential for significant market share.","In such multi-media devices, in particular digital cellular telephones, processor platforms include two main processor cores: a digital signal processor (DSP) core coupled to the radio interface and a host processor core for running the device and coordinating data movements from several peripherals. Such a device may include as peripherals, a Universal Serial Bus (USB), a Universal Asynchronous Receiver\/Transmitter (UART) with an optional mode to support the IrDA standard, a Synchronous Serial Interface (SSI), a Multi-Media Card (MMC), and a Bluetooth interface supporting the Bluetooth standard.","It is desirable to be able to move data to and from the various peripherals and the memory of the host processor, and also to and from the various peripherals and the memory of the DSP, and furthermore, to and from the memory of the DSP and the memory of the host processor. Using a technique known in the art as Direct Memory Access (DMA), such transfers advantageously take place without involving either the host processor or the DSP. Thus, for example, instead of the host processor initiating a data transfer from a particular peripheral to the host processor memory, a DMA controller performs the data transfer, allowing the host processor to focus on more important functions. Advantageously, the DMA technique relieves the host processor and the DSP from the cumbersome tasks of simple data transfers, enabling faster and more efficient use of the processors within the device.","However, a DMA controller forms a hardwired unidirectional data channel between two nodes. The DMA controller is coupled between a particular peripheral and the system bus which accesses both the processor to be relieved of the task of performing the data transfer and it's memory. The DMA controller provides the hardware to implement the direct memory access. Because each data channel is unidirectional, two separate DMA data channels are required for bidirectional data transfers between the two nodes. Furthermore, since each data channel is implemented in hardware, once established, the data channel may not be reconfigured to allow a data transfer to and from different nodes or in a different direction.","Thus, separate unidirectional data channels must be hardwired to allow direct memory access for multiple processors and multiple peripherals. Disadvantageously, in handheld multi-media devices, there may be a large number of peripherals; thus, requiring many DMA controllers to hardwire all of the possible DMA connections. For example, to adequately relieve the host processor and the DSP from having to perform data transfers between the peripherals and the respective memories, DMA controllers must be implemented in hardware between each peripheral and the host processor memory and the DSP memory, such that each DMA controller establishes the desired unidirectional data channels.","Disadvantageously, in small handheld applications, implementing a large number of DMA controllers expends valuable real estate on the processor platform. In other words, the more hardware DMA controllers needed, the more transistors are required on the processor platform and the more space is consumed on the platform by the DMA hardware. What is needed is a processor platform that implements DMA functionality to allow efficient operation of multiple processors without using traditional DMA hardware for all of the various data transfer paths.","Another concern in processor platforms for small handheld multi-media processors is minimizing power consumption. Employing a processor platform without concern for saving power unnecessarily reduces the battery life, which is important in handheld applications because this decreases the time in between battery charges that are required. Furthermore, in multi-media applications which require a large random access memory (RAM), it is desirable to employ dynamic RAM (DRAM) as opposed to static RAM (SRAM), since DRAM is much less costly than SRAM in terms of die size versus array density.","Additionally, embedded DRAM (eDRAM), which is DRAM embedded on the processor platform, may be used to reduce the overall space required by the processor platform. However, in comparison to SRAM, both DRAM and eDRAM must be periodically refreshed in order to ensure that the data contained therein is saved. The refreshing process, typically performed by a refresh controller, consumes valuable power to make sure that data remains stored. What is needed is a method to refresh the DRAM in such a way as to conserve as much power as possible.","Furthermore, in such handheld multi-media devices, such as telephones, liquid crystal displays (LCDs), such as those found in personal digital assistants (PDAs), are implemented to allow the user to readily view web pages, for example. A typical LCD requires data to be moved from the video buffer to the display driver circuit. This presents problems in that the large LCD bus must transmit and receive data from 8, 16, or 32 bit busses from a memory (e.g. eDRAM) that is only 8, 16 or 32 bits wide. Disadvantageously, the LCD controller and image processor of the LCD spend much time using the system memory, as a video buffer, relative to other peripherals and devices that are required to access the system memory for DMA techniques, which makes the system memory less accessible to these other peripherals and devices. Thus, when video images are displayed on the LCD, the system memory (e.g. eDRAM) acts primarily as the video buffer and also as the system RAM. A separate RAM (e.g. another eDRAM) may be implemented to act as the video buffer; however, such additional memory disadvantageously adds to the transistor count and thus size of the processor platform. What is needed is an efficient memory that can adequately support an LCD controller and at the same time be used as a system RAM and for DMA data transfers.","The present invention advantageously addresses the above and other needs.","Corresponding reference characters indicate corresponding components throughout the several views of the drawings.","The following description of the presently contemplated best mode of practicing the invention is not to be taken in a limiting sense, but is made merely for the purpose of describing the general principles of the invention. The scope of the invention should be determined with reference to the claims.","The present invention advantageously addresses the needs above as well as other needs by providing a wireless multimedia processor platform including multiple processor cores, multiple peripherals, and an interprocessor communication module that performs programmable direct memory access functionality for programmably selectable data transfers between the memories of the multiple processor cores and the various peripherals attached thereto. Furthermore, the processor platform includes features that minimize the size and power consumption of the processor platform as well as allow video buffering from the host processor memory to support an LCD display without limiting the ability of other devices to access the host processor memory.","Multi-Media Processor Platform Overview","Referring first to , a high level block diagram is shown of a wireless multimedia processor platform having three processor cores: a digital signal processor (DSP), a host processor, and a RISC processor core within an interprocessor communication module (IPCM), wherein the interprocessor communication module performs programmable direct memory access data transfers. Shown is a multimedia processor platform  including a digital signal processor  (also referred to as DSP ), a random access memory  (also referred to as RAM, DSP memory or DSP RAM), a host processor  (also referred to as host  or MCore), an embedded dynamic random access memory  (also referred to as eDRAM  or host processor memory), a Universal Serial Bus  (also referred to as USB ), a Universal Asynchronous Receiver\/Transmitter  with an optional mode to support the IrDA standard (also referred to as UART\/IrDA ), a Multi-Media Card  (also referred to as MMC ), and an interprocessor communication module  (also referred to as IPCM ).","The multimedia processor platform , which may also be referred to as a processor platform  or simply processor , is in the form of a single integrated circuit or chip having three processor cores: the DSP , the host processor , and a RISC processor core within the IPCM . The processor  represents a \u201csystem on a chip\u201d design (also referred to as \u201cSOC\u201d). In the application of a wireless handheld multimedia devices, it is advantageous that the components of the processor  all appear on a single chip. This is because of the size constraints in the handheld applications and also due to the fact that separate processors on separate chips must be hardwired together which may result in losses from wiring chip to chip. However, it is important to note that the present invention is not limited to a system on a chip design, and thus, the three processor cores, i.e. the DSP , the host processor , and RISC processor core of the IPCM , may be implemented on separate chips if so desired in another application.","In operation, the IPCM  couples all three of the DSP portion (i.e the DSP  and RAM ), the host portion (i.e. the host processor  and the eDRAM ) and the peripherals (i.e. the USB , the UART\/IrDA , and the MMC ) together. Advantageously, the IPCM  provides programmable direct memory access (DMA) data channels to allow direct memory access data transfers (1) from a particular peripheral to either the DSP RAM  or the eDRAM , (2) from the DSP RAM  or the eDRAM  to a particular peripheral, and (3) between the DSP RAM  and the eDRAM . These DMA data transfers may be time coordinated (occurring at predetermined times) or event coordinated (occurring upon request or instruction). The IPCM  has a reduced instruction set computer (RISC) processor core that enables direct memory access (DMA) data transfers over programmably selectable DMA data channels. For example, the IPCM  replaces a large number of hardware DMA controllers to create, for example, 32 programmable data channels, wherein each data channel may be programmed to transfer data in any one of the three directions above. An equivalent hardware DMA implementation generally would require 2*n*(c+1) individual DMA data hardware controllers, where the number 2 represents data channels in two directions, n represents the number of data channels and c represents the number of processors capable of using the IPCM , such that c+1 is the number of data paths. In the embodiment shown, n=32, c=2 (i.e. the DSP  and the host processor ) such that c+1=3 (i.e. the number of data paths, e.g. peripheral to memory, memory to peripheral and memory to memory), which results in the IPCM  replacing of 192 individual hardware DMA controllers. Disadvantageously, this large number of DMA controllers would not be cost effective and would dominate the available space of the processor. Thus, the IPCM  provides a number of DMA data channels or data paths that are each configurable or programmable to connect different nodes together. As such, a node is typically the RAM , eDRAM , or one of the peripherals. Thus, a single DMA data channel may be programmed to provide a direct memory access data transfer from the USB  to the eDRAM , and then the same data channel may be reprogrammed or reconfigured at a later time to provide a direct memory access data transfer to from the DSP RAM  to the MMC .","This is a departure from hardware DMA controllers which provide a non-programmable, unidirectional wired data channel from one node to another node, which may not be later reconfigured as between two different nodes. Advantageously, in a wireless multi-media application, where the physical size of the chip or processor  is important and there are a large number of peripheral devices requiring many DMA controllers for direct memory access, the IPCM  provides a programmable DMA functionality in which a data channel is formed that may be altered as needed. Thus, many DMA controllers are not needed and the overall size of the processor  may be made smaller than if many hardware DMA controllers were implemented.","The function of the IPCM  advantageously relieves both the host processor  and the DSP  from having to stop performing tasks in order to perform data transfers. The IPCM  performs these transfers in order to provide the most efficient operation of both the DSP  and the host processor . In other words, the DSP  and the host processor  are allowed to operate at their optimal speeds and perform the critical tasks that they were designed for without slowing down to perform simple data transfers.","Referring next to , a detailed block diagram is shown of one embodiment of the wireless multimedia processor platform of . Shown is the multi-media processor platform  including the digital signal processor  (DSP ), a DSP RAM , DSP peripheral interface , the host processor  (also referred to as the call processor ), the embedded DRAM  (eDRAM ), an LCD controller  (also referred to more generically as a display controller) including image processing  and configuration registers , and host peripheral interface . The processor platform  also includes the following peripherals : the USB , the UART\/IrDA , a Synchronous Serial Interface  (also referred to as an SSI ), the MMC , and a bluetooth interface . Also included is the IPCM , an event timer , data path select  (also referred to as the data path select unit ), an eDRAM refresh controller  (also referred to as refresh controller ), and a bus interface .","Further included are the following busses: a clock bus  (also referred to as the \u201cc\u201d bus ) coupled to the refresh controller ; the DSP system bus  (also referred to as the \u201cd\u201d bus ) coupling the DSP , the DSP RAM  and the DSP peripherals  to the IPCM ; the event bus  (also referred as the \u201ce\u201d bus ) coupling the peripherals  to the event timer  and the IPCM ; the host system bus  (also referred to as the \u201ch\u201d bus ) coupling the host processor to the peripherals  and , the LCD controller , bus interface , data path select , refresh controller , and the IPCM ; the IPCM bus  (also referred to as the \u201ci\u201d bus ) coupling the IPCM  to peripherals ; the memory bus  (also referred to as the \u201cm\u201d bus ) coupling the data path select  to the eDRAM ; LCD bus  (also referred to as the \u201cp\u201d bus ) coupling the image processing  to the data path select ; the refresh bus  (also referred to as the \u201cr\u201d bus ) coupling the refresh controller  to the data path select ; an external system bus  (also referred to as the \u201cs\u201d bus ) coupling the bus interface to, for example, external memory ; and a transfer bus  (also referred to as the \u201ct\u201d bus ) coupling the IPCM  to the data path select .","Also illustrated in , but not part of the processor platform , are the radio hardware  coupled to the DSP peripheral interface , the LCD panel  coupled to the image processing , the external memory  coupled to the bus interface , and a clock input  coupled to the refresh controller .","The processor platform  includes three processor cores: the DSP , the host processor , and a RISC processor core embedded within the IPCM . Advantageously, in this embodiment, the processor platform  is implemented as a system on a chip, although many features of the present invention are not limited to an integrated system on a chip design. The following is a brief description of several of the components of the processor platform .","The DSP , as known in the art, is interfaced via a DSP system bus  to a system memory, e.g. DSP RAM , and DSP peripheral interface . The DSP RAM  contains DSP program and data storage areas. The DSP peripheral interface  is used to interface the DSP core (i.e. modem) to the radio hardware  to implement cellular radio communications. These components are well known in the art and are commonly found in cellular telephones.","The host processor  is a general purpose reduced instruction set computer (RISC) processor or a complex instruction set computer (CISC) processor as known in the art. The LCD controller  is a module containing digital logic configured to render an image onto an external LCD panel  from a binary bit image contained within memory, e.g. an eDRAM  memory array. The host peripheral interface  includes one or more modules containing digital logic and configured as a peripheral operated by the host processor . Examples of such peripheral interfaces include keyboard interface, general purpose timer, and general purpose I\/O ports.","Also included are multimedia peripherals . The USB  is a logic block configured as a peripheral implementing the media access layer functions of the open standard known as the Universal Serial Bus. The module is configured with 2 interface ports: a port interfaced to the host processor  via the h bus  for purposes of configuration management and control and a data port interfaced to the IPCM  via the i bus  used to pass data to and from the external serial interface.","The IrDA\/UART  is a logic block configured as a peripheral implementing the necessary functions known in the art as a Universal asynchronous Receiver\/Transmitter with an optional mode to support the IrDA standard. The IrDA\/UART  is configured with 2 interface ports: a port interfaced to the host processor  via the h bus  for purposes of configuration management and a data port interfaced to the IPCM  via the i bus  used to pass data to and from the external serial interface.","The SSI  is a logic block configured as a peripheral implementing the necessary functions known in the art as a Synchronous Serial Interface. The module is configured with 2 interface ports: a port interfaced to the host processor  via the h bus  for purposes of configuration management and a data port interfaced to the IPCM  via the i bus  and used to pass data to and from the external serial interface.","The MMC  is a digital interface designed for the purpose of connecting to and operating with a MULTIMEDIACARD. The MMC  is configured with 2 interface ports: a port interfaced to the host processor  via the h bus  for purposes of configuration management and a data port interfaced to the IPCM  via the i bus  and used to pass data to and from the external MULTIMEDIACARD.","The bluetooth interface  is a digital interface containing designed for the purpose of supporting the BLUETOOTH open standard. The bluetooth interface  is configured with 2 interface ports: a port interfaced to the host processor  via the h bus  for purposes of configuration management and a data port interfaced to the IPCM  via the i bus  and used to pass data to and from an external Bluetooth compliant radio circuit.","The event timer  is a binary counter coupled to the IPCM  via the e bus  and having \u2018n\u2019 number of states connected to comparison logic capable of detecting a predetermined distinct state for the purpose of generating a signal when a specific state is indicated. The counter is clocked by an accurate clock source. In one embodiment, the event timer  can handle up to 32 events at a given time. In some embodiments, the event timer  may be used to signal a programmed event or direct memory access data transfer to the IPCM , for example, at regular intervals.","The IPCM  is designed to perform interprocessor and serial I\/O communication employing DSP  processor, and the I\/O peripherals , such as USB , IRDA\/UART , bluetooth interface  and MMC . The IPCM  is strategically positioned in the architecture to enable programmable direct memory access (DMA) data transfers to\/from I\/O peripherals with either the host processor  or the DSP . In addition, the IPCM  supports data transfers between the DSP and Host itself. Thus, advantageously, the IPCM  behaves as a programmable DMA to transfer data into memory without involving either the DSP  or the host processor  to make the data transfer.","Within the IPCM  is a programmable RISC core which is programmed to perform DMA functions. A more detailed description of the inner workings of the IPCM  is described with reference to . This approach offers several advantages over non-programmable (e.g. hardware based) solutions. The programmable DMA functionality of the IPCM  has many benefits. First, this allows dynamic routing in that the RISC core can be programmed to perform a variety of tasks. Under programmed control, in one embodiment, the IPCM  can configure up to 32 simultaneous DMA data channels, each of which may be configured in any one of three directions. DMA data transfers are routed over respective ones of each of these 32 DMA data channels. For example, each data channel could be configured to as a DMA data channel for DMA data transfers between (1) a peripheral  to memory (e.g. DSP RAM  or eDRAM ), (2) memory (e.g. DSP RAM  or eDRAM ) to peripheral , or (3) memory (e.g. DSP RAM  or eDRAM ) to memory (e.g. the other of eDRAM  or DSP RAM ). Advantageously, each of these 32 programmed DMA data channels may later be reprogrammed to allow DMA data transfers between two different nodes.","Furthermore, the IPCM  allows more functionality in a smaller footprint. This is because the IPCM  replaces many separate wired DMA controllers between the various nodes, i.e. the DSP RAM , the eDRAM , and the various I\/O peripherals . This represents a significant savings in gates or transistors needed on the die, which for handheld multimedia applications is important in minimizing processor size. Typical gate counts of DMA channels are approximately 3 k gates per channel. In this embodiment, the IPCM  becomes a space saving advantage when more than 6 hardware DMA channels are required. Advantageously, in this embodiment, the IPCM  behaves as 192 (as described above) separate DMA channels within the footprint of about 6 actual hardware DMA channels.","Additionally, the IPCM  is flexible and scalable. The concept lends itself to enhancements for future generation products. The flexible data routing capabilities enable additions to the basic architecture such as hardware based accelerators. Enhancements to the RISC core of the IPCM  include adding registers and new instructions to permit the concept to meet future needs.","Also, the programmable RISC processor core of the IPCM  provides a common application program interface (API) to be defined, since the programmable RISC core uses virtual control registers which are mapped into the host memory (i.e. eDRAM ). The API can remain intact when enhancements are made to the IPCM  in future generations. This feature increases software reusability.","Another feature is that the IPCM  is provided with smart power management such that a sleep mode is entered during periods of inactivity. This is important in handheld applications where battery life is an important concern.","Yet another feature of the IPCM is that the DMA data transfers can be transferred to and from memory (e.g. either DSP RAM  or eDRAM ) using little-Endian format or big-Endian format, as known in the art. This enables the IPCM  to communicate with different types of processors configured according to either format. For example, a DSP configured for little Endian format or a DSP configured for big-Endian format can interface with the IPCM .","Another component of the processor platform  is that since the entire system is implemented on a chip, the RAM of the host processor  is an on-chip memory array constructed of DRAM type bit cells as known in the art and referred to as an embedded DRAM or eDRAM . The array is configured as 65536 words (64 k words) of 128 bits each for a total of 67,108,846 bit cells (64M bit). The eDRAM  must be refreshed periodically and this function is accomplished by the refresh controller . The 128 bit width of the eDRAM  is optimized for the LCD controller  as will be described further below. Thus, the eDRAM  functions as the host processor memory and an on-chip video buffer for the LCD panel . Advantageously, the width of the eDRAM reduces the number of access cycles consumed by the LCD controller  and thereby increase the number of access cycles available to the host processor  and IPCM .","The bus interface  is a module containing digital logic configured to function as a memory controller as known in the art. The module supports external memory  interfaced to the processor platform  via the s bus . The external memory  includes a number of discrete memory devices such as SRAM, EPROM, FLASH and DRAM. The external memory  is directly accessible by the host processor  or indirectly accessible by the DSP  via the IPCM . This is advantageous because this enables the host processor  and\/or the DSP  to upload and run applications that are too large to be stored in the respective memories of these processors. For example, the DSP  may upload and run voice recognition programs stored in the external memory . Furthermore, the bus interface  allows concurrent processing operations between the host processor , the IPCM  and the DSP ; thus, implementing a multiple instruction stream, multiple data stream (i.e. MIMD) on a single integrated circuit realizing the multi-media telephone, for example.","Note that since the eDRAM  has its own bus, i.e. the m bus , instead of being a part of the host system bus or h bus , the host processor  may access the external memory  through the bus interface  while at the same time, the IPCM  accesses the eDRAM .","The data path select  contains arbitration logic and a pre-programmed data multiplexer designed for the purpose of interfacing the data path of the eDRAM  to one of 4 entities that may request access to the array. The 4 entities which can request access to the eDRAM  are the host processor  having an access width of 32 bits, the IPCM  having an access width of 32 bits, the LCD Controller  having an access width of 128 bits, and the refresh controller  for performing 16 ms periodic cycle stealing refresh for 4096 rows as known in the art. In the embodiment shown, each requester has a unique data path bus width, e.g. the p bus  has a width of 128 bits while the i bus  and the h bus  have a 32 bit width. The data path select  automatically configures the appropriate data path depending on the device being granted access. As such, the data path select  converts the wide array of 128 bits to support popular 32 bit RISC processor cores, e.g. within the IPCM . In all cases the memory address presented by the requester is taken into account in order to reference the correct data elements from the array. The bus width and access modes for each requestor is shown in Table 1 below.",{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Data path configuration"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},{},"Access"]},{"entry":[{},"Requestor","Bus width","Read\/Write","modes"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"Host Core","x32","R\/W","x8, x16, x32"]},{"entry":[{},"IPCM","x32","R\/W","x8, x16, x32"]},{"entry":[{},"LCD","x128","Read only","x128"]},{"entry":[{},"Controller"]},{"entry":[{},"Refresh","0","Special","Invokes"]},{"entry":[{},"Controller",{},"refresh","4096 bit"]},{"entry":[{},{},{},"cycle","cells"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"Furthermore, in one embodiment, the data path select  always stores and retrieves data to and from the eDRAM  using the big-Endian format. However, since the IPCM is configured to operate in either little-Endian format or big-Endian format, if the IPCM is operating according to the little-Endian format, the data path select  converts the data to and from the IPCM according to the little-Endian and to and from the eDRAM into big-Endian format. As such, the IPCM must inform the data path select which format it is configured as.","The refresh controller  generates memory requests to the eDRAM  in order to facilitate periodic cycle refresh of the bit cells within the eDRAM array. However, in preferred embodiments of the present invention, the method of refreshing the eDRAM  is performed in such a manner as to minimize power consumption in ways not contemplated by known refreshing techniques. Several specific refreshing techniques that are designed to conserve power consumption are described with reference to .","The following is a description of the various bus interfaces. The clock bus  (\u201cc\u201d bus) is a clock input line used to sequence and time the refresh controller . The DSP system bus  (\u201cd\u201d bus) contains a separate address and data path along with control signals to convey read and write operations to the selected device. In addition, a bus request and bus acknowledge signal is also incorporated to allow the IPCM  to request use of the DSP system bus. The event bus  (\u201ce\u201d bus) is a group of signals driven by the peripherals  and sent to the input event detection device of the IPCM  (see ) for the purpose of activating a data movement operation. The host system bus  (\u201ch\u201d bus) contains a separate address and data path along with control signals to convey read and write operations to the selected device. The h bus  can operate independently from all other buses. In addition, a bus request and bus acknowledge signal is also incorporated to allow the IPCM to request use of the h bus . The IPCM bus  (\u201ci\u201d bus) is the IPCM system bus containing a separate address and data path along with control signals for signaling read and write operations to a specified peripheral . The memory bus  (\u201cm\u201d bus) is a bi-directional bus and is used to interconnect the eDRAM  with the data path select  module. The memory bus  has a bus width of 128 bits. The LCD bus  (\u201cp\u201d bus) is a unidirectional bus having a width of 128 bits and is used to move display image samples to the LCD controller  for display on the LCD panel . The refresh bus  (\u201cr\u201d bus) is a bus that, when asserted, contains the address of the next row to be refreshed in the eDRAM  array. The external system bus  (\u201cs\u201d bus) contains a separate address and data path along with control signals to convey read and write operations to the selected external memory . The external system bus  is accessible by the host processor  or the IPCM . The transfer bus  (\u201ct\u201d bus) conveys access requests from the IPCM  to the eDRAM  array. The transfer bus is bi-directional and has a 32 bit data path and a 32 bit address path.","Another feature of the eDRAM  is that it provides an on-chip video buffer as well as being the RAM for the host processor . Advantageously, the eDRAM  is 128 bits wide, in order to accommodate the LCD controller . If the eDRAM were 32 bits wide, which would be customary to support common RISC processor cores and host processors, the eDRAM  would be dominated by requests from supporting the LCD controller , such that the other devices using the eDRAM would have to compete with the LCD controller . Thus, the LCD controller  would essentially become the primary user of the eDRAM and the IPCM  and the host processor  would become secondary user. By providing a very wide buffer that is the same width as the LCD bus , the LCD controller  only briefly accesses the eDRAM  allowing the IPCM  and the host processor  to become the primary users of the eDRAM . Thus, configuring the eDRAM at 128 bits wide, the LCD controller only uses about 2\u20133% of the eDRAM capabilities, advantageously leaving 97% to the other devices using the eDRAM. Note that the data path select  allows for the differently sized busses to access the eDRAM .","The fact that the eDRAM  doubles as the system memory and the video buffer further reduces space on the processor platform . If a separate dedicated video buffer was employed, such as traditionally done, this separate video buffer would occupy additional space on the processor platform or be a separate integrated circuit wired to the LCD controller , which would take up even more space and introduce losses in the wiring. In contrast to conventional discrete video buffers, the eDRAM  of the processor platform  acts as both the system memory and the video buffer within a small footprint.","The following describes various other features of the IPCM .","Since the IPCM allows DMA data transfers from the peripherals mapped to the IPCM bus  to the either the DSP RAM  or the eDRAM , the IPCM allows these peripherals  to be used by the DSP  and\/or the host processor . For example, a data storage device, such as the MMC  is accessible to the DSP  or host processor . Thus, MP3 formatted data may be streamed from the MMC  to the DSP  to affect an Internet audio player. Other applications include using the IPCM to write or read data files located on the MMC  by the host processor . Furthermore, the IPCM can be configured to move digital audio samples to and from the DSP RAM  to a pair of USB isochronous ports; thus, realizing a speakerphone. Additionally, the IPCM  supports multiple data streams originating and\/or terminating from either the eDRAM  or the DSP RAM . The data transfers from each of the eDRAM  and the DSP RAM  may be performed independently of each other.","Additionally, since the IPCM  contains a RISC processor core (described in more detail with reference to ), it is smart programmable. Thus, program tasks can be off-loaded from the host processor  via DMA data transfers from the eDRAM. For example, the IPCM  may perform \u201cbit-blit\u201d tasks, normally performed by the host processor . \u201cBit-blit\u201d tasks, as known in the art of computer graphics, involve altering the background displays of a visual display or causing images to \u201cfly\u201d across a visual display. The IPCM  can load the necessary program from the host processor  to perform such tasks, instead of the host processor  so that the host processor  is free to perform other tasks.","Another application would be to off-load the host processor  or the DSP  from performing packet protocol framer functions such as \u201cPPP\u201d or the \u201cLAP layer\u201d function used in the IrDA standard. Again, advantageously the host processor  and the DSP  do not have to perform these functions.","In one embodiment, the IPCM  supports an external MPEG decoder coupled to either the SSI  or the UART\/IrDA  by sending packets to the decoder under the control and supervision of the host processor . The IPCM  retrieves the decoded pixel data from the external MPEG decoder and deposits the pixel data into the video buffer area allocated within the eDRAM . As such, a \u201cpicture-in-desktop-window\u201d is provided to the LCD panel .","The IPCM takes advantage of the event timer  so that programmable DMA data transfers can be activated according the event timer , in addition to being activated by events triggered by the respective peripherals and\/or the DSP  and\/or the host processor . Thus, pre-programmed DMA data transfers will automatically occur at predetermined times.","Furthermore, in order to minimize power consumption, the IPCM is designed to enter a low power mode (i.e. sleep mode) when no events are pending. Thus, the IPCM  will not unnecessarily drain battery life in between DMA data transfers.","InterProcessor Communication Module (IPCM)","Referring next to , a block diagram is shown of the interprocessor communication module (IPCM) of the wireless multimedia processor platform  of . Shown is the IPCM  (also referred to as a \u201cprogrammable direct memory access module\u201d) including a RISC processor core  (also referred to as a RISC core of more generally as processor ), an event scheduler  (also referred to as an event detect unit , a task scheduler  or a programmable task scheduler ), static RAM  (also referred to as SRAM ), read only memory  (also referred to as ROM ), DSP direct memory access unit  (also referred to as DSP DMA unit ), a host direct memory access unit  (also referred to as a host DMA unit ), DSP control registers  (also referred to as DSP control unit ), and host control registers  (also referred to as host control unit ). Also shown are the DSP system bus  (\u201cd\u201d bus ), the host system bus  (\u201ch\u201d bus ) the IPCM bus  (\u201ci\u201d bus ), and the peripherals  including the USB , IrDA\/UART , SSI  and MMC . Also shown are the event timer input  and peripheral\/DMA event inputs  into the event scheduler  via the event bus  (\u201ce\u201d bus ).","The DSP control registers  and the DSP DMA unit  are coupled to the d bus  via a bus interface. The host control registers  and the host DMA unit  are coupled to the h bus  via a bus interface. The IPCM  also includes the i bus  which couples to the various peripherals . Within the IPCM , the RISC processor core , the SRAM , the ROM , the DSP control registers , the DSP DMA unit , the host control registers  and the host DMA unit  are all coupled to the i bus . Both the DSP DMA unit  and the host DMA unit  each comprise a bus transceiver portion of a conventional DMA controller. The event scheduler  is coupled to the processor . Inputs to the event scheduler  are the event timer  and the peripheral\/DMA events .","In operation, the IPCM  is provides interprocessor and serial I\/O data transfers employing direct memory access (DMA) techniques without actually implementing individually dedicated hardware DMA channels for all the various possible data transfer paths. Advantageously, by providing the IPCM  to perform these DMA data transfers, both the host processor and the DSP are relieved of such tasks and can perform more important tasks. Advantageously, and in contrast to traditional DMA circuits (also referred to as DMA controllers) that establish hardwired unidirectional DMA data channels, the IPCM  is a programmable DMA module that provides programmable DMA data channels that may be programmed to perform any one of three types of data transfers: (1) from a selectable peripheral  to either of two memories (e.g. DSP RAM  or eDRAM ), (2) from either of two memories to a selectable peripheral , and (3) between the two memories. Thus, the IPCM  configures, for example, 32 programmable DMA data channels, each one which can be configured for one of the six types of data transfers. Advantageously, within the physical footprint of approximately six conventional hardware DMA controllers as known in the art, in one embodiment, the IPCM  replaces 192 individual DMA controllers and has the ability to configure 32 out of 192 possible DMA data channel configurations at any given time. Each of these 32 programmed DMA data channels are then used for DMA data transfers. Furthermore, these 32 data channels may then be re-configured to a different 32 out of the 192 possible DMA data channel configurations at a later time or as needed. This proves very valuable and flexible in space conscious applications, such as in handheld devices.","In one embodiment, one of the 32 DMA channels is reserved as a control channel from the host processor  to the IPCM . Thus, the IPCM  can configure 31 DMA data channels out of 186 possible DMA data channel configurations. Advantageously, this control channel allows the host processor to be able to send a control message to the IPCM to reconfigure one or more of a set of 31 configured DMA data channels into another one of the 186 possible DMA data channel configurations. Even if there is no control channel, the entire set of 32 configured DMA data channels may be dumped and reconfigured by the host processor.","In order to accomplish this programmable DMA data transfer capability, the IPCM  includes a RISC processor core  and also ROM  and the SRAM . In some embodiments, the RISC processor core  comprises a microRISC processor core. The RISC processor core  is used to execute short routines or instructions (stored in SRAM ) which perform DMA data transfers. A specific example, of a custom RISC processor core and its instruction set are further described later in this specification. Also included are a pair of DMA units, DSP DMA unit  and host DMA unit , interface with the RISC processor core  and use specialized, dedicated registers for all DMA transfers. Thus, the DSP DMA unit  and the host DMA unit  comprise the bus transceiver portion of a conventional DMA controller. The address register, data register and counter, for example, of the conventional DMA controller are implemented within the RISC processor core . As such, the respective DSP DMA unit  and the host DMA unit  each represent two wired data paths to and from the RISC processor core  and the respective busses, e.g. d bus  and h bus .","The ROM  contains startup scripts (i.e. boot code) and the other common utilities which are referenced by scripts that reside in the SRAM . An example set of ROM scripts are attached in Appendix B. The SRAM  is divided into a processor context area and a code space area used to store channel scripts. Channel scripts are downloaded into SRAM  from the eDRAM or from external memory by the IPCM  using the host DMA unit . Downloads are invoked using command and pointers provided by the host processor. Each programmable or \u201cvirtual\u201d DMA data channel can be configured independently on an \u201cas needed\u201d basis under the control of the host processor. This permits a wide range of IPCM functionality while using the lowest internal memory footprint possible. Microcode routines can be stored in an external memory, e.g. a large capacity Flash memory, and downloaded when needed.","The task scheduler  is a programmable scheduler that receives requests from the peripherals , host processor , and DSP RAM  for DMA data transfers. These requests are in the form of \u201cevents\u201d detected on the e bus . An event is a condition that arises that controls the operation of a particular programmable DMA data channel. For example, an event is an indication from one of the peripherals, the host or the DSP (e.g. peripheral\/DMA event inputs ) that a DMA data transfer is desired. An event may be a signal from the host processor alerting the IPCM to re-program a specific DMA data channel. An event may also be a timed indication from the event timer (i.e. event timer inputs ) that a DMA data transfer is to take place. For example, depending on which line of the e bus  an event is detected on, the task scheduler  can tell who is making the request or indicating that a DMA transfer is desired. The task scheduler  prioritizes and manages the requests. The task scheduler  monitors and detects external events for DMA data transfers, and maps the event (e.g. signal indicating a DMA data transfer is to be performed) to a particular DMA data channel. The events are mapped as DMA data transfers within a specific DMA data channel according to a priority such that higher priority data transfers will occur before lower priority DMA data transfers. Furthermore, the task scheduler  is capable of performing \u201cpriority-based preemption\u201d in which a particular DMA data transfer currently being executed by the IPCM is interrupted (i.e. paused) so that a higher priority DMA data transfer may be executed. Once the higher priority DMA data transfer has been completed, the DMA data transfer having been interrupted is then resumed, unless another higher priority DMA data transfer is requested. Priority-based preemption is known to processors generally; however, conventional DMA controllers are hardware-based (i.e. non-programmable) and thus, not capable of such preemption. Advantageously, this embodiment provides priority-based preemption in a programmable DMA system.","The following is a brief description of the data flow in the different types of programmable DMA data transfers supported by the IPCM.","1. Peripheral to Memory","In operation, the various peripherals  are responsible for gathering data to be input into the processor platform. When data has arrived at the particular peripheral, for example, at the MMC , the peripheral signals an event to the task scheduler  of the IPCM  via the event bus . The task scheduler  is able to handle 32 events at any given time. The event is prioritized by the task scheduler  and mapped to a particular DMA data channel. Once the event is to be executed, the RISC processor core  runs software in the form of scripts located in the SRAM . The software is specific to the particular DMA data channel and configures the particular DMA data channel. The software effectively disciplines the RISC processor core  to affect the DMA data transfer from the specific peripheral to the memory destination, e.g. either the eDRAM or the DSP RAM. The DMA data transfer is performed by the software in the RISC processor core  such that the data in the peripheral travels to the respective memory via the i bus  and the respective DMA unit, e.g. either the DSP DMA unit  or the host DMA unit .","Advantageously, the DMA data transfer occurs without involvement of the either the DSP or the host processor. Furthermore, by using the IPCM  which includes the RISC processor core  and a single hardware DMA circuit, e.g. host DMA unit , many different DMA data paths are established through a single hardwired DMA unit. Each of these data paths are referred to as a programmable DMA data channel or a \u201cvirtual\u201d DMA data channel. For example, there may be a DMA data channel or path from the USB  to the DSP RAM  and another DMA data channel or path from the SSI  to the DSP RAM , both of which travel through the DSP DMA unit . Advantageously, either DMA data channel may be later reconfigured as a different DMA data channel, e.g. from the MMC  to the DSP RAM . Thus, each peripheral to memory DMA data channel utilizes either the DSP DMA unit  or the host DMA unit, but may be may be programmably selectable as from any one of the peripherals coupled to the IPCM .","2. Memory to Peripheral","This type of DMA transfer is opposite the first type in that the transfer is from the memory of one of the processor cores of the processor platform, e.g. the DSP RAM or the host processor memory (e.g. eDRAM) to one of the peripherals . The DSP, via the DSP control registers , signals an \u201cevent\u201d (data transfer) to the task scheduler , which prioritizes the event and maps it to a DMA data channel and signals to the RISC processor core  to perform the data transfer. The information provided by the DSP indicates a location in the DSP RAM that the data is stored and how much data to transfer. Then, the RISC processor core  runs software in the form of scripts located in the SRAM . The software is specific to the particular DMA data channel. The software effectively disciplines the RISC processor core  to affect the DMA data transfer from the DSP RAM  to the particular peripheral . The transfer is performed by the software in the RISC processor core  such that the data is copied from the DSP RAM into registers within the DSP DMA unit, then transferred to the peripheral via the i bus .","3. Memory to Memory","A third type of DMA data transfer is memory to memory. For example, in the event data is to be transferred from the DSP memory (e.g. DSP RAM ) to the host processor memory (e.g. eDRAM ), the DSP would assert an event to the task scheduler  of the IPCM . The task scheduler  recognizes the event, prioritizes it and then causes the RISC processor core  to load scripts from the SRAM  to affect a DMA data transfer from the DSP RAM to the RISC processor core  itself via the DSP DMA unit . For example, the data is temporarily placed into registers within the RISC processor core . Then, a DMA data transfer is performed between the RISC processor core  and the host processor memory (e.g. eDRAM ) via the host DMA unit . This is effectively a \u201cback to back\u201d DMA data transfer. The IPCM  resolves differences in a memory sizes. For example, if the DSP RAM is 16 bits wide and the host processor memory is 32 bits wide, the IPCM will gather 16 bit words and pack them into 32-bit words, then transfer the 32-bit words to the host processor memory.","Once the complete \u201cback to back\u201d DMA data transfer has taken place from the DSP RAM to the host processor memory via the RISC processor core , the IPCM  will signal to the host processor to inform it that there is data stored in its memory. In other words, the RISC processor core  sends a control signal via the host control registers  to the host processor, giving the host processor a location pointer to an address in the host processor memory where the data begins and how many words have been placed in the host processor memory starting at that address. At that point, the host processor will retrieve the data at it's convenience. Note that most DMA data transfers are many bytes in length (e.g. 1000 bytes), requiring many iterations before a transfer complete event is signaled. This notification process is also the same in a peripheral to memory transfer, i.e. the RISC processor core  notifies the respective processor core, e.g. DSP or host processor, that data is waiting in memory.","This is in contrast to a processor bridge, as known in the art that allows data transfers between two processors. For example, if a host processor wanted to move data from the host to the DSP, the host would have to interrupt the DSP, wait until the DSP was ready to exchange data, then for a brief moment, the host processor would control the DSP memory in order to effect the transfer. This disadvantageously temporarily halts both the DSP and the host processor during the data transfer. Thus, the host memory and the DSP memory each stop and communicate at the same moment.","In contrast, the IPCM  allows a direct memory access data transfer from the host memory into the RISC processor core  without interrupting the DSP. The only activity required of the host processor  is to transmit the control signals to signal an event to the IPCM to perform the DMA data transfer of data from the host memory into the RISC processor core . Next, a DMA data transfer is performed from the RISC processor core  into the DSP memory. The DSP then retrieves the data from the DSP RAM. In this situation, neither the DSP or the host processor have to stop for the other to cause the transfer.","Referring next to , a diagram is shown that illustrates the programmably selectable direct memory access (DMA) data channels provided by the IPCM of ,  and . Shown are the IPCM , the DSP DMA unit , the host DMA unit , the RISC processor core , the i bus , the d bus , and the h bus . The DSP DMA unit  includes a first DSP DMA data connection  and a second DSP DMA data connection . The host DMA unit  includes a first host DMA data connection  and a second host DMA data connection .","The IPCM  includes the DSP DMA unit  and the host DMA unit . Each DMA unit  and  comprises a bus transceiver portion of a conventional DMA controller and forms 2 hardwired DMA data connections (through which programmable DMA data channels are established for DMA data transfers), one in the direction of RISC processor core  to memory and the other in the direction of memory to RISC processor core . These four DMA data connections are programmed by the RISC processor core  of the IPCM to act as if they together, with the RISC processor core , were 192 (186 if one of the DMA data channels is a control channel) actual hardware DMA controllers. In contrast, conventional DMA controllers only allow one dedicated DMA channel to be established using a DMA data connection.","In a broad sense, the RISC processor core  acts as a switch between devices and the various wired DMA data connections. Thus, the first host DMA channel data connection  may be configured or programmed as many different programmable DMA data channels, e.g., a DMA data channel from the USB  to the eDRAM , a DMA data channel from SSI  to eDRAM , and a DMA data channel from MMC  to eDRAM . These different DMA data channels utilizing the first host DMA data connection  may be referred to as \u201cvirtual\u201d DMA data channels, since they effectively provide more DMA data channels than exist in hardware. Thus, the first host DMA channel  is programmably selectable such that it can support DMA data transfers from any one of several peripherals or from the originating node of the second DSP DMA data connection  to a memory at the destination end of the first host DMA data connection , e.g. the eDRAM . Thus, the RISC processor core  and a single DMA unit, e.g. host DMA unit , replace many separately wired conventional DMA controllers.","Likewise, the second host DMA data connection  may be programmably selectable into \u201cvirtual\u201d DMA data channels from the originating end or node (e.g. eDRAM ) and to any one of several peripherals or to the destination node of the first DSP DMA data connection . These virtual DMA data channels each utilize the second host DMA data connection . Furthermore, a \u201cback to back\u201d DMA data channel may be affected through the second host DMA data connection  and the first DSP DMA data connection  via the RISC processor core .","Custom RISC Processor Core\/IPCM","It is noted that the RISC processor core may be a standard RISC processor as is known in the art. However, custom RISC processors may be designed which may improve performance in the IPCM . The following is a description of a specific embodiment of a custom RISC processor core and IPCM for use as the IPCM of .","The custom RISC processor core  is a 32-bit register architecture with 16-bit instructions. There are 8 general purpose 32-bit registers, 4 flags (T, LM, SF, and DF) and PCU registers (PC, RPC, SPC, and EPC) as known in the art. The RISC processor core  is a two stage pipeline and also includes ROM  and the SRAM . The ROM  is 1 k byte (configured as 256\u00d732) and the SRAM  is 8 k byte (configured as 2048\u00d732).","The custom RISC processor core  (hereinafter simply referred to as the RISC processor core ) is used to execute short routines which perform DMA data transfers. The instruction set (stored in SRAM ) is comprised of single cycle instructions with the exception of Load\/Store, CRC, DMA, and branch instructions which take two, or more cycles, to execute. A preferred instruction set is provided in Appendix A, which is attached hereto. The i bus  supports a 32-bit data path and a 16-bit address bus. A pair of DMA units, DSP DMA unit  and host DMA unit , interface with the RISC processor core  and use specialized, dedicated registers for all DMA transfers.","The ROM  contains startup scripts (i.e. boot code) and the other common utilites which are referenced by scripts that reside in the SRAM . The SRAM  is divided into a processor context area and a code space area used to store channel scripts. Channel scripts are downloaded into SRAM  from the eDRAM or from external memory by the IPCM  using the host DMA unit . Downloads are invoked using command and pointers provided by the host processor. Each programmable or \u201cvirtual\u201d DMA data channel can be configured independently on an \u201cas needed\u201d basis under the control of the host processor. This permits a wide range of IPCM functionality while using the lowest internal memory footprint possible. Microcode routines can be stored in an external memory, e.g. a large capacity Flash memory, and downloaded when needed.","The task scheduler  is responsible for monitoring and detecting external events, mapping events to DMA data channels (also referred to simply as channels) and mapping individual channels to a pre-configured priority. At any point in time, the task scheduler will present the highest priority channel requiring service to the IPCM . A special IPCM core instruction is used to \u201cconditionally yield\u201d the current channel being executed to an eligible channel that requires service. If, and only if an eligible channel is pending will the current execution of a channel be pre-empted. There are two \u201cyield\u201d instructions that differently determine the eligible channels: in the first version, eligible channels are pending channels with a strictly higher priority than the current channel priority; in the second version (\u201cyieldge\u201d), eligible channels are pending channels with a priority that is greater or equal to the current channel priority. The task scheduler  detects devices (e.g., channels) needing service through the 32 input event port (the event timer input  and the peripheral\/DMA events ). After an event is detected, and only if it is mapped to a channel, the channel event is latched into the \u201cChannel Pending (EP)\u201d register. The priorities of all pending channels are combined with control bits set by the host processor and the DSP and continuously evaluated in order to update the highest pending priority. Each bit in the channel pending register is cleared by the channel script software when the channel service routine has completed.","The Host Control module (i.e. host control registers ) contains several small RAM blocks organized as an array which are used to control (i.e., channel mapping) the 32 individual channels. The Channel Enable Register is the largest RAM array (32 bits\u00d732 bits) and is used to map events to a specific channel(s). The second array is the Priority RAM and is used to assign channels to a programmable 1-of-7 level priority.","The 32 event inputs connected to the task scheduler via the e bus  come from a variety of sources and are analogous to interrupt request signals. The receive register full and transmit register empty events that are found in UART and USB ports are typical examples of signals connected to the Event Port on the IPCM. Some of the event inputs are sourced from the Layer 1 timer (e.g. event timer ). Within the Layer 1 timer are register based compare\/capture blocks which can be used to signal an event for a unique, momentary state of the Layer 1 timer. These events can be used to trigger a specific IPCM channel or channels. This feature can be used to realize a \u201cjust-in-time\u201d data exchange between the two processors (e.g. DSP and host processor) to relax the requirement to meet critical deadlines.","The embedded nature of the IPCM requires on-chip debug capability to assure product quality and reliability and to realize the full performance capabilities of the core. The OnCE compatible debug port includes support for setting breakpoints, single step & trace and register dump capability. In addition, all memory locations are accessible from the debug port.","The IPCM  has two memory spaces: one for the instructions and one for the data; as both spaces share the same resources (ROM and RAM devices), the system bus manages possible conflicts when the IPCM accesses the same resource for both instruction read and data read or write.","Instructions, that are 16-bit wide, are stored in 32-bit wide devices and are also accessible as data. The correspondence is Big Endian: an even instruction address (terminated by \u20180\u2019) accesses the Most Significant part of the 32-bit data (bits [:]) and an odd instruction address (terminated by \u2018I\u2019) accesses the Least Significant part of the 32-bit data (bits [:]).","Instructions can be fetched from the IPCM ROM and RAM. The ROM, RAM, peripherals (USB, UART1, UART3, MMC and VSAP) and memory mapped registers are accessible as data.","The task scheduler  is a hardware based design used to coordinate the timely execution of 32 programmable selectable DMA data channels (virtual DMA channels) by the IPCM on the basis of channel status and priority. The task scheduler performs the following functions: (1) monitors, detects, and registers the occurrence of any one of the 32 event inputs provided; (2) links a specific event input to a specific channel or group of channels (channel mapping); (3) ignores events which are not mapped to a previously configured channel(s); (4) maintains a list of all channels requesting service; (5) assigns a pre-programmed priority level (1 of 7) to each channel requesting service; and (6) detects and flags overrun\/underrun conditions.","A programmable DMA data channel or virtual DMA data channel (hereafter simply called a channel) manages a flow of data through the IPCM . Flows are typically unidirectional, but are reconfigurable or reprogrammable. The IPCM can have 32 simultaneously operating channels, numbered  to . Channel  is dedicated for use by the host processor  to control the IPCM . All other channels can be assigned by the host processor software.","An event is a condition that arises which can control the operation of a channel. Events may be caused by externally (i.e., external to the IPCM) controlled conditions (e.g., UART receive FIFO reaches a threshold) or by the firing of internal timers (e.g. the event timer). The IPCM will implement at most 32 events, which occur randomly with respect to each other. Thus, events are designed to arrive at the task scheduler randomly while the task scheduler can handle 32 events at any one time.","The task scheduler  maps events to channels and prioritizes events. A channel can stall waiting on a single event. A single event can awaken more than one channel (e.g., the L1 timer). The mapping from an event to the channels it affects is under program control. There is a register for each of the 32 events which contains a bit map. There is 1 bit for each channel, which determines which channels are awakened by the event. There is also a register for each of the 32 channels which contains the priority at which the channel will operate.","A hardware scheduling block implements a scheduling algorithm such that, when a script executes an instruction that allows rescheduling, the highest priority script that has a pending event will be run.","Multiple channels may be runnable at any given time. The task scheduler  (hardwired logic) picks the highest priority channel to run when the current channel yields. Yielding channels may block on an external event or awaiting intervention by the host processor  or signal processor . The I-th channel is runnable only if the following is true;\n\n(]) & ]) & (])\n","The host enable bit HE[i], for each channel may be set or cleared by the host processor. It can be cleared by a script.","The host override enable bit, HO[i], for each channel may be set or cleared by the host processor. By setting this bit, the host processor  may allow channels that do not involve it, like a communication between the DSP  and a peripheral .","The dsp enable bit, DE[i], which is set or cleared by the dsp. It can be cleared by a script.","The dsp override bit, DO[i], which is set or cleared by the host processor. By setting this bit, the host processor can prevent the DSP from stalling a channel. This will be the case when a channel transfer does not involve the DSP.","The event pending bit, EP[i], which is an output of the task scheduler. It can be cleared by a script. It also can be set by the host to override the event\/channel connection matrix.","The event override bit, EO[i], which is set or cleared by the host processor. By setting this bit, the host processor may prevent a channel from stopping to await peripheral events. This will be the case when the channel is not handling i\/o events, e.g., a host processor to DSP DMA data transfer.","All of the HE[i], HO[i], DE[i], DO[i], ER[i], and EO[i] are set to zero on reset.","The IPCM  can clear the HE[i], DE[i], and EP[i] bits by means of the done instruction or the notify instruction. The done instruction causes a reschedule while the notify instruction does not. The done and notify instructions can clear one (and only one) of the following bits:\n\n","When several channels with the same priority are eligible; the hardwired selection tree will automatically select the channel with the highest number: i.e., if channel  and channel  with priority  are both pending, channel  will be next channel to run.","In the case of the \u201cyieldge\u201d instruction (i.e. yield if greater or equal), and channels with the same priority as the current channel are pending, the behavior is driven by the hardwired selection tree as described above. For example, given three channels (i.e. 7, 23 and 29) that have the same highest priority.","Channel  is active and runs a \u201cyieldge\u201d; it is preempted by channel ; after a while channel  runs a \u201cyieldge\u201d, it is then preempted by channel  that is the selected channel as channel  does not belong to the selectable channels because it is the current channel. Later on, channel  runs a \u201cyieldge\u201d and is preempted by channel . Channels  and  will go on switching after every \u201cyieldge\u201d until one of them terminates. It is only at that point that channel  becomes eligible. During that example, it is supposed that no other eligible channel is pending.","Referring next to , an illustration is shown which demonstrates the functionality of a specific embodiment of the task scheduler used in a custom RISC processor of  in accordance with an embodiment of the present invention. Shown is edge detection and latch unit , multiplexer , counter , Channel Enable RAM , Channel Pending Register  (EP which produces the event pending bit EP[i]), \u201cOR\u201d gate , \u201cAND\u201d gate , Channel Error Register , host enable register  (HE which produces the host enable bit HE[i]), host override enable register  (HO which produces the host override enable bit HO[i]), dsp enable register  (DE which produces the dsp enable bit DE[i]), dsp override register  (DO which produces the host override bit DO[i]), event override register  (EO which produces the event override bit EO[i]), decision tree , priority register , highest pending priority register  (HPPR), and highest pending current channel register  (HPCR).","The task scheduler  contains a 3 stage pipeline for processing and prioritizing event inputs. The first stage of the pipeline scans the event inputs and maps detected events to an active channel(s). The second stage of the pipeline maintains a list of channels requesting service (Channel Pending Register) and assigns a priority to all pending channels from the Priority RAM  while the third stage identifies the top priority and the associated channel.","The priority output of the task scheduler is applied to the RISC processor core of the IPCM and compared to the priority currently being executed by the RISC processor core. The core maintains the current priority in a Program Status Word (PSW). Priority-based preemption will occur if the task scheduler priority is greater than the current priority when a yield instruction is encountered.","The following text contains a description of the pipeline of the task scheduler.","The first stage (stage ) of the pipeline contains a 32 bit edge detection and latch unit  placed in front of a 32\u00d71 digital multiplexer  (referred to as mux or M). The mod  counter  drives the mux  select input and the mux  sequences through 32 event inputs. A logic \u201c1\u201d is applied to the 32\u00d732 entry Channel Enable RAM  for each corresponding logic \u201c1\u201d being scanned; thus mapping an event to a channel. The edge-detect latch corresponding to the event scanned is automatically cleared on the next clock cycle. A positive detect on one of the event inputs supplies a read enable signal to the Channel Enable RAM . An event can take up to 32 clocks to be detected. Once detected, an event can propagate from the mux  through the Channel enable RAM  in 1 clock cycle.","In the second stage, The Channel Enable RAM  is addressed by the same 32 bit counter  and is a square (32\u00d732) array having a single bit provided for each event across each channel. A logic \u201c1\u201d output is produced from the channel enable RAM  on the data output port if a channel is enabled and the corresponding event is detected. This signal is latched into the corresponding position within the Channel Pending Register . The detected event propagates from the Channel Enable RAM  to the Channel Pending Register  in 2 clock cycles. The Channel Pending Register  (EP) is a 32 bit register having one bit for each of the 32 channels. Note that the number of channels asserted to the Channel Pending Register  on any given clock cycle is determined by the number of bits set to \u201c1\u201d in the 32 bit mask corresponding to the address selected by the 5 bit counter. An \u201cOR\u201d gate  is used to provide \u201cpresent state feedback\u201d to trap and hold a detected event in the Channel Pending Register . Also note that a \u201cbit clear\u201d input is provided to allow the IPCM core to clear a specific bit in the Channel Pending Register . This operation is performed by the IPCM core through a software instruction when the corresponding channel has been serviced.","Lastly, a group of 32 \u201cAND\u201d gates  is used to detect the reassertion of an event which has not been serviced. In other words, if an event is signaled and the channel is already pending, then a corresponding bit signifying and overrun\/underrun condition is latched into a Channel Error Register . The host processor is then signaled of any errors in the task scheduler.","In the third stage of the pipeline, the output of former Channel Pending Register , as well as output of EO register , HE register , HO register , DE register  and DO register , and the priority register  (which stores the current priorities) to determine which channels are enabled and have to be ordered through the decision tree .","This priority tree  will deliver, on a cycle by cycle basis, the enabled channel with the highest priority (a channel \u201ci\u201d is said enabled if )EP[i]|EO[i]) & (HE[i]|HO[i]) & (DE[i]|DO[i]) is set to one for this particular channel).","In case multiple enabled channels with the same priority are eligible, the first one detected will be elected (the detection starting with channel  and going downwards; i.e., if channel  and channel  are both eligible, channel  is selected).","The \u201ctree architecture\u201d allows dynamic modification of (EP[i]|EO[i]) & (HE[i]|HO[i]) & (DE[i]|DO[i], as well as dynamic modifications of priorities.","The propagation time is one clock from the Channel Pending Register  to the FIFO.","The following is a brief summary of the steps of the task scheduler of , referring to numbers corresponding in  to the portion of FIG. that performs the step.","At step , the Digital mux  scans event inputs. All inputs are edged sensed and latched until scanned. After scanning they are automatically cleared. At step , a bit in the Channel Pending Register  is \u201cset\u201d when the corresponding bit in the event and Channel enable register  map produces a positive result. At step , the Channel Pending Register  (EP) is continuously combined with bits from the EO, DE, DO, HE and HO registers, and together with the priorities, feeds the decision tree . At step , the value in the highest pending priority register  (HPPR) presents the highest priority currently pending service to the RISC processor core. At step , the Channel Error Register  captures occasions when a channel is pending and a another subsequent event is detected on that channel. At step , the IPCM core clears single bit in Channel Pending Register  when the channel has been serviced. Once cleared, the channel may be reasserted when another event has been detected.","On execution of a done instruction the program control unit will jump to a context switch subroutine (see Appendix B\u2014EXAMPLE ROM SCRIPTS FOR RISC PROCESSOR CORE OF IPCM, and spill current context to memory. The \u201creal context switch\u201d, where CCR (Current Channel Register) (not shown in , but located within the RISC processor core of the IPCM) changes to HPCR  (Highest Pending Channel Register), takes place on execution of TstPendingAndSwitch instruction, after the current context has been spilled to memory.","The context switch program (see Appendix B) can be divided into 6 parts: (1) Load current context's spin base address; (2) Spill registers of current context to memory; (3) Test Pending Channel and react appropriately (TstpendingALnd Switch); (4) Load new context's base address; (5) Download new context; and (6) Copy shadow registers.","On execution of TstPPendingAndSwitch instruction, if there is no longer an HPPR  (Highest Pending Priority Register) is null, due to modifications of (HE[i]|HO[i]) & (EP[i]|EO[i] & DE[i]|DO[i] or priorities modifications), the RISC core will enter its IDLE mode, else the second half of the context switch script will be executed, and the context of the elected channel will be downloaded.","In case we enter IDLE mode (i.e., in case HPCR\/HPPR is empty after the context spill to memory has finished), on a new event we will continue the second half of the script and download the context of channel associated to the new event.","Once elected, Current Channel Register's status (CCR) and Current Channel Priority (CPRi) can not be modified, even if the associated (HE[i]|HO[i]) & (EP[i]|EO[i] & DE[i]|DO[i] condition transitions to zero or if the priority associated to this channel is dynamically modified by the host.","The yield (done000) will be handled on a different way in case after the spill part of subroutine, HPCR\/HPPR is empty. In this particular case, we will continue the script and download back the context we just spilled to memory.","The following portion describes several of the functional units of the IPCM .","In one embodiment, the custom IPCM includes a cyclic redundancy check (CRC) unit (not shown) which is coupled to the RISC processor. It can perform CRC calculation for a set of given polynomials from degree  to . The CRC unit includes two 32 bit registers: the CRC algorithm CA which selects the polynomial and the CRC checksum CS to accumulate the data after each processing.","After loading both registers to select the polynomial and initialize the calculation, the CRC unit is able to process one byte every clock cycle.","The DSP DMA unit  receives instructions from the RISC processor core . It is able to read and write data from\/to the DSP memory via DMA accesses and it allows 32-bit and 16-bit transfers to the Quartz DMA.","There are two major registers used by the DSP DMA : the address register (DA) that contains the address of the data to read or write in the Quartz memory and the data register (DD) that contains the data itself.","Due to its prefetch and flush capabilities, the DSP DMA  is able to perform accesses to the Quartz memory without stalling the RISC processor core so that it can execute other instructions while the DSP DMA  waits for the read or write command to complete.","The host DMA unit  receives instructions from the RISC processor core  (also referred to as the IPCM core). It is able to read and write data from\/to the embedded DRAM  or the external memory  via DMA accesses and it allows 32-bit, 16-bit and 8-bit transfers. The external memory  accesses are done through an MCORE local bus (MLB) switch.","There are two major registers used by the Host DMA : the address register (MA) that contains the address of the data to read or write in the Quartz memory and the data register (MD) that contains the data itself.","Due to its prefetch and flush capabilities, the Host DMA  is able to perform accesses to the host processor (e.g. MCORE) memory (i.e. eDRAM ) without stalling the RISC processor core  so that it can execute other instructions while the Host DMA unit  waits for the read or write command to complete. Note that MCORE is a known host or call processor.","An IPCM bus Switch allows the host DMA unit  to access external memories through the MCORE's EIM module connected to the MCORE Local Bus (MLB). It also allows other devices (such as the MCORE Test module, the NEXUS module or the GEM module) to take control of the MLB.","Furthermore, The IPCM  internally manages two power modes: RUN and IDLE. In RUN mode, all the modules of the IPCM  receive a 100 MHZ IPCM clock. The IPCM  is in RUN mode when a channel is active.","In IDLE mode, all the channels have been serviced and no more channels are pending; this is the mode after reset. Most of the IPCM modules do not receive the 100 MHZ clock any more: the RISC processor core, the functional units and the bus arbitration logic. The task scheduler  continues to work as it has to sample incoming events and decide when the RISC processor core  should start again to service a new channel. The host control modules  and DSP control modules  that hold the control registers of the IPCM  still receive the 100 MHZ clock as they may be accessed by the host processor  or the DSP  while the IPCM  is in IDLE mode. The IDLE mode conserves power, which is important in battery operated environments.","It is also possible for the host processor to completely stop the IPCM  through a clock controller. In that case, no clock at all is received by the IPCM  and it is not possible for the IPCM  to restart its clock. It is up to the host processor to restore the IPCM clock. This functional mode can be useful when no data transfers are required through the IPCM .","Afer reset (either received from the reset module or a software reset required by the host processor), the IPCM  is in idle mode; it will start its boot code located at address  once a channel is activated. Activating a channel can be done by the host processor after programming a positive priority and setting the channel bit in the EVTPEND register.","It is important to notice that when the IPCM  is in IDLE mode, it is impossible to perform the OnCE debug actions that need to execute instructions on the core; beforehand, the IPCM must be wakened by activating a channel. One possibility is to perform a debug request through the OnCE, and then activate any channel, which will start the IPCM clock and the core will immediately enter debug mode without executing any instruction. More details can be found in the OnCE specific chapter. Another possibility is to use a JTAG module to switch off IPCM clock gating, which enables it to immediately respond and does not require to have an active channel; in that mode, clocks are always running, whatever the IPCM mode.","The following text describes the software interface used to operate the programmable DMA data channels of the IPCM .","Referring next to , a diagram is shown of the pointers and memory buffers within the IPCM and the host processor memory and which are used for each of the programmable direct memory access data channels. Shown is the IPCM including table  including a pointer register , a channel enable register , DSP override register  and event override register . Also shown is the system RAM  including Table  which includes channel pointers . The system RAM  also includes Table  including a buffer pointer , count field  and mode field . And the system RAM also includes buffers .","This section describes buffer management mechanism used between IPCM  and either the host processor  (also referred to as Host MCU) or DSP . The IPCM relies on having a minimum of one or more memory buffers for each channel that is active. These channel buffers must be located in the system RAM  (e.g. eDRAM ) of the MCU and DSP (e.g. DSP RAM ) respectively. Buffers are described and managed through the use of virtual control registers implemented as a Linked-List residing in the system RAM  area of the MCU and DSP. The following describes the control structure for the Host MCU port.","Table  is a group of hardware registers located within the IPCM . The pointer register  is a 32-bit read\/write register accessible by the Host Core that contains a pointer to Table , which is a structure of pointers . The pointers  and  may reference any memory location within the system RAM .","System programmers should be advised that optimal performance is realized when Table  and Table  are located in the main system RAM  (e.g., eDRAM  in the case of a smart phone).","Table  is a fixed structure of 32 entries. Each entry represents one of the 32 IPCM DMA data channels and contains a 32-bit pointer. The IPCM  uses the pointer in Table  to find Table . Table  must be present in its entirety even when all 32 channels are not used. The IPCM  will not use pointer entries for channels which are not enabled (e.g., a bit set in the channel enable register ).","It is intended that the value of the pointer(s) in Tables  and  remain \u201cstatic\u201d for the duration of the IPCM operating session.","Table  contains the operating command and status registers, a buffer size descriptor (e.g. count field ) and a pointer  to the physical buffer  itself. The dedicated table  must be present for each of the 32 channels and is implemented as a Linked-List structure. This technique permits one or more buffers  to be allocated to a single DMA channel and thereby enables a variety of implementation schemes such as buffer swapping and daisy chaining.","In operation, the IPCM  will read the command register element of the first buffer described in the list and rise that buffer  until it is filled to capacity or closed by some event. The IPCM  will refer back to the Linked-List and open the next buffer in the list if one is declared. When the IPCM  reaches the end of the list, all buffers  will have been filled, or closed, and the specific IPCM channel referenced by Table  will be shutdown. The channel may be restarted by the MCU updating the contents of Table  for the respective channel followed by asserting the appropriate channel enable bit in the Channel Enable Register  located in the IPCM.","A variety of operating scenarios are possible using the modes provided. Buffers  may be alternately swapped, daisy chained, or operated in modulo mode. Interrupts may be generated to the Host MCU or DSP when a specific buffer is filled, or closed, by configuring the appropriate control bit within the Mode Register.","The Mode field  within the structure of Table  contains a control bit to serve as a semaphore and referred to as the \u201cD\u201d bit. When set the buffer is owned by the IPCM and the count, pointer, status, and control fields must not be changed by the MCU. When D=0, the MCU owns that particular buffer and the IPCM will not attempt to write into any of the control fields or buffer space.","Note that the channel interface to Quartz DSP is similar to that of the host MCU.","Host Processor Programming Model","The host processor  (simply referred to as the host) controls the IPCM  by means of several interface registers. They are all accessed with 0 wait-state on the ip bus interface except the once command register (ONCE_CMD) that requires 1 wait-state and the CHENENBL RAM that also requires 1 wait-state. They are all clocked with the IPCM clock (which means the Host must ensure the IPCM clock is running when it wants to access any register).","Regarding read & write authorized sizes; any read puts the 32-bit contents of the register on the bus regardless of the read size (i.e., byte enables are ignored); any write updates the contents of the register according to the required size (i.e., byte enables are used to allow writing of the corresponding byte from the bus to the register) except when writing to the CHNENBL RAM that always stores the full size word on the bus (32-bit) into the RAM, regardless of the size.","Following are the registers of the host processor used in controlling the IPCM  in accordance with one embodiment of the invention.","CPTR (Channel  Pointer). This register contains the 32-bit address, in host memory, of the array of channel control blocks starting with that for channel  (the control channel). The host has a read\/write access, the IPCM has a read-only access. On reset, this register will be all zeros. This register should be initialized by the host before it enables a channel (e.g. channel ).","INTR\u2014Channel Interrupts. This register contains the 32 HI[i] bits. If any bit is set, it will cause an interrupt to the host. This register is a \u201cwrite-ones\u201d register to the host. When the host sets a bit in this register, the corresponding HI[i] bit is cleared. The interrupt service routine should clear individual channel bits when their interrupts are serviced, failure to do so will cause continuous interrupts. The IPCM is responsible for setting the HI[i] bit corresponding to the current channel when the corresponding done instruction is executed.","STOP\/STAT\u2014Channel Stop\/Channel Status. This 32-bit register has one bit for each channel. This register is a \u201cwrite-ones\u201d register to the host. When the host writes I in bit i of this register, it clears the HE[i] and START[i] bits. Reading this resister yields the current state of the HE[i] bits.","START\u2014Channel Start. This 32-hit register has one bit for each channel. This register is a \u201cwrite-ones\u201d register to the host. Neither START[i] bit can be set while the corresponding HE[i] bit is cleared. When the host tries to set the START[i] bit by writing a one, if the corresponding HE[i] bit is clear, the bit in the START[i] register will remain cleared and the HE[i] bit will be set. If the corresponding HE[i] bit was already set, the START[i] bit will be set. The next time the IPCM channel i attempts to clear the HE[i] bit by means of a done instruction, the bit in the START[i] register will be cleared and the HE[i] bit will take the old value of the START[i] bit. Reading this register yields the current state of the START [i] bits. That mechanism allows the Host to pipe-line two START commands per channel.","EVTOVR\u2014Channel Event Override. This register contains the 32 EO[i] bits. A bit set in this register causes the IPCM to ignore events when scheduling the corresponding channel. Writing in this register overwrites the previous value.","DSPOVR\u2014Channel DSP Override. This register contains the 32 DO[i] bits. A bit set in this register causes the IPCM to ignore DSP enable when scheduling the corresponding channel.","HOSTOVR\u2014Channel HOST Override. This register contains the 32 HO[i] bits. A bit set in this register causes the IPCM to ignore HOST enable when scheduling the corresponding channel.","EVTPEND\u2014Channel Event Pending. This register contains the 32 EP[i] bits. Reading this register allows the host to determine which charnels have events pending. Setting a bit in this register causes the IPCM to reevaluate scheduling as if a peripheral event destined for this channel had occurred (this a \u2018write-ones\u2019 mechanism: writing an \u20180\u2019 does not clear the corresponding bit). This is useful for starting up channels, so that initialization is done before awaiting the first event. The task scheduler can also sets bits in the EVTPEND register, according to the received events. The EP[i] bit may be cleared by the done instruction when running channel I script.","DSPENMBL\u2014Channel DSP Enable. This register contains the 32 DE[i] bits (from the DSP Control module or control registers). This register enables the host to determine which channels the DSP has enabled.","RESET\u2014Reset Register. This register contains two control bits: (1) the reset bit (RESET[0]), when set causes the IPCM to be held in software reset. The reset has to be held some cycles before it cam be released. Actually a counter is used to keep the soft reset (soft_rstB low) active during these cycles. The soft_rstB signal is driven low as the reset bit is set. The reset bit is cleared by the IPCM. And (2) The resched bit (REST[i]), when set, forces the IPCM to reschedule. as if a script had executed a done instruction. This allows the host to recover from a runaway script on a channel by clearing its HE[i] bit via the STOP register and then forcing a reschedule via the RESCHED bit of the RESET register. When the context switch starts. the resched bit is cleared by the IPCM.","EVTERR\u2014Event Error Register. This register is used by the IPCM to warn the host when an incoming event was detected and it triggers a channel that is already pending or being serviced. That probably means there is an overflow of data for that channel. This is a \u201cwrite-ones\u201d register for the scheduler; it is only able to set the flags; the flags are cleared when the register is read by the Host or during IPCM reset.","Any EVTERR[i] bit is set when an event that triggers channel i has been received through the event input pins and the EP[i] bit is already set; the EVTERR[i] bit is unaffected if the Host tries to set EP[i] bit whereas that EP[i] bit is already set.","This register is NOT the same as the DSP EVTERR: when the Host reads and clears it, the same information is still available in the DSP register.","INTRMASK\u2014Channel Interrupt Mask Flags. This register contains 32 interrupt generation mask bits. If bit INTRMASK[i] is set, the HI[i] bit is set and an interrupt is sent to the Host whenever an event error is detected on channel i (i.e., EVTERR[i] is set).","PSW\u2014Scheduler Status. This is a 16-bit register with the following status information: [4:0]CCR (current channel register); [7:5]CCP (current channel priority); [12:8]NCR (next channel register); and [15:13]NCP (next channel priority).","EVTERRDBG\u2014Event Error Register for Debug. This register is the same as EVTERR except reading it does not change its contents (i.e., it is not cleared); that address is meant to be used in debug mode: the MCU OnCE may check that register value without modifying it.","ONCE_ENB\u2014OnCE Enable. That one-bit register selects the OnCE control source; when cleared (0), the JTAG controls the OnCE; when set (1), the Host controls the OnCE through the registers described below. After reset, the Once enable bit is cleared (JTAG controls).","ONCE_CMD\u2014OnCE Command Register (1 wait state). Writing to that register will cause the OnCE to execute the written command; when needed, the ONCE_DATA and ONCE_INSTR registers should be loaded with the correct value before writing the command to that register.","CSWADDR\u2014Context Switch Address. A 15-bit register that contains the context switch address (bits \u2013) and an enable bit (14); when the enable bit is set, the context switch routine is assumed to start at the address contained in bits \u2013. The reset value of that register is 0 for the enable bit and decimal  for the context switch address.","ILLINSTADDR\u2014Illegal Instruction Trap Address. Bits \u2013 of this register contain the address where the IPCM jumps when an illegal instruction is executed; it is 0x0001 at reset.","CHNADDR\u2014Channel  Address. This 13-bit register is used by the boot code or the IPCM: after reset, it points to the standard boot routine in ROM (channel  routine); by changing that address, the user has the ability to perform a boot sequence with his own routine. The very first instructions of the boot code fetch the contents of that register (it is also mapped in the IPCM memory space) and jump to the given address. The reset value is 0x0050 (decimal ).","CHNENBL\u2014Channel Enable RAM. The Host Control module contains a 32\u00d732 channel enable RAM. This channel enable RAM contains the event\/channel correspondence map. Any event can trigger any possible combination of channels according to the contents of that RAM.","CHNPRI\u2014Channel Priority Registers. This set of 32 registers contains the priority of every channel; that number is comprised between 1 and 7. 0 is a reserved value used by the IPCM hardware to detect when no channels are pending.","DSP Programming Model","The DSP  has some limited, compared to the host processor  (i.e. host), control over the IPCM  via several interface registers. Each register occupies two 16-bit words to accommodate all 32 channels. All registers operate in the same manner as there host processor counterparts. The CEVTOVR and CDSPOVR registers are not implemented in the DSP interface.","All addresses, such as the CPTR, are comprised of one 32-bit word that may address any location within the Quartz memory space (4 Gbytes).","All registers are clocked with the IPCM clock (which means the Host must ensure the IPCM clock is running when the DSP is supposed to access those registers).","Regarding read & write authorized sizes: any read puts the 32-bit contents of the register on the bus, regardless of the read size (i.e., byte enables are ignored); any write updates the contents of the register according to the required size (i.e., byte enables are used to allow writing of the corresponding byte from the bus to the register).","The following are the registers of the DSP used in controlling the IPCM  in accordance with one embodiment of the invention.","CPRT\u2014Channel  Pointer. This register contains the 32-bit address, in DSP memory, of the array of channel control blocks starting with CCB for channel  (the control channel). The DSP has a read\/write access, the IPCM has a read-only access. On reset, this register will be all zeros. This register should be initialized by the DSP before any channels are enabled.","INTR\u2014Channel Interrupts. This register contains the 32 DI[i] bits. If any bit is set, it will cause an interrupt to the host. This register is a \u201cwrite-ones\u201d register to the host. When the host sets a bit in this register the corresponding DI[i] bit is cleared. The interrupt service routine should clear individual channel bits when their interrupts are serviced, failure to do so will cause continuous interrupts. The IPCM is responsible for setting the DI[i] bit corresponding to the current channel when the corresponding done instruction is executed.","STOP\/STAT\u2014Channel Stop\/Channel Status. This 32-bit register has one bit for every channel. This register is a \u201cwrite-ones\u201d register to the DSP. When the DSP writes a 1 in bit I of this register, it clears the corresponding DE[i] and START[i] bits. Reading this register yields the current state of the DE[i] bits.","START\u2014Channel Start. This 32-bit register has one bit for each channel. This register is a \u201cwrite-ones\u201d register to the DSP. Neither START[i] bit can be set while the corresponding DE[i] bit is cleared. When the DSP tries to set the START[i] bit by writing a one, if the corresponding DE[i] bit is clear, the bit in the START [i] register will remain cleared and the DE[i] bit will be set. If the correspondent DE[i] bit was already set, the START [i] bit will be set. The next time the IPCM channel I attempts to clear the DE[i] bit by means of a done instruction, the bit in the START [i] register will be cleared and the DE[i] bit will take the old value of the START[i] bit. Reading this register yields the current state of the START[i] bits. That mechanism allows the DSP to pipe-line two START commands per channel.","EVTERR\u2014Event Error Register. This register is used by the IPCM to warn the DSP when an incoming event was detected and it triggers a channel that is already pending or being serviced. That probably means there is an overflow of data for that channel. This is a \u201cwrite-ones\u201d register for the scheduler. It is only able to set the flags; the flags are cleared when the register is read by the DSP or during IPCM reset.","Any EVTERR[i] bit is set when an event that triggers channel i has been received through the event input pins and the EP[i] bit is already set; the EVTERR[i] bit is unaffected if the Host tries to set the EP[i] bit whereas that EP[i] bit is already set.","This register is not the same as the Host EVTERR. When the DSP reads and clears it, the same information is still available in the Host register.","INTRMASK\u2014Channel Interrupt Mask Flags. This register contains 32 interrupt generation mask bits. If bit INTRMASK[i] is set, the DI[i] bit is set and an interrupt is sent to the DSP whenever an event error is detected on channel i (i.e., EVTERR[i] is set).","PSW\u2014Scheduler Status. This is a 16-bit register with the following status information: [4:0]CCR (current channel register); [7:5]CCP (current channel priority); [12:8]NCR (next channel register); and [15:13] NCP (nest channel priority).","EVTERRDBG\u2014Event Error Register for Debug. This register is the same as EVTERR except reading it does not change its contents (i.e. it is not cleared); that address is meant to be used in debug mode. The DSP OnCE may check that register value without modifying it.","IPCM Programming Model","Each programmable DMA data channel has eight general purpose registers of 32-bits for use by scripts. General register  has a dedicated function for the loop instruction, but otherwise can be used for any purpose.","Functional Unit State. Each channel context has some state that is part of the functional units. The specific allocation of this state is part of the functional unit definition. This state must be saved\/restored on context switches.","Program Counter Register (PC). The PC is 14 bits. Since instructions are 16-bits in width and all memory in the IPCM is 32-bits in width, the low order bit of the PC selects which half of the 32-bit word contains the current instruction. A low order bit of zero selects the most significant half of the word (i.e. big-endian).","Flags. Each channel has 4 flags: The T bit reflects the status of some arithmetic and test instructions. It is set when the result of an addition or a subtraction is zero and cleared otherwise. It is also the copy of the tested bits. Finally it can also be set when the loop counter ((GReg) reaches zero; when the last instruction of the hardware loop is an operation that can modify the T flag, its effect on T is discarded and replaced by the GReg Status.","Two additional bits, SF and DF, are used to indicate error conditions resulting from loading data sources and storing to destinations, respectively. Access errors set these bits, and successful transactions clear them. They can also be cleared by specific instructions (CLRF and LOOP. The SF (source fault) is updated by loads LD and LDF; the DF (destination fault) is updated by stores ST and STF.","Access errors are caused by several conditions: writing to the ROM, writing to read-only memory mapped register. accessing art unmapped address or any transfer error received by a peripheral when it is accessed.","The SF and DF flags have a major impact on the behavior of the hardware loop: if SF or DF is set when starting a hardware loop and it is not masked by the LOOP instruction, the loop body will not be executed; now, inside the loop body, if a load or store sets the corresponding SF or DF flag, the loop exits immediately. Testing the status of the T flag at the end of the loop (as well as testing both SF and DF) tells If the loop exited abnormally as any anticipated exit prevents Greg from reaching the zero value and thus setting the T flag. This is also valid if the fault occurs at the last instruction of the last loop.","The last flag is the loop mode flag, LM, which indicates when the processor is currently operating in loop mode. It is set by the LOOP instruction and is cleared after execution of the last instruction of the last loop.","Return Program Counter (RPC). The RPC is 4 bits. It is set by the jump to subroutine instructions and used by the return from subroutine instruction. Instructions are available to transfer its contents to and from a general register.","Loop Mode Start Program Counter (SPC). The SPC is 14 bits. It is set by the loop instruction to the location immediately following it.","Loop Mode End Program Counter (EPC). The EPC is 14 bits. It is set by the loop instruction to the location of the next instruction after the loop.","Context Switching. Each channel has a separate context consisting of the 8 general purpose registers and additional context representing the state of the functional units. The active registers and functional units contain the context of the active channel. The context of in inactive channels are stored in IPCM RAM which is part or the IPCM address space. A context switch stores the active registers into the context area of the old channel and loads the new context from the context area of the new channel. It exactly requires 47 IPCM cycles to complete.","It is possible to define a custom context switch routine. The user has to store it wherever possible in RAM and its start address must be written in the CSWADDR control register via the MCORE. With that option it is not possible to achieve a similar cycle count as the built-in routine (i.e., 47 cycles) as all loads and stores will require 2 cycles to complete instead of 1 cycle in the ROM routine (1 cycle to perform the load\/store plus 1 cycle to fetch the next instruction: both accesses use the RAM, which means they cannot be done in parallel).","Memory Mapped Registers. The IPCM core has access to several registers through the system bus.","Host Channel  Pointer (MCPTR). Contains the address, in the MCU memory space, of the initial IPCM context and scripts, that are loaded by the IPCM boot script which is running on channel . This is a read-only register.","DSP Channel  Pointer (DCPTR). Contains the address, in the DSP memory space, of the initial IPCM context and scripts, that are loaded by the IPCM boot script which is running on channel . It is unused for now. This is a read-only register.","Current Channel Register (CCR). Contains the 5-bit priority of the channel whose context is installed. This is a read-only register.","Current Channel Priority (CCPR). Contains the 3-bit priority of the channel whose context is installed. This is a read-only register.","Highest Pending Channel Register (HPCR). Contains the decoded 32-bit number of the channel the task scheduler has selected to run next. A bit is set to \u201c1\u201d at position or channel selected (e.g., if HPCR contains value 0x04000000, channel  is the next channel selected by the scheduler). This is a read-only register.","Highest Pending Priority (HDPR). Contains the 3-bit priority of the channel the scheduler has selected to run next. This is a read-only register.","Current Channel Pointer (CCPTR). Contains the start address of the context data for the current channel: its value is CONTEXT_BASE+20*CCR (CONTEXT_BASE=0x0800); this is a read-only register.","CHNADDR. Contains the address of the channel  routine programmed by the MCORE; it is loaded into a General register at the very start of the boot and the IPCM jumps to the address it contains. By default, it points to the standard boot routine in ROM.","Address Space. The IPCM has two internal busses: the Instruction bus used to read instructions from the memory; and the data bus used to access the same memories as those visible on the instruction bus, plus some memory mapped registers (scheduler status and OnCE registers) and 5 peripheral registers (USB, UART1, UART3, MMC & Video SAP).","Instruction Memory Map. It is based on a 14-bit address bus and a 16-bit data (instruction) bus; instructions are fetched from either program ROM or program RAM. An IPCM script is able to change the contents of the program RAM that is also visible from the data bus.","The first two instruction locations (at  and ) are special. Location  is where the PC is set on reset. Location  is where the PC is set upon the execution of an illegal instruction. It is expected that both of these locations will contain a jmp to handler routines.","Data Memory Map. All of the data accessible to IPCM scripts make tip the data memory space or the IPCM. This address space has several components: ROM, RAM, peripheral registers, and scheduler registers (CCR, HPCR and CCPTR) and OnCE registers. IPCM scripts can read and write to the context RAM, data RAM and peripheral registers.","The address range is 16 bits and the data width os 32 bits; however, when accessing peripheral registers (USB, etc.), the data width may be different; in that case, during a write, the unused part of the 32-bit data to write is ignored by the peripheral; during a read, the missing part of the 32-bit read data is replaced by \u20180\u2019s.","IPCM Initialization","After hardware reset, the IPCM , the program RAM, context RAM, and data RAM have unpredictable contents. The active register set is assigned to channel  and the PC is initialized to all zeros. However, since the channel enable register is all zeros, there are no active channels and the IPCM is halted.","To start up the IPCM, the host processor  (i.e. host) first creates some channel control blocks in host memory for the control channel (channel ) and then initializes the channel  pointer register to the address of the first control block. It then sets bit  (corresponding to channel ) in the channel enable register.","Upon being enabled, the IPCM  then begins executing the script located at address  in the program ROM for channel . This ROM  script will read the channel  pointer register and, using the address contained therein, begin fetching (using DMA) the first channel control block. If the block contains a valid command, it interprets the command (which will normally be to download something from host to IPCM memory) and proceeds to implement the command and move on to the next control block. This continues until an invalid channel command is reached, at which time the script will halt, awaiting the host to re-enable the channel again.","There are also two means to make the IPCM boot on a user-defined script. First, by using the OnCE (either via its Jtag interface of its MCORE interface) to download any code in the IPCM RAM and force the IPCM to boot on that code; second, by using the CHNOADDR register in the Host programming model; the IPCM boot code fetches the contents of that register and jumps to the given address.","The execution of an IPCM script depends on both the instructions that make up the script and the data context upon which it operates. Both must be initialized before the script is allowed to execute. Each of the 32 channels has a separate data context, but may share scripts and locations in data RAM.","The host manages the space in program RAM and data RAM. It also manages the assignment of IPCM channels to the device drivers that need them. Channels are initialized by the host by using channel  to download any required scripts and data values and the channels initial context. The context contains all the initial values of the registers, including the PC. Then the host  enables the channel and the channel becomes active and begins fetching and executing instructions from its script.","Refer to attached Appendix A entitled INSTRUCTION SET FOR RISC PROCESSOR CORE OF IPCM, which describes a complete set of preferred instructions for use in the IPCM  in accordance with one embodiment of the present invention.","The following further describes the DSP DMA unit and the host processor DMA unit corresponding to the embodiment employing the instruction set of Appendix A. functional units.","The functional unit instructions cause an 8-bit code, found in the low 8-bits of the instruction, to be asserted on the functional unit control bus. Some of these bits are used to select one of several functional units. In order to establish a programming convention, we will assume the selection bits are some number of the most significant bits of the 8-bit code. Furthermore, some number or the least significant bits will be decoded by a given functional unit to establish the type of operation to perform.","For the host DMA unit , the DMA instructions control the DMA state machine and may cause a DMA cycle on the associated memory bus. There are three registers associated with the host DMA unit, an address register (MA), a data buffer (MD) and a state machine register (MS).","The address register (MA) contains the pointer into DMA memory associated with the next data transfer. It has byte granularity. Reading the register with the ldf instruction (i.e. read) has no side effects. Writing the address register may have side effects. If there is value write data in the buffer, and the address is changed, the write data will be flushed (i.e., a DMA write cycle will be issued). If the prefetch bit is set and if there are no valid write data, a DMA read cycle will be issued with the new address.","As data is transferred to or from the data buffer, the address register is incremented by the number of bytes transferred\/ Of the address increments across a 32-bit word boundary any valid write data in the buffer will be flushed.","In the data buffer register (MD), a DMA cycle is not always associated with a stf instruction which loads the write buffer, the instruction may just load a subunit of transfer into the buffer register as it accumulates bytes which will be later used in full size memory transfers. The DMA unit keeps state as to which bytes are valid and does the correct shifting and insertion of new data. The instruction that loads the write buffer can conditionally cause the resulting buffer to be flushed, causing a DMA write cycle, even if the buffer is not entirely filled.","A ldf instruction that reads the data buffer, may cause a DMA cycle if the data has not already been fetched. Each read transfer can conditionally cause a prefetch, if all the bytes in the buffer have been transferred.","Writes and reads of the data buffer may cause destination or source faults, respectively. As the MLB does not support 24-bit accesses, the Host DMA triggers an error when a 3-byte access is requested on the MLB. That only no occurs when a flush or a fetch is requested; the internal MD register can have a 3-byte data at any moment as far as no external access is performed. The eDRAM supports 3-byte accesses.","There is the special case of the flush: using byte accesses to MD, it is possible to have 3 active bytes and request a flush; the 3 active bytes in MD will be correctly written to the eDRAM; but the access will cause an error if the write is done on the MLB.","The state register (MS) contains the DMA state-machine value. It is not meant to be accessed by the user in normal mode. In fact, as context switches may occur while the DMA is in any state, it is necessary to save that state, which is done by the context switch routine.","The Prefetch and Flush management allows the IPCM RISC machine to go on while a DMA access is performed. When the RISC Core requires a prefetch (p=1) or an auto-flush (f=0) to the Host DMA, it will receive an immediate transfer acknowledge before the DMA has finished the external access; which allows the RISC Core to do other things like accessing another DMA machine.","However, the user must be aware of the inherent limits of that mechanism: as far as the DMA has not a FIFO stack to store commands, if a prefetch\/auto-flash command is issued, whereas the DMA has not finished its previous access, the transfer acknowledge will be delayed until the preceding access is over.","Another point is the management of errors: as the DMA immediately sends an acknowledge to the RISC Core, it assumes no error will occur (except if it detect the access is forbidden like a 24-bit access to the MLB). If an error occurs, it will be flagged (transfer error acknowledge) for the following DMA access.","That should not be a problem if the DMA is used properly. The prefetch\/auto-flush feature is meant to be used in hardware loops and a last access with no prefetch (p=0) or a forced flush (f=1) should be performed after the hardware loop: that access will gather any remaining error (its own as well as an error from the previous prefetch or auto-flush access).","The DSP DMA Unit  is functionally identical to the host DMA unit  with minor restrictions. It allows 32-bit and 16-bit transfers to the Quartz DMA.","The DMA instructions control the DMA state machine and may cause a DMA cycle on the associated memory bus. There are three registers associated with the host DMA unit, an address register (DA), a data buffer (DD) and a state machine register (DS).","The address register (DA) contains the pointer into DMA memory associated with the next data transfer. It has byte granularity. Reading the register with the ldf instruction has no side effects. Writing the address register may have side effects. If there is valid write data in the buffer, and the address is changed, the write data will be flushed (i.e., a DMA write cycle will be issued). If the prefetch bit is set and if there are no valid write data, a DMA read cycle will be issued with the new address.","As data is transferred to or from the data buffer, the address register is incremented by the number of bytes transferred. If the address increments across a 32-bit word boundary any valid write data in the buffer will be flushed.","In the data buffer register (DD), a DMA cycle is not always associated with a DMA write instruction which loads the write buffer. The instruction may just load a subunit of transfer into the buffer register as it accumulates bytes which will be later used in full size memory transfers. The DMA status keeps state as to which bytes are valid and does the correct shifting and insertion of new data. The instruction that loads the write buffer can conditionally cause the resulting buffer to be flushed, causing a DMA write cycle, even if the buffer is not entirely filled.","A DMA read instruction that reads the data buffer, may cause a DMA cycle if the data has not already been fetched. Each read transfer can conditionally cause a prefetch, if all the bytes in the buffer have been transferred.","Writes and reads of the data buffer may cause destination or source faults, respectively. As the Quartz DMA does not support byte accesses, the DSP DMA detects any unauthorized access size and triggers an error accordingly. Unauthorized sizes are 1 byte and 3 bytes. That only occurs when a flush or a fetch is requested. The internal DD register can have a I-byte or a 3-byte data at any moment as far as no external access is performed.","The state register (DS) consists of 00110000 32-bit read with no side effect.","The Prefetch and Flush management allows the IPCM RISC processor to go on while a DMA access is performed. When the RISC Core requires a prefetch (p=1) or an automatic flush (f=0) to the Host DMA, it will receive an immediate transfer acknowledge before the DMA has finished the external access; which allows the RISC Core to do other things like accessing another DMA machine.","However, the user must be aware of the inherent limits of that mechanism: as far as the DMA has not a FIFO stack to store commands, if a prefetch\/auto-flush command is issued whereas the DMA has not finished its previous access, the transfer acknowledge will be delayed until the preceding access is over.","Another point is the management of errors: as the DMA immediately sends an acknowledge to the RISC Core, it assumes no error will occur (except if it detects the access is forbidden like a 24-bit access to the MLB). If an error occur, it will be flagged (transfer error acknowledge) for the following DMA access.","That should not be a problem if the DMA is used properly: the prefetch\/auto-flush feature is meant to be used in hardware loops and a last access with no prefetch (p=0) or forced flush (f=1) should be performed after the hardware loop: that access will gather any remaining error (its own as well as an error from the previous prefetch or auto-flush access).","Programming Conventions","Much of the programming model as seen by the host or DSP is not mandated by the hardware architecture of the IPCM, but rather by the scripts that run on the IPCM. Some of these scripts will be in ROM so the conventions they impose are not easily changeable.","On the host processor side, There are 32 channel control blocks (CCBs) in a array whose base address is specified in the CPTR. Each control block consists of four 32-bit words. The first word will contain status which is currently undefined. The second word contains a pointer to the base of an array of buffer descriptors (Bds). The third word contains a pointer to the current BD. The fourth word is currently unused.","The contents of a channel control block may only be changed by the host when the channel is not running.","The host buffer descriptors (refer to ) form an array of programmable size, the last buffer descriptor is marked as such. The array of buffer descriptors is treated as a ring, with some logically contiguous portion owned by the host, and the remainder by the IPCM. A status bit indicates the ownership of each buffer descriptor.","When a buffer descriptor changes ownership from the host to the IPCM, the count field indicates how much data is to be transmitted or the size of the receive buffer. When ownership reverts back to the host, the count indicates how much data was transmitted or received.","Channel  Commands. The COMMAND field of a buffer descriptor contains an 8-bit command code used to communicate between the host and the IPCM. Currently the channel  script recognizes only the following commands: (1) Set the IPCM address to be used in subsequent commands to the value contained in the buffer address field; (2) Copy from the host memory at buffer address to the IPCM memory; (3) Copy to the host memory at buffer address from the IPCM memory; (4) Copy from the host memory to the channel context of the channel number in the high 5 bits; and (5) Copy to the host memory from the channel context of the channel number in the high 5 bits.","On the DSP side, there are 32 channel control blocks (CCBs) in a array whose base address is specified in the CPTR. The CCB for channel  is not used. Each channel control block consists of eight 16-bit words\/The first two words will contain status which is currently undefined. The second two words contain a pointer to the base of an array of buffer descriptors (Bds). The third two words contain a pointer to the current BD. The fourth two words are currently unused.","Referring briefly back to , the processor platform is illustrated including the refresh controller responsible for refreshing the dynamic random access memory, i.e. eDRAM. The refresh controller  is coupled to the eDRAM  via the r bus  through the data path select , which acts to multiplex access to the eDRAM from other competing devices, such as the IPCM , the host processor , and the LCD controller .","As is known in the art, dynamic memory (DRAM or eDRAM) is required to be provided DC power and refreshed periodically so that the data stored in the memory is retained. In contrast, static memory (e.g. SRAM) does not need to be refreshed as long as a constant power supply is coupled thereto. The refresh controller  of one embodiment of the processor platform  is designed to conserve as much power as possible, which for handheld applications is advantageous in extending battery life.","The refresh controller  has two basic modes of operation: an active mode and a data retention mode. The active mode is invoked during normal operation of the eDRAM . The active mode is used anytime the product incorporating the processor platform  is operated by the end-user. The active mode uses a \u201ccycle stealing\u201d distributed refresh method as known in the art of discrete DRAM implementations.","Data retention mode is invoked when the product incorporating the processor platform  is not operational and it is desired to retain the contents of the eDRAM . This data retention mode has three operating modes: (1) distributed refresh method, (2) a \u201cselective refresh\u201d method and (3) a \u201ctemperature compensated\u201d refresh method.","The distributed refresh method as known in the art is identical to the active mode of operation in that the memory is refreshed periodically, whereas the selective refresh and the temperature compensated refresh may be used individually or together in order to reduce the amount of power required to retain data in the eDRAM memory array or may be used together to achieve a further overall reduction in the power consumed to retain data, which results in a longer battery life in which is particularly important to handheld applications.","Even though the active mode and distributed refresh technique are well known in the art, the refresh controller  advantageously uses a low frequency clock source from a time of day module operating at 32 kHz, although in other embodiments any clock known in the art may be used. Thus, in preferred embodiments, the clock input  to the refresh controller  is the time of day clock required for use in the product incorporating the processor platform . This 32 kHz clock input  is multiplied (\u00d72) within the refresh controller  and used to activate the refresh cycle. As is known in the art, a counter is provided within the refresh controller  having \u2018n\u2019 number of states where \u201cn\u201d is equal to the total number of rows in the array. The counter is incremented modulo \u2018n\u2019 with each clock transition. \u201cSense amplifiers\u201d, as known in the art, perform the actual refresh of the selected bit cells within the rows.","Advantageously, the refresh controller  uses the already provided time of day clock as the clock input; thus, eliminating the need for a separate dedicated clock to run the refresh controller  as is done conventionally. Employing a separate dedicated clock for the refresh controller  further adds to the power consumed by the system when the power is off.","Referring next to , The selective refresh method advantageously reduces the numbers of rows in the memory (e.g. eDRAM ) to be refreshed in order to reduce power consumption at the expense of reducing the number of memory cells that will be retained. For example, if the memory (i.e. DRAM) is divisible into multiple portions, one or more of the multiple portions of the memory may be refreshed without refreshing all of the multiple portions. Specifically, the multiple portions may be rows of memory in an array. Thus, the contents of the rows of the memory being refreshed will be saved, while the contents of the data held in memory rows not being refreshed will be lost. For example, while the device is being shut down by the user (e.g. turned off), the host processor  makes a determination of which rows within the memory, e.g. eDRAM , need to be saved and which portions (e.g. rows) do not need to be saved (Step ). Next, the host processor  sends a control signal to the refresh controller  instructing which rows or portions of the host processor memory is desired to be saved (Step ). The refresh controller  is configured to refresh only the identified rows or portions within memory for the duration of time that the power is off. Then, the refresh controller  accesses the host processor memory (e.g. eDRAM  through the data path select ) and refreshes the configured rows (Step ). Thus, less power is consumed in the refresh of the memory since only part of the memory is being refreshed, instead of the entire memory being refreshed. In this embodiment, this provides quite a savings in power since the eDRAM  is large and typically less than the entire eDRAM  needs to be saved.","The selective refresh method implemented by the refresh controller  is described as follows. Given that there are n rows within the memory array, e.g. eDRAM , define j as the total number of rows in the memory array to be refreshed such that j is a number between 0 and n. The algorithm then becomes:\n\ni=0\n\nRefresh Row\n\n1 modulo \n","In other words, the refresh controller  modulo \u2018n\u2019 counter is reduced to a modulo (n\u2212a) counter where \u2018a\u2019 is the number of rows to be omitted from the refresh activity.","Referring next to , a flowchart  is shown of the steps of the refresh controller  of  in performing the temperature compensated method of memory refresh. The temperature compensated method of memory refresh adjusts the periodicity of the refresh activity based on ambient temperature of the product. At room temperature and below, this can save a considerable amount of power, which is important to increasing battery life in battery operated handheld devices.","Generally, the higher the temperature, the more often a given memory, e.g. eDRAM, is required to be refreshed. Prior art approaches design the refresh rate of a refreshing unit around \u201cworst case\u201d scenarios in which the product incorporating the DRAM would be at an unusually high default temperature. As such, for most of the time, the memory is actually \u201cover-refreshed\u201d. However, in size and power conscious applications, such as for use in the processor platform  used as a multimedia wireless handheld device where power consumption is desired to be minimized, such \u201cover-refreshing\u201d may lead to a waste of power in operating the refresh controller more than necessary.","Thus, in contrast to conventional refresh controllers, the default temperature assumed for the refresh controller  is very low, such that the default refresh rate is less (i.e. the time in between refreshes is longer), often resulting in a savings of power. However, the temperature of the product may be at this low temperature or below, but at other times the ambient temperature of the product will be above this low refresh rate temperature. Unless the refresh rate is compensated for higher temperatures, the data retained in the DRAM will be lost in between refresh cycles. Thus, the temperature compensated method of refreshing measures the ambient temperature of the product in order to determine if the refresh rate needs to be increased or if it can remain at a slower refresh cycle in order to save power. When the ambient temperature of the product is high, the time between refresh cycles is decreased.","Specifically, the temperature compensated refresh method is described below. First, given a digital timer circuit that is clocked with an accuracy of +\/\u2212100 ppm and having a resolution of at least 0.1 second. The timer shall be capable of measuring time using a suitable clock signal and signaling an \u201cevent\u201d after a pre-programmed time has elapsed. The timer shall have a register which is set to an integer value and is used to represent a pre-programmed value elapsed time to be measured. Also given an electronic digital thermometer circuit providing an indication range of x to y degrees with an accuracy of +\/\u201cj\u201d degrees and further given a translation table consisting of a non-volatile memory array (e.g. a pre-programmed ROM) of \u201cn\u201d elements with each element containing an integer number herein referred to as \u201ccount\u201d. The bounds of the array (i.e. number of elements) are determined by the following equation: n=y\u2212x, where n is the number of array elements and x and y upper and lower temperature range limits.","The absolute value and range of \u201ccount\u201d must be compatible with the absolute value and range of the \u201ccount\u201d register that is supported in the digital timer. Each \u201ccount\u201d entry is assigned to occupy one element within the array. The entries of \u201ccount\u201d are ordered in the array in a linear ascending manner such that the first element in the array corresponds to the lowest measured temperature (i.e. x) and the last element in the array corresponds to the highest measured temperature (i.e. y).","The value assigned to each count entry is made from empirical data taken from actual samples of the actual DRAM memory device intended to be used. As an alternative, the values for \u201ccount\u201d may be determined through computer simulation methods of the leakage characteristics of the transistors used in the memory array as a function of changes in ambient temperature. In either case, the value of \u201ccount\u201d is to represent the minimum refresh rate necessary to maintain data integrity at a specific temperature within the range of x to y degrees. Each element in the array is to represent an incremental change in ambient temperature staring at temperature x and incrementing to temperature y. The contents of each element is to represent the minimum necessary refresh rate to maintain data integrity. Additional tolerance must be given to accommodate digital temperature accuracy \u201cj\u201d as well as memory operating voltage tolerance and expected unit to unit variation. It is expected that while the elements of the array are ordered in linear fashion with respect to temperature, the values of \u201ccount\u201d may represent an exponential characteristics.","The temperature compensated refresh method operating procedure begins by refreshing all rows in the memory array (Step ). Note that rows to be refreshed may be governed by \u201cselective refresh method\u201d described above with reference to , such that Step  may be refreshing less than all of the rows (portions) of memory in the memory array. Next, an ambient temperature is measured (Step ) using digital thermometer. Next, the ambient temperature measurement is translated to a count value using a look-up table (Step ). The lookup table represents various refresh rates at different temperatures determined through simulation and empirical data. If the measured temperature is out of bounds for the lookup table then the first element, in the case exceeding the lower boundary \u201cx\u201d, or the last element, in the case of exceeding the higher boundary \u201cy\u201d, should be chosen. The count value is applied to the digital timer circuit (Step ). Once the timer \u201cevent\u201d has expired, i.e. the digital timer circuit expires (Step ), refresh all rows; thus, repeating Steps  through . All steps are repeated indefinitely until the product is turned on (Step ); thus, active refresh mode is re-entered (Step ).","Thus, by employing the temperature compensated refresh method of memory refresh, power is conserved, especially at or below room temperature operating environments, in comparison to a standard refresh operation, e.g. the distributed refresh method.","The \u201ctemperature compensated mode\u201d together with the \u201cselective refresh mode\u201d can advantageously be operated simultaneously in order to consume the lowest possible data retention power. The operating modes of the refresh controller are configured by the host processor via signaling overt the h bus  prior to product shut down. The refresh controller  automatically reverts to the \u201cNormal\u201d refresh mode of operation (e.g. distributed refresh) when the host processor  re-enters the active state, i.e. the power is turned on. The transition between data retention and normal operation (active mode) is performed seamlessly without requiring any intervention from the host processor .","Referring next to , a block diagram is shown of a memory refresh system  using the selective refresh technique and the temperature compensated refresh techniques of . Shown is a time of day clock , binary counters  and , comparators  and , partial refresh register , host processor  (host MCU ), count register , memory array , digital temperature measurement , temperature sensor , refresh enable flip flop , clear signal , set signal , refresh enable signal  and refresh row enable .","Consistent with the descriptions associated with , a digital temperature sensor  measures an ambient temperature. This temperature measurement  is sent to memory array  and translated into a count value according to a look up table stored in the memory array, as described above with reference to . The count value corresponds to a time measurement in between refresh cycles for various operating temperatures. The count value is copied into a count register . This count value is then compared to the value of binary counter  by comparator  coupled therebetween. Binary counter  is coupled to the time of day clock  such that it counts according to real time.","When the value in binary counter  equals the count value in the count register , the comparator  outputs a set signal  to set the refresh enable flip-flop  to activate a refresh cycle, i.e. the refresh enable flip-flop  outputs a refresh enable signal  (e.g. refresh enable signal  goes high or \u201c1\u201d). At this point, after an amount of time determined according to the temperature the memory is refreshed. The set signal  is also output back to binary counter  (resetting it back to zero or another reference starting point) and to the digital temperature measurement , which is re-loaded into the memory array  in order to determine the next variable amount of the time for the next refresh cycle. If the temperature remains the same, the time in between refresh cycles remains the same. As the temperature changes, the time in between refresh cycles will change. For example, if the temperature drops, then the time in between refresh cycles is lengthened, advantageously conserving power since, the refresh cycle is less often.","Additionally, the host processor is coupled to a partial refresh register  such that the host processor  loads a value into the partial refresh register  indicating what portion of the system memory to refresh, e.g. which rows to refresh and which rows not to refresh. The value is the partial refresh register  is then compared to the value of binary counter  by comparator  coupled therebetween. Binary counter  is also coupled to the time of day clock , but does begin to start counting until comparator  outputs the set signal  which is also coupled to binary counter . Thus, once the refresh cycle (refresh enable signal is output) is activated by the set signal  into the refresh enable flip-flop , then the binary counter  begins to count.","Once the value in binary counter  equals the value in the partial refresh register , the comparator outputs a clear signal  to the refresh enable flip-flip  and back to the binary counter . The clear signal resets binary counter  and causes the refresh enable flip-flop to disable the refresh enable signal  (e.g. the refresh enable signal  goes low or \u201c0\u201d). This effectively stops the refresh process such that less than the entire portion of the memory is refreshed (as determined by the host processor prior to power off) which advantageously conserves power. Note that in this embodiment, the binary counter also counts a number corresponding to the refresh row address in memory (DRAM), i.e. refresh row address signal .","The memory refresh system shown in  advantageously uses both the selective refresh technique and the temperature compensated refresh technique to synergistically reduce power consumption during the refreshing of DRAM. The components used are well known in the art. Most of the components may be a part of the refresh controller  of  depending on the embodiment. For example, in one embodiment, the temperature sensor , temperature measurement  and memory array  are located on a separate chip, while the host processor is located on the same processor platform. The partial refresh register , comparators  and , binary counters  and , count register , and the refresh enable flip-flop  are all part of the refresh controller .","While the invention herein disclosed has been described by means of specific embodiments and applications thereof, numerous modifications and variations could be made thereto by those skilled in the art without departing from the scope of the invention set forth in the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The above and other aspects, features and advantages of the present invention will be more apparent from the following more particular description thereof, presented in conjunction with the following drawings and Appendices A and B wherein:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 3","FIGS. 1 and 2"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 4","FIGS. 1"],"b":["2","3"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 5","FIG. 2"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 7","FIG. 2"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 8","FIG. 2"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 9","FIGS. 7 and 8"]}]},"DETDESC":[{},{}]}
