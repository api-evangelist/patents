---
title: Naming service implementation in a clustered environment
abstract: A method and system for providing naming operations. Contexts are created and organized hierarchically under an initial context. The hierarchy is retained in a non-persistent storage medium. The objects and contexts created as a result of various naming operations are removed from the naming system responsive to a reboot of a server. In one embodiment, the entire naming hierarchy is represented in nested hash tables with a nesting level of only two.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08028002&OS=08028002&RS=08028002
owner: SAP AG
number: 08028002
owner_city: Walldorf
owner_country: DE
publication_date: 20040527
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","Embodiments of the invention relate to naming. More specifically, embodiments of the invention relate to naming systems in which naming operations are performed locally with the results stored in non-persistent memory.","2. Background","Naming service broadly refers to the mechanism by which an object is associated with a name and by which objects may be found given their names. Each name is generated by a set of syntactic rules called, \u201cnaming convention\u201d. An atomic name is an indivisible component of a name as defined by the naming convention. The association of the atomic name with an object is called, \u201cbinding.\u201d Some objects cannot be stored directly so they are put in the system as references. A \u201creference\u201d is an object, which contains one or some addresses of objects which themselves are not directly bound to the naming system. Every name is interpreted relative to some context, and every naming operation is performed in a context object. A \u201ccontext\u201d is a set of bindings in which names are relative to a certain naming convention. A client may obtain an initial context object that provides a starting point for resolution of names in the naming system. Every naming system consists of contexts of a certain type (one and the same naming convention) that provide the same identical set of operations. Every operation is relative to a certain namespace. A \u201cnamespace\u201d is the set of names in the naming system. The naming service organization of the namespace is a treelike structure of naming context objects that can be traversed to locate a particular name.","A directory service is a naming service that allows each bound object to be associated with attributes and provides a way to retrieve an object by looking up some of its attributes rather than its name (search). The \u201cattributes\u201d are object characteristics. Both the attributes and the object itself form a directory object. A \u201cdirectory\u201d is a linked set of directory objects.","In a Java context, basic support for the naming and directory service is provided by a Java Naming and Directory Interface (JNDI) such as specified in , Version 1.2, published by Sun Microsystems of Mountain View, Calif. and subsequent revisions thereof (the JNDI Specification). The JNDI Specification meets the system requirements of Java 2 Enterprise Edition (J2EE). These requirements are defined in the Java 2 Enterprise Edition Specification 1.3, published Jul. 27, 2001 or subsequent versions thereof (the J2EE Standard). JNDI is defined to be independent of any specific directory service implementation. This permits a variety of directories to be accessed in a common way.","Various naming services use a database management system (DBMS) service to store data resulting from naming operations. The storage within the database insures persistency of the naming operations in the event that the node goes down. One such example is depicted in .  is a diagram of a portion of naming tree and corresponding database representation used in one existing JNDI compatible naming service. The naming tree  shows the objects and contexts maintained in the database representation . As previously noted, the data is stored and managed in a database by the DBMS service. In this database representation , all contexts are represented as hierarchical structures of containers. As represented, the root container  contains the object1 container  and in the subcontext1 container . The subcontext1 container  contains object2 container  and the subcontext2 container . In this example, the only way to read the data  corresponding to object2 is by traversing through the root container  and then through the subcontext1 container  and then through the object2 container . In this example, since a single name space is used system wide, each naming operation must use a unique name for every object. These traversals and the required interaction with the DBMS service slow the performance of the naming service. Moreover, the stability of the naming service then also depends on the stability of the DBMS service.","A method, apparatus and system to implement a naming service are disclosed. A server node and a non-persistent storage unit are provided. A hierarchical naming structure is stored in the non-persistent storage during operation. When the server is rebooted, the hierarchical naming structure is removed from the non-persistent storage.","Embodiments of the invention include a system and method of providing many operations in a clustered environment. The results of naming operations are retained in a non-persistent memory local to the creating server. Responsive to the reboot of the server all preexisting naming relationships are removed from the naming system. By using local memory, the speed of naming operations increases relative to the speed of operations in other existing naming services with persistent data storage.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2","b":["200","210","220","210","220","214","216","218","224","226","228","212","222","214","216","218","224","226","228","260","263","270","273","200","202","204","210","220","200","210","220"]},"Server nodes , ,  within instance  provide the business and\/or presentation logic for the network applications supported by the system. Each application server, for example  and , provides a set of core services ,  to the business and\/or presentation logic. Among the services provided is naming service , . In one embodiment, the naming service ,  stores data and objects resulting from naming operations, referred to collectively as \u201cnaming data\u201d, in the memory implementation ,  of its respective virtual machine , . The memory implementation ,  by its nature is non-persistent. As a result, when a server goes down and reboots the naming data is not retained. Accordingly, on reboot, the server is assured of a clear name space. Moreover, because the naming operations are not reliant on a DBMS, efficiency and reliability of the naming service is improved.","Each of the server nodes , ,  within a particular instance  may be configured with a redundant set of application logic and associated data. In one embodiment, dispatcher  distributes service requests from clients to one or more of server nodes , ,  based on the load on each of the servers. For example, in one embodiment, a dispatcher implements a round-robin policy of distributing service requests (although various alternate load-balancing techniques may be employed). In one embodiment, the dispatcher performs load balancing on naming service requests from remote clients. However, once a remote client has received an initial context from a certain server node, the subsequent naming requests from that client are directed to the same server node.","In one embodiment of the invention, server nodes , ,  are Java 2 Platform, Enterprise Edition (\u201cJ2EE\u201d) server nodes which support Enterprise Java Bean (\u201cEJB\u201d) components and EJB containers (at the business layer) and Servlets and Java Server Pages (\u201cJSP\u201d) (at the presentation layer). A J2EE platform complies with the J2EE Standard. In one embodiment, the naming service is compliant with the JNDI Specification. Of course, certain aspects of the embodiment of the invention described herein may be implemented in the context of other software platforms including, by way of example, Microsoft .NET platforms and\/or the Advanced Business Application Programming (\u201cABAP\u201d) platforms developed by SAP AG, the assignee of the present application. Microsoft Net Platforms implement the Active Directory Service Interfaces (ADSI) such as Active Directory Service Interfaces Version 2.5 published by Microsoft Corporation of Redlands, Wash. or other versions thereof (the ADSI Standard). Thus, in the context of a .Net platform, the naming service would be compliant with the ADSI Standard.","In one embodiment, communication and synchronization between each of instances  and  is enabled via central services instance . As illustrated in , central services instance  includes messaging service  and locking service . Message service  allows each of the servers within each of the instances to communicate with one another via a message passing protocol. For example, messages from one server may be broadcast to all other servers within the cluster via messaging service . In addition, messages may be addressed directly to specific servers within the cluster (e.g., rather than being broadcast to all servers).","In one embodiment, locking service  disables access to (i.e., locks) certain specified portions of program code and\/or configuration data stored within a central database . Locking managers  and  employed within the server nodes lock data on behalf of various system components which need to synchronize access to specific types of data and program code (e.g., such as the configuration managers  and ).","In one embodiment, messaging service  and locking service  are each implemented on dedicated servers. However, messaging service  and the locking service  may be implemented on a single server or across multiple servers while still complying with the underlying principles of embodiments of the invention.","As illustrated in , each server node (e.g., , ) includes a lock manager ,  for communicating with locking service ; a cluster manager ,  for communicating with messaging service ; and a configuration manager ,  for communicating with central database  (e.g., to store\/retrieve configuration data). Although lock managers  and , cluster managers  and , and configuration managers  and  are illustrated with respect to particular server nodes,  and , in , each of the server nodes , ,  and  and\/or on the dispatchers ,  may be equipped with equivalent lock managers, cluster managers, configuration managers, and services.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 3A","FIG. 5","FIG. 3B"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 3B","FIG. 3A"]},"As noted above, where the basic object forms part of a context, the link identifier is equal to the container identifier of the container object, which the basic object is linked to form the context. However, where the object is merely a basic object not forming a context, the link identifier is selected to be a value that cannot be a container identifier. In one embodiment of the invention, the link identifier for all objects not forming a context is negative one (\u22121).",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 4A","FIG. 1","FIG. 3A"],"b":["100","402","404","418","418","406","406","412","428","428","414","410","404","412","412","404"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 4B","FIG. 4A","FIG. 4A"],"b":["450","284","402","406","410","420","422","450"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 4C","b":["420","422"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 5","b":"500"},"At start up of the naming service, an initial context factory builder is established as a default factory builder in the javax.naming.spi.NamingManager such that a JNDI Application Programming Interface (API)  will access the initial context factory builder implementation when an initial context is requested by a client . The initial context factory builder will provide a proper initial context factory implementation  depending on the environment properties supplied by the client. The initial context of factory implementation  will return either offset client context  or client context  depending on the properties of the environment. Client Context always returns the root context, which is an abstraction that forms a starting point for all subsequent naming operations. The returned context may then be organized under the root context or any subcontext within the naming tree dependent on the rights of the client. In one embodiment, only applications will be provided an instance of offset client context . Offset client context  is an extension of client context  and indicates that the context is other than the root context. This prevents application from accessing or creating objects higher up the naming tree. Applications are allowed to perform naming operations only in their own namespace, e.g., the context returned as initial context and the subcontexts created under it.","Client context  has an instance of server context interface which will be either server context implementation , if a client is local or a stub to the server context implementation if the client is remote. Remote clients may use Remote Method Innovation (RMI) to pass messages to the server context implementation. Local client can communicate directly without using RMI.","Server context implementation  is connected to the JNDI memory implementation , which functions as the naming repository in one embodiment of the invention. Also, in some embodiments of the invention, server context implementation  may be connected to a naming cache . Naming cache  may be used to increase the speed of lookup operations in the naming system. In one embodiment, the naming cache  holds object instances for application clients running on the server and byte arrays of the objects for all other clients.","In one embodiment, the naming cache includes two concurrent hash tables and a cache communicator. A first hash table keeps every cached object as byte array and name. Elements are added in this hash table any time a client performs a lookup operation. The second hash table keeps every cached object as an object instance and name. Elements are added in this hash table only if an application running on a local server performs a lookup operation. The cache communicator (CC) is registered as a message listener and performs the communication among the naming services in the different server nodes in the cluster. The CC is used to notify the cluster about the changes in cache, which concern global objects. If an unbind, rebind or rename operation is performed over a global object, the object will be removed from cache on the current server and a message with object name will be sent to all other servers to inform them of the invalid global object.","In one embodiment, JNDIMemoryImp1  is the implementation of the non-persistent naming data management within the naming service. JNDIMemoryImp1  keeps the hash tables of the containers stored by name and by ID and a handle to the root container object, which keeps hash tables of all the objects and sub contexts that can be found in the root context of the naming system stored by name and ID. All other containers have the same structure as the root container but are available for direct access. Thus the whole hierarchical tree like structure of objects and contexts in a naming system may be organized in hash tables with only two levels of nesting.","The following example of operation in one embodiment of the invention illustrates operations in response to local and global objects. For example, client performs a bind (String name, Object object) operation. First in ClientContext  the object parameter is wrapped in a directory object (DirObject) instance, serialized, if possible, and the byte array is sent to ServerContextImp1  where the type and correctness of the operation are evaluated.","In ServerContextImp1 , if the operation involves a local object: the object is passed to a bind method of JNDIMemoryImp1 . An object ID that is unique to the server is generated. The byte array representation of the object, the object ID, the type of the operation and the link ID identifying the container object linked to this object are wrapped in an Obj object and placed against the object name in the hash table instance of the container corresponding to the context in which the object has to be placed. In one embodiment, the link ID is the container ID (if the object represents a context) or \u22121 otherwise.","If the operation involves a global object, the object is still passed to the bind method of JNDIMemoryImp1 , but the method generates an object ID of type long that is unique for the entire cluster. In one embodiment, this ID is generated from two integers\u2014the server ID of the current server node and the consecutive number of the global bound object. The byte array representation of the object, the object ID, the type of the operation and the link ID form an Obj object, which is put against the object name in a hash table instance of a container corresponding to the context in which the object should be placed. Using the messaging service, (see ), messages containing the ID, the name and the byte array representing the object, a byte parameter which shows whether the object is remote or not, and the name of the container in which the object should be placed are sent to all server nodes in the cluster. The name of the container is unique in the cluster and shows the full path name from the root context to the requested context. In one embodiment, the sender server does not wait to receive answers from the other server nodes whether the bind operation is performed successfully.","When a new server node is connected to the cluster it sends a message with a specific ID via the messaging service to an arbitrary server node with a request that information for all global objects and context to be sent to it. This message \u201carrives\u201d in the CacheCommunicator instance of the receiver server and calls a method of JNDIMemoryImp1. Naming tree is recursively searched for global objects and contexts and if such are found they are sent as messages with all additional information to the server from which the request has been sent. The other server receives the messages and executes the operations locally. If the container in which the global object must be place does not exist, it is created and the object is put in it. If a part of the path of contexts from the root context to the context in which the object must be placed does not exist, all the missing intermediate contexts from the path are created. The names for the contexts are taken from the name of the container in which the object must be placed\u2014it contains the whole path. In one embodiment, no responses are returned to the server, which sends the messages whether the replication is executed correctly or not.","Before every lookup operation, a check is made whether the looked up object is a global remote object, e.g. it is a global object created by a remote server node. If the object is a global remote object, the creating server is checked to insure the server remains in the cluster, e.g. has not shut down or crashed. If the creating server remains in the cluster, the object is returned as a result from the operation. Otherwise, the object is deleted from the hash table of the corresponding container and a message is sent to all other server nodes to delete the object from the hash table in their respective containers. If the object is not a global remote object, it is returned as a result from the operation.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 6","b":"602"},"At decision block , a determination is made if an object is serializable. If it is, at block  a serialized directory object is received from a client at the server side naming implementation. At block , the naming service generates a basic object from the serialized directory object. At block , the basic object is placed in a designated container within the naming hierarchy. This may take the form of placing the object in the hash table of the container objects. As previously noted, such hash table is retained in non-persistent storage. A determination is made at decision block  if the subcontext is to be created with the object. If so, at block , the naming service creates a new container instance. At block , the basic object is linked to the new container instance to form a context. At block , the Container of the context is stored in the table of containers in non-persistent memory. In one embodiment, this non-persistent storage may be a memory implementation of a Java virtual machine. If at decision block  no context was to be created, the routine ends. If at decision block  no serialized directory object is received (implying that the created object is non-serializable), naming system handles non-serializable object at block . In one embodiment of the invention permits non-serializable objects to be bound within the naming system, but requires all data for such objects to be maintained on the client side. In such embodiments, the non-serializable objects are only available to the client which has bound them and all the clients running on the same VM.","By virtue of the fact that this storage is non-persistent, in the event that a reboot of the system or the server occurs, objects and context stored in the non-persistent storage are guaranteed to be removed from the naming system. As a result, naming service rebuilds the naming hierarchy on reboot without concerns of conflict from any preexisting naming hierarchy.","Elements of embodiments may also be provided as a machine-readable medium for storing the machine-executable instructions. The machine-readable medium is an article of manufacture and may include, but is not limited to, flash memory, optical disks, CD-ROMs, DVD ROMs, RAMs, EPROMs, EEPROMs, magnetic or optical cards, propagation media or other type of machine-readable media suitable for storing electronic instructions. For example, embodiments of the invention may be downloaded as a computer program which may be transferred from a remote computer (e.g., a server) to a requesting computer (e.g., a client) by way of a communication link (e.g., a modem or network connection).","It should be appreciated that reference throughout this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Therefore, it is emphasized and should be appreciated that two or more references to \u201can embodiment\u201d or \u201cone embodiment\u201d or \u201can alternative embodiment\u201d in various portions of this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures or characteristics may be combined as suitable in one or more embodiments of the invention.","In the foregoing specification, the invention has been described with reference to specific embodiments thereof. It will, however, be evident that various modifications and changes can be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. It should be noted that references to \u201can\u201d or \u201cone\u201d embodiment in this disclosure are not necessarily to the same embodiment, and such references mean at least one.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4C"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
