---
title: System and method for configuring software for distribution
abstract: A method for distributing software is provided. The method includes configuring a first software system of a software suite, such as by installing it on a processor. A first set of configuration data associated with the first software system is then stored. A second software system of the software suite is then configured, and a second set of configuration data associated with the second software system is then stored. Conflict resolution rules are then applied to the first set of configuration data and the second set of configuration data. The first set of configuration data and the second set of configuration data are then compared to determine whether any conflicts exist, and the first set of configuration data and the second set of configuration data are assembled for installation on one or more processors if no conflicts exist.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06983449&OS=06983449&RS=06983449
owner: Electronic Data Systems Corporation
number: 06983449
owner_city: Plano
owner_country: US
publication_date: 20020315
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is related to U.S. patent application Ser. No. 09\/435,300, entitled \u201cSystem and Method for Integrating Software Management and Distribution,\u201d filed Nov. 5, 1999.","The present invention pertains to the field of software distribution. More specifically, the invention relates to a system and method for configuring software for distribution that identifies conflicts between two or more components in a software suite and resolves the conflicts before distributing the software.","Systems for enterprise software distribution are known in the art. For example, it is known to prepackage software for distribution over an existing enterprise network, such as a local area network, a wide area network, or a combination of such networks. The prepackaged software is then installed on one or more preselected workstations, such as by using a point-to-point message protocol, a broadcast protocol, or a publish and subscribe message protocol.","Many problems have been encountered with such software distribution schemes. One problem is that prepackaging of software usually includes installing two or more software systems on a processor, correcting any problems, and then storing the configuration of the software applications for distribution. Identification of problems is usually performed by operator testing, such that if an operator does not discover a problem during testing, the problem will be present on all nodes that receive the distribution package. This process results in many problems in enterprises having a large number of nodes, where the nodes differ significantly in the types of hardware and software available at each node. Operators must then manually correct problems at each node, resulting in additional expenses for such operators and lost productivity at each node.","In accordance with the present invention, a system and method for configuring software for distribution are provided that overcome known problems with systems and methods for configuring software for distribution.","In particular, a system and method for configuring software for distribution are provided that process components of software suites to identify conflicts prior to assembly of the components into software suites.","In accordance with an exemplary embodiment of the present invention, a method for distributing software is provided. The method includes configuring a first software system of a software suite, such as by installing it on a processor. A first set of configuration data associated with the first software system is then stored. A second software system of the software suite is then configured, and a second set of configuration data associated with the second software system is then stored. Conflict resolution rules are then applied to the first set of configuration data and the second set of configuration data. The first set of configuration data and the second set of configuration data are then compared to determine whether any conflicts exist, and the first set of configuration data and the second set of configuration data are assembled for installation on one or more processors if no conflicts exist.","The present invention provides many important technical advantages. One important technical advantage of the present invention is a system and method for configuring software for distribution that identifies files, settings, and dependencies for each software component in a suite and determines whether any conflicts exist for such files, settings, and dependencies prior to the assembly of the components into a software suite. Rules can thus be created for resolving such conflicts, which prevents inadvertent failure to correct problems, such as by failing to identify the problem through operator testing.","Those skilled in the art will further appreciate the advantages and superior features of the invention together with other important aspects thereof on reading the detailed description that follows in conjunction with the drawings.","In the description that follows, like parts are marked throughout the specification and drawings with the same reference numerals, respectively. The drawing figures might not be to scale, and certain components can be shown in generalized or schematic form and identified by commercial designations in the interest of clarity and conciseness.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1","b":["100","100"]},"System  includes application distribution system , which can be implemented in hardware, software, or a suitable combination of hardware and software, and which can be one or more software systems operating on a general purpose server platform. As used herein, a software system can include one or more objects, agents, lines of code, threads, subroutines, databases, application programming interfaces (APIs), web browser plug-ins, or other suitable data structures, source code (human readable), object code (machine readable), and can include two or more different lines of code or suitable data structures operating in two or more separate software applications, on two or more different processing platforms, or in other suitable architectures. In one exemplary embodiment, a software system can include one or more lines of code or other suitable software structures operating in a general purpose software application, such as an operating system, and one or more lines of code or other suitable software structures operating in a specific purpose software application. In another exemplary embodiment, a software system can be implemented as a distributed software system, on a different processing platform than that shown in the exemplary embodiments herein, or in other suitable manners.","Application distribution system  is used to distribute packages of software that have been assembled for installation on an endpoint, such as using an assembly system and method described in U.S. patent application Ser. No. 09\/435,300, entitled \u201cSystem and Method for Integrating Software Management and Distribution,\u201d filed Nov. 5, 1999, which is hereby incorporated by reference for all purposes. An endpoint can be a suitable processor platform, such as a laptop computer, a desktop computer, a workstation, a handheld device, a peripheral component such as a scanner, a printer, a copy machine, a fax machine or other suitable systems having a processor and processing capabilities.","Application distribution system  is coupled to primary router . As used herein, the term \u201ccouple,\u201d and its cognate terms such as \u201ccouples\u201d and \u201ccoupled,\u201d can include a physical connection (such as through a copper conductor), a virtual connection (such as through randomly assigned memory locations of a data memory device), a logical connection (such as through one or more logical devices of a semiconducting circuit), a hypertext transfer protocol connection, other suitable connections, or a suitable combination of such connections. In one exemplary embodiment, systems and components are coupled to other systems and components through intervening systems and components, such as through an operating system of a general purpose server platform.","Application distribution system  provides files to primary router  for distribution to a plurality of endpoints. Application distribution system  coordinates the transmission of files used for configuring the software applications so that the distribution of the software applications to the endpoints is optimized. Primary router  is used to distribute the files as a plurality of messages in a modified publish and subscribe format, where the address for each message is assigned by application distribution system  based on the location of the endpoints.","Primary router  can be implemented in hardware, software, or a suitable combination of hardware and software, and can be one or more software systems operating on a general purpose server platform. Primary router  is an application layer router, as opposed to a hardware layer router. In one exemplary embodiment, in the Open Systems Interconnection (OSI)networking model, an application layer router would operate in layer  of the OSI model, whereas a physical layer router would operate in layer  of the OSI model. Thus, primary router  can operate on a suitable network node that is normally not used for software distribution, such as a server, a workstation, or other suitable processing platforms. In this manner, primary router  can be selected based on an optimal network architecture, as opposed to using an existing hardware layer router that may not be optimally located for distribution of software in an enterprise.","Primary router controller  is coupled to primary router , and performs control of primary router . In one exemplary embodiment, primary router controller  can be implemented in hardware, software, or a suitable combination of hardware and software, and can be one or more software systems operating on a general purpose server platform. Primary router controller  receives messages from primary router  and stores the messages for subsequent transmission to other nodes in the distribution system. In one exemplary embodiment, primary router controller  stores messages that include one or more files, and then provides the messages to primary router  for transmission at predetermined times, upon the occurrence of predetermined events, or in other suitable manners. The processor resources of primary router  can thus be optimized, so as to facilitate rapid distribution of software throughout the enterprise from a centralized location.","Primary router  is coupled to secondary router  and secondary router , such as through a network. Secondary router , secondary router , secondary router controller  and secondary router controller  can each be implemented in a manner similar or identical to that of primary router  and primary router controller , respectively. Secondary router  and secondary router  receive messages containing files for distribution to endpoints from primary router . The messages are addressed and distributed in a modified publish and subscribe process that uses the connection between secondary router  and primary router  as a first channel, and the connection between secondary router  and primary router  as a second channel. In this manner, primary router  distributes messages to secondary router  and secondary router  by posting those messages to the corresponding channel. Thus, files to be distributed through primary router  and secondary router  and secondary router  can be addressed using a conventional publish and subscribe process where the message is addressed by identifying the channel to which the message should be routed, but where the \u201csubscription\u201d process is performed using standard network messaging functions.","Secondary router controller  and secondary router controller  are used to store and process the messages and files as they are received, so that the messages and files can then be routed through secondary router  and secondary router , respectively, in accordance with router processor capacity, bandwidth of the communications media, at predetermined times, in response to predetermined events, or based on other suitable criteria.","Secondary router  is coupled to endpoint  and endpoint , and secondary router  is coupled to endpoint  and endpoint , such as by a single network connection, two network connections as shown, or other suitable communications media. Files are transmitted in the form of messages from secondary router  to endpoints  and , and from secondary router  to endpoints  and , such as upon receipt of notification of a predetermined event, after the expiration of a period of time, or in accordance with other suitable routing commands. In addition, the addressing of messages from secondary router  to endpoint  and endpoint  is performed by using a modified publish and subscribe message format. In this manner, application distribution system  can address files for distribution to endpoints  through  by identifying the first channel to secondary router  or secondary router , and the second channel to the endpoint, where the existing network messaging software is used to install the files on the endpoints from the secondary routers. Thus, system  uses a modified publish and subscribe message format to distribute software in an enterprise, so as to deploy software systems on a large number of endpoints. System  allows the transmission of large numbers and sizes of files over application layer routers and communications media that does not overload the processor capabilities of the routers, and that does not overload the bandwidth of the communications media. In this manner, application distribution system  can sequence the distribution of files in a manner that optimizes the existing system architecture.","Gateway  can be implemented in hardware, software, or a suitable combination of hardware and software, can be one or more software systems operating on a general purpose server platform. In one exemplary embodiment, gateway  is an existing server node in a network that is used as an application layer gateway for the purpose of facilitating enterprise software distribution. The enterprise software distribution process may require response messages to be generated by endpoints  through  and transmitted back to application distribution system  or other suitable systems. Gateway  can be used to return messages in response to event notification messages or other data transmitted through primary router  to secondary routers  or  so as to trigger subsequent transmission of messages to endpoints  and . Gateway  is coupled to endpoints  through , such as through the network connection between secondary routers  and secondary router , or by other suitable means. Thus, gateway  can be used to receive and coordinate message transmissions from endpoints  through  to application distribution system  or other suitable systems.","In operation, system  can be used to distribute software in an enterprise that includes a large number of nodes in geographically dispersed areas. System  allows software to be transmitted to each node using modified publish and subscribe messaging that uses existing network communications systems and allows file transmission to be coordinated through timing or in response to events, and to optimize the use of application layer router processing capabilities and bandwidth of network connections. In this manner, application distribution system  can determine an optimal processor and bandwidth loading based on the distribution of software to endpoints, and can further address files for distribution to endpoints in a manner that does not require those files to be individually addressed, broadcast, or that does not require the endpoints to determine the files that are needed and to subscribe to channels to receive such files. In this manner, application distribution system  can provide a sequence of file distribution based on optimized routing practices, such as by transmitting messages to endpoints to determine configuration information and then sequencing specific software to endpoints based on geographical, functional, or other parameters and network bandwidth and resources.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 2","b":["200","200","102","202","204","206","208","210","212"]},"Endpoint configuration system  includes endpoint configuration data for a plurality of endpoints in an enterprise. In one exemplary embodiment, endpoint configuration system  can include a database of processor configuration data that identifies the location of each processor, the applications that are required for each processor, the groups to which the processor operators are assigned, processors having multiple operators, and other suitable information. This processor configuration data is used by endpoint configuration system  to identify software that should be transmitted to each endpoint in an enterprise software distribution event.","Bandwidth allocation system  receives message routing data and provides bandwidth allocation data in response to the message routing data. In one exemplary embodiment, bandwidth allocation system  tracks bandwidth availability for a software distribution path based on message routing data, such as by using modified publish and subscribe routing in which each channel that is required to transmit a message to an endpoint is contained in the address for the message, in addition to the total number of endpoints that will be receiving the message. Bandwidth allocation system  can generate bandwidth availability data, such as in response to a query from application distribution system  or other suitable systems, so as to allow such other systems to sequence messages accordingly. Likewise, bandwidth allocation system  can receive message data that includes priority data, and can sequence the messages based upon available bandwidth and message routing data contained in the modified publish and subscribe format.","Response sequencing system  receives message routing data and provides response sequencing data in response to the message routing data. In one exemplary embodiment, response sequencing system  tracks bandwidth availability for a response message path based on message routing data, such as by determining the maximum response message load that can be generated when a plurality of endpoints generate a response to a transmitted message. Response sequencing system  can determine bandwidth availability or processor capacity data, and can provide a time, event, or priority ranking for transmitted messages to ensure that the response messages can be transmitted to the required destination.","Memory resource allocation system  receives message routing data and provides memory resource allocation data in response to the message routing data. In one exemplary embodiment, memory resource allocation system  tracks memory resource availability for a software distribution path based on message routing data, such as using modified publish and subscribe routing in which messages need to be stored at application routers in response to bandwidth availability or other variables. Memory resource allocation system  can generate memory resource availability data, such as in response to a query from application distribution system  or other suitable systems, so as to allow such other systems to sequence messages accordingly. Likewise, memory resource allocation system  can receive message data that includes priority data, and can sequence the messages based upon available memory resources and message routing data contained in the modified publish and subscribe format.","Processor resource allocation system  receives message routing data and provides processor resource allocation data in response to the message routing data. In one exemplary embodiment, processor resource allocation system  tracks processor resource availability for a software distribution path based on message routing data, such as using modified publish and subscribe routing in which each channel required to transmit a message to an endpoint is contained in the address for the message, in addition to the total number of endpoints that will be receiving the message. Processor resource allocation system  can generate processor resource availability data, such as in response to a query from application distribution system  or other suitable systems, so as to allow such other systems to sequence messages accordingly. Likewise, processor resource allocation system  can receive message data that includes priority data, and can sequence the messages based upon available processor resources and message routing data contained in a modified publish and subscribe format.","Event based sequencing system  generates event based sequencing control data for inclusion in a message. In one exemplary embodiment, event based sequencing system  can determine whether the occurrence of an event is required prior to transmitting a message. For example, receipt of a \u201cWakeOnLAN\u201d message may be required before files are transmitted, or receipt of a first file may be required prior to transmission of a second file. Event based sequencing system  can include event confirmation control data that requires receipt of confirmation data from application distribution system , nodes, or other system components before transmitting a message. Likewise, event based sequence system  can receive event notification from systems operating on a router or router controller, such as timer systems, bandwidth availability monitors, processor loading monitors or other suitable systems.","In operation, system  allows files to be organized as messages, and messages to be sequenced for distribution to a plurality of processors in an enterprise. System  allows the distribution of files to be organized so that files are transmitted in accordance with optimal bandwidth allocation, optimal memory resource allocation, optimal processor resource allocation, optimal response sequencing allocation for response gateways or other response systems, and optimal event based sequencing. System  thus allows files to be sequenced so as to facilitate file distribution in an optimal time period.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 3","b":["300","300","302","304","306","308","310","312"]},"File cache system  receives messages, including one or more files, and stores the messages for subsequent transmission to one or more endpoints. File cache system  can store the messages in a random access memory, a magnetic storage media, or other suitable storage media based on the expected amount of time that a given file will be stored. In one exemplary embodiment, file cache system  can determine whether a file will be stored for a predetermined amount of time or until an event occurs, and can store the file in a storage medium based upon the expected amount of storage time for the file.","Message receiving system  receives messages including routing data, such as publish and subscribe distribution data, and payload data that can include files for distribution and corresponding control data, event messages that are used to trigger event based message distribution (such as timing messages, processor availability messages, bandwidth availability messages, or other suitable messages), and other suitable payload data. Message receiving system  then performs a message preparation function on the message. In one exemplary embodiment, a message preparation function can include extracting payload data for processing by message timing system , event based message system , or other suitable systems, preparing the message for retransmission to another router through message transmission system , or other suitable message preparation functions.","Message transmission system  assembles address data and payload data into a message for transmission by a router. In one exemplary embodiment, the message transmission system  can assemble files into payload data and append publish and subscribe address data based on control data received from message timing system , event based message system , message receiving system , or other suitable systems. In another exemplary embodiment, message transmission system  can transmit data to another router or router controller, such as bandwidth availability data, processor capacity data or other suitable messages.","Message timing system  performs timing functions for distribution of messages. Message timing system  can sequence messages in accordance with timing control data associated with each message, can start one or more timers based on receipt of messages with associated timer control data, and can perform other suitable functions.","Event based message system  tracks messages with event based transmission functions and generates message transmission control data upon the occurrence of an event. In one exemplary embodiment, event based message system  can store a list or other suitable structures with the events, and can monitor event messaging to determine whether an event has occurred. In another exemplary embodiment, event based message system  can perform queries or other suitable functions to determine whether an event has occurred. Event based message system  can further compile files and other data into a message to be transmitted upon the occurrence of an event.","In operation, system  provides control for an application layer router in a software distribution system for an enterprise. System  allows modified publish and subscribe messaging to be used to distribute messages in an enterprise software distribution system, in which messages are published based upon priority, time, bandwidth capacity, processor capacity, events, or other occurrences. System  thus allows the existing network to be used in an enterprise to distribute software to a plurality of endpoints in a manner that optimizes the software distribution process.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 4","b":["400","400"]},"Method  begins at , where software distribution data is received. In one exemplary embodiment, the software distribution data can include data identifying suites of software to be distributed, where the suites further comprise a plurality of software components, where each component includes a plurality of files. Likewise, the software distribution data can identify classes of machines that should receive different software suites and components based upon the function of the node, the location of a node, the geographic location of a node, the location of a node within an organization, or other suitable functions. The method then proceeds to .","At , the endpoints associated with the software distribution data are identified. In one exemplary embodiment, endpoints can be classed based upon various geographical data, organizational data, functional data, or other suitable data, where the network address for the endpoint is correlated based on these various factors. After the endpoints are identified, the method proceeds to .","At , it is determined whether a response is required to the message. In one exemplary embodiment, a message can include a control command that causes the processor to perform a function, such as activating an Intel WakeOnLAN Network Interface Card that causes a computer that is off to activate, an inventory scan function that causes the computer to transmit a list of files stored on the computer, a heartbeat query that causes a computer to respond if it is active, or other suitable responses. If it is determined at  that a response is not required, the method proceeds to . Otherwise, the method proceeds to  where a response to sequencing is performed. In one exemplary embodiment, the response to sequencing can include an analysis of the priority in which responses should be received, the bandwidth available between endpoints that will be receiving the response message and the application requiring the response, such as an application distribution system , the processing capacity of an application layer gateway or other suitable systems that are used to coordinate transmission of responses to the application, and other suitable constraints or factors. The method then proceeds to .","At , the bandwidth requirements for the messages are determined. In one exemplary embodiment, bandwidth requirements can be based on total bandwidth required for a group of messages, the bandwidth required at various points and the message transmission path to endpoints, or other suitable bandwidth requirements. The method then proceeds to .","At , it is determined whether the amount of bandwidth required is greater than available bandwidth. If the amount of bandwidth required is not greater than available, the method proceeds to . Otherwise, the method proceeds to  where bandwidth sequencing is performed. In one exemplary embodiment, bandwidth sequencing can be performed by using the priority of messages, the priority of endpoints, can be based on an analysis of bottleneck constraints, such as areas in which the bandwidth is a constraint on distribution for other areas, or other suitable factors. The method then proceeds to .","At , resource requirements are determined for distribution of the messages throughout the enterprise. In one exemplary embodiment, resource requirements can include the processor requirements for receiving and transmitting messages, storing messages, bandwidth requirements, or other suitable resource requirements. The method then proceeds to .","At , it is determined whether the amount of resources required for distribution of the messages exceeds available resources. If the amount does not exceed available resources, the method proceeds to . Otherwise, the method proceeds to  where resource sequencing is performed. In one exemplary embodiment, resource sequencing can include ordering messages based upon the priority of the message, based upon the amount of resources required, based upon bottleneck resource constraints, such as areas in which the processor capacity or storage availability will limit the distribution of the messages or other suitable resource sequencing. The method then proceeds to .","At , it is determined whether any event based messages are included. If no event based messages are included, the method proceeds to  and terminates. Otherwise the method proceeds to  where event based sequencing is performed. In one exemplary embodiment, events can be sequenced based upon priority of the event, a sequence number for events, or other suitable data. The method then proceeds to  where the message sequencing is released.","In operation, method  allows a plurality of messages including file messages and control data messages to be sequenced so as to allow enterprise distribution of software to be performed over a network. Method  uses existing network resources to distribute software from one or more centralized locations to a plurality of endpoints in an efficient manner, so as to optimize available network resources to allow the software to be efficiently distributed.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 5","b":["500","500"]},"Method  begins at  where distribution priority is determined. In one exemplary embodiment, distribution priority can be determined based upon the software suite, the software component of a suite, the location of an endpoint, the function of an endpoint, a function that has to be performed by the endpoint, a function that has to be performed by an application layer router or gateway, or other suitable criteria. The method then proceeds to .","At , a message set is selected based upon the available bandwidth. In one exemplary embodiment, the message set can be selected by taking the highest priority messages in sequence until all available bandwidth has been allocated. In another exemplary embodiment, the message set can be selected based on priority in conjunction with other factors, such as the location of associated endpoints with priority messaging, bandwidth bottlenecks at certain locations, or other suitable functions. The method then proceeds to .","At , it is determined whether a priority violation has occurred. In one exemplary embodiment, a priority violation can include a sequencing of messages that results in a message not being transmitted at a required time, such as prior to transmission of other messages, in conjunction with transmission of other messages, or at other suitable times. If a priority violation has not occurred, the method proceeds to . Otherwise the method proceeds to  where operator notification is generated. In one exemplary embodiment, operator notification can request that the operator correct the priority violation, such as by reviewing the messages and selecting an operator override sequence. The method then proceeds to .","At , it is determined whether any remaining messages need to be sequenced. If messages remain, the method returns to . Otherwise, the method proceeds to  where sequencing of messages continues, such as response sequencing, resource sequencing, or event sequencing.","In operation, method  allows messages to be sequenced based upon available bandwidth so as to optimize message distribution in an enterprise software distribution system. Method  allows priority to be assigned to messages so as to ensure that messages are received in a predetermined order, such as messages that may require a response to be generated or other suitable messages.",{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 6","b":["600","600"]},"Method  begins at  where distribution priority is determined. The method then proceeds to , where a message set is selected based upon the available resources. In one exemplary embodiment, the message set can be selected based on processor requirements for processing the message, for generating responses, for processing responses, for operating timers, for storing files, processor capacity bottlenecks at certain locations, or other suitable resource sequencing functions. The method then proceeds to .","At , it is determined whether a priority violation has occurred. If a priority violation has not occurred, the method proceeds to . Otherwise the method proceeds to  where operator notification is generated. The method then proceeds to .","At , it is determined whether any remaining messages need to be sequenced. If messages remain, the method returns to . Otherwise, the method proceeds to  where sequencing of messages continues, such as response sequencing, bandwidth sequencing, event sequencing, or other suitable sequencing.","In operation, method  allows messages to be sequenced based upon available resources so as to optimize message distribution in an enterprise software distribution system. Method  allows priority to be assigned to messages so as to ensure that messages are received in a predetermined order, such as messages that may require a response to be generated or other suitable messages.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 7","b":["700","700"]},"Method  begins at  where a response priority is determined. In one exemplary embodiment, a response priority may be based upon control commands such as execution of an Intel WakeOnLAN Network Interface Card so that a processor is turned on prior to the transmission of messages to that processor. In this exemplary embodiment, the priority of the WakeOnLAN command would be greater than the priority for any other message. After the response priority is determined the method proceeds to .","At , response bandwidth is determined. In one exemplary embodiment, response bandwidth can include the available bandwidth between a plurality of endpoints and an application layer gateway, such as where the gateway is used to coordinate the transmission of response messages from the endpoints back to an application, such as an application distribution system . After the response bandwidth is determined, the method proceeds to .","At , it is determined whether the bandwidth required for the response is greater than available bandwidth. In one exemplary embodiment, the bandwidth can be determined based upon maximum response bandwidth required, the response bandwidth required at system bottlenecks, or other suitable bandwidth. If it is determined that the bandwidth is not greater than available, the method then proceeds to , where the messages are sequenced in accordance with the message priority. Otherwise, the method proceeds to .","At , a set of messages is selected based upon priority and bandwidth constraints. In one exemplary embodiment, bandwidth sequencing may have already been performed such that predetermined sets are available for response priority sequencing. In another exemplary embodiment, priority sequencing can be performed in conjunction with bandwidth sequencing, and the transmission sets can be selected based upon overlapping compatible sets. The method then proceeds to .","At , it is determined whether a priority violation has occurred. If a priority violation has not occurred, the method proceeds to . Otherwise, the method proceeds to  where a notification is generated requesting operator assistance. The method then proceeds to .","At , it is determined whether any remaining messages need to be sequenced. If remaining messages are available, the method returns to . Otherwise, the method proceeds to  where sequencing for other factors is performed, such as resource sequencing or event sequencing.","In operation, method  is used to perform response sequencing in an enterprise software distribution system, so as to prevent responses that may be generated following transmission of messages including files or control data from overloading system capacity. In this manner, system  prevents data loss from occurring, such as from undelivered messages, which can result in improper installation of files in an enterprise software distribution system.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 8","b":["800","800","802","804"]},"At , it is determined whether there are any related events required for the message. In one exemplary embodiment, installation of components, bandwidth availability, processor availability, or other suitable events may need to occur before a message is transmitted, such as to prevent inadvertent non-delivery of the message, to ensure that predetermined events occur prior to transmission of the message, or for other suitable purposes. The method then proceeds to .","At , sequence commands are generated. In one exemplary embodiment, message sequencing can be generated based upon relative events, such that messages are sequenced after all messages have been processed. In another exemplary embodiment, messages can be assigned a sequence based upon absolute events, such as transmission of a message after a processor is on, transmission of a message after an operating system has been installed, or other suitable events. The method then proceeds to .","At , it is determined whether remaining messages need to be sequenced for event related sequencing. If any messages are remaining, the method returns to . Otherwise, the method proceeds to  where the process continues with any remaining sequencing, such as bandwidth sequencing, response sequencing, or resource sequencing.","In operation, method  allows messages to be sequenced based upon events that may be required prior to transmission of a message. Method  thus allows modified publish and subscribe messaging to be used in an enterprise software distribution system so as to allow the address of an endpoint to be determined centrally and for the message to be sequenced to the endpoint without inadvertent receipt of a message prior to predetermined events.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 9","b":["900","900"]},"System  includes software components , suite assembly system , and suite . Suite assembly system  converts two or more software applications from software components  into one or more required components  or optional components  of suite . Suite assembly system  can be implemented in hardware, software, or a suitable combination of hardware and software, and can be one or more software systems operating on a general purpose server platform. Suite assembly system  is used to assemble two or more software components into a software suite. In one exemplary embodiment, suite assembly system  allows software components to be configured for operation on a processor independently, and then analyzes each software component to identify dependencies, files, and settings that are used to determine whether the combination of the software component with other software components into a software suite would create conflicts requiring resolution. Furthermore, suite assembly system  can implement existing rules for resolution of conflicts, can notify an operator of conflicts and allow the operator to take corrective actions, or can perform other suitable functions.","Each required component  includes one or more dependencies  (which can include hardware or software that are used by the required component ), files  (which can include one or more of the files that are a part of required component  or generated by required component  or used by required component  for operation), one or more settings  (which can include registry settings in one or more registries of the operating system or other related software applications), and other suitable features.","Likewise, optional component  includes dependencies , files , and settings . The software applications of suite  are organized into required components  and optional components  so as to facilitate the identification of conflicts between the dependencies  and dependencies , files  and files , and settings  and settings . In this manner, conflicts can be identified between the dependencies, files, and settings before a component is combined with another component. For example, a list of dependencies for a first component can be compared to the list of dependencies for a second component, and any conflicts can be identified, such as dependencies on hardware or software that require different types of hardware, different versions of software, or other dependencies. In this manner, the components can be analyzed to determine whether it is possible to obtain a later version of the components having correct hardware or software dependencies, whether the hardware or software dependencies can be analyzed to determine whether they are compatible, or whether other suitable rules or corrections can be implemented.","Likewise, files  or files  for two components (such as two required components , two optional components , or a required component  and an optional component ) can be compared to determine whether the files required by one component conflict with the files required by the second component, such as where versions of files are different, file names are identical but functions are different, or other conflicts exist. In this manner, rules or fixes to the problem can be determined, such as by renaming files, modifying the components to make file versions compatible, or other suitable rules or corrections.","Likewise, the settings for two components can also be compared to determine whether any setting conflicts exists. If a setting conflict is determined to exist, then a rule or correction or code modification can be implemented to correct the setting conflict.","Furthermore, when a conflict exists between a required component and an optional component, the optional component can be overridden in favor of the required component, such as by changing the dependency, file, or setting requirement of the optional component to match that of the required component, disabling the optional component until a new version of the optional component can be obtained from the provider that resolves the conflict, or other suitable functions. Thus, arrangement of suite  into one or more required component  and one or more optional component  allows further flexibility in resolving conflicts between components prior to installation of such components in an operating environment.","In operation, system  allows software installation in an enterprise setting to be performed in a manner that eliminates the potential for conflicts to occur when suites of software are installed on a processor. System  allows software suites to be assembled in advance from separate components in a manner that identifies conflicts between hardware and software dependencies, files, settings, or other features of the software. In this manner, conflicts between such dependencies, files, and settings, can be resolved prior to the time when the software suite is deployed. Likewise, system  allows optional component dependencies, files, and settings, to be overridden in favor of required component dependencies, files, and settings when conflicts exist between such and required optional components.",{"@attributes":{"id":"p-0093","num":"0092"},"figref":"FIG. 10","b":["1000","1000"]},"System  includes suite assembly system  and component suite assembly , conflict resolution system , conflict verification system , new rule system , files\/settings\/dependencies system , and external interface system , each of which can be implemented in hardware, software, or a suitable combination of hardware and software, and which can be one or more software systems operating on a general purpose server platform.","Component suite assembly  takes two or more software components and assembles them into a software suite. In one exemplary embodiment, component suite assembly  can implement existing rules for resolution of conflicts, can receive operator entered rules or instructions for resolution of conflicts, or can perform other suitable functions to resolve conflicts. Component suite assembly  then assembles the components into suites for installation in an enterprise software distribution system, such as by ordering the software components in a directory based order, an installation sequence based order, or other suitable assemblies.","Conflict resolution system  receives conflict identification data from component suite assembly  and performs conflict resolution processes to resolve the conflicts. In one exemplary embodiment, conflict resolution system  can implement existing rules for correcting conflicts between files, settings, dependencies, or other software system features. Likewise, conflict resolution system  can receive operator-entered directions for resolution of conflicts as a function of enterprise, applications within enterprise, workstation functions, or other suitable features, and can store such directions as rules for subsequent conflict resolution.","Conflict verification system  performs verification of component conflicts. In one exemplary embodiment, conflict verification system  can analyze files, settings, and dependencies and determine whether an actual conflict between such files, settings, and dependencies exists. In this embodiment, conflicting files can be compared to determine whether the content of the files is identical. Likewise, settings and dependencies can also be compared to determine whether actual conflicts exists. Conflict verification system  can generate conflict verification data that identifies whether conflicts can be resolved by files\/settings\/dependencies system , new rule system , external interface system , or other suitable systems or functions.","New rule system  allows an operator to generate new rules for resolution of conflicts between components and a software suit. In one exemplary embodiment, a rule can be used to resolve conflicts where the conflict can be corrected by overriding an optional component in favor of a required component, where the conflict can be resolved by disabling a component in a manner that does not affect the component's application in the enterprise, by editing a file, setting or dependency, or by otherwise creating an external rule. In this manner, new rule system  allows new rules to be created and implemented through conflict resolution system  so as to reduce the amount of operator involvement required to resolve conflicts.","Files\/settings\/dependencies system  resolves conflicts between files, settings, and dependencies of two or more components. In one exemplary embodiment, conflict resolution system  can determine that resolution of a conflict between two components in a software suite can be performed by addressing the files, settings, or dependencies of the components, such as where conflict verification system  determines that the two different versions of a file perform the same function or contain the same matter, that hardware or software settings can be corrected, that dependencies can be corrected, or that other suitable fixes can be made.","External interface system  performs tracking and verification of requests to external organizations for resolving conflicts between components, such as software system providers. In one exemplary embodiment, a conflict between components may be caused through a conflict in files, settings, or dependencies that cannot be resolved by overriding the files, settings, or dependencies of an optional component with those of a required component, by disabling functions of a component, or by otherwise generating rules for resolution of conflicts. In this exemplary embodiment, the resolution of the problem may require modification of source code that is unavailable, the addition of new functionality to source code, or other functions that cannot be performed by an operator. External interface system  allows such problems to be tracked, and performs management of the request to one or more external software development organizations.","In operation, system  allows components to be assembled into software suites in a manner that identifies and corrects conflicts between files, settings, dependencies, and which also allows for operator intervention where necessary to resolve conflicts. System  thus allows resolution of conflicts between components to be automated, to the extent that operator intervention is not required. Likewise, system  allows tracking of component fixes that require the involvement of third parties.",{"@attributes":{"id":"p-0102","num":"0101"},"figref":"FIG. 11","b":["1100","1100","1102","1104"]},"At , the first component is installed. In one exemplary embodiment, the component can be installed on a platform having the software and hardware configuration of platforms within the enterprise that will be operating the same component. Likewise, the hardware and software configurations can be simulated and the component can be installed in an operating environment for assembling software components. The method then proceeds to .","At , directory configuration data is stored. In one exemplary embodiment, the names, creation dates, version numbers, sizes, and other information or files can be stored for subsequent comparison with other components. The method then proceeds to .","At , file data for selected types is stored. In one exemplary embodiment, the selected file types can include Dynamic Link Library (*.DLL) flies, executable (*.EXE) file headers, and other suitable files that will control the generatation of files, settings, or dependency settings for the various software components. The method then proceeds to .","At , it is determined whether any additional components remain. If no additional components remain, the method proceeds to  and terminates. Otherwise, the method proceeds to  where the next component is installed. The method then proceeds to  where a directory configuration is stored for the new component. At , file data is stored for the selected file types of the new component and the method proceeds to .","At , the new and stored directory and file data is compared to determine whether there are any conflicts. In one exemplary embodiment, the directory and file data can be stored for each previously processed component, such that conflicts between individual components can be identified. In this manner, the addition of a new component that conflicts with only one of several existing components can be identified, so as to determine whether a rule should be implemented or whether modification of a file, setting, or dependency can be implemented to resolve the conflict. The method then proceeds to .","At , it is determined whether any conflicts exist. If no conflicts exist, the method returns to . Likewise, if conflicts are determined to exist, the method proceeds to . At , existing rules for conflict resolution are applied, such as from previous software suite configurations, software suite configurations for previous versions of the components, or other suitable rules. The method then proceeds to .","At , the database is checked for new conflicts. In one exemplary embodiment, the directory configuration and file data for selected file types can be checked to determine whether a conflict exists. If no conflict exists, the method returns to . Otherwise, if it is determined that a conflict exists, the method proceeds to , where new rules are created to resolve the conflicts. In one exemplary embodiment, the generation or creation of new rules can include contacting a third party to modify one or more software components to resolve the conflict. The method then returns to .","In operation, method  allows two or more components to be assembled into a software suite in a manner that allows conflicts between components to be identified and corrected prior to distribution of the component in an enterprise environment. Method  thus allows such conflicts to be identified before enterprise-wide distribution of a software suite.",{"@attributes":{"id":"p-0111","num":"0110"},"figref":"FIG. 12","b":["1200","1200"]},"Method  begins at  where conflicting files are displayed. In one exemplary embodiment, the conflicting files can be displayed on a user interface for operator review, the conflicting files can be stored in a file for use by a software application, or other suitable processes can be used. The method then proceeds to .","At , it is determined whether any of the files belong to optional components. If none of the files belong to optional components, the method proceeds to . Otherwise, the method proceeds to , where a new rule is generated to replace the optional file with the required file. Likewise, some files may require a rule to replace the file only for predetermined components, while others may allow replacement of the file for all components. The method then proceeds to .","At , it is determined whether the optional file is equivalent to the required file, such as in operation, configuration or in other suitable manners. If it is determined at  that the optional file is not equivalent to the required file, the method proceeds to  where a third party fix is tracked. In this exemplary embodiment, generation of the new rule does not resolve the conflict and a third party fix is necessary to eliminate the conflict between the files. The method then proceeds to . If it is determined at  that the files are equivalent, the method proceeds to  where the new rule to replace the optional file with the required file is generated and implemented or stored for further implementation. Likewise, some files may require a rule to replace the file only for predetermined components, while others may allow replacement of the file for all components. The method then proceeds to .","At , conflicting dependencies are displayed. In one exemplary embodiment, the conflicting dependencies can be displayed on a user interface for operator review, the conflicting dependencies can be stored in a file for use by a software application, or other suitable processes can be used. The method then proceeds to .","At , it is determined whether any of the dependencies are related to optional components. If none of the dependencies are related to optional components, the method proceeds to . Otherwise, the method proceeds to , where a new rule is generated to replace the optional dependencies with the required dependencies. Likewise, some dependencies may require a rule to replace the dependencies only for predetermined components, while others may allow replacement of the dependencies for all components. The method then proceeds to .","At , it is determined whether the optional dependencies are equivalent to the required dependencies, such as in operation, configuration or in other suitable manners. If it is determined at  that the optional dependencies are not equivalent to the required dependencies, the method proceeds to  where a third party fix is tracked. The method then proceeds to . If it is determined at  that the dependencies are equivalent, the method proceeds to  where the new rule to replace the optional dependency with the required dependency is generated and implemented or stored for further implementation. Likewise, some dependencies may require a rule, while others may allow replacement. The method then proceeds to .","At , conflicting settings are displayed. In one exemplary embodiment, the conflicting settings can be displayed on a user interface for operator review, the conflicting settings can be stored in a file for use by a software application, or other suitable processes can be used. The method then proceeds to .","At , it is determined whether any of the settings are related to optional components. If none of the settings are related to optional components, the method proceeds to . Otherwise, the method proceeds to , where a new rule is generated to replace the optional settings with the required settings. Likewise, some settings may require a rule to replace the settings only for predetermined components, while others may allow replacement of the settings for all components. The method then proceeds to .","At , it is determined whether the optional settings are equivalent to the required settings, such as in operation, configuration or in other suitable manners. If it is determined at  that the optional settings are not equivalent to the required settings, the method proceeds to  where a third party fix is tracked. If it is determined at  that the settings are equivalent, the method proceeds to  where the new rule to replace the optional setting with the required setting is generated and implemented or stored for further implementation. Likewise, some settings may require a rule, while others may allow replacement.","In operation, method  allows two or more software components to be analyzed to determine whether conflicts exist, and to resolve the conflicts, to generate new rules, to request third party fixes, or to otherwise resolve the conflict.","Although exemplary embodiments of a system and method for performing the present invention have been described in detail herein, those skilled in the art will also recognize that various substitutions and modifications can be made to the systems and methods without departing from the scope and spirit of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
