---
title: Monitoring the responsiveness of a user interface
abstract: A diagnostic mechanism monitors execution of a user interface (UI) thread to detect execution of a long running task that may have caused the UI thread to become unresponsive. The execution time of the UI thread is monitored and when it exceeds a threshold, the UI thread's call stack is preserved to a mini-dump file. The completion time of the UI thread is also tracked and stored in a delay file. The mini-dump and delay files are then uploaded to a server where the collected data is aggregated overall execution runs by multiple users to identify the cause of the unresponsiveness.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09389936&OS=09389936&RS=09389936
owner: MICROSOFT TECHNOLOGY LICENSING, LLC.
number: 09389936
owner_city: Redmond
owner_country: US
publication_date: 20110923
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["A software application may be configured to utilize independent threads of execution in order to offload the processing of certain functions from the main process. A user interface (UI) thread may be used to create windows and to manage the exchange of messages and user input communicated through the windows. For example, the UI thread may manage user-interface objects, such a dialog boxes, and user activities, such as resizing windows, and so forth.","The slow response time of the UI thread in processing the user's input affects the usefulness of the software application. At times, it may be difficult to identify the bottlenecks contributing to the slow response time or unresponsiveness of the UI thread. Each user's execution environment differs which makes reproducing or detecting a bottleneck difficult. Often users may employ different network connections or may utilize other programs that interact with the hardware and resources on the user's machine. In addition, the user interfaces may utilize graphical user interface objects in a variety of ways that may not have been foreseen or tested. Accordingly, the responsiveness of the UI thread is a key factor that affects the user's experience with the software application.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","An application may contain a UI thread to process user interactions with the application. The UI thread may be implemented as a message pump that retrieves user events, represented in the form of messages, from a message queue. The UI thread calls an event handler associated to process the message. The UI thread waits for the message to finish processing before retrieving another message from the message queue.","A diagnostic mechanism monitors the UI thread to determine when the UI thread becomes unresponsive. The unresponsive behavior may be determined when the UI thread fails to retrieve a message from the message queue within a predetermined time. When the diagnostic mechanism determines that the UI thread has become unresponsive, the UI thread is suspended in order to preserve the call stack to a mini-dump file. The UI thread resumes and when the message completes processing, the delay time of the event as well as other data is then recorded in a delay file. The mini-dump and delay files are then uploaded to a server for further analysis.","In one or more embodiments, the diagnostic mechanism may be implemented as a diagnostic module having a monitoring component and a monitoring thread. The monitoring component and monitoring thread are configured to execute in the same process as the UI thread. At runtime, the monitoring component detours certain functions used by the UI thread to the monitoring component so that the monitoring component may track the time the UI thread spends processing a message. The monitoring thread uses a timer to determine when the UI thread becomes unresponsive. Once the monitoring thread determines that the UI thread has meet the threshold time for unresponsiveness, the call stack of the UI thread is preserved.","These and other features and advantages will be apparent from a reading of the following detailed description and a review of the associated drawings. It is to be understood that both the foregoing general description and the following detailed description are explanatory only and are not restrictive of aspects as claimed.","Various embodiments are directed to a mechanism for monitoring the unresponsiveness of a user interface. A UI thread may be used by an application to manage the application's user interface. User interface events are represented as messages that are stored in a message queue until processed by the UI thread. The UI thread may be implemented as a message pump or loop that retrieves messages from a message queue and processes them accordingly. The goal of the UI thread is to continually retrieve messages from the message queue which is otherwise known in the art as pumping messages. In this manner, the events triggering the messages are responded to quickly thereby improving the performance and responsiveness of the UI thread.","When the UI thread takes an inordinate amount of time to process a message, the UI thread is considered unresponsive. The condition that caused the UI thread to become unresponsive may be a long running task that caused the UI thread to hang. In order to improve the responsiveness of the UI thread, it is paramount to know what conditions delayed the UI thread.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1","b":["100","102","104","106","102","104","106","102","104","102","104"]},"In one or more embodiments, the computing device  may be utilized by a user. The computing device  may include an operating system , a diagnostic module , and one or more applications . The application  and the diagnostic module  may be a sequence of computer program instructions, that when executed by a processor, causes the processor to perform methods and\/or operations in accordance with a prescribed task. The application  and the diagnostic module  may be implemented as program code, programs, procedures, module, code segments, program stacks, middleware, firmware, methods, routines, and so on. The executable computer program instructions may be implemented according to a predefined computer language, manner or syntax, for instructing a computer to perform a certain function. The instructions may be implemented using any suitable high-level, low-level, object-oriented, visual, compiled and\/or interpreted programming language.","A process is an instance of an application that is configured with the resources needed to execute it. A process may contain one or more threads. A thread is an independent execution unit that executes a subset of the application's instructions or code. A component is a software package that contains instructions and data configured to execute as an independent unit. The application  may include a UI thread  that executes concurrently with other threads. The UI thread  may be used to create windows and to manage the exchange of messages and user input exchanged through the windows.","In an embodiment, the UI thread  may be implemented as a message pump. A message pump retrieves messages from a message queue  which are then forwarded to a corresponding event handler for processing. A sequence of messages may be translated or aggregated into an event. For example, the mouse button down message and the move message may be aggregated into a window resize event. Examples of other events may include keyboard input, time expiration, and so forth. The UI thread  calls the event handler associated with a message and waits for the completion of the execution of the event handler before retrieving another message.","Messages may be placed into the message queue  by the operating system . Retrieving a message from the message queue  may be referred to as pumping a message and the mechanism for retrieving messages from the message queue  and forwarding them for processing is otherwise known as the message pump. The goal of the UI thread  is to continually retrieve messages from the message queue  or to continually pump messages. In this manner, the events triggering the messages are responded to quickly thereby improving the performance and responsiveness of the UI thread . When the UI thread  takes an inordinate amount of time to process a message, the UI thread  is considered unresponsive. In order to improve the responsiveness of the UI thread, it is important to know the source of the problem.","The operating system  manages and coordinates the resources needed to execute the application  and other programs. The operating system  may include a Query Performance Counter (QPC)  which is a high-precision timer that may be used to determine the length of time that a process or thread within an application  takes to execute. The time units may be milliseconds, seconds, etc. The QPC  may be implemented as a kernel function that may be accessible by an application through an application programming interface (API). Alternatively, the QPC  may be implemented as a software procedure external of the operating system .","A diagnostic module  may be a software application that monitors the responsiveness of the UI thread . The responsiveness of an application  may be measured by the amount of time the UI thread  takes to execute a task. If the UI thread  takes an inordinate amount of time to execute a task, then the UI thread  is considered to be unresponsive. A threshold may be used to determine when the UI thread  is deemed unresponsive. The threshold may be a particular amount of time such as 2000 milliseconds or 2 seconds, or any other defined value.","The diagnostic module  may be composed of a monitoring thread , a monitoring component , a collection component , an uploader thread , and a stored QPC value . The monitoring thread  monitors the UI thread  to determine when the UI thread  is unresponsive. At that time, the collection component  captures the UI thread's call stack which is stored in a mini-dump file . When the UI thread  completes processing the message that caused the unresponsiveness behavior, the collection component  collects the delay time and other anonymous data that may be stored in a delay file . The uploader thread  may be used to upload the data to the server . The stored QPC value , when set to a non-zero value, retains the time at which the UI thread started processing the current message, and when set to zero, indicates that the previous message has finished processing.","In one or more embodiments, the application  may be Microsoft's Visual Studio\u00ae product which may be used by a user to develop console and graphical user interface applications. The UI thread  may be the Visual Studio\u00ae UI thread and the diagnostic module  may be PerfWatson extension to Visual Studio\u00ae. However, the embodiments are not limited to these particular software programs.","A server  may be utilized to aggregate the data from the mini-dump file  and the delay file  from various users of the application . The server  may include an aggregation database  and an aggregation and reporting module . The aggregation database  stores the data in the mini-dump files  and the delay files  from the various executed runs of the application  by multiple users across various computing platforms. The aggregation and reporting module  may be used to analyze the aggregated data and to formulate reports displaying the analysis. The analysis may be used to determine the conditions attributing to the delay of the UI thread . By aggregating the data across multiple users of an application, the source of the problem may be recognized quickly.","Although the system  shown in  has a limited number of elements in a certain configuration, it should be appreciated that the system  can include more or less elements in alternate configurations. For example, the server  may be arranged as a plurality of server machines or configured as a combination of server and client machines. The diagnostic module  may be part of the application  and not a separate program as shown in . There may also be several aggregation and reporting modules  that may operate concurrently on one or more servers . The embodiments are not limited in this manner.","In various embodiments, the system  described herein may comprise a computer-implemented system having multiple elements, programs, procedures, modules. As used herein, these terms are intended to refer to a computer-related entity, comprising either hardware, a combination of hardware and software, or software. For example, an element may be implemented as a process running on a processor, a hard disk drive, multiple storage drives (of optical and\/or magnetic storage medium), an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a server and the server may be an element. One or more elements may reside within a process and\/or thread of execution, and an element may be localized on one computer and\/or distributed between two or more computers as desired for a given implementation. The embodiments are not limited in this manner.","The various elements of system  may be communicatively coupled via various types of communications medium as indicated by various lines or arrows. The elements may coordinate operations between each other. The coordination may involve the uni-directional or bi-directional exchange of information. For instance, the elements may communicate information in the form of signals communicated over the communications medium. The information may be implemented as signals allocated to various signal lines. In such allocations, each message is a signal. Further embodiments, however, may alternatively employ data messages. Such data messages may be sent various connections. Exemplary connections include parallel interfaces, serial interfaces, and bus interfaces.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 2","b":["200","112","110","102","120","122","114","150","122","122","120","123","124","152","150"]},"The application  may have a mechanism for extending the functions provided by an application  by allowing other executable code to be executed as part of the application . For example, the application  may have an installer program that allows an application  to load in additional code so that the entire combination would execute in the same process. When the application  is loaded for execution, the installer program may load the monitoring component  into the same process as the application .","The application process  and the diagnostic process  execute in separate address spaces and communicate with each other through an inter-process communication (IPC) mechanism . In one or more embodiments, the application process  and the diagnostic process  may communicate through any one of the Windows-supported IPC mechanisms, such as pipes, clipboard, file mapping, mail slots, sockets, remote procedure calls, and so forth. In an embodiment, the application process  and diagnostic process  may use pipes to communicate and transfer data. A pipe is an area of memory shared by the application process  and the diagnostic process  so that each process is able to read and write data stored in the shared memory.","The application  executes within the application process  and may spawn off the UI thread  as a separate and independent execution path to manage the application's windows. The UI thread  runs within the application process  and shares the same address space. This allows the UI thread  and the application  to share the same data structures.","The UI thread  executes a message pump whereby the UI thread  obtains messages from the message queue  and calls functions to process the messages continuously. The UI thread calls a GetMessage function  to retrieve a message from the message queue  and then calls a Dispatch Message function  to execute the event handler associated with the message. However, the GetMessage function  is detoured to the monitoring component . The monitoring component  may set and reset a stored value of the QPC which may be used to track the processing time of the UI thread in processing a message.","A detour is a technique that enables interception of a source function call so that a detour function is executed in place of the source function. At runtime, when the UI thread  calls the GetMessage function  to retrieve a message off the message queue , control jumps to the detour function instead. In the present case, the detour function is the monitoring component . The monitoring component  initializes a stored QPC value  to zero and transfers control to the original GetMessage function. When the original GetMessage function completes processing, the control flows back to the monitoring component which stores the current QPC value as the stored QPC value  (i.e., stored_QPC=current QPC value). The monitoring thread , at predefined intervals, makes a comparison of the stored QPC value  and the current QPC value to determine if the UI thread  exceeds a threshold indicative of unresponsiveness. For example, the comparison may be made every 300 ms and a timer may be used to activate the monitoring thread  every 300 ms to make the comparison.","The detour may be facilitated by a technique referred to as API hooking. In API hooking, a detour API is provided that enables a program, such as the monitoring component , to change the address of a source function call with the address of the detour function or monitoring component . At runtime when the UI thread  calls the GetMessage function to retrieve a message from the message queue , the monitoring component  is called first.","Once the message is retrieved and the stored QPC value  set, the UI thread  calls the DispatchMessage function which calls the event handler corresponding to the message (block ). The UI thread  waits until the event handler completes processing (block ) and then returns to the GetMessage function (block ) to get the next message off the message queue .","Simultaneously, the monitoring thread  polls for the current QPC value repeatedly at predetermined intervals (block ). The monitoring thread  compares the stored QPC value  with the current QPC value to determine the amount of time that has lapsed since the UI thread has started processing a message. The monitoring thread  determines if the difference between the stored QPC  value and the current QPC value meets and\/or exceeds a threshold that deems the UI thread unresponsive (block ). The threshold may be a predetermined value that is set by a developer or alternatively, the threshold may be a user-configurable input.","When the monitoring thread  determines that the UI thread  has become unresponsive, the monitoring thread  freezes or suspends execution of the UI thread  (block ) and notifies the collection component  to collect the call stack (block ). The call stack is saved at the point in time after the threshold has been met. The call stack contains a list of the calls made by the UI thread  at the point the UI thread  is suspended. The call stack is preserved into the min-dump file  for use in identifying the condition causing the UI thread's unresponsiveness.","Next, the monitoring thread  unfreezes the UI thread  and allows the UI thread  to finish executing the message to completion (block ). When the message completes processing, the UI thread  loops back to GetMessage  to get another message from the message queue . When the monitoring thread  detects that the stored QPC value  is zero, then the monitoring thread  recognizes that the previous message has completed processing (block ). At this point, the monitoring thread  signals a delay end to the collection component  (block ).","The collection component  executes when it receives notifications or messages from the monitoring thread . The monitoring thread  may send the collection component  a message indicating that the call stack is to be collected (block ). Upon receiving such a notification (block ), the collection component  obtains the call stack which it copies to a mini-dump file  (block ).","An operating system may contain methods that may be used to create a dump file containing system information, such as a call stack. For example, in some Windows-based operating systems, the Windows\u00ae IDebugClient provides methods for use in opening and writing system-level data into a dump file. In an embodiment, the collection component  may preserve the call stack by calling one of the methods provided by Windows\u00ae IDebugClient to open and write to the mini-dump file  with the UI thread's call stack.","Additionally, the collection component  may receive a notification or message from the monitoring thread  to collect the delay data (block ). The delay data may include anonymous data pertaining to the application and the duration of the unresponsive condition. The delay data may be collected and stored in a delay file  (block ).","For example, the collected data may contain the following data and may be formatted into an XML-based file as follows:",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<?xml version=\u201d1.0\u201d encoding = \u201cutf-8\u201d?>"},{"entry":"<ResponsivenessDelayInfo>"},{"entry":"\u2003<Duration> 3539 <\/Duration>"},{"entry":"\u2003\u2002<UserName> External <\/UserName>"},{"entry":"\u2003\u2002<ComputerName> External <\/Computer Name>"},{"entry":"\u2003\u2002<ServerProc> devenv <\/ServerProc>"},{"entry":"\u2003\u2002<VsVersion> 10.0.40219.1 builtby:SP1Rel <\/VsVersion>"},{"entry":"\u2003\u2003<Timestamp>2011-06-15T08:29:17<\/Timestamp>"},{"entry":"\u2003\u2003\u2002<SessionId>ed5f81b8-86b8-40ff-88b0-9e8f457233b8<\/SessionId>"},{"entry":"<\/ResponsivenessDelayInfo>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The Duration tag indicates the total amount of time that the UI thread  was unresponsive. The UserName tag indicates whether the application run was internal to the developer of the application or external. The ComputerName tag indicates whether the application run was executed on a computer that is internal to the developer of the application or external. The ServerProc tag indicates the name of the application. The VsVersion tag indicates the version of the application being monitored, the Timestamp tag indicates the day and time that the unresponsiveness occurred, and the SessionId tag specifies a session identifier associated with the execution of the application.","The delay file  may then be stored in the computing device  and at a later point in time uploaded to a server  (block ) by the uploader thread . The uploader thread  may be initiated by the collection component  to upload all the mini-dump files  and delay files  on the computing device  to the server  at a designated point in time.","Operations for the embodiments may be further described with reference to various exemplary methods. It may be appreciated that the representative methods do not necessarily have to be executed in the order presented, or in any particular order, unless otherwise indicated. Moreover, various activities described with respect to the methods can be executed in serial or parallel fashion, or any combination of serial and parallel operations. The methods can be implemented using one or more hardware elements and\/or software elements of the described embodiments or alternative embodiments as desired for a given set of design and performance constraints. For example, the methods may be implemented as logic (e.g., computer program instructions) for execution by a logic device (e.g., a general-purpose or specific-purpose computer).",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 3","FIG. 3"],"b":["300","100","200"]},"The UI thread , the monitoring component , the monitoring thread , the collection component , and the uploader thread  execute simultaneously. The UI thread  executes a message pump or message loop that gets messages from a message queue  (block ). The UI thread  is detoured to the monitoring component  when the UI thread  calls the GetMessage function. The monitoring component  resets the stored QPC  value to zero and calls the original GetMessage function which retrieves a message from the message queue  (block ). When the GetMessage function completes processing, control returns back to the monitoring component . The monitoring component  then sets the stored QPC value to the current QPC value and calls the DispatchMessage function. The DispatchMessage function calls the event handler associated with the message (block ).","The monitoring thread  continuously at predetermined intervals (blocks , ), such as 300 ms, compares the current value of the QPC with the stored QPC value  until the difference meets or exceeds a threshold (block ). At this point, the monitoring thread  freezes the UI thread (blocks , ) and notifies the collection component  to collect the current call stack (block ).","The collection component  engages the operating system  to preserve or copy the call stack into the mini-dump file  (block ) and notifies the monitoring thread  when the dump or collection is completed (block ). The monitoring thread , in response to the end dump notification, unfreezes or resumes the UI thread  (block ). The monitoring thread , at predetermined intervals, continues to compare the current value of the QPC with the stored QPC value  (blocks , ). The UI thread  resumes processing to completion and calls the GetMessage function to retrieve another message from the message queue  (block ). When the GetMessage function is detoured to the monitoring component , the stored QPC value  is reset to zero (block ). The monitoring thread , at the predetermined interval, detects that the stored QPC value is zero thereby indicating that the previous message has completed processing (block ). The monitoring thread  then signals the end of the delay to the collection component  (block ).","The collection component  in turn writes out the delay data to the delay file  (block ). The uploader thread  uploads the mini-dump file  and the delay file  at a later point in time (block ). The monitoring thread  continues to poll the current QPC, the UI thread  continues processing messages from the message queue , and the collection component  waits for notifications from the monitoring thread  to collect the data.","Referring now to , there is shown a schematic block diagram of an exemplary operating environment . The operating environment  may include one or more client(s)  in communication through a communications framework  with one or more server(s) . The client(s)  may implement the client systems, such as the computing device  and the server(s)  may implement the server(s) .","A client  may be embodied as a hardware device, a software module, or as a combination thereof. Examples of such hardware devices may include, but are not limited to, a computer (e.g., server, personal computer, laptop, etc.), a cell phone, a personal digital assistant, or any type of computing device, and the like. A client  may also be embodied as a software module having instructions that execute in a single execution path, multiple concurrent execution paths (e.g., thread, process, etc.), or in any other manner","A server  may be embodied as a hardware device, a software module, or as a combination thereof. Examples of such hardware devices may include, but are not limited to, a computer (e.g., server, personal computer, laptop, etc.), a cell phone, a personal digital assistant, or any type of computing device, and the like. A server  may also be embodied as a software module having instructions that execute in a single execution path, multiple concurrent execution paths (e.g., thread, process, etc.), or in any other manner.","The communications framework  facilitates communications between the client  and the server . The communications framework  may embody any type of communications medium, such as wired or wireless networks, utilizing any communication protocol. Each client(s)  may be coupled to one or more client data store(s)  that store information local to the client . Each server(s)  may be coupled to one or more server data store(s)  that store information local to the server .",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 5","b":["102","102","240","242","244","246","247","240","242","244","120","247","120"]},"The memory  may be any computer-readable storage media that may store executable procedures, applications, and data. The computer-readable media does not pertain to propagated signals, such as modulated data signals transmitted through a carrier wave. It may be any type of memory device (e.g., random access memory, read-only memory, etc.), magnetic storage, volatile storage, non-volatile storage, optical storage, DVD, CD, floppy disk drive, and the like. The memory  may also include one or more external storage devices or remotely located storage devices. The memory may  contain instructions and data as follows:\n\n",{"@attributes":{"id":"p-0060","num":"0072"},"figref":"FIG. 6","b":["104","104","248","250","252","254","255","248","250","252","120","255","120"]},"The memory  may be any computer-readable storage media that can store executable procedures, applications, and data. The computer-readable media does not pertain to propagated signals, such as modulated data signals transmitted through a carrier wave. It may be any type of memory device (e.g., random access memory, read-only memory, etc.), magnetic storage, volatile storage, non-volatile storage, optical storage, DVD, CD, floppy disk drive, and the like. The memory  may also include one or more external storage devices or remotely located storage devices. The memory  may contain instructions and data such as one or more of the following:\n\n","Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather, the specific features and acts described above are disclosed as example forms of implementing the claims.","Various embodiments may be implemented using hardware elements, software elements, or a combination of both. Examples of hardware elements may include devices, components, processors, microprocessors, circuits, circuit elements, integrated circuits, application specific integrated circuits, programmable logic devices, digital signal processors, field programmable gate arrays, memory units, logic gates and so forth. Examples of software elements may include software components, programs, applications, computer programs, application programs, system programs, machine programs, operating system software, middleware, firmware, software modules, routines, subroutines, functions, methods, procedures, software interfaces, application program interfaces, instruction sets, computing code, code segments, and any combination thereof. Determining whether an embodiment is implemented using hardware elements and\/or software elements may vary in accordance with any number of factors, such as desired computational rate, power levels, bandwidth, computing time, load balance, memory resources, data bus speeds and other design or performance constraints, as desired for a given implementation.","Some embodiments may comprise a storage medium to store instructions or logic. Examples of a storage medium may include one or more types of computer-readable storage media capable of storing electronic data, including volatile memory or non-volatile memory, removable or non-removable memory, erasable or non-erasable memory, writeable or re-writeable memory, and so forth. Examples of the logic may include various software elements, such as programs, procedures, module, applications, code segments, program stacks, middleware, firmware, methods, routines, and so on. In an embodiment, for example, a computer-readable storage medium may store executable computer program instructions that, when executed by a processor, cause the processor to perform methods and\/or operations in accordance with the described embodiments. The executable computer program instructions may be implemented according to a predefined computer language, manner or syntax, for instructing a computer to perform a certain function. The instructions may be implemented using any suitable high-level, low-level, object-oriented, visual, compiled and\/or interpreted programming language."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
