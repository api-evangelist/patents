---
title: Secure mobile wireless device
abstract: A secure mobile wireless device in which executable code to be installed on the device is assigned a set of capabilities which define the protected resource(s) on the device which it can access. Hence, the present invention takes the idea of capabilities (known in the context of defining the capabilities or access privileges of different users in a multi-user system) and applies it to defining the capabilities or access privileges of different native executable code for secure, single-user mobile wireless devices.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07882352&OS=07882352&RS=07882352
owner: Nokia Corporation
number: 07882352
owner_city: 
owner_country: FI
publication_date: 20030528
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","DESCRIPTION OF THE PRIOR ART","SUMMARY OF THE PRESENT INVENTION","DETAILED DESCRIPTION"],"p":["This application claims the priority of PCT\/GB03\/02311 filed May 28, 2003 and British Application GB 0212314.9 filed on May 28, 2002, the contents of which are hereby incorporated by reference.","This invention relates to a secure mobile wireless device; in particular it relates to a new approach to platform security for mobile wireless devices which protects key operating system resources from harmful access.","Platform security covers the philosophy, architecture and implementation of platform defence mechanisms against malicious or badly written code. These defence mechanisms prevent such code from causing harm. Malicious code generally has two components: a payload mechanism that does the damage and a propagation mechanism to help it spread. They are usually classified as follows:\n\n","Security threats encompass (a) a potential breach of confidentiality, integrity or availability of services or data in the value chain and integrity of services and (b) compromise of service function. Threats are classified in the following categories:\n\n","Hence, mobile wireless devices offer very considerable challenges to the designer of a security architecture. A conventional approach typically operates by first of all determining whether the code (e.g. an application) is sufficiently trustworthy to be installed and then subsequently protecting the platform from errant behaviour once it is installed. In terms of determining trust, third party applications can be categorised according to the degree of trust associated with their authors. Hence, it is known to allow applications to be automatically installed on a device only if they can present a valid digital certificate issued by an acceptable Certificate Authority (CA).","Digital certificates are however only just becoming widespread; prior to their adoption, a primary platform security mechanism was to grant privileges to a user rather than to an application. At run time, the code being executed by the user is granted all his privileges. At install time, only designated users could install sensitive software. This meant that potentially harmful code could be vetted by an expert administrator prior to installation. Many well known operating systems adopt this approach to platform security\u2014e.g. Unix-based operating systems.","Platform security based on giving different users different access privileges is not relevant however for mobile wireless devices for the simple reason that this category of product is single user. It is a personal device, typically a \u2018smartphone\u2019, enhanced mobile telephone, PDA or other personal, portable computing device. Furthermore, the single user is very likely not to be expert in computing and hence cannot reliably assess the risk of installing and running code. With mobile wireless devices, the key threats that a platform security model tries to address are unauthorised access to user data and to system services, in particular the phone stack. The phone stack is especially important because it controls a permanent data connection to the phone network; mobile commerce, mobile banking etc. will be performed using the phone stack and (as noted above) losing control over it to malicious or badly written code exposes the device owner to potentially very significant financial damage.","To date, there have been no effective proposals for platform security for mobile wireless devices.","In a first aspect of the present invention, there is a secure mobile wireless device for a single user in which native executable code is written to include a set of capabilities which define the protected resource(s) on the device which it can access, such that a native process running on the device and providing the protected resource(s) will only grant access to the native executable code if doing so is permitted by the capabilities included within the native executable code, as determined during run time, by that particular native process. Native code is composed of instructions directly executed by a CPU on a device.","Hence, the present invention takes the idea of capabilities (known in the context of defining the capabilities or access privileges of different users in a multi-user system) and applies it to defining the capabilities or access privileges of different native executable code for secure, single-user mobile wireless devices.","An implementation of the present invention can be thought of as firewall protection of key operating system servers through the use of capability-based access control as applied to native executable code. Each capability may grant access to a specific API (or range of APIs), a file or any other applicable resource(s). Each executable (e.g. program (EXEs), or shared, static or dynamic libraries (DLLs)) contains the capabilities it has been granted at installation time. Each executable is permanently stored in a location only accessible to the Trusted Computing Base (kernel, loader, file server and software installer, see Detailed Description section 1.1) to preserve the integrity of the capabilities assigned to the executable. Once an executable is invoked, the loader will load the executable either to create a new process or to load the library code into an existing process. When creating a new process, the capabilities of this process are equal to the capabilities granted to the program. Based on this set of capabilities, the loader controls which libraries can be loaded into n process. For each client-server communication, the kernel will pass the client capabilities to the server. Therefore, the server can fully trust the client capabilities, as they are not passed\/approved by it but by a process part of the Trusted Computing Base, e.g. the kernel. The server can decide either to process the call or to reject it.","Preferably, the capability model is deliberately limited to a small number of capabilities. System capabilities are mandatory and control access to the operating system kernel, file system and system data. They guarantee the integrity of the \u2018Trusted Computing Environment\u2019 (or TCE\u2014see Detailed Description at 1.2). The way they are controlled cannot be modified by the user of the device and they are never exposed to them. Other kinds of capability are discretionary, as they are meaningful enough to average users to let them decide whether or not to grant some of them to code they have installed. These capabilities are categorised are follow:\n\n","Other aspects of the invention are particularise in the appended claims.","The present invention will be described with reference to the security architecture of the Symbian OS object oriented operating system, designed for single user wireless devices. The Symbian operating system has been developed for mobile wireless devices by Symbian Ltd, of London, United Kingdom.","The basic outline of the Symbian OS security architecture is analogous to a medieval castle defences. In a similar fashion it employs simple and staggered layers of security above and beyond the installation perimeter. The key threats that the model is trying to address are those that are linked with unauthorised access to user data and to system services, in particular the phone stack The phone stack is especially important in the context of a smart phone because it will be controlling a permanent data connection to the phone network. There are two key design drivers lying behind the model:\n\n","The main concept of the capability model described below is to control what a process can do rather than what a user can do. This approach is quite different to well-known operating systems as Windows NT and Unix. The main reasons are:\n\n","A remarkable point of this invention is that the use of cryptography has been deliberately excluded from the kernel and the loader executables are not signed, capabilities are not stored encrypted or signed. That has been possible because data partitioning provides a secure storage area for executables. It allows the system to treat executables from ROM (built in the device) the same way as code from RAM (installed by the user) without compromising either on security or performance. Therefore any misuse or exploit of device manufacturer code is restricted to the capabilities assigned to this code. As is well known, the code is stored on a computer-readable medium, such as a hard drive, CD-ROM, floppy disk, RAM memory, ROM memory, USB drive, or the like.","1 Trusted Computing Platform","1.1 Trusted Computing Base","A trusted computing base (TCB) is a basic architectural requirement for robust platform security. The trusted computing base consists of a number of architectural elements that cannot be subverted and that guarantee the integrity of the device. It is important to keep this base as small as possible and to apply the principle of least privilege to ensure system servers and applications do not have to be given privileges they do not need to function. On closed devices, the TCB consists of the kernel, loader and file server, on open devices the software installer is also required. All these processes are system-wide trusted and have therefore full access to the device. This trusted core would run with a \u201croot\u201d capability not available to other platform code (see section 2.1).","There is one other important element to maintain the integrity of the trusted computing base that is out of the scope of this invention, namely the hardware. In particular, with devices that hold trusted computing base functionality in flash ROM, it is necessary to provide a secure boot loader to ensure that it is not possible to subvert the trusted computing base with a malicious ROM image.","1.2 Trusted Computing Environment","Beyond the core, other system components would be granted restricted orthogonal system capabilities and would constitute the Trusted Computing Environment (TCE); they would include system servers such as phone and window servers . . . . For instance the window server would not be granted the capability of phone stack access and the phone server would not be granted the capability of direct access to keyboard events. It is strongly recommended to give as few system capabilities as possible to a software component to limit potential damage by any misuse of these privileges.","The TCB ensures the integrity of the full system as each element of the TCE ensures the integrity of one service. The TCE cannot exist without a TCB but the TCB can exist by itself to guarantee a safe \u201csand box\u201d for each process.","2 Process Capabilities","A capability can be thought of as an access token that corresponds to a permission to undertake a sensitive action. The purpose of the capability model is to control access to sensitive system resources. The most important resource that requires access control is the kernel executive itself and a system capability (see section 2.1) is required by a client to access certain functionality through the kernel API. All other resources reside in user-side servers accessed via IPC [Inter Process Communication]. A small set of basic capabilities would be defined to police specific client actions on the servers (see ). For example, possession of a make calls capability would allow a client to use the phone server. It would be the responsibility of the corresponding server to police client access to the resources that the capability represents. Capabilities would also be associated with each library (DLL) and program (EXE) and combined by the loader at run time to produce net process capabilities that would be held by the kernel. For open devices, third party software would be assigned capabilities either during software installation based on the certificate used to sign their installation packages or post software installation by the user, as detailed in section 3. The policing of capabilities would be managed between the loader, the kernel and affected servers but would be kernel-mediated through the IPC mechanism.","The key features of the process capability model are:\n\n",{"@attributes":{"id":"p-0029","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"WriteSystemData","Allows modification of configuration system"]},{"entry":[{},{},"data"]},{"entry":[{},"CommDD","Grants access to all communication and"]},{"entry":[{},{},"Ethernet card device drivers."]},{"entry":[{},"DiskAdmin","Can perform administration task on the"]},{"entry":[{},{},"disk (reformat, rename a drive, . . .)."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The process of generating capabilities can be difficult. One has first to identify those accesses that require policing and then to map those requirements into something that is meaningful for a user. In addition, more capabilities means greater complexity and complexity is widely recognised as being the chief enemy of security. A solution based on capabilities should therefore seek to minimise the overall number deployed. The following capabilities map fairly broadly onto the main threats which are unauthorised access to system services (eg. the phone stack) and preserving the confidentiality\/integrity of user data.\n\n","It is necessary to make a distinction between PhoneNetwork and LocalNetwork because it is possible to transmit information across a network without spending any money (eg. Bluetooth piconet). This kind of access may be a very useful third party software enabler but nonetheless represents a local way of leaking sensitive information via a trojan horse so it must be protected with a capability, albeit LocalNetwork PhoneNetwork if granted by the user, would allow trojans seeking to use the phone network as their exit route; that is potentially much more damaging and hence the blunt warning in its description. Root and system capabilities are mandatory, if not granted to an executable, the user of the device cannot decide to do it. Their strict control ensures the integrity of the Trusted Computing Platform. However the way servers check user-exposed capabilities or interpret them may be fully flexible and even user-discretionary.",{"@attributes":{"id":"p-0032","num":"0078"},"figref":"FIG. 1"},"2.3 Assigning Capabilities to a Process","The association of a run-time capability with a process involves the loader. In essence, it transforms the static capability settings associated with individual libraries and programs into a run-time capability that the kernel holds and can be queried through a kernel user library API. The loader applies the following rules:","Rule 1. When creating a process from a program, the loader assigns the same set of capabilities as its program's.","Rule 2. When loading a library within an executable, the library capability set must be greater than or equal to the capability set of the loading executable. If not true, the library is not loaded into the executable.","Rule 3. An executable can load a library with higher capabilities, but does not gain capabilities by doing so.","Rule 4. The loader refuses to load any executable not in the data caged part of the file system reserved to the TCB.","It has to be noted that:\n\n","These rules\n\n","The examples below show how these rules are applied in the cases of statically and dynamically loaded libraries respectively.","2.3.1 Examples for Linked DLLs","The program P.EXE is linked to the library L1.DLL.","The library L1.DLL is linked to the library L0.DLL.","Case 1:\n\n","Case 2:\n\n","The program P.EXE dynamically loads the library L1.DLL.","The library L1.DLL then dynamically loads the library L0.DLL.","Case 1:\n\n","Case 2:\n\n","To prevent impersonation of critical servers, a specific system capability ProtServ has been created. When a process is granted this capability, it can register as a \u2018Protected Server\u2019 to the kernel under a specific name format, for instance starting by \u2018!\u2019. The kernel will reject any name registration starting by \u2018!\u2019 if the calling process does not have ProtServ. However all servers from the protected server community must be trusted not to impersonate another server of this community. It is believed this simple mechanism will achieve a good enough level of security providing that ProtServ is granted only to a small set of services. If two server domains were proven not to be enough, nothing would prevent in the future adding a new domain linked to a new capability and name format.","2.5 Firewall-ing Symbian OS System Servers","2.5.1 Capability Permission Lifetime","With a kernel-mediated process capability model in place, specific policy decisions are delegated to the servers themselves. Each server would have to police itself and would do so differently\u2014some would be more paranoid than others and may decide to check client capability settings per access or may refuse to allow access at all without the requisite capability bit set. Devolving security policy to a local decision at servers represents good abstraction as it means that security policy can be interpreted locally as desired. In addition, interpretation of the presence of the capability bit could be done in one of four ways, namely blanket permission, process permission, session permission and selective access permission.","From a user point of view, it has become more and more difficult to identify the lifetime of a process or a session. For instance, in most smart phones, when the user accesses her Agenda, she does not know if a new Agenda process has been created or if an existing one is being re-used. In the same way, she does not have any idea, when making a telephone call, if the telephone application has created a new session to the phone server or re-use the previous one. It is our belief that users can understand only two ways of granting capabilities: the blanket and the selective access permission.","In line with this, there would be two possible alternatives for interpretation of the presence of a user-exposed capability bit at capability-aware servers:","Blanket permission: Capability is granted as a one off act. If the capability is not present when the process is created, the request fails. All access requiring system capability will be policed this way.","Single action permission: Capability is checked upon each sensitive API call to the server. This means that on each access to the sensitive API call, a dialog box created by the server asks the user if they wish to grant that capability. However the capability only lasts for the duration of the corresponding sensitive API call.","The user perception of this kind of permission must not be confused with when a server will check a required capability. For instance, an application may be granted PhoneNetwork as blanket permission but the phone server will check PhoneNetwork capability at each relevant call made by this application as the kernel will send the client capability set at each IPC call anyway. But as the user will not be asked to make a decision (to grant or not to grant PhoneNetwork for this call), this security check is transparent to the user.","The advantages of this design are:\n\n","The software installer has to support the process capability model to determine what capabilities can genuinely be granted to a piece of code to be installed after manufacture time. There are many ways to do it and this invention does not mandate any. In the following sections, we explore different scenarios based on the existence of a Public Key Infrastructure to illustrate how someone may choose to do it and which issues should be considered.","The software installer may support three main scenarios:\n\n","The trust distinction here is a function of the presence of a root certificate in the signing chain that corresponds to one of the root certificates stored on the device. In the next subsections, we examine these alternatives from a user perspective.","3.1 Installation of Trusted (Signed) Software","In this case, approved client applications would be checked by a recognised authority. Software would then be signed, along with a list of the capabilities it required, into installation packages. Capabilities that could be signed for would be system and user-exposed capabilities. The chain of certificates included with the software is terminated by a root CA known by the software installer, in which case the user can install the software safe in the knowledge that the root CA vouches for it. At install time, the software would be installed on the device without any user feedback, though on some devices it would be possible to examine the details of the signing certificate. Note that any third party software that sought system capability would be forced to go via this route.","3.2 Installation of Untrusted (Signed) Software","In this case, the third party software would not check out against any of the root certificates. The software is signed by an unknown root CA in which case the user would be presented with a warning but could just go ahead and install the software anyway after viewing the contents of the certificate. The software installer would throw up a user dialog at install time, which would offer the user the option of installing the application plus a list of the capabilities the application wished to request. Capabilities that could be granted via this route would be in the range of user-exposed capabilities. In other words, it would not be possible for users to grant system capability to signed software that did not check out against one of the root certificates on the device.","3.3 Installation of Unsigned Software","The scenario here would be similar to 3.2. Third parties would have to request capabilities with their installation package. Again, only user-exposed capabilities would be available via this route\u2014it would not be possible for users to grant system capability to unsigned software.",{"@attributes":{"id":"p-0063","num":"0136"},"figref":"FIG. 2"},"3.4 Control Panel for Revoking Capabilities","In case it is wished to let the user make discretionary security policy decisions after install time, a software installer control panel dialog would be required to provide access to the capability settings currently granted to various installed third party applications. The user would be able to view and optionally grant or revoke user-exposed capabilities for installed third party code. In addition, it would be possible to view a corresponding code signing certificate (if necessary). The following table illustrates what the control panel dialog might look like:",{"@attributes":{"id":"p-0065","num":"0138"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":["Installed","PhoneNetwork","ReadUserData","WriteUserData","LocalNetwork","Certificate"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Good.exe","Not granted","Granted","Not granted","Granted","Checked"]},{"entry":[{},{},{},{},{},"OK -"]},{"entry":[{},{},{},{},{},"click to"]},{"entry":[{},{},{},{},{},"view root"]},{"entry":[{},{},{},{},{},"signing"]},{"entry":[{},{},{},{},{},"cert"]},{"entry":["Bad.exe","Not granted","Not granted","Not granted","Not granted","Unsigned"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}}}}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention will be described with reference to the accompanying drawings, in which",{"@attributes":{"id":"p-0016","num":"0031"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0032"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0033"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
