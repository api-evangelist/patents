---
title: Software platform for radio network
abstract: A pervasive computing system comprises a set of client devices and a network of small computing units, referred to as nodes. The client devices and nodes run programs that communicate with each other to solve a given problem, but the client devices and the nodes use different software execution environments and protocols. A host server acts as an intermediary between the client devices and the nodes, bridging the gap between the different software execution environments and protocols of the client devices and the nodes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07991915&OS=07991915&RS=07991915
owner: Sentilla Corporation
number: 07991915
owner_city: Redwood City
owner_country: US
publication_date: 20090429
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims the benefit of Provisional Application No. 61\/050,549, filed on May 5, 2008, which is hereby incorporated herein by reference.","The present invention generally relates to the field of software systems, and more specifically, to a software platform for facilitating data interchange between units of a pervasive computing system.","Pervasive computing, also known as ubiquitous computing, is an emerging field involving the distribution of data monitoring and processing capabilities beyond a small number of traditional server or client computer systems to additionally include a large number of very small computing units, or nodes, distributed at strategic locations throughout a target environment. The use of large numbers of such nodes has been rendered technologically and economically feasible by recent improvements in electronics design and manufacturing, and this approach may be employed in a number of different applications to solve different categories of problems. For example, in one application, the nodes may be embedded within the structure of a bridge, collecting data such as current structural rigidity in order to continuously monitor and report on the safety and stability of the bridge by providing data to a server-side program. As another example, the nodes may be used in control systems to monitor and control the operations of devices, such as controlling heat output and calculating statistics on the amount of energy expended. As a further example, the nodes could be used to monitor and report on the temperature of devices used in manufacturing, and to issue a warning if the temperature of any devices rises above a safe level. The number of such applications which may be constructed using the nodes is numerous and greatly varied.","In conventional systems employing such nodes, creating and deploying the programs that run on the client, servers, and nodes is difficult. This is particularly so in the case of one or more networks of nodes, each node of which has limited hardware resources and thus typically requires its programs to be written in a very low-level language, such as C or assembly. Since client and server systems lack such hardware constraints, their programs are typically written in a higher-level language, such as Java. Further, the nodes, having limited resources, typically use different protocols, e.g. communication protocols, than the more powerful clients. Thus, enabling node and client programs to communicate to solve a given problem is difficult, requiring proper translation both of programs and other data and of protocols. Such translation requires a great deal of effort and care, requiring tedious and error-prone programming to implement.","A pervasive computing system comprises a set of client devices and a network of small computing units, referred to as nodes. The client devices and nodes run programs that communicate with each other to solve a given problem, but the client devices and the nodes use different software execution environments and protocols. A host server acts as an intermediary between the client devices and the nodes, bridging the gap between the different software execution environments and protocols of the client devices and the nodes.","In one embodiment, the client devices execute programs written using an object-oriented programming language. The host server then provides translation of objects and classes into a form executable on the nodes, and further implements communications protocols and protocol translations of both the client devices and the nodes.","The figures depict embodiments of the present invention for purposes of illustration only. One skilled in the art will readily recognize from the following description that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles of the invention described herein.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1","b":["100","110","115","115","105","110","115","105"]},"There may be any number of nodes A within node network , from only one or two to hundreds, thousands, or more. The nodes A may be arranged in any configuration, as appropriate for the application for which they are employed. In one embodiment, communication between individual nodes A and the host  occurs via short-distance radio transmission, such that some nodes A may not be able to communicate directly with other nodes within the node network . In such a case, the transmission protocols employed within the node network  must support data forwarding in order to allow communication across the entire set of nodes A. The nodes A of node network  may all be running programs designed to solve the same problem, or they may be running different applications but using a common host server . In one embodiment, the various nodes A may be physically different and have different software execution environments. A given node network  may have exactly one host server , or may have multiple host servers . Similarly, a given host server  may communicate with a single node network , or with many.","The client devices  can serve several purposes within the architecture . They can be used for development of the programs that together solve the problem in question. This includes both the programs that execute on the clients , and those that execute on the nodes A. In one embodiment, a client  used for program development includes an integrated development environment used to author and debug programs and to deploy them across the architecture .","Additionally, the client devices  can execute the client programs, including displaying data and accepting user input, as appropriate to the problem. For example, when the problem is that of monitoring device temperatures, a client application could graphically display the monitored devices and their temperatures, and accept input specifying that a particular device should be shut off or run in a different manner. It is appreciated that a client device  that executes the applications need not be the same client  that is used to develop the applications. A given client device  might perform either or both functions. Physically, the client devices  may be any one of a number of conventional computing devices including, but not limited to, desktop computer systems, laptop computer systems, mainframe systems, personal digital assistants (PDAs), or cellular phones. In one embodiment, a client device  uses, as one of its software execution environments, a standard Java virtual machine. (A \u201csoftware execution environment\u201d as described herein represents the physical and\/or software environment required to execute the programs in question. For example, a Java virtual machine supporting class files and objects having a particular data format is one instance of a software execution environment.) In another embodiment, a client device  uses, as one of its software execution environments, a web platform (such as Python, Perl, Ruby, or PHP) to present data objects to users through the Internet.","A client  communicates with a host server , and thence indirectly with a node network , using a conventional computer communications network. In one embodiment, the communications network is the Internet or a LAN. The communications network can also use dedicated or private communications links that are not necessarily part of the Internet. In one embodiment, the communications network uses standard communications technologies and\/or protocols such as Ethernet, 802.11, etc. Similarly, the networking protocols used on the communications network can include the transmission control protocol\/Internet protocol (TCP\/IP), the hypertext transport protocol (HTTP), or the like. The data exchanged over the network  can be represented using technologies and\/or formats including the hypertext markup language (HTML), the extensible markup language (XML), etc. In addition, all or some of the links can be encrypted using conventional encryption technologies such as the secure sockets layer (SSL), Secure HTTP and\/or virtual private networks (VPNs). In another embodiment, the entities can use custom and\/or dedicated data communications technologies instead of, or in addition to, the ones described above.","The host server , among its other functions, acts as an intermediary between the nodes A and the clients , which use different communication protocols, for example. This intermediary functionality is accomplished using a \u201cvirtual node\u201d , which, as discussed below in more detail, is accomplished with code implementing a node application programming interface (API) and providing data format translation. Similarly, by executing code implementing client communications protocols, the host server  also implements a \u201cvirtual client\u201d . Thus, both nodes A and clients  may communicate with each other using their own protocols, without knowing about protocols and data formats other than their own. The host server  may have any number of virtual nodes  and virtual clients , though for simplicity only one virtual node and one virtual client are depicted in .",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2","b":["115","115","115","115","8085","115","105","115","110","115","110"]},"Described at a logical level, a node A comprises a physical layer , an execution environment layer , a system services layer , and an application layer . The physical layer  includes the resources noted above, including a communication device such as a radio transmitter, sensors and actuators, and persistent and non-persistent storage devices such as RAM and flash memory. The execution environment layer  in one embodiment includes an embedded kernel for providing basic operating system functionality such as access to memory and I\/O devices. The execution environment layer  may further include a language runtime for executing programs. For example, in one embodiment the client  and node A programs are written with the Java programming language, and the node execution environment layer  thus includes a Java Virtual Machine to execute node programs, although such a Java Virtual Machine is specialized in order to accept smaller, more optimized object formats, for example. In such an embodiment, the execution environment layer  is stored in a persistent storage medium, such as read-only memory (ROM) or flash memory, and may be loaded into RAM when the node A begins to operate. In another embodiment, the execution environment layer  may be executed, partially or entirely, directly from the persistent storage medium, rather than first being loaded into RAM.","The system services layer  includes a number of services that support the operations of programs run on the node A. For example, the system services layer  includes implementations of networking protocols, such as IEEE standard 802.15.4, used to send and receive data. It also includes implementations of protocols specific to the node network . For example, in one embodiment, nodes of the node network  run an object distribution protocol based on forwarding that ensures that all participating nodes have the latest version of the object in question, and an object dispatcher protocol that accepts and responds to messages based the type of an object type contained in the message.","The system services layer  further includes services for using any sensors and\/or actuators included as part of the node A, such as reading the values provided by a temperature sensor. It further includes file system services for persistently storing data on the node A itself, and a driver registry for accessing peripherals, communication protocols, and other hardware components. In one embodiment, the services of system services layer  are stored in flash memory and loaded into RAM when the node begins to operate. In another embodiment, the services may be executed, partially or entirely, directly from the persistent storage medium, rather than first being loaded into RAM.","The application layer  includes programs executed by the node A. Programs could include, for example, monitoring a value provided by a temperature sensor and sending a notification if it exceeds some threshold, or specifying a policy regulating the communication interface, or setting control values for an actuator needed to implement an appropriate response, often based on sensor input. In one embodiment, the programs are stored in the persistent storage medium of the node A, e.g., within flash memory, and are executed directly from the persistent storage medium. In another embodiment, the programs are not persistently stored on the node A, but rather are received via the communications device and loaded into RAM during the execution of the node A. Other embodiments combining these approaches, such as persistently storing the applications and partially loading them into RAM, are equally possible. The program code that is executed includes calls to the services of the system services layer .",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3","b":["105","106","105","115","110","115","115","105","110","115","105","110","115"]},"The following description of the actions of the host server  relates to an example embodiment in which the client and node programs are written using the Java programming language and executed using a Java Virtual Machine runtime. Java programs are composed of objects, and the class files embodying them\u2014including those with main( ) methods, which therefore can act as executable programs\u2014are themselves represented as objects, and the example embodiment thus particularly focuses on the handling of objects. It is appreciated, however, that the invention is not limited to program development in the Java programming language or even to object-oriented programming languages and object models in general, but rather is applicable to systems in which the execution environment of the client  differs from that of a node A.","In the example embodiment, the host server  includes a node API A and a client API B, a communication bridge , a translation module , and translation databases A and B, which together provide the functionality required to properly translate between a client  and a node A. Each instance of a virtual node , such as an instance for a particular type of node such as a power distribution system component, has its own node API A and translation database A. Similarly, each instance of a virtual client , such as an instance for a particular type of client, has its own client API B and translation database B. The node API A allows the host server  to emulate a node A. Because the physical resources of the nodes A are limited, the various nodes A communicate as if they were speaking only to other nodes A, thus freeing them from the extra processing requirements of determining the source or destination of a message and performing any necessary translation between formats. The node API A allows the host server  to emulate functions of a node, thereby in effect creating a virtual node  within the host server . In this way, the nodes can interact with the virtual node  in the host server  as if the host server  were merely another node.","In order to fully allow this virtual node  to simulate a physical node A, the node API A for the virtual node instance corresponding to the type of the node A includes an implementation of each node protocol run by system services layer  of a node A. For example, to distribute a program or data value from a client  to the various nodes A of the node network , the client calls an appropriate function of the node API A of the host server  and passes the program or data value to that API function. The host server  then executes the API function, which simulates the node object distribution protocol, e.g., by packaging the program or data value within a message packet along with an appropriate version number and a code indicating that the packet relates to the node object distribution protocol, as done by the node object distribution protocol itself. This may also require that the program or data value packaged within the message packet be properly translated to a form usable by a node A, as described below in conjunction with the translation database A.","Similarly, when receiving a message packet from the nodes A that is formatted according to the node object distribution protocol, for example, the host server  examines the message packet and recognizes, via an appropriate code in the packet header, that the message packet is intended for distribution to other nodes A and clients . Consequently, the host server  calls the node API function implementing the node object distribution protocol and thereby retransmits the message packet in order to reach nodes A that may have been out of communication range of the other nodes. The host server  also translates and transmits to clients  any application classes or objects contained within the message.","The translation module  accounts for the different object formats and other data formats used by the clients  and by the nodes A by translating objects as appropriate. For example, when a client  wishes to have the node network  run a particular program embodied in a given Java class, the translation module  translates the class from the standard Java class format used by the client  to the optimized format suitable for the more constrained physical resources of a node A. This translation involves reconstructing the class file created on the client  by a standard Java compiler, including re-linking by updating the references to standard Java classes to reflect their node-optimized equivalents, resizing primitive and reference variables to reflect their smaller, more memory-efficient representations within the node-optimized version of the Java Virtual Machine used to execute code on the nodes A, changing memory references as needed to reflect repositioning in memory of the resized variables, and re-applying the applicable digital signature algorithm to the node-optimized version of the class if the original class had been signed. Translation of abstract classes, interfaces, and the like is performed in similar fashion.","Similarly, when an object is transferred from a client  to a node A, the translation module  translates the object from a standard client representation to a node-optimized representation. In one embodiment, this is performed by de-serializing the byte stream representation of the object provided by the client , and then re-serializing the object in a node-optimized representation before sending it over the network to the node A. When an object refers to other objects, this translation process is performed recursively until all objects have been translated to node-optimized representations. The process is similar when transferring in the other direction, from a node A to a client .","In one embodiment, the object translation module  can translate between many different object formats. For example, it can receive a Java Archive (\u201cJAR\u201d) file storing program class files from a client , extract the individual class files from the JAR file, and translate each from the class file format of the Java Virtual Machine of the client  to the node-optimized format of the nodes A. As another example, the host server  can receive an object specified in the Simple Object Access Protocol (SOAP), using the client protocols of the virtual client  to accept the object using SOAP, and the object translation module  can translate the SOAP object from XML to the node-optimized object format of the nodes A.","The translation database  stores the results of the translation module  so as to speed up future data transfers. For example, the first time that a client  wishes to deploy a particular version of a program on the node network , the host server  stores both the class file embodying the application and the node-optimized version provided by the translation module  within the translation database A for the virtual node for the appropriate node type. The translation database  is additionally updated to include a mapping between the client and node versions of the program. In one embodiment, the translation database is a conventional relational database, with optimized and non-optimized class files stored as binary objects in a class table with a unique identifier\u2014such as the fully qualified class name\u2014as the primary key, and pairs of unique identifiers relating the original class file and node-optimized class file stored in a second table.","The communication bridge  serves as the intermediary between the client  and the node network . When a message packet arrives from a node A or a client , the communication bridge examines the message, employing the node API A as described above to create a message for the node network , or to receive a message from the node network , as the case may be. This includes performing class or object translation via the translation module . After classes and objects have been properly translated and messages formatted via the node API A to conform to the desired destination (i.e. a client  and\/or the node network ), the communication bridge  then sends the resulting message using the network protocols and network interface that are associated with the destination.","It should be noted that that virtual client  of the host server  can perform any translation necessary for communication between host server  and the clients  in a similar fashion to the above-described translation between the host server  and the nodes A performed by the virtual node . For example, if the clients  communicate using Web Services protocols such as SOAP, the virtual client  implements the protocols using the client API B, thus allowing the clients  to communicate with it as if it were another client. Similarly, if a client  happens to use a software execution environment different from that of the host server , the virtual client  can perform data format translations similar to those performed by the virtual node  using the translation database B.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 4","b":["105","115"]},"Initially, the host server  receives  a program to be distributed to all nodes A, or to a subset thereof. This may occur, for example, after a user creates programs to be executed on the clients  and nodes A and, and indicates using user interface functionality on the client  that the node programs are to be deployed on the appropriate nodes A. For example, after successful program compilation, a user could choose a \u201cDeploy to nodes\u201d option provided within the IDE used to develop the programs. As a result, the client  would transmit a copy of the node program to the host server  for distribution to the nodes.","The host server  then translates  the program from the format specific to the client  to a format suited to execution by a node A. The translation process is performed by the translation module , as discussed above. Following translation of the program format, the translation database  may be updated , as discussed above, in order to prevent the need to repeat the translation of the program in future.","Finally, the host server  distributes  the translated, node-optimized version of the program to the appropriate nodes A for execution. In one embodiment, this is performed according to the distribution protocol referenced above, in which a version number is provided along with each program or object being sent, and the various nodes A broadcast advertisements of the latest version that they possess and\/or request a copy of a newer version in response to an advertisement. If the program is of a type in which a node A is interested, then handler code on the node A reads the received code and causes it to be loaded and executed by the node A.","The process of distributing objects from a client  to a node A occurs in similar manner to the distribution of programs, involving object translation from client to node formats, possible updating of the translation database , and distribution to the nodes A using a node object distribution protocol. The provision of objects in a reverse direction, from a node A to a client , is likewise similar, but with object translation being from a node to a client format, and without the need to use an object distribution protocol to deliver the object to the appropriate client .","It is appreciated that the operations of the invention are not limited to those involved in distributing a program, as discussed above with respect to ; rather, the steps of  are merely illustrative of one example scenario in which the invention is employed\u2014namely, translation of an object distributed from a client  to nodes A, in which the object is a program. Other equally possible scenarios include the transmission of non-program objects from nodes A to a client  and the transmission of non-object data, as well as other situations previously discussed.","In sum, the embodiments described above provide a uniform software platform to software developers creating applications for pervasive computing systems. Thus, programs, whether destined to be executed on a node network or on a traditional client system, may be authored using a single programming language or object model, thus greatly simplifying application development.","Some portions of above description describe the embodiments in terms of algorithms and symbolic representations of operations on information. These algorithmic descriptions and representations are commonly used by those skilled in the data processing arts to convey the substance of their work effectively to others skilled in the art. These operations, while described functionally, computationally, or logically, are understood to be implemented by computer programs or equivalent electrical circuits, microcode, or the like. Furthermore, it has also proven convenient at times to refer to these arrangements of operations as modules, without loss of generality. The described operations and their associated modules may be embodied in software, firmware, hardware, or any combinations thereof.","As used herein any reference to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular element, feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification are not necessarily all referring to the same embodiment.","As used herein, the terms \u201ccomprises,\u201d \u201ccomprising,\u201d \u201cincludes,\u201d \u201cincluding,\u201d \u201chas,\u201d \u201chaving\u201d or any other variation thereof, are intended to cover a non-exclusive inclusion. For example, a process, method, article, or apparatus that comprises a list of elements is not necessarily limited to only those elements but may include other elements not expressly listed or inherent to such process, method, article, or apparatus. Further, unless expressly stated to the contrary, \u201cor\u201d refers to an inclusive or and not to an exclusive or. For example, a condition A or B is satisfied by any one of the following: A is true (or present) and B is false (or not present), A is false (or not present) and B is true (or present), and both A and B are true (or present).","In addition, use of the \u201ca\u201d or \u201can\u201d are employed to describe elements and components of the embodiments herein. This is done merely for convenience and to give a general sense of the invention. This description should be read to include one or at least one and the singular also includes the plural unless it is obvious that it is meant otherwise.","Upon reading this disclosure, those of skill in the art will appreciate still additional alternative structural and functional designs for a system and a process for providing a uniform software interface in a pervasive computing environment through the disclosed principles herein. Thus, while particular embodiments and applications have been illustrated and described, it is to be understood that the disclosed embodiments are not limited to the precise construction and components disclosed herein. Various modifications, changes and variations, which will be apparent to those skilled in the art, may be made in the arrangement, operation and details of the method and apparatus disclosed herein without departing from the spirit and scope defined in the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
