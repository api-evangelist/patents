---
title: Hierarchical bounding of displaced parametric surfaces
abstract: Hierarchical bounding of displaced parametric surfaces may be a very common use case for tessellation in interactive and real-time rendering. An efficient normal bounding technique may be used, together with min-max mipmap hierarchies and oriented bounding boxes. This provides substantially faster convergence for the bounding volumes of the displaced surface, without tessellating and displacing the surface in some embodiments. This bounding technique can be used for different types of culling, ray tracing, and to sort higher order primitives in tiling architectures.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08144147&OS=08144147&RS=08144147
owner: Intel Corporation
number: 08144147
owner_city: Santa Clara
owner_country: US
publication_date: 20100407
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["This relates generally to graphics processing and, particularly, to tessellation in rendering systems, such as interactive, real time, and off-line\/film rendering.","Modern graphics processors contain dedicated hardware for tessellating surfaces into many small triangles. The DirectX 11 application programming interface (\u201cDX11\u201d) (API) adds three new stages to the graphics pipeline to support tessellation: the hull shader, the fixed-function tessellator and the domain shader. The hull shader is executed once per patch and once per control point, typically to compute tessellation factors and change control point bases. The fixed-function tessellator takes tessellation factors as inputs and generates a large set of vertex positions in the domain of the input primitive and connectivity information between vertices. The connectivity information forms many small triangles. The domain shader is executed once per generated vertex position from the tessellator. A typical domain shader usage is evaluating the position and normal of a parametric surface, using, for example, a set of control points, barycentric coordinates, and a detailed texture as inputs. The output is a displaced vertex defined by a set of attributes. One attribute is the position, but the shader also can compute the normal\/tangent\/bi-tangent\/texture coordinate\/color\/transparency or other attribute of the displaced vertex.","Reducing the number of domain shader evaluations reduces the computational resources needed for that stage of a graphics pipeline. This can be done by culling patches which do not contribute to the final image. To make this culling efficient, an algorithm for computing hierarchical bounds of displaced surfaces may be used.","Furthermore, in tile-based rendering architectures, bounds for input primitives are needed to efficiently sort the input primitives into tiles. A \u201cbounding volume\u201d is a volumetric object, such as a box or sphere, that encloses another object. Since the domain shader is programmable, it is hard to give conservative and tight bounds of the output positions, which may give rise to a need to sort the generated small triangles individually into tiles. This increases the memory requirements on the tile queues, increases bandwidth usage, and reduces the efficiency of occlusion culling on a patch primitive level.","These bounds may, instead, be computed on the fly (block ) based on the domain shader only without any need for a user specified parameter, as indicated in . The bounds may then be adaptively refined as the primitive is split into smaller sub-patches to create a hierarchy. In one embodiment, an algorithm enables conservative and tight bounding of dynamic displaced parametric surfaces, such as B\u00e9zier patches, using efficient normal bounding, oriented bounding boxes and min-max mipmap hierarchies of the displacement texture. The patch may be culled (block ). If not, then the primitive may be subjected to tessellation and domain shading (block ).","Since the patch does not have to be sent to the tessellator, both domain shader and tessellator tasks may be reduced for the patch in some embodiments. If the input patch is culled, then no tessellation and domain shading may be done in some embodiments. Similarly, if a sub-patch is culled, no further processing of that sub-patch may be done in some embodiments. Otherwise, the sub-patch is tessellated and domain shaded.","Collections of bi-cubic B\u00e9zier patches are popular rendering primitives for smooth surfaces. Known algorithms may be used for translating Catmull-Clark subdivision surfaces to collections of such parametric patches, while faithfully approximating the limit surface of the recursive subdivision process. It is common to add displacements from high resolution textures in the direction of the normal vector of the patch in order to increase the detail of the final surface.","The B\u00e9zier patch with displacement may be used in a domain shader in the rendering API. The B\u00e9zier patch is compactly represented by its control points, and this parametric surface representation can be efficiently evaluated in parallel (unlike recursive subdivision surfaces).","A B\u00e9zier patch, p(u,v), is a parametric surface, that is, a surface defined over two parametric coordinates, u and v. The term \u201cbase patch\u201d denotes the B\u00e9zier patch which has not yet been displaced, to distinguish it from the final displaced surface. A domain shader that evaluates a displaced B\u00e9zier patch at a parametric coordinate, (u,v), computes the base patch position, p(u,v), the base patch's normalized normal {circumflex over (n)}(u,v) and a displacement value (usually) taken from a texture, t(u,v). If the displacement acts in the base patch's normal direction, the domain shader (before multiplication with the model-view-projection matrix) is then:\n\n()=()+{circumflex over ()}()()\u2003\u2003(1)\n","Multiplying d(u,v) by the model view projection matrix, M, the clip space position, q, in homogeneous coordinates is obtained:\n\n()=()=(()+{circumflex over ()}()())\u2003\u2003(2)\n","The normalized device coordinates are given by s=q\/qand s=q\/q.","A conservative bounds of q(u,v) over a parametric domain, where a<=u<=b and c<=v<=d can be found.","Next, we describe how we bound p(u,v). B\u00e9zier patches have the convex hull property and they can be easily bounded by their control points. Finding an axis-aligned bounding box (AABB) for a B\u00e9zier patch accounts for 3 min and 3 max operations per control point.","By repeatedly applying B\u00e9zier subdivision, the control point cages of the subdivided patches converge quickly towards the underlying base patch. Furthermore, if the original patch is recursively split in two pieces, pand p, in each step, the de Casteljau steps needed to generate pwill generate the control points for pas a side product. This allows for an efficient implementation.","We can derive axes for an oriented bounding box (OBB) from the control points of the base patch defined axes. This box encloses the base patch more tightly than an AABB. For each of the two subdivided patches in the same iteration both the base patch, the normal patch, and the displacement texture and lookup is refined. Referring to  which shows steps which are used to compute the bounds of the displaced surface indicated in block  in , the base patch is subdivided along one axis using B\u00e9zier subdivision. The base patch bounding, indicated in block , involves finding the OBB axes from control points and projecting all control points on these axes. Then the minimum and maximum along each axis is located to derive an OBB that contains all of the control points, and the convex hull property of B\u00e9zier patches means that the surface is contained in this OBB.","Next, as indicated in block , the displacement minimum and maximums are looked up in a min\/max texture hierarchy. Thereafter, in diamond , a check determines whether the displacement is zero. If so, the model view projection is applied to the eight corners of the patch's bounding box (block ) and the bounds are returned (block ). If the displacement is not zero, normal bounding is done in block  using one of the techniques to be described hereinafter called TPATCH and NPATCH, before doing the model view projection transform (block ) and returning the bounds (block ). Finally, in block , the model view projection transform is applied.","For B\u00e9zier patches, the vectors between the corner control points () are summed to get two axes (, block ). Given a patch with (m+1)x(n+1) control points, we denote the four corner control points C, c, cand c, and form the two vectors:\n\n\u2003\u2003(3)\n\n\u2003\u2003(4)\n\nt and b can be seen as approximate average gradients in the u and v parametric directions respectively. They do not have to be orthogonal. Their cross product (, block ) gives a third axis: n=t cross product of b. To form an orthonormal coordinate system, we set x=t, y=n cross product of t, and z=n and normalize each vector (, block ). The final coordinate system is: ({circumflex over (x)},\u0177,{circumflex over (z)}). This significantly reduces the size of the bounding boxes compared to using AABBs in most cases. More elaborate OBB fitting schemes based on the control point cage could be derived, but in practice, the simple approach above produces axes for OBBs that bound the surface tightly. The difference in quality between bounding with AABBs and OBBs is highlighted in  for curves and in  for a B\u00e9zier patch. For degenerate cases, we simply use an AABB. As we will show below, the OBB axes are also very useful in the normal bounding algorithms.\n","Bounding the patch normal, {circumflex over (n)}(u,v), over a domain is considerably more difficult than bounding the base position, p(u,v). The normal direction is computed as the cross product of two parametric derivatives of the base patch, p(u,v).","Following standard notation for tensor product B\u00e9zier surfaces, a B\u00e9zier patch P(u,v): R?Ris defined by:",{"@attributes":{"id":"p-0033","num":"0032"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"msup":{"mi":"p","mrow":{"mi":["m","n"],"mo":","}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["u","v"],"mo":","}}},{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"0"},"mi":"m"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"j","mo":"=","mn":"0"},"mi":"n"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":{"mi":"c","mrow":{"mi":["i","j"],"mo":","}},"mo":["\u2062","\u2062"],"mrow":[{"msubsup":{"mi":["B","i","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"u"}},{"msubsup":{"mi":["B","j","n"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"v"}}]}}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"5"}}]}}}},"br":{},"sub":["i,j ","i","j"]},"The partial derivatives can be written as",{"@attributes":{"id":"p-0035","num":"0034"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"mrow":[{"mfrac":{"mrow":[{"mo":"\u2202","mi":"p"},{"mo":"\u2202","mi":"u"}]},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mi":["u","v"],"mo":","}}},{"munderover":{"mo":"\u2211","mrow":{"mi":"j","mo":"=","mn":"0"},"mi":"n"},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":[{"mi":"i","mo":"=","mn":"0"},{"mi":"m","mo":"-","mn":"1"}]},"mo":"\u2062","mrow":{"msub":{"mi":"a","mrow":{"mi":["i","j"],"mo":","}},"mo":["\u2062","\u2062"],"mrow":[{"msubsup":{"mi":["B","i"],"mrow":{"mi":"m","mo":"-","mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"u"}},{"msubsup":{"mi":["B","j","n"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"v"}}]}}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"6"}}]},{"mtd":[{"mrow":{"mrow":[{"mfrac":{"mrow":[{"mo":"\u2202","mi":"p"},{"mo":"\u2202","mi":"v"}]},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mi":["u","v"],"mo":","}}},{"munderover":{"mo":"\u2211","mrow":{"mi":"i","mo":"=","mn":"0"},"mi":"m"},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":[{"mi":"j","mo":"=","mn":"0"},{"mi":"n","mo":"-","mn":"1"}]},"mo":"\u2062","mrow":{"msub":{"mi":"b","mrow":{"mi":["i","j"],"mo":","}},"mo":["\u2062","\u2062"],"mrow":[{"msubsup":{"mi":["B","j"],"mrow":{"mi":"n","mo":"-","mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"v"}},{"msubsup":{"mi":["B","i","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"u"}}]}}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"7"}}]}]}}},"br":[{},{},{},{}],"in-line-formulae":[{},{},{},{}],"i":["a","=m","c","\u2212c","b","=n","c","\u2212c"],"sub":["i,j","i+1,j","i,j","i,j","i,j+1","i,j","i,j ","i,j "]},{"@attributes":{"id":"p-0036","num":"0035"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"n","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["u","v"],"mo":","}}},{"mrow":[{"mo":["(",")"],"mrow":{"msub":[{"mi":["n","x"]},{"mi":["n","y"]},{"mi":["n","z"]}],"mo":[",",","]}},{"mfrac":[{"mrow":[{"mo":"\u2202","mi":"p"},{"mo":"\u2202","mi":"u"}]},{"mrow":[{"mo":"\u2202","mi":"p"},{"mo":"\u2202","mi":"v"}]}],"mo":["\u2062","\u00d7","\u2062"],"mrow":[{"mo":["(",")"],"mrow":{"mi":["u","v"],"mo":","}},{"mrow":{"mo":["(",")"],"mrow":{"mi":["u","v"],"mo":","}},"mo":"."}]}],"mo":"="}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"10"}}]}}}},"br":{}},{"@attributes":{"id":"p-0037","num":"0036"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mover":{"mi":"n","mo":"^"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["u","v"],"mo":","}}},"mo":"=","mfrac":{"mi":"n","msqrt":{"mrow":{"msubsup":[{"mi":["n","x"],"mn":"2"},{"mi":["n","y"],"mn":"2"},{"mi":["n","z"],"mn":"2"}],"mo":["+","+"]}}}}},{"mrow":{"mo":["(",")"],"mn":"11"}}]}}}},"br":{}},"To apply displacement, we need the normalized normal. The normalization operation (Equation 11) needs bi-degree 2(m+n\u22121, m+n\u22121) for an exact representation of the subexpressions: n, n, and n. For a bi-cubic B\u00e9zier patch, these terms can be represented exactly as a bi-degree (10,10) B\u00e9zier patch. In many cases, this is prohibitively expensive (11\u00b711=121 control points). Finally, the reciprocal square root cannot be represented exactly with Bernstein polynomials. In addition, the operand to the reciprocal square root should always be larger than or equal to zero, since the operand is the squared length of the normal. If this is not true, inf or NaN may result. Therefore the bounded representation of n+n+nshould be strictly greater than zero. This seems trivial at a first glance, as the square root of a sum of three squared (real) terms should be greater than or equal to zero. However, this can be difficult in practice as we use the bounding box of the control point cage for bounding, and there is no guarantee that all control points will be positive.","Here, we describe a normal bounding algorithm, which avoids most of the problems discussed above. In summary, normal vector B\u00e9zier patch is derived from the parametric derivatives (, block ), then its control points are projected on the unit sphere (, block ) and their solid angle on the unit sphere is bounded in an OBB coordinate frame (, block ), which gives a conservative bound of the normalized normal. We denote this normal bounding approach NPATCH.","Recall that the normal is defined by:",{"@attributes":{"id":"p-0041","num":"0040"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"n","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["u","v"],"mo":","}}},{"mfrac":[{"mrow":[{"mo":"\u2202","mi":"p"},{"mo":"\u2202","mi":"u"}]},{"mrow":[{"mo":"\u2202","mi":"p"},{"mo":"\u2202","mi":"v"}]}],"mo":["\u2062","\u00d7","\u2062"],"mrow":[{"mo":["(",")"],"mrow":{"mi":["u","v"],"mo":","}},{"mo":["(",")"],"mrow":{"mi":["u","v"],"mo":","}}]}],"mo":["=","\u2062"],"mi":{}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"j","mo":"=","mn":"0"},"mi":"n"},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":[{"mi":"i","mo":"=","mn":"0"},{"mi":"m","mo":"-","mn":"1"}]},"mo":"\u2062","mrow":{"msub":{"mi":"a","mrow":{"mi":["i","j"],"mo":","}},"mo":["\u2062","\u2062","\u00d7"],"mrow":[{"msubsup":{"mi":["B","i"],"mrow":{"mi":"m","mo":"-","mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"u"}},{"msubsup":{"mi":["B","j","n"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"v"}}]}}}}}},{"mtd":{"mrow":{"mi":{},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"k","mo":"=","mn":"0"},"mi":"m"},"mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":[{"mi":"l","mo":"=","mn":"0"},{"mi":"n","mo":"-","mn":"1"}]},"mo":"\u2062","mrow":{"msub":{"mi":"b","mrow":{"mi":["k","l"],"mo":","}},"mo":["\u2062","\u2062"],"mrow":[{"msubsup":{"mi":["B","k","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"u"}},{"mrow":{"msubsup":{"mi":["B","l"],"mrow":{"mi":"n","mo":"-","mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"v"}},"mo":"."}]}}}}}}]}},{"mrow":{"mo":["(",")"],"mn":"12"}}]}}}},"br":{}},{"@attributes":{"id":"p-0042","num":"0041"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mrow":[{"msubsup":{"mi":["B","i","m"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"u"}},{"msubsup":{"mi":["B","j","n"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"u"}}],"mo":"\u2062"},{"mfrac":{"mrow":[{"mrow":[{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"mi":"m"}},{"mtd":{"mi":"i"}}]}},{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"mi":"n"}},{"mtd":{"mi":"j"}}]}}],"mo":"\u2062"},{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"mrow":{"mi":["m","n"],"mo":"+"}}},{"mtd":{"mrow":{"mi":["i","j"],"mo":"+"}}}]}}]},"mo":"\u2062","mrow":{"msubsup":{"mi":"B","mrow":[{"mi":["i","j"],"mo":"+"},{"mi":["m","n"],"mo":"+"}]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"u"}}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"13"}}]}}}},"br":{}},{"@attributes":{"id":"p-0043","num":"0042"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"munder":{"mo":"\u2211","mrow":{"mi":["i","j","k","l"],"mo":[",",",",","]}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":[{"mi":"a","mrow":{"mi":["i","j"],"mo":","}},{"mi":"b","mrow":{"mi":["k","l"],"mo":","}}],"mo":["\u00d7","\u2062","\u2062","\u2062"],"mfrac":{"mrow":[{"mrow":[{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"mrow":{"mi":"m","mo":"-","mn":"1"}}},{"mtd":{"mi":"i"}}]}},{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"mi":"m"}},{"mtd":{"mi":"k"}}]}},{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"mi":"n"}},{"mtd":{"mi":"j"}}]}},{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"mrow":{"mi":"n","mo":"-","mn":"1"}}},{"mtd":{"mi":"l"}}]}}],"mo":["\u2062","\u2062","\u2062"]},{"mrow":[{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"mrow":{"mi":["m","n"],"mo":["+","-"],"mn":"1"}}},{"mtd":{"mrow":{"mi":["i","k"],"mo":"+"}}}]}},{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"mrow":{"mi":["m","n"],"mo":["+","-"],"mn":"1"}}},{"mtd":{"mrow":{"mi":"j","mo":"+","mn":"1"}}}]}}],"mo":"\u2062"}]},"mrow":[{"msubsup":{"mi":"B","mrow":[{"mi":["i","k"],"mo":"+"},{"mi":["m","n"],"mo":["+","-"],"mn":"1"}]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"u"}},{"mrow":{"msubsup":{"mi":"B","mrow":[{"mi":"j","mo":"+","mn":"1"},{"mi":["m","n"],"mo":["+","-"],"mn":"1"}]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"v"}},"mo":"."}]}}},{"mrow":{"mo":["(",")"],"mn":"14"}}]}}}},"br":{},"sub":"p,q"},{"@attributes":{"id":"p-0044","num":"0043"},"maths":{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"msub":{"mi":"v","mrow":{"mi":["p","q"],"mo":","}},"mo":"=","mrow":{"munder":{"mo":"\u2211","munder":{"mrow":[{"mrow":{"mi":["i","k"],"mo":"+"},"mo":"=","mi":"p"},{"mrow":{"mi":"j","mo":"+","mn":"1"},"mo":"=","mi":"q"}]}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":[{"mi":"a","mrow":{"mi":["i","j"],"mo":","}},{"mi":"b","mrow":{"mi":["k","l"],"mo":","}}],"mo":["\u00d7","\u2062"],"mfrac":{"mrow":[{"mrow":[{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"mrow":{"mi":"m","mo":"-","mn":"1"}}},{"mtd":{"mi":"i"}}]}},{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"mi":"m"}},{"mtd":{"mi":"k"}}]}},{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"mi":"n"}},{"mtd":{"mi":"j"}}]}},{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"mrow":{"mi":"n","mo":"-","mn":"1"}}},{"mtd":{"mi":"l"}}]}}],"mo":["\u2062","\u2062","\u2062"]},{"mrow":[{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"mrow":{"mi":["m","n"],"mo":["+","-"],"mn":"1"}}},{"mtd":{"mrow":{"mi":["i","k"],"mo":"+"}}}]}},{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"mrow":{"mi":["m","n"],"mo":["+","-"],"mn":"1"}}},{"mtd":{"mrow":{"mi":"j","mo":"+","mn":"1"}}}]}}],"mo":"\u2062"}]}}}}},{"mrow":{"mo":["(",")"],"mn":"15"}}]}}}}},"To conservatively bound the base patch's normal over the patch, we exploit the fact that the normal after normalization is of unit length. Therefore, we normalize the control vectors, v, so that they are represented by points on the unit sphere.","A fast way to derive these bounds is to use the i-axis from the OBE coordinate frame, which is an approximation of the patch's normal, and simply compute the minimal scalar product between any normalized control point and the axis. This gives the cosine of the half-angle of a cone enclosing the normalized directions. This is illustrated in .","For a bi-cubic B\u00e9zier patch, the computation of vincludes 144 cross products. The binomial coefficients can be pre-computed in a small lookup table.","Note, however, that all correlation of which direction corresponds to which parametric coordinate is lost. The tightness of the approach depends on whether the unnormalized normal can be bound reasonably well, which can be hard over large domains, but becomes easier as the subdomain shrinks.","Coarser bounds can be obtained more quickly by forming two tangent cones from the control points of the first order parametric derivative patches \u2202p\/\u2202u and \u2202p\/\u2202v (see Equations 6 and 7). The control points of the derivative patches are normalized and bounded on the unit sphere, (as shown in ), forming two cones T:{{circumflex over (t)},\u03b1} and B:{{circumflex over (b)},\u03b1}. A cone, T, is defined by a normalized axis {circumflex over (t)} and a half-angle \u03b1.","If the cones T and B do not overlap, a cone N: ({circumflex over (n)},\u03b8) that bounds all possible cross products of two vectors, one from each of T and B can be constructed. Its axis {circumflex over (n)} is in the direction t\u00d7b and its half-angle, \u03b8, is given by:",{"@attributes":{"id":"p-0051","num":"0050"},"maths":{"@attributes":{"id":"MATH-US-00009","num":"00009"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mi":["sin","\u03b8"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mo":"=","mfrac":{"msqrt":{"mrow":{"mrow":[{"msup":{"mi":"sin","mn":"2"},"mo":"\u2062","msub":{"mi":["\u03b1","t"]}},{"mn":"2","mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mi":["sin","sin","cos","\u03b2"],"msub":[{"mi":["\u03b1","t"]},{"mi":["\u03b1","b"]}]},{"msup":{"mi":"sin","mn":"2"},"mo":"\u2062","msub":{"mi":["\u03b1","b"]}}],"mo":["+","+"]}},"mrow":{"mi":["sin","\u03b2"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}}},{"mrow":{"mo":["(",")"],"mn":"16"}}]}}}},"br":{},"figref":"FIG. 5"},"We use the {circumflex over (t)} and {circumflex over (b)} axes derived above as axes for the cones T and B and the cone angles are found for cones T and B from the parametric derivative patches' control points (, block ). The cosine of the cone angle \u00e1(\u00e1) is simply the minimum dot product of any normalized control point from the tangent patch with the {circumflex over (t)} ({circumflex over (b)}) axis. A normal cone is derived by computing the cross product of cones T and B (, block ). The bounds for the normalized normal expressed in the OBB coordinate frame are:\n\n([\u2212sin \u03b8, sin \u03b8],[\u2212sin \u03b8, sin \u03b8],[cos \u03b8,1])\u2003\u2003(17)\n\nwhere \u03b8 is the cone half angle of the normal cone N. Using the equality sin\u00e8+cos\u00e8=1, we can derive the bounds of the normalized normal using the normal cone angle without using any trigonometric functions (, block ). We denote this approach TPATCH.\n","Care must be taken to check that the two tangent cones do not overlap. The cones overlap if \u00e1+\u00e1>\u00e2, which given \u03b1<pi, \u03b1<pi, and, \u03b2<pi can be rewritten as:\n\ncos \u03b1cos \u03b1\u2212sin \u03b1sin \u03b1<cos \u03b2\u2003\u2003(18)\n\nIf this condition is true, or if cos \u00e1<0, cos \u00e1<0, we return the unit box in the OBB coordinate frame. A unit box has the following two extreme vertices: (\u22121,\u22121,\u22121) and (+1,+1,+1). However, this will rarely happen, except for highly curved patches, since the OBB coordinate frame is computed from an approximation of the local surface tangent, bi-normal, and normal of the base patch.\n","Techniques for bounding texture lookups involve keeping two extra mipmap hierarchies. The first stores the maximum displacement value over each texture footprint and level and the second stores the minimum displacement value of the footprint. In general, when the parametric interval decreases, so do the texture bounds.","The final bounds of the displacement vector, o={circumflex over (n)}t, is the product (on interval arithmetic form) of the interval from the texture lookup [t,t] times the intervals of the normalized normal vector along each axis. Using the notation [,\u0101] to define an interval, where,  is the lower limit and \u0101 is the upper limit, multiplication of two intervals is defined by:\n\n[][]=[min(),max()]\u2003\u2003(19)\n\nHence, the interval version of the x-component of o, is:\n\n[,][,]\u2003\u2003(20)\n\nand similarly for the other components. If the texture displacement is strictly positive, then equation 20 can be further optimized.\n","The last step in most domain shaders is the matrix transformation to clip space, so the remaining part in obtaining bounds for q is the model view projection matrix, which does not depend on the parametric domain, and can be seen as a constant. This constant matrix is easily multiplied with the eight corners of the OBB obtained from the displaced patch d, resulting in bounds for the clip space position q. (The last step may not be needed when using hierarchical bounds for pre-tessellation sorting and ray tracing).","Given an initial coarse subdivision of the patch, a priority queue of the bounding boxes of the subdomains may be maintained in some embodiments. (For example, each sub-patch could alternatively be divided into a number of smaller sub-patches until each sub-patch is \u201csmall enough,\u201d in terms of volume, surface area, or projected area, as examples). In each following subdivision step, we take the top element of the queue, subdivide it further, and insert the subdivided boxes back into the queue.","The exact sorting criterion is application dependent, and may contain the screen-space extents of the bounding box, the depth values, or prioritize boxes intersecting a frustum plane for view frustum culling.  illustrates a view-dependent subdivision criterion.","For view frustum culling, the OBB corners (in clip-space) are tested against the frustum planes. The subdivision criterion may be designed so that sub-patches straddling the camera frustum are prioritized, which efficiently culls geometry outside the clip planes. The clip test results of the patch can also be used to guarantee that the entire patch is completely inside the view frustum, so the clip tests for generated triangles from the patch can possibly be bypassed.","Given a coarse depth buffer, subpatches can be culled if their bounding box is entirely occluded by already drawn primitives. The subdivision criterion may be adopted so that sub-patches closer to the camera are processed first and sent to the rasterization stage of the pipeline, therefore increasing the likelihood of z-culling.","Backface culling is the hardest type of culling, due to the difficulty in efficiently bounding the geometric normal after displacement. However, given the tessellation rate, the normal bounds and a tight interval of the displacement, bounds for the displaced surface normal can be derived. Further, the subdivision criterion can be adapted to target patches with high normal variation, increasing the likelihood of backface-culling of subpatches.","After computing a bounded representation of the displaced B\u00e9zier patch, we can use the bounds for pre-tessellation sorting into tiles. Tile-overlap can be reduced by hierarchical subdivision of the largest screen-space bounding box.","In a ray tracing environment, the subdivision criterion is tuned to reduce the total surface area of each OBB, similar to how a surface area heuristic builds acceleration data structures. In collision detection, the subdivision criterion for reduced OBB volumes is tuned.","Hierarchical bounding volumes can be used for culling, as well as for sorting into tiles and ray tracing. Using the techniques described herein, electronic data may be transformed to a visual form for display on a display.","To efficiently support the DX-11 tessellation pipeline stages, in a tiling architecture, the bounds of the displaced surfaces are needed before tessellation and domain shading occurs. These bounds can be used to bin (i.e. sort primitives into tile-specific queues) the displaced B\u00e9zier patches without doing any tessellation. The tessellation and domain shading would then occur when and if needed. The use of hierarchical bounds may be useful for binning, view frustum culling, occlusion culling, and backface culling.","The graphics processing techniques described herein may be implemented in various hardware architectures. For example, graphics functionality may be integrated within a chipset. Alternatively, a discrete graphics processor may be used. As still another embodiment, the graphics functions may be implemented by a general purpose processor, including a multicore processor.","The computer system , shown in , may include a hard drive  and a removable medium , coupled by a bus  to a chipset core logic . A keyboard and mouse , or other conventional components, may be coupled to the chipset core logic via bus . The core logic may couple to the graphics processor , via a bus , and the main or host processor  in one embodiment. The graphics processor  may also be coupled by a bus  to a frame buffer . The frame buffer  may be coupled by a bus  to a display screen . In one embodiment, a graphics processor  may be a multi-threaded, multi-core parallel processor using single instruction multiple data (SIMD) architecture.","In the case of a software implementation, the pertinent code may be stored in any suitable semiconductor, magnetic, or optical memory, including the main memory  or any available memory within the graphics processor. Thus, in one embodiment, the code to perform the sequences of  may be stored in a machine or computer readable medium, such as the memory  or the graphics processor , and may be executed by the processor  or the graphics processor  in one embodiment.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIGS. 8-12","FIGS. 8-13"]},"References throughout this specification to \u201cone embodiment\u201d or \u201can embodiment\u201d mean that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one implementation encompassed within the present invention. Thus, appearances of the phrase \u201cone embodiment\u201d or \u201cin an embodiment\u201d are not necessarily referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be instituted in other suitable forms other than the particular embodiment illustrated and all such forms may be encompassed within the claims of the present application.","While the present invention has been described with respect to a limited number of embodiments, those skilled in the art will appreciate numerous modifications and variations therefrom. It is intended that the appended claims cover all such modifications and variations as fall within the true spirit and scope of this present invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
