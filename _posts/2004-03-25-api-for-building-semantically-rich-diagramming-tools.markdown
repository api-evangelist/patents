---
title: API for building semantically rich diagramming tools
abstract: The system employs a rich framework to support both document and diagram state. Because the same framework is used to manipulate the state in a consistent way, it becomes much easier to keep the diagram synchronized with the underlying data than with conventional system(s).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07624403&OS=07624403&RS=07624403
owner: Microsoft Corporation
number: 07624403
owner_city: Redmond
owner_country: US
publication_date: 20040325
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present invention relates generally to computer system(s), and more particularly, to system(s) and method(s) facilitating diagramming tools.","Diagramming tool(s) make it easier to create tools that allow people to display and edit information. Conventional diagramming tool(s) have suffered from three major flaws. First, conventional diagramming tool(s) have focused on just the problem of creating diagrams and generally ignored the fact that the diagrams are essentially views of semantically rich data. This makes the application program interface(s) (APIs) cumbersome to use in practice since software developers generally are required to write large amounts of code to keep the diagram and the underlying data synchronized.","Secondly, conventional diagramming tool(s) have had cumbersome APIs that have required software developers to write large amounts of code to support the high quality user interfaces expected in commercial diagramming tools. Finally, The APIs have not supported large complex drawings. Large and complex drawings either cause the software to fail or carry out operations unacceptably slowly.","The following presents a simplified summary of the invention in order to provide a basic understanding of some aspects of the invention. This summary is not an extensive overview of the invention. It is not intended to identify key\/critical elements of the invention or to delineate the scope of the invention. Its sole purpose is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.","The present invention provides for a system and method facilitating diagramming. In accordance with an aspect of the present invention, a diagram system is provided which manages presentation elements (diagrams and shapes) in the same context as the subject elements they depict. The diagram system includes an object model application program interface (API) with a control that facilitates access to the presentation elements, scoped on one diagram at a time. The control maintains state information associated with the diagram. For example, application(s) can employ the API to access and\/or modify the diagram.","The system employs a rich framework to support both document and diagram state. Because the same framework is used to manipulate the state in a consistent way, it becomes much easier to keep the diagram synchronized with the underlying data than with conventional system(s).","The system facilitates customizability through modern API design techniques, for example, class inheritance. Standard default ways to perform common behavior customizations (e.g., static appearance of a shape in the diagram) is provided. However, mechanism(s) to override this behavior, for example, through inheritance are provided. Additionally, the system facilitates control-less design that makes it easier to appropriately and efficiently respond to state changes in the underlying data and operating system.","To the accomplishment of the foregoing and related ends, certain illustrative aspects of the invention are described herein in connection with the following description and the annexed drawings. These aspects are indicative, however, of but a few of the various ways in which the principles of the invention may be employed and the present invention is intended to include all such aspects and their equivalents. Other advantages and novel features of the invention may become apparent from the following detailed description of the invention when considered in conjunction with the drawings.","The present invention is now described with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It may be evident, however, that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to facilitate describing the present invention.","As used in this application, the terms \u201ccomponent,\u201d \u201chandler,\u201d \u201cmodel,\u201d \u201csystem,\u201d and the like are intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component may be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a server and the server can be a component. One or more components may reside within a process and\/or thread of execution and a component may be localized on one computer and\/or distributed between two or more computers. Also, these components can execute from various computer readable media having various data structures stored thereon. The components may communicate via local and\/or remote processes such as in accordance with a signal having one or more data packets (e.g., data from one component interacting with another component in a local system, distributed system, and\/or across a network such as the Internet with other systems via the signal). Computer components can be stored, for example, on computer readable media including, but not limited to, an ASIC (application specific integrated circuit), CD (compact disc), DVD (digital video disk), ROM (read only memory), floppy disk, hard disk, EEPROM (electrically erasable programmable read only memory) and memory stick in accordance with the present invention.","Further \u201chittest\u201d refers to functionality that can test a shape that has been dropped by dragging. For example, the test can return information which indicates if the shape has been dropped outside the boundary of a target shape, on the boundary of a target shape, inside the filled-area of a two-dimensional shape and\/or on the line of a one-dimensional shape. Further, the target can be a single shape and\/or a collection of shapes.","\u201cObject role modeling\u201d (ORM) employs objects and roles to provide a conceptual approach to modeling. ORM can employ natural language and intuitive diagram(s) (e.g., ORM diagram(s)).","The present invention relates to systems and methods that facilitate application development by providing an Application Programming Interface (API) and framework that supports modeling diagram object manipulation and\/or interaction. A diagram object is provided that models, for example, application(s), class(es), relational database(s) and\/or object role modeling (ORM). Accordingly, developer(s) can easily describe attribute(s), relationship(s) and\/or constraint(s).","System ","Referring to , a diagram system  in accordance with an aspect of the present invention is illustrated. The system  includes an application program interface (API)  and a diagram . Application(s)  employ the API  to access and\/or modify the diagram .","The system  employs a rich framework to support both document and diagram state. Because the same framework is used to manipulate the state in a consistent way, it becomes much easier to keep the diagram synchronized with the underlying data than with conventional system(s).","The system  further facilitates customizability through modern API design techniques, for example, inheritance. Simple default ways to perform common behavior customizations (e.g., static appearance of a shape in the diagram) is provided. However, mechanism(s) to override this behavior, for example, through inheritance are provided. Additionally, the system  facilitates control-less design that makes it easier to appropriately and efficiently respond to state changes in the underlying data and operating system.","Conventional system(s) suffered from poor scalability which the system  can mitigate by using a control-less design and designing data structure(s) to scale well. Generally, operating system(s) do not scale well when there are large numbers of windows present. This makes the implementation easier but at the cost of scalability. The invention instead uses a single window for whole diagramming surface and provides fast scalable APIs that replace operating system functionality.","Core Design Surface","Turning briefly to , a diagram system  in accordance with an aspect of the present invention is illustrated. The system  includes a diagram  coupled to a DiagramClientView . DiagramClientView  is derived from Forms:Control .","The DiagramClientView  class is a control that allows an end-user to interact with a Diagram  object. The DiagramClientView  owns the state information such as the selection, zoom, and scroll position, and reroutes paint, keyboard, and mouse events to the Diagram  and the member shapes. DiagramClientView  can provide the control to draw upon and to capture events. The Diagram  and its shapes, on the other hand, are responsible for painting themselves and for responding to user interaction. This makes the implementation of DiagramClientView implementation very light weight and independent of any specific Diagram .","The design surface operates on model(s) managed by an In-Memory-Store (IMS). The IMS core meta-model is extended to include diagram(s) and diagram shape(s).  illustrates an overview of major classes of a diagram system  in accordance with an aspect of the present invention. The system  includes a diagram class , a NodeShape class , a BinaryLinkShape class , a ShapeElement class , a PresentationElement class  and a ModelElement class .","In this example, the design is based on an existing PresentationElement  base class in the IMS. The PresentationElement  is a display element for zero or more ModelElement  derived classes. With a PresentationElement (PEL)  based design surface, the PEL  and corresponding object on the design surface are one and the same; therefore there are no synchronization issues between PEL  and another object on the design surface. This means that the developer doesn't have to create and maintain classes which mirror the PEL  classes. Rather than having some attributes & operations of a shape living in a PEL  and some other attributes\/operations of the same shape living in another design surface object, the entire shape is embodied within a single class.","The ShapeElement class  is responsible for painting itself and responding to mouse action(s), hittest and\/or keystroke(s). A ShapeElement  can have child shapes as noted by the ParentShapeContainsChildShape class .","The NodeShape class  is characterized by a Bounds property which defines its location and size. An example of a NodeShape  is a rectangle or an ellipse shape.","The BinaryLinkShape class  is a line with two endpoints.","The Diagram class  is a container of shapes which is associated with zero or more DiagramClientView control(s)  as discussed previously. The diagram class also inherits from NodeShape.","Custom Diagram(s)","Custom diagram types are implemented by deriving from the Diagram class . Shapes specific to a custom diagram derive from the NodeShape  or BinaryLinkShape classes .  illustrates classes  of an exemplary database diagram in accordance with an aspect of the present invention. The classes  include a DatabaseDiagram class  derived from a diagram class , a ViewShape class  and a TableShape class . The diagram class , the ViewShape class  and the TableShape class  derive from a NodeShape class . Further, a ForeignKeyRelationshipLinkShape class  derives from a BinaryLinkShape class .","ShapeElement Class ","The abstract ShapeElement class  is derived from PresentationElement  and represents the basic foundational class on the design surface.","The ShapeElement class  mimics the Control class  in the sense that it responds to mouse, keyboard, and\/or paint event(s). These events are rerouted from the DiagramClientView . The DiagramClientView  creates new event argument(s) which carry more information than the standard event argument(s) as discussed below.","Referring briefly to , an exemplary ShapeElement class  in accordance with an aspect of the present invention is illustrated.","The ShapeElement class  can include a Geometry property which defines the outline of the shape. The Geometry property can be used to paint the shape, perform shape hittesting, and perform \u201clink folding\u201d (which will be discussed later). To change the Geometry, this property can be overridden to return a different Geometry-derived object.","The ShapeElement class  can include StyleSet property which is the object by which operating system drawing resources are retrieved and managed. More details regarding the StyleSet property is the Managing Shape Appearance section below.","The ShapeElement class  can further include a ShapeFields property which returns a list of ShapeFields. A ShapeField is to a ShapeElement as a Control is to a dialog. For example, if a user wanted to display text or an image on a shape, the user can display the text or image using a ShapeField. More details regarding ShapeField are discussed below.","To add a child ShapeElement to a ShapeElement, the AddChild( ) method is called. An IMS parent-child relationship is created between the two shapes.","To create a custom shape, the shape developer does not derive directly from ShapeElement . Instead, the developer will derive from the NodeShape  or BinaryLinkShape class  and override the appropriate method(s).","The ShapeElement  can have more method(s) as discussed below.","NodeShape Class ","Turning to , an exemplary NodeShape class  in accordance with an aspect of the present invention is illustrated. The NodeShape class  is characterized by a location and size which collectively define the bounds of the shape. This defines the bounding area in which the shape can draw and hittest. Although the bounds are rectangular, the shape does not have to be.","In this example, the NodeShape class has an AbsoluteBounds property which is implemented as an IMS property. The absolute bounds is relative to the top left corner of the diagram . The NodeShape class can also have a Bounds property which is relative to the top left corner of the parent shape. The Bounds property is calculated based on contained elements or other criteria that the implementation deems appropriate.","Referring briefly to , an exemplary BoundsRules class  in accordance with an aspect of the present invention is illustrated. A child shape class can have rules as to where it can be located and how large or small it can be sized. When the AbsoluteBounds property setter is called, the bounds are adjusted to comply with these rules. These rules can be defined in a BoundsRules-derived class, and the ShapeElement  class can have a BoundsRules property whose getter returns a valid BoundsRules object. The BoundsRules class has one method GetCompliantBounds whose responsibility it is to return a rectangle which complies with whatever bounds rules are in effect.","For example, by default, the BoundsRules property getter can return a reference to a BasicRules object which is a Singleton pattern capable of performing snap-to-grid and anchoring. A Singleton pattern is a creational pattern to dictate how and when objects get created\u2014employed, for example, to ensure a class has only one instance, and provide a global point of access to it.","Diagram Class ","Next, turning to , an exemplary diagram  in accordance with an aspect of the present invention is illustrated. The Diagram class  is derived from the NodeShape class  primarily because it shares much of the same behavior. A Diagram  is different from a NodeShape  in primarily the following ways:","(1) The Diagram  contains the link to associated DiagramClientView  objects. A DiagramClientView  object is the actual control, which is intended to be a generic displayer of a Diagram  object and a receiver (and rerouter) of events. To associate the diagram  with a design surface, the Associate( ) method is called.","BinaryLinkShape Class ","BinaryLinkShape class  represents the connection between two NodeShapes . BinaryLinkShape  derives from the ShapeElement  class and is responsible for the visual representation of a connector in the diagram . A connector refers to a physical and\/or logical connection between two or more shapes.","Control-Less Shapes","This design does not use control as the base class for each shape as other conventional design surfaces have done in the past. Instead, the design surface of the present invention is a single control with control-less based shapes.","The control-less based design can lead to, for example:","(1) Lower usage of operating system drawing resources. Although a control-based shape can be faster to implement, it consumes one control per shape. A single diagram with 10,000 shapes would use 10,000 controls. Additionally, the number of shapes on the diagram is not restricted by a operating system drawing resource limit.","(2) Smaller memory footprint.","(3) Faster. With a control-based design, there is limited ability to optimize. For example, when zoomed out to show the entire diagram of 10,000 shapes, painting can be sluggish at best using a control-based design. With the system  (e.g., a control-less design), special purpose algorithms can, optionally, be employed to address performance issues on shape painting, hittesting, and\/or updating.","(4) Greater control. Default shape behavior can be customized elegantly. Further deep optimizations can be achieved.","(5) Hittesting capability using conventional diagram system(s). In accordance with an aspect of the present invention, the system  can further include at least a portion of a convention, control-based design which can facilitate hit-testing capability.","(6) Tight coupling with the core meta-model reduces synchronization issues. By not separating the subject elements (data) from the presentation elements (diagrams and shapes) , , , this synchronization issue is eliminated","Graph Object","In one example, the diagram class  employs a conventional diagram system graphic object to manage its graphic space. In this example, a diagram instance has exactly one graph object. The diagram's children can be mapped to graph layout objects, maintained by the graph object. This approach allows the diagram to delegate hittest queries, auto-layout (e.g., placement of shapes), and auto-routing (e.g., stream of coordinates that make up a path of a connector, for example BinaryLinkShape ) to its graph object. Shapes contained in the diagram are mapped to a graph layout object; this allows the graph object to \u201csee\u201d the shapes on the diagram.","The Graph Object can further enable:","(1) auto-routing of connections","(2) auto-layout of shapes","(3) hit-testing through spatial queries","(4) keyboard navigation through spatial queries","(5) lasso-selection through spatial queries","Each diagram element has a corresponding conventional graph object within its diagram's Graph object. The conventional graph objects maintain the spatial properties for a diagram element. The Graph Wrapper contains a series of maps that provide mappings between both sides of the interface, so that a ShapeElement can be queried for its GraphLayoutObject or query the GraphLayoutObject for its ShapeElement.","In one example, each Diagram contains a GraphWrapper Object which is responsible for maintaining consistency between the conventional graph object and the Diagram Shapes. In another example, the conventional graph object functionality integrates directly into the core meta-model so that it ultimately operates on Diagram Shapes, eliminating the duplication maintained by the conventional graph object.","In order to operate more effectively with the graph object and the objects that it supports, in one example, the following objects can be wrapped:","(1) Conventional graph.Graph is wrapped by GraphWrapper","(2) Conventional graph.LayoutObject is wrapped by GraphLayoutObject","(3) Conventional graph.Node is wrapped by GraphNode","(4) Conventional graph.Edge is wrapped by GraphEdge","This wrapper layer achieves several purposes:","(1) Complex operations that employ the graph objects highly granular interface can be hidden in a more useable API.","(2) Mappings between Shapes and GraphLayoutObjects can be maintained and hide the relationships between them in the wrapper classes.","(3) Lifetime issues are much better dealt with in this manner.",{"@attributes":{"id":"p-0135","num":"0133"},"figref":["FIG. 9","FIG. 9"],"b":"900"},"Referring briefly to , a sequence diagram  of an exemplary process facilitating auto-layout and auto-routing in accordance with an aspect of the present invention is illustrated. For auto-layout and auto-routing, the graph object can modify the bounds of the shapes during a pre-commit phase without the IMS's knowledge. Before the pre-commit phase is done, the changed objects are retrieved from the graph object, and changed events can be artificially generated.","Responding to Object Model Changes: In-Memory Store (IMS) Rules","In one example, a model contains a SourceFile model element which can contain Component model elements through a SourceFile-contains-Component relationship. In this example, there exists a corresponding Diagram which can contain Component shapes. Finally, for every Component model element, a corresponding Component shape must exist on the diagram.","In this example, if a Component model element is added to the model, it is desired to reflect this change in the diagram by automatically generate the corresponding Component shape. If this were handled as an IMS Add event handler, a second undo record would be created for creating the Component shape, which is undesirable.","To move the creation of the Component shape into the same transaction as the creation of the Component model element, the shape developer can create an IMS rule instead. An IMS rule is similar to event handling except that it is executed within a transaction rather than after the transaction. In this particular example, the shape developer needs to listen to the creation of the SourceFile-contains-Component relationship.","To create an IMS rule, the shape developer derives from the appropriate IMS base rule (AddRule, RemoveRule, or ChangeRule) and overrides the method (ElementAdded, ElementRemoved, ElementAttributeChanged) as illustrated in . In the example above, the ElementAdded method can respond by creating the Component shape.","To activate the rule for a particular class, add the RuleOn attribute above the rule-derived class, for example, employing C# syntax:",{"@attributes":{"id":"p-0143","num":"0141"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[RuleOn(typeof(SourceFileContainsComponent))]"]},{"entry":[{},"public sealed class ComponentAddRule : AddRule"]},{"entry":[{},"{"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Layered Painting","In one example, the DiagramClientView.OnPaint method draws the design surface in layers in the following sequence:","(1) Paint shapes","(2) Paint selection outlines and grab handles","(3) Paint mouse action feedback (such as rubberband or resize feedback)","(4) Paint Ole drag\/drop feedback","This layering permits performance optimizations. More details are provided in the Managing Shape Appearance section below.","Painting Performance Optimization","For example, painting can be optimized by the following techniques:","(1) Draw only the shapes within the invalid rectangle. By using the rectangle hittesting functionality of the graph object to find the shapes, this simple optimization will iterate only those shapes rather than starting with the root shape (the Diagram) and recursively calling DoPaint on its child shapes.","(2) Use a shadow bitmap. This will enable faster redraw as the shapes don't have to be individually redrawn using their own DoPaint methods. Instead, it's a snapshot of the drawing surface without the selection drawing and mouse feedback.","(3) Greeking.","(4) Painting by bands. This addresses the case where the user grabs the scroll thumb and moves through the diagram quickly. It allows for the canceling of partial painting if another scroll event has been detected.","ShapeFields and Properties","A single shape can include displayable item(s), for example, a name, an image and the like. Unlike subshapes, these items are typically not selectable nor do they correspond to any Element. Rather, these items generally correspond to properties of the shape or properties of the corresponding element and can optionally be editable. When one of these items is clicked on, it can potentially receive focus, but it is desirable that the shape itself remain selected and not the item.","Referring briefly to , a WebService shape  includes an object name, an image, a list of data lines, and indicator \u201clights.\u201d The sub shapes that are along the perimeter and outside of the component shape can be disregarded for purposes of discussion.","By clicking on the object name, it is expected the WebService shape itself to be selected. If the object name is editable, it is expected that a blinking caret will appear with the object name highlighted. By pressing the tab key, it is expected that the focus will be moved to the next item within the shape, namely the data lines. All the while, the WebService shape  remains selected and the content of the property browser remains unchanged.","These items can be implemented as shape. In this example, to be useful, the shape field includes at least some of the following characteristics:","(1) Ability to paint itself.","(2) Ability to provide hittest information (e.g., the field may be a circle, so clicking in its bounding rectangle may not necessarily mean it was hit.)","(3) Reuse of PropertyDescriptors (e.g., created for the Property Browser).\n\n","(4) Lightweight in terms of memory and resource usage.","The shape fields can be able to support the following properties:\n\n","To keep the shapes lightweight, ShapeFields describe these properties rather than store instance information. For example, the \u201cvalue\u201d property can be described using an IMS property and the \u201cbounds\u201d property can be described by anchoring styles. By doing so, ShapeFields can be static members of a Shape-derived class.","Referring briefly to , an exemplary abstract ShapeField class  in accordance with an aspect of the present invention is illustrated.","In this example, the Get methods (GetVisible, GetFontID, etc.) are virtual methods which return the default value (DefaultVisibility, DefaultFontID, etc.). The default values are settable. Because shape fields are intended to be static, these default values affect the shape class, not the particular shape instance.","To customize the behavior of the shape field, the shape developer can derive a new class from ShapeField or any other ShapeField-derived class. Then the Get methods can be overridden to create customized behavior.","In this example, the \u201cAssociated IMS Property\u201d functionality is part of the base ShapeField class because it eliminates the need for a dual class hierarchy, one with a base class that has an associated IMS Property and one with a base class that is not.","Associated IMS Property","In one example, it is expected common practice is to display IMS properties on the shapes, such as \u201cName.\u201d An IMS property is a MetaAttribute of a ModelElement. A MetaAttribute is the description of property on the ModelElement.","The ShapeField is capable of rendering an IMS property based on its domain type. It is also able to respond to property changed events and update appropriately. Because not all ShapeFields need this functionality, it can be placed in its own class and instantiated only as needed. To instantiate this class, the shape field's AssociateValueWith( ) method is called which takes a MetaAttribute guid. This will instantiate the class, subscribe to the property changed events and invalidate the proper shape(s) upon receiving the PropertyChanged events.","Referring back to , the WebServiceShape  needed to draw the name in the shape. To do so, the InitializeShapeFields( ) method of the WebServiceShape  instantiates a TextField, sets any default(s), and associates the value with the appropriate IMS property. Again, these shape fields are static; the shape fields only exist on a per class basis. For example:",{"@attributes":{"id":"p-0176","num":"0186"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"static TextField nameField = null;"]},{"entry":[{},"protected override void InitializeShapeFields( ShapeFieldCollection"]},{"entry":[{},"shapeFields )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003TextField nameField = new TextField( );"]},{"entry":[{},"\u2003\u2003nameField.DefaultFontID = DesignSurfaceFonts.ShapeTitleText;"]},{"entry":[{},"\u2003\u2003nameField.AssociateValueWith( Store,"]},{"entry":[{},"WebServiceShape.NameMetaAttributeGuid );"]},{"entry":[{},"\u2003\u2003shapeFields.Add( nameField );"]},{"entry":[{},"\u2003\u2003\/\/ continue adding other shape fields..."]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Proxy Property","Typically, the property that the shape needs to display is not found on the shape itself, but rather on another MEL  elsewhere. For example, the WebServiceShape  can maintain the Name property on a WebService element rather than on the WebServiceShape  as the previous example showed. In one example, to support such a scenario, the IMS support for a proxy property is taken advantage of. The proxy property will point to the real property by adding the attributes as shown. For example,",{"@attributes":{"id":"p-0179","num":"0189"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"[MetaAttribute("},{"entry":"XPathExpression=\u201c\/WebServiceShape\/ElementHasDisplay.Subjects\/"},{"entry":"Subjects\u201d,"},{"entry":"RealAttributeName=\u201cName\u201d,"},{"entry":"ReverseXPathExpression=\u201c\/WebService\/"},{"entry":"ElementHasDisplay.Presentations\/Presentations\u201d,"},{"entry":"ProxyAttributeName=\u201cName\u201d)]"},{"entry":"[StringDomain( )]"},{"entry":"[MetaObject(\u201cDD74DBDE-C032-4773-8854-7838AB947906\u201d, \u201cName\u201d)]"},{"entry":"public String Name"},{"entry":"{"},{"entry":"get"},{"entry":"{"},{"entry":"return"},{"entry":"(string)GetAttributeValue(WebServiceShape.NameMetaAttributeGuid);"},{"entry":"}"},{"entry":"set"},{"entry":"{"},{"entry":"SetAttributeValue(WebServiceShape.NameMetaAttributeGuid, value);"},{"entry":"}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In this example, the WebServiceShape  has a Name proxy property which points to the real Name property on the WebService. The WebService can be found by traversing from the WebServiceShape, across the ElementHasDisplay relationship, and to the instance that plays the Subjects role using the XPathExpression. Once the instance is found, the RealAttributeName is used to identify the property from which to get the value.","The XPathExpression provides the forward traversal path from the shape containing the proxy property to the element containing the real property. A description of the path is necessary because the shape field is static and only describes behavior. If a shape field instance existed for every shape instance, the path would not need to be described.","When the real property changes, the shape needs to be notified. To do so, the real property's changed event could be individually subscribed for every shape instance. But that has the downside of consuming memory for each shape and defeats the flyweight design pattern of the shape field. An alternative is to subscribe once per shape type. The lone event handler then runs a reverse traversal from the element containing the real property to the shape(s) containing the proxy property. This is specified by the ReverseXPathExpression. Since XPath expressions don't provide a means of reversing a path, the reverse XPath expression must be explicitly provided.","The forward XPathExpression and the ReverseXPathExpression both have the syntax of:\n\n\u201c\/\u201d meta_class_name {\u201c\/\u201d meta_relationship_name \u201c.\u201d meta_role_name \u201c\/\u201d meta_role_name}\n","where:","the meta_class_name is either:\n\n","In both cases, a derived class name cannot be supplied; it must be the class that actually contains the proxy or real property that supplies it.","The meta_relationship_name is the name of the relationship class to be traversed. A typical meta relationship class is ElementHasDisplay, which has the role SubjectHasPresentations. This is the relationship that associates a MEL  with a PEL . Another typical meta relationship class is Containment. This is the relationship that associates a parent shape with a child shape.","The meta_role_name is the name given to one of the roles in the relationship. Subjects in the meta-relationship class ElementHasDisplay is an example of a meta_role_name.","In one example, to associate a proxy property with a ShapeField, the following ShapeField method is called:","public void AssociateValueWith(Store store, Guid proxyMetaAttributeGuid, Guid realMetaAttributeGuid)","Bounds Behavior","To specify how shape fields are to be laid out within a shape, the bounds behavior of each shape field is set. Bounds behavior is used to describe the positions and sizes of a shape's shape fields, regardless of the shape's actual size. This allows a developer to specify the layout of a shape's shape fields without knowledge of the exact size of the shape. It also makes resizing the shape a non-issue.","As an example, when a shape is sized smaller than the combined minimum widths of its shape fields, the shape fields are laid out from top to bottom, left to right using the minimum heights and minimum widths provided, and clipped to the bounds of the shape.","Referring to , a first view of a shape  is illustrated. In this example, the shape's field layout can be described via the bounds behavior's of the shape fields. For example: (1) center the title shape field vertically, (2) make it one line tall, and (3) make it stretch as the shape's width is changed. On the line above the title, display the type and an icon shape fields, anchor the icon to the left side of the shape, and stretch the type between the right side of the shape and the icon. A second view of the shape  and a third view of the shape  are further illustrated.","Exemplary code is:",{"@attributes":{"id":"p-0196","num":"0208"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public class MyShape : Shape"},{"entry":"{"},{"entry":":"},{"entry":"protected override void InitializeShapeFields( ShapeFieldCollection shapeFields )"},{"entry":"{"},{"entry":"const private float fiftyPercent = 0.50F;"},{"entry":"const private float horizontalMargin = 0.125F; \/\/\u215binch"},{"entry":"const private float verticallMargin = 0.125; \/\/ \u215binch"},{"entry":"const private float iconSize = 0.25.0F; \/\/ quarter inch"},{"entry":"const private float oneInch = 1.0F; \/\/ one inch"},{"entry":"\u2003\u2003\/\/ Set the height of the title field to one line tall. Anchor it to stretch between the"},{"entry":"left and"},{"entry":"\u2003\u2003\/\/ right edges of the shape, leaving an 8 unit margin. Finally, center the field"},{"entry":"between the"},{"entry":"\u2003\u2003\/\/ top and bottom edges of the shape."},{"entry":"\u2003\u2003ShapeField titleField = new TextField( );"},{"entry":"\u2003\u2003titleField.BoundsBehavior.MinimumHeightInLines =1.0F;"},{"entry":"\u2003\u2003titleField.BoundsBehavior.MinimumWidth = oneInch;"},{"entry":"\u2003\u2003titleField.BoundsBehavior.AnchorLeftTo(Edge.Left, horizontalMargin);"},{"entry":"\u2003\u2003titleField.BoundsBehavior.AnchorRightTo(Edge.Right, horizontalMargin);"},{"entry":"\u2003\u2003titleField.BoundsBehavior.CenterVertically(fiftyPercent);"},{"entry":"\u2003\u2003titleFieldKey = shapeFields.Add( titleField );"},{"entry":"\u2003\u2003\/\/ Set the size of the icon field to be 16\u00d716, and Anchor it to the right side of the"},{"entry":"shape,"},{"entry":"\u2003\u2003\/\/ leaving an 8 unit margin."},{"entry":"\u2003\u2003ShapeField iconField = new ImageField( );"},{"entry":"\u2003\u2003iconField.BoundsBehavior.MinimumWidth = iconSize;"},{"entry":"\u2003\u2003iconField.BoundsBehavior.MinimumHeight = iconSize;"},{"entry":"\u2003\u2003iconField.BoundsBehavior.AnchorRightTo(Edge.Right, horizontalMargin);"},{"entry":"\u2003\u2003iconFieldKey = shapeFields.Add( iconField );"},{"entry":"\u2003\u2003\/\/ Set the size of the type field to be one line tall. Anchor it to stretch between the"},{"entry":"left edge"},{"entry":"\u2003\u2003\/\/ of the shape, and the left edge of the icon field, leaving an 8 unit margin on each"},{"entry":"side."},{"entry":"\u2003\u2003\/\/ Also, anchor the shape vertically to the title field, leaving a 4 unit vertical"},{"entry":"margin."},{"entry":"\u2003\u2003ShapeField typeField = new TextField( );"},{"entry":"\u2003\u2003typeField.BoundsBehavior.MinimumHeightInLines = 1.0F;"},{"entry":"\u2003\u2003typeField.BoundsBehavior.MinimumWidth = oneInch;"},{"entry":"\u2003\u2003typeField.BoundsBehavior.AnchorLeftTo(Edge.Right, horizontalMargin);"},{"entry":"\u2003\u2003typeField.BoundsBehavior.AnchorRightTo(Edge.Left, iconField,"},{"entry":"horizontalMargin);"},{"entry":"\u2003\u2003typeField.BoundsBehavior.AnchorBottomTo(Edge.Top, titleField,"},{"entry":"verticallMargin);"},{"entry":"\u2003\u2003typeFieldKey = shapeFields.Add( typeField );"},{"entry":"\u2003\u2003\/\/ Set the size of the value field to be one line tall. Anchor it to stretch between the"},{"entry":"left and"},{"entry":"\u2003\u2003\/\/ right edges of the shape, leaving an 8 unit margin on each side."},{"entry":"\u2003\u2003\/\/ Also, anchor the shape vertically to the title field, leaving a 4 unit vertical"},{"entry":"margin."},{"entry":"\u2003\u2003ShapeField valueField = new TextField( );"},{"entry":"\u2003\u2003valueField.BoundsBehavior.MinimumHeightInLines = 1.0F;"},{"entry":"\u2003\u2003valueField.BoundsBehavior.MinimumWidth = oneInch;"},{"entry":"\u2003\u2003valueField.BoundsBehavior.AnchorLeftTo(Edge.Right, horizontalMargin);"},{"entry":"\u2003\u2003valueField.BoundsBehavior.AnchorRightTo(Edge.Right, horizontalMargin);"},{"entry":"\u2003\u2003valueField.BoundsBehavior.AnchorTopTo(Edge.Bottom, titleField,"},{"entry":"verticallMargin);"},{"entry":"\u2003\u2003valueFieldKey = shapeFields.Add( valueField );"},{"entry":"\u2003\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Bounds Behavior Implementation","In one example, the shape field has exactly one private instance of bounds behavior. The bounds behavior class defines its anchors and springs with internal visibility so that ShapeField's GetBounds(Shape parent) (not pictured) can access them to calculate the shape field's size and position. Referring to , an exemplary BoundsBehavior class  in accordance with an aspect of the present invention is illustrated.","The BoundsBehavior class  includes four methods: SetLeftAnchor, SetTopAnchor, SetRightAnchor, and SetBottomAnchor. Alternatively, one method SetAnchor, which takes as its first parameter an AnchorSide enum (Left, Top, . . . ) can be employed.","Next, referring to , an exemplary AnchorText class  in accordance with an aspect of the present invention is illustrated. Anchor targets specify WHAT to anchor to, and WHERE to anchor to it. An anchor target can be shape field's parent shape (AnchorTargetParentEdge), a sibling shape field (AnchorTargetShapeField), or a sibling shape (AnchorTargetShape.) For any anchor target, the side to anchor to is specified, and the margin specifies how far from that edge to anchor. Specifying an anchor target percentage allows targeting of the center (50%) of a shape as the anchor point. A suspension object is used to implement CenterVertically and CenterHorizontally. A suspension takes two anchor targets, and a percentage which indicates how to center it (50%, the default, would center the shape field, 33% would position the shape \u2153 of the way between the two anchors.","In Place Editing","FieldTextEditor","In one example, FieldTextEditor is an internal control, generally one instance per DiagramClientView , to edit the various text fields throughout the diagram . It can either be shown\/hidden or created\/destroyed each time editing begins and ends. The control is derived from the RichTextBox so that the text font appears the same while editing as it does while displaying.","void TextField.BeginEdit( )","void TextField.BeginEdit(PointD cursorPosition)","Begin editing: (invoked, for example, by F, double-clicking, \u201crename\u201d command):","(1) The view auto-scrolls:","Top-left of field is scrolled into view if it is not already. The control is positioned at the top-left of the field.","Overlapping Shapes:","To avoid the case where focused text is partially or entirely covered by another shape, the following z-order (e.g., drawing order) change can be performed:","If a shape (or a field or subfield within that shape) is selected or has focus, the shape is temporarily brought to the top of the z-order. When the user deselects the shape or the focus moves to another shape, the shape returns to its original z-order.","If more than one shape is selected, only the primary shape in the selection is temporarily brought to the top of the z-order.","PropertyDescriptor driven","In-place editing can be supported on text fields that are bound to IMS properties.","In-place editing uses the ElementPropertyDescriptor of the ModelElement for:","GetValue: Getting the value to display\/edit.","SetValue: Setting the value.","IsReadOnly: Determines whether the field is editable or not.","GetEditor: Retrieving the UITypeEditor when the builder button and drop down button are supported.","Miscellaneous: Text for a tooltip (e.g., Name, DisplayName, Description).","The shape developer can alter the default editability of the text field by performing the following:","Override ModelElement.CreatePropertyDescriptor to return a custom property descriptor with the IsReadOnly property overridden.","Add the System.ComponentModel.ReadOnly attribute to the property.","Programmability:","To alter the default editability of the text field:","Override ModelElement.CreatePropertyDescriptor to return an ElementPropertyDescriptor-derived class with the IsReadOnly property overridden.","Add the System.ComponentModel.ReadOnly attribute to the property.","By default, the text field will be read\/write if:","(1) its associated IMS property has a property setter,","(2) its associated IMS property has the Browsable attribute set to true, and","(3) its associated IMS property does not have a ReadOnly attribute, or if it has one, it is set to false.","ElementPropertyDescriptor.GetValue can be called to get the value.","ElementPropertyDescriptor.SetValue can be called to commit the value.","Nested Shape","Nested shapes allow designers to show containment relationships of ShapeElements  in the Core Design Surface. To model some relationships, like nested classes and compound component types, ShapeElements  have the ability to fully contain other shape(s) and hide\/show them as the user selects. In order, to support this functionality\u2014the ability to affect the parent's size and plowing\u2014it has to be fully integrated with other auto-sizing and placement features in the design surface.","\u201cNest shape\u201d refers to a ShapeElement  fully contained within another ShapeElement . \u201cDesigner(s)\u201d refer to application(s) derived from the core design surface that implement their own unique meta-model and functionality. Further, \u201cplowing\u201d refers to moving other shape(s) out of the way so they don't overlap.","Public Interfaces and Programmability","Nested shapes provide auto fixup code that is run when a ShapeElement's  Bounds is updated. For example:","1. Pel fix-ups from drag-drop\/copy\/paste","2. Shape plowing","3. OnBoundsFixup","4. Auto-sizing of parent","5. OnBoundsFixup","6. Shape anchoring","7. Routing lines","For nested shapes, most of the functionality is automatically done by the design surface, so there are only a few points of integration with for designers.","Adding NestedShape to Parent","Adding a nested shape to its parent is a matter of adding it to the appropriate collection.",{"@attributes":{"id":"p-0249","num":"0261"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ first, create new child shape."]},{"entry":[{},"MyShape myChildShape ="]},{"entry":[{},"Store.ElementFactory.CreateElement(typeof(MyShape));"]},{"entry":[{},"\/\/ for simplicity, let's start with the diagram."]},{"entry":[{},"NodeShape myParentShape = Diagram;"]},{"entry":[{},"myParentShape.NestedChildShapes.Add(myChildShape);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Making ShapeField Size-to-Content","The AnchorTargetSizeToContent works similarly to the other AnchorTargets. It is set on the right or bottom of a ShapeField, depending on which direction it is desired for the content to flow.",{"@attributes":{"id":"p-0252","num":"0264"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class MyShape : NodeShape"]},{"entry":[{},"{"]},{"entry":[{},"\u2003public override void InitializeShapeFields"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\/\/ Create NameField"]},{"entry":[{},"\u2003\u2003TextField nameField = new TextField( );"]},{"entry":[{},"\u2003\u2003if(layout.TitleFieldAssociation!=null)"]},{"entry":[{},"\u2003\u2003nameField.AssociateValueWith(Store,"]},{"entry":[{},"MyShape.NameMetaAttributeGuid,"]},{"entry":[{},"NamedElement.NameMetaAttributeGuid);"]},{"entry":[{},"\u2003\u2003\/\/ setup the NameField presentation information."]},{"entry":[{},"\u2003\u2003nameField.DrawBorder = false;"]},{"entry":[{},"\u2003\u2003nameField.DefaultPenID ="]},{"entry":[{},"DiagramPens.ShapeTitleOutline;"]},{"entry":[{},"\u2003\u2003nameField.FillBackground = false;"]},{"entry":[{},"\u2003\u2003nameField.DefaultBackgroundBrushID ="]},{"entry":[{},"DiagramBrushes.ShapeTitleBackground;"]},{"entry":[{},"\u2003\u2003nameField.DefaultFontID ="]},{"entry":[{},"DiagramFonts.ShapeTitle;"]},{"entry":[{},"\u2003\u2003StringFormat nameFieldStringFormat = new"]},{"entry":[{},"StringFormat( StringFormatFlags.NoClip );"]},{"entry":[{},"\u2003\u2003nameFieldStringFormat.Alignment ="]},{"entry":[{},"layout.TitleTextAlignment;"]},{"entry":[{},"\u2003\u2003nameFieldStringFormat.LineAlignment ="]},{"entry":[{},"StringAlignment.Near;"]},{"entry":[{},"\u2003\u2003nameFieldStringFormat.Trimming ="]},{"entry":[{},"StringTrimming.EllipsisCharacter;"]},{"entry":[{},"\u2003\u2003nameField.DefaultStringFormat ="]},{"entry":[{},"nameFieldStringFormat;"]},{"entry":[{},"\u2003\u2003\/\/ set the ShapeField anchoring."]},{"entry":[{},"\u2002nameField.AnchoringBehavior.SetTopAnchor(AnchoringBehavior."]},{"entry":[{},"Edge.Top);"]},{"entry":[{},"\u2002nameField.AnchoringBehavior.SetLeftAnchor(AnchoringBehavior."]},{"entry":[{},"Edge.Left);"]},{"entry":[{},"\u2002nameField.AnchoringBehavior.SetRightAnchor(AnchoringBehavior."]},{"entry":[{},"Edge.Right);"]},{"entry":[{},"\u2003\u2003\/\/ set the size to content anchor."]},{"entry":[{},"\u2002nameField.AnchoringBehavior.SetBottomAnchor(0.25);"]},{"entry":[{},"\u2003\u2003nameField.AnchoringBehavior.MinimumHeightInLines"]},{"entry":[{},"= 1;"]},{"entry":[{},"\u2003\u2003\/\/ add the NameField to the shapeFields"]},{"entry":[{},"collection for this ShapeElement."]},{"entry":[{},"\u2003\u2003nameFieldKey = shapeFields.Add(nameField);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Make ShapeElement Plowable","In order to make a ShapeElement plow other shape(s), the WillPlow property is overridden:",{"@attributes":{"id":"p-0255","num":"0267"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class MyShape : NodeShape"]},{"entry":[{},"{"]},{"entry":[{},"\u2003public override bool WillPlow"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003get"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003return (this.NestedChildShapes.Count > 0);"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Responding to OnBoundsFixup","The OnBoundsFixup method can be overridden to customize position and\/or size based on the BoundsRules set up for the particular NodeShape:",{"@attributes":{"id":"p-0258","num":"0270"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class MyShape : NodeShape"]},{"entry":[{},"{"]},{"entry":[{},"\u2003public override OnBoundsFixup(CustomModelEventArgs"]},{"entry":[{},"e)"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\/\/ apply the snap-to-grid bounds rule."]},{"entry":[{},"\u2003\u2003RectangleD newBounds ="]},{"entry":[{},"this.BoundsRules.GetCompliantBounds(this.Bounds);"]},{"entry":[{},"\u2003\u2003if (newBounds != this.Bounds)"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003this.Bounds = newBounds;"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Nested Children Detailed Design","Referring next to , an exemplary ParentShapeHasRelativeChildShapes class  in accordance with an aspect of the present invention is illustrated.","Nested shapes are ShapeElements  with a particular relationship with other ShapeElements  that restrict them to be fully contained within their parent. Nested children contained within a parent ShapeElement  can be represented by the ParentShapeContainsNestedChildShapes relationship. This relationship contains ParentShape and NestedChildShape role players. For example, they can be accessed on a ShapeElement through the ParentShape and NestedChildShapes properties.","Adding to NestedChildShapes","In one example, in order to add or remove ShapeElements  from the NestedChildShapes collection, the ShapeElement class  does not expose additional methods. Since NestedChildShapes is a ShapeElementMoveableCollection, child shapes in this relationship can be added by calling the Add method on the collection (e.g., same thing for Remove). If the ShapeElement  is already parented to a different shape (e.g., it already has a ParentShape role player), then the original relationship is broken first, and the new relationship is established. A re-parented ShapeElement  can disconnect any BinaryLinkShapes  connected to it as part of this operation as well. In this example, it is up to the designer to re-establish appropriate connections as they are required.","parent.NestedChildShapes.Add(myShape);","Child shape(s) of the ShapeElement that is added are moved along with it to the new ParentShape.","Auto-size and Positioning","Nested shapes support several auto-size and positioning features. These features are fully integrated with other positioning code (e.g., PEL fixup code and bounds rules) that can also change the position or size of a shape. The following are additional exemplary auto-size\/positioning features for nested shapes and a description of how these integrate together to figure out the final position and size of a ShapeElement .","Order of Auto-Size\/Positioniong Rules","In this example, the overall order in which the auto-size and positioning occurs is important and can be integrated with other features that create or delete PresentationElements  from the design surface. The following is an exemplary list of the priority order in which rules will be processed. These design surface related priorities can be in the ViewFixupConstants class.\n\n","AutoFixup Custom Rules","Turning to , an exemplary CustomModelRule class  in accordance with an aspect of the present invention is illustrated. Further,  illustrates an exemplary AutoFixupContext class  in accordance with an aspect of the present invention.","During the BoundsChanged rule handling for NodeShapes , the shapes that have changed either their position or size are added to the appropriate collection which is cached in the Transaction's Context property. If it is the first item added to that particular collection, then one of the rules is fired. For example, if a shape's size is changed, then it's added to the ShapeAnchorCollection, and since it's the first one, the ShapeAnchoringRule is fired. Additional changes are stored in the collection until the rule is finally handled. During the rule handling in ShapeAnchoringRule.FireCustomModelRule method, the ShapeAnchorCollection is copied and the one in the Transaction.Context is cleared, so that other change(s) caused by this rule can be queued correctly and have this rule fired again as needed. The shapes in the collection are then processed and their Bounds are fixed, as needed, by each step in the process.","In one example, the following conditions in the BoundsChanged rule causes the custom rules to be fired:\n\n","Size to Content Anchor","Referring next to , an exemplary AnchorTarget class  in accordance with an aspect of the present invention is illustrated. In this example, the AnchorTargetSizeToContent does not actually target a specific edge of the parent shape or another ShapeField, but allows the ShapeField's height or width (but not both) to flow depending on the content it is going to display. Thus, a ShapeField can size itself to its contents.","AnchorTarget  can be set on the AnchoringBehavior class by calling the SetLeftAnchor, SetTopAnchor, SetRightAnchor or SetBottomAnchor methods. When calculating the height for a ShapeField with the AnchorTargetSizeToContent anchor, the anchor calculation code can get the content for the corresponding ShapeField and determine its size requirements based on that content. In this example, the Size to Content setting can only have one floating side. The other size is fixed by anchoring to something else, for example, the edge of the parent ShapeElement or another ShapeField.","The AnchorTargetSizeToContent allows a designer to set its maximum size in number of lines. That way, if it is desired to allow flowing content but only up to a certain threshold, then this can be accomplished by setting the maximum size to the number of lines desired to be allowed. Although the size in lines is set, the actual size of the ShapeField itself is determined by the number of lines as well as the line height, which depends on the font being used.","Resizing Parent","For the parent resize functionality required by the design surface, whenever there is a BoundsChangedRule fired, the design surface checks that the ShapeElement is a NestedChildShape. If that is the case, then this ShapeElement's ParentShape can be placed in the PlowAndResizeParentCollection in the Transaction.Context. If this is the first one in the collection, then the PlowAndResizeParentRule can be added to the event queue.","Later, when the PlowAndResizeParentRule is fired, the collection can be copied locally and the one in the Transaction.Context can be cleared. Thus, if any bounds changes here cause another parent resize, the rule can be fired again, as needed. Also, in handling the PlowAndResizeParentRule, each shape in the PlowAndResizeParentCollection can be resized to fit its nested children.","If the child shapes have anchoring set on them, then the resize code can use the anchor margins to determine how much larger to make the parent shape to accommodate those margins. If the child shapes don't have anchoring, then a default margin size can be employed.","Virtual Document Size","The virtual document size is implemented in the same way as sizing the parent; in this case the parent ShapeElement  is the Diagram . The Diagram.Bounds is changed to contain all of its NestedChildShapes. It can then fire the appropriate event (ScrollRangeChanged) to ensure that the scroll bars update correctly with size of the document.","Resize Feedback","Resize feedback is drawn as the user uses the selection grab handles to make a ShapeElement's size larger or smaller. The feedback allows users to see what the new size will look like before committing the change. Resize feedback is limited by the ShapeElement.MinimumSize property.","For the resize feedback to work correctly with parent resize features, the MinimumSize property is calculated, so that for a parent of nested shapes, it cannot be smaller than the size required to fit all of its nested children. That is because the parent is allowed to be sized larger, but cannot size smaller than the area needed to display all of its nested children if they are currently marked as visible.","For it to work with size to content, the MinimumSize calculation also allows content to wrap and ShapeFields to be repositioned as needed for the content to be displayed.","Plowing","In one example, the core design surface implements a simple form of shape plowing. Plowing moves overlapping shapes out of the way, so that they no longer overlap. ShapeElement(s)  that are identified as causing a plow forces other sibling ShapeElement(s)  or themselves down and to the right, depending on which direction the overlap occurs on. The plowed ShapeElement(s)  can be moved to the next grid unit past the Bounds.Right or Bounds.Bottom of the plowing ShapeElement . This plowing mechanism can be implemented in the design surface itself.","To allow designers to specify if a ShapeElement  can or cannot plow, the WillPlow property can be exposed. If it returns true, then this shape can plow others, so any move it does will have an effect on its siblings. Also, any shapes that move and affect it (by overlap this plowable shape) will also cause shapes to move, including possibly moving the plowable shape.","During the handling of the PlowAndResizeParentRule, the plowing code can reposition shapes that overlap another shape that has the WillPlow property set to true.","Bounds Fixup","The design surface allows several points of integration for designers to plug into during the transaction processing. At these points, designer(s) are given an opportunity to adjust ShapeElement.Bounds as needed by calling the ShapeElement.OnBoundsFixup method. OnBoundsFixup can be called at the end of Pel Fixup, after shapes have been plowed, and after parent shapes have been resized. Each time, OnBoundsFixup can be called with the appropriate flag letting the method implementers know what step in the process they're in and the number of auto sizing\/positioning iterations.","In this example, the design surface no longer implicitly calls the BoundsRules on a ShapeElement  during its BoundsChangedRule processing. Instead, the default implementation of OnBoundsFixup applies the ShapeElement.BoundsRules. But designers can override this behavior and select which BoundsRules to apply and when to apply them in the OnBoundsFixup method.","Expand\/Collapse of Nested Shapes","Next, referring to , an exemplary Shape Element class  in accordance with an aspect of the present invention is illustrated. The ShapeElement class  can expose the Visible property. This property can control when shapes are displayed on the design surface. If a ShapeElement  has its Visible property set to false, then it will not be drawn, hit tested, and cannot be keyed to.","For the expand\/collapse feature of nested shapes, the Visible property can be employed to turn off child shapes that are nested within a containing shape. ShapeElement can expose two methods\u2014Expand and Collapse\u2014to support the expand\/collapse feature. Both methods can go through the RelativeChildShapes and change their Visible flag to the appropriate setting.","Graph Object Changes","In one example, to fully support nested shapes, the Graph Object can support a hierarchy of container shapes. Each container in the Graph Object can create its own instance of a Graph Object to track its NestedChildShapes. ShapeElements  can continue to be Nodes on that Graph Object; however, when the first NestedChildShape is added to a ShapeElement , then it becomes a Container instead at that point, it will be given its own instance of a Graph Object Container (which is the equivalent of another diagram inside the Graphic Object) to use for manipulating its NestedChildShapes. This is also referred to as hierarchy or a sub-container.","Referring briefly to , to support the Graph Object, PortShapes that are on the container can be exposed in two places within the Graph Object. First, a PortShape relative object  can be placed on the parent ShapeElement's Node,  so that it can be routed correctly in the outer Graph Object. Then, a duplicate PortShape relative object  can be placed within the container's Graph Object, so that lines within the ParentShape can be routed to it correctly. The outer Port connection direction (the direction a route is allowed to touch the Port in) is determined by the Port's position on the parent's bounding box. The inner Port simply uses the inverse direction of that determined for the outer port.","Hit test results can return objects in sub-containers to get all the possible shapes hit within it. Sub-containers may also be marked as visible or not letting clients ignore portions of the hierarchy. For example, when a container is \u201ccollapsed\u201d (e.g., analogous to collapsing a tree view of files), hit results from that container are ignored.","Declarative Design","A diagram's  style is defined by the pens, colors, fonts, and brushes used to paint it. The style can be changed without changing the semantic meaning of the diagram. The shape(s) in a diagram  fall into various categories, each having a specific style set used for painting.","In terms of the object model, a shape has a property named StyleSet which effectively acts as a tray of pens, colors, brushes, and fonts. DoPaint( ) can request any of these by name and the StyleSet returns a valid pen, brush, font, or color. For example, painting an ORM Role:","Pen pen=someRole.StyleSet.GetPen(\u201cdefault\u201d);","e.Graphics.DrawRectangle(pen, someRole.Bounds);","If a named resource is requested that does not exist, a default can be returned. Thus, assuming there is no pen named \u201cRoleBoundingBox\u201d the following code would return the default pen.","Pen pen=someRole.StyleSet.GetPen(\u201cORM.RoleBoundingBox\u201d);","e.Graphics.DrawRectangle(pen, someRole.Bounds);","However, if the \u201cORM.RoleBoundingBox\u201d pen was defined as a thick blue line, the above code would paint the role's bounding box with a thick blue line.","In order to define named resources, named pens, brushes, fonts, and colors can be specified declaratively on a shape class using the attributes: NamedPen; NamedBrush; NamedFont; & NamedColor. These attributes can be applied more than once and can be inherited. A class's overall \u201cstyle\u201d is determined by the combination of its locally defined and inherited named pens, brushes, fonts, & colors.","In addition to the above attributes, in one example, there are the five more: StyleSet, BrowsablePens, BrowsableBrushes, BrowsableFonts, & BrowsableColors. The StyleSet attribute names a style set. The BrowsableXxx attributes identify pens, brushes, fonts, & colors that will appear in the property browser when a shape is selected. These five attributes are not inherited and cannot be applied more than one time per class. These attributes are discussed in greater detail below.","Referring briefly to , B and C, exemplary shapes of an ORM diagram  in accordance with an aspect of the present invention is illustrated.","Attribute Descriptions","These attributes can be applied to additively specify properties for named pens, brushes, fonts, and colors. Generally, an unspecified property defers to its parent. If no parent exists, the ResourceCache's absolute default can be used. If the default pen (brush, font, color) is appropriate with no alteration, then no attribute need be specified.","[AttributeUsage (AttributeTargets.Class, AllowMultiple=true, Inherited=true)]","The NamedPen attribute names a pen that is defined by its specified & inherited property values.\n\n","[AttributeUsage (AttributeTargets.Class, AllowMultiple=true, Inherited=true)]","The NamedBrush attribute names a brush that is defined by its specified & inherited property values.\n\n","[Attribute Usage (AttributeTargets.Class, AllowMultiple=true, Inherited=true)]","The NamedFont attribute names a font that is defined by its specified & inherited property values.\n\n","[AttributeUsage (AttributeTargets.Class, AllowMultiple=true, Inherited=true)]","The NamedColor attribute names a color that is defined by its specified & inherited property values.\n\n","[Attribute Usage (AttributeTargets.Class, AllowMultiple=false, Inherited=false)]","The StyleSet attribute names the style set associated with the class that the attribute is applied to. If this attribute is not specified, the name defaults to the name of the class.","Properties include:\n\n","BrowsablePens, BrowsableBrushes, BrowsableFonts, & BrowsableColors","When a shape is selected, the Visual Studio Properties grid can display the properties for the element. If the style properties for a diagram element class are meant to be editable, then the class should be marked with the BrowsableXxx attributes. Property Descriptors can be created for every named pen, brush, font, & color that is listed in the BrowsableXxx attribute.","It is to be appreciated that immutable properties cannot be overridden, and cannot be set via the user interface. If a named resource has immutable properties and is listed as browsable, the immutable properties show up as read-only in the UI. For example, the following attributes define a browsable default pen, so when a shape associated with this pen is selected, the default pen will be appear in the property browser. The user will be able to set the pen's width and color, but will not be able to change the pen's dash style.\n\n","[Attribute Usage (AttributeTargets.Class, AllowMultiple=false, Inherited=false)]","BrowsablePens\n\n","[AttributeUsage (AttributeTargets.Class, AllowMultiple=false, Inherited=false)]","BrowsableBrushes\n\n","BrowsableFonts\n\n","[AttributeUsage (AttributeTargets.Class, AllowMultiple=false, Inherited=false)]","BrowsableColors\n\n",{"@attributes":{"id":"p-0337","num":"0437"},"figref":"FIGS. 25A","b":["25","25","25","2500"]},"Managing Shape Appearance","This section describes how the core design surface manages shape geometry and shape resources such as scarce system drawing resources (e.g., pens, fonts and brushes).","Public Interfaces & Programmability","Defining the Default Appearance of a Shape Class","To define the default (or static) appearance of a shape, the shape's geometry and resources are initialized. The resources include the fonts used throughout the shape, the pen characteristics such as color and thickness to draw such things as the shape outline and text rectangle outlines, and the shape background brush characteristics such as color and pattern.","In one example, to do so, following steps are taken:","(1) Override the ShapeGeometry property getter in a ShapeElement-derived class to define the geometry of the shape. Return an existing geometry from the ShapeGeometries class or create the designer's own geometry by deriving from ShapeGeometry.","(2) Override the InitializeResources method in the ShapeElement-derived class to define the default fonts, pens, and brushes for the shape.",{"@attributes":{"id":"p-0346","num":"0446"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003protected override void InitializeResources( StyleSet classStyleSet )"},{"entry":"\u2003{"},{"entry":"\u2003base.InitializeResources( classStyleSet );"},{"entry":"\u2003PenSettings outlinePenSettings = new PenSettings( );"},{"entry":"\u2003outlinePenSettings.Color = Color.Blue;"},{"entry":"\u2003outlinePenSettings.Width = 0.75f\/72.0f; \/\/ in inches"},{"entry":"\u2003classStyleSet.OverridePen( DiagramPens.ShapeOutline,"},{"entry":"outlinePenSettings);"},{"entry":"\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"ul":{"@attributes":{"id":"ul0035","list-style":"none"},"li":{"@attributes":{"id":"ul0035-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0036","list-style":"none"},"li":["This method is called by the core design surface prior to painting for the first time, allowing the designer to modify the class style set. The class style set is a collection of resources to be used for the shape instances of the ShapeElement-derived class.","In the body of your overridden method, it is important to call the base InitializeResources method first since it will initialize the class style set to the designer's base class's class style set. Without calling the base method, the base appearance of the shape will not be inherited.","In InitializeResources, call the style set's OverridePen, OverrideFont, and OverrideBrush to modify the default appearance of the shape. To determine which resources to override:\n        \n        "]}}}},"If it is important to guarantee that shapes which derive from the shape class inherit the shape class's appearance, the designer can use the pattern shown below in the designer's own shape class. This is especially important if a resource property, such as pen width, which should be immutable because it carries semantic meaning is involved.",{"@attributes":{"id":"p-0348","num":"0455"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003sealed protected override void InitializeResources( StyleSet"},{"entry":"classStyleSet )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003base.InitializeResources( classStyleSet );"},{"entry":"\u2003\u2003MyInitializeResources( classStyleSet );"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003protected virtual void MyInitializeResources( StyleSet classStyleSet )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Defining the Appearance of Shape Instance Based on IMS Property Values","To define the appearance of a shape instance based on IMS property values, IMS properties are associated with specific pens, brushes, and fonts. When the IMS properties change, an opportunity can be presented to udpate the pens, brushes, and fonts before using them.","For example:","(1) Call RegisterForPropertyChangedEvent method at the end of InitializeResources. This method associates an IMS property with a particular resource. When one of the IMS properties changes, then the ShapeElement will be automatically invalidated. The IMS property must be on the shape, not on an element-behind. If the property is on an element-behind, then create a proxy property on the ShapeElement.",{"@attributes":{"id":"p-0353","num":"0460"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"protected override void InitializeResources( StyleSet classStyleSet )"]},{"entry":[{},"{"]},{"entry":[{},"base.InitializeResources( classStyleSet );"]},{"entry":[{},"\/\/ ...<class style set initialization>"]},{"entry":[{},"\/\/\u2003\u2003\u2003\u2003\u2003:"]},{"entry":[{},"\u2003\u2003RegisterForPropertyChangedEvent( this.Store,"]},{"entry":[{},"\u2003\u2003IsExternalMetaAttributeGuid"]},{"entry":[{},");"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"(2) Override the InitializeInstanceResources method in the ShapeElement-derived class to define the instance specific fonts, pens, and brushes for the shape. This method is useful for setting instance style information that is different for each instance of a ShapeElement but doesn't change during the lifetime of the shape.",{"@attributes":{"id":"p-0355","num":"0462"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"protected void InitializeInstanceResources( )"]},{"entry":[{},"{"]},{"entry":[{},"base.InitializeInstanceResources( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003if (this.AssociatedElements[0] is ProviderPort)"]},{"entry":[{},"\u2003\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003BrushSettings bs = new BrushSettings( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ Provider Fill (Background Brush)"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003bs.Color = HslColor.White.ToRgbColor( );"]},{"entry":[{},"this.StyleSet.OverrideBrush(DiagramBrushes.ShapeBackground, bs);"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003else if (this.AssociatedElements[0] is ConsumerPort)"]},{"entry":[{},"\u2003\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003BrushSettings bs = new BrushSettings( );"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ Consumer Fill (Background Brush)"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003bs.Color = ThemeColor.ToRgbColor( );"]},{"entry":[{},"this.StyleSet.OverrideBrush(DiagramBrushes.ShapeBackground, bs);"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0038","list-style":"none"},"li":{"@attributes":{"id":"ul0038-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0039","list-style":"none"},"li":["This method is called by the core design surface when the instance style set for the shape is created, allowing the designer to modify the instance style set. The instance style set is a collection of resources to be used for this particular instance of the shape.","In the body of the overridden method, it is important to call the base InitializeInstanceResources method first since it will initialize the instance style set to the base class's instance style set. Without calling the base method, it will not inherit the base appearance of your shape."]}}}},"(3) Override the OnBeforePaint method. This method is called by the core design surface right before any of the ShapeElement painting is done. This is the last chance to change any drawing resources (pens, brushes, fonts) before they're used in the ShapeElement drawing. In the body of this overridden method, the appearance of the pen, brush, or font are defined based on the current values of shape properties.",{"@attributes":{"id":"p-0357","num":"0466"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003protected override void OnBeforePaint( )"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003PenSettings outlinePenSettings = new PenSettings( );"},{"entry":"\u2003\u2003outlinePenSettings.DashStyle = ( IsExternal ) ? DashStyle.Dash :"},{"entry":"DashStyle.Solid;"},{"entry":"\u2003\u2003this.StyleSet.OverridePen( DiagramPens.ShapeOutline,"},{"entry":"outlinePenSettings );"},{"entry":"\u2003\u2003}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"(4) Call AssociateGeometryWith at the end of InitializeResources. This method associates a set of IMS properties with the shape geometry. When one of the IMS properties changes, then OnUpdateGeometry will be called. The IMS properties are on the shape, not on an element-behind. If the property is on an element-behind, then create a proxy property.","Making a Resource Property Immutable","In certain instances, it may be desirable to prevent a derived shape from modifying a resource property (such as pen color) because it has semantic meaning. This can be accomplished, for example, by marking the resource property as immutable. For example:","To make immutable a resource property in the class style set, set the Immutable<PropertyName> of the PenSettings, BrushSettings, and\/or FontSettings while in the InitializeResources method. Once any resource property is set as immutable, it cannot generally be reversed without deleting the PenSettings, BrushSettings, or FontSettings object.",{"@attributes":{"id":"p-0362","num":"0471"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"protected override void InitializeResources( StyleSet classStyleSet )"]},{"entry":[{},"{"]},{"entry":[{},"base.InitializeResources( classStyleSet );"]},{"entry":[{},"PenSettings outlinePenSettings = new PenSettings( );"]},{"entry":[{},"outlinePenSettings.Color = Color.Blue;"]},{"entry":[{},"outlinePenSettings.ImmutableColor = true;"]},{"entry":[{},"this.StyleSet.OverridePen("]},{"entry":[{},"DiagramPens.ShapeOutline,"]},{"entry":[{},"outlinePenSettings );"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Making the Entire Shape Highlight","To highlight or unhighlight a shape for a given view, call the Set, Add, Remove, or Clear methods on the DiagramClientView's HighlightedShapes property. Any shape in this collection is considered highlighted.","To modify the default luminosity of the highlighted shape, override the ShapeElement's CalculateHighlightLuminosity method. This converts the current luminosity value for a shape with a different luminosity to show that the shape is highlighted.\n\n","Architecture and Detailed Design","Abstract Geometry Classes","A ShapeElement  in a diagram  can define virtual methods which handle painting, hit testing, and connector folding:",{"@attributes":{"id":"p-0369","num":"0483"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003public virtual void OnPaintShape( DiagramPaintEventArgs"},{"entry":"\u2003\u2003paintArgs )"},{"entry":"\u2003\u2003public virtual bool DoHitTest( PointD point, DiagramHitTestInfo"},{"entry":"hitTestInfo)"},{"entry":"\u2003\u2003public virtual PointD DoFoldToShape( PointD potentialPoint, PointD"},{"entry":"vectorEndpoint )"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"However, many diagram shape types are represented using variations of the same basic geometric shape, even though they have completely different semantic meanings and are from completely unrelated branches of the shape type hierarchy. Along those lines, there are several shape behaviors that are loosely dependent upon each other because of their geometric representations. The geometry of the instance of the shape influences the process of hit testing a shape, painting the shape on the design surface and \u2018folding\u2019 a connector to the perimeter of that shape. All of these behaviors may be generically applicable not only vertically through class hierarchy, but also \u2018horizontally\u2019 across unrelated types. Therefore, a hierarchy of Geometry Helper classes can be defined to which the shape classes will delegate to these tasks in a general purpose manner.","The Shape object will expose a method which returns a Geometry class instance for use by the shape's DoPaint( ), DoHitTest( ), and DoFoldToShape( ) methods.","Using the helper object in this manner allows several advantages and flexibilities, for example:\n\n","Referring to , an exemplary ShapeGeometry class  in accordance with an aspect of the present invention is illustrated.","Painting Behavior","A design surface view can be associated with one Diagram PresentationElement at a time. Drawing is triggered by invalidating (regions of) the design surface view (e.g., indication of area(s) that are required for redraw). The design surface view queries the Diagram's graph object to determine which shapes need to be rendered based on the clipping region to be redrawn. The identified shapes will be called to paint themselves through their OnPaintShape( ) method. By default, the ShapeElement OnPaintShape method can work in conjunction with the appropriate StyleSet and Geometry objects. This can occur for each element recursively in reverse z-order (e.g., drawing order) maintained by the diagram. Scrolling and pan-zoom are handled by the design surface view.","The ShapeElement::OnPaintShape( ) method can be overridden by subclasses, but the following pseudocode demonstrates how default implementation operates:",{"@attributes":{"id":"p-0377","num":"0495"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"OnPaintShape(args)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003this.ShapeGeometry.DoPaint(args);"]},{"entry":[{},"\u2003\u2003For (each shapeField of this shape)"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003shapeField.Dopaint(args);"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The Geometry DoPaint( ) methods use the shape's StyleSet to retrieve the designated outline pen and background brush when painting by default.","Shadows","In one example, the ability to set clipping regions into the Graphics surface is provided. One of the regions supported is a GraphicsPath region. Additionally, the clipping regions can be extended using several flags which allow xor, union, intersection, complement, etc. The Complement setting allows replacement of non-overlapping path regions that are not covered by prior paths in the region. Using this setting yields the \u2018sliver\u2019, which is painted using the Shadow brush from the shape's style set. For example:",{"@attributes":{"id":"p-0381","num":"0499"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"ShapeGeometry::DoPaintShadow( )"},{"entry":"{"},{"entry":"\u2003\u2003save current graphics state"},{"entry":"\u2003\u2003get path for the shape's geometry"},{"entry":"\u2003\u2003set the path into the clipping region"},{"entry":"\u2003\u2003offset the path by the shadow offset"},{"entry":"\u2003\u2003set the offset path into the clipping region using complement setting"},{"entry":"\u2003\u2003draw the path as a filled region using the shadow brush"},{"entry":"\u2003\u2003restore graphics state"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Hit Test Behavior","In response to mouse action(s) and\/or invalidated region(s), the design surface can query the Diagram  (which in turn queries the diagram's graph object) to determine which shape(s) are affected. The design surface view is responsible for converting the regions into rectangles to be used when querying the graph object. The shapes themselves can support fine grained hit testing since the Graph Object only works on bounding rectangles. For example, a rounded rectangle has small regions in the corners which lie within the bounding rectangle but are outside the shape's perimeter. Therefore, the Graph object will return all shapes (including those in sub-containers) whose bounding rectangles coincide with the hit test point, and the DoHitTest( ) method of each potential shape can be called in z-order for final determination with respect to fine grained selection of the shape itself as well as internal shape field selection. The graph object has no knowledge of shape fields, so this functionality is provided by the shapes themselves.","The Geometry object of the shape is delegated the task of determining whether the hit point lies within the interior of the shape. If so, then the shape's fields are tested to determine which was selected.","The following demonstrates how a ShapeElement's DoHitTest( ) method can operate:",{"@attributes":{"id":"p-0386","num":"0504"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"virtual bool DoHitTest(args)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003if ( Geometry.DoHitTest(args))"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003for (each shapeField in this shape )"]},{"entry":[{},"\u2003\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003if ( shapeField.DoHitTest( args ) )"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ save the shape field as a hit target"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003return true;"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003return false;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Shape Folding Behavior","As stated above, the Graph object is only capable of supporting rectangular boundaries for its shapes. Complex outlining of a shape therefore requires \u201cfolding\u201d a connector to the perimeter of a shape. This is accomplished by constructing a vector from two points. The vectorXY point marks the base of the vector. The potentialXY marks the point that the graph object determines that the vector intersects the bounding rectangle of the shape. The method returns the point where the vector intersects the actual perimeter of the shape.","Referring to , an exemplary user interface  in accordance with an aspect of the present invention is illustrated. In this example, an elliptical shape is held by the graph object. A connector is \u201cfolded\u201d to the perimeter of the ellipse. The following demonstrates how a ShapeElement's DoFoldToShape( ) method delegates to the geometry object by default:",{"@attributes":{"id":"p-0390","num":"0508"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"virtual DoFoldToShape(args)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003return Geometry.DoFoldToShape(args);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Resource Cache","To draw a shape, the shape has access to any number of fonts, pens, and brushes. In an application containing perhaps tens of thousands (or even hundreds of thousands) of shapes and subshapes, management of these resources is important. The diagram and diagram shapes should minimize their use of memory and graphical resources without taking away functionality, perceptible performance, or ease of use for the shape developer to access and use them. By introducing a resource cache to the design surface, a means of sharing common resources among shapes and diagrams is provided.","The resource cache can be thought of as a pool of resource descriptions coupled with their corresponding font, pen, or brush resource. The resource cache is global across the entire application, so it is implemented as a singleton class which is instantiated the first time it is used. It can be optimized to locate a resource quickly given the resource description.","The relevant methods are GetPen( ), GetBrush( ), and GetFont( ). These methods take a resource description (a PenInfo, BrushInfo, or FontInfo which will be described later) and return a system drawing resource such as a pen, brush, or font. If a GDI+ resource does not exist which matches the resource description, a new resource descriptor will be created and its reference returned.","Internally, the resource cache contains maps of pen, font, and brush descriptors. A descriptor is comprised of the actual resource, the description of the resource, and a method to clone the private resource.","Referring to , exemplary ResourceCache class  in accordance with an aspect of the present invention is illustrated.","Named Resources","It can be useful to abstract the use or meaning of the pen, brush, or font from its appearance. The drawing code does not care what the pen, brush, or font looks like. However, it does care about the fact that it can get the shape's outline pen or the shape's background brush.","In accordance with an aspect of the present invention, an abstraction for shapes, for example, named resources is provided. A named resource associates a name with a resource in the ResourceCache.","The shape developer refers to the resource based on its meaning within the shape. The meaning of the resource is indicated by the name of the desired resource. This abstracts the meaning from the actual appearance that can be altered later independently.","Exemplary predefined resource identifiers include, but are not limited to:",{"@attributes":{"id":"p-0402","num":"0520"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public sealed class DiagramPens"},{"entry":"{"},{"entry":"\u2003\u2003public static StyleSetResourceId DiagramOutline {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId ShapeOutline {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId ShapeTitleOutline {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId ShapeSubtitleOutline {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId ConnectionLine {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId ConnectionLineGhost {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId ConnectionLineDecorator {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId SelectionPrimaryOutline {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId SelectionNonPrimaryOutline {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId GridLines {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId Lasso {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId ZoomLasso {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId ShapeResizeOutline {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId SelectionGrabHandles {get;}"},{"entry":"}"},{"entry":"public sealed class DiagramBrushes"},{"entry":"{"},{"entry":"\u2003\u2003public static StyleSetResourceId DiagramTitleBackground {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId DiagramSubtitleBackground {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId DiagramBackground {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId ShapeTitleBackground {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId ShapeSubtitleBackground {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId ShapeBackground {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId Shadow {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId PrimaryGrabHandles {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId SecondaryGrabHandles {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId CommentTitleBackground {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId CommentBackground {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId DiagramTitleText {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId DiagramSubtitleText {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId DiagramText {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId ShapeTitleText {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId ShapeSubtitleText {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId ShapeText {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId ConnectionLineText {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId CommentTitleText {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId CommentText {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId Selection {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId ConnectionLineDecorator {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId SelectionGrabHandles {get;}"},{"entry":"}"},{"entry":"public sealed class DiagramFonts"},{"entry":"{"},{"entry":"\u2003\u2003public static StyleSetResourceId DiagramTitle {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId DiagramSubtitle {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId Diagram {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId ShapeTitle {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId ShapeSubtitle {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId ShapeText {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId ConnectionLine {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId CommentTitle {get;}"},{"entry":"\u2003\u2003public static StyleSetResourceId CommentText {get;}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Style Sets","In one example, the developer does not have to create common named resources such as the shape's outline pen, the shape's background brush, and the shape's text font. Instead, a base set of predefined named resources is available to the developer for immediate use. Having a base set of predefined named resources:\n\n","Furthermore, the developer can get default functionality from the Geometry object, which means that the Geometry object should assume (by default) the common resources when drawing.","The end user also has a few customization requirements to address:\n\n","Resource Inheritance","In one example, there are three levels of inheritance, thus three levels of style sets:\n\n","Each style set has a collection of PenDescriptors. If a pen is overridden for a particular style set, then there will be an entry in that style set's PenDescriptor collection. The key for the collection is the pen id (a StyleSetResourceId) and, of course, the value is a PenDescriptor. The PenDescriptor keeps track of the pen description (color, width, etc) and a reference to the pen in the resource cache. If the pen is never asked for, it is never created, and the pen reference remains null.",{"@attributes":{"id":"p-0410","num":"0536"},"figref":"FIG. 30","b":"3000"},"To describe the resource inheritance process, a pen retrieval example can be used:\n\n","Style Set Initialization","Initializing the Application Style Set\n\n","Initializing the Class Style Set\n\n","protected virtual void InitializeResources(StyleSet classStyleSet)","Initializing the Instance Style Set\n\n","protected virtual void InitializeInstanceResources( )\n\n",{"@attributes":{"id":"p-0418","num":"0560"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public void RegisterForPropertyChangedEvent(Store store, Guid"]},{"entry":[{},"metaAttributeGuid)"]},{"entry":[{},"public void RegisterForPropertyChangedEvent(Store store, Guid"]},{"entry":[{},"proxyMetaAttributeGuid, Guid realMetaAttributeGuid)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0062","list-style":"none"},"li":{"@attributes":{"id":"ul0062-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0063","list-style":"none"},"li":"The RegisterForPropertyChangedEvent methods are responsible for subscribing to the attribute changed events. Rather than subscribe on a per shape instance, per shape class can be subscribed. The event handler will invalidate the shape instance that changed. This causes the shape to be repainted. Instance specific resources can then be changed in the OnBeforePaint method that is called by the design surface."}}}},"Immutability","The PenSettings, BrushSettings, and FontSettings structures maintain override information. When OverridePen, OverrideBrush, or OverrideFont is called, only the overridden information is transferred to the actual resource description. If nothing was overridden, no transfer takes place. The setter of each property keeps track if it was actually called, marking that property as overridden.","A particular property can be marked as immutable, such as the pen color. If so, then any attempt to set the property will be ignored.",{"@attributes":{"id":"p-0422","num":"0565"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public Color Color"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003get"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003return this.PenStyleSetInfo.Color;"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003set"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003if (!IsImmutable(PenSettingsFlags.Color))"]},{"entry":[{},"\u2003\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ marks property as overridden"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003Override(PenSettingsFlags.Color);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ set property value"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003this.PenStyleSetInfo.Color = value;"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"To make a particular property immutable, the following type of <Resource> Settings property can be called:",{"@attributes":{"id":"p-0424","num":"0567"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public bool ImmutableColor"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003get"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003return IsImmutable( PenSettingsFlags.Color );"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003set"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/ cannot clear once set."]},{"entry":[{},"\u2003\u2003\u2003\u2003if ( value )"]},{"entry":[{},"\u2003\u2003\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003SetImmutable( PenSettingsFlags.Color );"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Adding a Resource to a Style Set","Resources can be added to a style set through the methods below:",{"@attributes":{"id":"p-0427","num":"0570"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public void AddPen( StyleSetResourceId newPenID, StyleSetResourceId"},{"entry":"basePenID, PenSettings penSettings )"},{"entry":"public void AddBrush( StyleSetResourceId newBrushID,"},{"entry":"StyleSetResourceId baseBrushID, BrushSettings brushSettings )"},{"entry":"public void AddFont( StyleSetResourceId newFontID, StyleSetResourceId"},{"entry":"baseFontID, FontSettings fontSettings )"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"ul":{"@attributes":{"id":"ul0064","list-style":"none"},"li":{"@attributes":{"id":"ul0064-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0065","list-style":"none"},"li":["The methods above associate a resource id with a description of the resource. They do not create the resource. The resources are created just before they are actually used. A weak reference to the resources are maintained.","The PenSettings, BrushSettings, and FontSettings are structures used to define the resource properties to override and their new values. If no resource properties are set in any of the structures, the resource is not added."]}}}},"Application Style Set\n\n","Class Style Set\n\n","Instance Style Set\n\n","Modifying a Resource","Resources in a style set can be modified using the methods below:",{"@attributes":{"id":"p-0433","num":"0582"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public virtual void OverridePen( StyleSetResourceId penID, PenSettings"},{"entry":"penSettings )"},{"entry":"public virtual void OverrideBrush( StyleSetResourceId brushID,"},{"entry":"BrushSettings brushSettings )"},{"entry":"public virtual void OverrideFont( StyleSetResourceId fontID, FontSettings"},{"entry":"fontSettings )"},{"entry":"public virtual void ClearPenOverride( StyleSetResourceId penID )"},{"entry":"public virtual void ClearBrushOverride( StyleSetResourceId brushID )"},{"entry":"public virtual void ClearFontOverride( StyleSetResourceId fontID )"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"OverridePen, OverrideBrush, and OverrideFont do not create resources. Rather, they set the resource description for a given resource id (e.g., overriding the inherited resource description). That is, the instance style set inherits from the class style set; the class style set inherits from the application style set.","The override process is two step. Consider an overridden pen on a class style set as an example:\n\n",{"@attributes":{"id":"p-0436","num":"0586"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"internal virtual PenDescriptor GetPenDescriptor( StyleSetResourceId"]},{"entry":[{},"penID )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003PenDescriptor penDescriptor = null;"]},{"entry":[{},"\u2003\u2003\/\/ Get the pen descriptor from this style set."]},{"entry":[{},"\u2003\u2003if ( this.penDescriptors != null)"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003penDescriptor = this.penDescriptors[penID];"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\/\/ If this style set doesn't have it, go up the parent hierarchy"]},{"entry":[{},"\u2003\u2003\/\/ and find it. Eventually, the application style set will be"]},{"entry":[{},"\u2003\u2003\/\/ reached, and a default resource will be given."]},{"entry":[{},"\u2003\u2003if ( penDescriptor == null && this.Parent != null )"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003PenDescriptor penDescriptor ="]},{"entry":[{},"this.Parent.GetPenDescriptor(penID);"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003if ( penDescriptor == null )"]},{"entry":[{},"\u2003\u2003{"]},{"entry":[{},"\u2003\u2003\u2003\u2003\/\/ This should never happen as the pen descriptor should"]},{"entry":[{},"always be found"]},{"entry":[{},"\u2003\u2003\u2003\u2003throw new ArgumentOutOfRangeException( \u201cpenID\u201d );"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003return penDescriptor;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"ul":{"@attributes":{"id":"ul0074","list-style":"none"},"li":{"@attributes":{"id":"ul0074-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0075","list-style":"none"},"li":"The pen descriptor for the class style set is created by starting with the values from the inherited application style set PenDescriptor and replacing values from PenSettings.\n\nClearing an override removes the overridden resource description and the inherited resource description is used instead.\n"}}}},"Application Style Set\n\n","Class Style Set\n\n","Instance Style Set\n\n","Getting a Resource","The actual GDI+ resources can be retrieved through the methods below:",{"@attributes":{"id":"p-0442","num":"0596"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public Pen GetPen( StyleSetResourceId penID )"]},{"entry":[{},"public Brush GetBrush( StyleSetResourceId brushID )"]},{"entry":[{},"public Font GetFont( StyleSetResourceId fontID )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Getting a resource follows a specific search sequence until the resource is found. The sequence is as follows:\n\n","When a resource is found by the style set mechanism, a clone is returned. This implies that the client code can modify the resource without modifying the original resource. Performance measurements indicate that cloning an existing resource object performs much better than creating one from scratch using new( ), but returning the resource directly performs the best. If immutable GDI+ resources are implemented, then direct access to the resource can be provided.","Propagating Changes of a Base Style Set","If the application style set changes, then the class style sets and the instance style sets need to mark their resources as invalid so that the next time they are used, they are reinitialized.","Likewise, if the class style set changes, then the instance style sets need to mark their resources as invalid.","Removing a Resource from a Style Set","Resources can be removed from a style set through the methods below:",{"@attributes":{"id":"p-0450","num":"0607"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public void RemovePen( StyleSetResourceId penID )"]},{"entry":[{},"public void RemoveBrush( StyleSetResourceId brushID )"]},{"entry":[{},"public void RemoveFont( StyleSetResourceId fontID )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Predefined resources are not allowed to be removed in this implementation but that should not be considered as the only option available.","High contrast","Color Choice","Pen color(s) and font color(s) can be contrasted with background brush color(s) in the Application Style Set. In one example, the base color mapping in the Application Style Set will be used strictly for supporting high contrast. It is not intended to provide reasonable default colors since the designers typically will want to override the colors anyway. Therefore, in this example, the default base color mapping in the Application Style Set should be as follows (with a few exceptions):\n\n","To provide reasonable default colors, the Application Style Set will override its own base resources after the base resources have been initially defined. The following resources will be overridden to provide a more palatable appearance:\n\n","The shape developer can also choose to override the same application style set resources. For example, fore color and font can be set by overriding the resources in the application style set. In this case, the default overrides are replaced by those provided by the shape developer.","To enable the above, a single internal style set can be maintained within the application style set singleton.\n\n","Resolving Resources","When SystemInformation.HighContrast is set to true, then substantially all overridden colors (including application style set overrides) are ignored. The color properties of fonts, pens, and brushes will be made temporarily immutable at the application style set level. If SystemInformation.HighContrast is set to false, then resolution of colors is performed normally by traversing the style set hierarchy.","To force a re-resolution of the resources, the ResolvedBaseXxSettings and ResolvedXxDescriptor properties of the XxSettingsStruct must be nulled out. The StyleSet will have a new method RecomputeResources which will iterate all of its local XxSettingsStructs and null out the aforementioned properties. The ApplicationStyleSet will have a RecomputeAllResources method that will call its own RecomputeResources as well as iterate every shape instance and invoke RecomputeResources on both the instance style set as well as the class style set.","Updating Resources","The colors will be updated when the following events occur:\n\n","Color Assignments","Exemplary color assignments of base resources in the application style set are:",{"@attributes":{"id":"p-0465","num":"0636"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Pens (Default: Color=(SystemColors.WindowText)"},{"entry":"unless otherwise specified)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"shapeOutline","Default"]},{"entry":[{},"shapeTitleOutline","Default"]},{"entry":[{},"shapeSubtitleOutline","Default"]},{"entry":[{},"connectionLine","Default"]},{"entry":[{},"connectionLineGhost","Color=(SystemColors.GrayText)"]},{"entry":[{},"connectionLineDecorator","Default"]},{"entry":[{},"gridLines","Color=(SystemColors.GrayText)"]},{"entry":[{},"lasso","Color=(SystemColors.GrayText)"]},{"entry":[{},"zoomLasso","default -- override( Color="]},{"entry":[{},{},"(Color.DarkGreen))"]},{"entry":[{},"shapeResizeOutline","Color=(SystemColors.GrayText)"]},{"entry":[{},"selectionGrabHandles","Default"]},{"entry":[{},"focusIndicatorBackground","Color=(SystemColors.Window)"]},{"entry":[{},"focusIndicator","Default"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0466","num":"0637"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Brushes (Default: Color=(SystemColors.Window)"},{"entry":"and SolidBrush unless otherwise specified)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["diagramTitleBackground","Default"]},{"entry":["diagramSubtitleBackground","Default"]},{"entry":["diagramBackground","Default"]},{"entry":["shapeTitleBackground","Default"]},{"entry":["shapeSubtitleBackground","Default"]},{"entry":["shapeBackground","Default"]},{"entry":["shapeBackgroundSelected","Color=(SystemColors.Highlight);"]},{"entry":[{},"SolidBrush"]},{"entry":["shapeBackgroundSelectedInactive","Color="]},{"entry":[{},"(SystemColors.InactiveCaption);"]},{"entry":[{},"SolidBrush"]},{"entry":["shadow","Color=(SystemColors.WindowText);"]},{"entry":[{},"SolidBrush"]},{"entry":["commentBackground","Default"]},{"entry":["selection","ForeColor=(SystemColors.GrayText);"]},{"entry":[{},"BackColor=(SystemColors.Window);"]},{"entry":[{},"HatchBrush"]},{"entry":["connectionLineDecorator","Color=(SystemColors.WindowText);"]},{"entry":[{},"SolidBrush"]},{"entry":["selectionGrabHandles","Default"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0467","num":"0638"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Text Brushes (Default: Color=(SystemColors.WindowText)"},{"entry":"and SolidBrush unless otherwise specified)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["diagramTitleText","Default"]},{"entry":["diagramSubtitleText","Default"]},{"entry":["diagramText","Default"]},{"entry":["shapeTitleText","Default"]},{"entry":["shapeSubtitleText","Default"]},{"entry":["shapeText","Default"]},{"entry":["shapeTextSelected","Color=(SystemColors.HighlightText);"]},{"entry":[{},"SolidBrush"]},{"entry":["shapeTextSelectedInactive","Color=(SystemColors.InactiveCaptionText);"]},{"entry":[{},"SolidBrush"]},{"entry":["connectionLineText","Default"]},{"entry":["commentText","Default"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"List Field","This section describes the list field, a shape field capable of displaying a list of items efficiently.","Adding a List Field to a Shape","To add a list field to a shape:","1. In the InitializeShapeFields of the parent shape class, instantiate a ListField and call the ShapeFieldCollection.Add method. This will add a list field for every shape instance of the parent shape class.",{"@attributes":{"id":"p-0473","num":"0644"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"protected override void InitializeShapeFields( ShapeFieldCollection"},{"entry":"shapeFields )"},{"entry":"{"},{"entry":"\u2003\u2003ListField listField = new ListField( );"},{"entry":"\u2003\u2003listField.BoundsBehaviors.SetTopAnchor(BoundsBehavior.Edge."},{"entry":"\u2003\u2003Top, 0);"},{"entry":"\u2003\u2003listField.BoundsBehaviors.SetLeftAnchor(BoundsBehavior.Edge."},{"entry":"\u2003\u2003Left, 0);"},{"entry":"\u2003\u2003listField.BoundsBehaviors.SetRightAnchor(BoundsBehavior.Edge."},{"entry":"\u2003\u2003Right , 0);"},{"entry":"\u2003\u2003listField.BoundsBehaviors.SetBottomAnchor(BoundsBehavior.Edge."},{"entry":"\u2003\u2003Bottom, 0);"},{"entry":"\u2003\u2003listFieldKey = shapeFields.Add( listField );"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"2. Implement the IListFieldContainer interface on the parent shape class.",{"@attributes":{"id":"p-0475","num":"0646"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"interface IListFieldContainer"},{"entry":"{"},{"entry":"\u2003\u2003int GetItemCount(ListField listField);"},{"entry":"\u2003\u2003void GetItemDrawInfo(ListField listField, int row, ItemDrawInfo"},{"entry":"itemDrawInfo);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Setting the Contents of the List Field","The list field does not maintain its own contents. The parent shape class is responsible for maintaining this information. The list field requests from the parent shape what to draw. So instead of setting the contents of the list field, implement the IListFieldContainer.GetItemDrawInfo method on the parent shape class.",{"@attributes":{"id":"p-0478","num":"0649"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void GetItemDrawInfo(ListField listField, int row, ItemDrawInfo"]},{"entry":[{},"itemDrawInfo);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The ItemDrawInfo class contains the item text, item image, and item state.","Inserting and Deleting Items","To insert or delete an item, update your own list of items and then invalidate the shape. This will cause GetItemDrawInfo to be called again for substantially all items.","Sorting","To sort the list field, update your own list of items and invalidate the shape. This will cause GetItemDrawInfo to be called again for all items.","Customizing the Appearance of the List Field","By default, the list field will use the following style set resources of its parent shape:\n\n","1. Override the InitializeResources method of the parent shape class.","2. In the body of the InitializeResources method, call AddPen, AddBrush, and AddFont on the class style set to add your custom resources.","3. To make the list field use those custom resources, set the following ListField properties in the InitializeShapeFields method of the parent shape class:\n\n","ListCompartmentShape","The ListCompartmentShape sets a ListField with a CompartmentShape for convenience.","To customize the appearance of the ListCompartmentShape, override its InitializeShapeFields and customize the header text field and the list field.",{"@attributes":{"id":"p-0492","num":"0676"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"protected override void InitializeShapeFields( ShapeFieldCollection"]},{"entry":[{},"shapeFields )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003base.InitializeShapeFields( shapeFields );"]},{"entry":[{},"\u2003\u2003HeaderTextField.DefaultText = \u201c<Your ListField Title>\u201d;"]},{"entry":[{},"\u2003\u2003ListField.NormalFontID = DesignSurfaceFonts.ShapeText;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"To define the contents of the list field, override the methods GetItemCount and GetItemDrawInfo.",{"@attributes":{"id":"p-0494","num":"0678"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public override int GetItemCount( ListField listField )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003return this.myItemCollection.Count;"]},{"entry":[{},"}"]},{"entry":[{},"public override void GetItemDrawInfo( ListField listField, int row,"]},{"entry":[{},"ItemDrawInfo itemDrawInfo )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003itemDrawInfo.Text = this.myItemCollection[row].Text;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Architecture and Detailed Design","Subfields","The list field introduces the need for a subfield for hit testing, focus, and selection. Items are selectable and an item can be a candidate for the property browser. A subfield is a general notion: for example, the subfield for a grid field is a cell, the subfield for a list field is an item, and the subfield for a radio button group field is a radio button.","ShapeSubField Class","Referring to , an exemplary ShapeSubField class  in accordance with an aspect of the present invention is illustrated. The ShapeSubField class  provides the base class for hit-testable, focusable, and\/or selectable regions in a derived-ShapeField class. ShapeSubFields-derived objects are transient\u2014they live only long enough to return hit-test information, to keep track of focus, to keep track of a selected item within a ShapeField, to support navigation, and to support IAccessible and WinEvents.","ShapeSubFields  are not intended to live during the entire lifetime of the field since that is both an inefficient use of memory and would degrade performance. For example, a simple 5 by 10 grid field would require instantiating 50 ShapeSubFields , not including all the grid lines and row headers.","A subfield can be (1) focusable and selectable, (2) focusable only, or (3) neither focusable nor selectable. The subfield is queried for this information via GetFocusable and GetSelectable. Since shape subfields can receive focus, focusable subfields can respond to OnKeyDown, OnKeyUp, and OnKeyPress. Subfields can also respond to mouse events as well.","To provide cursor feedback and to activate a mouse action, a subfield can also respond to GetPotentialMouseAction. The mouse action returned by this method will be activated on the next MouseDown if the mouse is still over the subfield.","DiagramItem Class","Next, turning to , an exemplary DiagramItem class  in accordance with an aspect of the present invention is illustrated. A subfield is defined by its container shapefield and container shape. The DiagramItem class  captures this information together. The DiagramItem  is intended to represent a subfield that has been hit, focused, or selected. It can also represent a shape by nulling out the field and subfield, and a field by nulling out the subfield.","Hit Testing and Painting","DiagramHitTestInfo","Turning to , an exemplary DiagramHitTestInfo structure  in accordance with an aspect of the present invention is illustrated. The DiagramHitTestInfo structure  includes the concept of subfields, as discussed above.","DoHitTest and DoPaint","Next, referring to , an exemplary Shapefield class  in accordance with an aspect of the present invention is illustrated. To allow for the subfield support in the DiagramHitTestInfo class, the DoHitTest and DoPaint methods on the ShapeField class have been modified as illustrated in .\n\n","Selection","SelectedShapesCollection","Referring to , an exemplary SelectedShapesCollection class  in accordance with an aspect of the present invention is illustrated. To allow for the subfield support in the selection, the SelectedShapesCollection  can be modified to include fields and sub fields. The new collection item will no longer be the ShapeElement. Rather, the collection item will be a DiagramItem, a class representing the selected ShapeElement, ShapeField, and ShapeSubField. In this example, if a ShapeSubField is selected, then all three member attributes must be set. If a ShapeField is selected, then ShapeSubField is null. If only the ShapeElement is selected, then only the ShapeElement is set; all others are null.","Anchor","The user can multi-select list items by:\n\n","To support the above scenario, the SelectedShapesCollection employs a new Anchor property. The anchor object is different from the primary or focused object. The primary object is the last item in the selection. The anchor object, on the other hand, is the last clicked item in which the shift key was not pressed. Once shift+clicking begins, the anchor must not change.",{"@attributes":{"id":"p-0516","num":"0705"},"tables":{"@attributes":{"id":"TABLE-US-00037","num":"00037"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public class SelectedShapesCollection : ICollection"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003public SelectedDiagramItem Anchor {get; set; }"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The SelectAction mouse tool is responsible for setting the Anchor property. If Shift+click is not performed in the same shape field as the anchor object, then the SelectAction should set the Anchor to null.","SelectAction.Select( )","The Select method of the SelectAction selects the diagram item under the mouse. The exact operation is altered by modifier keys.","protected void Select(DiagramMouseEventArgs mouseArgs)","The Select method will expand its responsibilities to include:\n\n","Referring briefly to , a method  facilitating obtaining a first selectable object in accordance with an aspect of the present invention is illustrated. At , a determination is made as to whether a subfield is selectable. If the determination at  is YES, at , the selectable object has been found, and no further processing occurs.","If the determination at  is NO, at , a determination is made as to whether a field is selectable. If the determination at  is YES, processing continues at . If the determination at  is NO, at , a determination is made as to whether a shape is selectable. If the determination at  is YES, processing continues at . If the determination at  is NO, at , the parent shape is obtained and processing continues at .","Turning to  a method  facilitating obtains a first focusable object in accordance with an aspect of the present invention is illustrated. At , a determination is made as to whether a subfield is selectable. If the determination at  is YES, at , the selectable object is found, and, no further processing occurs.","If the determination at  is NO, at , a determination is made as to whether a field is focusable. If the determination at  is YES, processing continues at . If the determination at  is NO, at , a determination is made as to whether a shape is focusable. If the determination at  is YES, processing continues at . If the determination at  is NO, at , a parent shape is obtained, and, processing continues at .","For example, the SelectAction mouse action, when responding to the mouse events, sets the Handled property in the DiagramEventArgs to false. This enables the shape, field, or subfield to respond to the mouse events such as OnMouseDown and OnMouseUp. For example, a button field or subfield will still be able to respond to the MouseDown and MouseUp events even though the SelectAction is the active mouse action.","Diagram.LassoSelect","In this example, lasso selection selects only shape elements; it will not include fields or subfields. Further, Lasso selection filters out non-selectable shapes prior to executing the selection rules.","Delete","If a shape is deleted, substantially all DiagramItems which refer to that shape are removed from the SelectedShapesCollection.","DiagramSelectionRules Class","Referring to , an exemplary DiagramSelectionRules class  in accordance with an aspect of the present invention. The DiagramSelectionRules  is updated to take a collection of DiagramItems rather than ShapeElements.","Keyboard Support","Subfields will be given the ability to respond to keyboard events. Further, referring to , an exemplary SelectedShapesCollection class  in accordance with an aspect of the present invention is illustrated. The SelectedShapesCollection class  has an additional property FocusedItem which keeps track of which object has the focus. A focused item is separate from the primary item in the selection in order to support multi-select and to set focus to an object which should not be selected, such as a button.","Turning to , an exemplary ShapesSubField class  in accordance with an aspect of the present invention is illustrated. The keyboard event can be routed to the FocusedItem. If the focused item is the subfield, then the subfield will be given the chance to respond to it via its overridden OnKeyDown, OnKeyUp, and OnKeyPress.","Mouse Support","GetPotentialMouseAction","DiagramClientView.Cursor, .OnMouseDown, and OnMouseMove check for a potential mouse action if there is no active mouse action by calling ShapeElement.GetPotentialMouseAction. The potential mouse action is activated on MouseDown if the mouse is still over the hit object that supplied the potential mouse action.","The potential mouse action query can be expanded beyond just asking the hit shape: it can query field(s) and\/or subfield(s). Referring briefly to , a method  facilitating retrieval of a potential mouse action in accordance with an aspect of the present invention is illustrated. At , a determination is made as to whether a subfield has received a potential mouse action. If the determination is YES, at , the potential mouse action has been found, and, no further processing occurs.","If the determination at  is NO, at , a determination is made as to whether a field has received a potential mouse action. If the determination is YES, processing continues at . If the determination at  is NO, at , a determination is made as to whether a shape has received a potential mouse action. If the determination is made, processing continues at . If the determination at  is NO, at , it is determination no potential mouse action has been received, and, no further processing occurs.","Double Click","The mouse event routing will need to route the OnDoubleClick not only to the ShapeElement, but also to the ShapeField and the ShapeSubField. If the OnDoubleClick is handled at any stage, the routing stops.","ListField","The ListField class derives from ShapeField and overrides DoPaint and DoHitTest.",{"@attributes":{"id":"p-0545","num":"0737"},"tables":{"@attributes":{"id":"TABLE-US-00038","num":"00038"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public class ListField : ShapeField"},{"entry":"{"},{"entry":"\u2003public override void DoHitTest(PointD point, ShapeElement"},{"entry":"\u2003parentShape,"},{"entry":"\u2003\u2003DiagramHitTestInfo info) { }"},{"entry":"\u2003public override void DoPaint(DiagramPaintEventArgs e, ShapeElement"},{"entry":"\u2003\u2003parentShape) { }"},{"entry":"\u2003public virtual void DrawItem( CompleteItemDrawInfo"},{"entry":"\u2003completeItemDrawInfo )"},{"entry":"\u2003\u2003{ }"},{"entry":"\u2003public virtual double GetItemHeight( ShapeElement parentShape ) { }"},{"entry":"\u2003public int GetItemCount( ShapeElement parentShape ) { }"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"IListFieldContainer","Because the list field is a field, it is a \u201cflyweight\u201d. It has no instance data, so it relies on a combination of field behavior descriptions and its parent shape. In one example, an interface from which a ShapeElement-derived class can derive is provided.","The IListFieldContainer implementation is responsible for providing instance level information to the child list field.",{"@attributes":{"id":"p-0549","num":"0741"},"tables":{"@attributes":{"id":"TABLE-US-00039","num":"00039"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"interface IListFieldContainer"},{"entry":"{"},{"entry":"\u2003\u2003int GetItemCount(ListField listField);"},{"entry":"\u2003\u2003void GetItemDawInfo(ListField listField, int row, ItemDrawInfo"},{"entry":"itemDrawInfo);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"ListField Bounds","The parent shape is responsible for keeping track of the number of items in the list. The list field can determine the item height based on the font. With these two figures, the parent shape will know the size of the list field and must resize itself when an item is added to or removed from the list field. The list field must show all of its items because scrolling will not be provided.","The list field can therefore rely on the existing BoundsBehavior to set its size.","ListField.DoHitTest Details","The DoHitTest method needs to determine which item was hit. The row number defines the item, and this number will be used as the ShapeSubField Id that is returned in DiagramHitTestInfo. In one example, in order to determine which item was hit, the hit-test algorithm requires the following information:\n\n","ShapeElement.GetBounds","The ShapeField method GetBounds returns the bounds for the list field.","public virtual RectangleD GetBounds(ShapeElement parentshape)","ListField.GetItemHeight","The item height is calculated based on the height of the font used by the list item. The icon height is not considered in this calculation. If the icon height is greater than the list item height, the icon will be reduced to fit. If the icon height is less than the item height, then the icon is centered vertically. The ListField property DefauItFontID is used to retrieve the font. The height is in world units.","public virtual double GetItemHeight(ShapeElement parentshape)","ListField.GetItemCount","The item count needs additional help from the parent shape class. Therefore, IListFieldContainer needs a GetItemCount( ) method that this list field can use.",{"@attributes":{"id":"p-0563","num":"0758"},"tables":{"@attributes":{"id":"TABLE-US-00040","num":"00040"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public int GetItemCount( ShapeElement parentShape )"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003IListFieldContainer listFieldParent = parentShape as"]},{"entry":[{},"IListFieldContainer;"]},{"entry":[{},"\u2003\u2003return listFieldParent.GetItemCount( this );"]},{"entry":[{},"}"]},{"entry":[{},"int IListFieldContainer.GetItemCount( ListField listField ) { }"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"ListField.DoPaint Details","To draw, the DoPaint method requires the following general information from the parent shape:\n\n","IListFieldContainer.GetItemDrawInfo","To draw a single item, the DoPaint method requires the following information:\n\n","The following method is required to get this information:",{"@attributes":{"id":"p-0569","num":"0773"},"tables":{"@attributes":{"id":"TABLE-US-00041","num":"00041"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void GetItemDrawInfo(ListField listField, int row, ItemDrawInfo"]},{"entry":[{},"\u2003\u2003itemDrawInfo)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Item selected and focused states are retrieved from SelectedShapesCollection, so GetItemDrawInfo does not have to return that information. This method will be called once for each item in the list field.","StyleSet Usage","Additional Predefined Resources","In addition to the existing DesignSurfaceFonts.ShapeText, DesignSurfaceBrushes.ShapeText, and DesignSurfaceBrushes.ShapeBackground, the list field also needs:\n\n","Specifying which Style Set Resources to Use","To use custom named resources, the shape developer needs the following new ListField properties to set:",{"@attributes":{"id":"p-0576","num":"0785"},"tables":{"@attributes":{"id":"TABLE-US-00042","num":"00042"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"public DesignSurfaceResourceId DefaultFontID"},{"entry":"public DesignSurfaceResourceId DefaultTextBrushID"},{"entry":"public DesignSurfaceResourceId DefaultSelectedTextBrushID"},{"entry":"public DesignSurfaceResourceId DefaultSelectedBackgroundBrushID"},{"entry":"public DesignSurfaceResourceId DefaultInactiveSelectedTextBrushID"},{"entry":"public DesignSurfaceResourceId"},{"entry":"DefaultInactiveSelectedBackgroundBrushID"},{"entry":"public DesignSurfaceResourceId DefaultFocusPenID"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The following property already exists on ShapeField:","public DesignSurfaceResourceId DefaultBackgroundBrushID","It is to be appreciated that the system , the application program interface , the diagram , the application  and\/or the system  can be computer components as that term is defined herein.","Referring to , exemplary user interfaces in accordance with aspects of the present invention are illustrated.","Methodologies that may be implemented in accordance with the present invention are illustrated, for example, in , B and . While, for purposes of simplicity of explanation, the methodologies are shown and described as a series of blocks, it is to be understood and appreciated that the present invention is not limited by the order of the blocks, as some blocks may, in accordance with the present invention, occur in different orders and\/or concurrently with other blocks from that shown and described herein. Moreover, not all illustrated blocks may be required to implement the methodologies in accordance with the present invention.","The invention may be described in the general context of computer-executable instructions, such as program modules, executed by one or more components. Generally, program modules include routines, programs, objects, data structures, etc. that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.","In order to provide additional context for various aspects of the present invention,  and the following discussion are intended to provide a brief, general description of a suitable operating environment  in which various aspects of the present invention may be implemented. While the invention is described in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other devices, those skilled in the art will recognize that the invention can also be implemented in combination with other program modules and\/or as a combination of hardware and software. Generally, however, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular data types. The operating environment  is only one example of a suitable operating environment and is not intended to suggest any limitation as to the scope of use or functionality of the invention. Other well known computer systems, environments, and\/or configurations that may be suitable for use with the invention include but are not limited to, personal computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include the above systems or devices, and the like.","With reference to , an exemplary environment  for implementing various aspects of the invention includes a computer . The computer  includes a processing unit , a system memory , and a system bus . The system bus  couples system components including, but not limited to, the system memory  to the processing unit . The processing unit  can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .","The system bus  can be any of several types of bus structure(s) including the memory bus or memory controller, a peripheral bus or external bus, and\/or a local bus using any variety of available bus architectures including, but not limited to, an 8-bit bus, Industrial Standard Architecture (ISA), Micro-Channel Architecture (MSA), Extended ISA (EISA), Intelligent Drive Electronics (IDE), VESA Local Bus (VLB), Peripheral Component Interconnect (PCI), Universal Serial Bus (USB), Advanced Graphics Port (AGP), Personal Computer Memory Card International Association bus (PCMCIA), and Small Computer Systems Interface (SCSI).","The system memory  includes volatile memory  and nonvolatile memory . The basic input\/output system (BIOS), containing the basic routines to transfer information between elements within the computer , such as during start-up, is stored in nonvolatile memory . By way of illustration, and not limitation, nonvolatile memory  can include read only memory (ROM), programmable ROM (PROM), electrically programmable ROM (EPROM), electrically erasable ROM (EEPROM), or flash memory. Volatile memory  includes random access memory (RAM), which acts as external cache memory. By way of illustration and not limitation, RAM is available in many forms such as synchronous RAM (SRAM), dynamic RAM (DRAM), synchronous DRAM (SDRAM), double data rate SDRAM (DDR SDRAM), enhanced SDRAM (ESDRAM), Synchlink DRAM (SLDRAM), and direct Rambus RAM (DRRAM).","Computer  also includes removable\/nonremovable, volatile\/nonvolatile computer storage media.  illustrates, for example a disk storage . Disk storage  includes, but is not limited to, devices like a magnetic disk drive, floppy disk drive, tape drive, Jaz drive, Zip drive, LS-100 drive, flash memory card, or memory stick. In addition, disk storage  can include storage media separately or in combination with other storage media including, but not limited to, an optical disk drive such as a compact disk ROM device (CD-ROM), CD recordable drive (CD-R Drive), CD rewritable drive (CD-RW Drive) or a digital versatile disk ROM drive (DVD-ROM). To facilitate connection of the disk storage devices  to the system bus , a removable or non-removable interface is typically used such as interface .","It is to be appreciated that  describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system , which can be stored on disk storage , acts to control and allocate resources of the computer system . System applications  take advantage of the management of resources by operating system  through program modules  and program data  stored either in system memory  or on disk storage . It is to be appreciated that the present invention can be implemented with various operating systems or combinations of operating systems.","A user enters commands or information into the computer  through input device(s) . Input devices  include, but are not limited to, a pointing device such as a mouse, trackball, stylus, touch pad, keyboard, microphone, joystick, game pad, satellite dish, scanner, TV tuner card, digital camera, digital video camera, web camera, and the like. These and other input devices connect to the processing unit  through the system bus  via interface port(s) . Interface port(s)  include, for example, a serial port, a parallel port, a game port, and a universal serial bus (USB). Output device(s)  use some of the same type of ports as input device(s) . Thus, for example, a USB port may be used to provide input to computer , and to output information from computer  to an output device . Output adapter  is provided to illustrate that there are some output devices  like monitors, speakers, and printers among other output devices  that require special adapters. The output adapters  include, by way of illustration and not limitation, video and sound cards that provide a means of connection between the output device  and the system bus . It should be noted that other devices and\/or systems of devices provide both input and output capabilities such as remote computer(s) .","Computer  can operate in a networked environment using logical connections to one or more remote computers, such as remote computer(s) . The remote computer(s)  can be a personal computer, a server, a router, a network PC, a workstation, a microprocessor based appliance, a peer device or other common network node and the like, and typically includes many or all of the elements described relative to computer . For purposes of brevity, only a memory storage device  is illustrated with remote computer(s) . Remote computer(s)  is logically connected to computer  through a network interface  and then physically connected via communication connection . Network interface  encompasses communication networks such as local-area networks (LAN) and wide-area networks (WAN). LAN technologies include Fiber Distributed Data Interface (FDDI), Copper Distributed Data Interface (CDDI), Ethernet\/IEEE 802.3, Token Ring\/IEEE 802.5 and the like. WAN technologies include, but are not limited to, point-to-point links, circuit switching networks like Integrated Services Digital Networks (ISDN) and variations thereon, packet switching networks, and Digital Subscriber Lines (DSL).","Communication connection(s)  refers to the hardware\/software employed to connect the network interface  to the bus . While communication connection  is shown for illustrative clarity inside computer , it can also be external to computer . The hardware\/software necessary for connection to the network interface  includes, for exemplary purposes only, internal and external technologies such as, modems including regular telephone grade modems, cable modems and DSL modems, ISDN adapters, and Ethernet cards.","What has been described above includes examples of the present invention. It is, of course, not possible to describe every conceivable combination of components or methodologies for purposes of describing the present invention, but one of ordinary skill in the art may recognize that many further combinations and permutations of the present invention are possible. Accordingly, the present invention is intended to embrace all such alterations, modifications and variations that fall within the spirit and scope of the appended claims. Furthermore, to the extent that the term \u201cincludes\u201d is used in either the detailed description or the claims, such term is intended to be inclusive in a manner similar to the term \u201ccomprising\u201d as \u201ccomprising\u201d is interpreted when employed as a transitional word in a claim."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0015"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0016"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0017"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0018"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0021","num":"0019"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0022","num":"0020"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0023","num":"0021"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0024","num":"0022"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0025","num":"0023"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0026","num":"0024"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0027","num":"0025"},"figref":["FIG. 17","FIG. 16"]},{"@attributes":{"id":"p-0028","num":"0026"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0029","num":"0027"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0030","num":"0028"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0031","num":"0029"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0032","num":"0030"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0033","num":"0031"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0034","num":"0032"},"figref":"FIG. 23A"},{"@attributes":{"id":"p-0035","num":"0033"},"figref":"FIG. 24A"},{"@attributes":{"id":"p-0036","num":"0034"},"figref":["FIG. 24B","FIG. 24A"]},{"@attributes":{"id":"p-0037","num":"0035"},"figref":["FIG. 24C","FIGS. 24A and 24B"]},{"@attributes":{"id":"p-0038","num":"0036"},"figref":"FIG. 25A"},{"@attributes":{"id":"p-0039","num":"0037"},"figref":["FIG. 25B","FIG. 25A"]},{"@attributes":{"id":"p-0040","num":"0038"},"figref":["FIG. 25C","FIGS. 25A and 25B"]},{"@attributes":{"id":"p-0041","num":"0039"},"figref":["FIG. 25D","FIGS. 25A"],"b":["25","25"]},{"@attributes":{"id":"p-0042","num":"0040"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0043","num":"0041"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0044","num":"0042"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0045","num":"0043"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0046","num":"0044"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0047","num":"0045"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0048","num":"0046"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0049","num":"0047"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0050","num":"0048"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0051","num":"0049"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0052","num":"0050"},"figref":"FIG. 36A"},{"@attributes":{"id":"p-0053","num":"0051"},"figref":"FIG. 36B"},{"@attributes":{"id":"p-0054","num":"0052"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0055","num":"0053"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0056","num":"0054"},"figref":"FIG. 39"},{"@attributes":{"id":"p-0057","num":"0055"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0058","num":"0056"},"figref":"FIG. 41"},{"@attributes":{"id":"p-0059","num":"0057"},"figref":"FIG. 42"},{"@attributes":{"id":"p-0060","num":"0058"},"figref":"FIG. 43"},{"@attributes":{"id":"p-0061","num":"0059"},"figref":"FIG. 44"},{"@attributes":{"id":"p-0062","num":"0060"},"figref":"FIG. 45"},{"@attributes":{"id":"p-0063","num":"0061"},"figref":"FIG. 46"},{"@attributes":{"id":"p-0064","num":"0062"},"figref":"FIG. 47"},{"@attributes":{"id":"p-0065","num":"0063"},"figref":"FIG. 48"}]},"DETDESC":[{},{}]}
