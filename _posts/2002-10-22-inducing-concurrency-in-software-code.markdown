---
title: Inducing concurrency in software code
abstract: An Induced Multi-threading (IMT) framework may be configured to induce multi-threaded execution in software code. In one embodiment, the IMT framework may include a concurrent code generator configured to receive marked code having one or more blocks of code marked for concurrent execution. Software code initially intended for sequential execution may have been automatically marked by an automated code marker and/or marked manually to generate the marked code. The concurrent code generator may be configured to generate concurrent code from the marked code. The concurrent code may include one or more tasks configured for concurrent execution in place of the one or more marked blocks of code. In one embodiment, the IMT framework may also include a scheduler configured to schedule one or more of the tasks for multi-threaded execution.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07765532&OS=07765532&RS=07765532
owner: Oracle America, Inc.
number: 07765532
owner_city: Redwood City
owner_country: US
publication_date: 20021022
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS"],"p":["1. Field of the Invention","This invention relates to computer systems, and more particularly to concurrent execution of software code.","2. Description of the Related Art","Developers often implement distributed transactional applications as part of commercial and non-commercial business solutions for an enterprise. For example, a company may leverage use of an enterprise application that includes various databases distributed across multiple computers. The time spent to complete operations for the application, such as storing data in databases and manipulating data received from users, may be considerable due to high system loads and network latency (e.g., innumerable, simultaneous user requests and long waits for network communication). One technique to improve the efficiency of such applications may involve running independent operations in parallel. For example, a developer may modify application code to include threads so that some of the code (e.g., code that handles separate, independent operations) may execute concurrently. A thread may be a single sequential flow of control within an application program.","Developers may encounter various obstacles when transforming code that is intended to execute sequentially into code fragments (e.g., method, routine, function, subroutine) that may execute concurrently. For example, a particular platform such as Java\u2122 2 Platform, Enterprise Edition (J2EE\u2122) may impose constraints on thread usage. J2EE uses a multi-tiered distributed component application model. Application logic may be divided into components (e.g., Java\u2122 Servlets, JavaServer Pages\u2122 and Enterprise JavaBeans\u2122) according to function and the various application components may be installed on different computers depending on factors such as security, performance, etc. Although threads may be used in Java, for example, a component model such as J2EE may prevent threads from being started within the application code of a component. Thus, usage of threads as an optimization technique for an enterprise application may be limited or confined.","The typical manner of re-writing code that is intended to execute sequentially into code fragments that may execute concurrently may be burdensome for developers and counter-intuitive for readers of the code (e.g. someone maintaining the code). For example, sequential code may be split between two concurrent methods which may be contrary to what a reader of the code might expect. The relationship of logic between a caller (e.g., the code that calls a method) and the two concurrent methods may be less obvious or clear to a developer than the relationship of logic between the caller and the sequential code. Also, the methods names to be called may be very different from what would be expected or intuitive. For example, in Java, a method call may be object.start( ).","An Induced Multi-threading (IMT) framework may be configured to induce multi-threading in software code. In one embodiment, the IMT framework may include a concurrent code generator configured to receive marked code having one or more blocks of code marked for concurrent execution. Software code initially intended for sequential execution may have been automatically marked by an automated code marker and\/or marked manually to generate the marked code. In one embodiment, the one or more marked blocks of code for concurrent execution may be a portion of a program method. The concurrent code generator may be configured to generate concurrent code from the marked code. The concurrent code may include one or more tasks configured for concurrent execution in place of the one or more marked blocks of code. In one embodiment, the IMT framework may also include a scheduler configured to schedule one or more of the tasks for multi-threaded execution.","In one embodiment, the concurrent code generator may be configured to perform an analysis of the marked code to estimate performance benefits of concurrent execution of the marked blocks of code. Each of the marked blocks may be analyzed. The concurrent code generator may transform a marked block into a concurrently executable task if the analysis indicates a performance benefit is estimated for concurrent execution of the marked block. Otherwise, if the analysis indicates no performance benefit for a marked block, the marked block may not be transformed. In one embodiment, the concurrent code generator may be configured to remove concurrent execution markers in the concurrent code for one or more of the marked blocks not transformed.","In one embodiment, the automated code marker may be configured as part of the IMT framework. The automated code marker may be configured to receive the sequential code, analyze the sequential code to identify potentially concurrently executable blocks of the sequential code and insert markers into the sequential code to suggest the identified blocks for concurrent execution. Static method calls may be used to implement the markers. The scheduler may be configured to schedule one of the tasks for multi-threaded execution according to priority information included with the marker for the corresponding marked block. The scheduler may also be configured to schedule one of the tasks for multi-threaded execution according to dependency and\/or execution duration information included with the marker for the corresponding marked block.","In one embodiment, the framework may also be configured to include a thread pool manager to manage a thread pool that provides threads for multi-threaded execution of the task of the concurrent code. The scheduler may be configured to request a thread from the thread pool for each task scheduled for multi-threaded execution. In one embodiment, the framework may also be configured to include a tracking tool to log information to trace or profile execution of the tasks.","While the invention is described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that the invention is not limited to the embodiments or drawings described. It should be understood, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description or the claims. As used throughout this application, the word \u201cmay\u201d is used in a permissive sense (i.e., meaning having the potential to), rather than the mandatory sense (i.e., meaning must). Similarly, the words \u201cinclude\u201d, \u201cincluding\u201d, and \u201cincludes\u201d mean including, but not limited to.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1","b":["101","101","103","105","107","109","101","101","101","101","101"]},"Embodiments of the IMT framework  may be utilized to improve the execution time of various types of applications or software code having portions of code that from time-to-time may be blocked from execution. One embodiment of an IMT framework  may be used to induce multi-threaded execution of portions of Java 2 Enterprise Edition (J2EE) software code for an Internet-based application, for example, having portions of code that may encounter delays while waiting on completion of events. The Internet-based application may be based on a three-tier architecture and may contain code segments that may be blocked from execution until some other operation outside the scope of a host, or outside the scope of a processor within the host, completes. For example, an application component operating in a middle tier may contain code segments that may be blocked from execution until a database transaction operating in a backend tier completes. The Internet-based application may wait for communication to occur over a network. For example, network latency and\/or processing of an operation on a different host (e.g., operation involving a legacy system in the backend tier) may delay communication between application components. The application may wait for a user's input (e.g., via a Web browser) or other input from a device such as an input\/output (I\/O) device (e.g., storage device used by the legacy system). Using the IMT framework, portions of the Internet-based application, for example, may be configured to induce concurrent execution of certain blocks of code, such as tasks that are independent of other tasks that may cause delays.","An Internet-based application operating across tiers typically has considerable potential for delays. Software code developed and relying on various embodiments of the IMT framework  may involve different types of software code than an Internet-based application. For example, a software program for a client-server application may be developed and executed with the IMT framework . A simple program configured with non-blocking code segments (e.g., assigning a value to two different variables) may still benefit from concurrent execution and may be modified to specify multiple blocks of code for concurrent execution, e.g. to take advantage of a computer configured with multiple processors. Each specified block of the program may run concurrently and may each rely on a different processor of a multi-CPU computer, for example. Thus, true multi-threading may be achieved by executing each thread with a different processor and each portion of code may execute faster.","Embodiments of the IMT framework  may be used to transform initial sequential code  into running code  configured for concurrent execution. Different stages of the software code are illustrated in  as code  to code . The initial sequential code  may be for an application, for example, configured for sequential execution. The initial sequential code  may include one or more code fragments (e.g., methods, procedures, subroutines, functions) or blocks of code. As dictated by processing of sequential code, each of the code fragments of sequential code  may be configured to execute one after another instead of concurrently. The sequential code  may be developed with various types of compiled and\/or interpreted programming languages such as C++, Ada, Lisp and Java. An integrated development environment (e.g., Metrowerks CodeWarrior\u2122, Microsoft Visual C++\u00ae, Sun\u2122 ONE Studio) may be used to automatically generate some or all of the sequential code . In other cases, a developer, for example, may use various frameworks to develop sequential code . For example, several developers may use J2EE from Sun Microsystems, Core Services Framework (CSP) from Hewlett Packard, Sun\u2122 ONE Framework from Sun Microsystems, NET Framework from Microsoft or some other framework to develop sequential code .","The following describes a code snippet of an exemplary initial sequential code . The code snippet may be a portion of sequential code for an Internet-based application, for example, or sequential code for some other type of application or purpose. The exemplary sequential code may be configured to enable new users to register for continued access to the application by creating new user accounts for each of the new users. For example, a new user of the application may input a login name, password and email address via a Web browser and the login name, password and email address may be used to create a new user account for the new user. After successfully registering, the new user may continue to access the application without repeating a registration process. The code snippet of a portion (e.g., excluding exception handling and other functionality) of an exemplary initial sequential code  may be specified with Java and may be configured as follows.",{"@attributes":{"id":"p-0028","num":"0027"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class AccountManager{"]},{"entry":[{},"\u2003\u2003public void createNewAccount(String login, String passwd,"]},{"entry":[{},"\u2003\u2003String address) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ do operation on Database 1"]},{"entry":[{},"\u2003\u2003DataSource ds=ctx.lookup(\u201cpasswdDataSource\u201d);"]},{"entry":[{},"\u2003\u2003java.sql.Connection con=ds.getConnection( );"]},{"entry":[{},"\u2003\u2003java.sql.Statement stmt=con.createStatement( );"]},{"entry":[{},"\u2003\u2003java.sql.Resultset res=stmt.execute(\u201cinsert into"]},{"entry":[{},"\u2003\u2003passwdTable values(\u201c+login+\u201d,\u201d+passwd+\u201d);\u201d);"]},{"entry":[{},"\u2003\u2003stmt.close( );"]},{"entry":[{},"\u2003\u2003con.close( );"]},{"entry":[{},"\/\/ do operation on Database 2"]},{"entry":[{},"\u2003\u2003ds=ctx.lookup(\u201caddressDataSource\u201d);"]},{"entry":[{},"\u2003\u2003con=ds.getConnection( );"]},{"entry":[{},"\u2003\u2003stmt=con.createStatement( );"]},{"entry":[{},"\u2003\u2003res=stmt.execute(\u201cinsert into addressTable values"]},{"entry":[{},"\u2003\u2003(\u201c+login+\u201d,\u201d+address+\u201d);\u201d);"]},{"entry":[{},"\u2003\u2003stmt.close( );"]},{"entry":[{},"\u2003\u2003con.close( );"]},{"entry":[{},"}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["100","100","100","100"]},"One embodiment of the IMT framework  may include a marking API (application programming interface) to identify portions of software code. The marking API may be used by a developer, for example, and\/or the automated code marker  to embed one or more markers in software code such as the sequential code . After modifying software code using the marking API, the software code may be referred to as marked code . Markers within the marked code  may be used for various purposes. For example, the markers may be used to identify portions of software code that may run concurrently during execution of the software code. The markers may be used in code instrumentation. For example, the markers may demarcate specific portions of the software code so that run-time information relevant to each specific portion may be obtained during execution (e.g., profiling, tracing). In some embodiments, the markers may be used for other purposes. For example, a software program may be configured to use the markers to generate documentation for the marked code .","The markers may indicate potential points (e.g., blocks of code) within code fragments (e.g., methods, procedures, subroutines, functions) where multi-threading may be introduced. These potential points may be specified during initial development of the code and\/or may later be specified in an existing sequential version of the code. For example, a typical use may involve a developer using the IMT framework  to transform a sequential version of software code to a multi-threaded version of that same software code.","The developer, for example, may use the marking API to embed extra information for the sequential code . The developer of the sequential code  may have knowledge of expected execution behavior of the sequential code . For example, the developer may wish to reflect which portions of the sequential code  are potential points for concurrent execution based on the developer's knowledge that one portion of the sequential code  executes independent from another portion of the sequential code . The developer may also use the automated code marker  to embed extra information for the sequential code . In one embodiment, the automated code marker  may be configured to perform an analysis of the sequential code  and embed markers in the sequential code based on the results of the analysis. For example, the automated code marker  may be configured to parse the sequential code , evaluate dependencies among portions of the code to identify points for potential concurrent execution and then insert markers at those points. Many variations of an analysis may be performed by the automated code marker  to identify potential points for concurrent execution.","In both scenarios (e.g., developer manually marks code or uses the automated code marker ), the markers may be used and\/or ignored by the IMT framework  since the markers represent potential points for concurrent execution. Thus, the markers may be removed and\/or disregarded by the IMT framework  at any point after specification in marked code  to execution of the code. The developer or automated code marker  may simply embed the markers, and thus the extra information, without making assumptions about semantic behavior (e.g., properties of a run-time object) of the sequential code  at run-time since the markers may be used and\/or disregarded.","The marking API may be used within the scope of a code fragment (e.g., methods, procedures, subroutines, functions) or block of code. In one embodiment, a method may be the unit of software code in which the markers are specified and used to potentially induce multi-threading. In other embodiments, portions of a method or sub-methods may be marked for concurrency. One or more blocks of code within one or more methods may be marked for potential concurrent execution. The same markers across different methods may be different. For example, a developer may specify blocks of code within two different methods with the marking API and the specified blocks of code may remain separate for each of the different methods. In one embodiment, the IMT framework  may implicitly assume a method is a block of code. The portions of code specified for concurrent execution may be less than an entire method (e.g., implicit block) of the code.","In one embodiment, the marking API may assign additional meaning to pre-existing constructs of a programming language to serve as a marker to identify blocks of code for potential concurrentization. For example, markers may be existing programming language statements such as C statements, Lisp statements and FORTRAN statements. In one embodiment, static method calls of a programming language may be used for the marking API. For example, in an object-oriented language such as Java, C++ and Smalltalk, the marking API may include static methods or data members of a class. A class may include pre-existing constructs of the programming language that belong to a class instead of to a given instance of the class. These constructs may be called static or class members. The constructs may be assigned additional meaning so that software code that includes the markers may be translated (e.g., compiled or interpreted) in the same manner as software code that excludes the markers (e.g., sequential code ). Thus, in the absence of an IMT framework , marked code  may include pre-existing constructs of a programming language already recognized by an existing compiler, for example, for the programming language used. Thus, marked code may remain compatible with a programming language and traditionally executable even in the absence of IMT framework .","In one embodiment, static methods of a Java class may be used for the marking API. The following is an exemplary class and methods of the class that may be used for marking blocks of code in Java, for example. Each method may be used to specify potential points (e.g., markers around blocks of code) for concurrent execution.",{"@attributes":{"id":"p-0036","num":"0035"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"package com.xxx.codemarker;"]},{"entry":[{},"public class Marker{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public static void block( ) {}"]},{"entry":[{},"public static void endBlock( ) {}"]},{"entry":[{},"public static void block(String name) {}"]},{"entry":[{},"public static void block(String name, int priority);"]},{"entry":[{},"public static void block(String name, String [ ] dependencies);"]},{"entry":[{},"public static void block(String name, int priority, String [ ]"]},{"entry":[{},"dependencies);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":"100"},"In one embodiment, the block of code may be preceded by an opening statement (e.g., curly brace) and succeeded by a closing statement (e.g., curly brace). The opening and closing statement may further identify the beginning and ending programming statements between, for example, a block and endBlock call. In other embodiments, although the opening and closing statements may improve the readability of the software code, the opening and closing statements may be excluded. In one embodiment, variable scope within a block of code may be limited to the block of code to prevent variables from being accessed across two blocks of code that may potentially execute concurrently. Arguments and local variables (if any) of the specified block of code may be used as read-only data, in which case additional optimization may be done.","A block of code may be qualified with extra information that specifies hints for execution of the block of code in relation to another block of code. As shown in the above exemplary Marker class, the Marker class may include several different block methods for specifying additional arguments. In order to mark a block of code, one of the block methods may be used to mark the beginning of a block of code and an endBlock method may be used to mark the end of the block of code. A block of code may be qualified with extra information by using an overloaded block method. For example, as shown in the above exemplary Marker class, each of the blocks of code may be assigned a specific name (e.g., String). The extra information may be used and\/or disregarded during scheduling of the potential blocks of code for concurrent execution.","In one embodiment, the following guidelines describe the selection and usage of the block methods included in a class such as the exemplary class. If one block of code within a method is specified as a potential point for concurrent execution, then the block method without arguments (e.g., block ( )) may be used to indicate the block of code. For example, a developer may know that a specific portion of a method may execute independently of the remaining portion of the method, and the developer may specify the specific portion of code as a potential point for concurrent execution with the block( ) call, or as the result of a code analysis an automated code marker tool  may insert the block( ) at a point the tool identified for concurrentization. A method may include the one block of code that may execute concurrently with the remaining portion of the method. The opening statement of such block call may not include a specific block name or an indication of dependencies. Likewise, when the block methods are simply used to segregate blocks of code as potential points for concurrent execution, then the block method without arguments (e.g., block ( )) may be used to indicate the block of code. For example, in one embodiment, an automated code marker  may choose to use the block( ) call when the code marker  determines that qualifying a block of code with extra information (e.g., a specific name) is not necessary based on results of an analysis.","In one embodiment, a block opening statement may indicate a priority for execution of a concurrent block. Each of the blocks of code may be assigned a priority. The priority may be a thread priority in which the programming language statements of the blocks of code may be executed. Although the blocks may be marked for concurrent execution, only a limited number of threads may be available for concurrentization. Thus, a developer may include priority information with the markers to indicate certain blocks of code to be started ahead of others.","In one embodiment, each of the blocks of code may be assigned one or more dependencies on another block of code. The dependencies may indicate other blocks of code that may complete execution before a given block of code begins execution. Complex dependencies between blocks of code may be specified. In one embodiment, a block method may be used to specify dependencies over blocks of code that may be included in a later portion of a method as long as a cycle is avoided.","In one embodiment, an estimated or measured running duration (e.g., weight) of a block may be specified in the marked code. A developer, for example, may know an approximate duration for which a block of code may prevent execution of other code, so the developer may assign a weight accordingly to that block of code. In one embodiment, similar to priorities and dependencies, the weight may be used during scheduling of the potential blocks of code for concurrent execution. For example, blocks of code marked with longer execution times may be scheduled ahead of blocks with shorter execution times with a goal of the blocks all completing execution at approximately the same time.","Referring back to the code snippet of the exemplary sequential code , after modification and marking according to the marking API, the code snippet may be configured as follows.",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"import com.xxx.codemarker.Marker;"},{"entry":"class AccountManager{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public void createNewAccount(String login, String passwd, String"]},{"entry":[{},"address){"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Marker.block(\u201cupdate1\u201d);"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\/\/do operation on Database 1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DataSource ds=ctx.lookup(\u201cpasswdDataSource\u201d);"]},{"entry":[{},"java.sql.Connection con=ds.getConnection( );"]},{"entry":[{},"java.sql.Statement stmt=con.createStatement( );"]},{"entry":[{},"java.sql.Resultset res=stmt.execute(\u201cinsert into"]},{"entry":[{},"passwdTable values(\u201c+login+\u201d,\u201d+passwd+\u201d);\u201d);"]},{"entry":[{},"stmt.close( );"]},{"entry":[{},"con.close( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"Marker.endBlock( );"]},{"entry":[{},"Marker.block(\u201cupdate2\u201d);"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\/\/do operation on Database 2"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DataSource ds=ctx.lookup(\u201caddressDataSource\u201d);"]},{"entry":[{},"java.sql.Connection con=ds.getConnection( );"]},{"entry":[{},"java.sql.Statement stmt=con.createStatement( );"]},{"entry":[{},"java.sql.Resultset res=stmt.execute(\u201cinsert into"]},{"entry":[{},"addressTable values(\u201c+login+\u201d,\u201d+address+\u201d);\u201d);"]},{"entry":[{},"stmt.close( );"]},{"entry":[{},"con.close( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"Marker.endBlock( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":["100","103","1","2"]},"To further illustrate specification of dependencies between blocks of code using the marking API, the same code snippet may be manipulated to run the second block only when the first block is complete. The code snippet of an exemplary sequential code , after modification with the marking API, may be configured as follows.",{"@attributes":{"id":"p-0046","num":"0045"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"import com.xxx.codemarker.Marker;"]},{"entry":[{},"class AccountManager {"]},{"entry":[{},"public void createNewAccount (String login, String passwd, String"]},{"entry":[{},"address) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Marker.block(\u201cupdate1\u201d);"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\/\/do operation on Database 1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DataSource ds=ctx.lookup(\u201cpasswdDataSource\u201d);"]},{"entry":[{},"java.sql.Connection con=ds.getConnection( );"]},{"entry":[{},"java.sql.Statement stmt=con.createStatement( );"]},{"entry":[{},"java.sql.Resultset res=stmt.execute(\u201cinsert into"]},{"entry":[{},"passwdTable values(\u201c+login+\u201d,\u201d+passwd+\u201d);\u201d);"]},{"entry":[{},"stmt.close( );"]},{"entry":[{},"con.close( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"Marker.endBlock( );"]},{"entry":[{},"Marker.block(\u201cupdate2\u201d, {\u201cupdate1\u201d});"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\/\/do operation on Database 2"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DataSource ds=ctx.lookup(\u201caddressDataSource\u201d);"]},{"entry":[{},"java.sql.Connection con=ds.getConnection( );"]},{"entry":[{},"java.sql.Statement stmt=con.createStatement( );"]},{"entry":[{},"java.sql.Resultset res=stmt.execute(\u201cinsert into"]},{"entry":[{},"addressTable values(\u201c+login+\u201d,\u201d+address+\u201d);\u201d);"]},{"entry":[{},"stmt.close( );"]},{"entry":[{},"con.close( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"Marker.endBlock( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Use of static method calls to mark blocks of code for potential concurrent execution may be more intuitive for a developer than other forms of marking. For example, a developer may expect the execution behavior of an application to disregard comments as markers but expect static method calls to change the execution behavior of the application. In the absence of an IMT framework , the markers may be disregarded as empty method calls. For example, the marked code  may be fully compatible with an existing programming language in the absence of an IMT framework  that can make use of the markers. As an additional example, in the absence of the IMT framework, an optimizing Java compiler and virtual machine (VM) may remove the static method calls as empty method calls.","Use of the markers may help to hide implementation details, for example. A developer may use the marking API to identify potential points for concurrent execution, but the implementation details may be handled by the IMT framework . The marking API may enable a developer and\/or the automated code marker  to mark the code fragments with minimal modification to the sequential code . In one embodiment, the markers may be mark-up language constructs such as eXtensible markup language (XML) and\/or hypertext markup language (HTML) statements. In another embodiment, the markers may be programming language comments. For example, comments may be added to the sequential code  and used as markers to specify potential points for concurrent execution. In some embodiments, the markers may be entirely new constructs (e.g., data structure, programming-statement) that are unique to a programming language. For example, the markers may be symbols recognizable by a programming language that indicate potential points for concurrent execution.","In one embodiment, the IMT framework includes concurrent code generator . The concurrent code generator  may parse and modify the marked code  to generate concurrent code . In one embodiment, the concurrent code generator  may replace markers in the marked code  with other programming statements. Thus, the concurrent code generator  may be configured to transform marked code  into concurrent code  that induces concurrent execution of the blocks of code as initially indicated by the markers. The concurrent code  may include one or more tasks configured for concurrent execution in place of the one or more marked blocks of code. The concurrent code  may include references to shared programming language resources (e.g., dynamically linked libraries, shared objects, shared libraries, built-in code) that may provide concurrency functionality. For example, the concurrent code  may reference concurrency support code  configured to schedule each task concurrently.","In one embodiment, the concurrent code generator  may be configured to generate the concurrent code  in response to an indicated option from one or more compilers, interpreters and\/or parsers, for example. Concurrent code generator  may be included with a compiler or pre-processor that includes an option, for example, that when specified by a user, indicates that concurrent code  should be generated for the specified marked code . In one embodiment, a separate tool may be configured to receive the marked code  and generate the concurrent code  from the marked code . For example, the IMT framework  may be configured to include a tool to generate the concurrent code  from the marked code .","In one embodiment, the concurrent code generator  may be configured to perform an analysis of the marked code  to validate different rules and\/or handle different conditions before transforming the marked code  into concurrent code . The concurrent code generator may analyze the marked code and determine for each marked block of code whether or not that block should be transformed for concurrentization. For example, one block spanning over an entire method that cannot be executed in parallel with any other code would be ignored during the transformation process to reduce the overhead of scheduling the one block that is essentially still sequential. In one embodiment, even if the method includes a portion of code outside of the one block, that portion of code may be transformed only if the portion of code can execute in parallel with the one block.","The following describes other rules and\/or conditions for transformation of marked code  into concurrent code , according to various embodiments. The following rules and conditions are exemplary. Many other rules and\/or conditions may be handled by various embodiments of the IMT framework . In one embodiment, marked code  may include blocks of code within loops (e.g., for loops, while loops, do-while loops, etc.). For example, in marked code , a loop may include an index to count iterations of the loop and the loop may include one or more blocks of code marked for concurrent execution. In one embodiment, if the blocks of code (marked and unmarked) use the loop index as a read-only variable, for example, the concurrent code generator  may duplicate one or more independent loops for each of the one or more concurrent blocks. Each of the duplicated one or more loops may include one of the one or more concurrent blocks to help parallel loops execute more efficiently, for example.","To further illustrate handling of independent, blocks of code within a loop, a code snippet of an exemplary marked code  that includes a loop may be configured as follows.",{"@attributes":{"id":"p-0054","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"for (int i=0;i<1000;i++) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Marker.Block( ) {"]},{"entry":[{},"\u2003\u2003a[i]=i;"]},{"entry":[{},"}"]},{"entry":[{},"Marker.endBlock( );"]},{"entry":[{},"Marker.Block( ) {"]},{"entry":[{},"\u2003\u2003b[i]=i*i;"]},{"entry":[{},"}"]},{"entry":[{},"Marker.endBlock( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In one embodiment, if an endBlock call is missing, nested concurrent blocks may be implicitly assigned. In one embodiment, for example, if an endBlock( ) call is missing from a concurrent block and a new block call is specified, the concurrent block may be assumed to be an enclosing concurrent block and thus, as directed, the new block call would be nested.","In one embodiment, concurrent code generator  may generate a task for each concurrent block of marked code . Tasks may be functions, methods or other portions of code. A task may require access to data (e.g., arguments) originally passed to a method of marked code  from which the task is generated. Concurrent code generator  may generate from the data one or more instances of variables accessible to the task. In one embodiment, a task may modify local copies of the variables instead of using the variables as read-only. If tasks do modify the variables, for example, one embodiment of the concurrent code generator  may assume the variables will be modified by the task for further use within the scope of the task.","In one embodiment, concurrent code generator  may be configured to generate concurrent code  based on a naming convention. For example, each concurrent block ml (corresponding to a task) may be named \u201cTm\u201d to identify the task within the block. Each task may be named Tm_<num>, where <num> indicates a serial number of the block. Thus, tasks for ml, for example, may be named Tm_, Tm_, etc. Data (e.g., arguments) passed to each block may be named am_<num>, where <num> indicates the serial number of the data. Other naming conventions, for example, variables used to store exceptions (e.g., a run-time error condition) initiated during execution, may be defined and used by the IMT framework  during transformation of marked code  to concurrent code .","In one embodiment, concurrent code generator  may include synchronization points (e.g., code that induces a thread to enter a wait state) in concurrent code . Concurrent code generator  may include a synchronization point to allow a method and\/or code corresponding to a concurrent block to wait for completion of another task (e.g., another method, another concurrent block, a resource becoming available, etc.).","In one embodiment, concurrent code generator  may generate programming language code in concurrent code  to reference a scheduler in concurrency support code  to schedule each task of concurrent code . The scheduling may be based on information included in marked code . For example, concurrent code generator  may parse a concurrent block's opening statement of marked code  (e.g., as indicated with marking API). The opening statement may include a priority, weight and\/or dependencies on one or more other concurrent blocks for the concurrent block. Concurrent code generator  may generate code in concurrent code  to schedule the dependencies for execution. Concurrent code generator  may generate code in concurrent code  to schedule concurrent execution for each task based on specified priorities and\/or weights. For example, a task (as indicated by the marked code ) may be scheduled to begin execution before another task.","Referring back to the code snippet of the exemplary marked code , the following describes and shows exemplary concurrent code  generated from the exemplary marked code . As described above, the concurrent code  may include references to concurrency support code  that may provide concurrency functionality. For example, the concurrent code  may include references to a scheduler configured to schedule each task concurrently. In one embodiment, one or more shared libraries may be configured to include a Task class and Scheduler class. For example, each concurrent block may be transformed into a derived class (e.g., inherited from) of Task. Each thread scheduled to execute the concurrent block may begin by executing a method class (e.g., method task of Task class is overridden by method task of derived class) associated with the derived class. The Scheduler class may be configured to schedule the task for multi-threaded execution. An exemplary Task class may be configured as the following:",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"class Task{"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"private final int NOT_BEGUN =1;"]},{"entry":[{},"private final int BEGUN=2;"]},{"entry":[{},"private final int DONE=3;"]},{"entry":[{},"private int m_status="]},{"entry":[{},"public Exception m_ex=null;"]},{"entry":[{},"public void task( ){}"]},{"entry":[{},"public Exception waitForTask( ){"]},{"entry":[{},"\u2003\/\/if state is DONE just return"]},{"entry":[{},"\u2003\/\/if state is NOT_BEGUN keep sleeping and waiting for the"]},{"entry":[{},"\u2003task to begin"]},{"entry":[{},"\u2003\/\/If state is BEGUN"]},{"entry":[{},"\u2003synchronized(this){"]},{"entry":[{},"\u2003\u2003wait( );"]},{"entry":[{},"\u2003\u2003return m_ex;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The code snippet for an exemplary Scheduler class may be configured as the following:",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class Scheduler{"]},{"entry":[{},"\u2003\u2003private static int m_count=0;"]},{"entry":[{},"\u2003\u2003private static int getNodeSNo( ){return ++m_count;}"]},{"entry":[{},"\u2003\u2003public static void schedule(Task t){"]},{"entry":[{},"\u2003\u2003\u2003int sNo=getNodeSNo( );"]},{"entry":[{},"\u2003\u2003\u2003\/\/select a thread and attach to it the info about the"]},{"entry":[{},"\u2003\u2003\u2003node that began it"]},{"entry":[{},"\u2003\u2003\u2003\/\/command thread to do the task,"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003public static Exception wait(Task t){"]},{"entry":[{},"\u2003\u2003\u2003return t.waitForTask( );"]},{"entry":[{},"\u2003\u2003\u2003\/\/attach info to the thread about latest node info"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003..."]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"After transformation of the exemplary marked code  to exemplary concurrent code , the code snippet for the exemplary concurrent code , including references to concurrency support , may be configured as the following:",{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"import com.xxx.concurrency.*;"},{"entry":"class AccountManager{"},{"entry":"\u2003String acreateNewAccount_0=null;"},{"entry":"\u2003String acreateNewAccount_1=null;"},{"entry":"\u2003String acreateNewAccount_2=null;"},{"entry":"\u2003class TcreateNewAccount_update1_0 extends Task{"},{"entry":"\u2003\u2003public void synchronized task( ){"},{"entry":"\u2003\u2003\u2003try{"},{"entry":"\u2003\u2003\u2003\u2003\/\/do operation on Database 1"},{"entry":"\u2003\u2003\u2003DataSource ds=ctx.lookup(\u201cpasswdDataSource\u201d);"},{"entry":"\u2003\u2003\u2003java.sql.Connection con=ds.getConnection( );"},{"entry":"\u2003\u2003\u2003java.sql.Statement stmt=con.createStatement( );"},{"entry":"\u2003\u2003\u2003java.sql.Resultset res=stmt.execute(\u201cinsert into passwdTable"},{"entry":"\u2003\u2003\u2003values(\u201c+login+\u201d,\u201c+passwd+\u201d);\u201d);"},{"entry":"\u2003\u2003\u2003stmt.close( );"},{"entry":"\u2003\u2003\u2003con.close( );"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003catch(java.lang.Exception ex){"},{"entry":"\u2003\u2003\u2003m_ex=ex;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003notifyall( );"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"class TcreateNewAccount_update2_1 extends Task{"},{"entry":"\u2003public void task( ){"},{"entry":"\u2003\u2003try{"},{"entry":"\u2003\u2003\u2003\/\/do operation on Database 2"},{"entry":"\u2003\u2003DataSource ds=ctx.lookup(\u201caddressDataSource\u201d);"},{"entry":"\u2003\u2003java.sql.Connection con=ds.getConnection( );"},{"entry":"\u2003\u2003java.sql.Statement stmt=con.createStatement( );"},{"entry":"\u2003\u2003java.sql.Resultset res=stmt.execute(\u201cinsert into addressTable"},{"entry":"\u2003\u2003values(\u201c+login+\u201d,\u201c+address+\u201d);\u201d);"},{"entry":"\u2003\u2003stmt.close( );"},{"entry":"\u2003\u2003con.close( );"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2002catch(java.lang.Exception ex){"},{"entry":"\u2003\u2003\u2002m_ex=ex;"},{"entry":"\u2003\u2003\u2002}"},{"entry":"\u2003\u2003\u2002notifyall( );"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"private TcreateNewAccount_update1_0"},{"entry":"tcreateNewAccount_update1_0="},{"entry":"new TcreateNewAccount_update1_0( );"},{"entry":"private TcreateNewAccount_update2_1"},{"entry":"tcreateNewAccount_update2_1="},{"entry":"new TcreateNewAccount_update2_1( );"},{"entry":"public void createNewAccount(String login, String passwd,"},{"entry":"String address){"},{"entry":"\u2003acreateNewAccount_0=login;"},{"entry":"\u2003acreateNewAccount_1 =passwd;"},{"entry":"\u2003acreateNewAccount_2=address;"},{"entry":"\u2003Scheduler.schedule(tcreateNewAccount_update1_0);"},{"entry":"\u2003Scheduler.schedule(tcreateNewAccount_update2_1);"},{"entry":"\u2003java.lang.Exception ex ="},{"entry":"\u2003Scheduler.wait(tcreateNewAccount_update1_0);"},{"entry":"\u2003if(ex!=null) throw ex;"},{"entry":"\u2003ex = Scheduler.wait(tcreateNewAccount_update2_1);"},{"entry":"\u2003if(ex!=null) throw ex;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":["105","102","107","104","102","105","105","104","104","102","104","104"]},"The IMT framework  may reference other functionality of concurrency support . For example, one embodiment of an IMT framework  may be configured to use a Thread class of concurrency support  to implement a thread pool . In one embodiment, concurrent code  may generate code to implement specialized threads (e.g., threads of the thread pool  that may be managed by a thread manager of the IMT framework  at run-time) that may require initialization before executing an arbitrary task. A registration function, or hook, may be required so that a thread of a thread pool  may signal (e.g., to a scheduler of concurrency support ) that the thread is initialized and ready to be assigned a task to execute. In one embodiment, a Scheduler class (e.g., Scheduter.submitThread, a member of the Scheduler class described above) may provide the registration function to be used by the threads. The code snippet for an exemplary Thread class may be configured as follows.",{"@attributes":{"id":"p-0067","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"package com.xxx.concurrency;"},{"entry":"class Scheduler {"},{"entry":"\u2003\u2003\u2003\u2003..."},{"entry":"\u2003\u2003public static void submitThread( );"},{"entry":"\u2003\u2003public static void submitThread(ThreadEventHandler eHandler);"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0068","num":"0067"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"package com.xxx.concurrency;"]},{"entry":[{},"interface ThreadEventHandler {"]},{"entry":[{},"\u2003\u2003\u2003\u2003void preTask(Thread parentThread);"]},{"entry":[{},"\u2003\u2003\u2003\u2003void postTask( );"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Concurrent code  may include software code that may later be translated into machine code by a compiler or interpreter, for example, for the programming language. Concurrent code  may include references to concurrency support code  that may provide concurrency functionality for the programming language. Concurrent code  may be linked to the concurrency support code  to generate running code .","Concurrency support  may include a scheduler, thread manager and any other functionality to support multi-threaded execution. In one embodiment, a scheduler may be configured to schedule the tasks for multi-threaded execution. Threads of the thread pool  may be initialized so that the threads are ready to execute tasks. The threads, in one embodiment, may be submitted to the scheduler by calling, for example, registration functions (e.g., submitThread( )).","One embodiment of the IMT framework  may be configured to include a tracking tool to log information for tracing and\/or profiling, for example, of concurrent tasks during execution of the running code. The running code  may be instrumented for logging in response to an indicated compiler option, for example. The instrumented running code  may be configured to collect and output (e.g., via the tracking tool) code coverage information for statements and paths, for example, of each concurrent task during execution. A log file may be created that includes profile information (e.g., task execution counts, control flow graph, time taken for resources referenced such as memory, network bandwidth, permanent storage accesses) for a particular execution, for example. Various external tools to the IMT framework  may be configured to access the logged information tracked during execution of running code .","The following guidelines describe handling of different abnormal conditions, if encountered, during execution of the running code , according to one embodiment. The following guidelines are exemplary. Many other conditions may be handled by various embodiments of the IMT framework . Various conditions occurring during execution of the running code may be handled so that the external behavior of the multi-threaded running code is the same as the sequential code from which the running code was derived. For example, in the case where multiple exceptions (e.g., run-time error conditions) are initiated by more than one concurrent block in a task, one of the exceptions may be selected for return to a caller. In one embodiment, an exception for the concurrent block that was started the earliest may be returned and other exceptions may be ignored. Selecting one exception may help insulate the caller (e.g., code that calls a method) of the method from the concurrency of the blocks.","The concurrent blocks may include conditional returns. Thus, returning from each concurrent block may mean returning from the concurrent block instead of the method. In one embodiment, one of the multiple return values may be selected from the multiple concurrent blocks. For example, a method may return the return value from a concurrent block that finishes execution last among the method's concurrent blocks. There may be other guidelines for determining a single return value from a plurality of return statements within a plurality of concurrent blocks of a single method. For example, a method may return the return value from a concurrent block that finishes execution first among the method's concurrent blocks.","In one embodiment, potential concurrent blocks may be nested within other potential concurrent blocks. Thus, one embodiment of an IMT framework  may require execution of nested concurrent blocks within an enclosing concurrent block to finish before execution of the enclosing concurrent block may be deemed complete. In one embodiment, a method may be implicitly assumed to be a block of code. Thus, execution of concurrent blocks within a method of the running code  may need to finish in order for execution of the method to be deemed complete (e.g., for the method to exit).",{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 2","b":"200"},"In one embodiment, the sequential code may be analyzed to identify blocks of code for potential concurrent execution, as indicated in . The blocks of code may be portions of code within the scope of a code fragment (e.g., methods, procedures, subroutines, functions). In one embodiment, a program method may be the unit of software code analyzed to identify blocks of code for potential concurrent execution. One or more blocks of code within one or more methods may be analyzed for potential concurrent execution.","Analyzing the sequential code may be performed by a developer with knowledge of the execution behavior of the sequential code or by an automated code marker, for example. For example, the developer may know that one portion of the sequential code executes completely independent from another portion of the sequential code. In one embodiment, analyzing the sequential code may include parsing the sequential code and evaluating dependencies among portions of the code to identify points for potential concurrent execution. Many variations of an analysis may be performed to identify potential points for concurrent execution.","One embodiment may include a marking API to specify one or more blocks of code that may run concurrently during execution. One or more markers may be inserted in the sequential code to suggest the identified blocks for concurrent execution, as indicated in . In other embodiments, markers within the marked code may be used for other purposes. For example, the markers may be used to generate documentation. After insertion of the markers into the sequential code, the sequential code may be referred to as marked code. The markers may indicate potential points (e.g., blocks of code) within code fragments (e.g., methods, procedures, subroutines, functions) where multi-threading should be introduced. Since the markers represent potential points for concurrent execution, the markers may be removed and\/or disregarded at any point after specification to execution of the code. The markers may simply be inserted without making assumptions about semantic behavior (e.g., properties of a run-time object) of the sequential code at run-time since the markers may be used and\/or disregarded.","In one embodiment, the markers may assign additional meaning to pre-existing constructs of a programming language. For example, markers may be existing programming language statements such as C statements, Lisp statements and FORTRAN statements. In one embodiment, static method calls of a programming language may be used for the marking API. For example, in an object-oriented language such as Java, C++ and Smalltalk, the marking API may include the methods and members of a static class (e.g., procedures within an object-oriented class as a category of objects, and associated data types and functions for each of the procedures). The constructs may be assigned additional meaning so that software code that includes the markers may be translated (e.g., compiled or interpreted) in the same manner as software code that excludes the markers (e.g., sequential code).","While inserting the markers, a block of code may be qualified with extra information that specifies hints for execution of the block of code in relation to another block of code. In one embodiment, a block method may be overloaded (e.g., one of many different methods) with other block methods. A block of code may be qualified with extra information by using an overloaded block method. For example, each of the blocks of code may be assigned a specific name (e.g., String), a priority, dependencies and\/or an execution duration (e.g., weight).",{"@attributes":{"id":"p-0081","num":"0080"},"figref":["FIG. 3","FIG. 2"],"b":["300","310"]},"The concurrent code may include one or more tasks configured for concurrent execution in place of the one or more marked blocks of code. The concurrent code may include references to shared programming language resources (e.g., dynamically linked libraries, shared objects, shared libraries, built-in code) that may provide concurrency functionality for the programming language. In one embodiment, the concurrent code may be generated in response to an indicated option from one or more compilers, interpreters and\/or parsers, for example.","In one embodiment, an analysis of the marked code may be performed to validate different rules and\/or handle different conditions before transforming the marked code into concurrent code. For example, one block spanning over an entire method would be ignored during the transformation process to reduce the overhead of scheduling the one block that is essentially still sequential. In one embodiment, the concurrent code may be generated based on a naming convention. In one embodiment, synchronization points (e.g., code that induces a thread to enter a wait state) may be included in the concurrent code.","In one embodiment, programming language code may be included in the concurrent code to reference a scheduler to schedule each task of concurrent code. The scheduling, as indicated in , may be based on information included in marked code. For example, an opening block statement of a concurrent block in the concurrent code may include a priority and dependencies on one or more other concurrent blocks. For example, a task (as indicated by the marked code) may be scheduled to begin execution before another task.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":["FIG. 4","FIG. 2"],"b":"400"},"From the marked code, concurrent code may be generated, as indicated in . The concurrent code may include one or more tasks scheduled for potential concurrent execution, as described with . The concurrent code may include references to shared programming language resources that may provide concurrency functionality for the programming language. For example, the concurrent code may include references to code of one or more shared libraries configured to schedule each task concurrently.","The concurrent code may be linked to concurrency support code to generate running code, as indicated in . For example, the concurrency support code may include shared libraries for scheduling the concurrent blocks of code for concurrent execution. The developer may then execute the running code that includes task(s) with concurrent processing, as indicated in . The one or more tasks may have been identified as tasks in the concurrent code and were scheduled for concurrent execution.","In one embodiment, the concurrent code generator may be configured to perform an analysis of marked code to estimate performance benefits of concurrent execution before transforming the marked code into concurrent code. The markers, as described with , may be used and\/or ignored during the analysis since the markers represent potential points for concurrent execution. In one embodiment, the results of the analysis may be used to transform the marked code into concurrent code.  illustrates a connected acyclic directed graph representation  of the marked code generated during an analysis of the marked code. In one embodiment, the analysis may represent the marked code as vertices (e.g., nodes ) and edges (e.g., lines ). In one embodiment, each vertex may represent a block of code that may be scheduled for execution. Each line may correspond to a task which may be the marked unit of code scheduled for execution by the IMT framework . In one embodiment, the IMT framework  may be configured to output an actual graph representation (e.g., printout of the graph).","During the analysis, in one embodiment, each vertex may represent the beginning or the end of a block of code. An edge may begin at one vertex and end at another vertex. Two vertices connected by an edge may be said to be adjacent. In one embodiment, a path of the represented graph may include a sequence of adjacent vertices. Referring back to the exemplary concurrent code , each Scheduler.schedule and Scheduler.wait call may be represented in a graph as a vertex . An edge may begin at a vertex A representing a Scheduler.schedule call. The edge may end at a vertex B representing a Scheduler.wait call.","The properties of a vertex may apply to edges emanating from the vertex. For example, a vertex may be associated with properties that may include possible scheduling priorities, possible exceptions and possible return values for corresponding blocks of code (as represented by edges to the vertex). In one embodiment, the analysis may use edges and properties of the vertices to compute a running length or cost for each path. For example, the analysis may traverse data representing the graph to calculate the number of programming statements of each vertex and each edge between a beginning vertex and an ending vertex for each block. During the analysis, modifications to the marked code may be suggested by determining which marked blocks of code would meet a performance benefit threshold if executed concurrently. For example, the performance benefit threshold may be determined by comparing the estimated execution duration of each marked block to an overhead for scheduling the concurrent blocks.","In one embodiment, as described with the marking API, a developer may specify a running duration (e.g., weight) of each block in the marked code. The analysis may include the weight as a property of each vertex. The analysis may traverse data representing the graph to determine the running duration of each path by totaling the running durations of vertices in the path. The analysis may suggest a path that may have a lower running cost than one or more other paths represented by the graph. In one embodiment, the analysis may suggest that blocks be scheduled to begin execution in order of decreasing running duration. For example, a block with a longest running duration may be scheduled to begin execution first. In other embodiments, suggestions may be based on other scheduling schemes. In one embodiment, the concurrent code generator may modify the code to implement the suggestions from the analysis. In one embodiment, each block of code may be analyzed to determine if the block of code meets the performance benefit threshold. If the concurrent block meets the performance benefit threshold, the block of code may be transformed into a task by the concurrent code generator.","Exceptions thrown by blocks of the concurrent code may be modeled on a graph such as the graph of . If an exception is thrown, one or more executing concurrent blocks may be interrupted. The block interruption may be represented in the graph by a truncated edge. In one embodiment, the graph may take dependencies between blocks in concurrent code into account. If an exception is thrown, for example, and an edge is truncated as a result of the thrown exception, vertices and edges representing blocks dependent on an interrupted block may be modified and\/or removed. In one embodiment, the edges may represent control flow. For example, if a block is dependent on another block, an edge of the other block may go from the other block to the dependent block. If other blocks do not depend on a block, an edge included in the block's graph representation may end at the vertex representing the end of a method including the block.","In one embodiment, the analysis may also be used to identify potential run-time problems with marked blocks of code. In one embodiment, the data representing the graph may indicate cycles. A cycle may be a path in which the first vertex is also the last vertex. In one embodiment, the concurrent code generator may not determine a schedule for beginning execution of the blocks represented in the cycle. The concurrent code generator may signal an error condition. In one embodiment, the concurrent code generator may automatically modify the concurrent code to remove the cycle.","The specified blocks of code may be scheduled for multi-threaded execution based on the results of the analysis. Although, in one embodiment, the markers have been replaced in the concurrent code, the IMT framework may still be configured to identify the concurrent blocks. For example, variables used in the concurrent code may indicate the concurrent blocks. In one embodiment, variables may be passed to the scheduler when the thread is initiated to execute. The identified blocks of code may be used and\/or ignored during the analysis since the concurrent blocks represent potential points for concurrent execution.",{"@attributes":{"id":"p-0095","num":"0094"},"figref":["FIG. 6","FIG. 2"],"b":["600","610"]},"A connected acyclic directed graph representation of the marked code, as described with , may be used during an analysis of the marked code. The marked code may be modified to implement the suggestions from the analysis. In one embodiment, each block of code may be analyzed to determine if the block of code meets the performance benefit threshold, as indicated in . If the concurrent block meets the performance benefit threshold, the block of code may be transformed into a task, as indicated in . Otherwise, the concurrent block may not be transformed, as indicated in . The analysis process may continue until all of the concurrent blocks have been analyzed, as indicated in .","The specified blocks of code may be scheduled for multi-threaded execution based on the results of the analysis, as indicated in . In one embodiment, the analysis may suggest that blocks be scheduled to begin execution in order of decreasing running time. For example, a block with a longest running time may be scheduled to begin execution first. In other embodiments, suggestions may be based on other scheduling schemes.","One embodiment of the IMT framework may be configured, as described with , to use blocks of code as the basis for scheduling a plurality of blocks for potential concurrent execution. A developer and\/or an automated code marker, for example, may have specified block-level performance criteria for each block of code that may potentially be executed concurrently. Markers may have been embedded to identify each block of code. Demarcation of block-level code suggestive for concurrent execution may be useful in deciding a block-level performance criterion for each block marked for potential concurrent execution. For example, one embodiment of the IMT framework may be configured to perform an analysis of the generated concurrent code to determine block-level performance criteria, such as priority, dependency and\/or weight duration, for use when scheduling a plurality of blocks. In one embodiment, the analysis may be performed using data representative of the concurrent code similar to the acyclic graph described with .","Multi-threaded execution of the plurality of blocks may be optimized to reduce the overall execution time of the running code (as scheduled by the scheduler). In one embodiment, a scheduler may be configured to initiate multi-threaded execution of the plurality of blocks in an order determined by the block-level performance criteria to reduce the overall execution time of the running code. For example, priority and weight information for each concurrent block may have been specified in the marked code (and\/or determined during analysis of the concurrent code) and the scheduler may schedule each concurrent block of the plurality of blocks according to the priority and weight information to reduce the overall execution time of the running code. In one embodiment, the scheduler may be configured to schedule concurrent blocks having longer execution durations ahead of concurrent blocks having shorter execution durations.","Demarcation of block-level code may be used in various ways to optimize execution of the running code. The running code may have been instrumented to collect and log performance data for each concurrent task during execution. For example, in one embodiment, a tracking tool may log information for tracing and\/or profiling of concurrent tasks during execution of the running code. A log file may be created that includes measured block-level performance data (e.g., block execution counts, block execution durations, block paths and edges, block execution predictions) for a particular execution, for example. In one embodiment, the scheduler may be configured to access the measured block-level performance data generated during previous executions of the running code. For example, the scheduler may be configured to read previously stored measured block-level performance data as indicated by a compiler option during recompilation. In one embodiment, the scheduler may be configured to determine the block-level performance criteria for each block of concurrent code according to measured block-level performance data generated from prior executions of each concurrent block. Repeating the process of feeding measured block-level performance data back to the scheduler may optimize multi-threaded execution of the concurrent blocks because of the benefit of new measured block-level performance data, for example.","Multi-threaded execution of the plurality of blocks may be optimized by changing the markings in marked code (e.g., move blocks of code around) and\/or changing the block-level performance criteria specified in the marked code. For example, a developer may determine that certain execution duration of a block (e.g., threshold weight of block) causes the running code to execute faster. The block-level performance criteria specified in the marked code, for example, the priority and weight of each block, may be modified to improve the overall execution time of the running code. Thus, repeatedly executing the running code, evaluating measured block-level performance data and repeatedly regenerating the running code may result with running code that executes faster. The data that is collected may be converted into performance metrics. Metrics may be viewed in tabular form at the object, function, method, block of code, source line or instruction level. Code that may be responsible for resource usage, inefficiencies or time delays, for example, may be modified to improve concurrent execution of the blocks. The markers may also be embedded and\/or changed within compiled code (e.g., Java byte-code).",{"@attributes":{"id":"p-0102","num":"0101"},"figref":"FIG. 7","b":"700"},"An analysis of the concurrent code may be performed to determine block-level performance criteria, such as priority, dependency and\/or weight duration, for use when scheduling a plurality of blocks, as indicated in . In one embodiment, the analysis of the concurrent code may be performed to determine the block-level performance criteria. In one embodiment, the analysis may be performed using data representative of the concurrent code similar to the acyclic graph described with .","In one embodiment, multi-threaded execution of the plurality of blocks in an order based on the block-level performance criteria may be initiated to reduce the overall execution time of the running code. For example, each concurrent block of the plurality of blocks may be scheduled according to priority and weight information to reduce the overall execution time of the running code. In one embodiment, concurrent blocks having longer execution durations may be scheduled ahead of concurrent blocks having shorter execution durations.",{"@attributes":{"id":"p-0105","num":"0104"},"figref":"FIG. 8","b":"800"},"In one embodiment, the developer, for example, may evaluate the generated measured block-level performance data to determine what types of changes may be implemented to optimize execution of the running code, as indicated in . The developer may attempt to improve execution time of the running code based on results of the evaluation by making enhancements and\/or regenerating the running code, as indicated in . Various enhancements may be performed. The developer may decide to feed the measured block-level performance data back to the scheduler. The scheduler may be configured to read previously stored measured block-level performance data as indicated by a compiler option during recompilation. In one embodiment, the scheduler may be configured to determine the block-level performance criteria for each block of concurrent code according to measured block-level performance data generated from prior executions of each concurrent block. The developer may continue to repeat the process of feeding measured block-level performance data back to the scheduler because of the benefit of new measured block-level performance data, for example.","The markings in the marked code may also be changed. For example, the developer may move blocks of code around and\/or change the block-level performance criteria specified in the marked code. A developer may determine that certain execution duration of a block (e.g., threshold weight of block) causes the running code to execute faster. The block-level performance criteria specified in the marked code, for example, the priority and weight of each block, may be modified to improve the overall execution time of the running code. Thus, repeatedly executing the running code, evaluating measured block-level performance data and repeatedly regenerating the running code may result with running code that executes faster.",{"@attributes":{"id":"p-0108","num":"0107"},"figref":"FIG. 9","b":["909","101","909","907","906","905","908","950","950","950","907","906","101","907","908","907"]},"Computer system  may further include other software and hardware components, such as a network interface , that may be coupled to various other components and memory . The CPU  may acquire instructions and\/or data through the I\/O interface . Through the I\/O interface , the CPU  may also be coupled to one or more other components . As illustrated, components  may include disk drive  A, a display device  B and other I\/O devices  C for use with computer system  such as other CPUs, track balls, mice, keyboards, printers, plotters, scanners, etc. Some computer systems  may include additional and\/or other components than shown in .","In one embodiment, the IMT framework  may be configured as part of an application server, for example. The application server may execute application components that operate across different computers based on different platforms and architectures. One embodiment of an IMT framework  may be implemented on a single computer. The software code may be implemented, for example, on virtual machines (VMs) (e.g., Java Virtual Machines) coupled to one embodiment of an IMT framework . The virtual machines may be implemented on one or more computers. The IMT framework  may operate on different and various types of computers that may communicate to each other over a network. For example, a client (e.g., Web browser) may operate on a desktop computer running Windows\u2122 NT from Microsoft and an IMT framework application server, in one embodiment, may operate on a minicomputer running an operating system such as Sun\u2122 Linux from Sun Microsystems.",{"@attributes":{"id":"p-0111","num":"0110"},"figref":["FIG. 10","FIG. 9","FIG. 10","FIG. 10"],"b":["101","974","974","101","101","974","971","973","975","101","974","101","101"]},"The Internet-based application logic may be divided into application components according to function and the various application components may be installed on different computers depending on which tier the application component belongs. The application components, for example, may be specified and assembled with one embodiment of the IMT framework . The application server A, executing the application components operating across tiers, may be a resource within the middle tier . For example, a Web browser as a client  within the client tier  may operate on a computer that is configured to access the application server A via an Internet\/Intranet  using an underlying protocol such as HyperText Transfer Protocol and HyperText Transfer Protocol Secure (HTTP\/HTTPS). The resources within each tier may operate on different and various types of host computers that may communicate to each other over a network. For example, a client  (e.g., Web browser) may operate on a desktop computer running various operating systems such as Windows\u2122 from Microsoft and Unix\u2122 from Sun Microsystems, and the application server A may operate on a minicomputer running various operating systems such as Solaris\u2122 and Sun\u2122 Linux from Sun Microsystems.","The flow charts described herein represent exemplary embodiments of methods. The methods may be implemented in software, hardware, or a combination thereof. The order of method may be changed, and various elements may be added, reordered, combined, omitted, modified, etc.","Various modifications and changes may be made to the invention as would be obvious to a person skilled in the art having the benefit of this disclosure. It is intended that the following claims be interpreted to embrace all such modifications and changes and, accordingly, the specifications and drawings are to be regarded in an illustrative rather than a restrictive sense.","Various embodiments may further include receiving, sending or storing instructions and\/or data implemented in accordance with the foregoing description upon a computer readable medium. Generally speaking, a computer readable medium may include storage media or memory media such as magnetic or optical media, e.g., disk or CD-ROM, volatile or non-volatile media such as RAM (e.g. SDRAM, DDR SDRAM, RDRAM, SRAM, etc.), ROM, etc. as well as transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network and\/or a wireless link."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
