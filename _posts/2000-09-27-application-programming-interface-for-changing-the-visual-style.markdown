---
title: Application programming interface for changing the visual style
abstract: A method of communicating between a graphical component library and an appearance manager is provided that includes issuing a request, that includes component defining parameters, for rendering services by a graphical component library. The appearance manager receives the request for rendering services and assigns appearance characteristics to the graphical component based upon the provided parameters. A method of rendering graphical components on the display of a computer system is also provided that includes rendering the requested graphical component according to the appearance characteristics assigned by the appearance manager. A method is also provided for communicating between a graphical component library and an appearance manager that includes issuing a request, that includes component defining parameters, for information about the defined component. The appearance manager receives the request for information and provides the requested information to the graphical component library based upon the provided parameters.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06873337&OS=06873337&RS=06873337
owner: Microsoft Corporation
number: 06873337
owner_city: Redmond
owner_country: US
publication_date: 20000927
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application claims the benefit of U.S. Provisional Application No. 60\/195,593, filed Apr. 6, 2000.","The present invention relates to a computer system and, more particularly, to an application programming interface that facilitates changing the visual style of displayed graphical components, such as controls.","Computer users in both the business and home environment have become accustomed to using a computer with a graphical operating system. For example, many users operate computers having a Microsoft Corporation \u201cWINDOWS\u201d operating system thereon. Certain components of these graphical operating systems are known as \u201ccontrols.\u201d For example, a control may be an \u201cOK\u201d button, which is generally a rectangular button with \u201cOK\u201d written in it. By moving the cursor over the button and clicking on the mouse, a known operation will begin that is associated with the control. Many other controls exist, with examples including scroll bars, dialog boxes and sliders. Beyond controls, the graphical operating systems also draw, or render, other graphical components as needed on the display of the computer, such as the frame, the minimize box and the close box.","There are two general kinds of controls in WINDOWS: standard and custom. Standard controls are provided by the operating system. The code to create, draw and operate standard controls is contained in the common control library (DLL), a part of WINDOWS. Custom controls are all other controls. Custom controls may be created by the manufacturer of the operating system or by third parties. The code for custom controls is contained in a corresponding separate library (DLL) or within an application.","Currently, when a graphical user interface component, such as a control, is used by an application, the application requests that an instance of the component be created. Following this, the operating system transmits a generic message to the component, instructing the component to render itself. The application plays a role in routing the message from the main window to the targeted control, but the control code performs the drawing. The application uses application programming interfaces (API's) to create and interact with the control. An API serves as a software interface to be used by other programs, much as the keypad serves as an interface to a calculator. An API is a fundamental concept of high-level programming. In high-level programming, a program often does not execute tasks by itself. Instead, the program asks some other program to execute these tasks. For example, programs frequently delegate various tasks to the underlying operating system. Continuing with the above example, an application delegates the rendering of a control to the control's code.","In the prior art environment, when a generic rendering message is received by a control to draw itself, the control will draw itself using its own drawing software code. In this prior art environment, the control knows what it is supposed to look like, how it is supposed to behave, and can effectuate such a display on the user interface of the computer. Thus, the application may delegate all aspects of visual rendering to the controls, avoiding the need to contain software code to support the visual rendering of the control within the host application itself.","By utilizing the standard controls defined and rendered by the operating system, all controls will have the same appearance, regardless of the application; Users of graphical operating systems can change only a limited number of characteristics of the controls. In the \u201cWINDOWS\u201d operating system, a user can change the color scheme used to display the various controls and components on the monitor. The user can also select a small set of fonts to be used by the controls and components. The user can also specify a limited number of nonclient sizes that will control the sizing of the nonclient areas. Thus, the colors, fonts and a limited set of sizes of the controls and components may be changed. However, the basic appearance of the controls and components is dictated by the rendering software code within the control library containing the particular graphical component or control. In the prior art environment, to change the appearance of the controls or graphical components, the rendering software code must be altered. For example, if it is desired to change the appearance of the \u201cOK\u201d button, the rendering software code within the operating system DLL file containing the button control must be altered and the DLL file reconstructed at the binary level. If it was desired to render the button as an oval with \u201cokay\u201d written inside, the software code would have to be changed accordingly. Such an approach makes it difficult, if not impossible, for a computer user and for software manufacturers, to easily alter the appearance of the controls and graphical components.","In order to enhance the user experience of the computer, it would be desirable for the user to have the ability to change the overall \u201clook and feel\u201d of the graphical display by changing the overall visual appearance or \u201ctheme\u201d of the various graphical components. In other words, it would be desirable if the user could change not only the color and font of the graphical components appearing on the monitor, but to change the appearance of those graphical components as well. For example, it would be desirable to be able to alter and direct the layout of the parts of a control, and to define the shape of a control or its parts. It would also be desirable to control all aspects of how a control or its parts are drawn. Because the controls and graphical components existing within the DLL file in the prior art environment are \u201chard coded\u201d with their own rendering software code, it is difficult and cumbersome to change the appearance of all of the controls and components. To do so would require recoding each of the controls to achieve the desired appearance. If multiple visual styles were required, they would each have to be predefined and each \u201chard coded\u201d into every control. Moreover, the controls must also be recoded if a different rendering technology is to be used. For example, if the controls are rendered using a bitmap and it is desired to utilize a vector-based renderer, each control must be altered.","Certain prior art approaches exist that attempt to address the above situation. However, these solutions do not allow all of the controls and graphical components of the entire system to be changed. Instead, the prior art approaches address only limited portions of the set of displayed components. This allows the appearance of some controls and graphical components to be altered, leaving the remainder unaltered. Such an approach leaves an appearance that is not as coordinated as may be desired.","The prior art approaches are further limited by the techniques they employ to implement control of the appearance characteristics of visual elements of the graphical user interface. Prior art appearance modifiers operate by intercepting the generic rendering signals transmitted to the control, and, using low-level operating system graphical APIs, substitute their own rendering code for that of the control. However, only a portion of the visual elements in the graphical user interface is interceptable. Because the prior art approaches depend exclusively on the interception of operating system signals, not only are they themselves incapable of controlling the appearance of visual elements that do not function according to this protocol, they are incapable of providing a standard means for the author of the visual element to modify the rendering code to accommodate external control.","Further, it is not possible to intercept all relevant signals transmitted by the operating system to a control in the course of rendering. Still further, it is not always possible to reproduce complex visual behavior implemented by a control, such as animated sequences. Thus, the prior art approaches are prone to functional incompatibilities, visual flaws, and performance problems.","Moreover, the prior art techniques do not provide an interface through which software developers can design controls to accommodate versatility in visual appearance. The prior art approaches do not involve an architecture that allows a control author the flexibility to design a control that is \u201ctheme aware.\u201d Control authors are therefore not allowed the freedom needed in authoring controls to create controls which can easily be visually altered.","Accordingly, there is a need for an effective system and method for altering the visual style of controls and graphical components that are rendered on the user interface that addresses the above drawbacks and deficiencies. There is also a need for a system and method for altering the visual style of controls and components that are used by an application that can utilize different rendering technologies without requiring modification of the controls and components at the binary level. A need also exists for a system and method for altering the visual style of controls and components that are used by an application that allows a selected theme to be applied to the controls and components without altering the software code of the controls and components. A need also exists for a system that allows software developers and control authors to quickly and efficiently alter the controls and graphical components.","Generally described, a method of communicating between a graphical component library and an appearance manager is provided. The method includes issuing a request, that includes component defining parameters, for rendering services by a graphical component library. The appearance manager receives the request for rendering services and assigns appearance characteristics to the graphical component based upon the provided parameters. The method allows the graphical component library to contain graphical components defined by the parameters and allows the appearance characteristics of the components to be contained within the appearance manager.","In another aspect of the invention, a method of rendering graphical components on the user interface of a computer system is provided that includes issuing a request, that includes component defining parameters, for rendering services by a graphical component library. An appearance manager receives the request for rendering services and assigns appearance characteristics to the graphical component based upon the provided parameters. The appearance manager renders the requested graphical component according to the assigned appearance characteristics. The method abstracts the tendering process from the graphical component library to the appearance manager.","In a further aspect of the invention, a method is also provided for communicating between a graphical component library and an appearance manager. The method includes issuing a request, that includes component defining parameters, for information about the defined component. The appearance manager receives the request for information and provides the requested information to the graphical component library based upon the provided parameters. The method allows the graphical component library to obtain appearance characteristics information from the appearance manager.","Additional advantages and novel features of the invention will be set forth in part in a description which follows, and in part will become apparent to those skilled in the art upon examination of the following, or may be learned by practice of the invention.","The present invention provides a system and method for changing the visual style of controls and components within a graphical operating environment.  illustrates an example of a suitable computing system environment  on which the invention may be implemented. The computing system environment  is only one example of a suitable computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the invention. Neither should the computing environment  be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary operating environment .","The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","Computer  typically includes a variety of computer readable media Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through an non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through a output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in FIG. . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Although many other internal components of the computer  are not shown, those of ordinary skill in the art will appreciate that such components and the interconnection are well known. Accordingly, additional details concerning the internal construction of the computer  need not be disclosed in connection with the present invention.","Those skilled in the art will understand that program modules such as the operating system , application programs  and data  are provided to the computer  via one of its memory storage devices, which may include ROM , RAM , hard disk drive , magnetic disk drive  or optical disk drive . Preferably, the hard disk drive  is used to store data  and programs, including the operating system  and application programs .","When the computer  is turned on or reset, the BIOS , which is stored in the ROM  instructs the processing unit  to load the operating system from the hard disk drive  into the RAM . Once the operating system  is loaded in RAM , the processing unit  executes the operating system code and causes the visual elements associated with the user interface of the operating system  to be displayed on the monitor . When an application program  is opened by a user, the program code and relevant data are read from the hard disk drive  and stored in RAM .","In the present invention, operating system  is a graphical operating system having graphically displayed controls and components associated therewith. Controls include, but are not limited to, such things as scroll bars, push buttons and sliders. Other controls are within the scope of this invention, and are known to those of skill in the art. Other graphically displayed components are also within the scope of this invention. These components include, but are in no way limited to, non-client sections of the windows in the display, such as the frame surrounding an application display on the user interface, the minimize box, and the close box.","An example display of graphical components having a variety of appearances is seen in FIG. . As shown in , the controls may take the form of an OK button , a Cancel button  and an Apply button . The present invention allows the appearance of the controls and other components to be visually changed to better suit the desire of the computer user. The invention allows the appearance of the controls to be altered beyond color and font selection. For example, the layout of the parts of a control can be defined as desired. For example, a scroll bar could be rendered with the up and down arrow buttons adjacent to each other at the bottom of the scroll bar, instead of the up arrow and the top and the down arrow at the bottom. Further, the shape of the control and its parts may be defined. As shown in , four different overall appearances are shown for each of the buttons ,  and . Each different appearance setting is coordinated and is called a \u201ctheme.\u201d Each theme is represented by one of the rows of buttons in FIG. . While only four themes are shown in , an unlimited variety of themes may be created for selection by the computer user. The theme is a collection or set of appearance characteristics relating to a particular subject or desired visual environment. As described below, the present invention allows the user of the computer to specify which of a number of predefined themes is to be applied to the controls and other components of the visual display. Moreover, the present invention allows new visual themes to be added to the system without the need of changing the software code of the controls and other graphical components. Still further, the present invention allows addition of new rendering technologies or modification of existing rendering technologies without changing the software code of the controls and other graphical components.","Turning now to , the basic architecture used in the present invention is illustrated. The architecture is illustrated with example applications  that are open and running on the computer . As an application  is running it often requires a control or graphical component to be rendered, or displayed, on the monitor  of the computer . For example, with reference to , the display of an OK button  may be needed by the application on the monitor.","In the prior art environment, application  requests that an instance of button  be created. Following this, the operating system transmits a generic message to the control instructing it to draw itself. This request would be routed to the dynamic link library (DLL) that contained the particular control. As an example, the DLL in the WINDOWS operating environment would be called User32.dll or ComCtl32.dll(V5), shown as  and , respectively, in FIG. . Libraries  and  exist within graphical operating system . In the prior art environment, libraries  and  are linked directly with applications . The defined control within libraries  and  contains the drawing code needed to render the control on the monitor. Therefore, to change the appearance of controls within libraries  and , the software drawing code must be changed for each control within libraries  and .","The present invention includes an additional DLL, shown as  in FIG. . In the WINDOWS operating environment, DLL  may be called ComCtl32.dll (V6), as indicated in FIG. . This DLL is similar to library , in that it contains a number of predefined controls and graphical components that may be used by application . Broadly, DLL  contains a number of components that are to be graphically displayed. In library , however, the controls are defined differently, making them \u201ctheme aware.\u201d Rather than containing all of the software code needed to render the control, the controls are defined with certain basic information or values about the control, for example, the location, parts and states of the controls.","The location is the position on the user interface where the control is desired. Parts are the different items that make up the control. For example, OK button  has a background part and a text part. As another example, a scrollbar control has an elongated rectangular shaft part, a smaller thumb part that slides within the shaft part, and an arrow part at each end of the shaft part. The state of a control describes the current appearance and functional state. For example, a button can be active, pressed, hot (when the mouse is over the control), disabled or inactive.","As stated above, in the prior art environment, libraries  and  are linked directly with applications . In the present invention, libraries ,  and  are linked to the applications  through a fusion process . Fusion  enables the theming of controls in applications without needing to change the applications themselves to request the themable version of the controls. Fusion  enables each application  to load the specific version of the DLL ,  or  at run time through the use of a manifest. The fusion manifest specifies the environment in which an application will run, which allows multiples versions of a DLL to exist on one machine. Thus, fusion  will map the request for OK button  so that it is rendered as a themable element in DLL  instead of a non-themable element from DLL . This allows an existing application to be themed without changing code of the application. Fusion  also allows the new themable controls to be placed in a different DLL from the existing DLL, which simplifies implementation and minimizes compatibility risks.","Controls existing within DLL  are therefore used if they are available. As seen above, the controls within DLL  are defined as a series of parts and states. The controls within DLL  also contain the drawing code needed to render the controls if no themes are selected, as well as the theme-aware paths through the code. DLL  requests rendering or drawing services from a theme manager DLL . Theme manager  provides the requested rendering services and draws the control on the display at the indicated location, with the indicated parts in the indicated states.","Theme manager  contains a series of APIs that allow library  to interact and communicate with the theme manager. The APIs allow a control author to define a control within DLL  as a series of parts and states without the need for software rendering code. These APIs are generally divided into three types: drawing APIs , information APIs  and utility APIs . Drawing APIs  are generally used to render and assist in the layout of the needed control parts and other components. Information APIs  are generally used to obtain information about the current defined appearance of the controls to allow controls to be individually customized. Utility APIs  are those APIs used by parts of the operating system other than the controls, to control theme selection. Utility APIs  include functions that can be used to enumerate an installed theme and load it.","Drawing APIs  are a collection of theme-aware drawing services. Each individual API within the set of drawing APIs  is used to perform a different drawing service. Generally, each API requires a specified part and state of the graphical component at hand. An API called \u201cDrawThemeBackground\u201d is provided that draws the theme-specified border and fill for the specified part and state at the desired location. Similarly, an API called \u201cDrawThemeText\u201d is provided that draws the specified text using the theme-specified color and font for the specified part and state.","As an example, if an OK button  was requested by an application , the control within DLL  would pass the part, state and location information to drawing APIs  through a function call, such as DrawThemeBackground, or DrawThemeText. As is more fully described below, this part and state information is matched with appearance characteristics and theme manager  draws the control on the monitor. Drawing APIs  further include an API called \u201cGetThemeBackgroundContentRect.\u201d This API allows the control to obtain the size of the content for the theme-defined background. Usually, this is the area inside the borders or margins. By using this API a control can determine the available area within the background in which items may be placed. When using this APL the control within DLL  is requesting information regarding a graphical component with a specified part and state. This information is obtained by the theme manager  and returned to the control. A similar API called \u201cGetThemeBackgroundExtent\u201d is provided that calculates the size and location of the theme-specified background for the specified part and state given a content rectangle. This API may be used when the content is known; and based upon that content, the outer boundary for the theme background needs to be determined. Another API called \u201cGetThemePartSize\u201d is provided to retrieve the theme author specified minimum and normal sizes of a control part.","Drawing APIs  further include an API entitled \u201cGetThemeTextExtent.\u201d This API is used to calculate the size of a specified text when rendered in the theme font. This API can therefore be used to determine the width and height of a given text string. The control author can thus specify a part and state having text associated therewith and use this API to obtain information from theme manager  regarding the size of the text string. Similarly, another API entitled \u201cGetThemeTextMetrics\u201d is available that can be used to obtain size information about the font being used. Therefore, this API may be used to obtain information such as the width of an average font character. In other words, this API is used to obtain from theme manager  information that the control needs regarding the size of a theme-specified font.","An API entitled \u201cGetThemeBackgroundRegion\u201d is also provided within drawing APIs . Within some operating systems, a region is a way to describe a non-rectangular shape. A region can also be thought of as an image with transparent parts. This API is used to compute the region for a regular or partially transparent theme-specified background. In other words, this API may be used to determine what is transparent and what is opaque within the framed background for a specified part and state. Thus, this API supports the definition of non-rectangular shapes of controls and parts. Similarly, an API entitled \u201cHitTestThemeBackground\u201d is provided. This API is used to determine whether the point within the background for the specified part being clicked is in a transparent or an opaque area. This API is used by a control within DLL  to obtain information from the theme manager . If the click is within a transparent area, no action may be needed. Conversely if the click is within an opaque area, an action may be required.","Another API contained within drawing APIs  is entitled \u201cDrawThemeLine.\u201d This API allows a theme to define a generic style of a line. This generic style may be accessed and used for a specified part by calling the \u201cDrawThemeLine\u201d API. Similarly, an API entitled \u201cDrawThemeBorder\u201d is provided that allows a theme-defined border to be specified. The theme-border may be drawn for a specified part utilizing this API.","An API entitled \u201cDrawThemeIcon\u201d is provided that allows a theme-defined icon to be rendered that may include theme-specified special effects. For example, a theme-icon may have a different appearance when the mouse is directly over the icon, such as a glowing appearance.","Drawing APIs  also contain an API entitled \u201cIsThemePartDefined\u201d that may be used to determine if the theme has defined parameters for the specified part and state. If the part is not defined within the theme the control can draw this part itself. If the part is theme defined, theme manager  will render the part according to the theme defined information. Another API is provided entitled \u201cIsThemeBackgroundPartiallyTransparent.\u201d This API is used to determine whether or not the background is a rectangle or region that has a transparent part. This API may be used to simplify the control code. If there is no transparency within the background, then there is no need to conduct any hit testing through the use of the \u201cHitTestThemeBackground\u201d API. Importantly, drawing APIs  further include an API entitled \u201cOpenThemeData.\u201d This API is used to obtain the handle for a list of class names. A class name list identifies a set of graphical components, and may be divided into parent class names and one or more child class names. For example, a parent class name might be button. A child class name for that parent class might be \u201cstart button.\u201d A handle is a reference to an internal structure detailing various information and properties of the object. Theme manager  will search for each class name in the list and use the first matching theme information found. For example, if the class names included both start button and button, the start button theme information would be used if it existed. If start button theme information did not exist, the theme information for a button would be used. If no value is found the old code will be used to render the control. If any non-0 value is returned, a valid theme handle is established. This theme handle will be retuned to DLL  and used for all of the theme drawings.","Similarly, another API provided is entitled \u201cCloseThemeData.\u201d This API is used when the control is closed, such as a button no longer being needed, or when the theme is changed, as is more fully described below.","Another API provided is entitled \u201cIsThemeActive.\u201d This API allows a control within DLL  to obtain a true or false answer as to whether there is a current theme in effect. This API can thus be used to determine whether to call the \u201cOpenThemeData\u201d API or merely use the existing drawing code where the controls will render themselves.","As described above, theme manager  also contains a set of information APIs . These information APIs  allow controls to be individually customized. In other words, these APIs are utilized in only certain instances and may be used to obtain information about specific controls. These information APIs are used to query theme manager  for defined theme information regarding specified properties of the theme. Each API  thus requests information, which is provided by theme manager .","Within information APIs  is an API entitled \u201cGetThemeColor.\u201d This API utilizes the specified part and specified state along with a specified color property identifier to obtain information about the theme color. The property identifier is the color property number that is desired. In other words, the color API is used to ask for the color value corresponding to the property desired, such as the background color. Another API called \u201cGetThemeMetric\u201d is provided that requests and receives a size value for a specified property identifier. This size value will be an integer. An API entitled \u201cGetThemeString\u201d is also provided within information APIs . This API is used to obtain the string for a specified property identifier. The string will include information regarding the number of characters in the string and where the string is terminated.","Another API is provided within information APIs  entitled \u201cGetThemeBool\u201d that will return an integer that is either 0 or 1 for a given part, state and property. The 0 and 1 correspond to a false or true state for that part, state and property. Another API provided is entitled \u201cGetThemeInt.\u201d That will return an integer value for a specified part, in a specified state with a specified property identifier. Similarly, an API is provided entitled \u201cGetThemeEnumValue\u201d that will return the theme-enum for the specified part, state and property identifiers. An enum is merely a variable that holds numeric values which correspond to symbolic information. For example, an enum for alignment might be left, middle, right corresponding to the numbers 0, 1, 2.","Another API entitled \u201cGetThemePosition\u201d is provided that will return two integer values, corresponding to an x-location and a y-location for a specified part in a specified state with a specified property identifier. Another API provided within information APIs  is entitled \u201cGetThemeFont.\u201d This API is used to obtain a logical description of the font theme used, given a specified part, state and property identifier.","Yet another API provided within information APIs  is entitled \u201cGetThemeRect.\u201d This API will return four integers representing the left, right, top and bottom of the specified part, state and property identifier. Similarly, an API entitled \u201cGetThemeMargins\u201d is provided that will return four integers representing a left space, right space, top space and bottom space given a specified part, state and property identified. There is also an API entitled \u201cGetThemeIntList\u201d which returns the value of a specified property whose type is a list of integer values. Finally, an information API entitled \u201cGetPropertyOrigin\u201d is provided that returns the location from which the property originated. This API allows the control author to obtain information for the property origin. In other words, the API allows the control author to determine whether the property was specified on the state, part, class, global or was the property not found. This is needed because theme properties are specified by the theme author in a hierarchical fashion. For example, if a property is not specified at the \u201cstate\u201d level, the theme manager will search the \u201cpart\u201d level, \u201cclass\u201d level, and finally the \u201cglobals\u201d level for the property. Sometimes it is important for the control to know if a property was explicitly defined for the part\/state it is processing. There is also an API entitled \u201cGetThemeFilename\u201d which returns the string value of the specified filename property.","Another API provided within information APIs  is entitled \u201cSetWindowTheme.\u201d This API allows a control author to redirect a control window to use a different set of theme information than its class would normally use. In other words, this API allows a control to be used while giving the control a special look other than the standard look defined by the theme for that class. This API may use additional parameters to identify a particular application and class name. This allows a theme author to use the specified class but to change the appearance of that class. For example, a button may be defined that has a given button appearance. Utilizing this API, this button can be redirected to a different class name. For example, \u201cOkayButton\u201d may be specified. The theme author will then be able to use a class called \u201cOkayButton\u201d and the \u201cOkayButton\u201d will have a different appearance from the standard button appearance.","There is also a subset of theme metrics APIs within the information API group that parallel the WIDOWS system metrics, but which are specific to a theme. Unlike normal control-based properties, these properties are available to and shared by all controls. \u201cGetThemeSysColor\u201d returns the theme-specified color value of the specified system color index. \u201cGetThemeSysColorBrush\u201d returns a handle to a drawing brush that is the color of the specified system color index. \u201cGetThemeSysSize\u201d returns the integer size of the specified theme size index. \u201cGetThemeSysBool\u201d returns a boolean (0 or 1) value for the specified theme boolean index. \u201cGetThemeSysFont\u201d returns a logical font structure for the specified theme font index. \u201cGetThemeSysString\u201d returns a string value of the specified theme string index.","There are also some application-oriented API's within the information API group . \u201cIsAppThemed\u201d returns a boolean (0 or 1) value indicating if the application is being themed by the operating system. \u201cGetWindowTheme\u201d returns the most recent theme handle, if any, opened for the specified window. \u201cGetThemeAppProperties\u201d returns the flags that control which parts and types of windows are themeable within the application. \u201cSetThemeAppProperties\u201d allows the application to set these same flags.","Finally, there are information API's  for error handling. \u201cGetThemeLastErrorContext\u201d returns the error context (including error code, error code parameters, filename and source line) associated with the last reported theme error on the current thread of execution. \u201cFormatThemeMessage\u201d returns the error string for the specified error context in the specified language.","Theme manager  includes not only drawing APIs  and information APIs , but also a set of utility APIs . These APIs may be used to achieve a variety of results.","Drawing APIs  and information APIs  allow the author or creator of controls within DLL  to define the controls as a series of parts and states. The defined control is therefore abstracted from the rendering process of theme manager  and is also abstracted from the theme-defined appearance information or characteristics, as is more fully described below. Using APIs  and  the control author can create controls that are \u201ctheme-aware\u201d and that are equipped to communicate with theme manager . This communication involves passing basic information or values to theme manager  that allow the theme manager to render the desired control, having the needed parts in the desired states.","Theme manager  also contains the renderers needed to execute the drawing instructions. For example, a border-fill renderer  could be used that allows different color themes to be applied to the controls. As another example, a bitmap renderer  could be used that defines the control parts as images. Other examples of renderers include using a vector definition language, portable network graphics (PNG) files, or portable document format files (PDF). It should be understood that the present invention is not limited to a particular rendering technology. If a different renderer is desired or needed, the drawing code of theme manager  is revised to add the renderer to theme manager . The controls within DLL  are therefore isolated or abstracted from the rendering technology within theme manager . This allows different renderers to be added to theme manager  without having to revise the controls within DLL , as is more fully explained below.","The renderer within theme manager  renders the requested control according to an appearance theme that has been selected by the user of the computer. For example, appearance themes  and  are shown in FIG. . As shown, theme  may be a consumer theme and theme  may be a business theme. It should be understood, however, that other themes could be used and that the invention is in no way limited to the particular theme. For example, other themes could include a cartoon theme, a children's theme or a golf theme. As seen in , business theme  has been selected by the user, as represented by the solid line . Consumer theme  is available for selection, as represented by the broken line .","Each theme  and  has similar architecture. As seen in , business theme  includes a series of image files . Image files  are the image files that will be used by the particular theme. In this case, image files  are the image files that will be used by business theme . Business theme  also includes a themes.ini file . File  is a text file and can be created in either ANSI or UNICODE character sets. File  specifies the available color schemes and sizes available for the theme. In the case of theme , file  specifies the available color schemes and sizes available for business theme . File  therefore represents all of the variations of the theme to which it applies.","Theme file  consists of one or more sections. The sections within theme file  include a documentation section , a size section , a color scheme section  and a file section . Documentation section  is optional and may contain any property name. Size section  specifies the size name, such as \u201cdefault size,\u201d \u201cvery small\u201d or \u201cvery large.\u201d Color scheme section  is used to specify a simple color scheme name and an optional color scheme transformation associated with the color scheme name. File section  is used to specify a unique name for the class data file. The file section  will include a file name, a color scheme (from color scheme section ) for that file name, and the sizes (from the size section ) that the file will support.","Theme  includes a second .ini file labeled  in FIG. . File  is a class data file that contains the theme data for a specific size and color theme. File  may also contain defining sections. For example, file  may contain a globals section that defines the properties of the particular class of control. File  may also contain a section that allows the system metrics to be obtained and used. Finally, file  may contain a group of class sections. Each class section name contains a class name, an optional part name, and an optional state name. Within the section are the property\/value pairs that define the appearance of the specified part or control. For example, a class name would be \u201cslider\u201d for the slider control. A part specified for the slider would be \u201ctrack.\u201d States defined for the track part would be \u201cnormal,\u201d \u201cdisabled,\u201d and \u201chot.\u201d The class section name can also include an application (or \u201cgroup\u201d) name, which specifies that the section only applies to a specific application (or \u201cgroup\u201d name, as specified by the SetWindowTheme API).","Image files , theme file , including file  are broadly grouped together to make up theme directory . Theme directory  and a system schema file located within the theme manager  are used to load business theme . The system schema file is the file that defines property numbers for all of the properties involved in a particular theme and is basically a master definition file that allows the themed properties to be assigned a number corresponding to a defined appearance.","Theme directory  thus contains a theme.ini file , a class data file  and all of the image files  used by the theme. The contents of theme directory  can be packaged into a DLL file by packthem tool . Packthem tool  processes the theme.ini file by parsing it against the schema file for syntax errors and adding the .ini file to the package being built. Recognized properties from documentation section  are written to a package string table. Color scheme information from color scheme section  and size information from size section  is also written to a package string table. Each class data file  is also processed. As the class data file is processed, the file is parsed against the schema file for syntax errors. The class data file is also added to the package being built.","The DLL file produced by packthem tool  is business theme file . File  contains the theme data and this theme data is isolated from control library . This allows different themes to be created and selected without changing the controls defined within library . Thus, control authors can create and define controls independently of the appearance or theme data. File  is in binary format and is passed into a shared theme data file  when business theme  is selected by the computer user, as best seen in FIG. . File  is a shared memory map file that can be accessed by all processes. Thus, when a theme is selected by the computer user, theme manager  will read the information for a defined theme file, such as file , and will place that information in a binary format in file  where all running processes have access to the binary information.","As best seen in , a theme-switching control panel  is provided that is in communication with theme manager . Panel  cooperates with a user interface that displays the available themes from which the user can select. As shown in , control panel  would allow a user to select business theme  or consumer theme . If, as has been discussed above, business theme  is selected and the user of the computer switches to select consumer theme , theme  will be loaded into shared memory map file  as binary data. Theme manager  also sends a message to each theme-aware control within DLL file  that the theme has changed. Each theme-aware control knows how to respond to this message.","When the theme-aware control receives a message that the theme has changed, the control will close the current theme handle that was received via the OpenThemeData API. The control will then attempt to open a new theme handle, again using the OpenThemeData API. If a new theme handle cannot be opened, the control knows that the theme has been switched off for that control and that the old drawing code is to be used by the control to draw itself. If a new theme handle is opened, theme manager  will look at the theme binary data and will start a new drawing routine so that all of the theme-aware controls are redrawn utilizing the newly selected theme, such as consumer theme . Any information that was cached regarding the previously selected theme is invalidated and that information must be recalculated.","In operation, as is best seen in , an application  will request a graphic, such as a control, to be rendered on the user interface, as represented at . This graphical request is routed through fusion . As represented by , the fusion process will determine if the requested control is a theme-aware control. If the control requested is not theme-aware, the old code is used and the control will draw itself using a control from DLL  or , as represented by  in FIG. . If the control is theme aware, the graphical request is processed in DLL , as is represented by . The controls within DLL  will pass basic information for the graphical request, such as the part, state and location for the requested control to the theme manager  in a request for rendering services, using APIs ,  and . Thus, the graphical request is processed in DLL  without application of the appearance characteristics that are found by theme manager . Theme manager  will then determine or apply the theme-specific appearance characteristics for the given control part and state, as shown by . This appearance data is retrieved from the shared memory map data file . Using the retrieved appearance data, for the requested control part and state, along with the location, the theme manager will render the control on the display of the computer, as represented by .","In addition to isolation of controls from rendering technologies, the present invention also provides for isolation of controls from individual themes. Allowing a user to pick from a variety of different themes that may be pleasing to the user and enhances the user's computing experience. The APIs and architecture described above allows ease in switching from one theme to another, again without having to modify the control functionality. The architecture including a theme manager API, making controls theme aware and the extent of control in the theme authoring results in higher performance, better quality drawing with less bugs, more complete control and window theming and easier to author themes.","The present invention has numerous advantages over prior art approaches. In particular, as discussed above, the present invention allows an author of controls within DLL file  to define the controls using only basic information, such as the part and state of the control. The provided APIs allow the controls defined within DLL  to communicate with theme manager . Through the APIs, theme manager  can provide information and rendering services to the controls within DLL . The APIs thus allow the rendering services to be isolated, or abstracted, from the controls within DLL . This allows flexibility in the use of additional rendering technologies, and modification of existing rendering technologies. This flexibility enhances the situation where future rendering technologies are developed. These rendering technologies can easily be added to theme manager , without making any other modifications to the operating system. Therefore, the isolation of each control from the rendering technology provides a computer architecture that is flexible, easy to revise, and easy to build upon for future expansion of rendering technologies.","Additionally, the present invention mitigates application compatibility risks and is faster than previous approaches.","Alternative embodiments of the present invention will become apparent to those skilled in the art to which it pertains upon review of the specification, including the drawing figures. Accordingly, the scope of the present invention is defined by the appended claims rather than the foregoing description."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWING","p":["The present invention is described in detail below with reference to the attached drawing figures, wherein:",{"@attributes":{"id":"P-00020","num":"00020"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00021","num":"00021"},"figref":"FIG. 2"},{"@attributes":{"id":"P-00022","num":"00022"},"figref":"FIG. 3"},{"@attributes":{"id":"P-00023","num":"00023"},"figref":"FIG. 4"},{"@attributes":{"id":"P-00024","num":"00024"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
