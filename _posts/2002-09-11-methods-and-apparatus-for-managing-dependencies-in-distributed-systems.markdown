---
title: Methods and apparatus for managing dependencies in distributed systems
abstract: Techniques for managing information in a computing environment. Information associated with components of the computing environment is obtained. Then, from at least a portion of the obtained information, a determination is made as to the existence of one or more relationships associated with at least a portion of the components of the computing environment. The determination of the existence of one or more relationships is capable of accounting for a full lifecycle (e.g., including deployment, installation and runtime) associated with at least one component of the computing environment. Thus, techniques for managing runtime dependencies between the various components of computing systems are disclosed which provide a level of abstraction from individual systems and allow the computation of service/component (wherein the component may, for example, be an application, middleware, hardware, a device driver, an operating system and a system associated with the computing environment) dependencies that are related to end-to-end services, as perceived by a customer. By way of example, the inventive techniques may be applied to a distributed computing environment. The computing environment may also be an autonomic computing environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06847970&OS=06847970&RS=06847970
owner: International Business Machines Corporation
number: 06847970
owner_city: Armonk
owner_country: US
publication_date: 20020911
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS"],"p":["The present application is related to the concurrently-filed U.S. patent applications respectively identified as: Ser. No. 10\/241,213 entitled: \u201cMethods And Apparatus For Root Cause Identification and Problem Determination in Distributed Systems;\u201d Ser. No. 10\/241,189 entitled: \u201cMethods And Apparatus For Topology Discovery and Representation of Distributed Applications and Services;\u201d Ser. No. 10\/241,214 entitled: \u201cMethods And Apparatus For Impact Analysis and Problem Determination;\u201d and Ser. No. 10\/241,397 entitled: \u201cMethods And Apparatus For Dependency-based Impact Simulation and Vulnerability Analysis;\u201d the disclosures of which are incorporated by reference herein.","The present invention relates to distributed computing systems and, more particularly, to methods and apparatus for managing dependencies between the various components of such distributed computing systems.","The identification and tracking of dependencies between the components of distributed systems is becoming increasingly important for integrated fault management. Applications, services and their components rely on a variety of supporting services that might be outsourced to a service provider. Moreover, emerging web based (world wide web-based) business architectures allow the composition of web-based e-business (electronic business) applications at runtime.","It is to be understood that the term \u201cruntime\u201d generally refers to the time period when a piece of software is being executed and active in a computer system's memory, as opposed to being dormant and merely sitting in storage on a computer's hard drive. Thus, being able to compose e-business applications at runtime means having the capability to do so without the need to bring down and restart the system\/application and without the need to recompile the application. Traditionally, the lifecycle of a computer program is: write program code\u2192compile (translate into machine code)\u2192run. Thus, with the above capability, one can assemble several pieces of software to form a new application \u201con-the-fly,\u201d i.e., without the need to bring down\/compile\/restart the application.","Consequently, however, failures occurring in one service affect other services being offered to a customer, i.e., services have dependencies on other services. Dependencies exist between the components of different services on a single system and also between the client and server components of a service across multiple systems and domains. Herein, services that depend on other services are referred to as dependents, while services on which other services depend are referred to as antecedents.","It is important to note that a service often plays both roles (e.g., a name service is required by many applications and services but depends, itself, on the proper functioning of other services, such as the operating system and the network protocols and infrastructure). Furthermore, dependency relationships are transitive, i.e., the dependent of a given component requires, in addition to the component itself, the components' antecedent(s).","Dependencies exist between various components of a distributed system, such as end-user services, system services, applications and their logical and physical components. However, service dependencies are not made explicit in today's systems, thus making the task of problem determination, isolation and resolution particularly difficult.","Existing art in the area of software development (such as U.S. Pat. Nos. 4,751,635 and 5,960,196), maintenance (such as U.S. Pat. No. 5,493,682) and software packaging (such as U.S. Pat. No. 5,835,777) deal with individual software elements and modules that form the atomic parts of a program package and require the availability of program source code in order to build software and bundle it into software products. Source code is available to the software developer and not to the service user. The invention primarily focuses on software products that are already packaged.","The Institute of Electrical and Electronics Engineers Standard 1387.2 (entitled \u201cPortable Operating System Interface (POSIX) system administration, part 2: Software Administration,\u201d IEEE, 1995) addresses software distribution\/deployment\/installation. The IEEE standard defines a mechanism for ensuring that new software components (which are going to be installed) do not conflict with an already existing software installation. The IEEE standard identifies three kinds of relationships: prerequisite, exrequisite, corequisite, that facilitate such compatibility checks. This is done individually for every system on which new software needs to be installed. With the IEEE standard, the software inventories present on other systems are not taken into account. Furthermore, the IEEE standard does not deal with instantiated applications and services and therefore does not represent any means of determining the dependencies between components at runtime.","Open Group (Systems Management: Distributed Software Administration, CAE Specification C701, The Open Group, January 1998) extends IEEE 1387.2 by defining several commands (swinstall, swlist, swmodify, etc.) that are invoked by software installation tools on a specific system. Open Group also defines a software definition file format to make sure that the information required by the aforementioned commands is available from the system on which the commands are invoked. The shortcomings of IEEE 1387.2 (i.e., confined to a single isolated system, no means for determining software dependencies at runtime) also apply to the Open Group specification.","Current Operating System Inventory implementations (such as the IBM AIX Object Data Manager (ODM), the Linux Red Hat Package Manager (RPM) or the Microsoft Windows Registry) follow either the OpenGroup specification and the IEEE 1387.2 standard or describe the software inventory in a proprietary format. Thus, the aforementioned limitations also apply to such Current Operating System Inventory implementations.","Techniques for electronic software distribution of whole program packages (such as U.S. Pat. Nos. 6,009,525 and 5,721,824) or updates\/corrections\/fixes\/patches (such as U.S. Pat. Nos. 5,999,740, 5,805,891, and 5,953,533) are, by definition, restricted to the distribution\/deployment\/installation of (one or many at a time) physical software packages and do not take the runtime stages of applications into account. In addition, they deal with one system at a time and do not take the cross-system aspects of applications and services into account.","Techniques for determining conflicts in existing software\/hardware configurations (such as U.S. Pat. No. 5,867,714) are also confined to a single system and do not take runtime aspects into account.","While existing work (such as U.S. Pat. No. 5,917,831), often within the scope of event correlation (see, e.g., Gruschke et al., \u201cIntegrated Event Management: Event Correlation Using Dependency Graphs, DSOM '98, 1998 and K\u00e4tker et al., \u201cFault Isolation and Event Correlation for Integrated Fault Management, IM '97, 1997), has focused on identifying and describing service dependencies in a proprietary format, it has remained unclear how dependency information can actually be exchanged between different entities of the fault management process. Since it is unlikely that the different parties involved in the fault management process of outsourced applications use the same toolset for tracking dependencies, it is of fundamental importance to define an open format for specifying and exchanging dependency information.","To sum up, a few techniques relating to the determination of relationships between software products have been described and implemented in the existing art. These existing techniques suffer from one or more of the following shortcomings:\n\n","The present invention provides techniques for managing information, particularly, dependency information, between the various components of a computing environment. By way of example, the inventive techniques may be applied to a distributed computing environment. The computing environment may also be an autonomic computing environment.","In one aspect of the invention, a technique for managing information in a computing environment comprises the following steps\/operations. Information associated with components of the computing environment is obtained. Then, from at least a portion of the obtained information, a determination is made as to the existence of one or more relationships associated with at least a portion of the components of the computing environment. In accordance with the invention, the determination of the existence of one or more relationships is capable of accounting for a full lifecycle (e.g., including deployment, installation and runtime) associated with at least one component of the computing environment. By way of example, a component may be a service, an application, middleware, hardware, a device driver, an operating system or a system associated with the computing environment. However, the term \u201ccomponent\u201d is not limited to these examples.","Furthermore, the technique is also capable of accounting for a heterogeneity associated with at least two components of the computing environment, and for one or more components which span one or more domains associated with the computing environment.","In a preferred embodiment, the technique of the invention determines the existence of the one or more relationships by computing component dependencies in a form comprising a functional categorization, a structural categorization and an operational categorization. The categorizations may comprise one or more dependency models.","Thus, advantageously, the present invention provides a level of abstraction from individual systems and allows the computation of service\/application dependencies that are related to end-to-end services, as perceived by a customer.","In contrast to the above mentioned limitations in the existing art, the invention overcomes such shortcomings by providing a higher level (end-to-end service\/application) view to customers that spans multiple systems and reflects the runtime behavior of the involved systems, applications and services. The gathered dependency information is described in an open, extensible format to facilitate the data exchange.","These and other objects, features and advantages of the present invention will become apparent from the following detailed description of illustrative embodiments thereof, which is to be read in connection with the accompanying drawings.","The present invention will be explained below in the context of an illustrative distributed computing environment. However, it is to be understood that the present invention is not limited to such a particular computing environment. Rather, the invention is more generally applicable to any computing environment in which it is desirable to manage (e.g., compute, query, etc.) dependencies in order to make the task of problem determination, isolation and resolution significantly easier.","As used herein, depending on the context of the discussion, the term \u201csystem\u201d may be used to refer to a computer system, a software system and\/or some combination thereof. The term \u201csystem\u201d may also be used to refer to an application and\/or a service. Thus, the phrase \u201cmultiple systems\u201d refers to a collection of several systems. Also, the term \u201ccomponent\u201d may refer to a system, itself, or one or more portions of a system.","As mentioned above, service dependencies are not made explicit in today's systems, thus making the task of problem determination, isolation and resolution particularly difficult. Solving this problem requires the determination and computation of dependencies between services and applications across different systems and domains, i.e., establishing a \u201cglobal\u201d service dependency model and enabling system administrators to navigate through the resulting directed graph from the top to the bottom and in reverse order. The need for such a mechanism is best illustrated by the following two scenarios.","The first scenario deals with managing outsourced services, typically offered by Internet or Application Service Providers (ISP\/ASP). Outsourcing services leads to layered service hierarchies where, e.g., the services of an ASP depend on the IP-connectivity (Internet Protocol-connectivity) offered by an ISP, which, in turn, relies on the wide area network of a telecom carrier. At every layer, a service is accessed through a Service Access Point (SAP). A SAP delimits the boundary between the different organizational domains and is the place where Service Level Agreements (SLAs) are defined and observed. Usually, this is done at every layer by monitoring a set of specific parameters that are exposed by the provider. In case of an outage or performance degradation in an upper-layer service, it is necessary to traverse the service hierarchy from the top to the bottom to identify the root cause of the problem.","The second scenario deals with the regular maintenance tasks that can not be done \u201con-the-fly\u201d and therefore affect services and their customers: e.g., e-mail servers get updated with a new release of their operating system, network devices are exchanged or upgraded with a new firmware version, etc. In all cases, it is important for the network and server administrators to determine in advance how many and, more specifically, which services and users are affected by the maintenance. We refer to this task as impact analysis.","The aforementioned tasks are further exacerbated by the following factors.","Dependency models provide a straightforward means to identify possible root causes of an observed problem. If the dependency graph for a system is known, navigating the graph from an impaired service towards its antecedents (being either co-located on the same host or on different systems) will reveal which entities might have failed. Traversing the graph towards its root (i.e., in upwards direction) yields the dependents of a service, i.e., the components that might fail if this service experiences an outage. The following issues need to be addressed.","(a) Scale: The number of dependencies between many involved systems can be computed, but may become very large. From an engineering viewpoint, it is often undesirable (and sometimes impossible) to store a complete, instantiated dependency model at a single place. Traditional mechanisms used in network management platforms such as keeping an instantiated network map in the platform database therefore can not be applied to dependencies due to the, sheer number and the dynamics of the involved dependencies.","These two facts make it prohibitive to follow a \u201cnetwork-management-style\u201d approach for the deployment of application, service and middleware dependency models. As an example, typical data centers of service outsourcers host vast amounts (several thousands) of web application and database servers. This implies a huge number of simultaneously running program instances of, e.g., web application and database servers. A system capable of constructing a dependency model should provide features that allow appropriate scalability by distributing the storage and computation of dependencies across the systems involved in the management process.","(b) Dynamics: Hosted applications (running within web application servers) have a very short lifetime, often only a few seconds. Upon reception of a request, the business logic of a web application (usually implemented as one or more Java Servlets) gets instantiated by the servlet engine of the application server, performs its tasks and is then removed by the servlet engine. Consequently, a system for computing dependencies among these dynamic entities should address the trade-off between the accuracy of the data and the workload generated for retrieving this data.","(c) Heterogeneity: Heterogeneity comes in three different flavors. First, the services offered to customers differ to a large degree. Second, there may be various providers involved in offering a service to a customer. Finally, the products implementing a service may stem from a variety of vendors. A system for computing dependencies should provide a language that is independent of specific operating systems, network protocols, software products and the services offered to a customer.","(d) Manual maintenance of Dependency Data: The acquisition of a service dependency model, even confined to a single host system, is a challenge on its own as today's systems usually do not provide appropriate management instrumentation. It is to be understood that the term \u201cinstrumentation\u201d refers to program code that exposes the management characteristics and capabilities of a (managed) resource through a well-defined (sometimes even standardized) interface so that it can be accessed by management applications. Further, even if available from managed resources, dependency data is not exploited by today's management systems. Instead, the dependency information not only has to be entered manually into a specific management component, but also in a proprietary format. The dependency information is therefore incomplete, outdated (due to the error-prone manual processing), and sometimes even inconsistent because different operators enter the rules independently and there is no way to check the rule base for consistency in an automated way.","(e) Taxonomy for Dependencies: The notion of dependencies is very coarse and needs to be refined in order to be useful. Examples for this are the strength of a dependency (indicating the likelihood and the degree to which a component is affected if its antecedent fails), the criticality (how important this dependency is with respect to the goals and policies of an enterprise), the degree of formalization (i.e., how difficult it is to obtain the dependency) and many more. There is a need to add attributes to dependencies that allow them to be qualified more appropriately; and accordingly, a need to reflect these attributes in the dependency representation.","(f) Problem Determination Features: Further facilities for combining local dependency graphs, stored on every system, into a uniform dependency model are desired. In addition, these facilities should provide an API (application programming interface) allowing management applications to issue queries against the dependency model. These queries will be allowed to retrieve the entities that a specific service directly depends on, or to recursively determine a whole set of nodes, including sub-antecedents. The list of nodes received by the management application enables it to perform specific problem determination routines to check whether these services are operational.","The previous discussion shows that it is important to establish a mapping between three different stages of a service lifecycle:\n\n","While the task of individually obtaining information available at every single stage is feasible, the combination of the three stages into a uniform dependency model is challenging and has not been done in previous work. In addition, there is a need for establishing an efficiently computable dependency model that addresses the requirements of scale, dynamics and heterogeneity of the underlying environment while eliminating the need for human interaction and maintenance of dependency data.","As will be illustrated below in the context of the figures, the present invention addresses these and other needs. That is, the present invention has features which compute runtime dependencies (a \u201cdependency model\u201d) between components of a distributed system on behalf of a management application. The invention offers a generic and uniform approach for retrieving dependency information from computer systems that provide a mechanism for retrieving configuration information of individual computer systems or that provide such data in a machine-readable format.","One benefit of the aforementioned system is that a large amount of application\/service management information can be obtained from these computer systems without having the need to instrument individual applications\/services. However, if such application\/service instrumentation is available, it can be used by the present invention.","The execution of the system described by the present invention may be triggered either by a specific (management) application (such as: impact analyzer, root cause analyzer), a network management platform (such as IBM\/Tivoli NetView, HP OpenView or Aprisma Spectrum) or a management application based on traditional network management systems and platforms.","The present invention provides, inter alia, features for:\n\n","The invention combines dependency information that is available during the lifecycle of an application or service (i.e., from the design to deployment, installation and runtime stages of an application\/service). This information is kept within the following models:\n\n","As is to be expected, the amount of dependencies and their dynamics are extremely high in large-scale distributed systems. The features of the present invention keep their impact on the distributed system (in terms of resource and bandwidth usage) as small as possible and leave as many configuration options that might affect the performance up to the user. Examples for this are: the time intervals for retrieving an updated dependency model, the range of the systems whose dependencies should be tracked, the depth of the dependency model (only services immediately affected versus transitive closure for a given service versus whole service hierarchy).","The present invention preferably exploits the following characteristics of dependency information:\n\n","One goal of the present invention is to retrieve information mainly from a few well-known\/well-defined places (e.g., system repositories) in order to achieve a maximum degree of independence from concrete service\/application instrumentation. In order to achieve this, the invention defines a minimal and sufficient amount of commonly available dependency information.","The invention comprises facilities for storing dependency models persistently or leaves this to the discretion of a management application or another service that uses the invention.","The invention is enabled to have a notion of history in order to detect and determine changes in the dependency model. In this case, the invention provides a publish\/subscribe interface for notifying software components that have previously registered for changes within the dependency model. Another possible use of the invention is to leave the detection of changes in the dependency model up to the discretion of a management application (or a change management service) to issue periodic calls to the invention in order to determine whether changes in the dependency model have occurred.","Given the above realizations made in accordance with the present invention and general features associated with the present invention, the remainder of the detailed description will provide an illustrative explanation of techniques for implementing such realizations and features in the context of .","Referring initially to , a block diagram illustrates an example of an electronic commerce system in the form of a client-server application architecture with which the features of the present invention can interact to produce information. The architecture of  will be described below to illustrate how such an architecture may handle a transaction in the absence of the techniques of the invention.","As depicted, a client system  is used to initiate a request, for example via keyboard. Requests, however, could be initiated by any conventional means such as by mouse click, voice command, bar code swipe, etc. Examples of the client system  are personal computers, kiosks, data entry terminals, scanners, telephones, pagers, handheld or wearable devices, wireless devices, personal digital assistants, network-enabled watches, etc.","The request is acted upon locally where the request is formulated and forwarded to a web application server  over a network  and by passing through one or many network access  devices. An example of the network  and communication protocol are socket-based communications riding on a TCP\/IP (Transmission Control Protocol\/Internet Protocol) transport across a local area network (LAN) that is connected by network access  devices such as routers and switches to a wide area network (WAN) containing many switching locations that create a virtual circuit to a service provider and eventually to a web application server . Examples of a web application server  are high-end personal computers, RISC-based PowerPC's, UNIX-based workstations, minicomputers or mainframe computers running software fielding requests from clients and distributing the requests to appropriate back-end database servers when appropriate.","For illustrative purposes, an electronic commerce transaction initiated within a web browser (running on the client system ) to purchase an item using the Internet will now be described. It is to be understood that the techniques of the invention may work with any form of transaction. Examples of web application servers include, but are not limited to, those available from IBM Corporation under the trademark WEBSPHERE, from BEA Systems, Inc. under the trademark WEBLOGIC, or from Lotus under the trademark LOTUS DOMINO SERVER.","In the example transaction, the business logic of the web application server  processes the incoming request and provides authentication and\/or identification of the client system . Once the business logic implemented by the web application server  determines that the client may proceed with the purchase, it communicates another request via a network  to a database server  to decrement the inventory. The database server  processes the request, accesses its database  and prepares a response to the web application server . Examples of database servers include, but are not limited to those sold by Microsoft under the trademark SQL\/SERVER or TRANSACTION SERVER and by IBM Corporation under the trademark DB2UNIVERSAL DATABASE SERVER.","The web application server  receives the response from the database server  and returns it via the network  to the client system . The client system  then processes the response to format it for display and presents the response for the transaction initiator to review.","An administrator  observes the various software and hardware components, through which the business transaction is processed, located at the site of the service provider to determine if they function properly. In case of an outage  occurring at the database , such as a corrupted tablespace or a failure of the database runtime system, the task of the administrator  is to locate the cause of the outage, correct the problem and verify if the overall system is functioning properly again. It is to be understood that the invention is intended to operate with any form of outage or performance degradation.","The administrator  interacts with the software and hardware components either directly or through a management system that processes the administrative information (such as status and health data) exposed by software and hardware components at a well-defined management interface. In either case, it is important to note that the hardware and software components are perceived by the administrator as isolated resources and not as being part of an overall system serving a specific business purpose.","In particular, errors occurring in one component may not be noticed because the administrator does not become aware of them due to lack of continuous monitoring. In addition, absent the techniques of the invention, no explicit information regarding the interdependencies between the various components is available to an administrator in a straightforward way. Thus, it is possible that an error within a component, which is not continuously monitored may go unnoticed until the failure propagates to a monitored component.","In case of the aforementioned database outage , an administrator may eventually only become aware of the outage if the web application server  is not functioning properly anymore (for example, the load on the web application server increases drastically because it continuously retries to connect to the database server , and is unable to complete the requests sent by the client system ). Thus, the administrator  would first examine the web application server , then determine if there is a network  connectivity problem and finally verify if the database server  is experiencing difficulties that might stem from an internal error in the database .","The client-server application architecture described above can be regarded as a precursor to an emerging computing environment referred to by IBM Corporation as an \u201cautonomic\u201d computing environment. P. Horn, \u201cAutonomic Computing: IBM's Perspective on the State of Information Technology,\u201d IBM Research, October 2001, the disclosure of which is incorporated by reference herein, defines autonomic computing as a comprehensive and holistic approach to self-managed computing systems with a minimum of human interference. The term derives from the body's autonomic nervous system, which controls key functions without conscious awareness or involvement. More specifically, one of the goals of autonomic computing is to automate some or all of the tasks an administrator  would typically carry out. Motivation for doing so is as follows.","As computing evolves, the overlapping connections, dependencies, and interacting applications call for administrative decision-making and responses faster than any human can deliver. Pinpointing root causes of failures becomes more difficult, while finding ways of increasing system efficiency generates problems with more variables than any human can hope to solve. The problem of identifying and tracking dependencies between different systems of an autonomic computing environment may be characterized in the following way. Since a system can exist at many levels, an autonomic system needs detailed knowledge of its components, current status, ultimate capacity, and all connections with other systems to govern itself. Those skilled in the art will appreciate that the present invention may be performed in an autonomic computing environment.","Referring now to , a block diagram illustrates a system for providing dependency management according to an embodiment of the present invention. More specifically,  depicts a dependency management system that addresses the aforementioned issues. The system comprises four layers (application layer , service layer , middleware layer  and resource layer ) and an administrator graphical user interface  by which an administrator  interacts with the system.","The lowest layer is the resource layer . The resource layer  comprises managed resources , a resource dependency repository  and a repository agent . Examples of managed resources  include, but are not limited to, physical and logical hardware components (examples of the former are hard disks, random access memory, central processing units, network adapters, channel controllers, etc.; examples of the latter are disk partitions, file systems, etc.) and software components (such as operating system, system services like print spoolers or name services, and end-user applications).","The resource dependency repository  contains the inventory of the hardware and software components of every managed resource  and the dependency information on a per-resource basis (i.e., the dependencies between the components within a managed resource ). The resource dependency repository  can be either co-located with every individual managed resource  or reside at a centralized location. The resource dependency repository  can be queried, updated and modified through a repository agent , which makes the information of the resource dependency repository  available to other components of the system.","The middleware layer  comprises a management communication infrastructure  such as the protocols and object request brokers by which the different components of the system exchange (management) information.","The service layer  comprises various generic management services  such as policy, event and directory, which can be used by a variety of management applications. A specifically important service is the dependency service , which retrieves information, both from the managed resources  and from the repository agent , and processes this information to establish an end-to-end dependency model of the overall resource environment. This model (or parts of it) is stored in the end-to-end dependency repository , according to the needs (e.g., caching for faster retrieval) of the dependency service . Note that the dependency service  is the only component in the described system that directly interacts with the end-to-end dependency repository .","The application layer  comprises various management applications that use the generic management services  and\/or the dependency service . Examples of such management applications include, but are not limited to, fault manager , topology generator , impact analyzer , impact simulator  and root cause analyzer .","The root cause analyzer  determines the root cause of an outage (i.e., the component that initially caused the outage) based on traversing the dependency model (provided by the dependency service ) from a component affected by an outage towards its antecedents. The root cause analyzer may employ the techniques disclosed in the above-referenced and concurrently-filed U.S. patent application identified by Ser. No. 10\/241,213 entitled: \u201cMethods And Apparatus For Root Cause Identification and Problem Determination in Distributed Systems.\u201d However, other root cause analysis techniques may be employed.","The impact analyzer  determines the impact of an outage (i.e., the components that are likely to be affected by the outage) based on traversing the dependency model (provided by the dependency service ) from a component experiencing an outage towards its dependents. The impact analyzer may employ the techniques disclosed in the above-referenced and concurrently-filed U.S. patent application identified by Ser. No. 10\/241,214 entitled: \u201cMethods And Apparatus For Impact Analysis and Problem Determination.\u201d However, other impact analysis techniques may be employed.","The impact simulator , based on the impact analyzer , allows an administrator  to carry out a \u201cwhat-if\u201d analysis by simulating the effects of an outage of a specific component on the overall system. This enables the provisioning of appropriate failover solutions. The impact simulator may employ the techniques disclosed in the above-referenced and concurrently-filed U.S. patent application identified by Ser. No. 10\/241,397 entitled: \u201cMethods And Apparatus For Dependency-based Impact Simulation and Vulnerability Analysis.\u201d However, other impact simulation techniques may be employed.","The fault manager  performs appropriate \u201csanity checks\u201d or tests on components that have been identified either by the root cause analyzer  or the impact analyzer  as candidates for a failure. That is, the fault manager can perform such tests upon the direction of the root cause analyzer  or the impact analyzer  (i.e., serve as an interface for these modules), and report back results thereto. However, the root cause analyzer  or the impact analyzer  can perform their own tests independent of the fault manager.","It is to be understood that the fault manager is preferably comprised of a collection of application-specific or resource-specific tools that allow a determination to be made whether the component that is being tested is working properly or not. Thus, after testing the component with a related tool, the fault manager may return a message indicating whether the component \u201cworks\u201d or \u201cdoes not work.\u201d These tools may be automated and\/or manual. By way of one automated example, a so-called \u201cping\u201d program checks network connectivity. If the subject remote system answers to a ping, it is online and its network protocol stack (and all the underlying hardware, e.g., network adapter, cables, intermediate network components, etc.) works. If the remote system does not answer, it is known that at least something is wrong and another (set of) tool(s) may be employed to determine the problem. Thus, the fault manager may employ the ping program, as well as any number and type of other tools needed to test components of the distributed computing environment (e.g., heartbeat detection, status indication, etc.).","The topology generator  establishes (a subset of) the overall topology of a distributed system, comprising a vast amount of highly dynamic components, such as web applications, database instances and transactions. An example for using the topology generator  is to display the components of a distributed system that are involved in fulfilling the requests of a specific client system . The dependency model (or parts of it) is stored in the topology database , according to the needs (e.g., caching for faster retrieval) of the topology generator . Note that the topology generator  is the only component in the described system that directly interacts with the topology database . The topology generator may employ the techniques disclosed in the above-referenced and concurrently-filed U.S. patent application identified by Ser. No. 10\/241,189 entitled: \u201cMethods And Apparatus For Topology Discovery and Representation of Distributed Applications and Services.\u201d However, other topology generation techniques may be employed.","Referring now to , a block diagram is shown illustrating a generalized hardware architecture of a computer system suitable for implementing the various functional components\/modules of a system for providing dependency management as depicted in the figures and explained in detail herein. It is to be understood that the individual components of the dependency management system, namely, components associated with the graphical user interface , the application layer , the service layer  and the middleware layer  (FIG. A), may be implemented on one or more computer systems having an architecture as shown in FIG. B. The other components shown in , e.g., the components associated with the resource layer , may also be implemented on similar computer systems.","As shown, the computer system may be implemented in accordance with a processor , a memory  and I\/O devices . It is to be appreciated that the term \u201cprocessor\u201d as used herein is intended to include any processing device, such as, for example, one that includes a CPU (central processing unit) and\/or other processing circuitry. The term \u201cmemory\u201d as used herein is intended to include memory associated with a processor or CPU, such as, for example, RAM, ROM, a fixed memory device (e.g., hard drive), a removable memory device (e.g., diskette), flash memory, etc. In addition, the term \u201cinput\/output devices\u201d or \u201cI\/O devices\u201d as used herein is intended to include, for example, one or more input devices (e.g., keyboard) for entering data to the processing unit, and\/or one or more output devices (e.g., CRT display and\/or printer) for presenting results associated with the processing unit.","It is also to be understood that the term \u201cprocessor\u201d may refer to more than one processing device and that various elements associated with a processing device may be shared by other processing devices.","Accordingly, software components including instructions or code for performing the methodologies of the invention, as described herein, may be stored in one or more of the associated memory devices (e.g., ROM, fixed or removable memory) and, when ready to be utilized, loaded in part or in whole (e.g., into RAM) and executed by a CPU.","Referring now to , a block diagram illustrates a functional dependency model of services according to an embodiment of the present invention. More specifically,  depicts a functional application dependency graph between various components in an electronic commerce system such as the one depicted in FIG. . This functional dependency model represents both the functional components of a distributed system and their dependencies. Thus, the model defines dependencies between generic services, which are considered atomic from a business perspective. This implies that the functional model is not concerned with dependencies occurring within a business service. Such a decomposition makes sense in the scope of a specific product being used to implement the service and will be discussed in more detail with reference to FIG. .","Dependencies between components are depicted as arrows. An arrow always points from the dependent to the antecedent. Functional components are the (sub-) services that a service provider needs to deploy for providing an end-to-end service to a customer, the latter being defined in a service level agreement. The functional model focuses on the design of an end-to-end service and abstracts from the details of an end-to-end service's technical realization, such as the products being used for the service offering, their location (local or remote system), the provider domain (i.e., whether the provider itself outsources some of its services to another service provider, transparent to the customer), etc.","As shown, an e-business application  service depends on a web application service  for hosting the business logic. In order to function properly, the web application service  requires two further services. The static content of the electronic commerce website is provided by a web service , while a back-end database service  stores the dynamic content (such as product descriptions, user and manufacturer data, shopping carts, user profiles and preferences, payment information, etc.) of the e-business application  being offered to a customer. The web service  depends, itself, on two services, namely, the name service  for mapping host names to IP addresses, and the IP service  for network connectivity.","Recall that dependency relationships are transitive, i.e., the dependent of a given component requires, in addition to the component itself, also the components' antecedent(s). Consequently, in addition to the IP service  and the database service , all the depicted services require the presence of an operating system (OS)  service. For the sake of brevity, the dependency relationships of an OS  on hardware components is not depicted, although they are present in a functional model.","Referring now to , a block diagram illustrates a structural dependency model of services according to an embodiment of the present invention. More specifically,  depicts a structural application dependency graph between various components in an electronic commerce system such as the one depicted in FIG. .","This structural dependency model extends the functional model () in the following ways. The structural dependency model deals with the implementation of a business service and is focused on concrete products and their logical (modules, components) and physical (files, shared libraries) architecture. The structural dependency model captures the detailed descriptions of software components, i.e., the system inventory, which is usually recorded in the various system repositories or in well-defined places, e.g., the configuration files of a managed resource .","Note that although the structural model deals with the components of a single system, it may maintain references to services and applications hosted by other systems, because the configuration files located on the system may contain this information. Examples of system repositories include, but are not limited to, the IBM AIX Object Data Manager (ODM), the Linux Red Hat Package Manager (RPM) or the Microsoft Windows Registry. Information relating to software components is typically captured during the installation and deployment of a software package. In addition, the structural model contains the dependencies between the various system components, depicted as arrows. For the sake of clarity, the names of the business services are written without quotes, while the names of the elements of the structural model are written with quotes in FIG. .","The system with the fully qualified domain name wslab8.watson.ibm.com  hosts the following components: the e-business application (a business service defined in the functional model), which is implemented as storefront servlets , the latter encapsulate the business logic of the application. The web application service is implemented by IBM WebSphere version 3.5 , while the web service is realized by the IBM HTTP Server version 1.3.6 . The IP service is implemented by the default IP protocol stack , the operating system (OS) is Win(dows) NT version 4 .","The system with the fully qualified domain name rslab2.watson.ibm.com  hosts the following components: a database service implemented by (IBM) DB2 Universal Database (UDB) version 5.2 , and an operating system, here (IBM) Advanced Interactive Executive (AIX) version 4.3.3 .","Referring now to , a block diagram illustrates a service lifecycle addressed by functional, structural and operational dependency models according to an embodiment of the present invention. More specifically,  depicts the relationships between a functional model  and a structural model , described above, and introduces a third dependency model, an operational model . These three models enable the invention to track the services during their whole lifecycle, i.e., from the design stage to the installation and deployment stage, to the operational or runtime stage.","As explained above, the functional model  relates to the design of the business services and is thus captured at the design time of a business system. Once the system described by the functional model  becomes instantiated or deployed (step ), the structural model  is established. The operational model  is created when the various components of the structural model  become instantiated (step ) and when runtime bindings between them are established. The operational model represents the characteristics of the previously described models at runtime. Several scenarios that illustrate the aforementioned concepts will now be described.","The web application service  is implemented by IBM WebSphere ; one or more instances of the latter are referred to as websphere-daemon . Here, the web (or WWW) service  is implemented by two products, namely, Apache 1.3.4  and Lotus Domino . The running instances of these products can be identified as http daemons \u201chttpd\u201d . The database service  is implemented by two products, namely, Oracle v7  and DB2 UDB ; however, no instances of Oracle v7  are active because no server processes are visible in the operational model . In contrast, four instances of DB2 UDB  are running, as can be seen from the presence of four DB2 daemons \u201cdb2d\u201d  in the operational model . The name service  is implemented by BIND version 5.6 ; the running instance of BIND can be observed as \u201cnamed\u201d  in the operational model .","Note that the dependencies are propagated from the functional to the structural and the operational model. This is necessary because it is not possible to determine from a running application instance which other application instance(s) it requires to function properly.","Due to the short-livedness of some application instances, the operational model  is highly dynamic and potentially very large. In contrast to the functional and structural dependency models, the operational model  is not stored in a repository or a database, but computed on demand and to the extent needed.","Referring now to , a block diagram illustrates relationships between functional, structural and operational dependency models according to an embodiment of the present invention. More specifically,  depicts the details of the data template used for the three dependency models and the means for tying these models together by an example. The example details the template and its associated values for describing the name service during its lifecycle.","The functional template , used for the functional model  contains the \u201chostName\u201d (the unique name of the computer system that hosts the service), the \u201cserviceName\u201d (name of the service) and the \u201ccomponentType\u201d (the role in which this service acts, i.e., client or server). With this information, a service can be uniquely identified within a distributed environment. However, further fields containing descriptive data (such as a description of the purpose of the service, the customer that subscribes to this service, etc.) may be added without departing from the spirit of the present invention. Finally, the \u201cAntecedent\u201d field contains the service(s) this service requires for proper functioning.","The structural template , used for the structural model , contains all the fields of the functional template , which allows to link the functional template  with the structural template  in order to navigate from the functional model  to the structural model , and vice-versa. In addition, the structural template  contains the \u201ccomponentName\u201d (the name of the product component), an \u201cidentifier\u201d (a globally unique name for identifying the component), the \u201cversion,\u201d \u201crelease\u201d and \u201cmodification\u201d (e.g., maintenance or patch\/fix level) numbers, the \u201cinstallState\u201d (indicating whether the component has been successfully and completely installed) and \u201cprocessName\u201d (the name of the process(es) that identify this product component at runtime). Furthermore, the \u201cAntecedent\u201d field lists the component(s) this component requires to be operable.","The operational template , used for the operational model , contains the fields \u201chostName\u201d (the unique name of the computer system that hosts the service) and \u201cprocessName\u201d (the name of the process(es) that identify the product component at runtime). These two fields link the structural template  with the operational template  in order to navigate from the structural model  to the operational model , and vice-versa. In addition, the operational template  contains the fields \u201coperState\u201d (the operational state of the process, i.e., running, interrupted, zombie, etc.), \u201cportNumber\u201d (the number of the TCP\/UDP port by which an application can connect to the process), and, \u201cinstanceID\u201d (to distinguish the various application instances within the scope of a computer system).","The three dependency models are stored and computed at different places to achieve a maximum degree of efficiency. The functional model  is gathered and stored at the management system , i.e., the central point of control by which the administrator  interacts with the distributed environment. Some of the reasons for this choice are as follows. As seen in the descriptions of FIG.  and , the functional model  is fairly compact because the amount of possible business services is limited. In addition, the functional model is not subject to overly frequent changes. The functional model is defined at the time when a business service is provided to a customer and remains unchanged until the service offering period ends. Since the administrator  is responsible for setting up and updating the functional model , it is a natural choice to keep it close to the management system .","As mentioned in the description of FIG.  and , the structural model , in contrast, captures the detailed descriptions of software components, i.e., the system inventory, which is usually recorded in the various system repositories or in well-defined places, e.g., the configuration files of managed resource . Consequently, it is both large sized (the content of a system repository tends to be between several hundred kilobytes and up to a few Megabytes) and also subject to frequent changes. Therefore, keeping the structural model  of a system at the managed resource , itself, eliminates both the communication overhead for updating the model and the need for vast amounts of storage that would occur if the structural models  of all managed resources () is stored at a centralized place.","The operational model  has been described in  as very dynamic and also extremely large because it covers potentially multiple instances of every application present on the computer systems of the distributed environment and the dependency relationships between them. Given the fact that current data centers of Internet\/Application\/Storage Service Providers and outsourcers consist of several thousands of computer systems with each hosting close to 100 applications and system services, an operational model comprising all the currently instantiated applications and their dependencies may be impractical. Thus, a practical approach is to compute the relevant parts of the operational model on demand (step ). This is the purpose of the dependency service , whose functioning is detailed in FIG. .","Referring now to , a block diagram illustrates components involved in computing end-to-end dependencies according to an embodiment of the present invention. More specifically,  depicts the data flows between the various components used for querying and computing end-to-end dependencies. It is assumed that the managed resources  are able to provide XML (Extensible Markup Language) descriptions of their system inventory, configuration files and their various dependencies. However, it should be noted that any data description format may be used in accordance with the invention. The details on how this information can be acquired are as follows.","One straightforward way is to provide appropriate instrumentation within the system and its applications and services. This information is described in flat XML files  and made available to the other components of the system through a web server .","Alternatively, the dependency service  makes use of information stored in system repositories  for generating appropriate service dependency information. This information is made available to the other components of the system through a web server .","Third, the managed resources  expose their information by means of an instrumentation agent, called CIM provider , which interacts with a CIM Object Manager (CIMOM) , as proposed by the Distributed Management Task Force (DMTF). The CIMOM then exposes the necessary information to the interested components.","In the center of , various management services, being part of the service layer , are depicted. These are: a name service , a trader service , an event service  and the dependency service . The dependency service , triggered by queries of the administrator  through its management system or any management application located in the application layer  using a communication protocol (e.g., Java Remote Method Invocation (RMI)), processes them and sends the results back to the administrator . The main tasks of the dependency service  are as follows:\n\n","As mentioned above, due to its fully distributed nature, the invention aims at keeping the load on every involved system as low as possible. The invention decouples the management system from the managed resources  and encapsulates the time consuming filter and join operations in the dependency service , which can be replicated on various systems. It is therefore possible to achieve a maximum level of parallelism for query operations, since the selection of an instance of the dependency service  can be done flexibly by the management system.","Another important advantage is that the (very large and highly dynamic) operational model  is not stored at a specific place but computed on demand in a stepwise manner. The different parts of the structural model  are stored at the managed resources . The management system therefore always receives the most recent information but is still free to store it according to elaborate caching policies.","Referring now to , a block diagram illustrates components of a dependency service according to an embodiment of the present invention. More specifically,  depicts components that implement the dependency service . As shown, an information provider  interacts with management applications of the application layer . The information provider  receives queries  over Java RMI and sends its results back as an XML document . Queries  may either be related to basic information (such as the descriptions of services and components or the retrieval of values of specific attributes) or deal with more complex issues (such as drill-up or drill-down operations on a dependency model).","A resource proxy  is responsible for obtaining the managed resources' XML descriptions  by interfacing with resource web servers . The resource proxy  does so by sending a query over http (step ) to the resource web servers . Upon receipt of the XML descriptions , the resource proxy  parses them and applies the query expressions (such as selection and filtering rules) to them and forwards the results to a query resolver .","The task of the query resolver  is to maintain a map to locate, for a given hostname, which resource proxy  is able to service the request and to forward this request to the appropriate resource proxy .","Element URI resolver  is responsible for constructing the uniform resource identifier (URI) for a given hostname and delivering the result back to the invoker, which can be either the information provider  or the query resolver .","XML subclass resolver  is a helper module responsible for locating the elements of a specific type according to the type system defined within an XML Schema . Examples for this are querying all the elements within one or more XML documents having the type \u201cService\u201d (such as web application service, web service or name service), having the type \u201cHost\u201d (the hosts on which services and dependencies are located), or having the type \u201cDependency.\u201d","Referring now to , a flow diagram illustrates steps of actions for invoking a dependency service (e.g., dependency service ) and collecting its results according to an embodiment of the present invention. This methodology is initiated either by an administrator  or a management application being part of the application layer , as described in FIG. A.","The methodology begins at block  and proceeds as follows. First, a business service is selected (step ), typically from the functional model, since an administrator is interested in the business services provided by the distributed system. Upon selection of a business service, the structural model is queried to provide a selection of hosts that are involved in the provisioning of the business service. This can be either done by locating the structural models present on every host of the distributed system, or (for efficiency purposes) by querying a (periodically updated) service\/host lookup table stored at the management system, which contains a mapping between the services and hosts present in the distributed system. The administrator then selects a host at his discretion (step ).","In addition, the administrator composes a query (step ). Examples of query parameters include, but are not limited to, the direction of the traversal (towards the service dependents, or towards its antecedents), the depth of the traversal (e.g., only the immediate antecedents\/dependents; the overall possible antecedents\/dependents, i.e., the complete transitive closure of the operational model; only between the m-th and n-th layers of the operational model), filtering criteria related either to the presence of attributes or to their values.","The fact that the order of the steps for selecting service (step ), host (step ) and the options for composing the query is prescribed here, emphasizes the \u201cservice-centric\u201d approach (versus the \u201chost-centric\u201d approach of existing art) of the present invention. However, one having skill in the relevant art will recognize that modifications in the order of steps (steps ,  and ) may be made without departing from the spirit and scope of the present invention.","Examples of such modifications are: to offer the user (e.g., by means of a graphical user interface) the choice of performing the three steps of the selection process in an arbitrary order; allowing at first the selection of a host and then looking up the services present on that host by means of querying the structural model, thereby restricting the possible service candidates for selection.","After the service and host selection and the composition of the query, the dependency service is invoked (step ) with these parameters. Note that the mode of invocation can be either synchronous (i.e., blocking the invoker until the results are returned by the dependency service) or asynchronous (thus allowing the invoker to perform additional tasks during the computation).","The dependency service computes the appropriate part of the operational model and, depending on the mode of invocation, either sends the results back to the invoker or notifies the invoker that the results are available. The invoker then collects the results (step ) and processes them further. The methodology ends at block .","Referring now to , a flow diagram illustrates tasks of an administrator for creating and updating a functional dependency model according to an embodiment of the present invention. This is necessary either if new (business) services are deployed and offered, or changes are applied to an existing model, or existing (business) services are withdrawn from an offering.","The methodology begins at block  and proceeds as follows. An administrator or a management application evaluates whether a new business service should be added or an existing service is to be deleted (step ). If this is not necessary, the methodology proceeds directly to block . Otherwise, in step , the service and its description are entered in (or removed from) the template  of the functional model, which has been described in FIG. .","Then, in step , the service dependencies, i.e., its relationships regarding its antecedents, need to be added to (or removed from) the template  of the functional model. In case of a deletion, note that the dependencies from the service dependents need to be adjusted to point to the antecedents of the service that is to be removed. This may involve checking for eventual duplicate descriptions within the dependencies of the antecedents. Finally, the updated functional model is stored in the repository of the management system (step ). The methodology ends at block .","Referring now to , a flow diagram illustrates steps of updating a structural dependency model by installing or removing hardware\/software components on a computer system according to an embodiment of the present invention. This is necessary either if new components are deployed and installed on a host, or existing components are removed from the host.","The methodology begins at block  and proceeds as follows. If new hardware components are installed\/removed, the verification and adjustment of their dependencies is usually performed by the operation system and is thus not described further here. Instead, the following description focuses on the task of adding\/removing software components. An administrator or a management application performing software distribution and installation evaluates whether a new software component should be added or an existing software component is to be deleted (step ). If this is not necessary, the methodology proceeds directly to block . Otherwise, in step , the software components' descriptions are entered in (or removed from) the template  of the structural model, which has been described in FIG. . Then, in step , the software components' dependencies, i.e., its relationships regarding its antecedents, needs to be added to (or removed from) the template  of the structural model.","In case of a deletion, note that the dependencies from the software components' dependents need to be adjusted to point to the antecedents of the software component that is to be removed. This may involve checking for eventual duplicate descriptions within the dependencies of the antecedents. Finally, the updated structural model is stored in the resource dependency repository of the host (step ). The methodology ends at block .","Referring now to , a flow diagram illustrates steps of the system responsible for the computation of the operational model according to an embodiment of the present invention. The methodology begins at block  and proceeds as follows.","The system performing the computation of the operational dependency model is continuously listening for requests at a specific port of the host on which the system is executed, which is illustrated by the loop that connects block  with itself. This is the standard behavior for server processes (\u201cdaemons\u201d) that implement services, which can be invoked by applications at any time.","On reception of a request, the system extracts the input parameters from the request (step ). As mentioned in the description of , examples of input parameters include, but are not limited to, the names of the service and the host in question, the direction of the traversal, the depth of the traversal, filtering criteria related either to the presence of attributes or to their values. These input parameters are then used to perform the actual computation of the operational model (step ).","The results of the computation, i.e., the operational model, are then delivered to the invoking application, in accordance with the mode of invocation specified at the time of the invocation (step ). After this step, any allocated resources of the host on which the system is running, are released (step ). Examples of host resources include, but are not limited to, memory, disk space or CPU registers. Finally, the system returns back to its initial stage and listens for subsequent incoming requests ().","Referring now to , a flow diagram illustrates steps of retrieving direct antecedents of a service located on a specified host according to an embodiment of the present invention. The methodology begins at block  and proceeds as follows.","First, the names of the targeted service and the host are obtained (step ). These parameters are provided by the invoking management application, which obtains these parameters either directly from the administrator or from an event message that arrives at the management console. Then, the element containing the service description is located in the structural model of the specified host (step ).","Then, an evaluation (step ) of the antecedent property of the structural template  of the given service, as described in , reveals whether this service has any antecedents. If the antecedent property is empty, i.e., the element does not have antecedents, the service element itself is added to the operational model (step ). An invoking management application interprets this as a service being dependent only on itself. The methodology then proceeds directly to block .","If, however, the antecedent property contains one or more elements, the service has antecedents. Thus, the methodology proceeds to block , which adds the service element to the operational model. In addition, a dependency element is added to the operational model (step ). Within the scope of the dependency element, the list of (one or more) antecedent elements are added (step ) by copying the content of the antecedent property of the structural template  into the operational model right after the dependency element. A typical example of such an implementation is to define the dependency element as an XML tag, adding the list of antecedents, and then closing the XML tag. The methodology ends at block  by sending the content of the operational model to the invoker.","Referring now to , a flow diagram illustrates steps of retrieving recursively antecedents of a service located on a specified host according to an embodiment of the present invention. More specifically,  illustrates the use of a depth-first strategy in recursively retrieving every (i.e., direct or indirect) antecedent of a service located on a specified host. Note that recursive queries may span system or even provider boundaries e.g., if a client\/server binding points to another system.","The methodology begins at block  and proceeds as follows. First, the names of the targeted service and the host are obtained (step ). These parameters are provided by the invoking management application or API function, which obtains these parameters either directly from the administrator or from an event message that arrives at the management console.","Then, the element containing the service description is located in the structural model of the specified host and entered into a service list (step ). After completion of this step, it is evaluated whether the service list is empty (step ). If the service list contains elements, the first element of the list is chosen, added to the model (step ) and deleted from the list.","An evaluation of the antecedent property of the structural template  of the given service, as described in , reveals whether this service has any antecedents. The elements listed in the antecedent property are then put into a separate list, the antecedent list (step ), which can be empty.","The methodology then proceeds directly to block , which evaluates whether the antecedent list contains any elements. If the antecedent list is empty (i.e., the service does not have any further antecedents), the methodology proceeds back to block  to continue with the next entry in the service list, if present.","If, however, the antecedent list contains one or more elements, the service has antecedents. Thus, the methodology proceeds to block , which removes the antecedent service from the antecedent list and inserts it at the beginning of the service list in order to enable a depth-first traversal of the graph structure. Furthermore, the antecedent (and a link representing the actual dependency) is added to the operational model (step ). This part of the methodology is executed until the antecedent list is empty. If this is the case, the methodology proceeds to block  and proceeds with the (eventually extended) service list. The methodology ends if the service list is empty (block ) by sending the content of the operational model to the invoker.","Referring now to , a flow diagram illustrates steps of retrieving direct dependents of a service located on a specified host according to an embodiment of the present invention. The methodology begins at block  and proceeds as follows.","First, the names of the targeted service and the host are obtained (step ). These parameters are provided by the invoking management application, which obtains these parameters either directly from the administrator or from an event message that arrives at the management console. Then, the element containing the service description is located in the structural model of the specified host (step ).","Then, a search for all the elements whose antecedent is the target service element reveals whether this service has any dependents. If the result is empty (step ), i.e., the element does not have dependents, the service element itself is added to the operational model (step ). An invoking management application interprets this as a service being dependent only on itself. The methodology then proceeds directly to block .","If, however, a search for all the elements whose antecedent is the target service element yields one or more elements, the service has dependents. Thus, the methodology proceeds to block , which adds the service element to the operational model. In addition, a dependency element is added to the operational model (step ). Within the scope of the dependency element, (one or more) dependent elements are added (step ) to the operational model right after the dependency element. A typical example of such an implementation is to define the dependency element as an XML tag, adding the list of dependents, and then closing the XML tag. The methodology ends at block  by sending the content of the operational model to the invoker.","Referring now to , a flow diagram illustrates steps of retrieving recursively dependents of a service located on a specified host according to an embodiment of the present invention. More specifically,  illustrates the use of a depth-first strategy in recursively retrieving every (i.e., direct or indirect) dependent of a service located on a specified host. Note that recursive queries may span system or even provider boundaries e.g., if a client\/server binding points to another system.","The methodology begins at block  and proceeds as follows. First, the names of the targeted service and the host are obtained (step ). These parameters are provided by the invoking management application or API function, which obtains these parameters either directly from the administrator or from an event message that arrives at the management console. Then, the element containing the service description is located in the structural model of the specified host and entered into a service list (step ).","After completion of step , it is evaluated whether the service list is empty (step ). If the service list contains elements, the first element of the list is chosen, added to the model (step ) and deleted from the list. An evaluation of the antecedent property of all structural templates  for the presence of the current element of the service list, as described in , reveals whether this service has any dependents.","The service names of the elements in whose antecedent property the service in question appears are then put into a separate list, the dependent list (step ), which can be empty. Alternatively, if the structural templates  contain a dependents property (i.e., the dependencies are represented with bi-directional links), the content of the dependents property is copied in the dependent list.","The methodology then proceeds directly to block , which evaluates whether the dependent list contains any elements. If the dependent list is empty (i.e., the service does not have any further dependents), the methodology proceeds back to block  to continue with the next entry in the service list, if present.","If, however, the dependent list contains one or more elements, the service has dependents. Thus, the methodology proceeds to block , which removes the dependent service from the dependent list and inserts it at the beginning of the service list in order to enable a depth-first traversal of the graph structure. Furthermore, the dependent (and a link representing the actual dependency) is added to the operational model (step ). This part of the methodology is executed until the dependent list is empty. If this is the case, the methodology proceeds to block  and proceeds with the (eventually extended) service list. The methodology ends if the service list is empty (block ) by sending the content of the operational model to the invoker.","Referring now to , examples of dependency service application programming interfaces (APIs) are depicted according to an embodiment of the present invention. The table includes base APIs that can generate, send and request receipt of appropriate operational models for a given service and host name. Those skilled in the art will appreciate that the APIs can use one or more parameters (not shown) to identify characteristics (specified in the Functional Description) used by the APIs.","Specifically, a \u201cgetAntecedents(parameters)\u201d API retrieves direct antecedents of a service located on a specific host. The \u201cgetAntecedentsRecursive(parameters)\u201d API performs a recursive \u201cdrill-down,\u201d i.e., it retrieve all the antecedents of a given service, which is located on a specific host. The \u201cgetDependents(parameters)\u201d API retrieves the direct dependents of a given service, which is located on a specific host. The \u201cgetDependentsRecursive(parameters)\u201d API performs a recursive \u201cdrill-up,\u201d i.e., it retrieves all the dependents of a given service, which is located on a specific host. The \u201cgetServiceDependencies(parameters)\u201d API yields a list of all recursive dependencies for a specific service (i.e., both antecedents and dependents).","The \u201cgetTransactionDependencies(parameters)\u201d API retrieves a list of hardware and software components and their dependencies taking part in a specific transaction. The \u201cgetTransactionComponents(parameters)\u201d API retrieves a list of hardware and software components taking part in a specific transaction. The \u201cgetHostDependencies(parameters)\u201d API yields a list of all recursive dependencies for all services, which are located on a specific host. The \u201cgetHostComponents(parameters)\u201d API retrieves a list of hardware and software components installed on a specific host. The getExternalServiceDependencies(parameters) API yields a list of all recursive dependencies for a specific service (i.e., both antecedents and dependents) crossing a domain boundary, i.e., under the control of another service provider. Finally, the \u201cgetReferencingDependencies(parameters)\u201d API returns the references of the dependencies both upwards and downwards for a given service on a host.","Although illustrative embodiments of the present invention have been described herein with reference to the accompanying drawings, it is to be understood that the invention is not limited to those precise embodiments, and that various other changes and modifications may be made by one skilled in the art without departing from the scope or spirit of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"P-00027","num":"00027"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00028","num":"00028"},"figref":"FIG. 2A"},{"@attributes":{"id":"P-00029","num":"00029"},"figref":"FIG. 2B"},{"@attributes":{"id":"P-00030","num":"00030"},"figref":"FIG. 3"},{"@attributes":{"id":"P-00031","num":"00031"},"figref":"FIG. 4"},{"@attributes":{"id":"P-00032","num":"00032"},"figref":"FIG. 5"},{"@attributes":{"id":"P-00033","num":"00033"},"figref":"FIG. 6"},{"@attributes":{"id":"P-00034","num":"00034"},"figref":"FIG. 7"},{"@attributes":{"id":"P-00035","num":"00035"},"figref":"FIG. 8"},{"@attributes":{"id":"P-00036","num":"00036"},"figref":"FIG. 9"},{"@attributes":{"id":"P-00037","num":"00037"},"figref":"FIG. 10"},{"@attributes":{"id":"P-00038","num":"00038"},"figref":"FIG. 11"},{"@attributes":{"id":"P-00039","num":"00039"},"figref":"FIG. 12"},{"@attributes":{"id":"P-00040","num":"00040"},"figref":"FIG. 13"},{"@attributes":{"id":"P-00041","num":"00041"},"figref":"FIG. 14"},{"@attributes":{"id":"P-00042","num":"00042"},"figref":"FIG. 15"},{"@attributes":{"id":"P-00043","num":"00043"},"figref":"FIG. 16"},{"@attributes":{"id":"P-00044","num":"00044"},"figref":"FIG. 17"}]},"DETDESC":[{},{}]}
