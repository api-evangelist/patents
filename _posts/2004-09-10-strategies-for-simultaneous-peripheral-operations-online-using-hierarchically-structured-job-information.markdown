---
title: Strategies for simultaneous peripheral operations on-line using hierarchically structured job information
abstract: Spooling strategies are described for producing job information that conforms to a hierarchical structure, and then storing the job information in a spool storage. The job information is then retrieved from the spool storage and consumed. The structured job information includes a multi-level hierarchy of nodes, including a job level that represents the entire job, a document level that represents a document to be processed within the job; a rendition level that represents a rendition of the document to be processed; and a page level that represents a page associated with the rendition. The hierarchical structure can also include resource nodes and metadata nodes associated with any level of the hierarchy, respectively representing resources and metadata. The hierarchy can optionally be composed using one or more selection and sequence parts. Program logic implements the production and consumption of the job information by providing a collection of logic modules for selectively adding and retrieving elements to the hierarchically structure. The program logic also provides logic for enumerating the contents of the job information and for signaling the occurrence of various events associated with the processing of the job information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08363232&OS=08363232&RS=08363232
owner: Microsoft Corporation
number: 08363232
owner_city: Redmond
owner_country: US
publication_date: 20040910
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims the benefit of the following U.S. Provisional Applications, all filed on May 3, 2004, and each of which is incorporated by reference herein in its respective entirety: U.S. Provisional Application No. 60\/568,071; U.S. Provisional Application No. 60\/567,679; U.S. Provisional Application No. 60\/567,663; U.S. Provisional Application No. 60\/567,890; U.S. Provisional Application No. 60\/567,830; and U.S. Provisional Application No. 60\/567,920.","The present application is also related to co-pending and commonly assigned U.S. patent application Ser. No. 10\/794,669, entitled \u201cMultilevel Ticket-Based Job Management Architecture for Computing Devices,\u201d filed on Mar. 5, 2004, which is incorporated herein by reference in its entirety.","The present application is also related to co-pending and commonly assigned U.S. patent application Ser. No. 10\/836,327, entitled \u201cDocument Mark Up Methods and Systems,\u201d filed on May 1, 2004, which is incorporated herein by reference in its entirety.","This subject matter relates to strategies for producing and consuming job information using spool storage, and, in another implementation, to a format and related interfaces used for producing and consuming job information.","Computing devices commonly render documents using spooling techniques (where \u201cspool\u201d is an acronym for Simultaneous Peripheral Operations On-Line). In a typical spooling technique, a device generates a document and stores it in a spool storage. The spool storage can be implemented using memory (such as RAM memory), or, more commonly, using disk storage. When the device is ready to process the document, the device can then access the document from the spool storage and convert it to a format that is compatible with the format expectations of an output device (such as a format defined by the Page Description Language). The device can then forward the converted document to the output device, whereupon the output device prints the document, or performs some other processing with respect to the document. Storing a document in a spool storage (rather than directly outputting the document to the printer) is generally advantageous because it allows the device to perform other tasks while the document is being processed for printing. Generally, a print job refers to the task of processing an identified document using a spooling strategy. The print job specifies job information to be processed by the spooling strategy.","Conventional strategies commonly generate and consume job information in a variety of proprietary and narrowly tailored formats. The lack of versatility, sophistication and uniformity in these formats can prevent the device from rendering job information in an efficient manner, especially for certain print scenarios to be described below. Known conventional strategies also do not provide techniques for processing job information in an asynchronous manner. Further, known conventional strategies do not provide versatile techniques for associating metadata with the job information. Known conventional strategies may suffer from yet additional unspecified deficiencies.","There is accordingly an exemplary need for more efficient strategies for producing and consuming documents using a spool storage.","A computer readable medium is described having a data structure stored on the computer readable medium. The data structure specifies job information to be processed by a spooling module, the data structure including a plurality of nodes organized into a hierarchical arrangement representing different aspects of the job information.","According to another exemplary aspect, the nodes include: (a) at least one job node representing an entire job to be processed by the spooling module; (b) at least one document node representing a document to be processed, within the job, by the spooling module; (c) at least one rendition node representing a rendition of the document to be processed by the spooling module; and (d) at least one page node representing a page associated with the rendition to be processed by the spooling module.","According to another exemplary aspect, the nodes include at least one resource node associated with at least one of: the at least one job node; the at least one document node; the at least one rendition node; or the at least one page node.","According to another exemplary aspect, the job information includes metadata associated with the at least one job node; the at least one document node; the at least one rendition node; or the at least one page node.","Additional exemplary implementations are described in the following.","The same numbers are used throughout the disclosure and figures to reference like components and features. Series 100 numbers refer to features originally found in , series 200 numbers refer to features originally found in , series 300 numbers refer to features originally found in , and so on.","The following description sets forth exemplary mechanisms for generating and consuming job information that conforms to a hierarchical structure. In a production phrase, the structured job information can be created and stored in a spool storage. In a consumption phase, the job information can then be retrieved from this storage for processing. A collection of application programming interface (API) classes facilitate the production and consumption of the job information. These API classes allow selective addition, retrieval and enumeration of targeted elements within the job information.","The term \u201cjob\u201d used herein refers to a task in which one or more actions are performed to process job information. For instance, a print job may entail printing job information that defines one or more documents. More generally, reference to \u201cprocessing\u201d job information can refer to any kind of rendering of such job information, such as printing or displaying such job information. Alternatively, processing can refer to distributing the job information to a target destination (with or without modifying it), archiving the job information, or some other form of processing. The term \u201cjob information\u201d refers to any kind of information used to specify the nature of the job, such as the actual information to be rendered, and\/or information that defines how the job is to be rendered, and so on.","A \u201cpackage\u201d is a logical concept that refers to a collection of job information that comprehensively specifies an entire job. The package can contain multiple parts, also referred to as \u201celements\u201d or \u201cfeatures\u201d herein. In the case where the job information defines a hierarchical tree of nodes, such nodes may define respective elements in the package. Collections of elements can be treated as a single unit. For instance, a package may specify multiple collections that respectively define different renditions of a single document, and each of these collections can contain multiple elements (e.g., image resources, font resources, etc.).","The term \u201cdocument\u201d as used herein refers to any unit of any kind of information. For example, a document may pertain to information created by a text editing application, a spreadsheet processing program, a drawing program, and so on. Each document can have multiple associated parts, each of which can itself be considered a component document in its own right. A job can specify documents that originate from multiple different sources.","The term \u201crendition\u201d refers to a version of a document. For example, one rendition of a document may correspond to a color version of the document, and another may correspond to a black and white version.","The term \u201cspool storage\u201d represents storage for storing job information implemented using any physical storage medium. In one case, a device may implement the spool storage using RAM memory. In another case, the device may implement the spool storage using disk storage, solid state memory, and so on. The spool storage can be fixed or removable. The spool storage may define a single file, a collection of associated files, or some other storage strategy. A unit of spool storage (such as a single file) that stores an entire package defining a job is also referred to as a \u201ccontainer.\u201d Alternatively, the spool storage can refer to transitory information transmitted via a communication channel and inherently retained by that channel during transport.","More generally, any of the functions described herein can be implemented using software, firmware (e.g., fixed logic circuitry), manual processing, or a combination of these implementations. The terms \u201cmodule,\u201d \u201cfunctionality,\u201d and \u201clogic\u201d as used herein generally represents software, firmware, or a combination of software and firmware. In the case of a software implementation, the terms \u201cmodule,\u201d \u201cfunctionality,\u201d or \u201clogic\u201d represent program code that performs specified tasks when executed on a processing device or devices (e.g., CPU or CPUs). The program code can be stored in one or more fixed and\/or removable computer readable memory devices.","The above-mentioned processing device(s) can be implemented in different ways. For example, the processing device(s) can be implemented using semiconductor transistor-based computing mechanisms (e.g., by electronic integrated circuits (ICs) or fixed electronic logic circuitry). Alternatively, the processing device(s) can be implemented, in whole or in part, using quantum computing mechanisms, optical computing mechanisms, mechanical computing mechanisms, biological computing mechanisms, and so forth.","Certain examples in this disclosure are framed in the exemplary context of an object-oriented programming paradigm. By way of background, in such an approach, an application implements program modules as respective objects. Objects can include properties which convey attributes of the objects (e.g., the characteristics or traits of the objects). Objects can include methods associated therewith that provide functions that can be performed by the objects. Objects interact by passing messages to each other. The object-oriented programming paradigm commonly organizes objects in parent-child hierarchies. A child inherits the properties of its parent. A class refers to a general \u201cblueprint\u201d which describes a collection of objects. However, the principles described herein are not to be construed as limited to an object-oriented programming paradigm.","Finally, certain examples in this disclosure are framed in the exemplary context of a virtual programming environment. A virtual machine (VM) environment executes programs in a manner which is generally independent of the underlying complexities in the platform used to implement the execution. Microsoft Corporation's .NET Framework (provided by Microsoft Corporation of Redmond, Wash.) provides a virtual machine environment with its Common Language Runtime (CLR) functionality. More specifically, the .NET programming involves compiling source code using a compiler. The compiler produces an intermediate language (IL) code and metadata. In an execution phase, the .NET programming model uses a CLR loader and a just-in-time (JIT) compiler to transform the IL and metadata into native code. The native code constitutes the actual machine code that will run on an execution platform (e.g., a specific computing machine). The compilation process provided by the loader\/JIT component is referred to as \u201cjust-in-time\u201d because the compilation can take place just prior to the execution of the code. However, the principles described herein are not to be construed as limited to a virtual programming environment or the .NET programming environment; that is, the features of the spooling strategies described herein are platform-independent, meaning that they can be implemented on any commercial computing platform.","This disclosure includes the following sections. Section A describes an exemplary system for producing and consuming structured job information. Section B describes an exemplary flowchart which explains the operation of the system of Section A. Section C describes an exemplary computer environment for implementing the system of Section A. And the Appendix, Section D, describes exemplary application programming interface (API) functionality for use in the system of Section A.","A. Exemplary System","A.1. Overview of System",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 1","b":["100","102","102","104","102","106","102","108"]},"This Section (i.e., Section A.1) provides an overview of the system  used to produce and consume the structured job information . The next Section (i.e., Section A.2) delves into greater detail regarding the organization of the job information  itself. Section A.3 then provides further information regarding the exemplary programming interfaces used to produce and consume the job information . Section A.4 describes an alternative technique for creating and consuming job information  using selector and sequence building blocks to provide a hierarchy of arbitrary depth.","By way of overview, the system  includes an application module  coupled to a spool storage  via interface functionality  (which can be implemented, in one example, as an application programming interface (API)). The spool storage  stores the job information . This chain of components implements the production aspects () of the processing of the job information . The system  also includes a spooling module  that is configured to retrieve the job information  from the spool storage  and then perform some kind of processing on it to provide an output result. This chain of components implements the consumption () aspects of the processing of the job information . As noted above, processing can refer to any kind of action performed on the job information , which may or may not modify the content of the job information . The processing may comprise printing the job information , displaying the job information , routing the job information  to a target location (with or without modifying it), archiving the job information , and so on. In any case, the recipient of the output result generated by the spooling module  can comprise one or more of the target entities (, , , . . . ) associated with different usage cases . A variety of the usage cases  will be discussed below.","The modules, logic and storage units shown in the system  can be implemented by any variety and grouping of physical mechanisms and devices. In one exemplary case, a computing device (not shown) implements the application module , interface functionality , spool storage  and spooling module . More specifically, the various logic and modules (, , , ) can be implemented by machine readable code stored in the memory of the computing device and executed by the processing unit(s) of the computing device. The spool storage  can be implemented by a storage medium (e.g., a hard disk) provided by the computing device. The computing device can operate using any kind of platform (e.g., as defined by the operating system and\/or other software configuration of the computing device). More specifically, in one implementation, the functionality and associated formats to be described below are specifically configured to operate using different computing platforms, thus defining a standard approach that has wide applicability to different technical environments and which thus serves to facilitate interaction among different technical environments and associated users.","In one case, the target entities (, , , . . . ) can be implemented as devices that are separate from the computing device which implements the other components (-) of the system . The computing device can be communicatively coupled to the target entities (, , , . . . ) via any kind of communication channel, such as USB coupling, parallel coupling, network coupling of any kind, manual transport of removable media, and so forth. In a common case, for instance, one or more of the target entities (, , , . . . ) can comprise printers for printing documents fed to them by the spooling module . The computing device can be communicatively coupled to the printer(s) via any kind of hardwired and\/or wireless links using any kind of communication protocol. Or the spool storage  can be implemented as a removable media and transported to the printer. The target entities (, , ) can alternatively represent display devices, storage devices, other computing devices, and so on.","The above allocation of system  functions to devices is only exemplary. In other implementations, different aspects of the system  can be implemented by separate computing devices. For instance, a first computing device can implement the application module  and a separate computing device can implement the spooling module . In other implementations, the spool storage  can also be implemented as a separate unit which couples to the computing device which implements the application module  and\/or the spooling module . In other implementations, the target entities (, , , . . . ) can be integrated into the same computing device which implements the application module  and\/or the spool module . Still other configurations are possible.","In any event, where one or more computing devices are used to perform aspects of the system , those computing devices can correspond to any type of computing devices (e.g., general purpose computing devices, application-specific computing devices (e.g., game consoles such as Xbox\u2122 game consoles produced by Microsoft Corporation of Redmond, Wash.), portable computing devices (such as a personal digital assistants, mobile phones, etc.), and so on. , to be discussed below in turn, shows one exemplary computer environment for implementing aspects of the system .","Further details regarding each of the above-identified components of the system  will follow. Beginning with the production aspect () of the system , the system  can use any kind of application module  to generate any kind of document. Common types of application modules  include text processing programs, spreadsheet processing programs, graphics processing programs, markup language processing programs, database search and retrieval programs, and so on. There is no constraint on the type of application program that can be used to supply job information  to be processed using the system . The application module  can represent a program implemented in any programming environment; for example, the application module  can be implemented as a managed program within the Microsoft Corporation's .NET programming environment.","The interface functionality  formats the output of the application module  into the structure  of the job information . Generally, exemplary and non-limiting functions performed by the application functionality  can include: (1) persisting the job information  in the spool storage  having the desired structure ; (2) submitting job information  to the spooling module  for scheduling and printing; (3) monitoring different stages of the job production and hooking up to back end notifications to inform any interested listening entities; (4) monitoring different stages of the job consumption and hooking up to back end notifications to inform any interested listening entities; (5) enabling the spooling module  to send output data to the target entities (, , ), and so on. Section A.3 provides further details regarding exemplary logic that can be used to implement the interface functionality . By way of preview, a first collection of classes can be used to create (e.g., \u201cadd\u201d) the job information  in the production phase  of operation, and a second collection of classes can be used to retrieve (e.g., \u201cget\u201d) the job information  in the consumption phase . That is, these classes can be used to selectively add elements (jobs, documents, renditions, pages, resources, metadata, etc.) to the job information , and to selectively get elements (jobs, documents, renditions, pages, resources, metadata, etc.) from the job information . The interface functionality  also provides functionality for retrieving information regarding the job information , and for enabling the generation of notifications for various events pertaining to the production and consumption of the job information .","In one implementation, interface functionality  produces the same uniform structure  regardless of the nature of the application module  which supplies the job data. For instance, the same interface functionality  can transform the output of a text editing application, spreadsheet application, graphics processing program, and so forth into the uniform structure . In another implementation, each application module  may include specifically tailored software to work in conjunction with the interface functionality  to provide the uniform structure . Alternatively, or in addition, the spooling module  can play a role in the generation of the job information  having the uniform structure .","With respect to the consumption () aspect of the system , the system  retrieves the resource information  from the spool storage  and supplies it to the spooling module  for processing. The spooling module  itself can represent a software program implemented by the same computing device that provides the application module . It includes processing logic  for processing the job information . This processing logic , in turn, can include management logic  for governing various operations performed by the processing logic .","The processing logic  can include filter logic  for actually performing the required processing on the job information . As will be described in greater detail below, the filter logic  can include one or more filters (, , . . . ) for performing different processing functions on the job information  to generate an output result. The spooling module  then feeds the final output result to one or more of the target entities (, , , . . . ) via device port logic . In the common case of printing, one or more of the target entities (, , , . . . ) can comprise a printer which receives the output result and prints the document(s) specified by the output result. Finally, the spooling module  can also include generically-labeled other logic  for performing other functions that are not pertinent to the focus of this disclosure and therefore will not be described further herein.","Further details regarding the filter logic  are provided as follows. In one implementation, the job information  that is processed by one or more of the filters (, , . . . ) retains the same format structure  as the job information  stored in the spooler storage . Thus, in this exemplary implementation, the filter logic  does not require that the job information  be converted into an intermediary form in order to process it. This, in turn, enables the spooling module  to processing job information  in an efficient manner. This also yields a uniform approach compared to other techniques which resort to a complicated assortment of disparate and ad hoc processing techniques to deal with different proprietary formats.","The functions performed by the individual filters (, , . . . ) can be generalized in the following manner. A first class of filters accepts job information  which conforms to the structure , performs some kind of processing on this information  (which may or may not modify the information ), and then generates an output result which also conforms to the structure . A second class of filters accepts job information  which conforms to the structure , performs some kind of processing on this information , and then generates an output result which does not conform to the structure  (or which only partially conforms to the structure ). A third class of filters accepts job information  which has already been converted into a non-structured format, and provides yet further modification or processing of such non-structured information.","More specifically, for example, one or more initial filters of the first class can be set up to modify the job information  in various ways (such as by adding a watermark, etc.), but does not otherwise change its basic format structure . A terminal filter (or multiple terminal filters) of the second class can be set up to modify the job information  by changing its format, such as by either completely removing its format structure  or at least partially modifying its format structure . More specifically, the terminal filter n (e.g., filter n ) (or plural terminal filters) can be used to convert job information  having the format structure  into a non-structured form that can be interpreted by an identified target entity (, , , . . . ). In effect, the terminal filter n  (or filters) thus serves the role of a printer driver. For instance, filter n  may convert the job information  having the structure  into a page description language (PDL) format that can be fed to a printer which accepts such format. In another case, a filter n-1 can convert the job information  into a printer-interpretable format, and filter n  can perform post-processing on this format, such that the combination of filter n-1 and filter n can be considered as the printer driver.","Suppose, as explained above, that the terminal filter n  is a filter of the first class which generates an output result having job information  which still conforms to the structure . A target entity  represents an appropriate device to receive such an output result. This target entity  is referred to as \u201cstructure-aware\u201d because it receives job information  conforming to the structure  and thus must provide necessary processing functioning to recognize such information  and process it appropriately.","Suppose, alternatively, that the terminal filter n  is a filter of the second class or third class which generates job information which no longer conforms to the structure . A target entity  represents an appropriate entity to receive such an output result. This target entity  is referred to as \u201cstructure-unaware\u201d because it receives job information  that no longer conforms to the structure , and thus the entity  does not need to devote any specialized functionality for processing information expressed in this structure ; indeed, the target entity  need not, and generally will not, be aware that the job information  its receives (e.g., in an appropriate PDL format) was ever originally expressed using the structure .","There is a third case where the terminal filter n  generates an output result which modifies the structured format  to some extent, but still maintains some vestiges of the structure . Target entity  is an example of the kind of entity that can receive and processing this output result.  identifies this kind of entity  as being \u201cpartially structure-aware\u201d because it should include at least some processing functionality for interpreting whatever remnants of the structure  that still remain in the output result.","Different jobs may require that different filtering operations be performed on the associated job information . A filter configuration module (not shown) can be used to define what filters (, , . . . ) are to be invoked in processing a particular job, how the individuals filters (, , . . . ) are to be configured, and how the filters (, , . . . ) are to be chained together. In other words, the spooling module  can chain the filters (, , . . . ) together in different ways to produce different net effects. In a series configuration shown in , for example, filter A  feeds its output result into the input of filter B , and filter B  feed its output result into to the input of filter C (not shown), and so on.","More specifically, the type of processing that the filter logic  performs on the job information  can be controlled, in element, by one or more \u201cprint tickets\u201d associated with the job information . The print tickets include attribute information that defines the operations that should be performed on the job information  as it passes through the filter logic . Different print tickets can be associated with different elements of the structure  of the job information , as will be described in the next subsection (A.2).","Further details regarding exemplary processing using chained filters and print tickets are provided in the above-captioned co-pending U.S. Ser. No. 10\/794,669.","The system  can also function in a client-server mode of operation, where the spooling module  responds to requests from a client module (which may comprise one of the target entities). In a client-server implementation, a server-side application (not shown) creates document content \u201con-the-fly\u201d in response to a client request. A server process generates parts of the job information , one at a time; while a separate process, at the same time, pulls parts from the job information , one at a time, to send \u201cdown\u201d to the client module.","A.2. Overview of Structured Job Information Format","As shown in , the job information  generally includes a structure  defined by a plurality of nodes coupled together according to a set of established rules. The same general rules can apply to the construction and consumption of the structure  regardless of the application and application platform used to produce and consume the job information . The strategies described below therefore provide a standardized mechanism for sharing job information among participants within different programming environments.","The job information  uses a hierarchical scheme to connect its nodes together. A hierarchical scheme couples the nodes together using parent-child relationships. That is, a \u201ctop-most\u201d node defines a so-called root node. The root node includes one or more child nodes, and the child nodes, in turn, can include one or more of their own respective child nodes, and so on. The child nodes can inherit methods, properties, metadata, etc. associated with their respective parent\/ancestor nodes.","Generally, the structure  is a logical concept that may or may not map to actual elements of a document to be rendered. That is, each node may be considered an object. Certain objects may represent actual elements of a document to be rendered (such as various image resources and font resources). Other objects may not have a one-to-one relationship with elements of the documents to be rendered. These latter types of nodes are therefore analogous to folders in a file hierarchy; that is, the folders may store individual files that contain content that maps to actual elements of the document, but the folders themselves may not have a one-to-one relationship with actual elements of the document.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 2","FIG. 1"],"b":["200","102","108","200","102","110","110","108","114","110","116","108"]},"The top level of the hierarchy specifies job-related information  that identifies the entire job itself. For instance, the job may pertain to the printing of a book including multiple chapters, and each chapter, in turn, can include multiple pages, and each page, in turn, can include font resources and image resources. In this example, the top level of the hierarchy identifies the logical package which encapsulates the entire job, that is, the entire book. The next level of the hierarchy specifies information  that identifies the documents associated with the job. In the example of the book, the document level might specify individual chapters in the book. Or this level of the hierarchy may specify different kinds of documents to be printed in a single print job, such a first document created using a text editor, and a second document created using a spreadsheet program, and so on, where these two documents together comprise a report of some kind.","The next level of the hierarchy specifies information  that identifies different renditions of the documents identified in the preceding level. For instance, consider the case of a chapter of a book. This chapter can be specified in a first rendition that requires that the chapter be printed in a black and white mode, and a second rendition that requires that the chapter be printed in a color mode. Or different renditions may correspond to different languages used to present information in the document, different page sizes, and so on. Depending on configuration information and other factors, the spooling module  or other processing logic can select an appropriate one of the renditions to process and present to an appropriate target entity (, , . . . ). By virtue of the ability to capture several renditions in a single package, the job information  having the structure  serves as a general blueprint from which many renditions can be generated. In general, the specification of such rendition information within the spool storage  itself is a unique and beneficial feature. For instance, this provides an efficient mechanism for printing different versions of the same document without having to store entire separately-tailored copies of the same document in the spool storage . Storing separate copies may overwhelm the storage and processing resources of the printing subsystem.","The next level of the hierarchy specifies information  that identifies different pages within the renditions of the documents identified in the proceeding level.","Resources can be associated with any level of the hierarchy defined by schema . For instance, an exemplary resource  can be associated with the job level , the document level , the rendition level , and\/or the page level . Particular types of resources can include an image resource , a font resource , or some other resource .","Further, metadata  can be associated with any of the levels of the hierarchy of the schema . For instance, exemplary metadata  can be associated with the job level , the document level , the rendition level , and\/or the page level . Metadata  specifies any supplemental information pertaining to the job information , such as an author who created a document contained in the job, a time when the document was created, various keywords pertaining to the content, a summary of the content, and so on. There are no restrictions on the type of, and meaning assigned to, metadata that can be appended to different elements of the schema .","A particular kind of metadata is a print ticket . The print ticket  can also be associated with any level of the hierarchy of the schema . For instance, exemplary metadata  can be associated with the job level , the document level , the rendition level , and\/or the page level . A print ticket defines the types of processing operations that should be performed on associated elements of the hierarchy of the job information . For instance, a print ticket associated with the job package level  will apply to the entirety of the package defined by the job information . A print ticket associated with an individual page  of the job information  will have a localized effect by only affecting that page . Further, inheritance applies to the methods, properties, metadata, etc. in the job information . As such, to determine what print instruction apply to any given node, the spooling module  can \u201cwalk\u201d the tree from a child node to its root (or vice versa), aggregating any print instructions that may apply along the way. This aggregation allows general instructions to be uniformly inherited by all children. A print instruction of a child node may override the general instructions of a parent node.","In summary, the schema  shown in  provides a powerful, uniform and versatile mechanism for representing complex job information, particularly for those jobs that involve multiple documents and\/or multiple renditions of documents. Traditional techniques provide no provisions for representing these kinds of complex scenarios in spool storage; therefore, these traditional techniques suffer from inefficiencies, which may be significant.","In one implementation, the hierarchy of the job information  is fixed to provide defined levels corresponding to jobs, documents, renditions, and pages. In another implementation, the hierarchy can be varied in one or more respects. For instance, Section A.4 (presented below) sets forth a technique for creating and consuming a hierarchy of arbitrary depth.","To further clarify the exemplary schema ,  shows one exemplary instantiation  of the schema . The entire collection of nodes shown in  defines a package. The package includes a root node  associated with the entire package, e.g., the entire job. An index can be associated with the package, and hence with the root node . This index can be used to locate the package in the spool storage .","The job defined by the root node  includes a number of documents, as identified by document node  and document node . Also, a metadata node  is associated with the root node . If so configured, the metadata associated with this metadata node  defines properties which apply to the job as a whole.","Each of the documents associated with nodes  and  can include multiple renditions associated therewith. For example, the document represented by node  includes at least two renditions identified by nodes  and . As explained in connection with , a document may allocate separate renditions for printing a document in black and white mode, color mode, etc. No limitation is placed on what a developer may define as a rendition in the context of a particular application environment.","In addition to rendition nodes (, ), node  also includes nodes  and  associated therewith. Node  specifies metadata associated with node  and node  specifies a resource associated with node . A resource can include an image resource, a font resource, or some other resource that goes into the composition of the document represented by node .","Each rendition includes one or more pages associated therewith. Nodes  and , for example, represent pages associated with rendition node . Metadata node  indicates that metadata can be associated with the rendition level of the hierarchy (as it can for any level). Resource node  indicates that resource information can be associated with the rendition level (as it can for any level).","Finally, each page can include page data associated therewith as well as metadata. For example, page node  includes page data node  and metadata node  associated therewith, indicating that page data and metadata can be associated with this page. Page node  includes page data node  and metadata node  associated therewith, indicating that page data and metadata can be associated with this page.","The package associated with root node  can also include a collection of resources for shared use by different nodes in the job. Such collection of resources thus defines a shared library of resources that can be applied at different points within a document represented by the package. Particular types of resources include image resources, as represented by general image node . Individual image nodes (, ) are children of the parent image node , and respectively represent individual image resources. A metadata node  depends from the general image node , which represents metadata that, if so configured, applies to all of the image resources. Another metadata node  depends from an individual image node , representing metadata that applies to only this image resource associated with this node .","The same structure applies to font resources. A general font node  represents the inclusion of a plurality of font resources to select from, indicated by font nodes  and . Metadata can be associated with the general font node , as indicated by metadata node , or can be associated with a particular font resource, as indicated by metadata node . If so configured, metadata associated with the general font node  applies to all font resources while metadata associated with a particular font resource (such as font resource ) applies only to that particular font resource.","The resources can also include a number of other types of resources, as generally indicated by resource node . Metadata can be associated with this node , as indicated by metadata node .","Any document-related node in the package can reference any reference node, indicating that a particular element or aspect of the document is referencing a particular resource for use thereat. For instance, in the exemplary case of , page node  references resource extensions node . This association is indicated with a dashed line. This means that the resource represented by node  is used in the page represented by page . Further, page node  is associated with image node  and font node , indicating that an image resource associated with node  and a font resource associated with node  are used in the page associated with node . These associations are indicated by two respective dashed lines.","Different strategies can be used to link the elements together to form the hierarchies shown in . In one technique, the individual elements can be modified so that they point to linked objects (e.g., parent and child objects). Linking can be provided by pointers, Uniform Resource Locators (URLs), or some other referencing mechanism. Alternatively, or in addition, separate relationship information can be defined that specifies how separate elements are linked together. This separate relationship information thus serves as a blueprint for linking together separate objects in the job information. Among other implementations, the Extensible Markup Language (XML), or other markup language, can be used, in whole or in part, to specify the elements in the hierarchies shown in  and the relationships among these elements.","Consider the specific case of attaching a resource, such as an image, to a particular node in the job information, such as a document node. This means that the image is a resource that is globally available to the document as a whole (as opposed to only an individual page in the document). The resource can be attached to the document by associating a URL with the node in the job information  which represents the document. More specifically, the URL can be considered as part of the metadata which is appended to this node (e.g., as exemplified by metadata  associated with document node ).","Metadata can be associated with individual nodes in the hierarchical structure  in different ways. For instance, individual nodes can provide linking information that points to associated metadata, or the nodes themselves can embed such metadata as integral parts of the nodes, and so forth.","As noted above, the nodes shown in  are logical entities. Mapping rules define how the logical nodes map to parts of actual physical storage (e.g., in spool storage ). A logical package may be \u201cphysically\u201d embodied by a collection of loose files, a .ZIP file archive, a compound file, or some other format. In one case, some of the nodes directly correspond, in one-to-one fashion, to parts (e.g., files) stored in the spool storage , such as pages, image resources, font resources, etc. Other nodes may not map, in one-to-one fashion, to actual parts of the spool storage .",{"@attributes":{"id":"p-0087","num":"0086"},"figref":["FIG. 4","FIG. 4","FIG. 3","FIG. 4","FIG. 3","FIG. 3","FIG. 3"],"b":["400","402","404","402"]},"The second series of entries  includes separate folders for font resources, image resources, extended (e.g., other) resources, etc. The image folder is expanded to show an exemplary series of seven .jpg image files. These image files define shared image resources that can be referenced by any page-related node in the package. For example, the metadata information stored in the files can make reference to these resources, effectively linking specific nodes to specific resources.","Whatever the form of the physical media and file structure, information can be stored on this media in simple (direct) ordered fashion, in interleaved fashion, or some other fashion. Information can be retrieved from this physical media in sequential mode or random access mode or some other mode.","A.3. Exemplary API Functionality for Producing and Consuming Job Information",{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 5","b":["114","102","114"]},"By way of overview, the interface functionality  facilitates interaction between the application module  and the job information  stored in spool storage , and between the spooling module  and the job information . This interaction can involve creating the job information  and storing the job information  in the spool storage , and retrieving the thus-created job information  from the spool storage . More specifically, different \u201cclients\u201d within the spooling module , such as various filters (,  . . . ), can retrieve the job information  for consumption using the logical hierarchical structure . The interface functionality  can also involve generating queries to determine features of the job information . The interface functionality can also set up various notification modules (e.g., event handlers) that generate notifications upon the occurrence of various events pertaining to the production and\/or consumption of the job information.","To this end,  broadly shows that the interface functionality  can include three basic exemplary functions. \u201cAdd functionality\u201d  serves the purpose of creating the job information . The add functionality  comes into play in the production phase  of the system  shown in . \u201cGet functionality\u201d  serves the purpose of retrieving the thus-created job information . The get functionality  can come into play in the consumption phase  of the system  shown in . Finally, \u201cinquiry\/notification functionality\u201d  serves the role of determining various characteristics of the job information  in the context of the production and\/or consumption of the job information . The inquiry\/notification functionality  also sets up and monitors various notification modules that generate notifications upon various events associated with the production and\/or consumption of the job information .","The following explanation provides information regarding exemplary general aspects of the interface functionality . This is followed by a more detailed discussion of one exemplary implementation of the interface functionality  which embodies these general aspects. Finally, Appendix D provides more details regarding one exemplary and non-limiting implementation of the interface functionality .","To begin with, the add functionality  and get functionality  can act on the job information  in piecemeal fashion by selectively adding and retrieving individual elements of the job information . For instance, the add functionality  can add individual elements to the hierarchy shown in . That is, the add functionality  can be invoked to selectively add a job, document, rendition, resource (image, font or other resource), and metadata to the job information . Similarly, the get functionality  can be selectively retrieve a job, document, rendition, resource (image, font or other resource), and metadata from the job information . Likewise, the enumeration and notification functionality  can selectively target different elements of the job information  to act upon.  illustrates this aspect of the interface functionality  by showing a bullet point breakdown of different elements that can be added to and retrieved from the job information .","The system  can implement the above-described functionality using any programming paradigm, such as an object-oriented programming paradigm. In this approach, the add functionality  can allocate a set of modules, e.g., classes, to the production phase  of the system . For instance, the add functionality  can devote separate classes having respective methods for separately adding jobs, documents, renditions, pages, resources, and so on. The add functionality  can automatically generate a Uniform Resource Indicator (URI) upon creation of each element (job, document, rendition, page, resource, etc.) in the hierarchy. The URI can include a name component as its last part. If a producer does not expressly specify the name, then the add functionality  can automatically supply the name. The interface functionality  can address the thus-created hierarchy by following the hierarchy to determine its elements or by directly using their URI through the root of the hierarchy.","The get functionality  can allocate a corresponding set of modules, e.g., classes, in the consumption phase  of the system . For instance, the get functionality  can devote separate classes having respective methods for separately consuming jobs, documents, renditions, pages, resources, and so on.","The interface functionality  can manipulate the job information in the above-described manner using different data access techniques, such as a synchronous mode of operation and an asynchronous mode of operation. In a synchronous mode of operation, a program module can invoke a function and then wait for its response before continuing on. In an asynchronous mode of operation, the program module can invoke a function and then continue on performing another task. The called function reports it results to the program module at a later time without holding up the tasks performed by the program module. One way of performing an asynchronous method is by first invoking a \u201cbegin\u201d operation which invokes the function, prompting it to immediately return a response. The program module then continues on performing other tasks while the function executes its operation. The program module can then invoke an \u201cend\u201d operation which queries the function to determine whether it has performed its task yet. If so, the end operation will prompt the function to return any result generated by the function to the program module.","Further, the interface functionality  can manipulate the job information  in any form, such as a record object, a stream object, etc. The abstraction of a stream object defines a sequence of information (e.g., bytes) constituting, for example, a file. (A client can consume a stream in piecemeal fashion as it receives the stream's data in serial fashion, without the necessity of receiving the entirety of the data in advance.) More specifically, parts of the job information  can be consumed while other parts of the job information  are being created. The interface functionality  can create a stream object in different ways, such as by opening a stream object associated with a record object, and so on.","The inquiry\/notification functionality  comes into play during the production and\/or consumption of the job information to facilitate the above-described tasks. For example, the inquiry\/notification functionality  can enumerate various characteristics of the job information  in preparation of retrieving the job information . For instance, the inquiry\/notification functionality  can determine the URI of a particular element, the parent of a particular element, the count of certain items in the hierarchy, and so on. The get functionality  can use this information to retrieve the enumerated elements. Further, the inquiry\/notification functionality  can determine whether the get functionality  (or some other functionality) has invoked certain requests and whether these requests remain pending. For instance, the inquiry\/notification functionality  can determine whether requests have been invoked to get any element in the hierarchy (e.g., job, document, rendition, page, resource, metadata, and so on), or whether requests have been invoked to determine certain properties of the job information (such as a request to determine a count of metadata items). Information regarding the pending status of these tasks helps the interface functionality  better coordinate its activities; for instance, add functionality  may benefit from status information regarding the consumption of job information  that it has created (or is in the process of creating).","The inquiry\/notification functionality  can provide notification modules (e.g., event handlers) that provide respective notifications when various events occur in the course of producing and\/or consuming the job information, such as when different elements of the job information are persisted in the spool storage and then consumed. More specifically, in the production phase , exemplary notification modules can provide notifications when jobs, documents, renditions, pages etc. are instantiated, committed, closed, etc. In the consumption phase , various notification modules can provide notifications when jobs, documents, pages, etc. are loaded, completed, etc. In one exemplary and non-limiting implementation, the inquiry\/notification functionality  can implement the notification modules using .NET delegates. Delegates encapsulate, inside a delegate object, a reference to a method. A program can pass the delegate object to a code module, which can then call the referenced method.","Appendix D provides an exemplary collection of classes that are built according to the principles described above. The classes have names organized into an exemplary namespace, PrintSystem.PrintSysCtnr. A namespace, in the exemplary context of the .NET programming environment, refers to a logical naming scheme for grouping related types. More specifically, the .NET Framework uses a hierarchical naming scheme for grouping types into logical categories of related functionality. However, the programming paradigm used in these examples, as well as the specific names assigned to individual classes, are illustrative rather than limiting.","In the example set forth in Appendix D, any client wishing to produce job information  can call PrintSysCtnr.AcquireProducer( ) to retrieve a PrintSysCtnrRootProducer, and any client wishing to consume a container can call PrintSysCtnr.AcquireConsumer( ) to retrieve a PrintSysCtnrRootConsumer. PrintSysCtnrRootProducer and PrintSysCtnrRootConsumer can manage symmetrical hierarchies of jobs, documents, renditions, pages, resources, etc.","More specifically, Appendix D describes a first collection of production-related modules, e.g., classes. A base class defines functionality available to all other classes which inherit from this base class. Other classes respectively include functionality for adding a job, adding a document, adding a rendition, adding a page, adding a resource, adding metadata, and so forth. (For example, the above-referenced PrintSystCtnrRootProducer adds a job to the job information .) Specific classes can be devoted to adding image resources, font resources, and print tickets. The production classes can include inquiry\/notification functionality  for receiving information regarding the status of pending tasks, and so forth.","Another series of classes respectively include functionality for getting a job, getting a document, getting a rendition, getting a page, getting a resource, getting metadata, and so forth. (For example, the above-referenced PrintSystCtnrRootConsumer gets a job from the job information .) Specific classes can be devoted to getting image resources, font resources, and print tickets. These consumption classes provide functionality for retrieving these elements in an asynchronous mode of operations as well as a synchronous mode of operations. These consumption classes further include inquiry\/notification functionality  for enumerating the characteristics of the job information, and so forth.","By virtue of the above design, the interface functionality  provides an abstraction for use in interacting with the job information . The interface functionality  thus can be conceptualized as a virtualized container model that wraps the underlying actual physical job information  stored in the spool storage .  illustrates this concept by showing the interface functionality  as a \u201cshim\u201d over the job information .","Other functionality can be layered on top of the job information , as indicated in the exemplary interface functionality  shown in . These additional methods and properties define functionality for controlling general properties of a consumption job, but not necessarily the job data itself (which is the role of the interface functionality ).","For instance, a PrintQueue class  can control the job from a high level between additions, deletion, restarting, as well as enumerating all the jobs hosted by a PrintQueue. This class  can specifically include functionality adding a job (or jobs), getting a job (or jobs), deleting a job, restarting a job, and so forth.","Another class, PrintQueueStream (not shown in ), provides a set of interfaces that comes into play during de-spooling job information  and after the data is processed and rendered by the driver. This class provides functionality for submitting the data to a target device. This class can specifically include functionality for streaming data to a target device, beginning and ending a writing task in an asynchronous manner, disposing of a job consumption task, flushing a job consumption task, and determining status information about the job consumption task, and so forth.","Another class, PrintSystemJobInfo , provides a set of high level interfaces for controlling tasks such as pausing a job, resuming a job, and so forth. This class can also determine (and in some cases, set) different characteristics of the job, such as job type, job priority, job ID, job submitter, position in queue, start time, number of pages, number of pages printed, job size, completion status, pause status, print status, restart status, spooling status, and so forth.","A.4. Implementation Variations: Exemplary Use of a \u201cReach Package\u201d and Associated API to Create and Consume Job Information","The above discussion set forth general techniques for creating and consuming job information  by separately adding and getting documents, renditions, pages, images, fonts, metadata, etc. to\/from a defined hierarchy. The preceding section (Section A.3) also set forth a series of API modules (classes) that are specifically allocated to creating and consuming these individual features of the job information . However, the job information  can be created and consumed using alternative techniques. In one alternative technique, the job information  can be constructed based on building blocks and related API modules that permit a more flexible hierarchy than the first-described implementation.","In one exemplary and non-limiting technique, a more flexible hierarchy can be constructed from so-called Metro and Reach package functionality, described in the above-cited co-pending and commonly assigned U.S. patent application Ser. No. 10\/836,327. More specifically, Metro functionality comprises platform-independent rules for structuring document-related information. A Reach package comprises document-related information created using the Metro functionality that satisfies certain additional Reach-related constraints. In other words, a Reach package is a specific kind, or species, of Metro document.","The following discussion sets forth exemplary features of job information  that conforms to Reach-related rules. The following discussion also sets forth API functionality that can be used to create and consume job information  constructed based on Reach-related rules.","To begin with, a Metro package is a logical entity that holds a collection of related parts. A single Metro package may contain multiple payloads, each acting as a different representation of document-related information. More precisely, a payload defines a collection of parts, including an identifiable \u201croot\u201d part and all the parts required for valid processing of that root part.","An individual part includes common properties (e.g., name and content type) and a stream of bytes. Part names are organized into a hierarchy, similar to paths on a file system. This hierarchy is composed of segments delineated by slashes. The last segment of the name is similar to a filename in a traditional file system. The segments of the names of all parts in a package form a tree.","Parts can reference other parts using URIs or other linking mechanisms. A part-relative URI is a reference to a part described such that the referenced part's address is determined relative to the part containing the reference. A part that references another part is referred to as a source part; the part that is referenced, in turn, is referred to as a target part. On the other hand, a package-relative URI is a reference to a part described such that the referenced part's address is determined relative to the package as a whole.","According to one feature, Metro functionality introduces a higher-level mechanism, referred to as \u201crelationships,\u201d to describe references between parts. Relationships provide a way to represent the kind of connection between a source part and a target part in a package without modifying the parts. As such, relationships make the connections between parts directly \u201cdiscoverable\u201d without examining the content in the parts. This makes the connections independent of content-specific schema, and also allows the connections to be resolved more quickly.","Relationships can be represented using the Extensible Markup Language (XML) using relationship parts. Namely, each part in the job information  that is the source of one or more relationships has an associated relationship part. This relationship part holds the list of relationships for the source part (expressed in XML using a content type application\/PLACEHOLDER).",{"@attributes":{"id":"p-0120","num":"0119"},"figref":"FIG. 7","b":["702","704","706","708","704","706","708","702","710","706","712","702","710","706","712"]},"More specifically, a part and its associated relationship part can be coupled together using a naming convention. In , the relationship part for the spine feature  can be stored in \/content\/_rels\/spine.xml.rels and the relationships for page 2 () can be stored in \/content\/_rels\/p2.xml.rels. Two exemplary naming conventions are used here. First, the relationship part for some other (original) part in a given \u201cfolder\u201d in the name hierarchy is stored in a \u201csub-folder\u201d called _rels. Second, the name of this relationship-holding part is formed by appending the rels extension to the name of the original part.","In the example of , the relationship part associated with the spine feature  contains a relationship that connects the spine feature  to print ticket  as set forth below:",{"@attributes":{"id":"p-0123","num":"0122"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Relationships Xmlns=\u201cHttp:\/\/mmcfrels-PLACEHOLDER\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Relationship"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Target=\u201c. .\/tickets\/ticket1.xml\u201d"]},{"entry":[{},"Name=\u201chttp:\/\/mmcf-print-ticket\/PLACEHOLDER\u201d\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/Relationships>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"As indicated above, relationships are represented using <Relationship> elements nested in a single <Relationships> element. The \u201cTarget\u201d element specifies a URI that points to the part at the other end of the relationship. The \u201cName\u201d element specifies an absolute URI that uniquely defines the role of the relationship.","Metro functionality also provides a number of basic building block parts. A so-called \u201cstart part\u201d defines a part that is typically processed first when a package is opened. Accordingly, the start part represents the logical root of the content stored in the package.","Metro functionality also defines two mechanisms for building higher-order structures from parts: selectors and sequences. A selector is a part which \u201cselects\u201d among a number of other parts. For example, a selector part might \u201cselect\u201d between a part representing an English version of a document and a part representing a French version of the document. A sequence is a part which \u201csequences\u201d a number of other parts, causing all of the part's children to be processed. For example, a sequence part might combine (into a linear sequence) two parts, one of which represents a five-page document and one of which represents a ten-page document.","These two types of composition parts (sequence and selector) and the rules for assembling these parts comprise a Metro composition model. A composition block of a package is the set of all composition parts (selector or sequence) reachable from the starting part of the package. The composition block also can define the higher-level organization of the package.","As mentioned above, a Reach package is constructed according to the provisions of Metro functionality, and is also subject to additional constraints. A Reach package may include the following features: a fixed page feature, which represents the content of a page; a fixed panel feature, which binds together a set of fixed pages in a defined order; a font feature, which defines fonts that can be applied to the document-related information in the Reach package; an image feature, which defines images that can be applied to the document-related information in the Reach package; a metadata feature, which defines descriptive metadata that can be applied to specified levels of the document-related information in the Reach package; and a print ticket feature, which defines print ticket information that can be applied to specified levels of the document-related information. A reach package can assemble these features into a so-called fixed payload. A fixed payload has a root part that contains fixed panel markup, which, in turn, references fixed page parts.","Moreover, Reach features can be combined together into different compositions to create compound documents. For instance, Reach packages support a specific kind of sequence (called a fixed panel sequence) that can be used, for example, to \u201cglue\u201d together a set of fixed panels into a single, larger \u201cdocument.\u201d For example, two documents can be \u201cglued\u201d together that originate from different sources: a two-page cover memo (defining a first fixed panel feature) and a twenty-page report (defining a second fixed panel feature).","Reach packages also support a number of specific selectors that can be used when building document packages containing alternate representations of the \u201csame\u201d content. In particular, Reach packages allow selection based on language, color capability, and page size, etc. More specifically, a language selector chooses between representations based on their natural language. A color selector chooses between representations based on whether they are black\/white or color. A page size selector chooses between representations based on their page size. A content type selector chooses between representations based on whether their content types can be understood by the system. Consider, for instance, the case of a language selector. In one example, job information  may constitute a bi-lingual document that uses a language selector to pick between the English representation and the French representation of the document. A language representation is chosen by inspecting the different representations and choosing the one that matches the system's specified default language.","Selectors and sequences can also contain further selectors and sequences allowing for powerful aggregate hierarchies to be built of arbitrary depth. For example, the following exemplary hierarchy is a valid Reach package: sequence-sequence-selector-sequence-fixed panel-fixed page.","A Reach package has a defined starting part, that is either a selector or a sequence. A fixed panel in a Reach package is discoverable by traversing the composition block from the starting part of the package.","With the above introduction, the following discussion provides more detailed information regarding fixed payloads, fixed panels, and fixed pages, followed by an example of a Reach package which embodies these features (with reference to ).","The fixed payload is a payload whose root part is a fixed panel part. The payload encompasses all of the parts required for valid processing of the fixed panel. These include: (a) the fixed panel itself; (b) all fixed pages references from within the fixed panel; (c) all image parts referenced (directly, or indirectly through a selector part) by any of the fixed pages in the payload; (d) all Reach selectors referenced directly or indirectly from image brushes used within any of the fixed pages within the payload; (e) all font parts referenced by any of the fixed pages in the payload; (e) all descriptive metadata parts attached to any part in the fixed payload; and (f) any print tickets attached to any part in the fixed payload.","The fixed panel part of the fixed payload content is specified in markup by including a <FixedPanel> element within a <Document> element. In the example below, the <FixedPanel> element specifies the sources of the pages that are held in the fixed panel.",{"@attributes":{"id":"p-0136","num":"0135"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<!-- SPINE -->"]},{"entry":[{},"<Document $XMLNSFIXED$ >"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<FixedPanel>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<PageContent Source=\u201cp1.xml\u201d \/>"]},{"entry":[{},"<PageContent Source=\u201cp2.xml\u201d \/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/FixedPanel>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/Document>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The <FixedPanel> element logically binds an ordered sequence of pages together into a single multi-page document. Pages can specify their own width and height, but a <FixedPanel> element can also optionally specify a height and width. This information can be used for a variety of purposes, including, for example, selecting between alternate representations based on page size. Each <PageContent> element refers to the source of the content for a single page. The source is specified as a URI string that refers to the page content, held in a distinct location within the package. The number of pages in the document can be determined by counting the number of <PageContent> children contained within the <FixedPanel> element. As with the <FixedPanel> element, the <PageContent> element can optionally include a PageHeight and PageWidth attribute, here reflecting the size of the single page. Each <PageContent> element in the <FixedPanel> element references a fixed page part.","Each fixed page part represents a page's contents in a <FixedPage> element with <Path> and <Glyphs> elements (which are together the basis for all marks rendered on a fixed page), and a <Canvas> element to group these elements. References to images from within any fixed page in a fixed payload can point to a selector part which can make a selection (potentially recursively through other selectors) to find the actual image part to be rendered.","More specifically, each fixed page part contains FixedPage markup describing the rendering of a single page of content. The excerpt provided below shows exemplary markup of the source content that can be used for the page referenced in the sample markup above (<PageContent Source=\u201cp1.xml\u201d\/>):",{"@attributes":{"id":"p-0140","num":"0139"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/\u2003\/content\/p1.xml"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<FixedPage PageHeight=\u201c1056\u201d PageWidth=\u201c816\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Glyphs"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"OriginX = \u201c96\u201d"]},{"entry":[{},"OriginY = \u201c96\u201d"]},{"entry":[{},"UnicodeString = \u201cThis is Page 1!\u201d"]},{"entry":[{},"FontUri = \u201c. .\/Fonts\/Times.TTF\u201d"]},{"entry":[{},"FontRenderingEmSize = \u201c16\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/FixedPage>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0141","num":"0140"},"figref":"FIG. 8","b":["800","800","802","804","806","804","806"]},"Namely, the selector part  selects between fixed payload  and fixed payload . Fixed payload  has a structure defined by a fixed panel . Namely, the fixed panel  \u201cglues\u201d together two fixed pages (, ). Fixed payload  has a structure defined by another fixed panel . The fixed panel  binds together two fixed pages (, ). The fixed pages (, , , ) can reference a number of font and image resources (, , , , ). A selector  can be used that allows fixed pages  and  to select either image  or image . Further note that fixed pages from different fixed payloads (, ) can share resources. For instance, both fixed payloads (, ) can draw from image resources  and . Both fixed payloads (, ) can also draw from font resource .","Finally, the job information  can attach print tickets (, , ) and metadata  to various levels in the hierarchy.","Although Metro and Reach terminology was used to describe the implementation in this section (A.4), these principles can be applied to create the job information  shown in , which is composed of jobs, documents, renditions, pages and resources (e.g., images and fonts). For instance, one or more sequence parts can be used to tie together several multi-page documents. One or more selector parts can be used to select between different renditions (defined by different fixed payloads, represented by fixed panel features). And the fixed pages can be used to implement the pages identified in . However, the principles described in this section (A.4) permit certain variations in the job hierarchy, allowing for the creation of hierarchies of arbitrary depth.","Corresponding Reach-enabled API functionality can be used to create and consume job information  that conforms to the Reach package structure. Like the examples set forth in  (with respect to the fixed-hierarchy job information ), the Reach-enabled API functionality can include \u201cadd functionality\u201d for adding parts to the Reach-constructed job information , and \u201cget functionality\u201d for retrieving parts from the Reach-constructed job information. More specifically, the Reach-enabled API functionality can include logic for adding and getting root parts of the job information , selector parts, sequence parts, fixed panel parts, fixed page parts, image resources, font resources, print tickets, and so forth. The root parts can correspond to selector parts or sequence parts.","Also, like the case of , the Reach-enabled API functionality can include inquiry\/notification functionality for determining various characteristics of the job information  in the context of the production and\/or consumption of the job information . The inquiry\/notification functionality can also set up and monitor various notification modules that generate notifications upon the occurrence of various events associated with the production and\/or consumption of the job information .","Also, like the case of , the Reach-enabled API functionality can manipulate the job information  using different data access techniques, such as a synchronous mode of operation and an asynchronous mode of operation.","Also, like the case of , the Reach-enabled API functionality can manipulate the job information  in any form, such as a record object, a stream object, etc.","As a final note to this section, unless otherwise stated, subsequent references to jobs, documents, renditions, pages and resources are intended to abstractly refer to any implementation of these features, including, but not limited to, the fixed-hierarchy examples developed in Section A.3 and the flexible-hierarchy examples developed in this section (Section A.4). In other words, unless otherwise noted, the terms jobs, documents, renditions, pages and resources should be construed in an implementation-independent manner. Moreover, the labels themselves (e.g., jobs, documents, renditions, pages, etc.) are arbitrary; for example, a level in the hierarchy that serves the role of representing different versions of a document can be regarded as a \u201crendition\u201d level based on its operative role, regardless of a particular implementation's naming convention, which may refer to this level using a different term.","B. Exemplary Method of Operation",{"@attributes":{"id":"p-0151","num":"0150"},"figref":["FIG. 9","FIG. 1"],"b":"100"},"The procedure  includes step  of generating the job information  having the structure . To perform this task, the application module  can generate job data, and the APIs  (and possibly the spooling module ) can produce the job information  having the format  by applying the various production-related classes described in Section A.3 (or, in the case of the flexible-hierarchy model, Section A.4). Step  represents the actual storage of this generated job information in the spool storage .","Step  entails retrieving the job information  from the spool storage  and consuming this job information  using the spooling module  and by applying the consumption-related classes described in Section A.3 (or, in the case of the flexible-hierarchy model, Section A.4). Such consumption may entail applying different combinations of processing operations provided by individual filters (, , . . . ). Step  generally represents any such processing of job information . The processing may entail converting the job information  having the structure  to processed job information  that still maintains the structure . This output result would be appropriate to send to the \u201cstructure-aware\u201d target entity  which can interpret this structure . The processing may alternatively entail converting the job information  having the structure  into job information that no longer has any semblance to the structure . This output result would be appropriate to send to the \u201cstructure-unaware\u201d target entity . Or the processing may entail converting the job information  having the structure  to processed job information  that has some vestiges of the structure , but which deviates from the structure in one or more respects. This output result would be appropriate to send to the \u201cpartially structure-aware\u201d target entity .","Whatever the case, upon receipt of the job information, the target entities (, , , . . . ) can perform prescribed processing on the job information, such as by printing it, displaying it, archiving it, etc.","C. Exemplary Computer Environment","In one exemplary implementation, the application module , APIs , and spooling module  can be implemented by software executed by a computing device. In this case,  provides information regarding an exemplary computer environment  that can be used to implement this functionality. Insofar as a target entity is implemented by a computing mechanism as well, such a computing mechanism can also be implemented using the type of computing environment  shown in , or using a related environment.","The computing environment  includes a general purpose type computer  and a display device . However, the computing environment  can include other kinds of computing equipment. For example, although not shown, the computer environment  can include hand-held or laptop devices, set top boxes, mainframe computers, etc. Further,  shows elements of the computer environment  grouped together to facilitate discussion. However, the computing environment  can employ a distributed processing configuration. In a distributed computing environment, computing resources can be physically dispersed throughout the environment.","Exemplary computer  includes one or more processors or processing units , a system memory , and a bus . The bus  connects various system components together. For instance, the bus  connects the processor  to the system memory . The bus  can be implemented using any kind of bus structure or combination of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures.","Computer  can also include a variety of computer readable media, including a variety of types of volatile and non-volatile media, each of which can be removable or non-removable. For example, system memory  includes computer readable media in the form of volatile memory, such as random access memory (RAM) , and non-volatile memory, such as read only memory (ROM) . ROM  includes an input\/output system (BIOS)  that contains the basic routines that help to transfer information between elements within computer , such as during start-up. RAM  typically contains data and\/or program modules in a form that can be quickly accessed by processing unit .","Other kinds of computer storage media include a hard disk drive  for reading from and writing to a non-removable, non-volatile magnetic media, a magnetic disk drive  for reading from and writing to a removable, non-volatile magnetic disk  (e.g., a \u201cfloppy disk\u201d), and an optical disk drive  for reading from and\/or writing to a removable, non-volatile optical disk  such as a CD-ROM, DVD-ROM, or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are each connected to the system bus  by one or more data media interfaces . Alternatively, the hard disk drive , magnetic disk drive , and optical disk drive  can be connected to the system bus  by a SCSI interface (not shown), or other coupling mechanism. Although not shown, the computer  can include other types of computer readable media, such as magnetic cassettes or other magnetic storage devices, flash memory cards, CD-ROM, digital versatile disks (DVD) or other optical storage, electrically erasable programmable read-only memory (EEPROM), etc.","Generally, the above-identified computer readable media provide non-volatile storage of computer readable instructions, data structures, program modules, and other data for use by computer . For instance, the readable media can store the operating system , application modules  (e.g., for implementing the application module ), other program modules , and program data . The computer readable media can also store, although not shown, logic for implementing the APIs  and spooling module . Any of the above-described storage media can be used to implement the spool storage , such as hard disk .","The computer environment  can include a variety of input devices. For instance, the computer environment  includes the keyboard  and a pointing device  (e.g., a \u201cmouse\u201d) for entering commands and information into computer . The computer environment  can include other input devices (not illustrated), such as a microphone, joystick, game pad, satellite dish, serial port, scanner, card reading devices, digital or video camera, etc. Input\/output interfaces  couple the input devices to the processing unit . More generally, input devices can be coupled to the computer  through any kind of interface and bus structures, such as a parallel port, serial port, game port, universal serial bus (USB) port, etc.","The computer environment  also includes the display device . A video adapter  couples the display device  to the bus . In addition to the display device , the computer environment  can include other output peripheral devices, such as speakers (not shown), a printer (not shown), etc. Any of these units can constitute the target entities (, , . . . ) shown in .","Computer  operates in a networked environment using logical connections to one or more remote computers, such as a remote computing device . The remote computing device  can comprise any kind of computer equipment, including a general purpose personal computer, portable computer, a server, remote printer or archival device, etc. Any of these units can also constitute the target entities (, , . . . ) shown in . Remote computing device  can include all of the features discussed above with respect to computer , or some subset thereof.","Any type of network  can be used to couple the computer  with remote computing device , such as a WAN, a LAN, etc. The computer  couples to the network  via network interface , which can utilize broadband connectivity, modem connectivity, DSL connectivity, or other connection strategy. Although not illustrated, the computing environment  can provide wireless communication functionality for connecting computer  with remote computing device  (e.g., via modulated radio signals, modulated infrared signals, etc.).","D. Appendix: Exemplary Interface Functionality","The following exemplary classes can be used to implement the interface functionality  for the case of fixed-hierarchy job information . Namely, these classes provide functionality for creating jobs, retrieving jobs, providing various notifications concerning the production and consumption of jobs, enumerating jobs, and so forth. Any object-oriented paradigm can be used to implement these classes, such as the .NET virtual programming environment (utilizing the CLR) provided by Microsoft Corporation. However, the principles set forth herein are not limited to the following exemplary and illustrative implementation.","To begin with, an abstract class PrintSysCtnrBaseProducer defines a base class of all types of elements that can be created in a container by a producer. This class can include various functions, such as the following exemplary list of functions:\n\n","An abstract class PrintSysCtnrBaseConsumer defines a base class of all types of elements that can be consumer from a container by the consumer. This class can include various functions, such as the following exemplary list of functions:","(Asynchronous Methods)\n\n","(Synchronous Methods)\n\n","A class PrintSysCtnrRootProduce, which inherits from the class PrintSysCtnrBaseProducer, provides the following exemplary functions:\n\n","A class PrintSysCtnrRootConsumer, which inherits from the class PrintSysCtnrBaseConsumer, provides the following exemplary functions:","(Asynchronous Methods)\n\n","(Synchronous Methods)\n\n","A class PrintSysCtnrJobProducer, which inherits from the class PrintSysCtnrBaseProducer, includes the following exemplary functions:\n\n","A class PrintSysCtnrJobConsumer, which inherits from the class PrintSysCtnrBaseConsumer, provides the following exemplary functions:","(Asynchronous Methods)\n\n","(Synchronous Methods)\n\n","A class PrintSysCtnrDocumentProducer, which inherits from the class PrintSysCtnrBaseProducer, provides the following exemplary functions:\n\n","A class PrintSysCtnrDocumentConsumer, which inherits from the class PrintSysCtnrBaseConsumer, provides the following exemplary functions:","(Asynchronous Methods)\n\n","(Synchronous Methods)\n\n","A class PrintSysCtnrRenditionProducer, which inherits from the class PrintSysCtnrBaseProducer, includes the following exemplary functions:\n\n","A class PrintSysCtnrRenditionConsumer, which inherits from the class PrintSysCtnrBaseConsumer, includes the following exemplary functions:","(Asynchronous Methods)\n\n","(Synchronous Methods)\n\n","A class PrintSysCtnrPageProducer, which inherits from the class PrintSysCtnrBaseProducer, includes the following functions:\n\n","A class PrintSysCtnrPageConsumer, which inherits from the class PrintSysCtnrBaseConsumer, includes the following exemplary functions:","(Asynchronous Methods)\n\n","(Synchronous Methods)\n\n","A class PrintSysCtnrResourceProducer, which inherits from the class PrintSysCtnrBaseProducer, provides the following exemplary functions:\n\n","A class PrintSysCtnrResourceConsumer, which inherits from the class PrintSysCtnrBaseConsumer, includes the following exemplary functions:","(Asynchronous Methods)\n\n","(Synchronous Methods)\n\n","The returned stream can be parsed.","A class PrintSysCtnrImageProducer, which inherits from the class PrintSysCtnrResourceProducer, provides special functionality tailored to produce image resources.","A class PrintSysCtnrImageConsumer, which inherits from the class PrintSysCtnrResourceConsumer, provides special functionality tailored to retrieve image resources.","A class PrintSysCtnrFontProducer, which inherits from the class PrintSysCtnrResourceProducer, provides special functionality tailored to produce font resources.","A class PrintSysCtnrFontConsumer, which inherits from the class PrintSysCtnrResourceConsumer, provides special functionality tailored to consume font resources.","A class ConsumerMetadata includes the following functions:\n\n","A class ProducerMetadata includes the following exemplary functions:\n\n","A class EffectivePrintTicketHandler provides functionality for merging information PrintTickets on multiple levels in the job hierarchy along an access path to the current node in the hierarchy. This functionality can perform this task by \u201cwalking up\u201d the hierarchy using the parent properties of each node, and then walking back down and merging the PrintTickets along the way. This class can include the following exemplary functions:\n\n","API functionality for Reach-model job information  can also include a number of classes. The classes can include functionality for adding and getting root information parts, selector parts, sequence parts, fixed panel parts, fixed page parts, image resources, font resources, print tickets, and so on. In addition, Reach-model API functionality can also include logic for determining various features of the job information  (such as page count, etc.), and for generating various notifications (such as notifications that signal the completion of various operations).","In closing, a number of examples were presented in this disclosure in the alternative (e.g., case A or case B). In addition, this disclosure encompasses those cases which combine alternatives in a single implementation (e.g., case A and case B), even though this disclosure may not have expressly mention these conjunctive cases in every instance.","More generally, although the invention has been described in language specific to structural features and\/or methodological acts, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described. Rather, the specific features and acts are disclosed as exemplary forms of implementing the claimed invention."],"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 5","FIG. 1"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 6","FIG. 1"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 9","FIG. 1"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 10","FIG. 1"]}]},"DETDESC":[{},{}]}
