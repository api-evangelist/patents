---
title: Semantic-based, service-oriented system and method of developing, programming and managing software modules and software solutions
abstract: Methods, systems, frameworks, and software products are disclosed for building well-defined software modules through the optionally nested, aggregation of other similar modules at any depth. The invention provides visual methods of aggregation and nesting of software interfaces within composite software services with an automated runtime platform. Other aspects of the invention include, but are not limited to, innovative methods for routing the flow of invocation, inter-service communication, and exception handling. Industry standards are leveraged to integrate the methods discussed in this invention to any computer system, programming language or software platform. The semantic-based and visual nature of the inventions discussed can significantly reduce the complexity of building, maintaining and deploying computer systems and software products.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08621428&OS=08621428&RS=08621428
owner: Nextaxiom Technology, Inc.
number: 08621428
owner_city: San Francisco
owner_country: US
publication_date: 20120217
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCES TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This application is a continuation application of and claims the priority benefit of U.S. patent application Ser. No. 10\/904,744 filed on Nov. 24, 2004, entitled \u201cSemantic-Based, Service-Oriented System and Method of Developing, Programming and Managing Software Modules and Software Solutions,\u201d which is a nonprovisional patent application claiming the priority benefit of U.S. Provisional Application Ser. No. 60\/481,702, filed on Nov. 25, 2003, entitled \u201cA Semantic-Based Method of Building Distributed Software Modules from other Distributed Software Modules\u201d, all of which are incorporated herein by reference in their entirety.","1.Field of the Invention","The present invention relates to the field of computer programming, software development and management and, in particular, to the design, service-oriented programming, implementation, integration, deployment, control and maintenance of software modules\/services and software applications.","2.Description of the Related Art","There are many computer programming languages, software design and development, and integration tools in existence today.","The current state for programming languages and software design tools is based on the well-known object-oriented development paradigm. Object-oriented programming languages inherit the complexity of the object-oriented paradigm. The current programming languages require an unnatural syntax-based coding or scripting approach that does not directly correspond to the way that non-technical people, functional experts and business analysts think. Furthermore, these languages often pivot around class definitions, class inheritance and polymorphism. These complex concepts require steep learning curves and can be only understood and utilized by highly technical programmers or computer scientists. Most people with functional know-how and understanding of business and application requirements are not technical enough to directly utilize the current programming languages and software development tools. As a result of this complexity, software development projects take too long to complete and are too expensive and non-flexible when it comes to the inevitable need for enhancements and maintenance.","Furthermore, the current integration tools are based on a message-oriented paradigm and only accommodate the communication and translation between different software layers. These tools are also too complex and are either not sufficient for general purpose programming, or utilize the complex object-oriented paradigm to accommodate programming capabilities.","It takes too long to develop, customize and integrate enterprise software solutions and the end result is too rigid. Today's approach to building software is very much like pouring concrete. Like developing software solutions, pouring concrete requires heavy lifting while the concrete is fluid. After the concrete sets, it is inflexible as is the case with the current approach to developing and delivering software solutions. A significantly less complex approach to software development can dramatically decrease the time to deliver software solutions. A dramatic decrease in the time to deliver will often correlate to a proportional decrease in cost. Time and cost are two main components of agility. Therefore, a significantly less complex approach to developing and delivering software solutions will increase the agility of an organization. If it took three weeks, instead of nine months to deliver or modify a software solution to support a business activity, organizations could optimize their operations in response to change and become significantly more agile. They could undertake less costly projects that would not be possible to undertake with an otherwise longer timescale.","Service-Oriented Architecture has been gaining popularity among software vendors and Information Technology users in the recent years. In a Service-Oriented Architecture (SOA), a service interface is used as a logical unit of communication between different software layers. SOA addresses the interoperability issue between different software systems through industry standards. Most software vendors have incorporated standards-based software services as the means of interfacing with other software applications and tools. Web services standards, such as Web Service Definition Language (WSDL) and Universal Description, Discovery and Integration (UDDI) make the traditional three-tier architecture interoperable. Each tier can provide or consume easily deployable \u201cblack-boxes\u201d of software functionality through standard-based service interfaces. However, service-oriented, standards-based communication does not make the application logic in the middle-tier more adaptable or easier to program.","A software service has a well-defined interface and performs a well-defined software task. The interface represents the inputs and outputs of a black-boxed software service as well as the properties of that service, such as service name and location. The interface acts as a contract between the consumer of the software service and the producer of the service.","The main object of the present invention is to introduce a general-purpose, service-oriented programming method that takes the idea of service-orientation beyond standards-based communication. The method of the present invention aims to provide a pure service-oriented approach for programming software logic and organizing the program into software modules (as services) that eliminates the need for coding or scripting while operating within a service-oriented paradigm. This makes the application, business and integration logic in the middle-tier of software architecture ten times faster to develop, maintain, and customize. Due to unique innovations, all application logic that utilizes this approach is adaptable, and can be created and modified on the fly.","The programming method of the present invention enforces a new means of decoupling and organizing a computer program that is fundamentally simpler than object-oriented programming, and significantly more flexible than any of its predecessors. This simple, yet powerful approach provides the base required to truly enable a one-hundred percent code-free, script-free, metadata-driven software development platform.","An object of Service-Oriented Programming (SOP), as defined by the method of the present invention, is to provide a revolutionary technique for developing software that uses a service interface as the pivot-point for developing computer program modules as services, and furthermore to natively support services as its fundamental unit of work at both development and execution time. Unlike a function or object-oriented method interface, a service interface supports rich integrity rules and allows for multiple, order-independent, complex types on both the inputs and outputs of a software task. The runtime kernel called for by the method of the present invention provides native support for this rich service interface\u2014it enforces integrity rules (in real-time), handles complex inputs and outputs, and uses flexible specifications to direct runtime behavior and to dispatch internal as well as remote software tasks. Here, the interface of the service accommodates private properties, not exposed to the consumer, used as a contract between the service and the runtime environment. These properties address technical properties such as service \u2018timeout\u2019 all the way to sophisticated behavior such as synchronization of service instances, cache keys, logging, and metering behavior.","A software service can be either implemented by coding in an object-oriented or functional environment bridged to the method of the present invention, or it can be implemented in a semantic-based programming environment based on the method of the present invention.","The present invention aims to provide a collection of methods to accomplish its objectives. An object of the present invention is to provide a method for building well-defined software modules (as software services), including, but not limited to \u201cWeb services\u201d, through the optionally nested aggregation of other likewise modules at any depth.","A further object of the present invention is to provide visual methods and systems of aggregation and nesting of software interfaces within composite service definitions with an automated runtime.","A further object of the present invention is to provide visualization methods for nested composite services.","A further object of this invention is to provide mechanisms for organizing, and discovering software services.","A further object of the present invention is to provide a method to correctly refactor a set of contained services, within a composite service, as a new composite service encapsulating those contained services.","A further object of the present invention is to provide a method to correctly unfactor services inside a parent composite service within another parent composite service.","A further object of the present invention is to allow context-sensitive configuration of the behavior for software services contained in a composite service.","A further object of the present invention is to provide programming capabilities in a graphical environment (that requires no coding) where those capabilities are based on service interfaces and a set of innovative constructs.","Another object of the present invention is to provide a method and mechanism for defining and controlling the flow of execution within a composite service.","A further object of the present invention is to provide a technique for configuring a software interface and providing automatic implementation for the configured interface.","Another object of the present invention is to provide means for mapping data and data transformations between connected services contained in a composite service.","A further object of the present invention is to provide a context-based mechanism for inter-service communication through shared memory.","A further object of the present invention is to provide a mechanism for exception handling within a composite service definition.","Another object of the present invention is to provide visual means for inspection and debugging of nested composite services.","Yet another object of the present invention is to provide a method of provisioning for software services based on their interfaces.","Other objects and advantages of this invention will be set in part in the description and in the drawings, which follow and, in part, will be obvious from the description, or may be learned by practice of the invention. Accordingly, the drawings and description are to be regarded as illustrative in nature, and not as restrictive.","To achieve the forgoing objectives, and in accordance with the purpose of the invention as broadly described herein, the present invention provides methods, frameworks, and systems for building a software system for the management, implementation and assembly of service-oriented, software modules. In preferred embodiments, this technique comprises: a visualization technique for assembling nested composite services with a semantic-based ability to add programming logic without syntax-based coding. Built-in service flow behavior, and semantic-based branching and looping constructs are provided to enable the systematic and programmatic control over the flow of service invocation. Semantic-based constructs are provided to accommodate service-oriented exception handling. Means for mapping data and data transformations are integrated in the visual assembly environment with automated runtime. Methods for organizing software services and composite definitions and discovery of services are integrated in the visual environment. Techniques for context-based configuration of services within the context of a parent composite service are provided. Furthermore, account-based provisioning of services is accommodated by creating a reference mechanism to software interfaces corresponding to the services under provisioning.","The method further comprises a mechanism for inner process communication through a variety of shared memory structures. An innovative framework together with a set of access and modification methods are used to enable composite services to share data within different instances of the same composite service definition or across the instances of different composite service definitions. The shared memory mechanisms and methods leverage the configurable construct invention together with data synchronization and persistent mechanisms to accommodate inner service communication through shared data storage.","The present invention will now be described with reference to the following drawings, in which like reference numbers denote the same element throughout. It is intended that any other advantages and objects of the present invention that become apparent or obvious from the detailed description or illustrations contained herein are within the scope of the present invention.","The present invention is a collection of many related innovative techniques, methods and systems for building well-defined software modules, including, but not limited to \u201cWeb services\u201d, through the optionally nested aggregation of other likewise modules at any depth. There are two distinct aspects of a software module (i.e., software service). The first is the interface of the service. The interface of the service defines the inputs, outputs and the properties of the service. The second aspect of a software service is the implementation of the service. The method of the present invention defines a pure service-oriented approach in implementing software modules by strictly separating these two aspects, and providing an implementation paradigm based on the interface of software services. The reader may refer to www.nextaxiom.com for obtaining a downloadable version of the Hyperservice\u00a9 Business Platform that is an example implementation of the methods, techniques and the systems discussed in the present invention while identifying her\/his request for download in the context of this patent application.","One aspect of the present service-oriented invention is in its hierarchical, nested approach to the organization of a software module (i.e., software services). Based on this approach, as depicted in , a software service can be composed of other services, which in-turn may be composed of other services, and so on, without a preset limit on the depth of composition. Each level of composition (i.e., implementation) is encapsulated from the containing parent level through its interface definition. The platform for the service-oriented paradigm of the present invention further distinguishes a software service implemented through this composition paradigm, herein referred to as a composite service or a Hyperservice\u00ae, from one implemented through any other programming paradigm, or with a distributed implementation (i.e., computer address space other than the instance of the executing platform) as an atomic (or raw material) service.","Another aspect of the present invention is in the method of composition used in assembling software services for the purpose of defining the implementation of a composite service. A set of semantic-based programming constructs control the flow of execution of child services that exist within the definition of a composite service; wherein, connecting either the success or the failure port of a contained service to the activation port of another service establishes a dependence between the invocation of the two services whereby the latter service is automatically invoked after the former service. If the failure port was connected, the latter service is only invoked if the former service fails as a result of its execution. But, if the success port was connected, the latter service is only invoked if the former service succeeds as a result of its execution. Either the simultaneous connection of both failure and success ports can be disallowed, or it can be interpreted as a positive activation signal for executing the latter service. Referring to an example depicted in , an activation port is associated with the input side, and a success and a failure port is associated with the output side of each presentation of a contained service. The automatic runtime system implementing the methods of the present invention provides the built-in behavior with respect to these ports. Again, referring to , Service-A begins execution when the execution of the parent\/containing service begins. Service-B and Service-C are only executed if Service-A's invocation was successful since they are attached to the success port of Service-A. Otherwise, if Service-A fails upon execution, Service-D is invoked by the automatic runtime platform since it is connected to the failure port of Service-A.","Among other benefits, the failure port provides a built-in flow mechanism for exception handling that is service-oriented (i.e., implemented through services). For example, Service-F is only activated when Service-D fails to handle the failure (i.e., exception handling). Again, referring to , Service-E is activated upon the success of Service-B AND service Service-C since its activation port is connected to the success ports of Service-B and Service-C. A set of logical activation constructs are introduced, based on the method of the present invention, to give those implementing a composite service control to change the default AND logic such as that mentioned in the case of Service-E from . is an example metadata representation of ","The method of the present invention provides the ability to connect the failure or success port of any service as well as any of the other constructs to any of a set of logical flow constructs, including but not limited to AND, OR and NOT constructs. Each of the logical constructs can operate on the flow signals of failure and success ports as well as signals generated by other constructs. Flow signals from many services can be connected to an AND construct, and the output signal generated by the AND construct is only an activation signal if all signals flowing into it indicate activation. The OR construct generates an activation signal if at least one signal flowing into it indicates activation. The NOT construct takes a flow signal as input and generates the negation of that signal on the output side. Now, referring to for an example, the success ports of Service-A and Service-B are connected to an AND construct and an output signal from the AND construct is mapped to the activation port of Service-E whereby Service-E will be only invoked if both Service-A and Service-B execute successfully. Again, referring to , the failure ports of Service-C and Service-D are connected to an OR construct and the output signal of the OR construct Service-F. Here, Service-F is activated if either Service-C or Service-D fails upon execution. The output signal of the OR construct is also connected to a NOT construct and the NOT construct is connected to the activation port of Service-G. Here, the NOT construct generates an activation signal that results in the activation of Service-G only if the OR construct outputs a deactivation signal (which only happens if either Service-C or Service-D fail to execute successfully). is an example metadata representation of ","The method of service composition outlined by the present invention provides a Decision construct for controlling the flow of invocation, through branching, based on the actual data carried by service inputs\/outputs at runtime. The method of the present invention provides the graphical ability to associate data elements from the inputs of the parent service or the outputs of any contained service to a branch of a decision construct. This association automatically defines the left-hand-side of a logical operator. The user then selects a logical operator from a list (those available to all databases query languages and higher level programming languages). The user then associates data from the inputs of the parent service or the outputs of any contained service to automatically define the right-hand-side of the logical operator. The method also provides the ability to add as many such branches to a decision construct to create the logical equivalent of an \u201cIF\/ELSE-IF\/ELSE-IF\/ELSE\u201d statement similar to those of general purpose programming languages. Furthermore, the method of the present invention provides for the association of a True port and False port with each decision branch. These ports are mutually exclusive; during runtime, only one of these ports will generate an activation signal. The True port of a decision branch generates an activation signal if the condition represented by that branch is True. The False port of a decision branch generates an activation signal if the condition represented by that branch is False. Each decision branch is chained to the next through the False port of the previous branch. During runtime, the evaluation of the next decision branch is only activated if the False branch of the previous branch is activated. If the evaluation of all branches result in a False value, the False port of the last decision branch is activated. Referring to for an example, you can see the composite implementation of an \u201cExpediteItem\u201d service used in a hypothetical manufacturing environment. Inside the ExpediteItem service (i.e., its composite definition) is a \u201cGet Qty on Hand\u201d service where the success port of the \u201cGet Qty On Hand\u201d service is connected to a decision construct with two branches. The figure shows a data-mapping tool that is used to express the mapping between data from the outputs of the \u201cGet Qty On Hand\u201d service and the decision construct as well as data from the inputs of the ExpediteItem composite service and the decision construct. On the top portion of the left side of the mapper tool, the inputs \u201citemID\u201d and \u201crequestedQty\u201d are displayed; and, on the bottom portion of the left side of the mapper tool, the outputs \u201conHandQty\u201d and \u201citemLocation\u201d of the \u201cGet Qty On Hand\u201d service are displayed. On the right portion of the mapper tool, the two branches of the decision construct of this example are displayed. During runtime, the True port of the first branch produces an activation signal if the \u201crequestedQty\u201d of the ExpediteItem service is less than or equal to the \u201conHandQty\u201d of the \u201cGet Qty On Hand\u201d service. If this condition is not true, the second branch is evaluated. The True port of the second branch produces an activation signal if the \u201conHandQty\u201d of the \u201cGet Qty On Hand\u201d service is greater than zero (a constant value of zero is attached to the right hand side of the second branch). Based on the logic implemented in the composite \u201cExpediteItem\u201d service, at runtime, if either the condition in the first branch or the second branch evaluates to true, Service-A is invoked. However, Service-B is invoked only if the condition in the second branch (i.e., \u201conHandQty\u201d being greater than zero) evaluates to true. If the condition in neither of the branches evaluates to true, the composite Service-C will be invoked since it is connected to the False port at the bottom of the decision construct. This False port is equivalent to an \u201celse\u201d statement of programming languages. is an example metadata representation of ","Another method of the present invention that controls the flow of execution within a composite implementation of a software service is introduced through exit and continue graphical flow constructs. These constructs have well-defined, built-in behavior at runtime. Furthermore, these constructs are part of the exception handling mechanisms provided by the method of the present invention. The method of the present invention supports an \u201cExit with success\u201d and an \u201cExit with failure\u201d construct that if reached at runtime, based on the flow of invocation rules, results in the termination of the containing parent composite service with success or failure respectively. Furthermore, the method of the present invention supports a \u201cContinue\u201d construct that if reached at runtime, based on the flow of invocation, results in the continuation to the next flow point (HYPERCYCLE). For example, if the failure port of a child service is connected to a \u201cContinue\u201d construct, then during runtime, if that child service fails, the parent service will continue execution. Now, referring to , an \u201cExit with success\u201d construct is connected to Service-A's success port. As a result of this connection, at runtime, if Service-A executes successfully, the execution of the composite service containing Service-A will terminate with a status of success. Based on the example in , if Service-A fails, Service-B is executed; however, if Service-B fails, since a Continue construct is attached to the failure port of Service-B, the runtime instance of the composite model (i.e., graphical implementation) will not terminate and the execution will flow to the next service (Service-C). Following the model in , if Service-C fails to execute successfully due to a \u201cRemote Connection Failure\u201d or an \u201cInvalid Request\u201d, the runtime instance of the model will exit with a status of failure; however, if it fails due to a \u201clogical Failure\u201d, Service-D will be invoked. Therefore, based on the method of the present invention, the construct or service connected to the failure port of a service can be activated upon specific failure types, based on the application designer's selection. is an example metadata representation of ","Another aspect of the present invention is the association of an attribute with the composite service implementation that indicates whether to repeat the execution of the implementation. There is a second related attribute that indicates whether to stop repeating once a configurable number of repetitions is reached, or to continue repeating until an Exit construct is reached. A third attribute indicates the amount of time to pause between repeats. This method of repeating, or \u201clooping\u201d, further comprises the optional ability to provide data feedback from any data element of the composite service outputs to the inputs of that service. Referring to for an example, the implementation of the composite service containing a child \u201cGet List item\u201d construct (introduced later in this document) and a service named Service-A is demonstrated. Here, based on the model property, the implementation is marked as a repeating implementation with no preset maximum number of iterations. Additionally, feedback from the outputs to inputs is enabled where a data-mapping tool allows the user to specify feedback data mappings from the outputs of the parent service to its inputs upon each iteration at runtime. is an example metadata representation of ","Based on the method of the present invention, graphical means for mapping data between the outputs and inputs of contained child services within a composite service are provided wherein the outputs of one or more child services can be mapped to the inputs of one or more child services. Furthermore, the inputs of the containing (i.e., parent) composite service can be mapped to the inputs of any of its contained services (i.e., its children) and the outputs of many contained services can be mapped to the outputs of the containing (parent) composite service. Referring to as an example, the data mapping tool on the left side of the figure holds a representation of the inputs of the parent service on the left side of the mapping tool and the inputs of Service-A, Service-B, and Service-C on the right side of the mapping tool. You can see how the user can express the data relation\/mapping of \u201cparent-input-1\u201d to \u201cservice-A-input\u201d, and the mapping of \u201cparent-input-2\u201d to both \u201cservice-B-input\u201d and \u201cservice-C-input\u201d elements. The expression of the mapping is stored as part of the implementation of the \u201cParentService\u201d model based on which actual data are transferred between the instances of the services at runtime. shows one metadata expression of the mapping relationships of \u201cParentModel\u201d to Service-A, Service-B and Service-C described in . Continuing with the explanation of the example in , the mapping tool on the right side of the figure shows the expression of data mapping, based on the method of the present invention, between the outputs of three services Service-E, F, G and the outputs of the \u201cParentService\u201d in a similar fashion. In this way, at runtime, data is transferred to the inside of the composite implementation through its inputs and to the outside the composite implementation through its outputs. Referring to the example of , you can see the outputs of three services, Service-A, B, C, being mapped to the inputs of Service-D and the outputs of Service-D being mapped to the inputs of three services, Service-E, F, G in a similar fashion. is an example metadata representation of the visual mapping demonstrated in ","The implementation method of the present invention includes the ability to express the mapping of complex input\/output data structures with plurality between the input\/output of services. Referring to as an example, you can see the outputs of Service-A that include a plural data container \u201cList-AAA\u201d within another plural data container, \u201cList-AA\u201d that is itself embedded within another plural data container \u201cList-A\u201d. In this example, each plural data container contains some atomic data element. Similarly on the input side of Service-B, data plurality is represented. As the mapping tool in the suggests, the method of the present invention provides for the expression of the mapping of the data elements within these containers. provides an example metadata representation of . demonstrates an example of automatic data transfer at runtime based on the expression of mapping defined at design-time. Furthermore, based on the method of the present invention, data is automatically converted, if needed, based on the actual data types on the two sides of the mapping. For example, a date of one format will be converted to another, based on the defined format of the date type to which it is connected. As another example, if a Boolean type is connected to an integer type, then during runtime, if the value of Boolean is \u2018true\u2019, it will be converted to an integer value of \u20181\u2019 upon transfer. At runtime, the actual conversion takes place based on the types as indicated as part of the definition of the service interfaces.","Based on the method of the present invention, the flow of execution upon the invocation of a composite service automatically starts by transferring data from the inputs of the parent composite service to those child services directly connected to the input port of that service. These and all connections are based on the expression of mapping defined at design-time and stored as part of the implementation of the composite service. Furthermore, the invocation of a composite service may end with the transfer of data from the outputs of the contained child services that have already been executed and are directly connected to the outputs of the parent service. Certain events may terminate the invocation of a composite service prematurely. For example, the invocation of a composite service may terminate prematurely when a child service fails upon invocation without a routing defined for its failure port or if an Exit construct was activated.","To determine the dependency order of invocation\/execution of the contained services, we construct an execution graph (a directed graph) for each composite service. Based on the connectivity of the contained services, we determine the order of invocation and the end life cycle of each child service at runtime. Refer to , , , , and , which demonstrate the EXECUTION GRAPH of the models represented by , , , , and , respectively.","The created execution graph captures the dependencies of all the child services and construct nodes, based on their connectivity to the success\/failure ports of other child services\/constructs or to the parent service's input node. To construct the EXECUTION GRAPH for a composite service, tree nodes are created corresponding to each service and graphical construct (such as a logical construct) within a composite service model. The created nodes are sorted based on the direct and indirect dependency of each node to the inputs node of the parent composite service. The maximum distance that must be traversed from one node, through other incoming nodes, to reach the inputs of the parent composite service is one way to compare two nodes in determining the order of sorting. Note that upon the definition of a composite service, based on the method of the present invention, all graphical nodes inserted within the definition and their immediate dependency (i.e., incoming nodes) are stored as part of the definition of a composite service. Refer to , , , , and , which demonstrate this dependency in example metadata form.","At runtime and upon the invocation of a composite service instance, a context, herein referred to as the INVOCATION MAP, is created for a composite service based on the EXECUTION GRAPH associated with the definition of the composite service. Upon the invocation of a composite service, the automation platform instantiates an INVOCATION MAP corresponding to the EXECUTION GRAPH that is created based on the dependency of contained services. The INVOCATION MAP determines the set of services that can be invoked by traversing the EXECUTION GRAPH in the order of node dependencies. The nodes with no dependencies or only dependencies to the input data of the composite service are the first set of nodes in the EXECUTION GRAPH and the nodes with dependencies to those nodes are the second set of nodes in the EXECUTION GRAPH, and so on. The automation platform of the present invention creates service instances corresponding to the service interfaces inserted in the definition of the composite and identified by the next set of non-dependent nodes of the EXECUTION GRAPH. After preparing the input data for those service instances (based on the expression of mapping stored within the composite service implementations), the automation platform stores the corresponding service instances in the INVOCATION MAP to be used when preparing the inputs of the next set of nodes. The automation platform then invokes the prepared services, using a unique key associated with the invocation of each service, for the purpose of recovery from an unknown state. Herein, we will refer to the invocation of each set of prepared services as a HYPERCYCLE. Referring to as an example, the method of the present invention accommodates the automatic multi-threaded invocation of contained services that have no unresolved dependencies to each other. As depicted in , Services-A, B, C have no dependencies to each other and only depend on the inputs of the parent composite service. Therefore, after the transfer of data from the inputs of the parent service, based on the mapping expression stored at the design-time, all three services may be invoked in parallel and in separate threads of execution. However, Service-D, belonging to the next HYPERCYCLE due its dependencies, can only start executing when all three services from the previous HYPERCYCLE have finished execution. Similarly, Services-E, F, G can only start execution, as part of the third HYPERCYCLE, after Service-D has finished execution and the automation platform has transferred data, if any, from Service-D's outputs to the inputs of the Services-E, F, G. is an example metadata representation of the EXECUTION GRAPH and HYPERCYCLES of ","After processing each set of services, optionally in parallel, and using separate threads of execution, the inputs of those services can be garbage collected (i.e., eliminated from the memory). Furthermore, each service whose end-life-cycle is reached (determined by the EXECUTION GRAPH based on a state of no remaining dependencies) can be eliminated from the INVOCATION MAP and garbage collected.","To accommodate the transparent distribution of an INVOCATION MAP object, methods are added to the INVOCATION MAP for serialization and de-serialization of its entire state after, or between, each discrete step of execution that involves the invocation of the next set of non-dependent services. The serialized state contains the complete state of each executed service (that has not been garbage collected), including: the state of execution such as the last executed HYPERCYCLE, the last iteration (in case looping was enabled), a cursor to the next set of services, the success and failure of service execution, and other information concerning the exact state of execution. One benefit of transparent distribution of the INVOCATION MAP is in the ability to construct a remote debugger for composite services implemented based on the method of the present invention.","Based on the method of the present invention, a visual semantic-based debugger is provided for the interactive and step-by step invocation of a composite service and the child services within the composite service whereby the semantic equivalent of all functionality usual to debugging tools for programming languages, including, but not limited to, insertion, deletion of break points, inspection of the data values contained in variables, stepping into functions, stepping out of functions, running to the end of a function, and other such functionality is provided. Furthermore, through the nesting of INVOCATION MAPs, related to each contained composite service, the method of the present invention accommodates the ability to step into any nested composite service contained within another composite service from within the semantic-based debugger. Referring to  as an example, a composite service is running within a semantic-based debugger. The first HYPERCYCLE containing the service GetFiles and a decision construct with four branches has already executed. The visual debugger in  shows that the GetFiles service executed successfully and the inputs passed to the service are being modified\/evaluated by the user.  attempts to document some of the functionality provided by the semantic-based debugger that can be constructed based on the method of the present invention. The ability to inspect\/view and modify the inputs\/outputs of the invoked services, to reinvoke from the point of modification, and to transfer data to the inputs of a child service without invoking that service are other functions that are easily incorporated within the present invention. Furthermore, the ability to set a break-point to stop the execution in a batch execution mode of a composite service, based on the integer position of an input component (the \u201cnth\u201d input component), is incorporated within the visual debugger. For example, if a CreateSalesOrder service is invoked with four Sales Order components as its input, the debugger can be used to set a break-point on the third component, stop at the beginning of that component and then execute the component when the user selects the appropriate debugger method (e.g., step-over, step-into).","The method of the present invention provides a way for synchronizing the execution of multiple instances of a composite service. The method of synchronization involves the association of an attribute to a composite service interface definition indicating whether simultaneous requests for the service should or should not be serialized (i.e., synchronized). At runtime, the system uses the unique object associated with the definition of the composite service, whose instances are to be synchronized, as the basis to serialize the execution of all of the concurrent requests for running the instances of that composite service. Referring to  as an example, an IncrementCounter service is depicted that contains two child services and is declared to serialize simultaneous instances of the parent service. The first service gets the value of the counter and the second service adds one to the output value of the first service and sets the incremented value as the new value of the counter. In this way, the increment counter operation becomes an atomic operation whose correctness is guaranteed through the method of the present invention. Furthermore, a method is provided for the granular synchronization of services in order to preserve the scalability of the applications built using the method of the present invention. According to this method, at design-time the user can graphically select one or more data paths from the inputs of the composite service that needs to be synchronized. Also, the user can specify whether the synchronization should span instances of more than one composite definition by selecting a common resource, such as a shared memory structure, for synchronization. At runtime, the automated runtime platform of this invention creates a string object that is a concatenation of the actual data values stored on the input data paths and either the unique id associated with the composite interface definition (if no shared resource was selected), or a unique id associated with any resource, such as any shared memory structure. This string object is used to synchronize all the service instances that result in the same string object.","One embodiment of the method of the present invention is the visual assembly of software services and the defining\/building of a composite service implementation as depicted in . The picture demonstrates a service-oriented integrated development environment, referred to as the Hyperservice Studio, used for building composite software services from other services through a semantic-based graphical\/visual environment without requiring the writing of code. The top left pane holds all of the service interfaces and composite definitions organized within packages (folders). Icons in a project pane, optionally organized under nested folders\/packages, are each associated with a software service that is identified by a unique identifier as well as a name in the context of the containing folder. The present invention provides a method of linking services across projects and packages through simple references established using service identifiers. Furthermore, the project pane provides a visual mechanism for viewing the inputs, outputs and the definition of a service in a tree like structure and under the containing project\/folder nodes of the tree, as depicted in .","Again, referring to , the \u201cFindFiles\u201d service (the parent composite) is explored in the project pane. In the right desktop pane, the definition of a composite implementation, which is generally referred to as a Hyperservice model, is opened. Based on one embodiment of the method of the present invention, the Hyperservice model's input port corresponds to the input interface of the \u201cFindFiles\u201d service and is located on the left side of the visual representation of the composite definition. The execution of an instance of the \u201cFindFiles\u201d composite service starts by flowing data from the input port of the composite definition to the connected service in the first HYPERCYCLE as discussed earlier. The model's output port corresponds to the output interface of the \u201cFindFiles\u201d service and is located at the right side of the visual representation of the composite definition. On the top part of the Hyperservice model editor, a set of toolbar items provide access to modeling constructs such as the Exit\/Continue constructs, logical constructs (AND, OR, NOT), the decision construct, and an extensible set of CONFIGURABLE CONSTRUCTs (inventions discussed later in this document). The \u201cFindFiles\u201d service was defined by dragging and dropping service interfaces (such as \u201cGetFiles\u201d) from the project pane into the Hyperservice model editor and by adding decision, logical and CONFIGURABLE CONSTRUCT instances from the tool bar. Lines can be connected between the success\/failure\/activation ports of services, constructs, and the inputs\/outputs of the composite model to indicate dependencies and the order of execution between services\/constructs. Through the connecting lines, data mapping tools can be launched to express data mapping relationships between one-to-many and many-to-one services'\/constructs' inputs and outputs. Furthermore, the present invention provides for an extensible framework for adding built-in functions to the design tools and the runtime platform with the ability to insert the available built-in functions between the data mappings by connecting the data types on the \u201cfrom-side\u201d (i.e., source) to the inputs of the built-in function and the outputs of the built-in function to the \u201cto-side\u201d of the target service. Refer to  for a documented example of inserting a built-in function between the mapping of two data elements within the mapping tool.","The definition of a composite service (i.e., Hyperservice model) may be stored as XML in a persistent repository. Each service within the Studio is assigned a universally unique identifier. A unique identifier is assigned to each service interface. The composite definition refers to each service that is inserted (i.e., dragged and dropped) into it using the unique identifier of its service interface. In this way, if the name or the packaging of a service is changed, its references within any composite definition in which it was placed remains the same.","The present invention provides a method for configuring\/defining the input\/output data structures used within a software service, referred to as \u201cCONFIGURABLE CONSTRUCTs\u201d. Furthermore, an extensible framework for the automatic runtime implementation of a CONFIGURABLE CONSTRUCT is provided. Once a CONFIGURABLE CONSTRUCT is added to the framework, it will automatically appear on the constructs toolbar of the composite service designer (i.e., Hyperservice model designer). Referring to , an instance of \u201cGet List Item\u201d CONFIGURABLE CONSTRUCT is dropped into the implementation of the \u201cGetWantedRecord\u201d model and a dependency line is connected between the child service \u201cGetWantedRecord\u201d and the \u201cGet List Item\u201d CONFIGURABLE CONSTRUCT. At first, when a mapping tool is used to define the data mapping between the outputs of \u201cGetWantedRecord\u201d and the inputs of \u201cGet List Item\u201d, in the right pane of the mapping tool, you can see that one of the inputs to \u201cGet List Item\u201d, named \u201canyList\u201d, is of configurable type. This means that the input \u201canyList\u201d can be configured to become any plural data structure. Again, referring to , the mapping tool provides one method of configuring the \u201canyList\u201d configurable type based on the outputs of the service in the left pane of the mapper which is the \u201cWantedRecords\u201d data container list of the \u201cGetWantedRecords\u201d service. The user simply connects the \u201cWantedRecords\u201d data container list to the \u201canyList\u201d input field of the CONFIGURABLE CONSTRUCT and agrees to proceed with the configuration. As a result, the \u201canyList\u201d configurable type takes the shape of the \u201cWantedRecords\u201d data container as shown in . Furthermore, the outputs of the \u201cGet List Item\u201d are automatically configured based on the inputs and the specific function of the construct, which in this case is to extract a WantedRecords item from the WantedRecords list with an index identified by the \u201citemNumber\u201d input of \u201cGet List Item\u201d. As you can see in , the output of the \u201cGet List Item\u201d configurable service is a non-plural structure otherwise corresponding to the \u201cWantedRecords\u201d data structure.","In general, the CONFIGURABLE CONSTRUCTs framework of the present invention uses a plug-in architecture, based on an application programming interface, for introducing new CONFIGURABLE CONSTRUCTs and automating the configuration of those constructs' inputs and outputs based on arbitrary connectivity of other data structures that may be optionally restricted by datatype. Furthermore, the plug-in architecture uses programming interfaces for providing the automatic implementation of the configured constructs at runtime. For example, in  the plug-in defining the behavior of \u201cGet List Item\u201d service, at runtime, extracts the wanted record whose index is identified by the \u201citemNumber\u201d input and adds the identified wanted record to its output data buffers. The design-time portion of a CONFIGURABLE CONSTRUCT service can store information on the composite definition that can be later referenced by the runtime portion of the construct. Each CONFIGURABLE CONSTRUCT, as part of an extensible tool bar, can be placed in the workspace representing the definition of a composite service and can be connected to the inputs of the parent service or to the outputs of any child service for the purpose of configuration and mapping. Referring to  as an example, other configurable data list manipulation constructs are provided such as, but not limited to: extracting an item by index from a list of items, appending items to a list, consolidating two different data lists into one, as well as getting the number of items in a list, sorting a list of data based on user defined keys, and filtering a list of data based on user defined criteria.  represents example metadata for the three list-constructs depicted in .","The present invention provides a set of configurable services, as CONFIGURABLE CONSTRUCTs, such as a calculator, data sorting, data list manipulation, text manipulation and filtration constructs. Referring to  as an example, the calculator construct provides the ability to perform mathematical and scientific operations on numerical data elements connected and flowed from parent service inputs or other child service outputs. Referring to  as an example, the text manipulation construct provides the ability to combine static text with the dynamic construction and formatting of text based on its configured service inputs. Similarly, the sort CONFIGURABLE CONSTRUCT provides the ability to sort arbitrary plural data elements transferred from inputs of the parent service or outputs of other child services.","The present invention provides a method of inter-service communication based on shared memory wherein the shared memory storage requirements and structural identity are represented by data structures similar to those used to describe service interface inputs\/outputs. An extensible framework through programming interfaces with a plug-in architecture is used in one embodiment of the present invention to define four types of shared memory: Shared Containers, Shared Arrays, Shared Vaults, and Shared Dictionaries. Each shared memory type comes with a set of access services for getting and setting data values within the corresponding shared memory instances. The extensible framework of shared memory for the present invention can be used to introduce new specialized types of shared memory. Referring to  as an example, the application developer defines a shared memory structure of type Shared Container, called the \u201cPartCounter\u201d. PartCounter contains an integer field, \u201clastPartCounter\u201d, and a date field, \u201ccreation Date\u201d. The shared memory mechanism for Shared Containers provides two services for each Shared Container that is defined: \u201cSet Data\u201d and \u201cGet Data\u201d. \u201cSet Data\u201d takes a \u201cPartCounter\u201d data structure as input and \u201cGet Data\u201d takes no input and returns a \u201cPartCounter\u201d structure as output.  shows a composite service used for incrementing the \u201clastPartCounter\u201d field of the \u201cPartCounter\u201d shared memory through its \u201cGet Data\u201d and \u201cSet Data\u201d services. The framework for shared memory services uses a mechanism that is a specialization (i.e., subclass) of the CONFIGURABLE CONSTRUCT framework to create the data access services (such as \u201cSet Data\u201d and \u201cGet Data\u201d services of the Shared Container) for each type of shared memory. When a shared memory structure of any type is added, specialized and predefined configurable services are automatically configured through the framework to take the shape of the shared memory structure on either the inputs or outputs. The shared memory mechanism provides optional persistence for shared memory data. Referring to  as another embodiment of the shared memory mechanism, a \u201cColor\u201d Shared Vault is defined by the user containing fields for RGB values and the corresponding color name. Here, the shared memory mechanism adds predefined data access services of Shared Vault, including \u201cSet Data With Key\u201d, \u201cGet Data With Key\u201d, \u201cGet All Data\u201d, \u201cRemove Data With Key\u201d, \u201cRemove All Data\u201d, and \u201cWait for Data\u201d services. The Wait construct notifies the consuming composite service when the data belonging to the specific shared memory structure has been modified (update\/set\/delete). In this way, the WAIT method provides a means for asynchronous communication across different instances of composite services wherein one service may be blocked until another service sets or modifies the data associated with a shared memory. In this case, these services are all configured automatically by the shared memory mechanism to take the Color structure as input or outputs.  shows some of these services contained in a composite service with their inputs or outputs. In a similar fashion,  depicts an example of another type of shared memory called a Shared Array. A Shared Array structure provides predefined data access services that allow order-dependent list manipulation such as \u201cAddItemFirst\u201d, \u201cAddItemLast\u201d, \u201cGetFirstItem\u201d, \u201cGetNthItem\u201d, \u201cGetLastItem\u201d, \u201cGetAllItems\u201d, \u201cRemoveFirstItem\u201d, \u201cRemoveLastItem\u201d, \u201cRemoveAllItems\u201d, and \u201cGetArraySize\u201d.  presents an example of a more specialized shared memory, referred to as Shared Dictionary, that provides methods for one-to-many and many-to-one translation of data in different forms or \u201clocales\u201d. In this example, a Shared Dictionary named \u201cMonth\u201d is defined. The standard word for each month of the year is added. In this case, the standard word is always the 2-digit representation of the Month. For each standard word, any number of alternate terms can be added, where the alternate term is identified by a unique \u201clocale\u201d for that word. In this example, \u201801\u2019 is a standard word for the Shared Dictionary named \u2018Month\u2019. Several alternate or \u201cNative\u201d forms for this standard word exist, such as \u201cJanuary\u201d, which is identified by the \u201cfullname\u201d locale, and \u201cJan\u201d, which is identified by the \u201c3-letter\u201d locale. Shared Dictionary provides predefined data access services such as \u201cTranslate to Standard\u201d, which translates a native form of a word, given the locale, to the standard form, and \u201cTranslate to Native\u201d, which translates a standard form of a word to the native form. Other data access services provide means to add, delete, or get words from the dictionary.","As mentioned earlier, the present invention provides a method of synchronization based on synchronized execution of a composite service instance. This method, as depicted in , can be used to synchronize access to shared memory structures while providing inter-service communication. Furthermore, a built-in context mechanism is provided for the shared memory that allows transactional behavior with respect to the shared memory accommodating rollback and commit behavior in the context of nested composite services. All modifications to shared memory data through the composite service are accommodated in the context of the composite service. In the case where a composite service contains another service, for each composite service a new context is created that is nested within the parent context. In this way, the modifications to the shared memory can be roll-backed or committed at the end of the execution of each composite service.","An access control mechanism for granting access of a shared memory service to some composite services and restricting access from the others is devised as part of the present invention. Here, the get\/set access to shared memory services\/methods is granted or restricted based on containment in a project or a package or directly based on a composite service by name. Referring to  for an example, a Shared Array structure named \u201cFilesSortedBySize\u201d is shown and access to the services that act on this Shared Array is granted to only some of the models (i.e., composite service definitions) within the containing project. Some Hyperservice models within some packages are only granted access to services for getting the shared data, some are granted access to services that set the shared data, and some are granted access to all of the \u201cFilesSortedBySize\u201d services.","Based on the method of the present invention, composite services are implemented\/defined by connecting interfaces of other software services, that may be composite services, to each other and optionally to a set of constructs. Furthermore, data mapping is defined based on the inputs and outputs of the interfaces. Also, the order of execution and opportunities for concurrent execution of services contained within a composite definition is automatically inferred based on the connectivity (i.e., from a dependency perspective) of services and constructs. The runtime platform of the present invention automatically instantiates actual service objects corresponding to the interfaces used within a composite definition (i.e., Hyperservice model) and as explained earlier, based on the EXECUTION GRAPH and an INVOCATION MAP object, conducts the automatic execution of a composite service. The innovative methods of the present invention provide a new paradigm for building composite software modules.","Given the hierarchical means of organizing the implementing services, the system of the present invention provides methods for visualizing the hierarchy of service composition. Referring to , on the top left portion of the figure, the implementation of a composite service is depicted. This service is implemented with four other composite services (i.e., it contains four other composite services): CreateDirectory, GetPackageToSave, GetNthSubPackage, and SaveServiceDoc. On the center and bottom right portion of , a flattened version of the composition is depicted. Here, the implementation of CreateDirectory, GetPackageToSave, and GetNthSubpackage composite services are selectively flattened to a single level of depth. Similarly, and based on this \u201chierarchical-flattening\u201d method of the present invention, the depth of flattening of composite services contained within a parent composite service can be selectively controlled by the application developer. Furthermore, based on the method of the present invention, the flattened view of a composite service's implementation can be abstracted, or \u201cunflattened\u201d. Abstracting a flattened view hides the details of the composition by replacing the details (i.e., the implementation) of a composite service with its interface.","A second method for visualizing the hierarchy of service composition is to use a hierarchical tree structure of contained (i.e., child) services, where the leaf nodes of the tree correspond to non-composite child services and the non-leaf nodes correspond to composite child services. One embodiment for this second method of visualizing the hierarchy of the composition of a composite service is depicted in . On the top-left pane of the composition tool for composite services, the user selects to \u201cexplore\u201d the implementation of a composite service (i.e., \u201cHyperservice model\u201d) named SavePackageDocs. This results in a hierarchical visualization of the service shown in the bottom-left pane of the composition tool. The right pane (i.e., the desktop area of the tool) shows the direct implementation of the selected service. The hierarchical visualization of the service depicted in the bottom-left pane demonstrates the composition of the service from the perspective of service containment in a tree structure. This method of visualization demonstrates to the application developer all the services contained within the selected service, as well as all the services contained in those services, and so on all the way to the raw material services (non-composite) services. This concept is analogous to the concept of a bill-of-materials for products in manufacturing applications.","An embodiment of a method of the present invention for encapsulating a portion of the implementation of a composite service is depicted through an example in . As presented in the top portion of the figure, the user selects an area of the implementation of a \u201cCompositeService-1A\u201d that includes two services named \u201cAtomicService-a\u201d and \u201cAtomicService-b\u201d and a chain of conditionals with two branches. After encapsulation, as depicted in the bottom portion of , the above elements in the selected area are contained in an automatically created composite service, \u201cCompositeService-2A\u201d and removed from the implementation of \u201cCompositeService-1A\u201d, while the interface of \u201cCompositeService-2A\u201d is inserted inside the implementation of the \u201cCompositeService-1A\u201d instead of the removed elements. Here, an interface for the new composite service, \u201cCompositeService-2A\u201d, is automatically created based on the unique aggregation of all the interfaces of the given subset of the services in the selected area that are to be encapsulated. Furthermore, an implementation for \u201cCompositeService-2A\u201d is automatically created containing the selected subset of the contained services. All service interface connectivity and data mapping associated with the subset of selected services is automatically remapped and correctly re-associated based on the insertion of the subset in the new automatically generated composite service (i.e., \u201cCompositeService-2A\u201d in the example).","Based on the composition method of the present invention, some of the behavior of the software services contained within a composite service implementation can be configured in the context of the containing (i.e., parent) composite service. As an example of such a context-sensitive behavior consider .  displays an implementation for the parent service \u201cGetGlobalStockQuote\u201d, where the execution results of one of its contained services, \u201cConvertToNum\u201d, is configured to be cached in the context of \u201cGetGlobalStockQuote\u201d and automatically purged every 5 minutes from the cache. The cached behavior of \u201cConvertToNum\u201d only applies to its usage within the context of \u201cGetGlobalStockQuote\u201d. Unless otherwise specified, the results of executing the \u201cConvertToNum\u201d service outside the context of \u201cGetGlobalStockQuote\u201d will not come from the cache. Other attributes related to the invocation of contained services can be configured in the context of a containing (i.e., parent) composite service. For example, whether to log the service invoked in a context of a composite can be configured in the same context-based fashion. How to automate the methods of context-sensitive configuration at runtime are obvious to a person expert in the art of software implementation.","Another aspect of the present invention is the ability to load-balance the execution of composite services, across a cluster of automation runtime platforms instances, without requiring the metadata associated with the interface and the definition of composition to be available at every server node of the cluster. To accommodate this, all methods for storing and retrieving metadata associated with the definition of interface and implementation of services are themselves implemented as services. Given this, the instance of the platform, which requests the invocation of a service by the other instances within the cluster, provides a callback address to the other instances of the platform within the cluster as part of the request. Other instances use the callback address to dynamically and on-demand gather the required metadata while the invocation of the requested service is in progress.","Another aspect of the present invention provides an automatic trigger mechanism whereby the invocation of one service automatically results in the invocation of one or more other composite services, herein referred to as TRIGGER MODELS. This mechanism provides a non-intrusive way for adding management logic without the need to modify the implementation of the services that define the application logic. In one embodiment of the present invention, referring to , a user can graphically declare a service to trigger the invocation of one or more TRIGGER MODELS. TRIGGER MODELS are specialized forms of composite definitions strictly used in association with the triggering services. The user can declare a TRIGGER MODEL to be automatically invoked: a) at the same time the associated (i.e., triggering) service is invoked, b) after the completion of the associated service, c) only after the successful completion of the associated service, or d) only after the failure of the associated service. An interface for each TRIGGER MODEL is automatically created based on the interface of the associated service wherein the input definition of the TRIGGER MODEL includes all the inputs of the associated service when the trigger is declared to be invoked at the same time as the associated service or upon the failure of the associated service. When the TRIGGER MODEL is invoked upon the completion or successful completion of the associated service, the inputs of the TRIGGER MODEL are automatically configured to include all the inputs and outputs of the associated service. Furthermore, the method of the present invention provides for the automatic instantiation and invocation of instances of the TRIGGER MODELs upon the invocation of the corresponding associated service.","Another aspect of the present invention provides a system for service-oriented, asynchronous notification of service invocation within a composite service. Referring to , the user can graphically declare a REQUEST EVENT for any software service. Each REQUEST EVENT provides a WAIT construct that is configured to provide as its outputs the input data of the software service associated with the REQUEST EVENT. The WAIT construct also takes a timeout value as an input, and a set of request keys that correlate selected inputs of the software service with a REQUEST EVENT. The WAIT construct can be dropped into any composite definition. At runtime, all instances of the composite service associated with the composite definition that contains a WAIT construct will block as the execution of each instance reaches the WAIT construct. The blocking continues until either the timeout is reached or the software service associated with the event is invoked with the specified key values. This mechanism combines the power of publish\/subscribe of the messaging paradigm in a unique service-centric fashion to provide an asynchronous mechanism for service notification. Here, the execution of any service can be viewed as an implicit publication, of an event where the invocation of a service is the event itself. The associated WAIT construct acts as a notification\/blocking mechanism and the request keys that are the inputs to the event service provide a correlation mechanism. The correlation mechanism issues notification based on correlating some actual key values from the inputs of a service with the key value that was set on the input of the WAIT construct.","Terms and Definitions","A software service, or service for short, including but not limited to a Web service, is a discrete software task that has a well-defined interface and may be accessible over the local and\/or public computer networks or may be only available on a single machine. Web services can be published, discovered, described, and accessed using standard-based protocols such as UDDI, WSDL, Simple Object Access Protocol (SOAP), and HyperText Markup Language (HTML).","A software service interface, in concept, represents the inputs and outputs of a black-boxed software service as well as the properties of that service, such as name and location. Take, for example, the interface of a simple software service named GetStockQuote, which retrieves simple stock quote information []. This service takes a ticker symbol input and returns the last trade price amount as well as some additional stock quote details, such as the day high and day low. Note that in order to use, or consume, a service, only knowledge of its interface is required. This means that as long as the interface of a service remains the same, different implementations of the service can be swapped in and out without affecting its consumers. This, as well as the fact that a service is a language- and platform-neutral concept, is one of the keys to the flexibility of service-oriented architectures.","An atomic service is a software service that is implemented directly by a segment of software code. In the existing NextAxiom\u2122 HyperService\u2122 Platform, atomic Web services are dispatched via a library. A library is a light, language- and platform-neutral wrapper that is linked to one or more atomic Web service implementations. Atomic Web services are logically indivisible Web services that represent \u201craw materials\u201d to the HyperService\u2122 platform.","A composite service is a software service that consumes any number of other atomic or composite services. In the HyperService\u2122 platform, a composite Web service is implemented with a metadata-driven model that is automatically interpreted by a high-performance runtime engine.","Visual metadata models, which represent composite software services implementations to the HyperService\u2122 system, are created in a graphical, design-time environment and stored as XML models. This environment offers a new and powerful visual modeling paradigm that can be leveraged to enable the visual modeling of transactional behavior. This environment was specifically designed to enable collaborative, on-the-fly creation of software services by business process analysts or functional experts, who understand the business logic and application required to implement real-world business processes and applications, but have no knowledge of programming paradigms or Web service protocols.  captures the implementation of a composite software service named \u201cExpedite 3000 Series\u201d. This service is used by a master planner to expedite 3000-series inventory items when they fall short on the shop floor. This service was developed collaboratively and reuses services that were selectively exposed by the Inventory and Purchasing departments to the developers of this service.","Any software service that is consumed by a composite service model is said to be \u201cnested\u201d or \u201cembedded\u201d within that composite service.  depicts a hypothetical composite service that resides in Chicago. This software service is composed of other composite services that are distributed across the country."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objectives and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 6","i":"a "},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 6","FIG. 6"],"i":["b","i","a "]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 6","FIG. 6"],"i":["b","ii","a "]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 7","i":"a "},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 7","FIG. 7"],"i":["b","i","a "]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 7","FIG. 7"],"i":["b","ii","a "]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 8","i":"a "},{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 8","FIG. 8"],"i":["b","i","a "]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 8","FIG. 8"],"i":["b","ii","a "]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 9","i":"a "},{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 9","FIG. 9"],"i":["b","i","a "]},{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 9","FIG. 9"],"i":["b","ii","a "]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 10","i":"a "},{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 10","FIG. 10"],"i":["b","i","a "]},{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 10","FIG. 10"],"i":["b","ii","a "]},{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 10","FIG. 10"],"i":["b","iii","a "]},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 11","i":"a "},{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 11","FIG. 11"],"i":["b","i","a "]},{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 11","FIG. 11"],"i":["b","ii","a "]},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 11","i":"c "},{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 11","FIG. 11"],"i":["d","i","c "]},{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 11","FIG. 11"],"i":["d","ii","c "]},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 12","i":"a "},{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 12","FIG. 12"],"i":["b","i","a "]},{"@attributes":{"id":"p-0065","num":"0064"},"figref":["FIG. 12","FIG. 12"],"i":["b","ii","a "]},{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 12","FIG. 12"],"i":["b","iii","a "]},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 12","i":"c "},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 13","i":"a "},{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 13","FIG. 13"],"i":["b ","a "]},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 21","i":"a "},{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 21","i":"b "},{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 21","i":"c "},{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 32"}]},"DETDESC":[{},{}]}
